; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\dns.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\dns.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\ZR60_v1.0_freeRTOS -I..\..\Lwip\App -I..\..\Lwip\Bsp -I..\..\Lwip\Bsp\LAN8742A -I..\..\Lwip\lwip-1.4.1 -I..\..\Lwip\lwip-1.4.1\port -I..\..\Lwip\lwip-1.4.1\port\arch -I..\..\Lwip\lwip-1.4.1\port\Standalone -I..\..\Lwip\lwip-1.4.1\src\include -I..\..\Lwip\lwip-1.4.1\src\include\ipv4 -I..\..\Lwip\lwip-1.4.1\src\include\lwip -I..\..\Lwip\lwip-1.4.1\src\include\netif -I..\..\Ecal\BtnFltr -I..\..\Ecal\UartComn -I..\..\Ecal\MemIf -I..\..\APP -I..\..\APP\BlackListMng -I..\..\APP\SeverNewsPush -I..\..\APP\NewsPull -I..\..\Ecal -I..\..\Ecal\JsonIf -I..\..\Ecal\Mcu_Init -I..\..\Service -I..\..\Complex -I..\..\Complex\FATFS -I..\..\FreeRTOS\Source\include -I..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\FreeRTOS -I.\RTE\_ZR60 -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=..\..\output\dns.crf ..\..\Lwip\lwip-1.4.1\src\core\dns.c]
                          THUMB

                          AREA ||i.dns_check_entry||, CODE, READONLY, ALIGN=2

                  dns_check_entry PROC
;;;635    static void
;;;636    dns_check_entry(u8_t i)
000000  b570              PUSH     {r4-r6,lr}
;;;637    {
000002  4605              MOV      r5,r0
;;;638      err_t err;
;;;639      struct dns_table_entry *pEntry = &dns_table[i];
000004  ebc000c5          RSB      r0,r0,r5,LSL #3
000008  492e              LDR      r1,|L1.196|
00000a  eb000080          ADD      r0,r0,r0,LSL #2
00000e  eb0104c0          ADD      r4,r1,r0,LSL #3
;;;640    
;;;641      LWIP_ASSERT("array index out of bounds", i < DNS_TABLE_SIZE);
000012  2d0a              CMP      r5,#0xa
000014  d302              BCC      |L1.28|
000016  a02c              ADR      r0,|L1.200|
000018  f7fffffe          BL       __2printf
                  |L1.28|
;;;642    
;;;643      switch(pEntry->state) {
00001c  7820              LDRB     r0,[r4,#0]
00001e  2800              CMP      r0,#0
000020  d03e              BEQ      |L1.160|
000022  ebc501c5          RSB      r1,r5,r5,LSL #3       ;639
000026  4b27              LDR      r3,|L1.196|
000028  eb010181          ADD      r1,r1,r1,LSL #2       ;639
00002c  eb0303c1          ADD      r3,r3,r1,LSL #3       ;639
000030  2600              MOVS     r6,#0
000032  2201              MOVS     r2,#1
000034  330c              ADDS     r3,r3,#0xc            ;639
000036  2801              CMP      r0,#1
000038  d008              BEQ      |L1.76|
00003a  2802              CMP      r0,#2
00003c  d00d              BEQ      |L1.90|
00003e  2803              CMP      r0,#3
000040  d03b              BEQ      |L1.186|
;;;644    
;;;645        case DNS_STATE_NEW: {
;;;646          /* initialize new entry */
;;;647          pEntry->state   = DNS_STATE_ASKING;
;;;648          pEntry->numdns  = 0;
;;;649          pEntry->tmr     = 1;
;;;650          pEntry->retries = 0;
;;;651          
;;;652          /* send DNS packet for this entry */
;;;653          err = dns_send(pEntry->numdns, pEntry->name, i);
;;;654          if (err != ERR_OK) {
;;;655            LWIP_DEBUGF(DNS_DEBUG | LWIP_DBG_LEVEL_WARNING,
;;;656                        ("dns_send returned error: %s\n", lwip_strerr(err)));
;;;657          }
;;;658          break;
;;;659        }
;;;660    
;;;661        case DNS_STATE_ASKING: {
;;;662          if (--pEntry->tmr == 0) {
;;;663            if (++pEntry->retries == DNS_MAX_RETRIES) {
;;;664              if ((pEntry->numdns+1<DNS_MAX_SERVERS) && !ip_addr_isany(&dns_servers[pEntry->numdns+1])) {
;;;665                /* change of server */
;;;666                pEntry->numdns++;
;;;667                pEntry->tmr     = 1;
;;;668                pEntry->retries = 0;
;;;669                break;
;;;670              } else {
;;;671                LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": timeout\n", pEntry->name));
;;;672                /* call specified callback function if provided */
;;;673                if (pEntry->found)
;;;674                  (*pEntry->found)(pEntry->name, NULL, pEntry->arg);
;;;675                /* flush this entry */
;;;676                pEntry->state   = DNS_STATE_UNUSED;
;;;677                pEntry->found   = NULL;
;;;678                break;
;;;679              }
;;;680            }
;;;681    
;;;682            /* wait longer for the next retry */
;;;683            pEntry->tmr = pEntry->retries;
;;;684    
;;;685            /* send DNS packet for this entry */
;;;686            err = dns_send(pEntry->numdns, pEntry->name, i);
;;;687            if (err != ERR_OK) {
;;;688              LWIP_DEBUGF(DNS_DEBUG | LWIP_DBG_LEVEL_WARNING,
;;;689                          ("dns_send returned error: %s\n", lwip_strerr(err)));
;;;690            }
;;;691          }
;;;692          break;
;;;693        }
;;;694    
;;;695        case DNS_STATE_DONE: {
;;;696          /* if the time to live is nul */
;;;697          if (--pEntry->ttl == 0) {
;;;698            LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": flush\n", pEntry->name));
;;;699            /* flush this entry */
;;;700            pEntry->state = DNS_STATE_UNUSED;
;;;701            pEntry->found = NULL;
;;;702          }
;;;703          break;
;;;704        }
;;;705        case DNS_STATE_UNUSED:
;;;706          /* nothing to do */
;;;707          break;
;;;708        default:
;;;709          LWIP_ASSERT("unknown dns_table entry state:", 0);
000042  e8bd4070          POP      {r4-r6,lr}
000046  a027              ADR      r0,|L1.228|
000048  f7ffbffe          B.W      __2printf
                  |L1.76|
00004c  2002              MOVS     r0,#2                 ;647
00004e  7020              STRB     r0,[r4,#0]            ;647
000050  7066              STRB     r6,[r4,#1]            ;648
000052  70a2              STRB     r2,[r4,#2]            ;649
000054  4630              MOV      r0,r6                 ;648
000056  70e6              STRB     r6,[r4,#3]            ;650
000058  e00d              B        |L1.118|
                  |L1.90|
00005a  78a0              LDRB     r0,[r4,#2]            ;662
00005c  1e40              SUBS     r0,r0,#1              ;662
00005e  f01000ff          ANDS     r0,r0,#0xff           ;662
000062  70a0              STRB     r0,[r4,#2]            ;662
000064  d11c              BNE      |L1.160|
000066  78e0              LDRB     r0,[r4,#3]            ;663
000068  1c40              ADDS     r0,r0,#1              ;663
00006a  b2c0              UXTB     r0,r0                 ;663
00006c  70e0              STRB     r0,[r4,#3]            ;663
00006e  2804              CMP      r0,#4                 ;663
000070  d007              BEQ      |L1.130|
000072  70a0              STRB     r0,[r4,#2]            ;683
000074  7860              LDRB     r0,[r4,#1]            ;686
                  |L1.118|
000076  462a              MOV      r2,r5                 ;686
000078  e8bd4070          POP      {r4-r6,lr}            ;686
00007c  4619              MOV      r1,r3                 ;686
00007e  f7ffbffe          B.W      dns_send
                  |L1.130|
000082  7860              LDRB     r0,[r4,#1]            ;664
000084  4601              MOV      r1,r0                 ;664
000086  1c40              ADDS     r0,r0,#1              ;664
000088  2802              CMP      r0,#2                 ;664
00008a  d20a              BCS      |L1.162|
00008c  4d1d              LDR      r5,|L1.260|
00008e  eb050181          ADD      r1,r5,r1,LSL #2       ;664
000092  1d0d              ADDS     r5,r1,#4              ;664
000094  d005              BEQ      |L1.162|
000096  6849              LDR      r1,[r1,#4]            ;664
000098  b119              CBZ      r1,|L1.162|
00009a  7060              STRB     r0,[r4,#1]            ;666
00009c  70a2              STRB     r2,[r4,#2]            ;667
00009e  70e6              STRB     r6,[r4,#3]            ;668
                  |L1.160|
;;;710          break;
;;;711      }
;;;712    }
0000a0  bd70              POP      {r4-r6,pc}
                  |L1.162|
0000a2  f8d45110          LDR      r5,[r4,#0x110]        ;673
0000a6  b125              CBZ      r5,|L1.178|
0000a8  2100              MOVS     r1,#0                 ;674
0000aa  4618              MOV      r0,r3                 ;674
0000ac  f8d42114          LDR      r2,[r4,#0x114]        ;674
0000b0  47a8              BLX      r5                    ;674
                  |L1.178|
0000b2  7026              STRB     r6,[r4,#0]            ;676
0000b4  f8c46110          STR      r6,[r4,#0x110]        ;678
0000b8  bd70              POP      {r4-r6,pc}
                  |L1.186|
0000ba  68a0              LDR      r0,[r4,#8]            ;697
0000bc  1e40              SUBS     r0,r0,#1              ;697
0000be  60a0              STR      r0,[r4,#8]            ;697
0000c0  d0f7              BEQ      |L1.178|
0000c2  bd70              POP      {r4-r6,pc}
;;;713    
                          ENDP

                  |L1.196|
                          DCD      ||.bss||
                  |L1.200|
0000c8  61727261          DCB      "array index out of bounds",0
0000cc  7920696e
0000d0  64657820
0000d4  6f757420
0000d8  6f662062
0000dc  6f756e64
0000e0  7300    
0000e2  00                DCB      0
0000e3  00                DCB      0
                  |L1.228|
0000e4  756e6b6e          DCB      "unknown dns_table entry state:",0
0000e8  6f776e20
0000ec  646e735f
0000f0  7461626c
0000f4  6520656e
0000f8  74727920
0000fc  73746174
000100  653a00  
000103  00                DCB      0
                  |L1.260|
                          DCD      ||.data||+0xc

                          AREA ||i.dns_enqueue||, CODE, READONLY, ALIGN=2

                  dns_enqueue PROC
;;;859    static err_t
;;;860    dns_enqueue(const char *name, dns_found_callback found, void *callback_arg)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;861    {
;;;862      u8_t i;
;;;863      u8_t lseq, lseqi;
;;;864      struct dns_table_entry *pEntry = NULL;
;;;865      size_t namelen;
;;;866    
;;;867      /* search an unused entry, or the oldest one */
;;;868      lseq = lseqi = 0;
;;;869      for (i = 0; i < DNS_TABLE_SIZE; ++i) {
;;;870        pEntry = &dns_table[i];
;;;871        /* is it an unused entry ? */
;;;872        if (pEntry->state == DNS_STATE_UNUSED)
;;;873          break;
;;;874    
;;;875        /* check if this is the oldest completed entry */
;;;876        if (pEntry->state == DNS_STATE_DONE) {
;;;877          if ((dns_seqno - pEntry->seqno) > lseq) {
000004  f8dfc0a4          LDR      r12,|L2.172|
000008  4681              MOV      r9,r0                 ;861
00000a  2000              MOVS     r0,#0                 ;868
00000c  4f28              LDR      r7,|L2.176|
00000e  f89c3000          LDRB     r3,[r12,#0]
000012  4690              MOV      r8,r2                 ;861
000014  4606              MOV      r6,r0                 ;868
000016  4605              MOV      r5,r0                 ;869
                  |L2.24|
000018  ebc502c5          RSB      r2,r5,r5,LSL #3       ;870
00001c  eb020282          ADD      r2,r2,r2,LSL #2       ;870
000020  eb0704c2          ADD      r4,r7,r2,LSL #3       ;870
000024  7822              LDRB     r2,[r4,#0]            ;872
000026  b15a              CBZ      r2,|L2.64|
000028  2a03              CMP      r2,#3                 ;876
00002a  d105              BNE      |L2.56|
00002c  7922              LDRB     r2,[r4,#4]
00002e  1a9a              SUBS     r2,r3,r2
000030  42b2              CMP      r2,r6
000032  dd01              BLE      |L2.56|
;;;878            lseq = dns_seqno - pEntry->seqno;
000034  b2d6              UXTB     r6,r2
;;;879            lseqi = i;
000036  4628              MOV      r0,r5
                  |L2.56|
000038  1c6d              ADDS     r5,r5,#1
00003a  b2ed              UXTB     r5,r5                 ;869
00003c  2d0a              CMP      r5,#0xa               ;869
00003e  d3eb              BCC      |L2.24|
                  |L2.64|
;;;880          }
;;;881        }
;;;882      }
;;;883    
;;;884      /* if we don't have found an unused entry, use the oldest completed one */
;;;885      if (i == DNS_TABLE_SIZE) {
000040  2d0a              CMP      r5,#0xa
000042  d110              BNE      |L2.102|
;;;886        if ((lseqi >= DNS_TABLE_SIZE) || (dns_table[lseqi].state != DNS_STATE_DONE)) {
000044  280a              CMP      r0,#0xa
000046  d207              BCS      |L2.88|
000048  ebc002c0          RSB      r2,r0,r0,LSL #3
00004c  eb020282          ADD      r2,r2,r2,LSL #2
000050  f8174032          LDRB     r4,[r7,r2,LSL #3]
000054  2c03              CMP      r4,#3
000056  d003              BEQ      |L2.96|
                  |L2.88|
;;;887          /* no entry can't be used now, table is full */
;;;888          LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": DNS entries table is full\n", name));
;;;889          return ERR_MEM;
000058  f04f30ff          MOV      r0,#0xffffffff
                  |L2.92|
;;;890        } else {
;;;891          /* use the oldest completed one */
;;;892          i = lseqi;
;;;893          pEntry = &dns_table[i];
;;;894        }
;;;895      }
;;;896    
;;;897      /* use this entry */
;;;898      LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": use DNS entry %"U16_F"\n", name, (u16_t)(i)));
;;;899    
;;;900      /* fill the entry */
;;;901      pEntry->state = DNS_STATE_NEW;
;;;902      pEntry->seqno = dns_seqno++;
;;;903      pEntry->found = found;
;;;904      pEntry->arg   = callback_arg;
;;;905      namelen = LWIP_MIN(strlen(name), DNS_MAX_NAME_LENGTH-1);
;;;906      MEMCPY(pEntry->name, name, namelen);
;;;907      pEntry->name[namelen] = 0;
;;;908    
;;;909      /* force to send query without waiting timer */
;;;910      dns_check_entry(i);
;;;911    
;;;912      /* dns query is enqueued */
;;;913      return ERR_INPROGRESS;
;;;914    }
00005c  e8bd87f0          POP      {r4-r10,pc}
                  |L2.96|
000060  4605              MOV      r5,r0                 ;892
000062  eb0704c2          ADD      r4,r7,r2,LSL #3       ;893
                  |L2.102|
000066  2001              MOVS     r0,#1                 ;901
000068  7020              STRB     r0,[r4,#0]            ;901
00006a  7123              STRB     r3,[r4,#4]            ;902
00006c  1c5b              ADDS     r3,r3,#1              ;902
00006e  f88c3000          STRB     r3,[r12,#0]           ;902
000072  e9c41844          STRD     r1,r8,[r4,#0x110]     ;905
000076  4648              MOV      r0,r9                 ;905
000078  f7fffffe          BL       strlen
00007c  28ff              CMP      r0,#0xff              ;905
00007e  d203              BCS      |L2.136|
000080  4648              MOV      r0,r9                 ;905
000082  f7fffffe          BL       strlen
000086  e000              B        |L2.138|
                  |L2.136|
000088  20ff              MOVS     r0,#0xff              ;905
                  |L2.138|
00008a  4606              MOV      r6,r0                 ;905
00008c  4602              MOV      r2,r0                 ;906
00008e  4649              MOV      r1,r9                 ;906
000090  f104000c          ADD      r0,r4,#0xc            ;906
000094  f7fffffe          BL       __aeabi_memcpy
000098  19a1              ADDS     r1,r4,r6              ;907
00009a  2000              MOVS     r0,#0                 ;907
00009c  7308              STRB     r0,[r1,#0xc]          ;907
00009e  4628              MOV      r0,r5                 ;910
0000a0  f7fffffe          BL       dns_check_entry
0000a4  f06f0004          MVN      r0,#4                 ;913
0000a8  e7d8              B        |L2.92|
;;;915    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L2.172|
                          DCD      ||.data||
                  |L2.176|
                          DCD      ||.bss||

                          AREA ||i.dns_gethostbyname||, CODE, READONLY, ALIGN=2

                  dns_gethostbyname PROC
;;;935    err_t
;;;936    dns_gethostbyname(const char *hostname, ip_addr_t *addr, dns_found_callback found,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;937                      void *callback_arg)
;;;938    {
000004  4605              MOV      r5,r0
;;;939      u32_t ipaddr;
;;;940      /* not initialized or no valid server yet, or invalid addr pointer
;;;941       * or invalid hostname or invalid hostname length */
;;;942      if ((dns_pcb == NULL) || (addr == NULL) ||
000006  4822              LDR      r0,|L3.144|
000008  4698              MOV      r8,r3                 ;938
00000a  4691              MOV      r9,r2                 ;938
00000c  6840              LDR      r0,[r0,#4]  ; dns_pcb
00000e  460f              MOV      r7,r1                 ;938
000010  b140              CBZ      r0,|L3.36|
000012  b13f              CBZ      r7,|L3.36|
;;;943          (!hostname) || (!hostname[0]) ||
000014  b135              CBZ      r5,|L3.36|
000016  7828              LDRB     r0,[r5,#0]
000018  b120              CBZ      r0,|L3.36|
;;;944          (strlen(hostname) >= DNS_MAX_NAME_LENGTH)) {
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       strlen
000020  28ff              CMP      r0,#0xff
000022  d903              BLS      |L3.44|
                  |L3.36|
;;;945        return ERR_ARG;
000024  f06f000d          MVN      r0,#0xd
                  |L3.40|
;;;946      }
;;;947    
;;;948    #if LWIP_HAVE_LOOPIF
;;;949      if (strcmp(hostname, "localhost")==0) {
;;;950        ip_addr_set_loopback(addr);
;;;951        return ERR_OK;
;;;952      }
;;;953    #endif /* LWIP_HAVE_LOOPIF */
;;;954    
;;;955      /* host name already in octet notation? set ip addr and return ERR_OK */
;;;956      ipaddr = ipaddr_addr(hostname);
;;;957      if (ipaddr == IPADDR_NONE) {
;;;958        /* already have this address cached? */
;;;959        ipaddr = dns_lookup(hostname);
;;;960      }
;;;961      if (ipaddr != IPADDR_NONE) {
;;;962        ip4_addr_set_u32(addr, ipaddr);
;;;963        return ERR_OK;
;;;964      }
;;;965    
;;;966      /* queue query with specified callback */
;;;967      return dns_enqueue(hostname, found, callback_arg);
;;;968    }
000028  e8bd87f0          POP      {r4-r10,pc}
                  |L3.44|
00002c  4628              MOV      r0,r5                 ;956
00002e  f7fffffe          BL       ipaddr_addr
000032  1c41              ADDS     r1,r0,#1              ;957
000034  d118              BNE      |L3.104|
000036  4e17              LDR      r6,|L3.148|
000038  2400              MOVS     r4,#0                 ;957
                  |L3.58|
00003a  ebc400c4          RSB      r0,r4,r4,LSL #3       ;957
00003e  eb000080          ADD      r0,r0,r0,LSL #2       ;957
000042  f8161030          LDRB     r1,[r6,r0,LSL #3]     ;957
000046  2903              CMP      r1,#3                 ;957
000048  d106              BNE      |L3.88|
00004a  eb0601c0          ADD      r1,r6,r0,LSL #3       ;957
00004e  4628              MOV      r0,r5                 ;957
000050  310c              ADDS     r1,r1,#0xc            ;957
000052  f7fffffe          BL       strcmp
000056  b150              CBZ      r0,|L3.110|
                  |L3.88|
000058  1c64              ADDS     r4,r4,#1              ;957
00005a  b2e4              UXTB     r4,r4                 ;957
00005c  2c0a              CMP      r4,#0xa               ;957
00005e  d3ec              BCC      |L3.58|
000060  f04f30ff          MOV      r0,#0xffffffff        ;957
                  |L3.100|
000064  1c41              ADDS     r1,r0,#1              ;961
000066  d00b              BEQ      |L3.128|
                  |L3.104|
000068  6038              STR      r0,[r7,#0]            ;963
00006a  2000              MOVS     r0,#0                 ;963
00006c  e7dc              B        |L3.40|
                  |L3.110|
00006e  ebc400c4          RSB      r0,r4,r4,LSL #3
000072  eb000080          ADD      r0,r0,r0,LSL #2
000076  eb0600c0          ADD      r0,r6,r0,LSL #3
00007a  f8d0010c          LDR      r0,[r0,#0x10c]
00007e  e7f1              B        |L3.100|
                  |L3.128|
000080  4642              MOV      r2,r8                 ;967
000082  4649              MOV      r1,r9                 ;967
000084  4628              MOV      r0,r5                 ;967
000086  e8bd47f0          POP      {r4-r10,lr}           ;967
00008a  f7ffbffe          B.W      dns_enqueue
;;;969    
                          ENDP

00008e  0000              DCW      0x0000
                  |L3.144|
                          DCD      ||.data||
                  |L3.148|
                          DCD      ||.bss||

                          AREA ||i.dns_getserver||, CODE, READONLY, ALIGN=2

                  dns_getserver PROC
;;;288    ip_addr_t
;;;289    dns_getserver(u8_t numdns)
000000  2802              CMP      r0,#2
;;;290    {
000002  d203              BCS      |L4.12|
;;;291      if (numdns < DNS_MAX_SERVERS) {
;;;292        return dns_servers[numdns];
000004  4903              LDR      r1,|L4.20|
000006  eb010080          ADD      r0,r1,r0,LSL #2
00000a  e000              B        |L4.14|
                  |L4.12|
;;;293      } else {
;;;294        return *IP_ADDR_ANY;
00000c  4802              LDR      r0,|L4.24|
                  |L4.14|
00000e  6800              LDR      r0,[r0,#0]  ; ip_addr_any
;;;295      }
;;;296    }
000010  4770              BX       lr
;;;297    
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      ||.data||+0xc
                  |L4.24|
                          DCD      ip_addr_any

                          AREA ||i.dns_init||, CODE, READONLY, ALIGN=2

                  dns_init PROC
;;;231    void
;;;232    dns_init()
000000  b538              PUSH     {r3-r5,lr}
;;;233    {
;;;234      ip_addr_t dnsserver;
;;;235    
;;;236      dns_payload = (u8_t *)LWIP_MEM_ALIGN(dns_payload_buffer);
000002  480f              LDR      r0,|L5.64|
000004  4c0f              LDR      r4,|L5.68|
000006  f0200003          BIC      r0,r0,#3
;;;237      
;;;238      /* initialize default DNS server address */
;;;239      DNS_SERVER_ADDRESS(&dnsserver);
00000a  60a0              STR      r0,[r4,#8]  ; dns_payload
00000c  a00e              ADR      r0,|L5.72|
00000e  f7fffffe          BL       ipaddr_addr
;;;240    
;;;241      LWIP_DEBUGF(DNS_DEBUG, ("dns_init: initializing\n"));
;;;242    
;;;243      /* if dns client not yet initialized... */
;;;244      if (dns_pcb == NULL) {
000012  9000              STR      r0,[sp,#0]
000014  6860              LDR      r0,[r4,#4]  ; dns_pcb
000016  2800              CMP      r0,#0
000018  d111              BNE      |L5.62|
;;;245        dns_pcb = udp_new();
00001a  f7fffffe          BL       udp_new
;;;246    
;;;247        if (dns_pcb != NULL) {
00001e  6060              STR      r0,[r4,#4]  ; dns_pcb
000020  2800              CMP      r0,#0
000022  d00c              BEQ      |L5.62|
;;;248          /* initialize DNS table not needed (initialized to zero since it is a
;;;249           * global variable) */
;;;250          LWIP_ASSERT("For implicit initialization to work, DNS_STATE_UNUSED needs to be 0",
;;;251            DNS_STATE_UNUSED == 0);
;;;252    
;;;253          /* initialize DNS client */
;;;254          udp_bind(dns_pcb, IP_ADDR_ANY, 0);
000024  2200              MOVS     r2,#0
000026  490c              LDR      r1,|L5.88|
000028  f7fffffe          BL       udp_bind
;;;255          udp_recv(dns_pcb, dns_recv, NULL);
00002c  2200              MOVS     r2,#0
00002e  490b              LDR      r1,|L5.92|
000030  6860              LDR      r0,[r4,#4]  ; dns_pcb
000032  f7fffffe          BL       udp_recv
;;;256    
;;;257          /* initialize default DNS primary server */
;;;258          dns_setserver(0, &dnsserver);
000036  4669              MOV      r1,sp
000038  2000              MOVS     r0,#0
00003a  f7fffffe          BL       dns_setserver
                  |L5.62|
;;;259        }
;;;260      }
;;;261    #if DNS_LOCAL_HOSTLIST
;;;262      dns_init_local();
;;;263    #endif
;;;264    }
00003e  bd38              POP      {r3-r5,pc}
;;;265    
                          ENDP

                  |L5.64|
                          DCD      ||.bss||+0xaf3
                  |L5.68|
                          DCD      ||.data||
                  |L5.72|
000048  3230382e          DCB      "208.67.222.222",0
00004c  36372e32
000050  32322e32
000054  323200  
000057  00                DCB      0
                  |L5.88|
                          DCD      ip_addr_any
                  |L5.92|
                          DCD      dns_recv

                          AREA ||i.dns_parse_name||, CODE, READONLY, ALIGN=1

                  dns_parse_name PROC
;;;527    static unsigned char *
;;;528    dns_parse_name(unsigned char *query)
000000  2203              MOVS     r2,#3
                  |L6.2|
;;;529    {
;;;530      unsigned char n;
;;;531    
;;;532      do {
;;;533        n = *query++;
000002  f8101b01          LDRB     r1,[r0],#1
;;;534        /** @see RFC 1035 - 4.1.4. Message compression */
;;;535        if ((n & 0xc0) == 0xc0) {
000006  ebb21f91          CMP      r2,r1,LSR #6
00000a  d008              BEQ      |L6.30|
00000c  e002              B        |L6.20|
                  |L6.14|
00000e  1e49              SUBS     r1,r1,#1
;;;536          /* Compressed name */
;;;537          break;
;;;538        } else {
;;;539          /* Not compressed name */
;;;540          while (n > 0) {
;;;541            ++query;
;;;542            --n;
000010  b2c9              UXTB     r1,r1
000012  1c40              ADDS     r0,r0,#1
                  |L6.20|
000014  2900              CMP      r1,#0                 ;540
000016  d1fa              BNE      |L6.14|
;;;543          };
;;;544        }
;;;545      } while (*query != 0);
000018  7801              LDRB     r1,[r0,#0]
00001a  2900              CMP      r1,#0
00001c  d1f1              BNE      |L6.2|
                  |L6.30|
00001e  1c40              ADDS     r0,r0,#1
;;;546    
;;;547      return query + 1;
;;;548    }
000020  4770              BX       lr
;;;549    
                          ENDP


                          AREA ||i.dns_recv||, CODE, READONLY, ALIGN=2

                  dns_recv PROC
;;;732    static void
;;;733    dns_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *addr, u16_t port)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;734    {
000004  4616              MOV      r6,r2
;;;735      u16_t i;
;;;736      char *pHostname;
;;;737      struct dns_hdr *hdr;
;;;738      struct dns_answer ans;
;;;739      struct dns_table_entry *pEntry;
;;;740      u16_t nquestions, nanswers;
;;;741    
;;;742      LWIP_UNUSED_ARG(arg);
;;;743      LWIP_UNUSED_ARG(pcb);
;;;744      LWIP_UNUSED_ARG(addr);
;;;745      LWIP_UNUSED_ARG(port);
;;;746    
;;;747      /* is the dns message too big ? */
;;;748      if (p->tot_len > DNS_MSG_SIZE) {
000006  8912              LDRH     r2,[r2,#8]
000008  f5b27f00          CMP      r2,#0x200
00000c  d870              BHI      |L7.240|
;;;749        LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: pbuf too big\n"));
;;;750        /* free pbuf and return */
;;;751        goto memerr;
;;;752      }
;;;753    
;;;754      /* is the dns message big enough ? */
;;;755      if (p->tot_len < (SIZEOF_DNS_HDR + SIZEOF_DNS_QUERY + SIZEOF_DNS_ANSWER)) {
00000e  2a1a              CMP      r2,#0x1a
000010  d36e              BCC      |L7.240|
;;;756        LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: pbuf too small\n"));
;;;757        /* free pbuf and return */
;;;758        goto memerr;
;;;759      }
;;;760    
;;;761      /* copy dns payload inside static buffer for processing */ 
;;;762      if (pbuf_copy_partial(p, dns_payload, p->tot_len, 0) == p->tot_len) {
000012  4c53              LDR      r4,|L7.352|
000014  2300              MOVS     r3,#0
000016  4630              MOV      r0,r6
000018  68a1              LDR      r1,[r4,#8]  ; dns_payload
00001a  f7fffffe          BL       pbuf_copy_partial
00001e  8931              LDRH     r1,[r6,#8]
000020  4288              CMP      r0,r1
000022  d165              BNE      |L7.240|
;;;763        /* The ID in the DNS header should be our entry into the name table. */
;;;764        hdr = (struct dns_hdr*)dns_payload;
;;;765        i = htons(hdr->id);
000024  68a7              LDR      r7,[r4,#8]  ; dns_payload
000026  46a0              MOV      r8,r4                 ;764
000028  8838              LDRH     r0,[r7,#0]
00002a  f7fffffe          BL       lwip_htons
;;;766        if (i < DNS_TABLE_SIZE) {
00002e  280a              CMP      r0,#0xa
000030  d25e              BCS      |L7.240|
;;;767          pEntry = &dns_table[i];
000032  ebc000c0          RSB      r0,r0,r0,LSL #3
000036  494b              LDR      r1,|L7.356|
000038  eb000080          ADD      r0,r0,r0,LSL #2
00003c  eb0104c0          ADD      r4,r1,r0,LSL #3
;;;768          if(pEntry->state == DNS_STATE_ASKING) {
000040  7820              LDRB     r0,[r4,#0]
000042  2802              CMP      r0,#2
000044  d154              BNE      |L7.240|
;;;769            /* This entry is now completed. */
;;;770            pEntry->state = DNS_STATE_DONE;
000046  f04f0903          MOV      r9,#3
00004a  f8849000          STRB     r9,[r4,#0]
;;;771            pEntry->err   = hdr->flags2 & DNS_FLAG2_ERR_MASK;
00004e  78f8              LDRB     r0,[r7,#3]
000050  f000000f          AND      r0,r0,#0xf
000054  7160              STRB     r0,[r4,#5]
;;;772    
;;;773            /* We only care about the question(s) and the answers. The authrr
;;;774               and the extrarr are simply discarded. */
;;;775            nquestions = htons(hdr->numquestions);
000056  88b8              LDRH     r0,[r7,#4]
000058  f7fffffe          BL       lwip_htons
00005c  4683              MOV      r11,r0
;;;776            nanswers   = htons(hdr->numanswers);
00005e  88f8              LDRH     r0,[r7,#6]
000060  f7fffffe          BL       lwip_htons
000064  4605              MOV      r5,r0
;;;777    
;;;778            /* Check for error. If so, call callback to inform. */
;;;779            if (((hdr->flags1 & DNS_FLAG1_RESPONSE) == 0) || (pEntry->err != 0) || (nquestions != 1)) {
000066  78b8              LDRB     r0,[r7,#2]
000068  f04f0a00          MOV      r10,#0
00006c  0600              LSLS     r0,r0,#24
00006e  d564              BPL      |L7.314|
000070  7960              LDRB     r0,[r4,#5]
000072  bbe0              CBNZ     r0,|L7.238|
000074  f1bb0f01          CMP      r11,#1
000078  d15f              BNE      |L7.314|
;;;780              LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": error in flags\n", pEntry->name));
;;;781              /* call callback to indicate error, clean up memory and return */
;;;782              goto responseerr;
;;;783            }
;;;784    
;;;785    #if DNS_DOES_NAME_CHECK
;;;786            /* Check if the name in the "question" part match with the name in the entry. */
;;;787            if (dns_compare_name((unsigned char *)(pEntry->name), (unsigned char *)dns_payload + SIZEOF_DNS_HDR) != 0) {
00007a  f8d80008          LDR      r0,[r8,#8]  ; dns_payload
00007e  f104010c          ADD      r1,r4,#0xc
000082  300c              ADDS     r0,r0,#0xc
000084  468b              MOV      r11,r1
000086  4603              MOV      r3,r0
000088  464f              MOV      r7,r9                 ;770
                  |L7.138|
00008a  f8102b01          LDRB     r2,[r0],#1            ;770
00008e  ebb71f92          CMP      r7,r2,LSR #6          ;770
000092  d010              BEQ      |L7.182|
000094  e009              B        |L7.170|
                  |L7.150|
000096  f891c000          LDRB     r12,[r1,#0]           ;770
00009a  f8908000          LDRB     r8,[r0,#0]            ;770
00009e  45c4              CMP      r12,r8                ;770
0000a0  d14b              BNE      |L7.314|
0000a2  1e52              SUBS     r2,r2,#1              ;770
0000a4  1c40              ADDS     r0,r0,#1              ;770
0000a6  b2d2              UXTB     r2,r2                 ;770
0000a8  1c49              ADDS     r1,r1,#1              ;770
                  |L7.170|
0000aa  2a00              CMP      r2,#0                 ;770
0000ac  d1f3              BNE      |L7.150|
0000ae  7802              LDRB     r2,[r0,#0]            ;770
0000b0  1c49              ADDS     r1,r1,#1              ;770
0000b2  2a00              CMP      r2,#0                 ;770
0000b4  d1e9              BNE      |L7.138|
                  |L7.182|
0000b6  4618              MOV      r0,r3                 ;770
;;;788              LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response not match to query\n", pEntry->name));
;;;789              /* call callback to indicate error, clean up memory and return */
;;;790              goto responseerr;
;;;791            }
;;;792    #endif /* DNS_DOES_NAME_CHECK */
;;;793    
;;;794            /* Skip the name in the "question" part */
;;;795            pHostname = (char *) dns_parse_name((unsigned char *)dns_payload + SIZEOF_DNS_HDR) + SIZEOF_DNS_QUERY;
0000b8  f7fffffe          BL       dns_parse_name
;;;796    
;;;797            while (nanswers > 0) {
;;;798              /* skip answer resource record's host name */
;;;799              pHostname = (char *) dns_parse_name((unsigned char *)pHostname);
;;;800    
;;;801              /* Check for IP address type and Internet class. Others are discarded. */
;;;802              SMEMCPY(&ans, pHostname, SIZEOF_DNS_ANSWER);
;;;803              if((ans.type == PP_HTONS(DNS_RRTYPE_A)) && (ans.cls == PP_HTONS(DNS_RRCLASS_IN)) &&
0000bc  f44f7880          MOV      r8,#0x100
;;;804                 (ans.len == PP_HTONS(sizeof(ip_addr_t))) ) {
0000c0  f44f6980          MOV      r9,#0x400
0000c4  1d00              ADDS     r0,r0,#4
0000c6  e036              B        |L7.310|
                  |L7.200|
0000c8  f7fffffe          BL       dns_parse_name
0000cc  6801              LDR      r1,[r0,#0]            ;802
0000ce  9100              STR      r1,[sp,#0]            ;802
0000d0  6841              LDR      r1,[r0,#4]            ;802
0000d2  4607              MOV      r7,r0                 ;799
0000d4  9101              STR      r1,[sp,#4]            ;802
0000d6  8900              LDRH     r0,[r0,#8]            ;802
0000d8  f8ad0008          STRH     r0,[sp,#8]            ;802
0000dc  f8bd0000          LDRH     r0,[sp,#0]            ;803
0000e0  4540              CMP      r0,r8                 ;803
0000e2  d120              BNE      |L7.294|
0000e4  f8bd0002          LDRH     r0,[sp,#2]            ;803
0000e8  4540              CMP      r0,r8                 ;803
0000ea  d11c              BNE      |L7.294|
0000ec  e001              B        |L7.242|
                  |L7.238|
0000ee  e024              B        |L7.314|
                  |L7.240|
0000f0  e030              B        |L7.340|
                  |L7.242|
0000f2  f8bd0008          LDRH     r0,[sp,#8]
0000f6  4548              CMP      r0,r9
0000f8  d115              BNE      |L7.294|
;;;805                /* read the answer resource record's TTL, and maximize it if needed */
;;;806                pEntry->ttl = ntohl(ans.ttl);
0000fa  9801              LDR      r0,[sp,#4]
0000fc  f7fffffe          BL       lwip_ntohl
;;;807                if (pEntry->ttl > DNS_MAX_TTL) {
000100  4919              LDR      r1,|L7.360|
000102  60a0              STR      r0,[r4,#8]
000104  4288              CMP      r0,r1
000106  d900              BLS      |L7.266|
;;;808                  pEntry->ttl = DNS_MAX_TTL;
000108  60a1              STR      r1,[r4,#8]
                  |L7.266|
;;;809                }
;;;810                /* read the IP address after answer resource record's header */
;;;811                SMEMCPY(&(pEntry->ipaddr), (pHostname+SIZEOF_DNS_ANSWER), sizeof(ip_addr_t));
00010a  f8d7000a          LDR      r0,[r7,#0xa]
00010e  f8c4010c          STR      r0,[r4,#0x10c]
;;;812                LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response = ", pEntry->name));
;;;813                ip_addr_debug_print(DNS_DEBUG, (&(pEntry->ipaddr)));
;;;814                LWIP_DEBUGF(DNS_DEBUG, ("\n"));
;;;815                /* call specified callback function if provided */
;;;816                if (pEntry->found) {
000112  f8d43110          LDR      r3,[r4,#0x110]
000116  b1eb              CBZ      r3,|L7.340|
;;;817                  (*pEntry->found)(pEntry->name, &pEntry->ipaddr, pEntry->arg);
000118  f5047186          ADD      r1,r4,#0x10c
00011c  4658              MOV      r0,r11
00011e  f8d42114          LDR      r2,[r4,#0x114]
000122  4798              BLX      r3
000124  e016              B        |L7.340|
                  |L7.294|
;;;818                }
;;;819                /* deallocate memory and return */
;;;820                goto memerr;
;;;821              } else {
;;;822                pHostname = pHostname + SIZEOF_DNS_ANSWER + htons(ans.len);
000126  f8bd0008          LDRH     r0,[sp,#8]
00012a  f7fffffe          BL       lwip_htons
00012e  1e6d              SUBS     r5,r5,#1
000130  4438              ADD      r0,r0,r7
;;;823              }
;;;824              --nanswers;
000132  b2ad              UXTH     r5,r5
000134  300a              ADDS     r0,r0,#0xa
                  |L7.310|
000136  2d00              CMP      r5,#0                 ;797
000138  d1c6              BNE      |L7.200|
                  |L7.314|
;;;825            }
;;;826            LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": error in response\n", pEntry->name));
;;;827            /* call callback to indicate error, clean up memory and return */
;;;828            goto responseerr;
;;;829          }
;;;830        }
;;;831      }
;;;832    
;;;833      /* deallocate memory and return */
;;;834      goto memerr;
;;;835    
;;;836    responseerr:
;;;837      /* ERROR: call specified callback function with NULL as name to indicate an error */
;;;838      if (pEntry->found) {
00013a  f8d43110          LDR      r3,[r4,#0x110]
00013e  b12b              CBZ      r3,|L7.332|
;;;839        (*pEntry->found)(pEntry->name, NULL, pEntry->arg);
000140  2100              MOVS     r1,#0
000142  f104000c          ADD      r0,r4,#0xc
000146  f8d42114          LDR      r2,[r4,#0x114]
00014a  4798              BLX      r3
                  |L7.332|
;;;840      }
;;;841      /* flush this entry */
;;;842      pEntry->state = DNS_STATE_UNUSED;
00014c  f884a000          STRB     r10,[r4,#0]
;;;843      pEntry->found = NULL;
000150  f8c4a110          STR      r10,[r4,#0x110]
                  |L7.340|
;;;844    
;;;845    memerr:
;;;846      /* free pbuf */
;;;847      pbuf_free(p);
000154  4630              MOV      r0,r6
000156  e8bd4ffe          POP      {r1-r11,lr}
00015a  f7ffbffe          B.W      pbuf_free
;;;848      return;
;;;849    }
;;;850    
                          ENDP

00015e  0000              DCW      0x0000
                  |L7.352|
                          DCD      ||.data||
                  |L7.356|
                          DCD      ||.bss||
                  |L7.360|
                          DCD      0x00093a80

                          AREA ||i.dns_send||, CODE, READONLY, ALIGN=2

                  dns_send PROC
;;;559    static err_t
;;;560    dns_send(u8_t numdns, const char* name, u8_t id)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;561    {
000004  4617              MOV      r7,r2
000006  4688              MOV      r8,r1
000008  4604              MOV      r4,r0
;;;562      err_t err;
;;;563      struct dns_hdr *hdr;
;;;564      struct dns_query qry;
;;;565      struct pbuf *p;
;;;566      char *query, *nptr;
;;;567      const char *pHostname;
;;;568      u8_t n;
;;;569    
;;;570      LWIP_DEBUGF(DNS_DEBUG, ("dns_send: dns_servers[%"U16_F"] \"%s\": request\n",
;;;571                  (u16_t)(numdns), name));
;;;572      LWIP_ASSERT("dns server out of array", numdns < DNS_MAX_SERVERS);
00000a  2802              CMP      r0,#2
00000c  d302              BCC      |L8.20|
00000e  a034              ADR      r0,|L8.224|
000010  f7fffffe          BL       __2printf
                  |L8.20|
;;;573      LWIP_ASSERT("dns server has no IP address set", !ip_addr_isany(&dns_servers[numdns]));
000014  4838              LDR      r0,|L8.248|
000016  eb100684          ADDS     r6,r0,r4,LSL #2
00001a  d002              BEQ      |L8.34|
00001c  f8500024          LDR      r0,[r0,r4,LSL #2]
000020  b910              CBNZ     r0,|L8.40|
                  |L8.34|
000022  a036              ADR      r0,|L8.252|
000024  f7fffffe          BL       __2printf
                  |L8.40|
;;;574    
;;;575      /* if here, we have either a new query or a retry on a previous query to process */
;;;576      p = pbuf_alloc(PBUF_TRANSPORT, SIZEOF_DNS_HDR + DNS_MAX_NAME_LENGTH +
000028  2200              MOVS     r2,#0
00002a  f44f7188          MOV      r1,#0x110
00002e  4610              MOV      r0,r2
000030  f7fffffe          BL       pbuf_alloc
000034  0005              MOVS     r5,r0
;;;577                     SIZEOF_DNS_QUERY, PBUF_RAM);
;;;578      if (p != NULL) {
000036  d04d              BEQ      |L8.212|
;;;579        LWIP_ASSERT("pbuf must be in one piece", p->next == NULL);
000038  6828              LDR      r0,[r5,#0]
00003a  b110              CBZ      r0,|L8.66|
00003c  a038              ADR      r0,|L8.288|
00003e  f7fffffe          BL       __2printf
                  |L8.66|
;;;580        /* fill dns header */
;;;581        hdr = (struct dns_hdr*)p->payload;
;;;582        memset(hdr, 0, SIZEOF_DNS_HDR);
000042  686c              LDR      r4,[r5,#4]
000044  f04f0900          MOV      r9,#0
;;;583        hdr->id = htons(id);
000048  4638              MOV      r0,r7
00004a  f8c49000          STR      r9,[r4,#0]            ;582
00004e  f8c49004          STR      r9,[r4,#4]            ;582
000052  f8c49008          STR      r9,[r4,#8]            ;582
000056  f7fffffe          BL       lwip_htons
00005a  f8240b02          STRH     r0,[r4],#2
;;;584        hdr->flags1 = DNS_FLAG1_RD;
00005e  2001              MOVS     r0,#1
000060  f8040b02          STRB     r0,[r4],#2
;;;585        hdr->numquestions = PP_HTONS(1);
000064  0202              LSLS     r2,r0,#8
000066  f8242b08          STRH     r2,[r4],#8
00006a  f1a80801          SUB      r8,r8,#1
                  |L8.110|
;;;586        query = (char*)hdr + SIZEOF_DNS_HDR;
;;;587        pHostname = name;
;;;588        --pHostname;
;;;589    
;;;590        /* convert hostname into suitable query format. */
;;;591        do {
;;;592          ++pHostname;
;;;593          nptr = query;
00006e  4623              MOV      r3,r4
;;;594          ++query;
000070  1c64              ADDS     r4,r4,#1
;;;595          for(n = 0; *pHostname != '.' && *pHostname != 0; ++pHostname) {
000072  2000              MOVS     r0,#0
000074  e003              B        |L8.126|
                  |L8.118|
;;;596            *query = *pHostname;
000076  1c40              ADDS     r0,r0,#1
000078  f8041b01          STRB     r1,[r4],#1
;;;597            ++query;
;;;598            ++n;
00007c  b2c0              UXTB     r0,r0
                  |L8.126|
00007e  f8181f01          LDRB     r1,[r8,#1]!           ;595
000082  292e              CMP      r1,#0x2e              ;595
000084  d001              BEQ      |L8.138|
000086  2900              CMP      r1,#0                 ;595
000088  d1f5              BNE      |L8.118|
                  |L8.138|
;;;599          }
;;;600          *nptr = n;
00008a  7018              STRB     r0,[r3,#0]
;;;601        } while(*pHostname != 0);
00008c  f8980000          LDRB     r0,[r8,#0]
000090  2800              CMP      r0,#0
000092  d1ec              BNE      |L8.110|
;;;602        *query++='\0';
000094  f8049b01          STRB     r9,[r4],#1
000098  f362070f          BFI      r7,r2,#0,#16
00009c  f362471f          BFI      r7,r2,#16,#16
;;;603    
;;;604        /* fill dns query */
;;;605        qry.type = PP_HTONS(DNS_RRTYPE_A);
;;;606        qry.cls = PP_HTONS(DNS_RRCLASS_IN);
;;;607        SMEMCPY(query, &qry, SIZEOF_DNS_QUERY);
0000a0  6027              STR      r7,[r4,#0]
;;;608    
;;;609        /* resize pbuf to the exact dns query */
;;;610        pbuf_realloc(p, (u16_t)((query + SIZEOF_DNS_QUERY) - ((char*)(p->payload))));
0000a2  88a8              LDRH     r0,[r5,#4]
0000a4  1a20              SUBS     r0,r4,r0
0000a6  1d00              ADDS     r0,r0,#4
0000a8  b281              UXTH     r1,r0
0000aa  4628              MOV      r0,r5
0000ac  f7fffffe          BL       pbuf_realloc
;;;611    
;;;612        /* connect to the server for faster receiving */
;;;613        udp_connect(dns_pcb, &dns_servers[numdns], DNS_SERVER_PORT);
0000b0  4c11              LDR      r4,|L8.248|
0000b2  4631              MOV      r1,r6                 ;610
0000b4  3c0c              SUBS     r4,r4,#0xc
0000b6  2235              MOVS     r2,#0x35
0000b8  6860              LDR      r0,[r4,#4]  ; dns_pcb
0000ba  f7fffffe          BL       udp_connect
0000be  4632              MOV      r2,r6
;;;614        /* send dns packet */
;;;615        err = udp_sendto(dns_pcb, p, &dns_servers[numdns], DNS_SERVER_PORT);
0000c0  2335              MOVS     r3,#0x35
0000c2  4629              MOV      r1,r5
0000c4  6860              LDR      r0,[r4,#4]  ; dns_pcb
0000c6  f7fffffe          BL       udp_sendto
0000ca  4604              MOV      r4,r0
;;;616    
;;;617        /* free pbuf */
;;;618        pbuf_free(p);
0000cc  4628              MOV      r0,r5
0000ce  f7fffffe          BL       pbuf_free
0000d2  e001              B        |L8.216|
                  |L8.212|
;;;619      } else {
;;;620        err = ERR_MEM;
0000d4  f04f34ff          MOV      r4,#0xffffffff
                  |L8.216|
;;;621      }
;;;622    
;;;623      return err;
0000d8  4620              MOV      r0,r4
;;;624    }
0000da  e8bd87f0          POP      {r4-r10,pc}
;;;625    
                          ENDP

0000de  0000              DCW      0x0000
                  |L8.224|
0000e0  646e7320          DCB      "dns server out of array",0
0000e4  73657276
0000e8  6572206f
0000ec  7574206f
0000f0  66206172
0000f4  72617900
                  |L8.248|
                          DCD      ||.data||+0xc
                  |L8.252|
0000fc  646e7320          DCB      "dns server has no IP address set",0
000100  73657276
000104  65722068
000108  6173206e
00010c  6f204950
000110  20616464
000114  72657373
000118  20736574
00011c  00      
00011d  00                DCB      0
00011e  00                DCB      0
00011f  00                DCB      0
                  |L8.288|
000120  70627566          DCB      "pbuf must be in one piece",0
000124  206d7573
000128  74206265
00012c  20696e20
000130  6f6e6520
000134  70696563
000138  6500    
00013a  00                DCB      0
00013b  00                DCB      0

                          AREA ||i.dns_setserver||, CODE, READONLY, ALIGN=2

                  dns_setserver PROC
;;;272    void
;;;273    dns_setserver(u8_t numdns, ip_addr_t *dnsserver)
000000  2802              CMP      r0,#2
;;;274    {
000002  d20c              BCS      |L9.30|
;;;275      if ((numdns < DNS_MAX_SERVERS) && (dns_pcb != NULL) &&
000004  4a06              LDR      r2,|L9.32|
000006  6852              LDR      r2,[r2,#4]  ; dns_pcb
000008  2a00              CMP      r2,#0
00000a  d008              BEQ      |L9.30|
;;;276          (dnsserver != NULL) && !ip_addr_isany(dnsserver)) {
00000c  2900              CMP      r1,#0
00000e  d006              BEQ      |L9.30|
000010  6809              LDR      r1,[r1,#0]
000012  2900              CMP      r1,#0
000014  d003              BEQ      |L9.30|
;;;277        dns_servers[numdns] = (*dnsserver);
000016  4a02              LDR      r2,|L9.32|
000018  320c              ADDS     r2,r2,#0xc
00001a  f8421020          STR      r1,[r2,r0,LSL #2]
                  |L9.30|
;;;278      }
;;;279    }
00001e  4770              BX       lr
;;;280    
                          ENDP

                  |L9.32|
                          DCD      ||.data||

                          AREA ||i.dns_tmr||, CODE, READONLY, ALIGN=2

                  dns_tmr PROC
;;;302    void
;;;303    dns_tmr(void)
000000  4806              LDR      r0,|L10.28|
;;;304    {
000002  b510              PUSH     {r4,lr}
;;;305      if (dns_pcb != NULL) {
000004  6840              LDR      r0,[r0,#4]  ; dns_pcb
000006  2800              CMP      r0,#0                 ;304
000008  d007              BEQ      |L10.26|
00000a  2400              MOVS     r4,#0                 ;304
                  |L10.12|
00000c  4620              MOV      r0,r4                 ;304
00000e  f7fffffe          BL       dns_check_entry
000012  1c64              ADDS     r4,r4,#1              ;304
000014  b2e4              UXTB     r4,r4                 ;304
000016  2c0a              CMP      r4,#0xa               ;304
000018  d3f8              BCC      |L10.12|
                  |L10.26|
;;;306        LWIP_DEBUGF(DNS_DEBUG, ("dns_tmr: dns_check_entries\n"));
;;;307        dns_check_entries();
;;;308      }
;;;309    }
00001a  bd10              POP      {r4,pc}
;;;310    
                          ENDP

                  |L10.28|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  dns_table
                          %        2800
                  dns_payload_buffer
                          %        515

                          AREA ||.data||, DATA, ALIGN=2

                  dns_seqno
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  dns_pcb
                          DCD      0x00000000
                  dns_payload
                          DCD      0x00000000
                  dns_servers
                          %        8

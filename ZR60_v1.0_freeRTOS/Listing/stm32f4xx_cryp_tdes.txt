; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\stm32f4xx_cryp_tdes.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\stm32f4xx_cryp_tdes.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\ZR60_v1.0_freeRTOS -I..\..\Lwip\App -I..\..\Lwip\Bsp -I..\..\Lwip\Bsp\LAN8742A -I..\..\Lwip\lwip-1.4.1 -I..\..\Lwip\lwip-1.4.1\port -I..\..\Lwip\lwip-1.4.1\port\arch -I..\..\Lwip\lwip-1.4.1\port\Standalone -I..\..\Lwip\lwip-1.4.1\src\include -I..\..\Lwip\lwip-1.4.1\src\include\ipv4 -I..\..\Lwip\lwip-1.4.1\src\include\lwip -I..\..\Lwip\lwip-1.4.1\src\include\netif -I..\..\Ecal\BtnFltr -I..\..\Ecal\UartComn -I..\..\Ecal\MemIf -I..\..\APP -I..\..\APP\BlackListMng -I..\..\APP\SeverNewsPush -I..\..\APP\NewsPull -I..\..\Ecal -I..\..\Ecal\JsonIf -I..\..\Ecal\Mcu_Init -I..\..\Service -I..\..\Complex -I..\..\Complex\FATFS -I..\..\FreeRTOS\Source\include -I..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\FreeRTOS -I.\RTE\_ZR60 -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=..\..\output\stm32f4xx_cryp_tdes.crf ..\..\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_cryp_tdes.c]
                          THUMB

                          AREA ||i.CRYP_TDES_CBC||, CODE, READONLY, ALIGN=1

                  CRYP_TDES_CBC PROC
;;;209      */
;;;210    ErrorStatus CRYP_TDES_CBC(uint8_t Mode, uint8_t Key[24], uint8_t InitVectors[8],
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;211                              uint8_t *Input, uint32_t Ilength, uint8_t *Output)
;;;212    {
000004  b091              SUB      sp,sp,#0x44
;;;213      CRYP_InitTypeDef TDES_CRYP_InitStructure;
;;;214      CRYP_KeyInitTypeDef TDES_CRYP_KeyInitStructure;
;;;215      CRYP_IVInitTypeDef TDES_CRYP_IVInitStructure;
;;;216      __IO uint32_t counter = 0;
000006  f04f0a00          MOV      r10,#0
00000a  e9ddb51e          LDRD     r11,r5,[sp,#0x78]     ;212
00000e  461c              MOV      r4,r3                 ;212
;;;217      uint32_t busystatus = 0;
;;;218      ErrorStatus status = SUCCESS;
000010  2701              MOVS     r7,#1
;;;219      uint32_t keyaddr    = (uint32_t)Key;
000012  4688              MOV      r8,r1
;;;220      uint32_t inputaddr  = (uint32_t)Input;
;;;221      uint32_t outputaddr = (uint32_t)Output;
;;;222      uint32_t ivaddr     = (uint32_t)InitVectors;
000014  4691              MOV      r9,r2
;;;223      uint32_t i = 0;
000016  4656              MOV      r6,r10
;;;224    
;;;225      /* Crypto structures initialisation*/
;;;226      CRYP_KeyStructInit(&TDES_CRYP_KeyInitStructure);
000018  4668              MOV      r0,sp
00001a  f8cda030          STR      r10,[sp,#0x30]
00001e  f7fffffe          BL       CRYP_KeyStructInit
;;;227    
;;;228      /* Crypto Init for Encryption process */
;;;229      if(Mode == MODE_ENCRYPT) /* TDES encryption */
000022  9811              LDR      r0,[sp,#0x44]
000024  2801              CMP      r0,#1
000026  d037              BEQ      |L1.152|
;;;230      {
;;;231        TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
;;;232      }
;;;233      else
;;;234      {
;;;235        TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
000028  2004              MOVS     r0,#4
00002a  9008              STR      r0,[sp,#0x20]
                  |L1.44|
;;;236      }
;;;237      TDES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_TDES_CBC;
00002c  2008              MOVS     r0,#8
;;;238      TDES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
00002e  9009              STR      r0,[sp,#0x24]
000030  2080              MOVS     r0,#0x80
;;;239    
;;;240      CRYP_Init(&TDES_CRYP_InitStructure);
000032  900a              STR      r0,[sp,#0x28]
000034  a808              ADD      r0,sp,#0x20
000036  f7fffffe          BL       CRYP_Init
;;;241    
;;;242      /* Key Initialisation */
;;;243      TDES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
00003a  f8d80000          LDR      r0,[r8,#0]
00003e  ba00              REV      r0,r0
;;;244      keyaddr+=4;
;;;245      TDES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
000040  9002              STR      r0,[sp,#8]
000042  f8d81004          LDR      r1,[r8,#4]
000046  ba09              REV      r1,r1
;;;246      keyaddr+=4;
;;;247      TDES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
000048  9103              STR      r1,[sp,#0xc]
00004a  f8d81008          LDR      r1,[r8,#8]
00004e  ba09              REV      r1,r1
;;;248      keyaddr+=4;
;;;249      TDES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
000050  9104              STR      r1,[sp,#0x10]
000052  f8d8100c          LDR      r1,[r8,#0xc]
000056  ba09              REV      r1,r1
;;;250      keyaddr+=4;
;;;251      TDES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
000058  9105              STR      r1,[sp,#0x14]
00005a  f8d81010          LDR      r1,[r8,#0x10]
00005e  ba09              REV      r1,r1
;;;252      keyaddr+=4;
;;;253      TDES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
000060  9106              STR      r1,[sp,#0x18]
000062  f8d80014          LDR      r0,[r8,#0x14]
000066  ba00              REV      r0,r0
;;;254      CRYP_KeyInit(& TDES_CRYP_KeyInitStructure);
000068  9007              STR      r0,[sp,#0x1c]
00006a  4668              MOV      r0,sp
00006c  f7fffffe          BL       CRYP_KeyInit
;;;255      
;;;256      /* Initialization Vectors */
;;;257      TDES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
000070  f8d90000          LDR      r0,[r9,#0]
000074  ba00              REV      r0,r0
;;;258      ivaddr+=4;
;;;259      TDES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
000076  900d              STR      r0,[sp,#0x34]
000078  f8d90004          LDR      r0,[r9,#4]
00007c  ba00              REV      r0,r0
;;;260      CRYP_IVInit(&TDES_CRYP_IVInitStructure);
00007e  900e              STR      r0,[sp,#0x38]
000080  a80d              ADD      r0,sp,#0x34
000082  f7fffffe          BL       CRYP_IVInit
;;;261      
;;;262      /* Flush IN/OUT FIFO */
;;;263      CRYP_FIFOFlush();
000086  f7fffffe          BL       CRYP_FIFOFlush
;;;264      
;;;265      /* Enable Crypto processor */
;;;266      CRYP_Cmd(ENABLE);
00008a  2001              MOVS     r0,#1
00008c  f7fffffe          BL       CRYP_Cmd
;;;267      
;;;268      if(CRYP_GetCmdStatus() == DISABLE)
000090  f7fffffe          BL       CRYP_GetCmdStatus
000094  b118              CBZ      r0,|L1.158|
000096  e026              B        |L1.230|
                  |L1.152|
000098  f8cda020          STR      r10,[sp,#0x20]        ;231
00009c  e7c6              B        |L1.44|
                  |L1.158|
;;;269      {
;;;270        /* The CRYP peripheral clock is not enabled or the device doesn't embed 
;;;271        the CRYP peripheral (please check the device sales type. */
;;;272        status = ERROR;
00009e  2700              MOVS     r7,#0
0000a0  e028              B        |L1.244|
                  |L1.162|
;;;273      }
;;;274      else
;;;275      {
;;;276        for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
;;;277        {
;;;278          /* Write the Input block in the Input FIFO */
;;;279          CRYP_DataIn(*(uint32_t*)(inputaddr));
0000a2  6820              LDR      r0,[r4,#0]
0000a4  f7fffffe          BL       CRYP_DataIn
;;;280          inputaddr+=4;
;;;281          CRYP_DataIn(*(uint32_t*)(inputaddr));
0000a8  f8540f04          LDR      r0,[r4,#4]!
0000ac  f7fffffe          BL       CRYP_DataIn
;;;282          inputaddr+=4;
;;;283          
;;;284          /* Wait until the complete message has been processed */
;;;285          counter = 0;
;;;286          do
;;;287          {
;;;288            busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;289            counter++;
;;;290          }while ((counter != TDESBUSY_TIMEOUT) && (busystatus != RESET));
0000b0  f44f3880          MOV      r8,#0x10000
0000b4  1d24              ADDS     r4,r4,#4
0000b6  f8cda030          STR      r10,[sp,#0x30]
                  |L1.186|
0000ba  2010              MOVS     r0,#0x10              ;288
0000bc  f7fffffe          BL       CRYP_GetFlagStatus
0000c0  990c              LDR      r1,[sp,#0x30]         ;289
0000c2  1c49              ADDS     r1,r1,#1              ;289
0000c4  910c              STR      r1,[sp,#0x30]
0000c6  4541              CMP      r1,r8
0000c8  d002              BEQ      |L1.208|
0000ca  2800              CMP      r0,#0
0000cc  d1f5              BNE      |L1.186|
0000ce  e002              B        |L1.214|
                  |L1.208|
;;;291          
;;;292          if (busystatus != RESET)
0000d0  b108              CBZ      r0,|L1.214|
;;;293          {
;;;294            status = ERROR;
0000d2  2700              MOVS     r7,#0
0000d4  e006              B        |L1.228|
                  |L1.214|
;;;295          }
;;;296          else
;;;297          {
;;;298            
;;;299            /* Read the Output block from the Output FIFO */
;;;300            *(uint32_t*)(outputaddr) = CRYP_DataOut();
0000d6  f7fffffe          BL       CRYP_DataOut
;;;301            outputaddr+=4;
;;;302            *(uint32_t*)(outputaddr) = CRYP_DataOut();
0000da  6028              STR      r0,[r5,#0]
0000dc  f7fffffe          BL       CRYP_DataOut
0000e0  6068              STR      r0,[r5,#4]
0000e2  3508              ADDS     r5,r5,#8
                  |L1.228|
0000e4  3608              ADDS     r6,r6,#8
                  |L1.230|
0000e6  455e              CMP      r6,r11                ;276
0000e8  d201              BCS      |L1.238|
0000ea  2f00              CMP      r7,#0                 ;276
0000ec  d1d9              BNE      |L1.162|
                  |L1.238|
;;;303            outputaddr+=4;
;;;304          }
;;;305        }
;;;306        
;;;307        /* Disable Crypto */
;;;308        CRYP_Cmd(DISABLE);
0000ee  2000              MOVS     r0,#0
0000f0  f7fffffe          BL       CRYP_Cmd
                  |L1.244|
;;;309      }
;;;310      return status; 
;;;311    }
0000f4  b015              ADD      sp,sp,#0x54
0000f6  4638              MOV      r0,r7                 ;310
0000f8  e8bd8ff0          POP      {r4-r11,pc}
;;;312    /**
                          ENDP


                          AREA ||i.CRYP_TDES_ECB||, CODE, READONLY, ALIGN=1

                  CRYP_TDES_ECB PROC
;;;99       */
;;;100    ErrorStatus CRYP_TDES_ECB(uint8_t Mode, uint8_t Key[24], uint8_t *Input, 
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;101                              uint32_t Ilength, uint8_t *Output)
;;;102    {
000004  b08d              SUB      sp,sp,#0x34
;;;103      CRYP_InitTypeDef TDES_CRYP_InitStructure;
;;;104      CRYP_KeyInitTypeDef TDES_CRYP_KeyInitStructure;
;;;105      __IO uint32_t counter = 0;
000006  f04f0900          MOV      r9,#0
00000a  4683              MOV      r11,r0                ;102
00000c  9d16              LDR      r5,[sp,#0x58]
00000e  469a              MOV      r10,r3                ;102
000010  4614              MOV      r4,r2                 ;102
;;;106      uint32_t busystatus = 0;
;;;107      ErrorStatus status = SUCCESS;
000012  2701              MOVS     r7,#1
;;;108      uint32_t keyaddr    = (uint32_t)Key;
000014  4688              MOV      r8,r1
;;;109      uint32_t inputaddr  = (uint32_t)Input;
;;;110      uint32_t outputaddr = (uint32_t)Output;
;;;111      uint32_t i = 0;
000016  464e              MOV      r6,r9
;;;112    
;;;113      /* Crypto structures initialisation*/
;;;114      CRYP_KeyStructInit(&TDES_CRYP_KeyInitStructure);
000018  4668              MOV      r0,sp
00001a  f8cd9030          STR      r9,[sp,#0x30]
00001e  f7fffffe          BL       CRYP_KeyStructInit
;;;115    
;;;116      /* Crypto Init for Encryption process */
;;;117      if(Mode == MODE_ENCRYPT) /* TDES encryption */
000022  f1bb0f01          CMP      r11,#1
000026  d02b              BEQ      |L2.128|
;;;118      {
;;;119         TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
;;;120      }
;;;121      else /*if(Mode == MODE_DECRYPT)*/ /* TDES decryption */
;;;122      {
;;;123         TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
000028  2004              MOVS     r0,#4
00002a  9008              STR      r0,[sp,#0x20]
                  |L2.44|
;;;124      }
;;;125    
;;;126      TDES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_TDES_ECB;
;;;127      TDES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
00002c  2080              MOVS     r0,#0x80
00002e  e9cd9009          STRD     r9,r0,[sp,#0x24]
;;;128      CRYP_Init(&TDES_CRYP_InitStructure);
000032  a808              ADD      r0,sp,#0x20
000034  f7fffffe          BL       CRYP_Init
;;;129    
;;;130      /* Key Initialisation */
;;;131      TDES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
000038  f8d80000          LDR      r0,[r8,#0]
00003c  ba00              REV      r0,r0
;;;132      keyaddr+=4;
;;;133      TDES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
00003e  9002              STR      r0,[sp,#8]
000040  f8d81004          LDR      r1,[r8,#4]
000044  ba09              REV      r1,r1
;;;134      keyaddr+=4;
;;;135      TDES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
000046  9103              STR      r1,[sp,#0xc]
000048  f8d81008          LDR      r1,[r8,#8]
00004c  ba09              REV      r1,r1
;;;136      keyaddr+=4;
;;;137      TDES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
00004e  9104              STR      r1,[sp,#0x10]
000050  f8d8100c          LDR      r1,[r8,#0xc]
000054  ba09              REV      r1,r1
;;;138      keyaddr+=4;
;;;139      TDES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
000056  9105              STR      r1,[sp,#0x14]
000058  f8d81010          LDR      r1,[r8,#0x10]
00005c  ba09              REV      r1,r1
;;;140      keyaddr+=4;
;;;141      TDES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
00005e  9106              STR      r1,[sp,#0x18]
000060  f8d80014          LDR      r0,[r8,#0x14]
000064  ba00              REV      r0,r0
;;;142      CRYP_KeyInit(& TDES_CRYP_KeyInitStructure);
000066  9007              STR      r0,[sp,#0x1c]
000068  4668              MOV      r0,sp
00006a  f7fffffe          BL       CRYP_KeyInit
;;;143    
;;;144      /* Flush IN/OUT FIFO */
;;;145      CRYP_FIFOFlush();
00006e  f7fffffe          BL       CRYP_FIFOFlush
;;;146    
;;;147      /* Enable Crypto processor */
;;;148      CRYP_Cmd(ENABLE);
000072  2001              MOVS     r0,#1
000074  f7fffffe          BL       CRYP_Cmd
;;;149    
;;;150      if(CRYP_GetCmdStatus() == DISABLE)
000078  f7fffffe          BL       CRYP_GetCmdStatus
00007c  b118              CBZ      r0,|L2.134|
00007e  e026              B        |L2.206|
                  |L2.128|
000080  f8cd9020          STR      r9,[sp,#0x20]         ;119
000084  e7d2              B        |L2.44|
                  |L2.134|
;;;151      {
;;;152        /* The CRYP peripheral clock is not enabled or the device doesn't embed 
;;;153        the CRYP peripheral (please check the device sales type. */
;;;154        status = ERROR;
000086  2700              MOVS     r7,#0
000088  e028              B        |L2.220|
                  |L2.138|
;;;155      }
;;;156      else
;;;157      {
;;;158        for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
;;;159        {
;;;160          /* Write the Input block in the Input FIFO */
;;;161          CRYP_DataIn(*(uint32_t*)(inputaddr));
00008a  6820              LDR      r0,[r4,#0]
00008c  f7fffffe          BL       CRYP_DataIn
;;;162          inputaddr+=4;
;;;163          CRYP_DataIn(*(uint32_t*)(inputaddr));
000090  f8540f04          LDR      r0,[r4,#4]!
000094  f7fffffe          BL       CRYP_DataIn
;;;164          inputaddr+=4;
;;;165          
;;;166          /* Wait until the complete message has been processed */
;;;167          counter = 0;
;;;168          do
;;;169          {
;;;170            busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;171            counter++;
;;;172          }while ((counter != TDESBUSY_TIMEOUT) && (busystatus != RESET));
000098  f44f3880          MOV      r8,#0x10000
00009c  1d24              ADDS     r4,r4,#4
00009e  f8cd9030          STR      r9,[sp,#0x30]
                  |L2.162|
0000a2  2010              MOVS     r0,#0x10              ;170
0000a4  f7fffffe          BL       CRYP_GetFlagStatus
0000a8  990c              LDR      r1,[sp,#0x30]         ;171
0000aa  1c49              ADDS     r1,r1,#1              ;171
0000ac  910c              STR      r1,[sp,#0x30]
0000ae  4541              CMP      r1,r8
0000b0  d002              BEQ      |L2.184|
0000b2  2800              CMP      r0,#0
0000b4  d1f5              BNE      |L2.162|
0000b6  e002              B        |L2.190|
                  |L2.184|
;;;173          
;;;174          if (busystatus != RESET)
0000b8  b108              CBZ      r0,|L2.190|
;;;175          {
;;;176            status = ERROR;
0000ba  2700              MOVS     r7,#0
0000bc  e006              B        |L2.204|
                  |L2.190|
;;;177          }
;;;178          else
;;;179          {
;;;180            
;;;181            /* Read the Output block from the Output FIFO */
;;;182            *(uint32_t*)(outputaddr) = CRYP_DataOut();
0000be  f7fffffe          BL       CRYP_DataOut
;;;183            outputaddr+=4;
;;;184            *(uint32_t*)(outputaddr) = CRYP_DataOut();
0000c2  6028              STR      r0,[r5,#0]
0000c4  f7fffffe          BL       CRYP_DataOut
0000c8  6068              STR      r0,[r5,#4]
0000ca  3508              ADDS     r5,r5,#8
                  |L2.204|
0000cc  3608              ADDS     r6,r6,#8
                  |L2.206|
0000ce  4556              CMP      r6,r10                ;158
0000d0  d201              BCS      |L2.214|
0000d2  2f00              CMP      r7,#0                 ;158
0000d4  d1d9              BNE      |L2.138|
                  |L2.214|
;;;185            outputaddr+=4;
;;;186          }
;;;187        }
;;;188        
;;;189        /* Disable Crypto */
;;;190        CRYP_Cmd(DISABLE);
0000d6  2000              MOVS     r0,#0
0000d8  f7fffffe          BL       CRYP_Cmd
                  |L2.220|
;;;191      }
;;;192      return status; 
;;;193    }
0000dc  b00d              ADD      sp,sp,#0x34
0000de  4638              MOV      r0,r7                 ;192
0000e0  e8bd8ff0          POP      {r4-r11,pc}
;;;194    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_cryp_tdes.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f4xx_cryp_tdes_c_2fc87a0d____REV16|
#line 138 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___21_stm32f4xx_cryp_tdes_c_2fc87a0d____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f4xx_cryp_tdes_c_2fc87a0d____REVSH|
#line 153
|__asm___21_stm32f4xx_cryp_tdes_c_2fc87a0d____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f4xx_cryp_tdes_c_2fc87a0d____RRX|
#line 328
|__asm___21_stm32f4xx_cryp_tdes_c_2fc87a0d____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

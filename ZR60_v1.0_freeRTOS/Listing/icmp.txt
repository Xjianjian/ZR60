; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\icmp.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\icmp.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\ZR60_v1.0_freeRTOS -I..\..\Lwip\App -I..\..\Lwip\Bsp -I..\..\Lwip\Bsp\LAN8742A -I..\..\Lwip\lwip-1.4.1 -I..\..\Lwip\lwip-1.4.1\port -I..\..\Lwip\lwip-1.4.1\port\arch -I..\..\Lwip\lwip-1.4.1\port\Standalone -I..\..\Lwip\lwip-1.4.1\src\include -I..\..\Lwip\lwip-1.4.1\src\include\ipv4 -I..\..\Lwip\lwip-1.4.1\src\include\lwip -I..\..\Lwip\lwip-1.4.1\src\include\netif -I..\..\Ecal\BtnFltr -I..\..\Ecal\UartComn -I..\..\Ecal\MemIf -I..\..\APP -I..\..\APP\BlackListMng -I..\..\APP\SeverNewsPush -I..\..\APP\NewsPull -I..\..\Ecal -I..\..\Ecal\JsonIf -I..\..\Ecal\Mcu_Init -I..\..\Service -I..\..\Complex -I..\..\Complex\FATFS -I..\..\FreeRTOS\Source\include -I..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\FreeRTOS -I.\RTE\_ZR60 -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=..\..\output\icmp.crf ..\..\Lwip\lwip-1.4.1\src\core\ipv4\icmp.c]
                          THUMB

                          AREA ||i.icmp_dest_unreach||, CODE, READONLY, ALIGN=1

                  icmp_dest_unreach PROC
;;;260    void
;;;261    icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
000000  460a              MOV      r2,r1
;;;262    {
;;;263      icmp_send_response(p, ICMP_DUR, t);
000002  2103              MOVS     r1,#3
000004  f7ffbffe          B.W      icmp_send_response
;;;264    }
;;;265    
                          ENDP


                          AREA ||i.icmp_input||, CODE, READONLY, ALIGN=2

                  icmp_input PROC
;;;76     void
;;;77     icmp_input(struct pbuf *p, struct netif *inp)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;78     {
;;;79       u8_t type;
;;;80     #ifdef LWIP_DEBUG
;;;81       u8_t code;
;;;82     #endif /* LWIP_DEBUG */
;;;83       struct icmp_echo_hdr *iecho;
;;;84       struct ip_hdr *iphdr;
;;;85       s16_t hlen;
;;;86     
;;;87       ICMP_STATS_INC(icmp.recv);
;;;88       snmp_inc_icmpinmsgs();
;;;89     
;;;90     
;;;91       iphdr = (struct ip_hdr *)p->payload;
;;;92       hlen = IPH_HL(iphdr) * 4;
000004  6845              LDR      r5,[r0,#4]
000006  4604              MOV      r4,r0                 ;78
000008  468a              MOV      r10,r1                ;78
00000a  7828              LDRB     r0,[r5,#0]
00000c  0700              LSLS     r0,r0,#28
00000e  0e87              LSRS     r7,r0,#26
;;;93       if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
000010  4279              RSBS     r1,r7,#0
000012  4688              MOV      r8,r1
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       pbuf_header
00001a  2800              CMP      r0,#0
00001c  d178              BNE      |L2.272|
00001e  8920              LDRH     r0,[r4,#8]
000020  2804              CMP      r0,#4
000022  d375              BCC      |L2.272|
;;;94         LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
;;;95         goto lenerr;
;;;96       }
;;;97     
;;;98       type = *((u8_t *)p->payload);
000024  6860              LDR      r0,[r4,#4]
000026  7800              LDRB     r0,[r0,#0]
;;;99     #ifdef LWIP_DEBUG
;;;100      code = *(((u8_t *)p->payload)+1);
;;;101    #endif /* LWIP_DEBUG */
;;;102      switch (type) {
000028  2800              CMP      r0,#0
00002a  d071              BEQ      |L2.272|
00002c  2808              CMP      r0,#8
00002e  d16f              BNE      |L2.272|
;;;103      case ICMP_ER:
;;;104        /* This is OK, echo reply might have been parsed by a raw PCB
;;;105           (as obviously, an echo request has been sent, too). */
;;;106        break; 
;;;107      case ICMP_ECHO:
;;;108    #if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
;;;109        {
;;;110          int accepted = 1;
;;;111    #if !LWIP_MULTICAST_PING
;;;112          /* multicast destination address? */
;;;113          if (ip_addr_ismulticast(&current_iphdr_dest)) {
000030  493a              LDR      r1,|L2.284|
000032  2601              MOVS     r6,#1                 ;110
000034  6808              LDR      r0,[r1,#0]  ; current_iphdr_dest
000036  f3c01203          UBFX     r2,r0,#4,#4
00003a  2a0e              CMP      r2,#0xe
00003c  d100              BNE      |L2.64|
;;;114            accepted = 0;
00003e  2600              MOVS     r6,#0
                  |L2.64|
;;;115          }
;;;116    #endif /* LWIP_MULTICAST_PING */
;;;117    #if !LWIP_BROADCAST_PING
;;;118          /* broadcast destination address? */
;;;119          if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
000040  4689              MOV      r9,r1
000042  4651              MOV      r1,r10
000044  f7fffffe          BL       ip4_addr_isbroadcast
000048  2800              CMP      r0,#0
00004a  d161              BNE      |L2.272|
;;;120            accepted = 0;
;;;121          }
;;;122    #endif /* LWIP_BROADCAST_PING */
;;;123          /* broadcast or multicast destination address not acceptd? */
;;;124          if (!accepted) {
00004c  2e00              CMP      r6,#0
00004e  d05f              BEQ      |L2.272|
;;;125            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
;;;126            ICMP_STATS_INC(icmp.err);
;;;127            pbuf_free(p);
;;;128            return;
;;;129          }
;;;130        }
;;;131    #endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
;;;132        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
;;;133        if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
000050  8920              LDRH     r0,[r4,#8]
000052  2808              CMP      r0,#8
000054  d35c              BCC      |L2.272|
;;;134          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
;;;135          goto lenerr;
;;;136        }
;;;137        if (inet_chksum_pbuf(p) != 0) {
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       inet_chksum_pbuf
00005c  2800              CMP      r0,#0
00005e  d157              BNE      |L2.272|
;;;138          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
;;;139          pbuf_free(p);
;;;140          ICMP_STATS_INC(icmp.chkerr);
;;;141          snmp_inc_icmpinerrors();
;;;142          return;
;;;143        }
;;;144    #if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
;;;145        if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
000060  2122              MOVS     r1,#0x22
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       pbuf_header
000068  2800              CMP      r0,#0
00006a  d029              BEQ      |L2.192|
;;;146          /* p is not big enough to contain link headers
;;;147           * allocate a new one and copy p into it
;;;148           */
;;;149          struct pbuf *r;
;;;150          /* switch p->payload to ip header */
;;;151          if (pbuf_header(p, hlen)) {
00006c  4639              MOV      r1,r7
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       pbuf_header
000074  b108              CBZ      r0,|L2.122|
;;;152            LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
000076  a02a              ADR      r0,|L2.288|
;;;153            goto memerr;
000078  e03c              B        |L2.244|
                  |L2.122|
;;;154          }
;;;155          /* allocate new packet buffer with space for link headers */
;;;156          r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
00007a  8921              LDRH     r1,[r4,#8]
00007c  2200              MOVS     r2,#0
00007e  2002              MOVS     r0,#2
000080  f7fffffe          BL       pbuf_alloc
000084  0006              MOVS     r6,r0
;;;157          if (r == NULL) {
000086  d043              BEQ      |L2.272|
;;;158            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
;;;159            goto memerr;
;;;160          }
;;;161          LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
000088  8971              LDRH     r1,[r6,#0xa]
00008a  f1070008          ADD      r0,r7,#8
00008e  4281              CMP      r1,r0
000090  d202              BCS      |L2.152|
000092  a030              ADR      r0,|L2.340|
000094  f7fffffe          BL       __2printf
                  |L2.152|
;;;162                      (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
;;;163          /* copy the whole packet including ip header */
;;;164          if (pbuf_copy(r, p) != ERR_OK) {
000098  4621              MOV      r1,r4
00009a  4630              MOV      r0,r6
00009c  f7fffffe          BL       pbuf_copy
0000a0  b108              CBZ      r0,|L2.166|
;;;165            LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
0000a2  a03a              ADR      r0,|L2.396|
;;;166            goto memerr;
0000a4  e026              B        |L2.244|
                  |L2.166|
;;;167          }
;;;168          iphdr = (struct ip_hdr *)r->payload;
0000a6  4641              MOV      r1,r8
;;;169          /* switch r->payload back to icmp header */
;;;170          if (pbuf_header(r, -hlen)) {
0000a8  4630              MOV      r0,r6
0000aa  6875              LDR      r5,[r6,#4]
0000ac  f7fffffe          BL       pbuf_header
0000b0  b108              CBZ      r0,|L2.182|
                  |L2.178|
;;;171            LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
0000b2  a040              ADR      r0,|L2.436|
;;;172            goto memerr;
0000b4  e01e              B        |L2.244|
                  |L2.182|
;;;173          }
;;;174          /* free the original p */
;;;175          pbuf_free(p);
0000b6  4620              MOV      r0,r4
0000b8  f7fffffe          BL       pbuf_free
;;;176          /* we now have an identical copy of p that has room for link headers */
;;;177          p = r;
0000bc  4634              MOV      r4,r6
;;;178        } else {
0000be  e006              B        |L2.206|
                  |L2.192|
;;;179          /* restore p->payload to point to icmp header */
;;;180          if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
0000c0  f06f0121          MVN      r1,#0x21
0000c4  4620              MOV      r0,r4
0000c6  f7fffffe          BL       pbuf_header
0000ca  2800              CMP      r0,#0
0000cc  d1f1              BNE      |L2.178|
                  |L2.206|
;;;181            LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
;;;182            goto memerr;
;;;183          }
;;;184        }
;;;185    #endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
;;;186        /* At this point, all checks are OK. */
;;;187        /* We generate an answer by switching the dest and src ip addresses,
;;;188         * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
;;;189        iecho = (struct icmp_echo_hdr *)p->payload;
;;;190        ip_addr_copy(iphdr->src, *ip_current_dest_addr());
0000ce  6860              LDR      r0,[r4,#4]
0000d0  f8d91000          LDR      r1,[r9,#0]  ; current_iphdr_dest
0000d4  60e9              STR      r1,[r5,#0xc]
;;;191        ip_addr_copy(iphdr->dest, *ip_current_src_addr());
0000d6  4944              LDR      r1,|L2.488|
;;;192        ICMPH_TYPE_SET(iecho, ICMP_ER);
0000d8  2600              MOVS     r6,#0
0000da  6809              LDR      r1,[r1,#0]            ;191  ; current_iphdr_src
0000dc  6129              STR      r1,[r5,#0x10]         ;191
0000de  7006              STRB     r6,[r0,#0]
;;;193    #if CHECKSUM_GEN_ICMP
;;;194        /* adjust the checksum */
;;;195        if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
;;;196          iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
;;;197        } else {
;;;198          iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
;;;199        }
;;;200    #else /* CHECKSUM_GEN_ICMP */
;;;201        iecho->chksum = 0;
0000e0  8046              STRH     r6,[r0,#2]
;;;202    #endif /* CHECKSUM_GEN_ICMP */
;;;203        
;;;204        /* Set the correct TTL and recalculate the header checksum. */
;;;205        IPH_TTL_SET(iphdr, ICMP_TTL);
0000e2  20ff              MOVS     r0,#0xff
0000e4  7228              STRB     r0,[r5,#8]
;;;206        IPH_CHKSUM_SET(iphdr, 0);
0000e6  816e              STRH     r6,[r5,#0xa]
;;;207    #if CHECKSUM_GEN_IP
;;;208        IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
;;;209    #endif /* CHECKSUM_GEN_IP */
;;;210    
;;;211        ICMP_STATS_INC(icmp.xmit);
;;;212        /* increase number of messages attempted to send */
;;;213        snmp_inc_icmpoutmsgs();
;;;214        /* increase number of echo replies attempted to send */
;;;215        snmp_inc_icmpoutechoreps();
;;;216    
;;;217        if(pbuf_header(p, hlen)) {
0000e8  4639              MOV      r1,r7
0000ea  4620              MOV      r0,r4
0000ec  f7fffffe          BL       pbuf_header
0000f0  b118              CBZ      r0,|L2.250|
;;;218          LWIP_ASSERT("Can't move over header in packet", 0);
0000f2  a03e              ADR      r0,|L2.492|
                  |L2.244|
0000f4  f7fffffe          BL       __2printf
0000f8  e00a              B        |L2.272|
                  |L2.250|
;;;219        } else {
;;;220          err_t ret;
;;;221          /* send an ICMP packet, src addr is the dest addr of the curren packet */
;;;222          ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL,
0000fa  2101              MOVS     r1,#1
0000fc  e9cd6100          STRD     r6,r1,[sp,#0]
000100  23ff              MOVS     r3,#0xff
000102  2200              MOVS     r2,#0
000104  f8cda008          STR      r10,[sp,#8]
000108  4904              LDR      r1,|L2.284|
00010a  4620              MOV      r0,r4
00010c  f7fffffe          BL       ip_output_if
                  |L2.272|
;;;223                       ICMP_TTL, 0, IP_PROTO_ICMP, inp);
;;;224          if (ret != ERR_OK) {
;;;225            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
;;;226          }
;;;227        }
;;;228        break;
;;;229      default:
;;;230        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
;;;231                    (s16_t)type, (s16_t)code));
;;;232        ICMP_STATS_INC(icmp.proterr);
;;;233        ICMP_STATS_INC(icmp.drop);
;;;234      }
;;;235      pbuf_free(p);
;;;236      return;
;;;237    lenerr:
;;;238      pbuf_free(p);
;;;239      ICMP_STATS_INC(icmp.lenerr);
;;;240      snmp_inc_icmpinerrors();
;;;241      return;
;;;242    #if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
;;;243    memerr:
;;;244      pbuf_free(p);
000110  4620              MOV      r0,r4
000112  e8bd4ffe          POP      {r1-r11,lr}
000116  f7ffbffe          B.W      pbuf_free
;;;245      ICMP_STATS_INC(icmp.err);
;;;246      snmp_inc_icmpinerrors();
;;;247      return;
;;;248    #endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
;;;249    }
;;;250    
                          ENDP

00011a  0000              DCW      0x0000
                  |L2.284|
                          DCD      current_iphdr_dest
                  |L2.288|
000120  69636d70          DCB      "icmp_input: moving p->payload to ip header failed\n",0
000124  5f696e70
000128  75743a20
00012c  6d6f7669
000130  6e672070
000134  2d3e7061
000138  796c6f61
00013c  6420746f
000140  20697020
000144  68656164
000148  65722066
00014c  61696c65
000150  640a00  
000153  00                DCB      0
                  |L2.340|
000154  63686563          DCB      "check that first pbuf can hold struct the ICMP header",0
000158  6b207468
00015c  61742066
000160  69727374
000164  20706275
000168  66206361
00016c  6e20686f
000170  6c642073
000174  74727563
000178  74207468
00017c  65204943
000180  4d502068
000184  65616465
000188  7200    
00018a  00                DCB      0
00018b  00                DCB      0
                  |L2.396|
00018c  69636d70          DCB      "icmp_input: copying to new pbuf failed\n",0
000190  5f696e70
000194  75743a20
000198  636f7079
00019c  696e6720
0001a0  746f206e
0001a4  65772070
0001a8  62756620
0001ac  6661696c
0001b0  65640a00
                  |L2.436|
0001b4  69636d70          DCB      "icmp_input: restoring original p->payload failed\n",0
0001b8  5f696e70
0001bc  75743a20
0001c0  72657374
0001c4  6f72696e
0001c8  67206f72
0001cc  6967696e
0001d0  616c2070
0001d4  2d3e7061
0001d8  796c6f61
0001dc  64206661
0001e0  696c6564
0001e4  0a00    
0001e6  00                DCB      0
0001e7  00                DCB      0
                  |L2.488|
                          DCD      current_iphdr_src
                  |L2.492|
0001ec  43616e27          DCB      "Can't move over header in packet",0
0001f0  74206d6f
0001f4  7665206f
0001f8  76657220
0001fc  68656164
000200  65722069
000204  6e207061
000208  636b6574
00020c  00      
00020d  00                DCB      0
00020e  00                DCB      0
00020f  00                DCB      0

                          AREA ||i.icmp_send_response||, CODE, READONLY, ALIGN=2

                  icmp_send_response PROC
;;;290    static void
;;;291    icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;292    {
000004  4691              MOV      r9,r2
000006  460e              MOV      r6,r1
000008  4607              MOV      r7,r0
;;;293      struct pbuf *q;
;;;294      struct ip_hdr *iphdr;
;;;295      /* we can use the echo header here */
;;;296      struct icmp_echo_hdr *icmphdr;
;;;297      ip_addr_t iphdr_src;
;;;298    
;;;299      /* ICMP header + IP header + 8 bytes of data */
;;;300      q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
00000a  2200              MOVS     r2,#0
00000c  2124              MOVS     r1,#0x24
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       pbuf_alloc
000014  0005              MOVS     r5,r0
;;;301                     PBUF_RAM);
;;;302      if (q == NULL) {
000016  d029              BEQ      |L3.108|
;;;303        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
;;;304        return;
;;;305      }
;;;306      LWIP_ASSERT("check that first pbuf can hold icmp message",
000018  8968              LDRH     r0,[r5,#0xa]
00001a  2824              CMP      r0,#0x24
00001c  d202              BCS      |L3.36|
00001e  a014              ADR      r0,|L3.112|
000020  f7fffffe          BL       __2printf
                  |L3.36|
;;;307                 (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));
;;;308    
;;;309      iphdr = (struct ip_hdr *)p->payload;
;;;310      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded from "));
;;;311      ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
;;;312      LWIP_DEBUGF(ICMP_DEBUG, (" to "));
;;;313      ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
;;;314      LWIP_DEBUGF(ICMP_DEBUG, ("\n"));
;;;315    
;;;316      icmphdr = (struct icmp_echo_hdr *)q->payload;
;;;317      icmphdr->type = type;
000024  686c              LDR      r4,[r5,#4]
000026  f8d78004          LDR      r8,[r7,#4]            ;316
;;;318      icmphdr->code = code;
;;;319      icmphdr->id = 0;
;;;320      icmphdr->seqno = 0;
;;;321    
;;;322      /* copy fields from original packet */
;;;323      SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
00002a  221c              MOVS     r2,#0x1c
00002c  7026              STRB     r6,[r4,#0]            ;317
00002e  f8849001          STRB     r9,[r4,#1]            ;318
000032  2600              MOVS     r6,#0                 ;319
000034  80a6              STRH     r6,[r4,#4]            ;319
000036  80e6              STRH     r6,[r4,#6]            ;320
000038  6868              LDR      r0,[r5,#4]
00003a  6879              LDR      r1,[r7,#4]
00003c  3008              ADDS     r0,r0,#8
00003e  f7fffffe          BL       __aeabi_memcpy
;;;324              IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);
;;;325    
;;;326      /* calculate checksum */
;;;327      icmphdr->chksum = 0;
000042  8066              STRH     r6,[r4,#2]
;;;328      icmphdr->chksum = inet_chksum(icmphdr, q->len);
000044  8969              LDRH     r1,[r5,#0xa]
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       inet_chksum
00004c  8060              STRH     r0,[r4,#2]
;;;329      ICMP_STATS_INC(icmp.xmit);
;;;330      /* increase number of messages attempted to send */
;;;331      snmp_inc_icmpoutmsgs();
;;;332      /* increase number of destination unreachable messages attempted to send */
;;;333      snmp_inc_icmpouttimeexcds();
;;;334      ip_addr_copy(iphdr_src, iphdr->src);
00004e  f8d8000c          LDR      r0,[r8,#0xc]
;;;335      ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
000052  9002              STR      r0,[sp,#8]
000054  2001              MOVS     r0,#1
000056  e9cd6000          STRD     r6,r0,[sp,#0]
00005a  23ff              MOVS     r3,#0xff
00005c  aa02              ADD      r2,sp,#8
00005e  2100              MOVS     r1,#0
000060  4628              MOV      r0,r5
000062  f7fffffe          BL       ip_output
;;;336      pbuf_free(q);
000066  4628              MOV      r0,r5
000068  f7fffffe          BL       pbuf_free
                  |L3.108|
;;;337    }
00006c  e8bd83fe          POP      {r1-r9,pc}
;;;338    
                          ENDP

                  |L3.112|
000070  63686563          DCB      "check that first pbuf can hold icmp message",0
000074  6b207468
000078  61742066
00007c  69727374
000080  20706275
000084  66206361
000088  6e20686f
00008c  6c642069
000090  636d7020
000094  6d657373
000098  61676500

                          AREA ||i.icmp_time_exceeded||, CODE, READONLY, ALIGN=1

                  icmp_time_exceeded PROC
;;;274    void
;;;275    icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
000000  460a              MOV      r2,r1
;;;276    {
;;;277      icmp_send_response(p, ICMP_TE, t);
000002  210b              MOVS     r1,#0xb
000004  f7ffbffe          B.W      icmp_send_response
;;;278    }
;;;279    
                          ENDP


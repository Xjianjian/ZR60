; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\memif.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\memif.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\ZR60_v1.0_freeRTOS -I..\..\Lwip\App -I..\..\Lwip\Bsp -I..\..\Lwip\Bsp\LAN8742A -I..\..\Lwip\lwip-1.4.1 -I..\..\Lwip\lwip-1.4.1\port -I..\..\Lwip\lwip-1.4.1\port\arch -I..\..\Lwip\lwip-1.4.1\port\Standalone -I..\..\Lwip\lwip-1.4.1\src\include -I..\..\Lwip\lwip-1.4.1\src\include\ipv4 -I..\..\Lwip\lwip-1.4.1\src\include\lwip -I..\..\Lwip\lwip-1.4.1\src\include\netif -I..\..\Ecal\BtnFltr -I..\..\Ecal\UartComn -I..\..\Ecal\MemIf -I..\..\APP -I..\..\APP\BlackListMng -I..\..\APP\SeverNewsPush -I..\..\APP\NewsPull -I..\..\Ecal -I..\..\Ecal\JsonIf -I..\..\Ecal\Mcu_Init -I..\..\Service -I..\..\Complex -I..\..\Complex\FATFS -I..\..\FreeRTOS\Source\include -I..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\FreeRTOS -I.\RTE\_ZR60 -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=..\..\output\memif.crf ..\..\Ecal\MemIf\MemIf.c]
                          THUMB

                          AREA ||i.GetMemIf_u_DtVild||, CODE, READONLY, ALIGN=2

                  GetMemIf_u_DtVild PROC
;;;400    ******************************************************/
;;;401    uint8 GetMemIf_u_DtVild(uint8 Obj)
000000  4906              LDR      r1,|L1.28|
;;;402    {
000002  b510              PUSH     {r4,lr}
;;;403    	uint8 VildFlag = 0U;
;;;404    	VildFlag = MemIfCfg_FLASH_ReadByte((uint32)CaEepromCfg_Conf[Obj].SecAddr);//读取扇区100数据有效性标志（存放已注销卡卡号信息）
000004  eb011000          ADD      r0,r1,r0,LSL #4
000008  6840              LDR      r0,[r0,#4]
00000a  f7fffffe          BL       MemIfCfg_FLASH_ReadByte
;;;405    	if(EE_VALID_FIELD_VALUE == VildFlag)//flash数据有效
00000e  2855              CMP      r0,#0x55
000010  d001              BEQ      |L1.22|
;;;406    	{
;;;407    		return 1U;
;;;408    	}
;;;409    	return 0U;
000012  2000              MOVS     r0,#0
;;;410    }
000014  bd10              POP      {r4,pc}
                  |L1.22|
000016  2001              MOVS     r0,#1                 ;407
000018  bd10              POP      {r4,pc}
;;;411    
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      CaEepromCfg_Conf

                          AREA ||i.GetMemIf_u_EEVild||, CODE, READONLY, ALIGN=2

                  GetMemIf_u_EEVild PROC
;;;341    ******************************************************/
;;;342    uint8 GetMemIf_u_EEVild(uint8 Object)
000000  4901              LDR      r1,|L2.8|
;;;343    {
;;;344    	return SeMemIf_u_VildFlag[Object];
000002  5c08              LDRB     r0,[r1,r0]
;;;345    }
000004  4770              BX       lr
;;;346    
                          ENDP

000006  0000              DCW      0x0000
                  |L2.8|
                          DCD      ||.bss||+0xa8

                          AREA ||i.GetMemIf_u_Idle||, CODE, READONLY, ALIGN=2

                  GetMemIf_u_Idle PROC
;;;374    ******************************************************/
;;;375    uint8 GetMemIf_u_Idle(void)
000000  2001              MOVS     r0,#1
;;;376    {
;;;377    	uint8 ret = 1U;
;;;378    	uint8 Le_u_i;
;;;379    	for(Le_u_i = 0U;Le_u_i < EE_OBJECT_NUM;Le_u_i++)
;;;380    	{
;;;381    		if(EE_IDLE != SeMemIf_u_EESt[Le_u_i])
000002  4a05              LDR      r2,|L3.24|
000004  2100              MOVS     r1,#0                 ;379
                  |L3.6|
000006  5c53              LDRB     r3,[r2,r1]
000008  b10b              CBZ      r3,|L3.14|
;;;382    		{
;;;383    			 ret = 0U;
00000a  2000              MOVS     r0,#0
;;;384    			 break;
;;;385    		}		
;;;386    	}
;;;387    	return ret;
;;;388    }
00000c  4770              BX       lr
                  |L3.14|
00000e  1c49              ADDS     r1,r1,#1
000010  b2c9              UXTB     r1,r1                 ;379
000012  2911              CMP      r1,#0x11              ;379
000014  d3f7              BCC      |L3.6|
000016  4770              BX       lr
;;;389    
                          ENDP

                  |L3.24|
                          DCD      ||.bss||+0x64

                          AREA ||i.GetMemIf_w_DtLng||, CODE, READONLY, ALIGN=2

                  GetMemIf_w_DtLng PROC
;;;422    ******************************************************/
;;;423    uint16 GetMemIf_w_DtLng(uint8 Obj)
000000  b570              PUSH     {r4-r6,lr}
;;;424    {
;;;425    	uint16 LeMemIf_w_Lng = 0U;
;;;426    	LeMemIf_w_Lng = MemIfCfg_FLASH_ReadByte((uint32)(CaEepromCfg_Conf[Obj].SecAddr + 1));
000002  4908              LDR      r1,|L4.36|
000004  eb011400          ADD      r4,r1,r0,LSL #4
000008  6860              LDR      r0,[r4,#4]
00000a  1c40              ADDS     r0,r0,#1
00000c  f7fffffe          BL       MemIfCfg_FLASH_ReadByte
;;;427    	LeMemIf_w_Lng = LeMemIf_w_Lng <<8U;
000010  f64f71ff          MOV      r1,#0xffff
000014  ea012500          AND      r5,r1,r0,LSL #8
;;;428    	LeMemIf_w_Lng = (LeMemIf_w_Lng | MemIfCfg_FLASH_ReadByte((uint32)CaEepromCfg_Conf[Obj].SecAddr +2));
000018  6860              LDR      r0,[r4,#4]
00001a  1c80              ADDS     r0,r0,#2
00001c  f7fffffe          BL       MemIfCfg_FLASH_ReadByte
000020  4328              ORRS     r0,r0,r5
;;;429    	return LeMemIf_w_Lng;
;;;430    }
000022  bd70              POP      {r4-r6,pc}
;;;431    
                          ENDP

                  |L4.36|
                          DCD      CaEepromCfg_Conf

                          AREA ||i.MemIf_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  MemIf_Init PROC
;;;55     ******************************************************/
;;;56     void MemIf_Init(void)
000000  b510              PUSH     {r4,lr}
;;;57     {
;;;58     	uint8 byte[2U];
;;;59     	uint8 Le_u_i;
;;;60     	for(Le_u_i = 0U;Le_u_i < EE_OBJECT_NUM;Le_u_i++)
;;;61     	{
;;;62     		SeMemIf_u_EESt[Le_u_i] = EE_IDLE;
000002  4a12              LDR      r2,|L5.76|
000004  2000              MOVS     r0,#0                 ;60
000006  4601              MOV      r1,r0                 ;60
;;;63     		SeMemIf_u_WrEEFlag[Le_u_i] = 0U;
000008  f1020311          ADD      r3,r2,#0x11
;;;64     		SeMemIf_u_VildFlag[Le_u_i] = 0U;//数据无效
00000c  f1020444          ADD      r4,r2,#0x44
                  |L5.16|
000010  5411              STRB     r1,[r2,r0]            ;62
000012  5419              STRB     r1,[r3,r0]            ;63
000014  5421              STRB     r1,[r4,r0]
000016  1c40              ADDS     r0,r0,#1
000018  b2c0              UXTB     r0,r0                 ;60
00001a  2811              CMP      r0,#0x11              ;60
00001c  d3f8              BCC      |L5.16|
;;;65     #if 0
;;;66     		MemIfCfg_FLASH_SectorErase((uint32)(CaEepromCfg_Conf[Le_u_i].SecAddr));
;;;67     		while(0U != SPI_FLASH_WrInProgStatus());
;;;68     #endif
;;;69     	}
;;;70     	byte[0]  = W25QXX_ReadSR(W25X_ReadStatusReg);
00001e  2005              MOVS     r0,#5
000020  f7fffffe          BL       W25QXX_ReadSR
000024  4601              MOV      r1,r0
;;;71     	printf("W25X_ReadStatusReg:%d\n",byte[0]);
000026  a00a              ADR      r0,|L5.80|
000028  f7fffffe          BL       __2printf
;;;72     	byte[1]  = W25QXX_ReadSR(W25X_ReadStatusRegTwo);
00002c  2035              MOVS     r0,#0x35
00002e  f7fffffe          BL       W25QXX_ReadSR
000032  4601              MOV      r1,r0
;;;73     	printf("W25X_ReadStatusRegTwo:%d\n",byte[1]);
000034  a00c              ADR      r0,|L5.104|
000036  f7fffffe          BL       __2printf
;;;74     	byte[1]  = W25QXX_ReadSR(W25X_ReadStatusRegThr);
00003a  2015              MOVS     r0,#0x15
00003c  f7fffffe          BL       W25QXX_ReadSR
000040  4601              MOV      r1,r0
;;;75     	printf("W25X_ReadStatusRegThr:%d\n",byte[1]);
000042  e8bd4010          POP      {r4,lr}
000046  a00f              ADR      r0,|L5.132|
000048  f7ffbffe          B.W      __2printf
;;;76     }
;;;77     
                          ENDP

                  |L5.76|
                          DCD      ||.bss||+0x64
                  |L5.80|
000050  57323558          DCB      "W25X_ReadStatusReg:%d\n",0
000054  5f526561
000058  64537461
00005c  74757352
000060  65673a25
000064  640a00  
000067  00                DCB      0
                  |L5.104|
000068  57323558          DCB      "W25X_ReadStatusRegTwo:%d\n",0
00006c  5f526561
000070  64537461
000074  74757352
000078  65675477
00007c  6f3a2564
000080  0a00    
000082  00                DCB      0
000083  00                DCB      0
                  |L5.132|
000084  57323558          DCB      "W25X_ReadStatusRegThr:%d\n",0
000088  5f526561
00008c  64537461
000090  74757352
000094  65675468
000098  723a2564
00009c  0a00    
00009e  00                DCB      0
00009f  00                DCB      0

                          AREA ||i.MemIf_ReadEE||, CODE, READONLY, ALIGN=2

                  MemIf_ReadEE PROC
;;;251    ******************************************************/
;;;252    uint8 MemIf_ReadEE(uint8 Le_u_Object,uint8* Le_u_Data,uint16 Le_w_Lng)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;253    {
000004  4616              MOV      r6,r2
000006  460f              MOV      r7,r1
;;;254    	uint8 Le_u_ok = 0U;
;;;255    	uint16 Le_w_i = 0U;
;;;256    	//uint8 Le_u_ValidFlag = 0U;
;;;257    	switch(CaEepromCfg_Conf[Le_u_Object].Space)
000008  4a0b              LDR      r2,|L6.56|
00000a  4601              MOV      r1,r0                 ;253
00000c  eb021501          ADD      r5,r2,r1,LSL #4
000010  2000              MOVS     r0,#0                 ;254
000012  7829              LDRB     r1,[r5,#0]
000014  4604              MOV      r4,r0                 ;255
000016  2900              CMP      r1,#0                 ;253
000018  d00c              BEQ      |L6.52|
00001a  2901              CMP      r1,#1
00001c  d10a              BNE      |L6.52|
00001e  e006              B        |L6.46|
                  |L6.32|
;;;258    	{
;;;259    
;;;260    		case EepromCfg_IntEE:/*读片上eeprom*/
;;;261    		{
;;;262    #if 0			
;;;263    			MemIfCfg_FLASH_Unlock();/*eeprom解锁保护*/
;;;264    			Le_u_ValidFlag = MemIfCfg_FLASH_ReadByte(EEPROM_START_ADDR);/*读取数据有效性标志字节*/
;;;265    			if((CaEepromCfg_Conf[Le_u_Object].Lng == Le_u_Lng) && (CaEepromCfg_Conf[Le_u_Object].Mask & Le_u_ValidFlag))
;;;266    			{
;;;267    				for(Le_w_i=0; Le_w_i < Le_u_Lng; Le_w_i++)
;;;268    				{
;;;269    					Le_u_Data[Le_w_i] = MemIfCfg_FLASH_ReadByte(CaEepromCfg_Conf[Le_u_Object].Addr + Le_w_i);			
;;;270    				}
;;;271    				Le_u_ok = 1U;
;;;272    			}
;;;273    			MemIfCfg_FLASH_Lock();/*eeprom加锁保护*/
;;;274    #endif
;;;275    		}
;;;276    		break;
;;;277    		case EepromCfg_ExtEE:/*读片外eeprom*/
;;;278    		{
;;;279    			for(Le_w_i=0; Le_w_i < Le_w_Lng; Le_w_i++)
;;;280    			{
;;;281    				Le_u_Data[Le_w_i] = MemIfCfg_FLASH_ReadByte(CaEepromCfg_Conf[Le_u_Object].DtAddr + Le_w_i);			
000020  68a8              LDR      r0,[r5,#8]
000022  4420              ADD      r0,r0,r4
000024  f7fffffe          BL       MemIfCfg_FLASH_ReadByte
000028  5538              STRB     r0,[r7,r4]
00002a  1c64              ADDS     r4,r4,#1
00002c  b2a4              UXTH     r4,r4                 ;279
                  |L6.46|
00002e  42b4              CMP      r4,r6                 ;279
000030  d3f6              BCC      |L6.32|
;;;282    			}
;;;283    			Le_u_ok = 1U;
000032  2001              MOVS     r0,#1
                  |L6.52|
;;;284    		}
;;;285    		break;
;;;286    		default:
;;;287    		break;
;;;288    	}
;;;289    	return Le_u_ok;
;;;290    }
000034  e8bd81f0          POP      {r4-r8,pc}
;;;291    
                          ENDP

                  |L6.56|
                          DCD      CaEepromCfg_Conf

                          AREA ||i.MemIf_Timer||, CODE, READONLY, ALIGN=2

                  MemIf_Timer PROC
;;;434    */
;;;435    void MemIf_Timer(void)
000000  4802              LDR      r0,|L7.12|
;;;436    {
;;;437    	SeMemIf_dw_Timer++;
000002  6841              LDR      r1,[r0,#4]  ; SeMemIf_dw_Timer
000004  1c49              ADDS     r1,r1,#1
000006  6041              STR      r1,[r0,#4]  ; SeMemIf_dw_Timer
;;;438    }
000008  4770              BX       lr
;;;439    
                          ENDP

00000a  0000              DCW      0x0000
                  |L7.12|
                          DCD      ||.data||

                          AREA ||i.MemIf_WriteEE||, CODE, READONLY, ALIGN=2

                  MemIf_WriteEE PROC
;;;196    ******************************************************/
;;;197    uint8 MemIf_WriteEE(uint8 Le_u_Object,void* Le_u_Data,uint16 Le_w_Lng)
000000  4b08              LDR      r3,|L8.36|
;;;198    {
;;;199    	uint8 Le_u_ok = 0U;
000002  2100              MOVS     r1,#0
;;;200    	//uint8 Le_u_i = 0U;
;;;201    	//uint8 Le_u_ValidFlag = 0U;
;;;202    	
;;;203    	switch(CaEepromCfg_Conf[Le_u_Object].Space)
000004  eb031300          ADD      r3,r3,r0,LSL #4
000008  781b              LDRB     r3,[r3,#0]
00000a  b14b              CBZ      r3,|L8.32|
00000c  2b01              CMP      r3,#1
00000e  d107              BNE      |L8.32|
;;;204    	{
;;;205    		case EepromCfg_IntEE:/*写片上eeprom*/
;;;206    		{
;;;207    #if 0
;;;208    			MemIfCfg_FLASH_Unlock();/*eeprom解锁保护*/
;;;209    			Le_u_ValidFlag = MemIfCfg_FLASH_ReadByte(EEPROM_START_ADDR);/*读取数据有效性标志字节*/
;;;210    			Le_u_ValidFlag &= (~CaEepromCfg_Conf[Le_u_Object].Mask);
;;;211    			MemIfCfg_FLASH_ProgramByte(EEPROM_START_ADDR,Le_u_ValidFlag);/*清数据有效性标志位*/
;;;212    			if(CaEepromCfg_Conf[Le_u_Object].Lng == Le_u_Lng)
;;;213    			{
;;;214    				for(Le_u_i=0; Le_u_i < Le_u_Lng; Le_u_i++)//将数据写入EEPROM中
;;;215    				{
;;;216    					MemIfCfg_FLASH_ProgramByte((CaEepromCfg_Conf[Le_u_Object].Addr + Le_u_i), Le_u_Data[Le_u_i]);			
;;;217    				}
;;;218    				Le_u_ValidFlag |= CaEepromCfg_Conf[Le_u_Object].Mask;
;;;219    				MemIfCfg_FLASH_ProgramByte(EEPROM_START_ADDR,Le_u_ValidFlag);/*置位数据有效性标志位*/
;;;220    				Le_u_ok = 1U;
;;;221    			}
;;;222    			MemIfCfg_FLASH_Lock();/*eeprom加锁保护*/
;;;223    #endif
;;;224    		}
;;;225    		break;
;;;226    		case EepromCfg_ExtEE:/*写片外eeprom*/
;;;227    		{
;;;228    			SeMemIf_u_WrEEFlag[Le_u_Object] = 1U;
000010  4b05              LDR      r3,|L8.40|
000012  2101              MOVS     r1,#1
000014  5419              STRB     r1,[r3,r0]
;;;229    			SeMemIf_w_Lng[Le_u_Object] = Le_w_Lng;
000016  f1030111          ADD      r1,r3,#0x11
00001a  f8212010          STRH     r2,[r1,r0,LSL #1]
;;;230    			Le_u_ok = 1U;
00001e  2101              MOVS     r1,#1
                  |L8.32|
;;;231    		}
;;;232    		break;
;;;233    		default:
;;;234    		break;
;;;235    	}
;;;236    	
;;;237    	return  Le_u_ok;	
000020  4608              MOV      r0,r1
;;;238    }
000022  4770              BX       lr
;;;239    
                          ENDP

                  |L8.36|
                          DCD      CaEepromCfg_Conf
                  |L8.40|
                          DCD      ||.bss||+0x75

                          AREA ||i.SetMemIf_EEVild||, CODE, READONLY, ALIGN=2

                  SetMemIf_EEVild PROC
;;;358    ******************************************************/
;;;359    void SetMemIf_EEVild(uint8 Object)
000000  4a01              LDR      r2,|L9.8|
;;;360    {
;;;361    	SeMemIf_u_VildFlag[Object] = 1U;
000002  2101              MOVS     r1,#1
000004  5411              STRB     r1,[r2,r0]
;;;362    }
000006  4770              BX       lr
;;;363    
                          ENDP

                  |L9.8|
                          DCD      ||.bss||+0xa8

                          AREA ||i.TskMemIf_MainFunction||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  TskMemIf_MainFunction PROC
;;;88     ******************************************************/
;;;89     void TskMemIf_MainFunction(void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;90     {
;;;91     	uint16 Le_w_Lng;
;;;92     	uint8 Le_u_Obj;
;;;93     	//uint8 Le_u_Object;
;;;94     	uint8* Le_u_ptr;
;;;95     	uint8 LeMemIfCfg_u_Xor = 0U;
;;;96     	uint8 Le_u_Xor = 0U;
;;;97     	
;;;98     	for(Le_u_Obj = 0U;Le_u_Obj < EE_OBJECT_NUM;Le_u_Obj++)
;;;99     	{
;;;100    		switch(SeMemIf_u_EESt[Le_u_Obj])
000004  f8df9160          LDR      r9,|L10.360|
000008  2600              MOVS     r6,#0                 ;95
;;;101    		{
;;;102    			case EE_IDLE:
;;;103    			{
;;;104    				if(1U == SeMemIf_u_WrEEFlag[Le_u_Obj])//数据更新
;;;105    				{
;;;106    					SeMemIf_u_EESt[Le_u_Obj] = EE_ERASE;
;;;107    				}			
;;;108    			}
;;;109    			break;
;;;110    			case EE_ERASE:
;;;111    			{
;;;112    				if(1U == MemIfCfg_FLASH_IDLE())//空闲，可擦除
;;;113    				{
;;;114    					MemIfCfg_FLASH_Unlock();//解除写保护,20180619 by liujian
;;;115    					MemIfCfg_FLASH_SectorErase((uint32)(CaEepromCfg_Conf[Le_u_Obj].SecAddr));
00000a  f8dfb160          LDR      r11,|L10.364|
00000e  4634              MOV      r4,r6                 ;98
;;;116    					SeMemIf_u_EESt[Le_u_Obj] = EE_WR;
;;;117    				}
;;;118    			}
;;;119    			break;
;;;120    			case EE_WR:
;;;121    			{
;;;122    				if(1U == MemIfCfg_FLASH_IDLE())//空闲，可写
;;;123    				{
;;;124    					MemIfCfg_FLASH_Unlock();//解除写保护,20180619 by liujian
;;;125    					Le_u_ptr = CaEepromCfg_Conf[Le_u_Obj].Data;
;;;126    					for(Le_w_Lng =0U; Le_w_Lng < SeMemIf_w_Lng[Le_u_Obj]; Le_w_Lng++)//将数据写入EEPROM中
000010  f1090a22          ADD      r10,r9,#0x22
                  |L10.20|
000014  f8190004          LDRB     r0,[r9,r4]            ;100
000018  b120              CBZ      r0,|L10.36|
00001a  2801              CMP      r0,#1                 ;100
00001c  d008              BEQ      |L10.48|
00001e  2802              CMP      r0,#2                 ;100
000020  d14c              BNE      |L10.188|
000022  e014              B        |L10.78|
                  |L10.36|
000024  4850              LDR      r0,|L10.360|
000026  3011              ADDS     r0,r0,#0x11           ;104
000028  5d00              LDRB     r0,[r0,r4]            ;104
00002a  2801              CMP      r0,#1                 ;104
00002c  d044              BEQ      |L10.184|
00002e  e045              B        |L10.188|
                  |L10.48|
000030  f7fffffe          BL       MemIfCfg_FLASH_IDLE
000034  2801              CMP      r0,#1                 ;112
000036  d141              BNE      |L10.188|
000038  f7fffffe          BL       MemIfCfg_FLASH_Unlock
00003c  eb0b1004          ADD      r0,r11,r4,LSL #4      ;115
000040  6840              LDR      r0,[r0,#4]            ;115
000042  f7fffffe          BL       MemIfCfg_FLASH_SectorErase
000046  2102              MOVS     r1,#2                 ;116
000048  f8091004          STRB     r1,[r9,r4]            ;116
00004c  e036              B        |L10.188|
                  |L10.78|
00004e  f7fffffe          BL       MemIfCfg_FLASH_IDLE
000052  2801              CMP      r0,#1                 ;122
000054  d132              BNE      |L10.188|
000056  f7fffffe          BL       MemIfCfg_FLASH_Unlock
00005a  eb0b1704          ADD      r7,r11,r4,LSL #4      ;125
00005e  2500              MOVS     r5,#0
000060  f8d7800c          LDR      r8,[r7,#0xc]
000064  e00a              B        |L10.124|
                  |L10.102|
;;;127    					{
;;;128    						MemIfCfg_FLASH_ProgramByte((CaEepromCfg_Conf[Le_u_Obj].DtAddr + Le_w_Lng), Le_u_ptr[Le_w_Lng]);	
000066  68b8              LDR      r0,[r7,#8]
000068  f8181005          LDRB     r1,[r8,r5]
00006c  4428              ADD      r0,r0,r5
00006e  f7fffffe          BL       MemIfCfg_FLASH_ProgramByte
;;;129    						LeMemIfCfg_u_Xor ^= Le_u_ptr[Le_w_Lng];
000072  f8180005          LDRB     r0,[r8,r5]
000076  4046              EORS     r6,r6,r0
000078  1c6d              ADDS     r5,r5,#1
00007a  b2ad              UXTH     r5,r5                 ;126
                  |L10.124|
00007c  f83a0014          LDRH     r0,[r10,r4,LSL #1]    ;126
000080  42a8              CMP      r0,r5                 ;126
000082  d8f0              BHI      |L10.102|
;;;130    					}
;;;131    					LeMemIfCfg_u_Xor = (~LeMemIfCfg_u_Xor);
000084  43f0              MVNS     r0,r6
000086  b2c6              UXTB     r6,r0
;;;132    					MemIfCfg_FLASH_ProgramByte((uint32)(CaEepromCfg_Conf[Le_u_Obj].SecAddr + 1),(uint8)(SeMemIf_w_Lng[Le_u_Obj] >> 8U));/*有效数据长度信息高Byte*/
000088  f83a0014          LDRH     r0,[r10,r4,LSL #1]
00008c  4655              MOV      r5,r10
00008e  0a01              LSRS     r1,r0,#8
000090  6878              LDR      r0,[r7,#4]
000092  1c40              ADDS     r0,r0,#1
000094  f7fffffe          BL       MemIfCfg_FLASH_ProgramByte
;;;133    					MemIfCfg_FLASH_ProgramByte((uint32)(CaEepromCfg_Conf[Le_u_Obj].SecAddr + 2),(uint8)SeMemIf_w_Lng[Le_u_Obj]);/*有效数据长度信息低Byte*/
000098  6878              LDR      r0,[r7,#4]
00009a  f8151014          LDRB     r1,[r5,r4,LSL #1]
00009e  1c80              ADDS     r0,r0,#2
0000a0  f7fffffe          BL       MemIfCfg_FLASH_ProgramByte
;;;134    					MemIfCfg_FLASH_ProgramByte((uint32)(CaEepromCfg_Conf[Le_u_Obj].SecAddr),LeMemIfCfg_u_Xor);/*写校验和*/
0000a4  4631              MOV      r1,r6
0000a6  6878              LDR      r0,[r7,#4]
0000a8  f7fffffe          BL       MemIfCfg_FLASH_ProgramByte
;;;135    					MemIfCfg_FLASH_Lock();//开启写保护,20180619 by liujian
0000ac  f7fffffe          BL       MemIfCfg_FLASH_Lock
;;;136    					SeMemIf_u_WrEEFlag[Le_u_Obj] = 0U;
0000b0  492d              LDR      r1,|L10.360|
0000b2  2000              MOVS     r0,#0
0000b4  3111              ADDS     r1,r1,#0x11
0000b6  5508              STRB     r0,[r1,r4]
                  |L10.184|
;;;137    					SeMemIf_u_EESt[Le_u_Obj] = EE_IDLE;
0000b8  f8090004          STRB     r0,[r9,r4]
                  |L10.188|
0000bc  1c64              ADDS     r4,r4,#1
0000be  b2e4              UXTB     r4,r4                 ;98
0000c0  2c11              CMP      r4,#0x11              ;98
0000c2  d3a7              BCC      |L10.20|
;;;138    	#ifdef EE_DEBUG
;;;139    					SeMemIf_u_RdFlag = 1U;
;;;140    	#endif
;;;141    				}			
;;;142    			}
;;;143    			break;
;;;144    			default:
;;;145    			break;
;;;146    		}
;;;147    	}
;;;148    	
;;;149    	if(SeMemIf_dw_Timer >= 60000U)//大概5min
0000c4  4e2a              LDR      r6,|L10.368|
0000c6  f64e2160          MOV      r1,#0xea60
0000ca  6870              LDR      r0,[r6,#4]  ; SeMemIf_dw_Timer
0000cc  4288              CMP      r0,r1
0000ce  d347              BCC      |L10.352|
;;;150    	{
;;;151    		if(1U == MemIfCfg_FLASH_IDLE())//空闲
0000d0  f7fffffe          BL       MemIfCfg_FLASH_IDLE
0000d4  2801              CMP      r0,#1
0000d6  d13b              BNE      |L10.336|
;;;152    		{
;;;153    			SeMemIf_dw_Timer = 0U;
0000d8  f04f0800          MOV      r8,#0
;;;154    			Le_u_Xor = MemIfCfg_FLASH_ReadByte((uint32)(CaEepromCfg_Conf[CaEepromCfg_CheckSumObj[SeMemIf_u_CheckSumObj]].SecAddr));//读取扇区数据校验和
0000dc  f8c68004          STR      r8,[r6,#4]  ; SeMemIf_dw_Timer
0000e0  4f24              LDR      r7,|L10.372|
0000e2  7830              LDRB     r0,[r6,#0]  ; SeMemIf_u_CheckSumObj
0000e4  5c39              LDRB     r1,[r7,r0]
0000e6  eb0b1001          ADD      r0,r11,r1,LSL #4
0000ea  6840              LDR      r0,[r0,#4]
0000ec  f7fffffe          BL       MemIfCfg_FLASH_ReadByte
0000f0  4605              MOV      r5,r0
;;;155    			Le_w_Lng = CaEepromCfg_ObjDtLng[SeMemIf_u_CheckSumObj];
0000f2  4921              LDR      r1,|L10.376|
0000f4  7830              LDRB     r0,[r6,#0]  ; SeMemIf_u_CheckSumObj
0000f6  5c0c              LDRB     r4,[r1,r0]
;;;156    			if(Le_w_Lng <= 100U)
0000f8  2c64              CMP      r4,#0x64
0000fa  d82b              BHI      |L10.340|
;;;157    			{
;;;158    				(void)MemIf_ReadEE(CaEepromCfg_CheckSumObj[SeMemIf_u_CheckSumObj],SeMemIf_u_DataCache, \
0000fc  491a              LDR      r1,|L10.360|
0000fe  5c38              LDRB     r0,[r7,r0]
000100  4622              MOV      r2,r4
000102  3964              SUBS     r1,r1,#0x64
000104  f7fffffe          BL       MemIf_ReadEE
;;;159    								   Le_w_Lng);//读取flash数据
;;;160    				if(Le_u_Xor != GetMemIf_u_XOR(SeMemIf_u_DataCache,Le_w_Lng))
000108  4a17              LDR      r2,|L10.360|
00010a  3a64              SUBS     r2,r2,#0x64
00010c  2100              MOVS     r1,#0
00010e  4608              MOV      r0,r1
000110  e003              B        |L10.282|
                  |L10.274|
000112  5c13              LDRB     r3,[r2,r0]
000114  4059              EORS     r1,r1,r3
000116  1c40              ADDS     r0,r0,#1
000118  b280              UXTH     r0,r0
                  |L10.282|
00011a  42a0              CMP      r0,r4
00011c  d3f9              BCC      |L10.274|
00011e  43c8              MVNS     r0,r1
000120  b2c0              UXTB     r0,r0
000122  42a8              CMP      r0,r5
000124  d00c              BEQ      |L10.320|
;;;161    				{//校验未通过，说明数据损坏,重新写数据到对应flash
;;;162    					USART_PRINTF_D("数据对象%d数据损坏\n",CaEepromCfg_CheckSumObj[SeMemIf_u_CheckSumObj]);
000126  7830              LDRB     r0,[r6,#0]  ; SeMemIf_u_CheckSumObj
000128  5c39              LDRB     r1,[r7,r0]
00012a  a014              ADR      r0,|L10.380|
00012c  f7fffffe          BL       __2printf
;;;163    					SeMemIf_u_WrEEFlag[CaEepromCfg_CheckSumObj[SeMemIf_u_CheckSumObj]] = 1U;
000130  7830              LDRB     r0,[r6,#0]  ; SeMemIf_u_CheckSumObj
000132  490d              LDR      r1,|L10.360|
000134  2201              MOVS     r2,#1
000136  5c38              LDRB     r0,[r7,r0]
000138  3111              ADDS     r1,r1,#0x11
00013a  540a              STRB     r2,[r1,r0]
;;;164    					SeMemIf_w_Lng[CaEepromCfg_CheckSumObj[SeMemIf_u_CheckSumObj]] = Le_w_Lng;
00013c  f82a4010          STRH     r4,[r10,r0,LSL #1]
                  |L10.320|
;;;165    				}
;;;166    				
;;;167    				SeMemIf_u_CheckSumObj++;
000140  7830              LDRB     r0,[r6,#0]  ; SeMemIf_u_CheckSumObj
000142  1c40              ADDS     r0,r0,#1
000144  b2c0              UXTB     r0,r0
000146  7030              STRB     r0,[r6,#0]
;;;168    				if(SeMemIf_u_CheckSumObj == EE_CHECKSUM_OBJ_NUM)
000148  2806              CMP      r0,#6
00014a  d101              BNE      |L10.336|
;;;169    				{
;;;170    					SeMemIf_u_CheckSumObj = 0U;
00014c  f8868000          STRB     r8,[r6,#0]
                  |L10.336|
;;;171    				}
;;;172    			}
;;;173    			else
;;;174    			{
;;;175    				USART_PRINTF_S("数据长度超出定义的最大长度");
;;;176    			}
;;;177    		}
;;;178    	}
;;;179    	else
;;;180    	{
;;;181    		SeMemIf_dw_Timer++;
;;;182    	}
;;;183    }
000150  e8bd9ff0          POP      {r4-r12,pc}
                  |L10.340|
000154  e8bd5ff0          POP      {r4-r12,lr}           ;175
000158  a10d              ADR      r1,|L10.400|
00015a  a014              ADR      r0,|L10.428|
00015c  f7ffbffe          B.W      __2printf
                  |L10.352|
000160  1c40              ADDS     r0,r0,#1              ;175
000162  6070              STR      r0,[r6,#4]            ;181  ; SeMemIf_dw_Timer
000164  e7f4              B        |L10.336|
;;;184    
                          ENDP

000166  0000              DCW      0x0000
                  |L10.360|
                          DCD      ||.bss||+0x64
                  |L10.364|
                          DCD      CaEepromCfg_Conf
                  |L10.368|
                          DCD      ||.data||
                  |L10.372|
                          DCD      CaEepromCfg_CheckSumObj
                  |L10.376|
                          DCD      CaEepromCfg_ObjDtLng
                  |L10.380|
00017c  cafdbedd          DCB      202,253,190,221,182,212,207,243,"%d",202,253,190,221,203
000180  b6d4cff3
000184  2564cafd
000188  beddcb  
00018b  f0bbb50a          DCB      240,187,181,"\n",0
00018f  00      
                  |L10.400|
000190  cafdbedd          DCB      202,253,190,221,179,164,182,200,179,172,179,246,182,168,210
000194  b3a4b6c8
000198  b3acb3f6
00019c  b6a8d2  
00019f  e5b5c4d7          DCB      229,181,196,215,238,180,243,179,164,182,200,0
0001a3  eeb4f3b3
0001a7  a4b6c800
0001ab  00                DCB      0
                  |L10.428|
0001ac  25730a00          DCB      "%s\n",0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  SeMemIf_u_DataCache
                          %        100
                  SeMemIf_u_EESt
                          %        17
                  SeMemIf_u_WrEEFlag
                          %        17
                  SeMemIf_w_Lng
                          %        34
                  SeMemIf_u_VildFlag
                          %        17

                          AREA ||.data||, DATA, ALIGN=2

                  SeMemIf_u_CheckSumObj
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  SeMemIf_dw_Timer
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\Ecal\\MemIf\\MemIf.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_MemIf_c_27ab8546____REV16|
#line 138 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___7_MemIf_c_27ab8546____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_MemIf_c_27ab8546____REVSH|
#line 153
|__asm___7_MemIf_c_27ab8546____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_MemIf_c_27ab8546____RRX|
#line 328
|__asm___7_MemIf_c_27ab8546____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\ip_frag.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\ip_frag.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\ZR60_v1.0_freeRTOS -I..\..\Lwip\App -I..\..\Lwip\Bsp -I..\..\Lwip\Bsp\LAN8742A -I..\..\Lwip\lwip-1.4.1 -I..\..\Lwip\lwip-1.4.1\port -I..\..\Lwip\lwip-1.4.1\port\arch -I..\..\Lwip\lwip-1.4.1\port\Standalone -I..\..\Lwip\lwip-1.4.1\src\include -I..\..\Lwip\lwip-1.4.1\src\include\ipv4 -I..\..\Lwip\lwip-1.4.1\src\include\lwip -I..\..\Lwip\lwip-1.4.1\src\include\netif -I..\..\Ecal\BtnFltr -I..\..\Ecal\UartComn -I..\..\Ecal\MemIf -I..\..\APP -I..\..\APP\BlackListMng -I..\..\APP\SeverNewsPush -I..\..\APP\NewsPull -I..\..\Ecal -I..\..\Ecal\JsonIf -I..\..\Ecal\Mcu_Init -I..\..\Service -I..\..\Complex -I..\..\Complex\FATFS -I..\..\FreeRTOS\Source\include -I..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\FreeRTOS -I.\RTE\_ZR60 -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=..\..\output\ip_frag.crf ..\..\Lwip\lwip-1.4.1\src\core\ipv4\ip_frag.c]
                          THUMB

                          AREA ||i.ip_frag||, CODE, READONLY, ALIGN=2

                  ip_frag PROC
;;;666    err_t 
;;;667    ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;668    {
000004  b08a              SUB      sp,sp,#0x28
000006  4604              MOV      r4,r0
;;;669      struct pbuf *rambuf;
;;;670    #if IP_FRAG_USES_STATIC_BUF
;;;671      struct pbuf *header;
;;;672    #else
;;;673    #if !LWIP_NETIF_TX_SINGLE_PBUF
;;;674      struct pbuf *newpbuf;
;;;675    #endif
;;;676      struct ip_hdr *original_iphdr;
;;;677    #endif
;;;678      struct ip_hdr *iphdr;
;;;679      u16_t nfb;
;;;680      u16_t left, cop;
;;;681      u16_t mtu = netif->mtu;
000008  980b              LDR      r0,[sp,#0x2c]
;;;682      u16_t ofo, omf;
;;;683      u16_t last;
;;;684      u16_t poff = IP_HLEN;
00000a  2514              MOVS     r5,#0x14
;;;685      u16_t tmp;
;;;686    #if !IP_FRAG_USES_STATIC_BUF && !LWIP_NETIF_TX_SINGLE_PBUF
;;;687      u16_t newpbuflen = 0;
00000c  2600              MOVS     r6,#0
00000e  8d07              LDRH     r7,[r0,#0x28]         ;681
;;;688      u16_t left_to_copy;
;;;689    #endif
;;;690    
;;;691      /* Get a RAM based MTU sized pbuf */
;;;692    #if IP_FRAG_USES_STATIC_BUF
;;;693      /* When using a static buffer, we use a PBUF_REF, which we will
;;;694       * use to reference the packet (without link header).
;;;695       * Layer and length is irrelevant.
;;;696       */
;;;697      rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
;;;698      if (rambuf == NULL) {
;;;699        LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
;;;700        return ERR_MEM;
;;;701      }
;;;702      rambuf->tot_len = rambuf->len = mtu;
;;;703      rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
;;;704    
;;;705      /* Copy the IP header in it */
;;;706      iphdr = (struct ip_hdr *)rambuf->payload;
;;;707      SMEMCPY(iphdr, p->payload, IP_HLEN);
;;;708    #else /* IP_FRAG_USES_STATIC_BUF */
;;;709      original_iphdr = (struct ip_hdr *)p->payload;
000010  6860              LDR      r0,[r4,#4]
;;;710      iphdr = original_iphdr;
;;;711    #endif /* IP_FRAG_USES_STATIC_BUF */
;;;712    
;;;713      /* Save original offset */
;;;714      tmp = ntohs(IPH_OFFSET(iphdr));
000012  9006              STR      r0,[sp,#0x18]
000014  88c0              LDRH     r0,[r0,#6]
000016  f7fffffe          BL       lwip_ntohs
;;;715      ofo = tmp & IP_OFFMASK;
00001a  f3c0010c          UBFX     r1,r0,#0,#13
;;;716      omf = tmp & IP_MF;
00001e  f4005000          AND      r0,r0,#0x2000
;;;717    
;;;718      left = p->tot_len - IP_HLEN;
000022  9103              STR      r1,[sp,#0xc]
000024  9008              STR      r0,[sp,#0x20]
000026  8920              LDRH     r0,[r4,#8]
000028  3814              SUBS     r0,r0,#0x14
00002a  3f14              SUBS     r7,r7,#0x14
00002c  fa1ff980          UXTH     r9,r0
;;;719    
;;;720      nfb = (mtu - IP_HLEN) / 8;
000030  17f8              ASRS     r0,r7,#31
000032  eb077050          ADD      r0,r7,r0,LSR #29
000036  f3c000cf          UBFX     r0,r0,#3,#16
;;;721    
;;;722      while (left) {
00003a  9707              STR      r7,[sp,#0x1c]
00003c  9004              STR      r0,[sp,#0x10]
00003e  e088              B        |L1.338|
                  |L1.64|
;;;723        last = (left <= mtu - IP_HLEN);
000040  9907              LDR      r1,[sp,#0x1c]
000042  4589              CMP      r9,r1
000044  dc01              BGT      |L1.74|
000046  2001              MOVS     r0,#1
000048  e000              B        |L1.76|
                  |L1.74|
00004a  2000              MOVS     r0,#0
                  |L1.76|
;;;724    
;;;725        /* Set new offset and MF flag */
;;;726        tmp = omf | (IP_OFFMASK & (ofo));
00004c  9903              LDR      r1,[sp,#0xc]
00004e  9a08              LDR      r2,[sp,#0x20]
000050  f3c1010c          UBFX     r1,r1,#0,#13
000054  4311              ORRS     r1,r1,r2
;;;727        if (!last) {
000056  9105              STR      r1,[sp,#0x14]
000058  b300              CBZ      r0,|L1.156|
;;;728          tmp = tmp | IP_MF;
;;;729        }
;;;730    
;;;731        /* Fill this fragment */
;;;732        cop = last ? left : nfb * 8;
00005a  4648              MOV      r0,r9
                  |L1.92|
00005c  fa1ffb80          UXTH     r11,r0
;;;733    
;;;734    #if IP_FRAG_USES_STATIC_BUF
;;;735        poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
;;;736    #else /* IP_FRAG_USES_STATIC_BUF */
;;;737    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;738        rambuf = pbuf_alloc(PBUF_IP, cop, PBUF_RAM);
;;;739        if (rambuf == NULL) {
;;;740          return ERR_MEM;
;;;741        }
;;;742        LWIP_ASSERT("this needs a pbuf in one piece!",
;;;743          (rambuf->len == rambuf->tot_len) && (rambuf->next == NULL));
;;;744        poff += pbuf_copy_partial(p, rambuf->payload, cop, poff);
;;;745        /* make room for the IP header */
;;;746        if(pbuf_header(rambuf, IP_HLEN)) {
;;;747          pbuf_free(rambuf);
;;;748          return ERR_MEM;
;;;749        }
;;;750        /* fill in the IP header */
;;;751        SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
;;;752        iphdr = rambuf->payload;
;;;753    #else /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;754        /* When not using a static buffer, create a chain of pbufs.
;;;755         * The first will be a PBUF_RAM holding the link and IP header.
;;;756         * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
;;;757         * but limited to the size of an mtu.
;;;758         */
;;;759        rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
000060  2200              MOVS     r2,#0
000062  2114              MOVS     r1,#0x14
000064  2002              MOVS     r0,#2
000066  f7fffffe          BL       pbuf_alloc
;;;760        if (rambuf == NULL) {
00006a  9002              STR      r0,[sp,#8]
00006c  b1e0              CBZ      r0,|L1.168|
;;;761          return ERR_MEM;
;;;762        }
;;;763        LWIP_ASSERT("this needs a pbuf in one piece!",
00006e  8960              LDRH     r0,[r4,#0xa]
000070  2814              CMP      r0,#0x14
000072  d202              BCS      |L1.122|
000074  a03e              ADR      r0,|L1.368|
000076  f7fffffe          BL       __2printf
                  |L1.122|
;;;764                    (p->len >= (IP_HLEN)));
;;;765        SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
00007a  9802              LDR      r0,[sp,#8]
00007c  2214              MOVS     r2,#0x14
00007e  9906              LDR      r1,[sp,#0x18]
000080  6840              LDR      r0,[r0,#4]
000082  f7fffffe          BL       __aeabi_memcpy
;;;766        iphdr = (struct ip_hdr *)rambuf->payload;
000086  9802              LDR      r0,[sp,#8]
;;;767    
;;;768        /* Can just adjust p directly for needed offset. */
;;;769        p->payload = (u8_t *)p->payload + poff;
000088  f8d0a004          LDR      r10,[r0,#4]
00008c  6860              LDR      r0,[r4,#4]
00008e  4428              ADD      r0,r0,r5
;;;770        p->len -= poff;
000090  6060              STR      r0,[r4,#4]
000092  8960              LDRH     r0,[r4,#0xa]
000094  1b40              SUBS     r0,r0,r5
000096  8160              STRH     r0,[r4,#0xa]
;;;771    
;;;772        left_to_copy = cop;
000098  465d              MOV      r5,r11
;;;773        while (left_to_copy) {
00009a  e031              B        |L1.256|
                  |L1.156|
00009c  f4415000          ORR      r0,r1,#0x2000         ;728
0000a0  9005              STR      r0,[sp,#0x14]         ;732
0000a2  9804              LDR      r0,[sp,#0x10]         ;732
0000a4  00c0              LSLS     r0,r0,#3              ;732
0000a6  e7d9              B        |L1.92|
                  |L1.168|
0000a8  f04f30ff          MOV      r0,#0xffffffff        ;761
                  |L1.172|
;;;774          struct pbuf_custom_ref *pcr;
;;;775          newpbuflen = (left_to_copy < p->len) ? left_to_copy : p->len;
;;;776          /* Is this pbuf already empty? */
;;;777          if (!newpbuflen) {
;;;778            p = p->next;
;;;779            continue;
;;;780          }
;;;781          pcr = ip_frag_alloc_pbuf_custom_ref();
;;;782          if (pcr == NULL) {
;;;783            pbuf_free(rambuf);
;;;784            return ERR_MEM;
;;;785          }
;;;786          /* Mirror this pbuf, although we might not need all of it. */
;;;787          newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
;;;788          if (newpbuf == NULL) {
;;;789            ip_frag_free_pbuf_custom_ref(pcr);
;;;790            pbuf_free(rambuf);
;;;791            return ERR_MEM;
;;;792          }
;;;793          pbuf_ref(p);
;;;794          pcr->original = p;
;;;795          pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
;;;796    
;;;797          /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
;;;798           * so that it is removed when pbuf_dechain is later called on rambuf.
;;;799           */
;;;800          pbuf_cat(rambuf, newpbuf);
;;;801          left_to_copy -= newpbuflen;
;;;802          if (left_to_copy) {
;;;803            p = p->next;
;;;804          }
;;;805        }
;;;806        poff = newpbuflen;
;;;807    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;808    #endif /* IP_FRAG_USES_STATIC_BUF */
;;;809    
;;;810        /* Correct header */
;;;811        IPH_OFFSET_SET(iphdr, htons(tmp));
;;;812        IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
;;;813        IPH_CHKSUM_SET(iphdr, 0);
;;;814        IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
;;;815    
;;;816    #if IP_FRAG_USES_STATIC_BUF
;;;817        if (last) {
;;;818          pbuf_realloc(rambuf, left + IP_HLEN);
;;;819        }
;;;820    
;;;821        /* This part is ugly: we alloc a RAM based pbuf for 
;;;822         * the link level header for each chunk and then 
;;;823         * free it.A PBUF_ROM style pbuf for which pbuf_header
;;;824         * worked would make things simpler.
;;;825         */
;;;826        header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
;;;827        if (header != NULL) {
;;;828          pbuf_chain(header, rambuf);
;;;829          netif->output(netif, header, dest);
;;;830          IPFRAG_STATS_INC(ip_frag.xmit);
;;;831          snmp_inc_ipfragcreates();
;;;832          pbuf_free(header);
;;;833        } else {
;;;834          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
;;;835          pbuf_free(rambuf);
;;;836          return ERR_MEM;
;;;837        }
;;;838    #else /* IP_FRAG_USES_STATIC_BUF */
;;;839        /* No need for separate header pbuf - we allowed room for it in rambuf
;;;840         * when allocated.
;;;841         */
;;;842        netif->output(netif, rambuf, dest);
;;;843        IPFRAG_STATS_INC(ip_frag.xmit);
;;;844    
;;;845        /* Unfortunately we can't reuse rambuf - the hardware may still be
;;;846         * using the buffer. Instead we free it (and the ensuing chain) and
;;;847         * recreate it next time round the loop. If we're lucky the hardware
;;;848         * will have already sent the packet, the free will really free, and
;;;849         * there will be zero memory penalty.
;;;850         */
;;;851        
;;;852        pbuf_free(rambuf);
;;;853    #endif /* IP_FRAG_USES_STATIC_BUF */
;;;854        left -= cop;
;;;855        ofo += nfb;
;;;856      }
;;;857    #if IP_FRAG_USES_STATIC_BUF
;;;858      pbuf_free(rambuf);
;;;859    #endif /* IP_FRAG_USES_STATIC_BUF */
;;;860      snmp_inc_ipfragoks();
;;;861      return ERR_OK;
;;;862    }
0000ac  b00d              ADD      sp,sp,#0x34
0000ae  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.178|
0000b2  8966              LDRH     r6,[r4,#0xa]          ;775
0000b4  42ae              CMP      r6,r5                 ;775
0000b6  d900              BLS      |L1.186|
0000b8  462e              MOV      r6,r5                 ;775
                  |L1.186|
0000ba  b306              CBZ      r6,|L1.254|
0000bc  2006              MOVS     r0,#6                 ;777
0000be  f7fffffe          BL       memp_malloc
0000c2  0007              MOVS     r7,r0                 ;777
0000c4  d04b              BEQ      |L1.350|
0000c6  6860              LDR      r0,[r4,#4]            ;787
0000c8  e9cd0600          STRD     r0,r6,[sp,#0]         ;787
0000cc  463b              MOV      r3,r7                 ;787
0000ce  2202              MOVS     r2,#2                 ;787
0000d0  4631              MOV      r1,r6                 ;787
0000d2  2003              MOVS     r0,#3                 ;787
0000d4  f7fffffe          BL       pbuf_alloced_custom
0000d8  ea5f0800          MOVS     r8,r0                 ;787
0000dc  d043              BEQ      |L1.358|
0000de  4620              MOV      r0,r4                 ;793
0000e0  f7fffffe          BL       pbuf_ref
0000e4  482a              LDR      r0,|L1.400|
0000e6  e9c70404          STRD     r0,r4,[r7,#0x10]      ;795
0000ea  4641              MOV      r1,r8                 ;800
0000ec  9802              LDR      r0,[sp,#8]            ;800
0000ee  f7fffffe          BL       pbuf_cat
0000f2  1ba8              SUBS     r0,r5,r6              ;801
0000f4  0405              LSLS     r5,r0,#16             ;801
0000f6  0c2d              LSRS     r5,r5,#16             ;801
0000f8  d004              BEQ      |L1.260|
0000fa  6824              LDR      r4,[r4,#0]            ;803
0000fc  e7d9              B        |L1.178|
                  |L1.254|
0000fe  6824              LDR      r4,[r4,#0]            ;778
                  |L1.256|
000100  2d00              CMP      r5,#0                 ;773
000102  d1d6              BNE      |L1.178|
                  |L1.260|
000104  4635              MOV      r5,r6                 ;806
000106  9805              LDR      r0,[sp,#0x14]         ;811
000108  f7fffffe          BL       lwip_htons
00010c  f8aa0006          STRH     r0,[r10,#6]           ;811
000110  f10b0014          ADD      r0,r11,#0x14          ;812
000114  b280              UXTH     r0,r0                 ;812
000116  f7fffffe          BL       lwip_htons
00011a  f8aa0002          STRH     r0,[r10,#2]           ;812
00011e  2100              MOVS     r1,#0                 ;813
000120  f8aa100a          STRH     r1,[r10,#0xa]         ;813
000124  2114              MOVS     r1,#0x14              ;814
000126  4650              MOV      r0,r10                ;814
000128  f7fffffe          BL       inet_chksum
00012c  f8aa000a          STRH     r0,[r10,#0xa]         ;814
000130  980b              LDR      r0,[sp,#0x2c]         ;842
000132  9a0c              LDR      r2,[sp,#0x30]         ;842
000134  9902              LDR      r1,[sp,#8]            ;842
000136  6943              LDR      r3,[r0,#0x14]         ;842
000138  4798              BLX      r3                    ;842
00013a  9802              LDR      r0,[sp,#8]            ;852
00013c  f7fffffe          BL       pbuf_free
000140  eba9000b          SUB      r0,r9,r11             ;854
000144  fa1ff980          UXTH     r9,r0                 ;854
000148  e9dd0103          LDRD     r0,r1,[sp,#0xc]       ;854
00014c  4408              ADD      r0,r0,r1              ;855
00014e  b280              UXTH     r0,r0                 ;855
000150  9003              STR      r0,[sp,#0xc]          ;855
                  |L1.338|
000152  f1b90f00          CMP      r9,#0                 ;722
000156  f47faf73          BNE      |L1.64|
00015a  2000              MOVS     r0,#0                 ;861
00015c  e7a6              B        |L1.172|
                  |L1.350|
00015e  9802              LDR      r0,[sp,#8]            ;783
000160  f7fffffe          BL       pbuf_free
000164  e7a0              B        |L1.168|
                  |L1.358|
000166  4638              MOV      r0,r7                 ;789
000168  f7fffffe          BL       ip_frag_free_pbuf_custom_ref
00016c  e7f7              B        |L1.350|
;;;863    #endif /* IP_FRAG */
                          ENDP

00016e  0000              DCW      0x0000
                  |L1.368|
000170  74686973          DCB      "this needs a pbuf in one piece!",0
000174  206e6565
000178  64732061
00017c  20706275
000180  6620696e
000184  206f6e65
000188  20706965
00018c  63652100
                  |L1.400|
                          DCD      ipfrag_free_pbuf_custom

                          AREA ||i.ip_frag_free_pbuf_custom_ref||, CODE, READONLY, ALIGN=2

                  ip_frag_free_pbuf_custom_ref PROC
;;;630    static void
;;;631    ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref* p)
000000  b510              PUSH     {r4,lr}
;;;632    {
000002  0004              MOVS     r4,r0
000004  d102              BNE      |L2.12|
;;;633      LWIP_ASSERT("p != NULL", p != NULL);
000006  a004              ADR      r0,|L2.24|
000008  f7fffffe          BL       __2printf
                  |L2.12|
;;;634      memp_free(MEMP_FRAG_PBUF, p);
00000c  4621              MOV      r1,r4
00000e  e8bd4010          POP      {r4,lr}
000012  2006              MOVS     r0,#6
000014  f7ffbffe          B.W      memp_free
;;;635    }
;;;636    
                          ENDP

                  |L2.24|
000018  7020213d          DCB      "p != NULL",0
00001c  204e554c
000020  4c00    
000022  00                DCB      0
000023  00                DCB      0

                          AREA ||i.ip_reass||, CODE, READONLY, ALIGN=2

                  ip_reass PROC
;;;475    struct pbuf *
;;;476    ip_reass(struct pbuf *p)
000000  e92d4ff1          PUSH     {r0,r4-r11,lr}
;;;477    {
;;;478      struct pbuf *r;
;;;479      struct ip_hdr *fraghdr;
;;;480      struct ip_reassdata *ipr;
;;;481      struct ip_reass_helper *iprh;
;;;482      u16_t offset, len;
;;;483      u8_t clen;
;;;484      struct ip_reassdata *ipr_prev = NULL;
000004  2700              MOVS     r7,#0
;;;485    
;;;486      IPFRAG_STATS_INC(ip_frag.recv);
;;;487      snmp_inc_ipreasmreqds();
;;;488    
;;;489      fraghdr = (struct ip_hdr*)p->payload;
000006  9800              LDR      r0,[sp,#0]
;;;490    
;;;491      if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
000008  6844              LDR      r4,[r0,#4]
00000a  7820              LDRB     r0,[r4,#0]
00000c  f000000f          AND      r0,r0,#0xf
000010  2805              CMP      r0,#5
000012  d17c              BNE      |L3.270|
;;;492        LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
;;;493        IPFRAG_STATS_INC(ip_frag.err);
;;;494        goto nullreturn;
;;;495      }
;;;496    
;;;497      offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
000014  88e0              LDRH     r0,[r4,#6]
000016  f7fffffe          BL       lwip_ntohs
00001a  04c0              LSLS     r0,r0,#19
00001c  ea4f4a10          LSR      r10,r0,#16
;;;498      len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
000020  8860              LDRH     r0,[r4,#2]
000022  f7fffffe          BL       lwip_ntohs
000026  7821              LDRB     r1,[r4,#0]
000028  f001010f          AND      r1,r1,#0xf
00002c  4249              RSBS     r1,r1,#0
00002e  eb000081          ADD      r0,r0,r1,LSL #2
000032  fa1ff980          UXTH     r9,r0
;;;499    
;;;500      /* Check if we are allowed to enqueue more datagrams. */
;;;501      clen = pbuf_clen(p);
000036  9800              LDR      r0,[sp,#0]
000038  f7fffffe          BL       pbuf_clen
;;;502      if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
00003c  4d58              LDR      r5,|L3.416|
00003e  4606              MOV      r6,r0                 ;501
000040  8828              LDRH     r0,[r5,#0]  ; ip_reass_pbufcount
000042  4430              ADD      r0,r0,r6
000044  280a              CMP      r0,#0xa
000046  d909              BLS      |L3.92|
;;;503    #if IP_REASS_FREE_OLDEST
;;;504        if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
000048  4631              MOV      r1,r6
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       ip_reass_remove_oldest_datagram
000050  2800              CMP      r0,#0
000052  d05c              BEQ      |L3.270|
;;;505            ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
000054  8828              LDRH     r0,[r5,#0]  ; ip_reass_pbufcount
000056  4430              ADD      r0,r0,r6
000058  280a              CMP      r0,#0xa
00005a  d858              BHI      |L3.270|
                  |L3.92|
;;;506    #endif /* IP_REASS_FREE_OLDEST */
;;;507        {
;;;508          /* No datagram could be freed and still too many pbufs enqueued */
;;;509          LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
;;;510            ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
;;;511          IPFRAG_STATS_INC(ip_frag.memerr);
;;;512          /* @todo: send ICMP time exceeded here? */
;;;513          /* drop this pbuf */
;;;514          goto nullreturn;
;;;515        }
;;;516      }
;;;517    
;;;518      /* Look for the datagram the fragment belongs to in the current datagram queue,
;;;519       * remembering the previous in the queue for later dequeueing. */
;;;520      for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
00005c  46a8              MOV      r8,r5
00005e  686d              LDR      r5,[r5,#4]  ; reassdatagrams
000060  f04f0b00          MOV      r11,#0
000064  e00d              B        |L3.130|
                  |L3.102|
;;;521        /* Check if the incoming fragment matches the one currently present
;;;522           in the reassembly buffer. If so, we proceed with copying the
;;;523           fragment into the buffer. */
;;;524        if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
000066  6968              LDR      r0,[r5,#0x14]
000068  68e1              LDR      r1,[r4,#0xc]
00006a  4288              CMP      r0,r1
00006c  d107              BNE      |L3.126|
00006e  69a8              LDR      r0,[r5,#0x18]
000070  6921              LDR      r1,[r4,#0x10]
000072  4288              CMP      r0,r1
000074  d103              BNE      |L3.126|
000076  89a8              LDRH     r0,[r5,#0xc]
000078  88a1              LDRH     r1,[r4,#4]
00007a  4288              CMP      r0,r1
00007c  d004              BEQ      |L3.136|
                  |L3.126|
;;;525          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
;;;526            ntohs(IPH_ID(fraghdr))));
;;;527          IPFRAG_STATS_INC(ip_frag.cachehit);
;;;528          break;
;;;529        }
;;;530        ipr_prev = ipr;
00007e  462f              MOV      r7,r5
000080  682d              LDR      r5,[r5,#0]            ;520
                  |L3.130|
000082  2d00              CMP      r5,#0                 ;520
000084  d1ef              BNE      |L3.102|
000086  e006              B        |L3.150|
                  |L3.136|
;;;531      }
;;;532    
;;;533      if (ipr == NULL) {
000088  b12d              CBZ      r5,|L3.150|
;;;534      /* Enqueue a new datagram into the datagram queue */
;;;535        ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
;;;536        /* Bail if unable to enqueue */
;;;537        if(ipr == NULL) {
;;;538          goto nullreturn;
;;;539        }
;;;540      } else {
;;;541        if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
00008a  88e0              LDRH     r0,[r4,#6]
00008c  f7fffffe          BL       lwip_ntohs
000090  04c0              LSLS     r0,r0,#19
000092  d024              BEQ      |L3.222|
000094  e02e              B        |L3.244|
                  |L3.150|
000096  2005              MOVS     r0,#5
000098  f7fffffe          BL       memp_malloc
00009c  0005              MOVS     r5,r0
00009e  d10a              BNE      |L3.182|
0000a0  4631              MOV      r1,r6
0000a2  4620              MOV      r0,r4
0000a4  f7fffffe          BL       ip_reass_remove_oldest_datagram
0000a8  42b0              CMP      r0,r6
0000aa  db16              BLT      |L3.218|
0000ac  2005              MOVS     r0,#5
0000ae  f7fffffe          BL       memp_malloc
0000b2  0005              MOVS     r5,r0
0000b4  d011              BEQ      |L3.218|
                  |L3.182|
0000b6  2120              MOVS     r1,#0x20
0000b8  f7fffffe          BL       __aeabi_memclr4
0000bc  2003              MOVS     r0,#3
0000be  77e8              STRB     r0,[r5,#0x1f]
0000c0  f8d81004          LDR      r1,[r8,#4]  ; reassdatagrams
0000c4  6029              STR      r1,[r5,#0]
0000c6  2214              MOVS     r2,#0x14
0000c8  4621              MOV      r1,r4
0000ca  f1050008          ADD      r0,r5,#8
0000ce  f8c85004          STR      r5,[r8,#4]  ; reassdatagrams
0000d2  f7fffffe          BL       __aeabi_memcpy
                  |L3.214|
0000d6  b1d5              CBZ      r5,|L3.270|
0000d8  e00c              B        |L3.244|
                  |L3.218|
0000da  465d              MOV      r5,r11                ;537
0000dc  e7fb              B        |L3.214|
                  |L3.222|
;;;542          ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
0000de  89e8              LDRH     r0,[r5,#0xe]
0000e0  f7fffffe          BL       lwip_ntohs
0000e4  04c0              LSLS     r0,r0,#19
0000e6  d005              BEQ      |L3.244|
;;;543          /* ipr->iphdr is not the header from the first fragment, but fraghdr is
;;;544           * -> copy fraghdr into ipr->iphdr since we want to have the header
;;;545           * of the first fragment (for ICMP time exceeded and later, for copying
;;;546           * all options, if supported)*/
;;;547          SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
0000e8  2214              MOVS     r2,#0x14
0000ea  4621              MOV      r1,r4
0000ec  f1050008          ADD      r0,r5,#8
0000f0  f7fffffe          BL       __aeabi_memcpy
                  |L3.244|
;;;548        }
;;;549      }
;;;550      /* Track the current number of pbufs current 'in-flight', in order to limit 
;;;551      the number of fragments that may be enqueued at any one time */
;;;552      ip_reass_pbufcount += clen;
0000f4  f8b81000          LDRH     r1,[r8,#0]  ; ip_reass_pbufcount
0000f8  4431              ADD      r1,r1,r6
0000fa  f8a81000          STRH     r1,[r8,#0]
;;;553    
;;;554      /* At this point, we have either created a new entry or pointing 
;;;555       * to an existing one */
;;;556    
;;;557      /* check for 'no more fragments', and update queue entry*/
;;;558      if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
0000fe  79a0              LDRB     r0,[r4,#6]
000100  0680              LSLS     r0,r0,#26
000102  d408              BMI      |L3.278|
;;;559        ipr->flags |= IP_REASS_FLAG_LASTFRAG;
000104  7fa8              LDRB     r0,[r5,#0x1e]
000106  f0400001          ORR      r0,r0,#1
00010a  77a8              STRB     r0,[r5,#0x1e]
;;;560        ipr->datagram_len = offset + len;
00010c  e000              B        |L3.272|
                  |L3.270|
00010e  e041              B        |L3.404|
                  |L3.272|
000110  eb0a0009          ADD      r0,r10,r9
000114  83a8              STRH     r0,[r5,#0x1c]
                  |L3.278|
;;;561        LWIP_DEBUGF(IP_REASS_DEBUG,
;;;562         ("ip_reass: last fragment seen, total len %"S16_F"\n",
;;;563          ipr->datagram_len));
;;;564      }
;;;565      /* find the right place to insert this pbuf */
;;;566      /* @todo: trim pbufs if fragments are overlapping */
;;;567      if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
000116  4628              MOV      r0,r5
000118  9900              LDR      r1,[sp,#0]
00011a  f7fffffe          BL       ip_reass_chain_frag_into_datagram_and_validate
00011e  2800              CMP      r0,#0
000120  d036              BEQ      |L3.400|
;;;568        /* the totally last fragment (flag more fragments = 0) was received at least
;;;569         * once AND all fragments are received */
;;;570        ipr->datagram_len += IP_HLEN;
000122  8ba8              LDRH     r0,[r5,#0x1c]
;;;571    
;;;572        /* save the second pbuf before copying the header over the pointer */
;;;573        r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
;;;574    
;;;575        /* copy the original ip header back to the first pbuf */
;;;576        fraghdr = (struct ip_hdr*)(ipr->p->payload);
;;;577        SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
000124  2214              MOVS     r2,#0x14
000126  3014              ADDS     r0,r0,#0x14           ;570
000128  83a8              STRH     r0,[r5,#0x1c]         ;570
00012a  6868              LDR      r0,[r5,#4]            ;573
00012c  f1050108          ADD      r1,r5,#8
000130  6846              LDR      r6,[r0,#4]            ;573
000132  4630              MOV      r0,r6
000134  6834              LDR      r4,[r6,#0]            ;573
000136  f7fffffe          BL       __aeabi_memcpy
;;;578        IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
00013a  8ba8              LDRH     r0,[r5,#0x1c]
00013c  f7fffffe          BL       lwip_htons
000140  8070              STRH     r0,[r6,#2]
;;;579        IPH_OFFSET_SET(fraghdr, 0);
000142  f8a6b006          STRH     r11,[r6,#6]
;;;580        IPH_CHKSUM_SET(fraghdr, 0);
000146  f8a6b00a          STRH     r11,[r6,#0xa]
;;;581        /* @todo: do we need to set calculate the correct checksum? */
;;;582        IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
00014a  2114              MOVS     r1,#0x14
00014c  4630              MOV      r0,r6
00014e  f7fffffe          BL       inet_chksum
000152  8170              STRH     r0,[r6,#0xa]
;;;583    
;;;584        p = ipr->p;
;;;585    
;;;586        /* chain together the pbufs contained within the reass_data list. */
;;;587        while(r != NULL) {
;;;588          iprh = (struct ip_reass_helper*)r->payload;
;;;589    
;;;590          /* hide the ip header for every succeding fragment */
;;;591          pbuf_header(r, -IP_HLEN);
000154  f06f0a13          MVN      r10,#0x13
000158  f8d59004          LDR      r9,[r5,#4]            ;587
00015c  e009              B        |L3.370|
                  |L3.350|
00015e  4651              MOV      r1,r10
000160  4620              MOV      r0,r4
000162  6866              LDR      r6,[r4,#4]
000164  f7fffffe          BL       pbuf_header
;;;592          pbuf_cat(p, r);
000168  4621              MOV      r1,r4
00016a  4648              MOV      r0,r9
00016c  f7fffffe          BL       pbuf_cat
;;;593          r = iprh->next_pbuf;
000170  6834              LDR      r4,[r6,#0]
                  |L3.370|
000172  2c00              CMP      r4,#0                 ;587
000174  d1f3              BNE      |L3.350|
;;;594        }
;;;595        /* release the sources allocate for the fragment queue entry */
;;;596        ip_reass_dequeue_datagram(ipr, ipr_prev);
000176  4639              MOV      r1,r7
000178  4628              MOV      r0,r5
00017a  f7fffffe          BL       ip_reass_dequeue_datagram
;;;597    
;;;598        /* and adjust the number of pbufs currently queued for reassembly. */
;;;599        ip_reass_pbufcount -= pbuf_clen(p);
00017e  4648              MOV      r0,r9
000180  f7fffffe          BL       pbuf_clen
000184  f8b82000          LDRH     r2,[r8,#0]  ; ip_reass_pbufcount
000188  1a10              SUBS     r0,r2,r0
00018a  f8a80000          STRH     r0,[r8,#0]
;;;600    
;;;601        /* Return the pbuf chain */
;;;602        return p;
00018e  4648              MOV      r0,r9
                  |L3.400|
;;;603      }
;;;604      /* the datagram is not (yet?) reassembled completely */
;;;605      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
;;;606      return NULL;
;;;607    
;;;608    nullreturn:
;;;609      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
;;;610      IPFRAG_STATS_INC(ip_frag.drop);
;;;611      pbuf_free(p);
;;;612      return NULL;
;;;613    }
000190  e8bd8ff8          POP      {r3-r11,pc}
                  |L3.404|
000194  9800              LDR      r0,[sp,#0]            ;611
000196  f7fffffe          BL       pbuf_free
00019a  2000              MOVS     r0,#0                 ;612
00019c  e7f8              B        |L3.400|
;;;614    #endif /* IP_REASSEMBLY */
                          ENDP

00019e  0000              DCW      0x0000
                  |L3.416|
                          DCD      ||.data||

                          AREA ||i.ip_reass_chain_frag_into_datagram_and_validate||, CODE, READONLY, ALIGN=2

                  ip_reass_chain_frag_into_datagram_and_validate PROC
;;;330    static int
;;;331    ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;332    {
;;;333      struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
;;;334      struct pbuf *q;
;;;335      u16_t offset,len;
;;;336      struct ip_hdr *fraghdr;
;;;337      int valid = 1;
;;;338    
;;;339      /* Extract length and fragment offset from current fragment */
;;;340      fraghdr = (struct ip_hdr*)new_p->payload; 
;;;341      len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
000004  684c              LDR      r4,[r1,#4]
000006  4606              MOV      r6,r0                 ;332
000008  4688              MOV      r8,r1                 ;332
00000a  2500              MOVS     r5,#0                 ;333
00000c  2701              MOVS     r7,#1                 ;337
00000e  8860              LDRH     r0,[r4,#2]
000010  f7fffffe          BL       lwip_ntohs
000014  7821              LDRB     r1,[r4,#0]
000016  f001010f          AND      r1,r1,#0xf
00001a  4249              RSBS     r1,r1,#0
00001c  eb000981          ADD      r9,r0,r1,LSL #2
;;;342      offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
000020  88e0              LDRH     r0,[r4,#6]
000022  f7fffffe          BL       lwip_ntohs
000026  04c0              LSLS     r0,r0,#19
;;;343    
;;;344      /* overwrite the fragment's ip header from the pbuf with our helper struct,
;;;345       * and setup the embedded helper structure. */
;;;346      /* make sure the struct ip_reass_helper fits into the IP header */
;;;347      LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
;;;348                  sizeof(struct ip_reass_helper) <= IP_HLEN);
;;;349      iprh = (struct ip_reass_helper*)new_p->payload;
;;;350      iprh->next_pbuf = NULL;
000028  f8d84004          LDR      r4,[r8,#4]
00002c  0c02              LSRS     r2,r0,#16             ;342
00002e  2000              MOVS     r0,#0
000030  6020              STR      r0,[r4,#0]
;;;351      iprh->start = offset;
;;;352      iprh->end = offset + len;
000032  eb020009          ADD      r0,r2,r9
000036  80a2              STRH     r2,[r4,#4]            ;351
000038  fa1ffc80          UXTH     r12,r0
00003c  f8a4c006          STRH     r12,[r4,#6]
;;;353    
;;;354      /* Iterate through until we either get to the end of the list (append),
;;;355       * or we find on with a larger offset (insert). */
;;;356      for (q = ipr->p; q != NULL;) {
000040  6871              LDR      r1,[r6,#4]
000042  e01d              B        |L4.128|
                  |L4.68|
;;;357        iprh_tmp = (struct ip_reass_helper*)q->payload;
;;;358        if (iprh->start < iprh_tmp->start) {
000044  6848              LDR      r0,[r1,#4]
000046  8883              LDRH     r3,[r0,#4]
000048  429a              CMP      r2,r3
00004a  d20e              BCS      |L4.106|
;;;359          /* the new pbuf should be inserted before this */
;;;360          iprh->next_pbuf = q;
00004c  6021              STR      r1,[r4,#0]
;;;361          if (iprh_prev != NULL) {
00004e  b145              CBZ      r5,|L4.98|
;;;362            /* not the fragment with the lowest offset */
;;;363    #if IP_REASS_CHECK_OVERLAP
;;;364            if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
000050  88eb              LDRH     r3,[r5,#6]
000052  429a              CMP      r2,r3
000054  d35b              BCC      |L4.270|
000056  8880              LDRH     r0,[r0,#4]
000058  4584              CMP      r12,r0
00005a  d858              BHI      |L4.270|
;;;365              /* fragment overlaps with previous or following, throw away */
;;;366              goto freepbuf;
;;;367            }
;;;368    #endif /* IP_REASS_CHECK_OVERLAP */
;;;369            iprh_prev->next_pbuf = new_p;
00005c  f8c58000          STR      r8,[r5,#0]
000060  e001              B        |L4.102|
                  |L4.98|
;;;370          } else {
;;;371            /* fragment with the lowest offset */
;;;372            ipr->p = new_p;
000062  f8c68004          STR      r8,[r6,#4]
                  |L4.102|
;;;373          }
;;;374          break;
;;;375        } else if(iprh->start == iprh_tmp->start) {
;;;376          /* received the same datagram twice: no need to keep the datagram */
;;;377          goto freepbuf;
;;;378    #if IP_REASS_CHECK_OVERLAP
;;;379        } else if(iprh->start < iprh_tmp->end) {
;;;380          /* overlap: no need to keep the new datagram */
;;;381          goto freepbuf;
;;;382    #endif /* IP_REASS_CHECK_OVERLAP */
;;;383        } else {
;;;384          /* Check if the fragments received so far have no wholes. */
;;;385          if (iprh_prev != NULL) {
;;;386            if (iprh_prev->end != iprh_tmp->start) {
;;;387              /* There is a fragment missing between the current
;;;388               * and the previous fragment */
;;;389              valid = 0;
;;;390            }
;;;391          }
;;;392        }
;;;393        q = iprh_tmp->next_pbuf;
;;;394        iprh_prev = iprh_tmp;
;;;395      }
;;;396    
;;;397      /* If q is NULL, then we made it to the end of the list. Determine what to do now */
;;;398      if (q == NULL) {
000066  b169              CBZ      r1,|L4.132|
000068  e023              B        |L4.178|
                  |L4.106|
00006a  d050              BEQ      |L4.270|
00006c  88c1              LDRH     r1,[r0,#6]            ;379
00006e  428a              CMP      r2,r1                 ;379
000070  d34d              BCC      |L4.270|
000072  b11d              CBZ      r5,|L4.124|
000074  88e9              LDRH     r1,[r5,#6]            ;386
000076  4299              CMP      r1,r3                 ;386
000078  d000              BEQ      |L4.124|
00007a  2700              MOVS     r7,#0                 ;389
                  |L4.124|
00007c  6801              LDR      r1,[r0,#0]            ;393
00007e  4605              MOV      r5,r0                 ;394
                  |L4.128|
000080  2900              CMP      r1,#0                 ;356
000082  d1df              BNE      |L4.68|
                  |L4.132|
;;;399        if (iprh_prev != NULL) {
000084  b175              CBZ      r5,|L4.164|
;;;400          /* this is (for now), the fragment with the highest offset:
;;;401           * chain it to the last fragment */
;;;402    #if IP_REASS_CHECK_OVERLAP
;;;403          LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
000086  88e8              LDRH     r0,[r5,#6]
000088  88a1              LDRH     r1,[r4,#4]
00008a  4288              CMP      r0,r1
00008c  d902              BLS      |L4.148|
00008e  a026              ADR      r0,|L4.296|
000090  f7fffffe          BL       __2printf
                  |L4.148|
;;;404    #endif /* IP_REASS_CHECK_OVERLAP */
;;;405          iprh_prev->next_pbuf = new_p;
000094  f8c58000          STR      r8,[r5,#0]
;;;406          if (iprh_prev->end != iprh->start) {
000098  88e8              LDRH     r0,[r5,#6]
00009a  88a1              LDRH     r1,[r4,#4]
00009c  4288              CMP      r0,r1
00009e  d008              BEQ      |L4.178|
;;;407            valid = 0;
0000a0  2700              MOVS     r7,#0
0000a2  e006              B        |L4.178|
                  |L4.164|
;;;408          }
;;;409        } else {
;;;410    #if IP_REASS_CHECK_OVERLAP
;;;411          LWIP_ASSERT("no previous fragment, this must be the first fragment!",
0000a4  6870              LDR      r0,[r6,#4]
0000a6  b110              CBZ      r0,|L4.174|
0000a8  a027              ADR      r0,|L4.328|
0000aa  f7fffffe          BL       __2printf
                  |L4.174|
;;;412            ipr->p == NULL);
;;;413    #endif /* IP_REASS_CHECK_OVERLAP */
;;;414          /* this is the first fragment we ever received for this ip datagram */
;;;415          ipr->p = new_p;
0000ae  f8c68004          STR      r8,[r6,#4]
                  |L4.178|
;;;416        }
;;;417      }
;;;418    
;;;419      /* At this point, the validation part begins: */
;;;420      /* If we already received the last fragment */
;;;421      if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
0000b2  7fb0              LDRB     r0,[r6,#0x1e]
0000b4  07c0              LSLS     r0,r0,#31
0000b6  d028              BEQ      |L4.266|
;;;422        /* and had no wholes so far */
;;;423        if (valid) {
0000b8  2f00              CMP      r7,#0
0000ba  d025              BEQ      |L4.264|
;;;424          /* then check if the rest of the fragments is here */
;;;425          /* Check if the queue starts with the first datagram */
;;;426          if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
0000bc  6872              LDR      r2,[r6,#4]
0000be  6850              LDR      r0,[r2,#4]
0000c0  8880              LDRH     r0,[r0,#4]
0000c2  b938              CBNZ     r0,|L4.212|
                  |L4.196|
;;;427            valid = 0;
;;;428          } else {
;;;429            /* and check that there are no wholes after this datagram */
;;;430            iprh_prev = iprh;
;;;431            q = iprh->next_pbuf;
0000c4  6820              LDR      r0,[r4,#0]
0000c6  4621              MOV      r1,r4
;;;432            while (q != NULL) {
0000c8  b130              CBZ      r0,|L4.216|
;;;433              iprh = (struct ip_reass_helper*)q->payload;
;;;434              if (iprh_prev->end != iprh->start) {
0000ca  6844              LDR      r4,[r0,#4]
0000cc  88c8              LDRH     r0,[r1,#6]
0000ce  88a1              LDRH     r1,[r4,#4]
0000d0  4288              CMP      r0,r1
0000d2  d0f7              BEQ      |L4.196|
                  |L4.212|
;;;435                valid = 0;
0000d4  2700              MOVS     r7,#0
;;;436                break;
0000d6  e017              B        |L4.264|
                  |L4.216|
;;;437              }
;;;438              iprh_prev = iprh;
;;;439              q = iprh->next_pbuf;
;;;440            }
;;;441            /* if still valid, all fragments are received
;;;442             * (because to the MF==0 already arrived */
;;;443            if (valid) {
0000d8  b1b7              CBZ      r7,|L4.264|
;;;444              LWIP_ASSERT("sanity check", ipr->p != NULL);
0000da  b912              CBNZ     r2,|L4.226|
0000dc  a028              ADR      r0,|L4.384|
0000de  f7fffffe          BL       __2printf
                  |L4.226|
;;;445              LWIP_ASSERT("sanity check",
0000e2  6870              LDR      r0,[r6,#4]
0000e4  6840              LDR      r0,[r0,#4]
0000e6  42a0              CMP      r0,r4
0000e8  d102              BNE      |L4.240|
0000ea  a025              ADR      r0,|L4.384|
0000ec  f7fffffe          BL       __2printf
                  |L4.240|
;;;446                ((struct ip_reass_helper*)ipr->p->payload) != iprh);
;;;447              LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
0000f0  6820              LDR      r0,[r4,#0]
0000f2  b110              CBZ      r0,|L4.250|
0000f4  a026              ADR      r0,|L4.400|
0000f6  f7fffffe          BL       __2printf
                  |L4.250|
;;;448                iprh->next_pbuf == NULL);
;;;449              LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
0000fa  88e0              LDRH     r0,[r4,#6]
0000fc  8bb1              LDRH     r1,[r6,#0x1c]
0000fe  4288              CMP      r0,r1
000100  d002              BEQ      |L4.264|
000102  a02c              ADR      r0,|L4.436|
000104  f7fffffe          BL       __2printf
                  |L4.264|
;;;450                iprh->end == ipr->datagram_len);
;;;451            }
;;;452          }
;;;453        }
;;;454        /* If valid is 0 here, there are some fragments missing in the middle
;;;455         * (since MF == 0 has already arrived). Such datagrams simply time out if
;;;456         * no more fragments are received... */
;;;457        return valid;
000108  4638              MOV      r0,r7
                  |L4.266|
;;;458      }
;;;459      /* If we come here, not all fragments were received, yet! */
;;;460      return 0; /* not yet valid! */
;;;461    #if IP_REASS_CHECK_OVERLAP
;;;462    freepbuf:
;;;463      ip_reass_pbufcount -= pbuf_clen(new_p);
;;;464      pbuf_free(new_p);
;;;465      return 0;
;;;466    #endif /* IP_REASS_CHECK_OVERLAP */
;;;467    }
00010a  e8bd87f0          POP      {r4-r10,pc}
                  |L4.270|
00010e  4640              MOV      r0,r8                 ;463
000110  f7fffffe          BL       pbuf_clen
000114  4933              LDR      r1,|L4.484|
000116  880a              LDRH     r2,[r1,#0]            ;463  ; ip_reass_pbufcount
000118  1a10              SUBS     r0,r2,r0              ;463
00011a  8008              STRH     r0,[r1,#0]            ;463
00011c  4640              MOV      r0,r8                 ;464
00011e  f7fffffe          BL       pbuf_free
000122  2000              MOVS     r0,#0                 ;465
000124  e7f1              B        |L4.266|
;;;468    
                          ENDP

000126  0000              DCW      0x0000
                  |L4.296|
000128  63686563          DCB      "check fragments don't overlap",0
00012c  6b206672
000130  61676d65
000134  6e747320
000138  646f6e27
00013c  74206f76
000140  65726c61
000144  7000    
000146  00                DCB      0
000147  00                DCB      0
                  |L4.328|
000148  6e6f2070          DCB      "no previous fragment, this must be the first fragment!",0
00014c  72657669
000150  6f757320
000154  66726167
000158  6d656e74
00015c  2c207468
000160  6973206d
000164  75737420
000168  62652074
00016c  68652066
000170  69727374
000174  20667261
000178  676d656e
00017c  742100  
00017f  00                DCB      0
                  |L4.384|
000180  73616e69          DCB      "sanity check",0
000184  74792063
000188  6865636b
00018c  00      
00018d  00                DCB      0
00018e  00                DCB      0
00018f  00                DCB      0
                  |L4.400|
000190  76616c69          DCB      "validate_datagram:next_pbuf!=NULL",0
000194  64617465
000198  5f646174
00019c  61677261
0001a0  6d3a6e65
0001a4  78745f70
0001a8  62756621
0001ac  3d4e554c
0001b0  4c00    
0001b2  00                DCB      0
0001b3  00                DCB      0
                  |L4.436|
0001b4  76616c69          DCB      "validate_datagram:datagram end!=datagram len",0
0001b8  64617465
0001bc  5f646174
0001c0  61677261
0001c4  6d3a6461
0001c8  74616772
0001cc  616d2065
0001d0  6e64213d
0001d4  64617461
0001d8  6772616d
0001dc  206c656e
0001e0  00      
0001e1  00                DCB      0
0001e2  00                DCB      0
0001e3  00                DCB      0
                  |L4.484|
                          DCD      ||.data||

                          AREA ||i.ip_reass_dequeue_datagram||, CODE, READONLY, ALIGN=2

                  ip_reass_dequeue_datagram PROC
;;;303    static void
;;;304    ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
000000  b570              PUSH     {r4-r6,lr}
;;;305    {
000002  4604              MOV      r4,r0
;;;306      
;;;307      /* dequeue the reass struct  */
;;;308      if (reassdatagrams == ipr) {
000004  4809              LDR      r0,|L5.44|
000006  460d              MOV      r5,r1                 ;305
000008  6841              LDR      r1,[r0,#4]  ; reassdatagrams
00000a  42a1              CMP      r1,r4
00000c  d102              BNE      |L5.20|
;;;309        /* it was the first in the list */
;;;310        reassdatagrams = ipr->next;
00000e  6821              LDR      r1,[r4,#0]
000010  6041              STR      r1,[r0,#4]  ; reassdatagrams
000012  e005              B        |L5.32|
                  |L5.20|
;;;311      } else {
;;;312        /* it wasn't the first, so it must have a valid 'prev' */
;;;313        LWIP_ASSERT("sanity check linked list", prev != NULL);
000014  b915              CBNZ     r5,|L5.28|
000016  a006              ADR      r0,|L5.48|
000018  f7fffffe          BL       __2printf
                  |L5.28|
;;;314        prev->next = ipr->next;
00001c  6820              LDR      r0,[r4,#0]
00001e  6028              STR      r0,[r5,#0]
                  |L5.32|
;;;315      }
;;;316    
;;;317      /* now we can free the ip_reass struct */
;;;318      memp_free(MEMP_REASSDATA, ipr);
000020  4621              MOV      r1,r4
000022  e8bd4070          POP      {r4-r6,lr}
000026  2005              MOVS     r0,#5
000028  f7ffbffe          B.W      memp_free
;;;319    }
;;;320    
                          ENDP

                  |L5.44|
                          DCD      ||.data||
                  |L5.48|
000030  73616e69          DCB      "sanity check linked list",0
000034  74792063
000038  6865636b
00003c  206c696e
000040  6b656420
000044  6c697374
000048  00      
000049  00                DCB      0
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||i.ip_reass_free_complete_datagram||, CODE, READONLY, ALIGN=2

                  ip_reass_free_complete_datagram PROC
;;;157    static int
;;;158    ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;159    {
000004  4606              MOV      r6,r0
;;;160      u16_t pbufs_freed = 0;
000006  2500              MOVS     r5,#0
000008  460f              MOV      r7,r1                 ;159
;;;161      u8_t clen;
;;;162      struct pbuf *p;
;;;163      struct ip_reass_helper *iprh;
;;;164    
;;;165      LWIP_ASSERT("prev != ipr", prev != ipr);
00000a  42b1              CMP      r1,r6
00000c  d102              BNE      |L6.20|
00000e  a027              ADR      r0,|L6.172|
000010  f7fffffe          BL       __2printf
                  |L6.20|
;;;166      if (prev != NULL) {
000014  b12f              CBZ      r7,|L6.34|
;;;167        LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
000016  6838              LDR      r0,[r7,#0]
000018  42b0              CMP      r0,r6
00001a  d002              BEQ      |L6.34|
00001c  a026              ADR      r0,|L6.184|
00001e  f7fffffe          BL       __2printf
                  |L6.34|
;;;168      }
;;;169    
;;;170      snmp_inc_ipreasmfails();
;;;171    #if LWIP_ICMP
;;;172      iprh = (struct ip_reass_helper *)ipr->p->payload;
000022  6874              LDR      r4,[r6,#4]
;;;173      if (iprh->start == 0) {
;;;174        /* The first fragment was received, send ICMP time exceeded. */
;;;175        /* First, de-queue the first pbuf from r->p. */
;;;176        p = ipr->p;
;;;177        ipr->p = iprh->next_pbuf;
;;;178        /* Then, copy the original header into it. */
;;;179        SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
;;;180        icmp_time_exceeded(p, ICMP_TE_FRAG);
;;;181        clen = pbuf_clen(p);
;;;182        LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
000024  f44f3880          MOV      r8,#0x10000
000028  6860              LDR      r0,[r4,#4]            ;173
00002a  8881              LDRH     r1,[r0,#4]            ;173
00002c  b9b9              CBNZ     r1,|L6.94|
00002e  6800              LDR      r0,[r0,#0]            ;177
000030  6070              STR      r0,[r6,#4]            ;179
000032  2214              MOVS     r2,#0x14              ;179
000034  f1060108          ADD      r1,r6,#8              ;179
000038  6860              LDR      r0,[r4,#4]            ;179
00003a  f7fffffe          BL       __aeabi_memcpy
00003e  2101              MOVS     r1,#1                 ;180
000040  4620              MOV      r0,r4                 ;180
000042  f7fffffe          BL       icmp_time_exceeded
000046  4620              MOV      r0,r4                 ;181
000048  f7fffffe          BL       pbuf_clen
00004c  4605              MOV      r5,r0                 ;181
00004e  4540              CMP      r0,r8
000050  d302              BCC      |L6.88|
000052  a01e              ADR      r0,|L6.204|
000054  f7fffffe          BL       __2printf
                  |L6.88|
;;;183        pbufs_freed += clen;
;;;184        pbuf_free(p);
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       pbuf_free
                  |L6.94|
00005e  46c1              MOV      r9,r8                 ;182
;;;185      }
;;;186    #endif /* LWIP_ICMP */
;;;187    
;;;188      /* First, free all received pbufs.  The individual pbufs need to be released 
;;;189         separately as they have not yet been chained */
;;;190      p = ipr->p;
;;;191      while (p != NULL) {
000060  6874              LDR      r4,[r6,#4]
000062  e00f              B        |L6.132|
                  |L6.100|
;;;192        struct pbuf *pcur;
;;;193        iprh = (struct ip_reass_helper *)p->payload;
;;;194        pcur = p;
;;;195        /* get the next pointer before freeing */
;;;196        p = iprh->next_pbuf;
000064  6860              LDR      r0,[r4,#4]
000066  46a0              MOV      r8,r4                 ;194
000068  6804              LDR      r4,[r0,#0]
;;;197        clen = pbuf_clen(pcur);
00006a  4640              MOV      r0,r8
00006c  f7fffffe          BL       pbuf_clen
;;;198        LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
000070  4405              ADD      r5,r5,r0
000072  454d              CMP      r5,r9
000074  d302              BCC      |L6.124|
000076  a015              ADR      r0,|L6.204|
000078  f7fffffe          BL       __2printf
                  |L6.124|
;;;199        pbufs_freed += clen;
00007c  b2ad              UXTH     r5,r5
;;;200        pbuf_free(pcur);
00007e  4640              MOV      r0,r8
000080  f7fffffe          BL       pbuf_free
                  |L6.132|
000084  2c00              CMP      r4,#0                 ;191
000086  d1ed              BNE      |L6.100|
;;;201      }
;;;202      /* Then, unchain the struct ip_reassdata from the list and free it. */
;;;203      ip_reass_dequeue_datagram(ipr, prev);
000088  4639              MOV      r1,r7
00008a  4630              MOV      r0,r6
00008c  f7fffffe          BL       ip_reass_dequeue_datagram
;;;204      LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
000090  4c16              LDR      r4,|L6.236|
000092  8820              LDRH     r0,[r4,#0]  ; ip_reass_pbufcount
000094  42a8              CMP      r0,r5
000096  d202              BCS      |L6.158|
000098  a015              ADR      r0,|L6.240|
00009a  f7fffffe          BL       __2printf
                  |L6.158|
;;;205      ip_reass_pbufcount -= pbufs_freed;
00009e  8820              LDRH     r0,[r4,#0]  ; ip_reass_pbufcount
0000a0  1b40              SUBS     r0,r0,r5
0000a2  8020              STRH     r0,[r4,#0]
;;;206    
;;;207      return pbufs_freed;
0000a4  4628              MOV      r0,r5
;;;208    }
0000a6  e8bd87f0          POP      {r4-r10,pc}
;;;209    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L6.172|
0000ac  70726576          DCB      "prev != ipr",0
0000b0  20213d20
0000b4  69707200
                  |L6.184|
0000b8  70726576          DCB      "prev->next == ipr",0
0000bc  2d3e6e65
0000c0  7874203d
0000c4  3d206970
0000c8  7200    
0000ca  00                DCB      0
0000cb  00                DCB      0
                  |L6.204|
0000cc  70627566          DCB      "pbufs_freed + clen <= 0xffff",0
0000d0  735f6672
0000d4  65656420
0000d8  2b20636c
0000dc  656e203c
0000e0  3d203078
0000e4  66666666
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L6.236|
                          DCD      ||.data||
                  |L6.240|
0000f0  69705f72          DCB      "ip_reass_pbufcount >= clen",0
0000f4  65617373
0000f8  5f706275
0000fc  66636f75
000100  6e74203e
000104  3d20636c
000108  656e00  
00010b  00                DCB      0

                          AREA ||i.ip_reass_remove_oldest_datagram||, CODE, READONLY, ALIGN=2

                  ip_reass_remove_oldest_datagram PROC
;;;220    static int
;;;221    ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;222    {
;;;223      /* @todo Can't we simply remove the last datagram in the
;;;224       *       linked list behind reassdatagrams?
;;;225       */
;;;226      struct ip_reassdata *r, *oldest, *prev;
;;;227      int pbufs_freed = 0, pbufs_freed_current;
;;;228      int other_datagrams;
;;;229    
;;;230      /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
;;;231       * but don't free the datagram that 'fraghdr' belongs to! */
;;;232      do {
;;;233        oldest = NULL;
;;;234        prev = NULL;
;;;235        other_datagrams = 0;
;;;236        r = reassdatagrams;
000004  f8df8068          LDR      r8,|L7.112|
000008  460f              MOV      r7,r1                 ;222
00000a  4605              MOV      r5,r0                 ;222
00000c  2600              MOVS     r6,#0                 ;227
                  |L7.14|
00000e  2200              MOVS     r2,#0                 ;233
000010  4613              MOV      r3,r2                 ;234
000012  4614              MOV      r4,r2                 ;235
;;;237        while (r != NULL) {
000014  f8d80004          LDR      r0,[r8,#4]  ; reassdatagrams
000018  e01a              B        |L7.80|
                  |L7.26|
;;;238          if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
00001a  6941              LDR      r1,[r0,#0x14]
00001c  f8d5c00c          LDR      r12,[r5,#0xc]
000020  4561              CMP      r1,r12
000022  d109              BNE      |L7.56|
000024  6981              LDR      r1,[r0,#0x18]
000026  f8d5c010          LDR      r12,[r5,#0x10]
00002a  4561              CMP      r1,r12
00002c  d104              BNE      |L7.56|
00002e  8981              LDRH     r1,[r0,#0xc]
000030  f8b5c004          LDRH     r12,[r5,#4]
000034  4561              CMP      r1,r12
000036  d007              BEQ      |L7.72|
                  |L7.56|
000038  1c64              ADDS     r4,r4,#1
;;;239            /* Not the same datagram as fraghdr */
;;;240            other_datagrams++;
;;;241            if (oldest == NULL) {
00003a  b122              CBZ      r2,|L7.70|
;;;242              oldest = r;
;;;243            } else if (r->timer <= oldest->timer) {
00003c  7fc1              LDRB     r1,[r0,#0x1f]
00003e  f892c01f          LDRB     r12,[r2,#0x1f]
000042  4561              CMP      r1,r12
000044  d800              BHI      |L7.72|
                  |L7.70|
;;;244              /* older than the previous oldest */
;;;245              oldest = r;
000046  4602              MOV      r2,r0
                  |L7.72|
;;;246            }
;;;247          }
;;;248          if (r->next != NULL) {
000048  6801              LDR      r1,[r0,#0]
00004a  b101              CBZ      r1,|L7.78|
;;;249            prev = r;
00004c  4603              MOV      r3,r0
                  |L7.78|
00004e  4608              MOV      r0,r1
                  |L7.80|
000050  2800              CMP      r0,#0                 ;237
000052  d1e2              BNE      |L7.26|
;;;250          }
;;;251          r = r->next;
;;;252        }
;;;253        if (oldest != NULL) {
000054  b122              CBZ      r2,|L7.96|
;;;254          pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
000056  4619              MOV      r1,r3
000058  4610              MOV      r0,r2
00005a  f7fffffe          BL       ip_reass_free_complete_datagram
;;;255          pbufs_freed += pbufs_freed_current;
00005e  4406              ADD      r6,r6,r0
                  |L7.96|
;;;256        }
;;;257      } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
000060  42be              CMP      r6,r7
000062  da01              BGE      |L7.104|
000064  2c01              CMP      r4,#1
000066  dcd2              BGT      |L7.14|
                  |L7.104|
;;;258      return pbufs_freed;
000068  4630              MOV      r0,r6
;;;259    }
00006a  e8bd81f0          POP      {r4-r8,pc}
;;;260    #endif /* IP_REASS_FREE_OLDEST */
                          ENDP

00006e  0000              DCW      0x0000
                  |L7.112|
                          DCD      ||.data||

                          AREA ||i.ip_reass_tmr||, CODE, READONLY, ALIGN=2

                  ip_reass_tmr PROC
;;;121    void
;;;122    ip_reass_tmr(void)
000000  b570              PUSH     {r4-r6,lr}
;;;123    {
;;;124      struct ip_reassdata *r, *prev = NULL;
;;;125    
;;;126      r = reassdatagrams;
000002  4809              LDR      r0,|L8.40|
000004  2500              MOVS     r5,#0                 ;124
000006  6844              LDR      r4,[r0,#4]            ;123  ; reassdatagrams
000008  e00b              B        |L8.34|
                  |L8.10|
;;;127      while (r != NULL) {
;;;128        /* Decrement the timer. Once it reaches 0,
;;;129         * clean up the incomplete fragment assembly */
;;;130        if (r->timer > 0) {
00000a  7fe0              LDRB     r0,[r4,#0x1f]
00000c  b120              CBZ      r0,|L8.24|
00000e  1e40              SUBS     r0,r0,#1
;;;131          r->timer--;
000010  77e0              STRB     r0,[r4,#0x1f]
;;;132          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
;;;133          prev = r;
000012  4625              MOV      r5,r4
;;;134          r = r->next;
000014  6824              LDR      r4,[r4,#0]
000016  e004              B        |L8.34|
                  |L8.24|
;;;135        } else {
;;;136          /* reassembly timed out */
;;;137          struct ip_reassdata *tmp;
;;;138          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
;;;139          tmp = r;
;;;140          /* get the next pointer before freeing */
;;;141          r = r->next;
000018  4620              MOV      r0,r4
00001a  6824              LDR      r4,[r4,#0]
;;;142          /* free the helper struct and all enqueued pbufs */
;;;143          ip_reass_free_complete_datagram(tmp, prev);
00001c  4629              MOV      r1,r5
00001e  f7fffffe          BL       ip_reass_free_complete_datagram
                  |L8.34|
000022  2c00              CMP      r4,#0                 ;127
000024  d1f1              BNE      |L8.10|
;;;144         }
;;;145       }
;;;146    }
000026  bd70              POP      {r4-r6,pc}
;;;147    
                          ENDP

                  |L8.40|
                          DCD      ||.data||

                          AREA ||i.ipfrag_free_pbuf_custom||, CODE, READONLY, ALIGN=2

                  ipfrag_free_pbuf_custom PROC
;;;639    static void
;;;640    ipfrag_free_pbuf_custom(struct pbuf *p)
000000  b510              PUSH     {r4,lr}
;;;641    {
000002  0004              MOVS     r4,r0
000004  d102              BNE      |L9.12|
;;;642      struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref*)p;
;;;643      LWIP_ASSERT("pcr != NULL", pcr != NULL);
000006  a006              ADR      r0,|L9.32|
000008  f7fffffe          BL       __2printf
                  |L9.12|
;;;644      LWIP_ASSERT("pcr == p", (void*)pcr == (void*)p);
;;;645      if (pcr->original != NULL) {
00000c  6960              LDR      r0,[r4,#0x14]
00000e  b108              CBZ      r0,|L9.20|
;;;646        pbuf_free(pcr->original);
000010  f7fffffe          BL       pbuf_free
                  |L9.20|
;;;647      }
;;;648      ip_frag_free_pbuf_custom_ref(pcr);
000014  4620              MOV      r0,r4
000016  e8bd4010          POP      {r4,lr}
00001a  f7ffbffe          B.W      ip_frag_free_pbuf_custom_ref
;;;649    }
;;;650    #endif /* !LWIP_NETIF_TX_SINGLE_PBUF */
                          ENDP

00001e  0000              DCW      0x0000
                  |L9.32|
000020  70637220          DCB      "pcr != NULL",0
000024  213d204e
000028  554c4c00

                          AREA ||.data||, DATA, ALIGN=2

                  ip_reass_pbufcount
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  reassdatagrams
                          DCD      0x00000000

; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\queue.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\queue.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\ZR60_v1.0_freeRTOS -I..\..\Lwip\App -I..\..\Lwip\Bsp -I..\..\Lwip\Bsp\LAN8742A -I..\..\Lwip\lwip-1.4.1 -I..\..\Lwip\lwip-1.4.1\port -I..\..\Lwip\lwip-1.4.1\port\arch -I..\..\Lwip\lwip-1.4.1\port\Standalone -I..\..\Lwip\lwip-1.4.1\src\include -I..\..\Lwip\lwip-1.4.1\src\include\ipv4 -I..\..\Lwip\lwip-1.4.1\src\include\lwip -I..\..\Lwip\lwip-1.4.1\src\include\netif -I..\..\Ecal\BtnFltr -I..\..\Ecal\UartComn -I..\..\Ecal\MemIf -I..\..\APP -I..\..\APP\BlackListMng -I..\..\APP\SeverNewsPush -I..\..\APP\NewsPull -I..\..\Ecal -I..\..\Ecal\JsonIf -I..\..\Ecal\Mcu_Init -I..\..\Service -I..\..\Complex -I..\..\Complex\FATFS -I..\..\FreeRTOS\Source\include -I..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\FreeRTOS -I.\RTE\_ZR60 -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=..\..\output\queue.crf ..\..\FreeRTOS\Source\queue.c]
                          THUMB

                          AREA ||i.prvCopyDataFromQueue||, CODE, READONLY, ALIGN=1

                  prvCopyDataFromQueue PROC
;;;1858   
;;;1859   static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
000000  b430              PUSH     {r4,r5}
;;;1860   {
000002  6c02              LDR      r2,[r0,#0x40]
000004  460b              MOV      r3,r1
000006  2a00              CMP      r2,#0
000008  d00b              BEQ      |L1.34|
;;;1861   	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
;;;1862   	{
;;;1863   		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
00000a  68c1              LDR      r1,[r0,#0xc]
00000c  4411              ADD      r1,r1,r2
;;;1864   		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
00000e  60c1              STR      r1,[r0,#0xc]
000010  6844              LDR      r4,[r0,#4]
000012  42a1              CMP      r1,r4
000014  d301              BCC      |L1.26|
;;;1865   		{
;;;1866   			pxQueue->u.pcReadFrom = pxQueue->pcHead;
000016  6801              LDR      r1,[r0,#0]
000018  60c1              STR      r1,[r0,#0xc]
                  |L1.26|
;;;1867   		}
;;;1868   		else
;;;1869   		{
;;;1870   			mtCOVERAGE_TEST_MARKER();
;;;1871   		}
;;;1872   		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
00001a  bc30              POP      {r4,r5}
00001c  4618              MOV      r0,r3
00001e  f7ffbffe          B.W      __aeabi_memcpy
                  |L1.34|
;;;1873   	}
;;;1874   }
000022  bc30              POP      {r4,r5}
000024  4770              BX       lr
;;;1875   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvCopyDataToQueue||, CODE, READONLY, ALIGN=1

                  prvCopyDataToQueue PROC
;;;1784   
;;;1785   static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
000000  b570              PUSH     {r4-r6,lr}
;;;1786   {
000002  4616              MOV      r6,r2
000004  6c02              LDR      r2,[r0,#0x40]
000006  4604              MOV      r4,r0
;;;1787   BaseType_t xReturn = pdFALSE;
000008  2500              MOVS     r5,#0
00000a  b182              CBZ      r2,|L2.46|
;;;1788   
;;;1789   	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
;;;1790   	{
;;;1791   		#if ( configUSE_MUTEXES == 1 )
;;;1792   		{
;;;1793   			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1794   			{
;;;1795   				/* The mutex is no longer being held. */
;;;1796   				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
;;;1797   				pxQueue->pxMutexHolder = NULL;
;;;1798   			}
;;;1799   			else
;;;1800   			{
;;;1801   				mtCOVERAGE_TEST_MARKER();
;;;1802   			}
;;;1803   		}
;;;1804   		#endif /* configUSE_MUTEXES */
;;;1805   	}
;;;1806   	else if( xPosition == queueSEND_TO_BACK )
00000c  b1c6              CBZ      r6,|L2.64|
;;;1807   	{
;;;1808   		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
;;;1809   		pxQueue->pcWriteTo += pxQueue->uxItemSize;
;;;1810   		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
;;;1811   		{
;;;1812   			pxQueue->pcWriteTo = pxQueue->pcHead;
;;;1813   		}
;;;1814   		else
;;;1815   		{
;;;1816   			mtCOVERAGE_TEST_MARKER();
;;;1817   		}
;;;1818   	}
;;;1819   	else
;;;1820   	{
;;;1821   		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00000e  68e0              LDR      r0,[r4,#0xc]
000010  f7fffffe          BL       __aeabi_memcpy
;;;1822   		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
000014  68e1              LDR      r1,[r4,#0xc]
000016  6c20              LDR      r0,[r4,#0x40]
000018  1a09              SUBS     r1,r1,r0
;;;1823   		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
00001a  60e1              STR      r1,[r4,#0xc]
00001c  6822              LDR      r2,[r4,#0]
00001e  4291              CMP      r1,r2
000020  d202              BCS      |L2.40|
;;;1824   		{
;;;1825   			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
000022  6861              LDR      r1,[r4,#4]
000024  1a08              SUBS     r0,r1,r0
000026  60e0              STR      r0,[r4,#0xc]
                  |L2.40|
;;;1826   		}
;;;1827   		else
;;;1828   		{
;;;1829   			mtCOVERAGE_TEST_MARKER();
;;;1830   		}
;;;1831   
;;;1832   		if( xPosition == queueOVERWRITE )
000028  2e02              CMP      r6,#2
00002a  d016              BEQ      |L2.90|
00002c  e01a              B        |L2.100|
                  |L2.46|
00002e  6820              LDR      r0,[r4,#0]            ;1793
000030  b9c0              CBNZ     r0,|L2.100|
000032  6860              LDR      r0,[r4,#4]            ;1796
000034  f7fffffe          BL       xTaskPriorityDisinherit
000038  4605              MOV      r5,r0                 ;1796
00003a  2000              MOVS     r0,#0                 ;1797
00003c  6060              STR      r0,[r4,#4]            ;1797
00003e  e011              B        |L2.100|
                  |L2.64|
000040  68a0              LDR      r0,[r4,#8]            ;1808
000042  f7fffffe          BL       __aeabi_memcpy
000046  6c21              LDR      r1,[r4,#0x40]         ;1809
000048  68a0              LDR      r0,[r4,#8]            ;1809
00004a  4408              ADD      r0,r0,r1              ;1809
00004c  60a0              STR      r0,[r4,#8]            ;1810
00004e  6861              LDR      r1,[r4,#4]            ;1810
000050  4288              CMP      r0,r1                 ;1810
000052  d307              BCC      |L2.100|
000054  6820              LDR      r0,[r4,#0]            ;1812
000056  60a0              STR      r0,[r4,#8]            ;1812
000058  e004              B        |L2.100|
                  |L2.90|
;;;1833   		{
;;;1834   			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
00005a  6ba0              LDR      r0,[r4,#0x38]
00005c  b110              CBZ      r0,|L2.100|
;;;1835   			{
;;;1836   				/* An item is not being added but overwritten, so subtract
;;;1837   				one from the recorded number of items in the queue so when
;;;1838   				one is added again below the number of recorded items remains
;;;1839   				correct. */
;;;1840   				--( pxQueue->uxMessagesWaiting );
00005e  6ba0              LDR      r0,[r4,#0x38]
000060  1e40              SUBS     r0,r0,#1
000062  63a0              STR      r0,[r4,#0x38]
                  |L2.100|
;;;1841   			}
;;;1842   			else
;;;1843   			{
;;;1844   				mtCOVERAGE_TEST_MARKER();
;;;1845   			}
;;;1846   		}
;;;1847   		else
;;;1848   		{
;;;1849   			mtCOVERAGE_TEST_MARKER();
;;;1850   		}
;;;1851   	}
;;;1852   
;;;1853   	++( pxQueue->uxMessagesWaiting );
000064  6ba0              LDR      r0,[r4,#0x38]
000066  1c40              ADDS     r0,r0,#1
000068  63a0              STR      r0,[r4,#0x38]
;;;1854   
;;;1855   	return xReturn;
00006a  4628              MOV      r0,r5
;;;1856   }
00006c  bd70              POP      {r4-r6,pc}
;;;1857   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvUnlockQueue||, CODE, READONLY, ALIGN=1

                  prvUnlockQueue PROC
;;;1876   
;;;1877   static void prvUnlockQueue( Queue_t * const pxQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1878   {
000002  4604              MOV      r4,r0
;;;1879   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
;;;1880   
;;;1881   	/* The lock counts contains the number of extra data items placed or
;;;1882   	removed from the queue while the queue was locked.  When a queue is
;;;1883   	locked items can be added or removed, but the event lists cannot be
;;;1884   	updated. */
;;;1885   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1886   	{
;;;1887   		/* See if data was added to the queue while it was locked. */
;;;1888   		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
;;;1889   		{
;;;1890   			/* Data was posted while the queue was locked.  Are any tasks
;;;1891   			blocked waiting for data to become available? */
;;;1892   			#if ( configUSE_QUEUE_SETS == 1 )
;;;1893   			{
;;;1894   				if( pxQueue->pxQueueSetContainer != NULL )
;;;1895   				{
;;;1896   					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
;;;1897   					{
;;;1898   						/* The queue is a member of a queue set, and posting to
;;;1899   						the queue set caused a higher priority task to unblock.
;;;1900   						A context switch is required. */
;;;1901   						vTaskMissedYield();
;;;1902   					}
;;;1903   					else
;;;1904   					{
;;;1905   						mtCOVERAGE_TEST_MARKER();
;;;1906   					}
;;;1907   				}
;;;1908   				else
;;;1909   				{
;;;1910   					/* Tasks that are removed from the event list will get added to
;;;1911   					the pending ready list as the scheduler is still suspended. */
;;;1912   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1913   					{
;;;1914   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1915   						{
;;;1916   							/* The task waiting has a higher priority so record that a
;;;1917   							context	switch is required. */
;;;1918   							vTaskMissedYield();
;;;1919   						}
;;;1920   						else
;;;1921   						{
;;;1922   							mtCOVERAGE_TEST_MARKER();
;;;1923   						}
;;;1924   					}
;;;1925   					else
;;;1926   					{
;;;1927   						break;
;;;1928   					}
;;;1929   				}
;;;1930   			}
;;;1931   			#else /* configUSE_QUEUE_SETS */
;;;1932   			{
;;;1933   				/* Tasks that are removed from the event list will get added to
;;;1934   				the pending ready list as the scheduler is still suspended. */
;;;1935   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1936   				{
;;;1937   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000008  f1040524          ADD      r5,r4,#0x24
00000c  e00a              B        |L3.36|
                  |L3.14|
00000e  6a60              LDR      r0,[r4,#0x24]         ;1935
000010  b158              CBZ      r0,|L3.42|
000012  4628              MOV      r0,r5                 ;1935
000014  f7fffffe          BL       xTaskRemoveFromEventList
000018  b108              CBZ      r0,|L3.30|
;;;1938   					{
;;;1939   						/* The task waiting has a higher priority so record that a
;;;1940   						context	switch is required. */
;;;1941   						vTaskMissedYield();
00001a  f7fffffe          BL       vTaskMissedYield
                  |L3.30|
;;;1942   					}
;;;1943   					else
;;;1944   					{
;;;1945   						mtCOVERAGE_TEST_MARKER();
;;;1946   					}
;;;1947   				}
;;;1948   				else
;;;1949   				{
;;;1950   					break;
;;;1951   				}
;;;1952   			}
;;;1953   			#endif /* configUSE_QUEUE_SETS */
;;;1954   
;;;1955   			--( pxQueue->xTxLock );
00001e  6ca0              LDR      r0,[r4,#0x48]
000020  1e40              SUBS     r0,r0,#1
000022  64a0              STR      r0,[r4,#0x48]
                  |L3.36|
000024  6ca0              LDR      r0,[r4,#0x48]         ;1888
000026  2800              CMP      r0,#0                 ;1888
000028  dcf1              BGT      |L3.14|
                  |L3.42|
;;;1956   		}
;;;1957   
;;;1958   		pxQueue->xTxLock = queueUNLOCKED;
00002a  f04f35ff          MOV      r5,#0xffffffff
00002e  64a5              STR      r5,[r4,#0x48]
;;;1959   	}
;;;1960   	taskEXIT_CRITICAL();
000030  f7fffffe          BL       vPortExitCritical
;;;1961   
;;;1962   	/* Do the same for the Rx lock. */
;;;1963   	taskENTER_CRITICAL();
000034  f7fffffe          BL       vPortEnterCritical
;;;1964   	{
;;;1965   		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
;;;1966   		{
;;;1967   			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;1968   			{
;;;1969   				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000038  f1040610          ADD      r6,r4,#0x10
00003c  e00a              B        |L3.84|
                  |L3.62|
00003e  6920              LDR      r0,[r4,#0x10]         ;1967
000040  b158              CBZ      r0,|L3.90|
000042  4630              MOV      r0,r6                 ;1967
000044  f7fffffe          BL       xTaskRemoveFromEventList
000048  b108              CBZ      r0,|L3.78|
;;;1970   				{
;;;1971   					vTaskMissedYield();
00004a  f7fffffe          BL       vTaskMissedYield
                  |L3.78|
;;;1972   				}
;;;1973   				else
;;;1974   				{
;;;1975   					mtCOVERAGE_TEST_MARKER();
;;;1976   				}
;;;1977   
;;;1978   				--( pxQueue->xRxLock );
00004e  6c60              LDR      r0,[r4,#0x44]
000050  1e40              SUBS     r0,r0,#1
000052  6460              STR      r0,[r4,#0x44]
                  |L3.84|
000054  6c60              LDR      r0,[r4,#0x44]         ;1965
000056  2800              CMP      r0,#0                 ;1965
000058  dcf1              BGT      |L3.62|
                  |L3.90|
;;;1979   			}
;;;1980   			else
;;;1981   			{
;;;1982   				break;
;;;1983   			}
;;;1984   		}
;;;1985   
;;;1986   		pxQueue->xRxLock = queueUNLOCKED;
00005a  6465              STR      r5,[r4,#0x44]
;;;1987   	}
;;;1988   	taskEXIT_CRITICAL();
00005c  e8bd4070          POP      {r4-r6,lr}
000060  f7ffbffe          B.W      vPortExitCritical
;;;1989   }
;;;1990   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxQueueMessagesWaiting||, CODE, READONLY, ALIGN=1

                  uxQueueMessagesWaiting PROC
;;;1692   
;;;1693   UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
000000  b510              PUSH     {r4,lr}
;;;1694   {
000002  4604              MOV      r4,r0
;;;1695   UBaseType_t uxReturn;
;;;1696   
;;;1697   	configASSERT( xQueue );
;;;1698   
;;;1699   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1700   	{
;;;1701   		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
000008  6ba4              LDR      r4,[r4,#0x38]
;;;1702   	}
;;;1703   	taskEXIT_CRITICAL();
00000a  f7fffffe          BL       vPortExitCritical
;;;1704   
;;;1705   	return uxReturn;
00000e  4620              MOV      r0,r4
;;;1706   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000010  bd10              POP      {r4,pc}
;;;1707   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxQueueMessagesWaitingFromISR||, CODE, READONLY, ALIGN=1

                  uxQueueMessagesWaitingFromISR PROC
;;;1726   
;;;1727   UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
000000  6b80              LDR      r0,[r0,#0x38]
;;;1728   {
;;;1729   UBaseType_t uxReturn;
;;;1730   
;;;1731   	configASSERT( xQueue );
;;;1732   
;;;1733   	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
;;;1734   
;;;1735   	return uxReturn;
;;;1736   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000002  4770              BX       lr
;;;1737   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxQueueSpacesAvailable||, CODE, READONLY, ALIGN=1

                  uxQueueSpacesAvailable PROC
;;;1708   
;;;1709   UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
000000  b510              PUSH     {r4,lr}
;;;1710   {
000002  4604              MOV      r4,r0
;;;1711   UBaseType_t uxReturn;
;;;1712   Queue_t *pxQueue;
;;;1713   
;;;1714   	pxQueue = ( Queue_t * ) xQueue;
;;;1715   	configASSERT( pxQueue );
;;;1716   
;;;1717   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1718   	{
;;;1719   		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
000008  e9d4100e          LDRD     r1,r0,[r4,#0x38]
00000c  1a44              SUBS     r4,r0,r1
;;;1720   	}
;;;1721   	taskEXIT_CRITICAL();
00000e  f7fffffe          BL       vPortExitCritical
;;;1722   
;;;1723   	return uxReturn;
000012  4620              MOV      r0,r4
;;;1724   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000014  bd10              POP      {r4,pc}
;;;1725   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vQueueDelete||, CODE, READONLY, ALIGN=1

                  vQueueDelete PROC
;;;1738   
;;;1739   void vQueueDelete( QueueHandle_t xQueue )
000000  f7ffbffe          B.W      vPortFree
;;;1740   {
;;;1741   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;1742   
;;;1743   	configASSERT( pxQueue );
;;;1744   
;;;1745   	traceQUEUE_DELETE( pxQueue );
;;;1746   	#if ( configQUEUE_REGISTRY_SIZE > 0 )
;;;1747   	{
;;;1748   		vQueueUnregisterQueue( pxQueue );
;;;1749   	}
;;;1750   	#endif
;;;1751   	vPortFree( pxQueue );
;;;1752   }
;;;1753   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueCreateCountingSemaphore||, CODE, READONLY, ALIGN=1

                  xQueueCreateCountingSemaphore PROC
;;;582    
;;;583    	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
000000  b510              PUSH     {r4,lr}
;;;584    	{
000002  460c              MOV      r4,r1
;;;585    	QueueHandle_t xHandle;
;;;586    
;;;587    		configASSERT( uxMaxCount != 0 );
;;;588    		configASSERT( uxInitialCount <= uxMaxCount );
;;;589    
;;;590    		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
000004  2202              MOVS     r2,#2
000006  2100              MOVS     r1,#0
000008  f7fffffe          BL       xQueueGenericCreate
;;;591    
;;;592    		if( xHandle != NULL )
00000c  2800              CMP      r0,#0
00000e  d000              BEQ      |L8.18|
;;;593    		{
;;;594    			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
000010  6384              STR      r4,[r0,#0x38]
                  |L8.18|
;;;595    
;;;596    			traceCREATE_COUNTING_SEMAPHORE();
;;;597    		}
;;;598    		else
;;;599    		{
;;;600    			traceCREATE_COUNTING_SEMAPHORE_FAILED();
;;;601    		}
;;;602    
;;;603    		configASSERT( xHandle );
;;;604    		return xHandle;
;;;605    	}
000012  bd10              POP      {r4,pc}
;;;606    
                          ENDP


                          AREA ||i.xQueueCreateMutex||, CODE, READONLY, ALIGN=1

                  xQueueCreateMutex PROC
;;;390    
;;;391    	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
000000  b510              PUSH     {r4,lr}
;;;392    	{
;;;393    	Queue_t *pxNewQueue;
;;;394    
;;;395    		/* Prevent compiler warnings about unused parameters if
;;;396    		configUSE_TRACE_FACILITY does not equal 1. */
;;;397    		( void ) ucQueueType;
;;;398    
;;;399    		/* Allocate the new queue structure. */
;;;400    		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
000002  204c              MOVS     r0,#0x4c
000004  f7fffffe          BL       pvPortMalloc
000008  0004              MOVS     r4,r0
;;;401    		if( pxNewQueue != NULL )
00000a  d019              BEQ      |L9.64|
;;;402    		{
;;;403    			/* Information required for priority inheritance. */
;;;404    			pxNewQueue->pxMutexHolder = NULL;
00000c  2000              MOVS     r0,#0
;;;405    			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
00000e  6060              STR      r0,[r4,#4]
;;;406    
;;;407    			/* Queues used as a mutex no data is actually copied into or out
;;;408    			of the queue. */
;;;409    			pxNewQueue->pcWriteTo = NULL;
000010  6020              STR      r0,[r4,#0]
;;;410    			pxNewQueue->u.pcReadFrom = NULL;
000012  60a0              STR      r0,[r4,#8]
;;;411    
;;;412    			/* Each mutex has a length of 1 (like a binary semaphore) and
;;;413    			an item size of 0 as nothing is actually copied into or out
;;;414    			of the mutex. */
;;;415    			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
000014  60e0              STR      r0,[r4,#0xc]
000016  63a0              STR      r0,[r4,#0x38]
;;;416    			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
000018  2101              MOVS     r1,#1
00001a  e9c4100f          STRD     r1,r0,[r4,#0x3c]
;;;417    			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
;;;418    			pxNewQueue->xRxLock = queueUNLOCKED;
00001e  1e40              SUBS     r0,r0,#1
000020  6460              STR      r0,[r4,#0x44]
;;;419    			pxNewQueue->xTxLock = queueUNLOCKED;
000022  64a0              STR      r0,[r4,#0x48]
;;;420    
;;;421    			#if ( configUSE_TRACE_FACILITY == 1 )
;;;422    			{
;;;423    				pxNewQueue->ucQueueType = ucQueueType;
;;;424    			}
;;;425    			#endif
;;;426    
;;;427    			#if ( configUSE_QUEUE_SETS == 1 )
;;;428    			{
;;;429    				pxNewQueue->pxQueueSetContainer = NULL;
;;;430    			}
;;;431    			#endif
;;;432    
;;;433    			/* Ensure the event queues start with the correct state. */
;;;434    			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
000024  f1040010          ADD      r0,r4,#0x10
000028  f7fffffe          BL       vListInitialise
;;;435    			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
00002c  f1040024          ADD      r0,r4,#0x24
000030  f7fffffe          BL       vListInitialise
;;;436    
;;;437    			traceCREATE_MUTEX( pxNewQueue );
;;;438    
;;;439    			/* Start with the semaphore in the expected state. */
;;;440    			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
000034  2300              MOVS     r3,#0
000036  461a              MOV      r2,r3
000038  4619              MOV      r1,r3
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       xQueueGenericSend
                  |L9.64|
;;;441    		}
;;;442    		else
;;;443    		{
;;;444    			traceCREATE_MUTEX_FAILED();
;;;445    		}
;;;446    
;;;447    		configASSERT( pxNewQueue );
;;;448    		return pxNewQueue;
000040  4620              MOV      r0,r4
;;;449    	}
000042  bd10              POP      {r4,pc}
;;;450    
                          ENDP


                          AREA ||i.xQueueGenericCreate||, CODE, READONLY, ALIGN=1

                  xQueueGenericCreate PROC
;;;312    
;;;313    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;314    {
000004  000d              MOVS     r5,r1
000006  4606              MOV      r6,r0
;;;315    Queue_t *pxNewQueue;
;;;316    size_t xQueueSizeInBytes;
;;;317    QueueHandle_t xReturn = NULL;
000008  f04f0700          MOV      r7,#0
00000c  d015              BEQ      |L10.58|
;;;318    
;;;319    	/* Remove compiler warnings about unused parameters should
;;;320    	configUSE_TRACE_FACILITY not be set to 1. */
;;;321    	( void ) ucQueueType;
;;;322    
;;;323    	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
;;;324    
;;;325    	if( uxItemSize == ( UBaseType_t ) 0 )
;;;326    	{
;;;327    		/* There is not going to be a queue storage area. */
;;;328    		xQueueSizeInBytes = ( size_t ) 0;
;;;329    	}
;;;330    	else
;;;331    	{
;;;332    		/* The queue is one byte longer than asked for to make wrap checking
;;;333    		easier/faster. */
;;;334    		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00000e  fb06f005          MUL      r0,r6,r5
000012  1c40              ADDS     r0,r0,#1
                  |L10.20|
000014  304c              ADDS     r0,r0,#0x4c
;;;335    	}
;;;336    
;;;337    	/* Allocate the new queue structure and storage area. */
;;;338    	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
000016  f7fffffe          BL       pvPortMalloc
00001a  0004              MOVS     r4,r0
;;;339    
;;;340    	if( pxNewQueue != NULL )
00001c  d00a              BEQ      |L10.52|
;;;341    	{
;;;342    		if( uxItemSize == ( UBaseType_t ) 0 )
00001e  b175              CBZ      r5,|L10.62|
;;;343    		{
;;;344    			/* No RAM was allocated for the queue storage area, but PC head
;;;345    			cannot be set to NULL because NULL is used as a key to say the queue
;;;346    			is used as a mutex.  Therefore just set pcHead to point to the queue
;;;347    			as a benign value that is known to be within the memory map. */
;;;348    			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
;;;349    		}
;;;350    		else
;;;351    		{
;;;352    			/* Jump past the queue structure to find the location of the queue
;;;353    			storage area. */
;;;354    			pxNewQueue->pcHead = ( ( int8_t * ) pxNewQueue ) + sizeof( Queue_t );
000020  f104004c          ADD      r0,r4,#0x4c
000024  6020              STR      r0,[r4,#0]
                  |L10.38|
;;;355    		}
;;;356    
;;;357    		/* Initialise the queue members as described above where the queue type
;;;358    		is defined. */
;;;359    		pxNewQueue->uxLength = uxQueueLength;
;;;360    		pxNewQueue->uxItemSize = uxItemSize;
;;;361    		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
000026  e9c4650f          STRD     r6,r5,[r4,#0x3c]
00002a  2101              MOVS     r1,#1
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       xQueueGenericReset
;;;362    
;;;363    		#if ( configUSE_TRACE_FACILITY == 1 )
;;;364    		{
;;;365    			pxNewQueue->ucQueueType = ucQueueType;
;;;366    		}
;;;367    		#endif /* configUSE_TRACE_FACILITY */
;;;368    
;;;369    		#if( configUSE_QUEUE_SETS == 1 )
;;;370    		{
;;;371    			pxNewQueue->pxQueueSetContainer = NULL;
;;;372    		}
;;;373    		#endif /* configUSE_QUEUE_SETS */
;;;374    
;;;375    		traceQUEUE_CREATE( pxNewQueue );
;;;376    		xReturn = pxNewQueue;
000032  4627              MOV      r7,r4
                  |L10.52|
;;;377    	}
;;;378    	else
;;;379    	{
;;;380    		mtCOVERAGE_TEST_MARKER();
;;;381    	}
;;;382    
;;;383    	configASSERT( xReturn );
;;;384    
;;;385    	return xReturn;
000034  4638              MOV      r0,r7
;;;386    }
000036  e8bd81f0          POP      {r4-r8,pc}
                  |L10.58|
00003a  2000              MOVS     r0,#0                 ;328
00003c  e7ea              B        |L10.20|
                  |L10.62|
00003e  6024              STR      r4,[r4,#0]            ;348
000040  e7f1              B        |L10.38|
;;;387    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGenericReceive||, CODE, READONLY, ALIGN=2

                  xQueueGenericReceive PROC
;;;1364   
;;;1365   BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1366   {
;;;1367   BaseType_t xEntryTimeSet = pdFALSE;
000004  2600              MOVS     r6,#0
000006  b083              SUB      sp,sp,#0xc            ;1366
000008  469a              MOV      r10,r3                ;1366
00000a  468b              MOV      r11,r1                ;1366
00000c  4604              MOV      r4,r0                 ;1366
00000e  46b1              MOV      r9,r6
;;;1368   TimeOut_t xTimeOut;
;;;1369   int8_t *pcOriginalReadPosition;
;;;1370   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;1371   
;;;1372   	configASSERT( pxQueue );
;;;1373   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;1374   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1375   	{
;;;1376   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;1377   	}
;;;1378   	#endif
;;;1379   
;;;1380   	/* This function relaxes the coding standard somewhat to allow return
;;;1381   	statements within the function itself.  This is done in the interest
;;;1382   	of execution time efficiency. */
;;;1383   
;;;1384   	for( ;; )
;;;1385   	{
;;;1386   		taskENTER_CRITICAL();
;;;1387   		{
;;;1388   			/* Is there data in the queue now?  To be running the calling task
;;;1389   			must be	the highest priority task wanting to access the queue. */
;;;1390   			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
;;;1391   			{
;;;1392   				/* Remember the read position in case the queue is only being
;;;1393   				peeked. */
;;;1394   				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
;;;1395   
;;;1396   				prvCopyDataFromQueue( pxQueue, pvBuffer );
;;;1397   
;;;1398   				if( xJustPeeking == pdFALSE )
;;;1399   				{
;;;1400   					traceQUEUE_RECEIVE( pxQueue );
;;;1401   
;;;1402   					/* Actually removing data, not just peeking. */
;;;1403   					--( pxQueue->uxMessagesWaiting );
;;;1404   
;;;1405   					#if ( configUSE_MUTEXES == 1 )
;;;1406   					{
;;;1407   						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1408   						{
;;;1409   							/* Record the information required to implement
;;;1410   							priority inheritance should it become necessary. */
;;;1411   							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
;;;1412   						}
;;;1413   						else
;;;1414   						{
;;;1415   							mtCOVERAGE_TEST_MARKER();
;;;1416   						}
;;;1417   					}
;;;1418   					#endif /* configUSE_MUTEXES */
;;;1419   
;;;1420   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;1421   					{
;;;1422   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
;;;1423   						{
;;;1424   							queueYIELD_IF_USING_PREEMPTION();
000010  f04f5780          MOV      r7,#0x10000000
000014  f8df8110          LDR      r8,|L11.296|
                  |L11.24|
000018  f7fffffe          BL       vPortEnterCritical
00001c  6ba0              LDR      r0,[r4,#0x38]         ;1390
00001e  b368              CBZ      r0,|L11.124|
000020  4659              MOV      r1,r11                ;1396
000022  4620              MOV      r0,r4                 ;1396
000024  68e5              LDR      r5,[r4,#0xc]          ;1396
000026  f7fffffe          BL       prvCopyDataFromQueue
00002a  f1ba0f00          CMP      r10,#0                ;1398
00002e  d013              BEQ      |L11.88|
;;;1425   						}
;;;1426   						else
;;;1427   						{
;;;1428   							mtCOVERAGE_TEST_MARKER();
;;;1429   						}
;;;1430   					}
;;;1431   					else
;;;1432   					{
;;;1433   						mtCOVERAGE_TEST_MARKER();
;;;1434   					}
;;;1435   				}
;;;1436   				else
;;;1437   				{
;;;1438   					traceQUEUE_PEEK( pxQueue );
;;;1439   
;;;1440   					/* The data is not being removed, so reset the read
;;;1441   					pointer. */
;;;1442   					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
;;;1443   
;;;1444   					/* The data is being left in the queue, so see if there are
;;;1445   					any other tasks waiting for the data. */
;;;1446   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
000030  60e5              STR      r5,[r4,#0xc]
000032  6a60              LDR      r0,[r4,#0x24]
000034  b150              CBZ      r0,|L11.76|
;;;1447   					{
;;;1448   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000036  f1040024          ADD      r0,r4,#0x24
00003a  f7fffffe          BL       xTaskRemoveFromEventList
00003e  b128              CBZ      r0,|L11.76|
                  |L11.64|
;;;1449   						{
;;;1450   							/* The task waiting has a higher priority than this task. */
;;;1451   							queueYIELD_IF_USING_PREEMPTION();
000040  f8c87000          STR      r7,[r8,#0]
000044  f3bf8f4f          DSB      
000048  f3bf8f6f          ISB      
                  |L11.76|
;;;1452   						}
;;;1453   						else
;;;1454   						{
;;;1455   							mtCOVERAGE_TEST_MARKER();
;;;1456   						}
;;;1457   					}
;;;1458   					else
;;;1459   					{
;;;1460   						mtCOVERAGE_TEST_MARKER();
;;;1461   					}
;;;1462   				}
;;;1463   
;;;1464   				taskEXIT_CRITICAL();
00004c  f7fffffe          BL       vPortExitCritical
;;;1465   				return pdPASS;
000050  2001              MOVS     r0,#1
                  |L11.82|
;;;1466   			}
;;;1467   			else
;;;1468   			{
;;;1469   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1470   				{
;;;1471   					/* The queue was empty and no block time is specified (or
;;;1472   					the block time has expired) so leave now. */
;;;1473   					taskEXIT_CRITICAL();
;;;1474   					traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1475   					return errQUEUE_EMPTY;
;;;1476   				}
;;;1477   				else if( xEntryTimeSet == pdFALSE )
;;;1478   				{
;;;1479   					/* The queue was empty and a block time was specified so
;;;1480   					configure the timeout structure. */
;;;1481   					vTaskSetTimeOutState( &xTimeOut );
;;;1482   					xEntryTimeSet = pdTRUE;
;;;1483   				}
;;;1484   				else
;;;1485   				{
;;;1486   					/* Entry time was already set. */
;;;1487   					mtCOVERAGE_TEST_MARKER();
;;;1488   				}
;;;1489   			}
;;;1490   		}
;;;1491   		taskEXIT_CRITICAL();
;;;1492   
;;;1493   		/* Interrupts and other tasks can send to and receive from the queue
;;;1494   		now the critical section has been exited. */
;;;1495   
;;;1496   		vTaskSuspendAll();
;;;1497   		prvLockQueue( pxQueue );
;;;1498   
;;;1499   		/* Update the timeout state to see if it has expired yet. */
;;;1500   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1501   		{
;;;1502   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1503   			{
;;;1504   				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
;;;1505   
;;;1506   				#if ( configUSE_MUTEXES == 1 )
;;;1507   				{
;;;1508   					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1509   					{
;;;1510   						taskENTER_CRITICAL();
;;;1511   						{
;;;1512   							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
;;;1513   						}
;;;1514   						taskEXIT_CRITICAL();
;;;1515   					}
;;;1516   					else
;;;1517   					{
;;;1518   						mtCOVERAGE_TEST_MARKER();
;;;1519   					}
;;;1520   				}
;;;1521   				#endif
;;;1522   
;;;1523   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1524   				prvUnlockQueue( pxQueue );
;;;1525   				if( xTaskResumeAll() == pdFALSE )
;;;1526   				{
;;;1527   					portYIELD_WITHIN_API();
;;;1528   				}
;;;1529   				else
;;;1530   				{
;;;1531   					mtCOVERAGE_TEST_MARKER();
;;;1532   				}
;;;1533   			}
;;;1534   			else
;;;1535   			{
;;;1536   				/* Try again. */
;;;1537   				prvUnlockQueue( pxQueue );
;;;1538   				( void ) xTaskResumeAll();
;;;1539   			}
;;;1540   		}
;;;1541   		else
;;;1542   		{
;;;1543   			prvUnlockQueue( pxQueue );
;;;1544   			( void ) xTaskResumeAll();
;;;1545   			traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1546   			return errQUEUE_EMPTY;
;;;1547   		}
;;;1548   	}
;;;1549   }
000052  b007              ADD      sp,sp,#0x1c
000054  e8bd8ff0          POP      {r4-r11,pc}
                  |L11.88|
000058  6ba0              LDR      r0,[r4,#0x38]         ;1403
00005a  1e40              SUBS     r0,r0,#1              ;1403
00005c  63a0              STR      r0,[r4,#0x38]         ;1403
00005e  6820              LDR      r0,[r4,#0]            ;1407
000060  b910              CBNZ     r0,|L11.104|
000062  f7fffffe          BL       pvTaskIncrementMutexHeldCount
000066  6060              STR      r0,[r4,#4]            ;1411
                  |L11.104|
000068  6920              LDR      r0,[r4,#0x10]         ;1420
00006a  2800              CMP      r0,#0                 ;1420
00006c  d0ee              BEQ      |L11.76|
00006e  f1040010          ADD      r0,r4,#0x10           ;1422
000072  f7fffffe          BL       xTaskRemoveFromEventList
000076  2801              CMP      r0,#1                 ;1422
000078  d0e2              BEQ      |L11.64|
00007a  e7e7              B        |L11.76|
                  |L11.124|
00007c  9805              LDR      r0,[sp,#0x14]         ;1469
00007e  b108              CBZ      r0,|L11.132|
000080  b11e              CBZ      r6,|L11.138|
000082  e006              B        |L11.146|
                  |L11.132|
000084  f7fffffe          BL       vPortExitCritical
000088  e01f              B        |L11.202|
                  |L11.138|
00008a  4668              MOV      r0,sp                 ;1481
00008c  f7fffffe          BL       vTaskSetTimeOutState
000090  2601              MOVS     r6,#1                 ;1482
                  |L11.146|
000092  f7fffffe          BL       vPortExitCritical
000096  f7fffffe          BL       vTaskSuspendAll
00009a  f7fffffe          BL       vPortEnterCritical
00009e  6c60              LDR      r0,[r4,#0x44]         ;1497
0000a0  1c40              ADDS     r0,r0,#1              ;1497
0000a2  d101              BNE      |L11.168|
0000a4  f8c49044          STR      r9,[r4,#0x44]         ;1497
                  |L11.168|
0000a8  6ca0              LDR      r0,[r4,#0x48]         ;1497
0000aa  1c40              ADDS     r0,r0,#1              ;1497
0000ac  d101              BNE      |L11.178|
0000ae  f8c49048          STR      r9,[r4,#0x48]         ;1497
                  |L11.178|
0000b2  f7fffffe          BL       vPortExitCritical
0000b6  a905              ADD      r1,sp,#0x14           ;1500
0000b8  4668              MOV      r0,sp                 ;1500
0000ba  f7fffffe          BL       xTaskCheckForTimeOut
0000be  b130              CBZ      r0,|L11.206|
0000c0  4620              MOV      r0,r4                 ;1543
0000c2  f7fffffe          BL       prvUnlockQueue
0000c6  f7fffffe          BL       xTaskResumeAll
                  |L11.202|
0000ca  2000              MOVS     r0,#0                 ;1546
0000cc  e7c1              B        |L11.82|
                  |L11.206|
0000ce  f7fffffe          BL       vPortEnterCritical
0000d2  6ba0              LDR      r0,[r4,#0x38]
0000d4  b130              CBZ      r0,|L11.228|
0000d6  2500              MOVS     r5,#0
                  |L11.216|
0000d8  f7fffffe          BL       vPortExitCritical
0000dc  b1f5              CBZ      r5,|L11.284|
0000de  6820              LDR      r0,[r4,#0]            ;1508
0000e0  b110              CBZ      r0,|L11.232|
0000e2  e008              B        |L11.246|
                  |L11.228|
0000e4  2501              MOVS     r5,#1                 ;1508
0000e6  e7f7              B        |L11.216|
                  |L11.232|
0000e8  f7fffffe          BL       vPortEnterCritical
0000ec  6860              LDR      r0,[r4,#4]            ;1512
0000ee  f7fffffe          BL       vTaskPriorityInherit
0000f2  f7fffffe          BL       vPortExitCritical
                  |L11.246|
0000f6  f1040024          ADD      r0,r4,#0x24           ;1523
0000fa  9905              LDR      r1,[sp,#0x14]         ;1523
0000fc  f7fffffe          BL       vTaskPlaceOnEventList
000100  4620              MOV      r0,r4                 ;1524
000102  f7fffffe          BL       prvUnlockQueue
000106  f7fffffe          BL       xTaskResumeAll
00010a  2800              CMP      r0,#0                 ;1525
00010c  d184              BNE      |L11.24|
00010e  f8c87000          STR      r7,[r8,#0]            ;1527
000112  f3bf8f4f          DSB                            ;1527
000116  f3bf8f6f          ISB                            ;1527
00011a  e77d              B        |L11.24|
                  |L11.284|
00011c  4620              MOV      r0,r4                 ;1537
00011e  f7fffffe          BL       prvUnlockQueue
000122  f7fffffe          BL       xTaskResumeAll
000126  e777              B        |L11.24|
;;;1550   /*-----------------------------------------------------------*/
                          ENDP

                  |L11.296|
                          DCD      0xe000ed04

                          AREA ||i.xQueueGenericReset||, CODE, READONLY, ALIGN=2

                  xQueueGenericReset PROC
;;;259    
;;;260    BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;261    {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;262    Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;263    
;;;264    	configASSERT( pxQueue );
;;;265    
;;;266    	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;267    	{
;;;268    		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
00000a  e9d4120f          LDRD     r1,r2,[r4,#0x3c]
00000e  6820              LDR      r0,[r4,#0]
000010  fb010002          MLA      r0,r1,r2,r0
;;;269    		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
000014  6060              STR      r0,[r4,#4]
000016  2000              MOVS     r0,#0
000018  63a0              STR      r0,[r4,#0x38]
;;;270    		pxQueue->pcWriteTo = pxQueue->pcHead;
00001a  6820              LDR      r0,[r4,#0]
;;;271    		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
00001c  60a0              STR      r0,[r4,#8]
00001e  4601              MOV      r1,r0
000020  6be0              LDR      r0,[r4,#0x3c]
000022  1e40              SUBS     r0,r0,#1
000024  fb001002          MLA      r0,r0,r2,r1
;;;272    		pxQueue->xRxLock = queueUNLOCKED;
000028  60e0              STR      r0,[r4,#0xc]
00002a  f04f30ff          MOV      r0,#0xffffffff
00002e  6460              STR      r0,[r4,#0x44]
;;;273    		pxQueue->xTxLock = queueUNLOCKED;
000030  64a0              STR      r0,[r4,#0x48]
;;;274    
;;;275    		if( xNewQueue == pdFALSE )
;;;276    		{
;;;277    			/* If there are tasks blocked waiting to read from the queue, then
;;;278    			the tasks will remain blocked as after this function exits the queue
;;;279    			will still be empty.  If there are tasks blocked waiting to write to
;;;280    			the queue, then one should be unblocked as after this function exits
;;;281    			it will be possible to write to it. */
;;;282    			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;283    			{
;;;284    				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
000032  f1040010          ADD      r0,r4,#0x10
000036  b14d              CBZ      r5,|L12.76|
;;;285    				{
;;;286    					queueYIELD_IF_USING_PREEMPTION();
;;;287    				}
;;;288    				else
;;;289    				{
;;;290    					mtCOVERAGE_TEST_MARKER();
;;;291    				}
;;;292    			}
;;;293    			else
;;;294    			{
;;;295    				mtCOVERAGE_TEST_MARKER();
;;;296    			}
;;;297    		}
;;;298    		else
;;;299    		{
;;;300    			/* Ensure the event queues start in the correct state. */
;;;301    			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
000038  f7fffffe          BL       vListInitialise
;;;302    			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
00003c  f1040024          ADD      r0,r4,#0x24
000040  f7fffffe          BL       vListInitialise
                  |L12.68|
;;;303    		}
;;;304    	}
;;;305    	taskEXIT_CRITICAL();
000044  f7fffffe          BL       vPortExitCritical
;;;306    
;;;307    	/* A value is returned for calling semantic consistency with previous
;;;308    	versions. */
;;;309    	return pdPASS;
000048  2001              MOVS     r0,#1
;;;310    }
00004a  bd70              POP      {r4-r6,pc}
                  |L12.76|
00004c  6921              LDR      r1,[r4,#0x10]         ;282
00004e  2900              CMP      r1,#0                 ;282
000050  d0f8              BEQ      |L12.68|
000052  f7fffffe          BL       xTaskRemoveFromEventList
000056  2801              CMP      r0,#1                 ;284
000058  d1f4              BNE      |L12.68|
00005a  4904              LDR      r1,|L12.108|
00005c  0700              LSLS     r0,r0,#28             ;286
00005e  6008              STR      r0,[r1,#0]            ;286
000060  f3bf8f4f          DSB                            ;286
000064  f3bf8f6f          ISB                            ;286
000068  e7ec              B        |L12.68|
;;;311    /*-----------------------------------------------------------*/
                          ENDP

00006a  0000              DCW      0x0000
                  |L12.108|
                          DCD      0xe000ed04

                          AREA ||i.xQueueGenericSend||, CODE, READONLY, ALIGN=2

                  xQueueGenericSend PROC
;;;609    
;;;610    BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;611    {
;;;612    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
000004  2600              MOVS     r6,#0
000006  b083              SUB      sp,sp,#0xc            ;611
000008  469a              MOV      r10,r3                ;611
00000a  468b              MOV      r11,r1                ;611
00000c  4604              MOV      r4,r0                 ;611
00000e  46b1              MOV      r9,r6
;;;613    TimeOut_t xTimeOut;
;;;614    Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;615    
;;;616    	configASSERT( pxQueue );
;;;617    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;618    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
;;;619    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;620    	{
;;;621    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;622    	}
;;;623    	#endif
;;;624    
;;;625    
;;;626    	/* This function relaxes the coding standard somewhat to allow return
;;;627    	statements within the function itself.  This is done in the interest
;;;628    	of execution time efficiency. */
;;;629    	for( ;; )
;;;630    	{
;;;631    		taskENTER_CRITICAL();
;;;632    		{
;;;633    			/* Is there room on the queue now?  The running task must be the
;;;634    			highest priority task wanting to access the queue.  If the head item
;;;635    			in the queue is to be overwritten then it does not matter if the
;;;636    			queue is full. */
;;;637    			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
;;;638    			{
;;;639    				traceQUEUE_SEND( pxQueue );
;;;640    				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
;;;641    
;;;642    				#if ( configUSE_QUEUE_SETS == 1 )
;;;643    				{
;;;644    					if( pxQueue->pxQueueSetContainer != NULL )
;;;645    					{
;;;646    						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
;;;647    						{
;;;648    							/* The queue is a member of a queue set, and posting
;;;649    							to the queue set caused a higher priority task to
;;;650    							unblock. A context switch is required. */
;;;651    							queueYIELD_IF_USING_PREEMPTION();
;;;652    						}
;;;653    						else
;;;654    						{
;;;655    							mtCOVERAGE_TEST_MARKER();
;;;656    						}
;;;657    					}
;;;658    					else
;;;659    					{
;;;660    						/* If there was a task waiting for data to arrive on the
;;;661    						queue then unblock it now. */
;;;662    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;663    						{
;;;664    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
;;;665    							{
;;;666    								/* The unblocked task has a priority higher than
;;;667    								our own so yield immediately.  Yes it is ok to
;;;668    								do this from within the critical section - the
;;;669    								kernel takes care of that. */
;;;670    								queueYIELD_IF_USING_PREEMPTION();
;;;671    							}
;;;672    							else
;;;673    							{
;;;674    								mtCOVERAGE_TEST_MARKER();
;;;675    							}
;;;676    						}
;;;677    						else if( xYieldRequired != pdFALSE )
;;;678    						{
;;;679    							/* This path is a special case that will only get
;;;680    							executed if the task was holding multiple mutexes
;;;681    							and the mutexes were given back in an order that is
;;;682    							different to that in which they were taken. */
;;;683    							queueYIELD_IF_USING_PREEMPTION();
;;;684    						}
;;;685    						else
;;;686    						{
;;;687    							mtCOVERAGE_TEST_MARKER();
;;;688    						}
;;;689    					}
;;;690    				}
;;;691    				#else /* configUSE_QUEUE_SETS */
;;;692    				{
;;;693    					/* If there was a task waiting for data to arrive on the
;;;694    					queue then unblock it now. */
;;;695    					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;696    					{
;;;697    						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
;;;698    						{
;;;699    							/* The unblocked task has a priority higher than
;;;700    							our own so yield immediately.  Yes it is ok to do
;;;701    							this from within the critical section - the kernel
;;;702    							takes care of that. */
;;;703    							queueYIELD_IF_USING_PREEMPTION();
000010  f04f5780          MOV      r7,#0x10000000
000014  f8df80e4          LDR      r8,|L13.252|
                  |L13.24|
000018  f7fffffe          BL       vPortEnterCritical
00001c  6ba0              LDR      r0,[r4,#0x38]         ;637
00001e  6be1              LDR      r1,[r4,#0x3c]         ;637
000020  4288              CMP      r0,r1                 ;637
000022  d306              BCC      |L13.50|
000024  f1ba0f02          CMP      r10,#2                ;637
000028  d003              BEQ      |L13.50|
;;;704    						}
;;;705    						else
;;;706    						{
;;;707    							mtCOVERAGE_TEST_MARKER();
;;;708    						}
;;;709    					}
;;;710    					else if( xYieldRequired != pdFALSE )
;;;711    					{
;;;712    						/* This path is a special case that will only get
;;;713    						executed if the task was holding multiple mutexes and
;;;714    						the mutexes were given back in an order that is
;;;715    						different to that in which they were taken. */
;;;716    						queueYIELD_IF_USING_PREEMPTION();
;;;717    					}
;;;718    					else
;;;719    					{
;;;720    						mtCOVERAGE_TEST_MARKER();
;;;721    					}
;;;722    				}
;;;723    				#endif /* configUSE_QUEUE_SETS */
;;;724    
;;;725    				taskEXIT_CRITICAL();
;;;726    				return pdPASS;
;;;727    			}
;;;728    			else
;;;729    			{
;;;730    				if( xTicksToWait == ( TickType_t ) 0 )
00002a  9805              LDR      r0,[sp,#0x14]
00002c  b1e0              CBZ      r0,|L13.104|
;;;731    				{
;;;732    					/* The queue was full and no block time is specified (or
;;;733    					the block time has expired) so leave now. */
;;;734    					taskEXIT_CRITICAL();
;;;735    
;;;736    					/* Return to the original privilege level before exiting
;;;737    					the function. */
;;;738    					traceQUEUE_SEND_FAILED( pxQueue );
;;;739    					return errQUEUE_FULL;
;;;740    				}
;;;741    				else if( xEntryTimeSet == pdFALSE )
00002e  b1f6              CBZ      r6,|L13.110|
000030  e021              B        |L13.118|
                  |L13.50|
000032  4652              MOV      r2,r10                ;640
000034  4659              MOV      r1,r11                ;640
000036  4620              MOV      r0,r4                 ;640
000038  f7fffffe          BL       prvCopyDataToQueue
00003c  6a61              LDR      r1,[r4,#0x24]         ;695
00003e  b131              CBZ      r1,|L13.78|
000040  f1040024          ADD      r0,r4,#0x24           ;697
000044  f7fffffe          BL       xTaskRemoveFromEventList
000048  2801              CMP      r0,#1                 ;697
00004a  d001              BEQ      |L13.80|
00004c  e006              B        |L13.92|
                  |L13.78|
00004e  b128              CBZ      r0,|L13.92|
                  |L13.80|
000050  f8c87000          STR      r7,[r8,#0]            ;716
000054  f3bf8f4f          DSB                            ;716
000058  f3bf8f6f          ISB                            ;716
                  |L13.92|
00005c  f7fffffe          BL       vPortExitCritical
000060  2001              MOVS     r0,#1                 ;726
                  |L13.98|
;;;742    				{
;;;743    					/* The queue was full and a block time was specified so
;;;744    					configure the timeout structure. */
;;;745    					vTaskSetTimeOutState( &xTimeOut );
;;;746    					xEntryTimeSet = pdTRUE;
;;;747    				}
;;;748    				else
;;;749    				{
;;;750    					/* Entry time was already set. */
;;;751    					mtCOVERAGE_TEST_MARKER();
;;;752    				}
;;;753    			}
;;;754    		}
;;;755    		taskEXIT_CRITICAL();
;;;756    
;;;757    		/* Interrupts and other tasks can send to and receive from the queue
;;;758    		now the critical section has been exited. */
;;;759    
;;;760    		vTaskSuspendAll();
;;;761    		prvLockQueue( pxQueue );
;;;762    
;;;763    		/* Update the timeout state to see if it has expired yet. */
;;;764    		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;765    		{
;;;766    			if( prvIsQueueFull( pxQueue ) != pdFALSE )
;;;767    			{
;;;768    				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
;;;769    				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
;;;770    
;;;771    				/* Unlocking the queue means queue events can effect the
;;;772    				event list.  It is possible	that interrupts occurring now
;;;773    				remove this task from the event	list again - but as the
;;;774    				scheduler is suspended the task will go onto the pending
;;;775    				ready last instead of the actual ready list. */
;;;776    				prvUnlockQueue( pxQueue );
;;;777    
;;;778    				/* Resuming the scheduler will move tasks from the pending
;;;779    				ready list into the ready list - so it is feasible that this
;;;780    				task is already in a ready list before it yields - in which
;;;781    				case the yield will not cause a context switch unless there
;;;782    				is also a higher priority task in the pending ready list. */
;;;783    				if( xTaskResumeAll() == pdFALSE )
;;;784    				{
;;;785    					portYIELD_WITHIN_API();
;;;786    				}
;;;787    			}
;;;788    			else
;;;789    			{
;;;790    				/* Try again. */
;;;791    				prvUnlockQueue( pxQueue );
;;;792    				( void ) xTaskResumeAll();
;;;793    			}
;;;794    		}
;;;795    		else
;;;796    		{
;;;797    			/* The timeout has expired. */
;;;798    			prvUnlockQueue( pxQueue );
;;;799    			( void ) xTaskResumeAll();
;;;800    
;;;801    			/* Return to the original privilege level before exiting the
;;;802    			function. */
;;;803    			traceQUEUE_SEND_FAILED( pxQueue );
;;;804    			return errQUEUE_FULL;
;;;805    		}
;;;806    	}
;;;807    }
000062  b007              ADD      sp,sp,#0x1c
000064  e8bd8ff0          POP      {r4-r11,pc}
                  |L13.104|
000068  f7fffffe          BL       vPortExitCritical
00006c  e01f              B        |L13.174|
                  |L13.110|
00006e  4668              MOV      r0,sp                 ;745
000070  f7fffffe          BL       vTaskSetTimeOutState
000074  2601              MOVS     r6,#1                 ;746
                  |L13.118|
000076  f7fffffe          BL       vPortExitCritical
00007a  f7fffffe          BL       vTaskSuspendAll
00007e  f7fffffe          BL       vPortEnterCritical
000082  6c60              LDR      r0,[r4,#0x44]         ;761
000084  1c40              ADDS     r0,r0,#1              ;761
000086  d101              BNE      |L13.140|
000088  f8c49044          STR      r9,[r4,#0x44]         ;761
                  |L13.140|
00008c  6ca0              LDR      r0,[r4,#0x48]         ;761
00008e  1c40              ADDS     r0,r0,#1              ;761
000090  d101              BNE      |L13.150|
000092  f8c49048          STR      r9,[r4,#0x48]         ;761
                  |L13.150|
000096  f7fffffe          BL       vPortExitCritical
00009a  a905              ADD      r1,sp,#0x14           ;764
00009c  4668              MOV      r0,sp                 ;764
00009e  f7fffffe          BL       xTaskCheckForTimeOut
0000a2  b130              CBZ      r0,|L13.178|
0000a4  4620              MOV      r0,r4                 ;798
0000a6  f7fffffe          BL       prvUnlockQueue
0000aa  f7fffffe          BL       xTaskResumeAll
                  |L13.174|
0000ae  2000              MOVS     r0,#0                 ;804
0000b0  e7d7              B        |L13.98|
                  |L13.178|
0000b2  f7fffffe          BL       vPortEnterCritical
0000b6  6ba0              LDR      r0,[r4,#0x38]
0000b8  6be1              LDR      r1,[r4,#0x3c]
0000ba  4288              CMP      r0,r1
0000bc  d101              BNE      |L13.194|
0000be  2501              MOVS     r5,#1
0000c0  e000              B        |L13.196|
                  |L13.194|
0000c2  2500              MOVS     r5,#0
                  |L13.196|
0000c4  f7fffffe          BL       vPortExitCritical
0000c8  b195              CBZ      r5,|L13.240|
0000ca  f1040010          ADD      r0,r4,#0x10           ;769
0000ce  9905              LDR      r1,[sp,#0x14]         ;769
0000d0  f7fffffe          BL       vTaskPlaceOnEventList
0000d4  4620              MOV      r0,r4                 ;776
0000d6  f7fffffe          BL       prvUnlockQueue
0000da  f7fffffe          BL       xTaskResumeAll
0000de  2800              CMP      r0,#0                 ;783
0000e0  d19a              BNE      |L13.24|
0000e2  f8c87000          STR      r7,[r8,#0]            ;785
0000e6  f3bf8f4f          DSB                            ;785
0000ea  f3bf8f6f          ISB                            ;785
0000ee  e793              B        |L13.24|
                  |L13.240|
0000f0  4620              MOV      r0,r4                 ;791
0000f2  f7fffffe          BL       prvUnlockQueue
0000f6  f7fffffe          BL       xTaskResumeAll
0000fa  e78d              B        |L13.24|
;;;808    /*-----------------------------------------------------------*/
                          ENDP

                  |L13.252|
                          DCD      0xe000ed04

                          AREA ||i.xQueueGenericSendFromISR||, CODE, READONLY, ALIGN=1

                  xQueueGenericSendFromISR PROC
;;;1054   
;;;1055   BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
000000  b570              PUSH     {r4-r6,lr}
;;;1056   {
000002  4604              MOV      r4,r0
000004  4616              MOV      r6,r2
000006  2010              MOVS     r0,#0x10
000008  f3ef8511          MRS      r5,BASEPRI
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
;;;1057   BaseType_t xReturn;
;;;1058   UBaseType_t uxSavedInterruptStatus;
;;;1059   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;1060   
;;;1061   	configASSERT( pxQueue );
;;;1062   	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;1063   	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
;;;1064   
;;;1065   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1066   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1067   	above the maximum system call priority are kept permanently enabled, even
;;;1068   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1069   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1070   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1071   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1072   	assigned a priority above the configured maximum system call priority.
;;;1073   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1074   	that have been assigned a priority at or (logically) below the maximum
;;;1075   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1076   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1077   	More information (albeit Cortex-M specific) is provided on the following
;;;1078   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1079   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1080   
;;;1081   	/* Similar to xQueueGenericSend, except without blocking if there is no room
;;;1082   	in the queue.  Also don't directly wake a task that was blocked on a queue
;;;1083   	read, instead return a flag to say whether a context switch is required or
;;;1084   	not (i.e. has a task with a higher priority than us been woken by this
;;;1085   	post). */
;;;1086   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
;;;1087   	{
;;;1088   		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
000018  6ba0              LDR      r0,[r4,#0x38]
00001a  6be2              LDR      r2,[r4,#0x3c]
00001c  4290              CMP      r0,r2
00001e  d305              BCC      |L14.44|
000020  2b02              CMP      r3,#2
000022  d003              BEQ      |L14.44|
;;;1089   		{
;;;1090   			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;1091   
;;;1092   			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
;;;1093   			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
;;;1094   			in a task disinheriting a priority and prvCopyDataToQueue() can be
;;;1095   			called here even though the disinherit function does not check if
;;;1096   			the scheduler is suspended before accessing the ready lists. */
;;;1097   			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
;;;1098   
;;;1099   			/* The event list is not altered if the queue is locked.  This will
;;;1100   			be done when the queue is unlocked later. */
;;;1101   			if( pxQueue->xTxLock == queueUNLOCKED )
;;;1102   			{
;;;1103   				#if ( configUSE_QUEUE_SETS == 1 )
;;;1104   				{
;;;1105   					if( pxQueue->pxQueueSetContainer != NULL )
;;;1106   					{
;;;1107   						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
;;;1108   						{
;;;1109   							/* The queue is a member of a queue set, and posting
;;;1110   							to the queue set caused a higher priority task to
;;;1111   							unblock.  A context switch is required. */
;;;1112   							if( pxHigherPriorityTaskWoken != NULL )
;;;1113   							{
;;;1114   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1115   							}
;;;1116   							else
;;;1117   							{
;;;1118   								mtCOVERAGE_TEST_MARKER();
;;;1119   							}
;;;1120   						}
;;;1121   						else
;;;1122   						{
;;;1123   							mtCOVERAGE_TEST_MARKER();
;;;1124   						}
;;;1125   					}
;;;1126   					else
;;;1127   					{
;;;1128   						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1129   						{
;;;1130   							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1131   							{
;;;1132   								/* The task waiting has a higher priority so
;;;1133   								record that a context switch is required. */
;;;1134   								if( pxHigherPriorityTaskWoken != NULL )
;;;1135   								{
;;;1136   									*pxHigherPriorityTaskWoken = pdTRUE;
;;;1137   								}
;;;1138   								else
;;;1139   								{
;;;1140   									mtCOVERAGE_TEST_MARKER();
;;;1141   								}
;;;1142   							}
;;;1143   							else
;;;1144   							{
;;;1145   								mtCOVERAGE_TEST_MARKER();
;;;1146   							}
;;;1147   						}
;;;1148   						else
;;;1149   						{
;;;1150   							mtCOVERAGE_TEST_MARKER();
;;;1151   						}
;;;1152   					}
;;;1153   				}
;;;1154   				#else /* configUSE_QUEUE_SETS */
;;;1155   				{
;;;1156   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1157   					{
;;;1158   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1159   						{
;;;1160   							/* The task waiting has a higher priority so record that a
;;;1161   							context	switch is required. */
;;;1162   							if( pxHigherPriorityTaskWoken != NULL )
;;;1163   							{
;;;1164   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1165   							}
;;;1166   							else
;;;1167   							{
;;;1168   								mtCOVERAGE_TEST_MARKER();
;;;1169   							}
;;;1170   						}
;;;1171   						else
;;;1172   						{
;;;1173   							mtCOVERAGE_TEST_MARKER();
;;;1174   						}
;;;1175   					}
;;;1176   					else
;;;1177   					{
;;;1178   						mtCOVERAGE_TEST_MARKER();
;;;1179   					}
;;;1180   				}
;;;1181   				#endif /* configUSE_QUEUE_SETS */
;;;1182   			}
;;;1183   			else
;;;1184   			{
;;;1185   				/* Increment the lock count so the task that unlocks the queue
;;;1186   				knows that data was posted while it was locked. */
;;;1187   				++( pxQueue->xTxLock );
;;;1188   			}
;;;1189   
;;;1190   			xReturn = pdPASS;
;;;1191   		}
;;;1192   		else
;;;1193   		{
;;;1194   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1195   			xReturn = errQUEUE_FULL;
000024  2000              MOVS     r0,#0
                  |L14.38|
000026  f3858811          MSR      BASEPRI,r5
;;;1196   		}
;;;1197   	}
;;;1198   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;1199   
;;;1200   	return xReturn;
;;;1201   }
00002a  bd70              POP      {r4-r6,pc}
                  |L14.44|
00002c  461a              MOV      r2,r3                 ;1097
00002e  4620              MOV      r0,r4                 ;1097
000030  f7fffffe          BL       prvCopyDataToQueue
000034  6ca0              LDR      r0,[r4,#0x48]         ;1101
000036  1c40              ADDS     r0,r0,#1              ;1101
000038  d004              BEQ      |L14.68|
00003a  6ca0              LDR      r0,[r4,#0x48]         ;1187
00003c  1c40              ADDS     r0,r0,#1              ;1187
00003e  64a0              STR      r0,[r4,#0x48]         ;1187
                  |L14.64|
000040  2001              MOVS     r0,#1                 ;1190
000042  e7f0              B        |L14.38|
                  |L14.68|
000044  6a60              LDR      r0,[r4,#0x24]         ;1156
000046  2800              CMP      r0,#0                 ;1156
000048  d0fa              BEQ      |L14.64|
00004a  f1040024          ADD      r0,r4,#0x24           ;1158
00004e  f7fffffe          BL       xTaskRemoveFromEventList
000052  2800              CMP      r0,#0                 ;1158
000054  d0f4              BEQ      |L14.64|
000056  2e00              CMP      r6,#0                 ;1162
000058  d0f2              BEQ      |L14.64|
00005a  2001              MOVS     r0,#1                 ;1164
00005c  6030              STR      r0,[r6,#0]            ;1164
00005e  e7ef              B        |L14.64|
;;;1202   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGiveFromISR||, CODE, READONLY, ALIGN=1

                  xQueueGiveFromISR PROC
;;;1203   
;;;1204   BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
000000  b570              PUSH     {r4-r6,lr}
;;;1205   {
000002  460d              MOV      r5,r1
000004  2110              MOVS     r1,#0x10
000006  f3ef8411          MRS      r4,BASEPRI
00000a  f3818811          MSR      BASEPRI,r1
00000e  f3bf8f4f          DSB      
000012  f3bf8f6f          ISB      
;;;1206   BaseType_t xReturn;
;;;1207   UBaseType_t uxSavedInterruptStatus;
;;;1208   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;1209   
;;;1210   	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
;;;1211   	item size is 0.  Don't directly wake a task that was blocked on a queue
;;;1212   	read, instead return a flag to say whether a context switch is required or
;;;1213   	not (i.e. has a task with a higher priority than us been woken by this
;;;1214   	post). */
;;;1215   
;;;1216   	configASSERT( pxQueue );
;;;1217   
;;;1218   	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
;;;1219   	if the item size is not 0. */
;;;1220   	configASSERT( pxQueue->uxItemSize == 0 );
;;;1221   
;;;1222   	/* Normally a mutex would not be given from an interrupt, especially if 
;;;1223   	there is a mutex holder, as priority inheritance makes no sense for an 
;;;1224   	interrupts, only tasks. */
;;;1225   	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
;;;1226   
;;;1227   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1228   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1229   	above the maximum system call priority are kept permanently enabled, even
;;;1230   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1231   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1232   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1233   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1234   	assigned a priority above the configured maximum system call priority.
;;;1235   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1236   	that have been assigned a priority at or (logically) below the maximum
;;;1237   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1238   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1239   	More information (albeit Cortex-M specific) is provided on the following
;;;1240   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1241   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1242   
;;;1243   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
;;;1244   	{
;;;1245   		/* When the queue is used to implement a semaphore no data is ever
;;;1246   		moved through the queue but it is still valid to see if the queue 'has
;;;1247   		space'. */
;;;1248   		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
000016  6b81              LDR      r1,[r0,#0x38]
000018  6bc2              LDR      r2,[r0,#0x3c]
00001a  4291              CMP      r1,r2
00001c  d217              BCS      |L15.78|
;;;1249   		{
;;;1250   			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;1251   
;;;1252   			/* A task can only have an inherited priority if it is a mutex
;;;1253   			holder - and if there is a mutex holder then the mutex cannot be
;;;1254   			given from an ISR.  As this is the ISR version of the function it
;;;1255   			can be assumed there is no mutex holder and no need to determine if
;;;1256   			priority disinheritance is needed.  Simply increase the count of
;;;1257   			messages (semaphores) available. */
;;;1258   			++( pxQueue->uxMessagesWaiting );
00001e  6b81              LDR      r1,[r0,#0x38]
000020  1c49              ADDS     r1,r1,#1
000022  6381              STR      r1,[r0,#0x38]
;;;1259   
;;;1260   			/* The event list is not altered if the queue is locked.  This will
;;;1261   			be done when the queue is unlocked later. */
;;;1262   			if( pxQueue->xTxLock == queueUNLOCKED )
000024  6c81              LDR      r1,[r0,#0x48]
000026  1c49              ADDS     r1,r1,#1
000028  d004              BEQ      |L15.52|
;;;1263   			{
;;;1264   				#if ( configUSE_QUEUE_SETS == 1 )
;;;1265   				{
;;;1266   					if( pxQueue->pxQueueSetContainer != NULL )
;;;1267   					{
;;;1268   						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
;;;1269   						{
;;;1270   							/* The semaphore is a member of a queue set, and
;;;1271   							posting	to the queue set caused a higher priority
;;;1272   							task to	unblock.  A context switch is required. */
;;;1273   							if( pxHigherPriorityTaskWoken != NULL )
;;;1274   							{
;;;1275   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1276   							}
;;;1277   							else
;;;1278   							{
;;;1279   								mtCOVERAGE_TEST_MARKER();
;;;1280   							}
;;;1281   						}
;;;1282   						else
;;;1283   						{
;;;1284   							mtCOVERAGE_TEST_MARKER();
;;;1285   						}
;;;1286   					}
;;;1287   					else
;;;1288   					{
;;;1289   						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1290   						{
;;;1291   							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1292   							{
;;;1293   								/* The task waiting has a higher priority so
;;;1294   								record that a context switch is required. */
;;;1295   								if( pxHigherPriorityTaskWoken != NULL )
;;;1296   								{
;;;1297   									*pxHigherPriorityTaskWoken = pdTRUE;
;;;1298   								}
;;;1299   								else
;;;1300   								{
;;;1301   									mtCOVERAGE_TEST_MARKER();
;;;1302   								}
;;;1303   							}
;;;1304   							else
;;;1305   							{
;;;1306   								mtCOVERAGE_TEST_MARKER();
;;;1307   							}
;;;1308   						}
;;;1309   						else
;;;1310   						{
;;;1311   							mtCOVERAGE_TEST_MARKER();
;;;1312   						}
;;;1313   					}
;;;1314   				}
;;;1315   				#else /* configUSE_QUEUE_SETS */
;;;1316   				{
;;;1317   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1318   					{
;;;1319   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1320   						{
;;;1321   							/* The task waiting has a higher priority so record that a
;;;1322   							context	switch is required. */
;;;1323   							if( pxHigherPriorityTaskWoken != NULL )
;;;1324   							{
;;;1325   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1326   							}
;;;1327   							else
;;;1328   							{
;;;1329   								mtCOVERAGE_TEST_MARKER();
;;;1330   							}
;;;1331   						}
;;;1332   						else
;;;1333   						{
;;;1334   							mtCOVERAGE_TEST_MARKER();
;;;1335   						}
;;;1336   					}
;;;1337   					else
;;;1338   					{
;;;1339   						mtCOVERAGE_TEST_MARKER();
;;;1340   					}
;;;1341   				}
;;;1342   				#endif /* configUSE_QUEUE_SETS */
;;;1343   			}
;;;1344   			else
;;;1345   			{
;;;1346   				/* Increment the lock count so the task that unlocks the queue
;;;1347   				knows that data was posted while it was locked. */
;;;1348   				++( pxQueue->xTxLock );
00002a  6c81              LDR      r1,[r0,#0x48]
00002c  1c49              ADDS     r1,r1,#1
00002e  6481              STR      r1,[r0,#0x48]
                  |L15.48|
;;;1349   			}
;;;1350   
;;;1351   			xReturn = pdPASS;
000030  2001              MOVS     r0,#1
000032  e00d              B        |L15.80|
                  |L15.52|
000034  6a41              LDR      r1,[r0,#0x24]         ;1317
000036  2900              CMP      r1,#0                 ;1317
000038  d0fa              BEQ      |L15.48|
00003a  3024              ADDS     r0,r0,#0x24           ;1317
00003c  f7fffffe          BL       xTaskRemoveFromEventList
000040  2800              CMP      r0,#0                 ;1319
000042  d0f5              BEQ      |L15.48|
000044  2d00              CMP      r5,#0                 ;1323
000046  d0f3              BEQ      |L15.48|
000048  2001              MOVS     r0,#1                 ;1325
00004a  6028              STR      r0,[r5,#0]            ;1325
00004c  e7f0              B        |L15.48|
                  |L15.78|
;;;1352   		}
;;;1353   		else
;;;1354   		{
;;;1355   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1356   			xReturn = errQUEUE_FULL;
00004e  2000              MOVS     r0,#0
                  |L15.80|
000050  f3848811          MSR      BASEPRI,r4
;;;1357   		}
;;;1358   	}
;;;1359   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;1360   
;;;1361   	return xReturn;
;;;1362   }
000054  bd70              POP      {r4-r6,pc}
;;;1363   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueIsQueueEmptyFromISR||, CODE, READONLY, ALIGN=1

                  xQueueIsQueueEmptyFromISR PROC
;;;2012   
;;;2013   BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
000000  6b80              LDR      r0,[r0,#0x38]
;;;2014   {
000002  b108              CBZ      r0,|L16.8|
;;;2015   BaseType_t xReturn;
;;;2016   
;;;2017   	configASSERT( xQueue );
;;;2018   	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
;;;2019   	{
;;;2020   		xReturn = pdTRUE;
;;;2021   	}
;;;2022   	else
;;;2023   	{
;;;2024   		xReturn = pdFALSE;
000004  2000              MOVS     r0,#0
;;;2025   	}
;;;2026   
;;;2027   	return xReturn;
;;;2028   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
000006  4770              BX       lr
                  |L16.8|
000008  2001              MOVS     r0,#1                 ;2020
00000a  4770              BX       lr
;;;2029   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueIsQueueFullFromISR||, CODE, READONLY, ALIGN=1

                  xQueueIsQueueFullFromISR PROC
;;;2051   
;;;2052   BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
000000  6b81              LDR      r1,[r0,#0x38]
;;;2053   {
;;;2054   BaseType_t xReturn;
;;;2055   
;;;2056   	configASSERT( xQueue );
;;;2057   	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
000002  6bc0              LDR      r0,[r0,#0x3c]
000004  4281              CMP      r1,r0
000006  d101              BNE      |L17.12|
;;;2058   	{
;;;2059   		xReturn = pdTRUE;
000008  2001              MOVS     r0,#1
;;;2060   	}
;;;2061   	else
;;;2062   	{
;;;2063   		xReturn = pdFALSE;
;;;2064   	}
;;;2065   
;;;2066   	return xReturn;
;;;2067   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
00000a  4770              BX       lr
                  |L17.12|
00000c  2000              MOVS     r0,#0                 ;2063
00000e  4770              BX       lr
;;;2068   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueuePeekFromISR||, CODE, READONLY, ALIGN=1

                  xQueuePeekFromISR PROC
;;;1638   
;;;1639   BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
000000  b570              PUSH     {r4-r6,lr}
;;;1640   {
000002  4604              MOV      r4,r0
000004  2010              MOVS     r0,#0x10
000006  f3ef8511          MRS      r5,BASEPRI
00000a  f3808811          MSR      BASEPRI,r0
00000e  f3bf8f4f          DSB      
000012  f3bf8f6f          ISB      
;;;1641   BaseType_t xReturn;
;;;1642   UBaseType_t uxSavedInterruptStatus;
;;;1643   int8_t *pcOriginalReadPosition;
;;;1644   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;1645   
;;;1646   	configASSERT( pxQueue );
;;;1647   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;1648   	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
;;;1649   
;;;1650   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1651   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1652   	above the maximum system call priority are kept permanently enabled, even
;;;1653   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1654   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1655   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1656   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1657   	assigned a priority above the configured maximum system call priority.
;;;1658   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1659   	that have been assigned a priority at or (logically) below the maximum
;;;1660   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1661   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1662   	More information (albeit Cortex-M specific) is provided on the following
;;;1663   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1664   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1665   
;;;1666   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
;;;1667   	{
;;;1668   		/* Cannot block in an ISR, so check there is data available. */
;;;1669   		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
000016  6ba0              LDR      r0,[r4,#0x38]
000018  b128              CBZ      r0,|L18.38|
;;;1670   		{
;;;1671   			traceQUEUE_PEEK_FROM_ISR( pxQueue );
;;;1672   
;;;1673   			/* Remember the read position so it can be reset as nothing is
;;;1674   			actually being removed from the queue. */
;;;1675   			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
;;;1676   			prvCopyDataFromQueue( pxQueue, pvBuffer );
00001a  4620              MOV      r0,r4
00001c  68e6              LDR      r6,[r4,#0xc]
00001e  f7fffffe          BL       prvCopyDataFromQueue
;;;1677   			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
;;;1678   
;;;1679   			xReturn = pdPASS;
000022  2001              MOVS     r0,#1
000024  60e6              STR      r6,[r4,#0xc]
                  |L18.38|
000026  f3858811          MSR      BASEPRI,r5
;;;1680   		}
;;;1681   		else
;;;1682   		{
;;;1683   			xReturn = pdFAIL;
;;;1684   			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
;;;1685   		}
;;;1686   	}
;;;1687   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;1688   
;;;1689   	return xReturn;
;;;1690   }
00002a  bd70              POP      {r4-r6,pc}
;;;1691   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueReceiveFromISR||, CODE, READONLY, ALIGN=1

                  xQueueReceiveFromISR PROC
;;;1551   
;;;1552   BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
000000  b570              PUSH     {r4-r6,lr}
;;;1553   {
000002  4604              MOV      r4,r0
000004  4616              MOV      r6,r2
000006  2010              MOVS     r0,#0x10
000008  f3ef8511          MRS      r5,BASEPRI
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
;;;1554   BaseType_t xReturn;
;;;1555   UBaseType_t uxSavedInterruptStatus;
;;;1556   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;1557   
;;;1558   	configASSERT( pxQueue );
;;;1559   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;1560   
;;;1561   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1562   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1563   	above the maximum system call priority are kept permanently enabled, even
;;;1564   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1565   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1566   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1567   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1568   	assigned a priority above the configured maximum system call priority.
;;;1569   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1570   	that have been assigned a priority at or (logically) below the maximum
;;;1571   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1572   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1573   	More information (albeit Cortex-M specific) is provided on the following
;;;1574   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1575   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1576   
;;;1577   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
;;;1578   	{
;;;1579   		/* Cannot block in an ISR, so check there is data available. */
;;;1580   		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
000018  6ba0              LDR      r0,[r4,#0x38]
00001a  b160              CBZ      r0,|L19.54|
;;;1581   		{
;;;1582   			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
;;;1583   
;;;1584   			prvCopyDataFromQueue( pxQueue, pvBuffer );
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       prvCopyDataFromQueue
;;;1585   			--( pxQueue->uxMessagesWaiting );
000022  6ba0              LDR      r0,[r4,#0x38]
000024  1e40              SUBS     r0,r0,#1
000026  63a0              STR      r0,[r4,#0x38]
;;;1586   
;;;1587   			/* If the queue is locked the event list will not be modified.
;;;1588   			Instead update the lock count so the task that unlocks the queue
;;;1589   			will know that an ISR has removed data while the queue was
;;;1590   			locked. */
;;;1591   			if( pxQueue->xRxLock == queueUNLOCKED )
000028  6c60              LDR      r0,[r4,#0x44]
00002a  1c40              ADDS     r0,r0,#1
00002c  d006              BEQ      |L19.60|
;;;1592   			{
;;;1593   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;1594   				{
;;;1595   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
;;;1596   					{
;;;1597   						/* The task waiting has a higher priority than us so
;;;1598   						force a context switch. */
;;;1599   						if( pxHigherPriorityTaskWoken != NULL )
;;;1600   						{
;;;1601   							*pxHigherPriorityTaskWoken = pdTRUE;
;;;1602   						}
;;;1603   						else
;;;1604   						{
;;;1605   							mtCOVERAGE_TEST_MARKER();
;;;1606   						}
;;;1607   					}
;;;1608   					else
;;;1609   					{
;;;1610   						mtCOVERAGE_TEST_MARKER();
;;;1611   					}
;;;1612   				}
;;;1613   				else
;;;1614   				{
;;;1615   					mtCOVERAGE_TEST_MARKER();
;;;1616   				}
;;;1617   			}
;;;1618   			else
;;;1619   			{
;;;1620   				/* Increment the lock count so the task that unlocks the queue
;;;1621   				knows that data was removed while it was locked. */
;;;1622   				++( pxQueue->xRxLock );
00002e  6c60              LDR      r0,[r4,#0x44]
000030  1c40              ADDS     r0,r0,#1
000032  6460              STR      r0,[r4,#0x44]
                  |L19.52|
;;;1623   			}
;;;1624   
;;;1625   			xReturn = pdPASS;
000034  2001              MOVS     r0,#1
                  |L19.54|
000036  f3858811          MSR      BASEPRI,r5
;;;1626   		}
;;;1627   		else
;;;1628   		{
;;;1629   			xReturn = pdFAIL;
;;;1630   			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
;;;1631   		}
;;;1632   	}
;;;1633   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;1634   
;;;1635   	return xReturn;
;;;1636   }
00003a  bd70              POP      {r4-r6,pc}
                  |L19.60|
00003c  6920              LDR      r0,[r4,#0x10]         ;1593
00003e  2800              CMP      r0,#0                 ;1593
000040  d0f8              BEQ      |L19.52|
000042  f1040010          ADD      r0,r4,#0x10           ;1595
000046  f7fffffe          BL       xTaskRemoveFromEventList
00004a  2800              CMP      r0,#0                 ;1595
00004c  d0f2              BEQ      |L19.52|
00004e  2e00              CMP      r6,#0                 ;1599
000050  d0f0              BEQ      |L19.52|
000052  2001              MOVS     r0,#1                 ;1601
000054  6030              STR      r0,[r6,#0]            ;1601
000056  e7ed              B        |L19.52|
;;;1637   /*-----------------------------------------------------------*/
                          ENDP


; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\ff.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\ff.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\ZR60_v1.0_freeRTOS -I..\..\Lwip\App -I..\..\Lwip\Bsp -I..\..\Lwip\Bsp\LAN8742A -I..\..\Lwip\lwip-1.4.1 -I..\..\Lwip\lwip-1.4.1\port -I..\..\Lwip\lwip-1.4.1\port\arch -I..\..\Lwip\lwip-1.4.1\port\Standalone -I..\..\Lwip\lwip-1.4.1\src\include -I..\..\Lwip\lwip-1.4.1\src\include\ipv4 -I..\..\Lwip\lwip-1.4.1\src\include\lwip -I..\..\Lwip\lwip-1.4.1\src\include\netif -I..\..\Ecal\BtnFltr -I..\..\Ecal\UartComn -I..\..\Ecal\MemIf -I..\..\APP -I..\..\APP\BlackListMng -I..\..\APP\SeverNewsPush -I..\..\APP\NewsPull -I..\..\Ecal -I..\..\Ecal\JsonIf -I..\..\Ecal\Mcu_Init -I..\..\Service -I..\..\Complex -I..\..\Complex\FATFS -I..\..\FreeRTOS\Source\include -I..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\FreeRTOS -I.\RTE\_ZR60 -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=..\..\output\ff.crf ..\..\Complex\FATFS\ff.c]
                          THUMB

                          AREA ||i.check_fs||, CODE, READONLY, ALIGN=2

                  check_fs PROC
;;;2157   static
;;;2158   BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
000000  b510              PUSH     {r4,lr}
;;;2159   	FATFS* fs,	/* File system object */
;;;2160   	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
;;;2161   )
;;;2162   {
000002  4604              MOV      r4,r0
;;;2163   	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
000004  2000              MOVS     r0,#0
000006  7120              STRB     r0,[r4,#4]
000008  1e40              SUBS     r0,r0,#1
;;;2164   	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
00000a  6320              STR      r0,[r4,#0x30]
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       move_window
000012  b108              CBZ      r0,|L1.24|
;;;2165   		return 3;
000014  2003              MOVS     r0,#3
;;;2166   
;;;2167   	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
;;;2168   		return 2;
;;;2169   
;;;2170   	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
;;;2171   		return 0;
;;;2172   	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
;;;2173   		return 0;
;;;2174   
;;;2175   	return 1;
;;;2176   }
000016  bd10              POP      {r4,pc}
                  |L1.24|
000018  f8b40232          LDRH     r0,[r4,#0x232]        ;2167
00001c  f5a0412a          SUB      r1,r0,#0xaa00         ;2167
000020  3955              SUBS     r1,r1,#0x55           ;2167
000022  d001              BEQ      |L1.40|
000024  2002              MOVS     r0,#2                 ;2168
000026  bd10              POP      {r4,pc}
                  |L1.40|
000028  f894006a          LDRB     r0,[r4,#0x6a]         ;2170
00002c  f8b4106b          LDRH     r1,[r4,#0x6b]         ;2170
000030  ea402101          ORR      r1,r0,r1,LSL #8       ;2170
000034  4808              LDR      r0,|L1.88|
000036  ebb02f01          CMP      r0,r1,LSL #8          ;2170
00003a  d008              BEQ      |L1.78|
00003c  f8941086          LDRB     r1,[r4,#0x86]         ;2172
000040  f8b42087          LDRH     r2,[r4,#0x87]         ;2172
000044  ea412102          ORR      r1,r1,r2,LSL #8       ;2172
000048  ebb02f01          CMP      r0,r1,LSL #8          ;2172
00004c  d101              BNE      |L1.82|
                  |L1.78|
00004e  2000              MOVS     r0,#0                 ;2173
000050  bd10              POP      {r4,pc}
                  |L1.82|
000052  2001              MOVS     r0,#1                 ;2175
000054  bd10              POP      {r4,pc}
;;;2177   
                          ENDP

000056  0000              DCW      0x0000
                  |L1.88|
                          DCD      0x54414600

                          AREA ||i.chk_chr||, CODE, READONLY, ALIGN=1

                  chk_chr PROC
;;;601    static
;;;602    int chk_chr (const char* str, int chr) {
000000  e000              B        |L2.4|
                  |L2.2|
;;;603    	while (*str && *str != chr) str++;
000002  1c40              ADDS     r0,r0,#1
                  |L2.4|
000004  7802              LDRB     r2,[r0,#0]
000006  b10a              CBZ      r2,|L2.12|
000008  428a              CMP      r2,r1
00000a  d1fa              BNE      |L2.2|
                  |L2.12|
;;;604    	return *str;
00000c  b2d0              UXTB     r0,r2
;;;605    }
00000e  4770              BX       lr
;;;606    
                          ENDP


                          AREA ||i.clust2sect||, CODE, READONLY, ALIGN=1

                  clust2sect PROC
;;;858    
;;;859    DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
000000  6982              LDR      r2,[r0,#0x18]
;;;860    	FATFS* fs,		/* File system object */
;;;861    	DWORD clst		/* Cluster# to be converted */
;;;862    )
;;;863    {
;;;864    	clst -= 2;
;;;865    	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
000002  1e89              SUBS     r1,r1,#2
000004  1e92              SUBS     r2,r2,#2
000006  428a              CMP      r2,r1
000008  d801              BHI      |L3.14|
00000a  2000              MOVS     r0,#0
;;;866    	return clst * fs->csize + fs->database;
;;;867    }
00000c  4770              BX       lr
                  |L3.14|
00000e  6ac2              LDR      r2,[r0,#0x2c]         ;866
000010  7880              LDRB     r0,[r0,#2]            ;866
000012  fb012000          MLA      r0,r1,r0,r2           ;866
000016  4770              BX       lr
;;;868    
                          ENDP


                          AREA ||i.create_chain||, CODE, READONLY, ALIGN=1

                  create_chain PROC
;;;1048   static
;;;1049   DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1050   	FATFS* fs,			/* File system object */
;;;1051   	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
;;;1052   )
;;;1053   {
000004  000f              MOVS     r7,r1
000006  4606              MOV      r6,r0
000008  d006              BEQ      |L4.24|
;;;1054   	DWORD cs, ncl, scl;
;;;1055   	FRESULT res;
;;;1056   
;;;1057   
;;;1058   	if (clst == 0) {		/* Create a new chain */
;;;1059   		scl = fs->last_clust;			/* Get suggested start point */
;;;1060   		if (!scl || scl >= fs->n_fatent) scl = 1;
;;;1061   	}
;;;1062   	else {					/* Stretch the current chain */
;;;1063   		cs = get_fat(fs, clst);			/* Check the cluster status */
00000a  f7fffffe          BL       get_fat
;;;1064   		if (cs < 2) return 1;			/* Invalid value */
00000e  2802              CMP      r0,#2
000010  d209              BCS      |L4.38|
000012  2001              MOVS     r0,#1
                  |L4.20|
;;;1065   		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
;;;1066   		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
;;;1067   		scl = clst;
;;;1068   	}
;;;1069   
;;;1070   	ncl = scl;				/* Start cluster */
;;;1071   	for (;;) {
;;;1072   		ncl++;							/* Next cluster */
;;;1073   		if (ncl >= fs->n_fatent) {		/* Check wrap around */
;;;1074   			ncl = 2;
;;;1075   			if (ncl > scl) return 0;	/* No free cluster */
;;;1076   		}
;;;1077   		cs = get_fat(fs, ncl);			/* Get the cluster status */
;;;1078   		if (cs == 0) break;				/* Found a free cluster */
;;;1079   		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
;;;1080   			return cs;
;;;1081   		if (ncl == scl) return 0;		/* No free cluster */
;;;1082   	}
;;;1083   
;;;1084   	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
;;;1085   	if (res == FR_OK && clst != 0) {
;;;1086   		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
;;;1087   	}
;;;1088   	if (res == FR_OK) {
;;;1089   		fs->last_clust = ncl;			/* Update FSINFO */
;;;1090   		if (fs->free_clust != 0xFFFFFFFF) {
;;;1091   			fs->free_clust--;
;;;1092   			fs->fsi_flag |= 1;
;;;1093   		}
;;;1094   	} else {
;;;1095   		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
;;;1096   	}
;;;1097   
;;;1098   	return ncl;		/* Return new cluster number or error code */
;;;1099   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L4.24|
000018  68f5              LDR      r5,[r6,#0xc]          ;1060
00001a  b115              CBZ      r5,|L4.34|
00001c  69b0              LDR      r0,[r6,#0x18]         ;1060
00001e  42a8              CMP      r0,r5                 ;1060
000020  d807              BHI      |L4.50|
                  |L4.34|
000022  2501              MOVS     r5,#1                 ;1060
000024  e005              B        |L4.50|
                  |L4.38|
000026  1c41              ADDS     r1,r0,#1              ;1065
000028  d0f4              BEQ      |L4.20|
00002a  69b1              LDR      r1,[r6,#0x18]         ;1066
00002c  4281              CMP      r1,r0                 ;1066
00002e  d8f1              BHI      |L4.20|
000030  463d              MOV      r5,r7                 ;1067
                  |L4.50|
000032  462c              MOV      r4,r5                 ;1070
                  |L4.52|
000034  69b0              LDR      r0,[r6,#0x18]         ;1073
000036  1c64              ADDS     r4,r4,#1              ;1073
000038  42a0              CMP      r0,r4                 ;1073
00003a  d802              BHI      |L4.66|
00003c  2402              MOVS     r4,#2                 ;1074
00003e  2d02              CMP      r5,#2                 ;1075
000040  d30a              BCC      |L4.88|
                  |L4.66|
000042  4621              MOV      r1,r4                 ;1077
000044  4630              MOV      r0,r6                 ;1077
000046  f7fffffe          BL       get_fat
00004a  b138              CBZ      r0,|L4.92|
00004c  1c41              ADDS     r1,r0,#1              ;1079
00004e  d0e1              BEQ      |L4.20|
000050  2801              CMP      r0,#1                 ;1079
000052  d0df              BEQ      |L4.20|
000054  42ac              CMP      r4,r5                 ;1081
000056  d1ed              BNE      |L4.52|
                  |L4.88|
000058  2000              MOVS     r0,#0                 ;1081
00005a  e7db              B        |L4.20|
                  |L4.92|
00005c  f06f4270          MVN      r2,#0xf0000000        ;1084
000060  4621              MOV      r1,r4                 ;1084
000062  4630              MOV      r0,r6                 ;1084
000064  f7fffffe          BL       put_fat
000068  b930              CBNZ     r0,|L4.120|
00006a  b157              CBZ      r7,|L4.130|
00006c  4622              MOV      r2,r4                 ;1086
00006e  4639              MOV      r1,r7                 ;1086
000070  4630              MOV      r0,r6                 ;1086
000072  f7fffffe          BL       put_fat
000076  b120              CBZ      r0,|L4.130|
                  |L4.120|
000078  2801              CMP      r0,#1                 ;1095
00007a  d00d              BEQ      |L4.152|
00007c  2401              MOVS     r4,#1                 ;1095
                  |L4.126|
00007e  4620              MOV      r0,r4                 ;1098
000080  e7c8              B        |L4.20|
                  |L4.130|
000082  60f4              STR      r4,[r6,#0xc]          ;1090
000084  6930              LDR      r0,[r6,#0x10]         ;1090
000086  1c41              ADDS     r1,r0,#1              ;1090
000088  d0f9              BEQ      |L4.126|
00008a  1e40              SUBS     r0,r0,#1              ;1090
00008c  6130              STR      r0,[r6,#0x10]         ;1092
00008e  7970              LDRB     r0,[r6,#5]            ;1092
000090  f0400001          ORR      r0,r0,#1              ;1092
000094  7170              STRB     r0,[r6,#5]            ;1092
000096  e7f2              B        |L4.126|
                  |L4.152|
000098  f04f34ff          MOV      r4,#0xffffffff        ;1095
00009c  e7ef              B        |L4.126|
;;;1100   #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.create_name||, CODE, READONLY, ALIGN=2

                  create_name PROC
;;;1826   static
;;;1827   FRESULT create_name (
000000  e92d5ff3          PUSH     {r0,r1,r4-r12,lr}
;;;1828   	DIR* dp,			/* Pointer to the directory object */
;;;1829   	const TCHAR** path	/* Pointer to pointer to the segment in the path string */
;;;1830   )
;;;1831   {
000004  4688              MOV      r8,r1
000006  680e              LDR      r6,[r1,#0]
000008  e000              B        |L5.12|
                  |L5.10|
00000a  1c76              ADDS     r6,r6,#1
                  |L5.12|
;;;1832   #if _USE_LFN	/* LFN configuration */
;;;1833   	BYTE b, cf;
;;;1834   	WCHAR w, *lfn;
;;;1835   	UINT i, ni, si, di;
;;;1836   	const TCHAR *p;
;;;1837   
;;;1838   	/* Create LFN in Unicode */
;;;1839   	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
00000c  7830              LDRB     r0,[r6,#0]
00000e  282f              CMP      r0,#0x2f
000010  d0fb              BEQ      |L5.10|
000012  285c              CMP      r0,#0x5c
000014  d0f9              BEQ      |L5.10|
;;;1840   	lfn = dp->lfn;
000016  9800              LDR      r0,[sp,#0]
;;;1841   	si = di = 0;
000018  2400              MOVS     r4,#0
00001a  4625              MOV      r5,r4
00001c  f8d0a01c          LDR      r10,[r0,#0x1c]
                  |L5.32|
;;;1842   	for (;;) {
;;;1843   		w = p[si++];					/* Get a character */
000020  5d70              LDRB     r0,[r6,r5]
000022  1c6d              ADDS     r5,r5,#1
;;;1844   		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
000024  2820              CMP      r0,#0x20
000026  d325              BCC      |L5.116|
000028  282f              CMP      r0,#0x2f
00002a  d023              BEQ      |L5.116|
00002c  285c              CMP      r0,#0x5c
00002e  d021              BEQ      |L5.116|
;;;1845   		if (di >= _MAX_LFN)				/* Reject too long name */
000030  2cff              CMP      r4,#0xff
000032  d260              BCS      |L5.246|
;;;1846   			return FR_INVALID_NAME;
;;;1847   #if !_LFN_UNICODE
;;;1848   		w &= 0xFF;
;;;1849   		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
000034  f1a00181          SUB      r1,r0,#0x81
000038  297d              CMP      r1,#0x7d
00003a  d80b              BHI      |L5.84|
;;;1850   			b = (BYTE)p[si++];			/* Get 2nd byte */
00003c  5d71              LDRB     r1,[r6,r5]
;;;1851   			if (!IsDBCS2(b))
00003e  1c6d              ADDS     r5,r5,#1
000040  f1a10240          SUB      r2,r1,#0x40
000044  2a3f              CMP      r2,#0x3f
000046  d302              BCC      |L5.78|
000048  3a40              SUBS     r2,r2,#0x40
00004a  2a7f              CMP      r2,#0x7f
00004c  d253              BCS      |L5.246|
                  |L5.78|
;;;1852   				return FR_INVALID_NAME;	/* Reject invalid sequence */
;;;1853   			w = (w << 8) + b;			/* Create a DBC */
00004e  eb012000          ADD      r0,r1,r0,LSL #8
000052  b280              UXTH     r0,r0
                  |L5.84|
;;;1854   		}
;;;1855   		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
000054  2101              MOVS     r1,#1
000056  f7fffffe          BL       ff_convert
00005a  0007              MOVS     r7,r0
;;;1856   		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
00005c  d04b              BEQ      |L5.246|
;;;1857   #endif
;;;1858   		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal characters for LFN */
00005e  2f80              CMP      r7,#0x80
000060  d204              BCS      |L5.108|
000062  4601              MOV      r1,r0
000064  a077              ADR      r0,|L5.580|
000066  f7fffffe          BL       chk_chr
00006a  bbe0              CBNZ     r0,|L5.230|
                  |L5.108|
;;;1859   			return FR_INVALID_NAME;
;;;1860   		lfn[di++] = w;					/* Store the Unicode character */
00006c  f82a7014          STRH     r7,[r10,r4,LSL #1]
000070  1c64              ADDS     r4,r4,#1
000072  e7d5              B        |L5.32|
                  |L5.116|
;;;1861   	}
;;;1862   	*path = &p[si];						/* Return pointer to the next segment */
000074  1972              ADDS     r2,r6,r5
;;;1863   	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
000076  f8c82000          STR      r2,[r8,#0]
00007a  2820              CMP      r0,#0x20
00007c  d201              BCS      |L5.130|
00007e  2504              MOVS     r5,#4
000080  e000              B        |L5.132|
                  |L5.130|
000082  2500              MOVS     r5,#0
                  |L5.132|
000084  2100              MOVS     r1,#0
;;;1864   #if _FS_RPATH
;;;1865   	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
000086  2c01              CMP      r4,#1
000088  d005              BEQ      |L5.150|
;;;1866   		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
00008a  2c02              CMP      r4,#2
00008c  d131              BNE      |L5.242|
00008e  f8ba0002          LDRH     r0,[r10,#2]
000092  282e              CMP      r0,#0x2e
000094  d117              BNE      |L5.198|
                  |L5.150|
000096  f8ba0000          LDRH     r0,[r10,#0]
00009a  282e              CMP      r0,#0x2e
00009c  d113              BNE      |L5.198|
;;;1867   		lfn[di] = 0;
00009e  f82a1014          STRH     r1,[r10,r4,LSL #1]
;;;1868   		for (i = 0; i < 11; i++)
0000a2  2000              MOVS     r0,#0
                  |L5.164|
;;;1869   			dp->fn[i] = (i < di) ? '.' : ' ';
0000a4  42a0              CMP      r0,r4
0000a6  d201              BCS      |L5.172|
0000a8  212e              MOVS     r1,#0x2e
0000aa  e000              B        |L5.174|
                  |L5.172|
0000ac  2120              MOVS     r1,#0x20
                  |L5.174|
0000ae  9a00              LDR      r2,[sp,#0]
0000b0  6992              LDR      r2,[r2,#0x18]
0000b2  5411              STRB     r1,[r2,r0]
0000b4  1c40              ADDS     r0,r0,#1
0000b6  280b              CMP      r0,#0xb               ;1868
0000b8  d3f4              BCC      |L5.164|
;;;1870   		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
0000ba  9900              LDR      r1,[sp,#0]
0000bc  f0450220          ORR      r2,r5,#0x20
0000c0  6989              LDR      r1,[r1,#0x18]
0000c2  540a              STRB     r2,[r1,r0]
;;;1871   		return FR_OK;
0000c4  e0bc              B        |L5.576|
                  |L5.198|
;;;1872   	}
;;;1873   #endif
;;;1874   	while (di) {						/* Strip trailing spaces and dots */
;;;1875   		w = lfn[di-1];
0000c6  eb0a0044          ADD      r0,r10,r4,LSL #1
0000ca  f8300c02          LDRH     r0,[r0,#-2]
;;;1876   		if (w != ' ' && w != '.') break;
0000ce  2820              CMP      r0,#0x20
0000d0  d00e              BEQ      |L5.240|
0000d2  282e              CMP      r0,#0x2e
0000d4  d00c              BEQ      |L5.240|
;;;1877   		di--;
;;;1878   	}
;;;1879   	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
0000d6  b134              CBZ      r4,|L5.230|
;;;1880   
;;;1881   	lfn[di] = 0;						/* LFN is created */
0000d8  f82a1014          STRH     r1,[r10,r4,LSL #1]
;;;1882   
;;;1883   	/* Create SFN in directory form */
;;;1884   	mem_set(dp->fn, ' ', 11);
0000dc  9800              LDR      r0,[sp,#0]
0000de  220b              MOVS     r2,#0xb
0000e0  2120              MOVS     r1,#0x20
0000e2  6980              LDR      r0,[r0,#0x18]
0000e4  e000              B        |L5.232|
                  |L5.230|
0000e6  e006              B        |L5.246|
                  |L5.232|
0000e8  f7fffffe          BL       mem_set
;;;1885   	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
0000ec  2700              MOVS     r7,#0
0000ee  e006              B        |L5.254|
                  |L5.240|
0000f0  1e64              SUBS     r4,r4,#1
                  |L5.242|
0000f2  2c00              CMP      r4,#0                 ;1874
0000f4  d1e7              BNE      |L5.198|
                  |L5.246|
0000f6  2006              MOVS     r0,#6                 ;1879
                  |L5.248|
;;;1886   	if (si) cf |= NS_LOSS | NS_LFN;
;;;1887   	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
;;;1888   
;;;1889   	b = i = 0; ni = 8;
;;;1890   	for (;;) {
;;;1891   		w = lfn[si++];					/* Get an LFN character */
;;;1892   		if (!w) break;					/* Break on end of the LFN */
;;;1893   		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
;;;1894   			cf |= NS_LOSS | NS_LFN; continue;
;;;1895   		}
;;;1896   
;;;1897   		if (i >= ni || si == di) {		/* Extension or end of SFN */
;;;1898   			if (ni == 11) {				/* Long extension */
;;;1899   				cf |= NS_LOSS | NS_LFN; break;
;;;1900   			}
;;;1901   			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
;;;1902   			if (si > di) break;			/* No extension */
;;;1903   			si = di; i = 8; ni = 11;	/* Enter extension section */
;;;1904   			b <<= 2; continue;
;;;1905   		}
;;;1906   
;;;1907   		if (w >= 0x80) {				/* Non ASCII character */
;;;1908   #ifdef _EXCVT
;;;1909   			w = ff_convert(w, 0);		/* Unicode -> OEM code */
;;;1910   			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
;;;1911   #else
;;;1912   			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
;;;1913   #endif
;;;1914   			cf |= NS_LFN;				/* Force create LFN entry */
;;;1915   		}
;;;1916   
;;;1917   		if (_DF1S && w >= 0x100) {		/* Double byte character (always false on SBCS cfg) */
;;;1918   			if (i >= ni - 1) {
;;;1919   				cf |= NS_LOSS | NS_LFN; i = ni; continue;
;;;1920   			}
;;;1921   			dp->fn[i++] = (BYTE)(w >> 8);
;;;1922   		} else {						/* Single byte character */
;;;1923   			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
;;;1924   				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
;;;1925   			} else {
;;;1926   				if (IsUpper(w)) {		/* ASCII large capital */
;;;1927   					b |= 2;
;;;1928   				} else {
;;;1929   					if (IsLower(w)) {	/* ASCII small capital */
;;;1930   						b |= 1; w -= 0x20;
;;;1931   					}
;;;1932   				}
;;;1933   			}
;;;1934   		}
;;;1935   		dp->fn[i++] = (BYTE)w;
;;;1936   	}
;;;1937   
;;;1938   	if (dp->fn[0] == DDE) dp->fn[0] = NDDE;	/* If the first character collides with deleted mark, replace it with 0x05 */
;;;1939   
;;;1940   	if (ni == 8) b <<= 2;
;;;1941   	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
;;;1942   		cf |= NS_LFN;
;;;1943   	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
;;;1944   		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
;;;1945   		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
;;;1946   	}
;;;1947   
;;;1948   	dp->fn[NSFLAG] = cf;	/* SFN is created */
;;;1949   
;;;1950   	return FR_OK;
;;;1951   
;;;1952   
;;;1953   #else	/* Non-LFN configuration */
;;;1954   	BYTE b, c, d, *sfn;
;;;1955   	UINT ni, si, i;
;;;1956   	const char *p;
;;;1957   
;;;1958   	/* Create file name in directory form */
;;;1959   	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
;;;1960   	sfn = dp->fn;
;;;1961   	mem_set(sfn, ' ', 11);
;;;1962   	si = i = b = 0; ni = 8;
;;;1963   #if _FS_RPATH
;;;1964   	if (p[si] == '.') { /* Is this a dot entry? */
;;;1965   		for (;;) {
;;;1966   			c = (BYTE)p[si++];
;;;1967   			if (c != '.' || si >= 3) break;
;;;1968   			sfn[i++] = c;
;;;1969   		}
;;;1970   		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
;;;1971   		*path = &p[si];									/* Return pointer to the next segment */
;;;1972   		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
;;;1973   		return FR_OK;
;;;1974   	}
;;;1975   #endif
;;;1976   	for (;;) {
;;;1977   		c = (BYTE)p[si++];
;;;1978   		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
;;;1979   		if (c == '.' || i >= ni) {
;;;1980   			if (ni != 8 || c != '.') return FR_INVALID_NAME;
;;;1981   			i = 8; ni = 11;
;;;1982   			b <<= 2; continue;
;;;1983   		}
;;;1984   		if (c >= 0x80) {				/* Extended character? */
;;;1985   			b |= 3;						/* Eliminate NT flag */
;;;1986   #ifdef _EXCVT
;;;1987   			c = ExCvt[c - 0x80];		/* To upper extended characters (SBCS cfg) */
;;;1988   #else
;;;1989   #if !_DF1S
;;;1990   			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
;;;1991   #endif
;;;1992   #endif
;;;1993   		}
;;;1994   		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
;;;1995   			d = (BYTE)p[si++];			/* Get 2nd byte */
;;;1996   			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
;;;1997   				return FR_INVALID_NAME;
;;;1998   			sfn[i++] = c;
;;;1999   			sfn[i++] = d;
;;;2000   		} else {						/* Single byte code */
;;;2001   			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
;;;2002   				return FR_INVALID_NAME;
;;;2003   			if (IsUpper(c)) {			/* ASCII large capital? */
;;;2004   				b |= 2;
;;;2005   			} else {
;;;2006   				if (IsLower(c)) {		/* ASCII small capital? */
;;;2007   					b |= 1; c -= 0x20;
;;;2008   				}
;;;2009   			}
;;;2010   			sfn[i++] = c;
;;;2011   		}
;;;2012   	}
;;;2013   	*path = &p[si];						/* Return pointer to the next segment */
;;;2014   	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
;;;2015   
;;;2016   	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
;;;2017   	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first character collides with DDE, replace it with 0x05 */
;;;2018   
;;;2019   	if (ni == 8) b <<= 2;
;;;2020   	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
;;;2021   	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
;;;2022   
;;;2023   	sfn[NSFLAG] = c;		/* Store NT flag, File name is created */
;;;2024   
;;;2025   	return FR_OK;
;;;2026   #endif
;;;2027   }
0000f8  e8bd9ffc          POP      {r2-r12,pc}
                  |L5.252|
0000fc  1c7f              ADDS     r7,r7,#1
                  |L5.254|
0000fe  f83a0017          LDRH     r0,[r10,r7,LSL #1]    ;1885
000102  2820              CMP      r0,#0x20              ;1885
000104  d0fa              BEQ      |L5.252|
000106  282e              CMP      r0,#0x2e              ;1885
000108  d0f8              BEQ      |L5.252|
00010a  b11f              CBZ      r7,|L5.276|
00010c  f0450503          ORR      r5,r5,#3              ;1886
000110  e000              B        |L5.276|
                  |L5.274|
000112  1e64              SUBS     r4,r4,#1              ;1886
                  |L5.276|
000114  b12c              CBZ      r4,|L5.290|
000116  eb0a0044          ADD      r0,r10,r4,LSL #1      ;1887
00011a  f8300c02          LDRH     r0,[r0,#-2]           ;1887
00011e  282e              CMP      r0,#0x2e              ;1887
000120  d1f7              BNE      |L5.274|
                  |L5.290|
000122  f04f0800          MOV      r8,#0                 ;1889
000126  46c1              MOV      r9,r8                 ;1889
000128  f04f0b08          MOV      r11,#8                ;1889
                  |L5.300|
00012c  f83a6017          LDRH     r6,[r10,r7,LSL #1]    ;1891
000130  1c7f              ADDS     r7,r7,#1              ;1891
000132  b306              CBZ      r6,|L5.374|
000134  2e20              CMP      r6,#0x20              ;1893
000136  d003              BEQ      |L5.320|
000138  2e2e              CMP      r6,#0x2e              ;1893
00013a  d104              BNE      |L5.326|
00013c  42a7              CMP      r7,r4                 ;1893
00013e  d002              BEQ      |L5.326|
                  |L5.320|
000140  f0450503          ORR      r5,r5,#3              ;1894
000144  e7f2              B        |L5.300|
                  |L5.326|
000146  45d8              CMP      r8,r11                ;1897
000148  d201              BCS      |L5.334|
00014a  42a7              CMP      r7,r4                 ;1897
00014c  d119              BNE      |L5.386|
                  |L5.334|
00014e  f1bb0f0b          CMP      r11,#0xb              ;1898
000152  d00e              BEQ      |L5.370|
000154  42a7              CMP      r7,r4                 ;1901
000156  d001              BEQ      |L5.348|
000158  f0450503          ORR      r5,r5,#3              ;1901
                  |L5.348|
00015c  d80b              BHI      |L5.374|
00015e  ea4f6089          LSL      r0,r9,#26             ;1904
000162  4627              MOV      r7,r4                 ;1903
000164  f04f0808          MOV      r8,#8                 ;1903
000168  f04f0b0b          MOV      r11,#0xb              ;1903
00016c  ea4f6910          LSR      r9,r0,#24             ;1904
000170  e7dc              B        |L5.300|
                  |L5.370|
000172  f0450503          ORR      r5,r5,#3              ;1899
                  |L5.374|
000176  9800              LDR      r0,[sp,#0]            ;1938
000178  6980              LDR      r0,[r0,#0x18]         ;1938
00017a  7801              LDRB     r1,[r0,#0]            ;1938
00017c  29e5              CMP      r1,#0xe5              ;1938
00017e  d03d              BEQ      |L5.508|
000180  e03e              B        |L5.512|
                  |L5.386|
000182  2e80              CMP      r6,#0x80              ;1907
000184  d308              BCC      |L5.408|
000186  4630              MOV      r0,r6                 ;1912
000188  f7fffffe          BL       ff_wtoupper
00018c  2100              MOVS     r1,#0                 ;1912
00018e  f7fffffe          BL       ff_convert
000192  4606              MOV      r6,r0                 ;1912
000194  f0450502          ORR      r5,r5,#2              ;1914
                  |L5.408|
000198  2eff              CMP      r6,#0xff              ;1917
00019a  d90f              BLS      |L5.444|
00019c  f1ab0001          SUB      r0,r11,#1             ;1918
0001a0  4580              CMP      r8,r0                 ;1918
0001a2  d303              BCC      |L5.428|
0001a4  f0450503          ORR      r5,r5,#3              ;1919
0001a8  46d8              MOV      r8,r11                ;1919
0001aa  e7bf              B        |L5.300|
                  |L5.428|
0001ac  9800              LDR      r0,[sp,#0]            ;1921
0001ae  0a31              LSRS     r1,r6,#8              ;1921
0001b0  6982              LDR      r2,[r0,#0x18]         ;1921
0001b2  f8021008          STRB     r1,[r2,r8]            ;1921
0001b6  f1080801          ADD      r8,r8,#1              ;1921
0001ba  e018              B        |L5.494|
                  |L5.444|
0001bc  b126              CBZ      r6,|L5.456|
0001be  4631              MOV      r1,r6                 ;1923
0001c0  a023              ADR      r0,|L5.592|
0001c2  f7fffffe          BL       chk_chr
0001c6  b118              CBZ      r0,|L5.464|
                  |L5.456|
0001c8  265f              MOVS     r6,#0x5f              ;1924
0001ca  f0450503          ORR      r5,r5,#3              ;1924
0001ce  e00e              B        |L5.494|
                  |L5.464|
0001d0  f1a60041          SUB      r0,r6,#0x41           ;1926
0001d4  2819              CMP      r0,#0x19              ;1926
0001d6  d802              BHI      |L5.478|
0001d8  f0490902          ORR      r9,r9,#2              ;1927
0001dc  e007              B        |L5.494|
                  |L5.478|
0001de  f1a60061          SUB      r0,r6,#0x61           ;1929
0001e2  2819              CMP      r0,#0x19              ;1929
0001e4  d803              BHI      |L5.494|
0001e6  3e20              SUBS     r6,r6,#0x20           ;1930
0001e8  f0490901          ORR      r9,r9,#1              ;1930
0001ec  b2b6              UXTH     r6,r6                 ;1930
                  |L5.494|
0001ee  9800              LDR      r0,[sp,#0]            ;1935
0001f0  6981              LDR      r1,[r0,#0x18]         ;1935
0001f2  f8016008          STRB     r6,[r1,r8]            ;1935
0001f6  f1080801          ADD      r8,r8,#1              ;1935
0001fa  e797              B        |L5.300|
                  |L5.508|
0001fc  2105              MOVS     r1,#5                 ;1938
0001fe  7001              STRB     r1,[r0,#0]            ;1938
                  |L5.512|
000200  f1bb0f08          CMP      r11,#8                ;1940
000204  d103              BNE      |L5.526|
000206  ea4f6089          LSL      r0,r9,#26             ;1940
00020a  ea4f6910          LSR      r9,r0,#24             ;1940
                  |L5.526|
00020e  f3c90081          UBFX     r0,r9,#2,#2           ;1941
000212  2803              CMP      r0,#3                 ;1941
000214  d003              BEQ      |L5.542|
000216  ea6f0109          MVN      r1,r9                 ;1941
00021a  0789              LSLS     r1,r1,#30             ;1941
00021c  d101              BNE      |L5.546|
                  |L5.542|
00021e  f0450502          ORR      r5,r5,#2              ;1942
                  |L5.546|
000222  07a9              LSLS     r1,r5,#30             ;1943
000224  d409              BMI      |L5.570|
000226  f0090103          AND      r1,r9,#3              ;1944
00022a  2901              CMP      r1,#1                 ;1944
00022c  d101              BNE      |L5.562|
00022e  f0450510          ORR      r5,r5,#0x10           ;1944
                  |L5.562|
000232  2801              CMP      r0,#1                 ;1945
000234  d101              BNE      |L5.570|
000236  f0450508          ORR      r5,r5,#8              ;1945
                  |L5.570|
00023a  9800              LDR      r0,[sp,#0]            ;1948
00023c  6980              LDR      r0,[r0,#0x18]         ;1948
00023e  72c5              STRB     r5,[r0,#0xb]          ;1948
                  |L5.576|
000240  2000              MOVS     r0,#0                 ;1950
000242  e759              B        |L5.248|
;;;2028   
                          ENDP

                  |L5.580|
000244  222a3a3c          DCB      """*:<>?|",127,0
000248  3e3f7c7f
00024c  00      
00024d  00                DCB      0
00024e  00                DCB      0
00024f  00                DCB      0
                  |L5.592|
000250  2b2c3b3d          DCB      "+,;=[]",0
000254  5b5d00  
000257  00                DCB      0

                          AREA ||i.dir_alloc||, CODE, READONLY, ALIGN=1

                  dir_alloc PROC
;;;1255   static
;;;1256   FRESULT dir_alloc (
000000  b570              PUSH     {r4-r6,lr}
;;;1257   	DIR* dp,	/* Pointer to the directory object */
;;;1258   	UINT nent	/* Number of contiguous entries to allocate (1-21) */
;;;1259   )
;;;1260   {
000002  460e              MOV      r6,r1
000004  4605              MOV      r5,r0
;;;1261   	FRESULT res;
;;;1262   	UINT n;
;;;1263   
;;;1264   
;;;1265   	res = dir_sdi(dp, 0);
000006  2100              MOVS     r1,#0
000008  f7fffffe          BL       dir_sdi
;;;1266   	if (res == FR_OK) {
00000c  b988              CBNZ     r0,|L6.50|
;;;1267   		n = 0;
00000e  2400              MOVS     r4,#0
                  |L6.16|
;;;1268   		do {
;;;1269   			res = move_window(dp->fs, dp->sect);
000010  6929              LDR      r1,[r5,#0x10]
000012  6828              LDR      r0,[r5,#0]
000014  f7fffffe          BL       move_window
;;;1270   			if (res != FR_OK) break;
000018  b958              CBNZ     r0,|L6.50|
;;;1271   			if (dp->dir[0] == DDE || dp->dir[0] == 0) {	/* Is it a free entry? */
00001a  6969              LDR      r1,[r5,#0x14]
00001c  7809              LDRB     r1,[r1,#0]
00001e  29e5              CMP      r1,#0xe5
000020  d00b              BEQ      |L6.58|
000022  b151              CBZ      r1,|L6.58|
;;;1272   				if (++n == nent) break;	/* A block of contiguous free entries is found */
;;;1273   			} else {
;;;1274   				n = 0;					/* Not a blank entry. Restart to search */
000024  2400              MOVS     r4,#0
                  |L6.38|
;;;1275   			}
;;;1276   			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
000026  2101              MOVS     r1,#1
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       dir_next
;;;1277   		} while (res == FR_OK);
00002e  2800              CMP      r0,#0
000030  d0ee              BEQ      |L6.16|
                  |L6.50|
;;;1278   	}
;;;1279   	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
000032  2804              CMP      r0,#4
000034  d100              BNE      |L6.56|
000036  2007              MOVS     r0,#7
                  |L6.56|
;;;1280   	return res;
;;;1281   }
000038  bd70              POP      {r4-r6,pc}
                  |L6.58|
00003a  1c64              ADDS     r4,r4,#1
00003c  42b4              CMP      r4,r6                 ;1272
00003e  d1f2              BNE      |L6.38|
000040  bd70              POP      {r4-r6,pc}
;;;1282   #endif
                          ENDP


                          AREA ||i.dir_find||, CODE, READONLY, ALIGN=2

                  dir_find PROC
;;;1511   static
;;;1512   FRESULT dir_find (
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1513   	DIR* dp			/* Pointer to the directory object linked to the file name */
;;;1514   )
;;;1515   {
000004  4604              MOV      r4,r0
;;;1516   	FRESULT res;
;;;1517   	BYTE c, *dir;
;;;1518   #if _USE_LFN
;;;1519   	BYTE a, ord, sum;
;;;1520   #endif
;;;1521   
;;;1522   	res = dir_sdi(dp, 0);			/* Rewind directory object */
000006  2100              MOVS     r1,#0
000008  f7fffffe          BL       dir_sdi
;;;1523   	if (res != FR_OK) return res;
00000c  2800              CMP      r0,#0
00000e  d17a              BNE      |L7.262|
;;;1524   
;;;1525   #if _USE_LFN
;;;1526   	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
000010  25ff              MOVS     r5,#0xff
000012  f64f70ff          MOV      r0,#0xffff
000016  46ab              MOV      r11,r5
000018  8420              STRH     r0,[r4,#0x20]
                  |L7.26|
;;;1527   #endif
;;;1528   	do {
;;;1529   		res = move_window(dp->fs, dp->sect);
00001a  6921              LDR      r1,[r4,#0x10]
00001c  6820              LDR      r0,[r4,#0]
00001e  f7fffffe          BL       move_window
000022  0007              MOVS     r7,r0
;;;1530   		if (res != FR_OK) break;
000024  d17c              BNE      |L7.288|
;;;1531   		dir = dp->dir;					/* Ptr to the directory entry of current index */
;;;1532   		c = dir[DIR_Name];
000026  6966              LDR      r6,[r4,#0x14]
000028  7830              LDRB     r0,[r6,#0]
;;;1533   		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
00002a  b148              CBZ      r0,|L7.64|
;;;1534   #if _USE_LFN	/* LFN configuration */
;;;1535   		a = dir[DIR_Attr] & AM_MASK;
00002c  7af1              LDRB     r1,[r6,#0xb]
;;;1536   		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
00002e  28e5              CMP      r0,#0xe5
000030  f001013f          AND      r1,r1,#0x3f           ;1535
000034  d069              BEQ      |L7.266|
000036  070a              LSLS     r2,r1,#28
000038  d504              BPL      |L7.68|
00003a  290f              CMP      r1,#0xf
00003c  d165              BNE      |L7.266|
00003e  e005              B        |L7.76|
                  |L7.64|
000040  2704              MOVS     r7,#4                 ;1533
000042  e06d              B        |L7.288|
                  |L7.68|
;;;1537   			ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
;;;1538   		} else {
;;;1539   			if (a == AM_LFN) {			/* An LFN entry is found */
000044  290f              CMP      r1,#0xf
000046  d001              BEQ      |L7.76|
;;;1540   				if (dp->lfn) {
;;;1541   					if (c & LLE) {		/* Is it start of LFN sequence? */
;;;1542   						sum = dir[LDIR_Chksum];
;;;1543   						c &= ~LLE; ord = c;	/* LFN start order */
;;;1544   						dp->lfn_idx = dp->index;	/* Start index of LFN */
;;;1545   					}
;;;1546   					/* Check validity of the LFN entry and compare it with given name */
;;;1547   					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
;;;1548   				}
;;;1549   			} else {					/* An SFN entry is found */
;;;1550   				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
000048  b38d              CBZ      r5,|L7.174|
00004a  e04d              B        |L7.232|
                  |L7.76|
00004c  69e1              LDR      r1,[r4,#0x1c]         ;1540
00004e  b379              CBZ      r1,|L7.176|
000050  0642              LSLS     r2,r0,#25             ;1541
000052  d506              BPL      |L7.98|
000054  f896b00d          LDRB     r11,[r6,#0xd]         ;1542
000058  f0200040          BIC      r0,r0,#0x40           ;1543
00005c  88e2              LDRH     r2,[r4,#6]            ;1544
00005e  4605              MOV      r5,r0                 ;1543
000060  8422              STRH     r2,[r4,#0x20]         ;1544
                  |L7.98|
000062  42a8              CMP      r0,r5                 ;1547
000064  d136              BNE      |L7.212|
000066  7b72              LDRB     r2,[r6,#0xd]          ;1547
000068  455a              CMP      r2,r11                ;1547
00006a  d133              BNE      |L7.212|
00006c  7830              LDRB     r0,[r6,#0]            ;1547
00006e  468a              MOV      r10,r1                ;1547
000070  f0200040          BIC      r0,r0,#0x40           ;1547
000074  1e40              SUBS     r0,r0,#1              ;1547
000076  46b1              MOV      r9,r6                 ;1547
000078  eb000180          ADD      r1,r0,r0,LSL #2       ;1547
00007c  eb0106c0          ADD      r6,r1,r0,LSL #3       ;1547
000080  f04f0800          MOV      r8,#0                 ;1547
000084  2701              MOVS     r7,#1                 ;1547
                  |L7.134|
000086  4828              LDR      r0,|L7.296|
000088  f8101008          LDRB     r1,[r0,r8]            ;1547
00008c  eb010009          ADD      r0,r1,r9              ;1547
000090  8800              LDRH     r0,[r0,#0]            ;1547
000092  b177              CBZ      r7,|L7.178|
000094  f7fffffe          BL       ff_wtoupper
000098  4607              MOV      r7,r0                 ;1547
00009a  2eff              CMP      r6,#0xff              ;1547
00009c  d21a              BCS      |L7.212|
00009e  f83a0016          LDRH     r0,[r10,r6,LSL #1]    ;1547
0000a2  1c76              ADDS     r6,r6,#1              ;1547
0000a4  f7fffffe          BL       ff_wtoupper
0000a8  42b8              CMP      r0,r7                 ;1547
0000aa  d113              BNE      |L7.212|
0000ac  e005              B        |L7.186|
                  |L7.174|
0000ae  e016              B        |L7.222|
                  |L7.176|
0000b0  e02f              B        |L7.274|
                  |L7.178|
0000b2  f5a0417f          SUB      r1,r0,#0xff00         ;1547
0000b6  39ff              SUBS     r1,r1,#0xff           ;1547
0000b8  d10c              BNE      |L7.212|
                  |L7.186|
0000ba  f1080801          ADD      r8,r8,#1              ;1547
0000be  f1b80f0d          CMP      r8,#0xd               ;1547
0000c2  d3e0              BCC      |L7.134|
0000c4  f8990000          LDRB     r0,[r9,#0]            ;1547
0000c8  0640              LSLS     r0,r0,#25             ;1547
0000ca  d506              BPL      |L7.218|
0000cc  b12f              CBZ      r7,|L7.218|
0000ce  f83a0016          LDRH     r0,[r10,r6,LSL #1]    ;1547
0000d2  b110              CBZ      r0,|L7.218|
                  |L7.212|
0000d4  25ff              MOVS     r5,#0xff              ;1547
                  |L7.214|
0000d6  b2ed              UXTB     r5,r5                 ;1547
0000d8  e01b              B        |L7.274|
                  |L7.218|
0000da  1e6d              SUBS     r5,r5,#1              ;1547
0000dc  e7fb              B        |L7.214|
                  |L7.222|
0000de  4630              MOV      r0,r6
0000e0  f7fffffe          BL       sum_sfn
0000e4  4558              CMP      r0,r11
0000e6  d01b              BEQ      |L7.288|
                  |L7.232|
;;;1551   				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
0000e8  69a0              LDR      r0,[r4,#0x18]
0000ea  7ac1              LDRB     r1,[r0,#0xb]
0000ec  07c9              LSLS     r1,r1,#31
0000ee  d10c              BNE      |L7.266|
0000f0  210b              MOVS     r1,#0xb
0000f2  2200              MOVS     r2,#0
                  |L7.244|
0000f4  1e49              SUBS     r1,r1,#1
0000f6  d307              BCC      |L7.264|
0000f8  f8162b01          LDRB     r2,[r6],#1
0000fc  f8103b01          LDRB     r3,[r0],#1
000100  1ad2              SUBS     r2,r2,r3
000102  d0f7              BEQ      |L7.244|
000104  e001              B        |L7.266|
                  |L7.262|
000106  e00c              B        |L7.290|
                  |L7.264|
000108  b152              CBZ      r2,|L7.288|
                  |L7.266|
;;;1552   				ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
00010a  f64f70ff          MOV      r0,#0xffff
00010e  25ff              MOVS     r5,#0xff
000110  8420              STRH     r0,[r4,#0x20]
                  |L7.274|
;;;1553   			}
;;;1554   		}
;;;1555   #else		/* Non LFN configuration */
;;;1556   		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
;;;1557   			break;
;;;1558   #endif
;;;1559   		res = dir_next(dp, 0);		/* Next entry */
000112  2100              MOVS     r1,#0
000114  4620              MOV      r0,r4
000116  f7fffffe          BL       dir_next
00011a  0007              MOVS     r7,r0
;;;1560   	} while (res == FR_OK);
00011c  f43faf7d          BEQ      |L7.26|
                  |L7.288|
;;;1561   
;;;1562   	return res;
000120  4638              MOV      r0,r7
                  |L7.290|
;;;1563   }
000122  e8bd9ff0          POP      {r4-r12,pc}
;;;1564   
                          ENDP

000126  0000              DCW      0x0000
                  |L7.296|
                          DCD      ||.constdata||

                          AREA ||i.dir_next||, CODE, READONLY, ALIGN=1

                  dir_next PROC
;;;1186   static
;;;1187   FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1188   	DIR* dp,		/* Pointer to the directory object */
;;;1189   	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
;;;1190   )
;;;1191   {
;;;1192   	DWORD clst;
;;;1193   	UINT i;
;;;1194   
;;;1195   
;;;1196   	i = dp->index + 1;
000004  88c7              LDRH     r7,[r0,#6]
000006  4604              MOV      r4,r0                 ;1191
000008  1c7f              ADDS     r7,r7,#1
;;;1197   	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
00000a  0438              LSLS     r0,r7,#16
00000c  460e              MOV      r6,r1                 ;1191
00000e  0c00              LSRS     r0,r0,#16
000010  d033              BEQ      |L8.122|
000012  6921              LDR      r1,[r4,#0x10]
000014  b389              CBZ      r1,|L8.122|
;;;1198   		return FR_NO_FILE;
;;;1199   
;;;1200   	if (!(i % (SS(dp->fs) / SZ_DIR))) {	/* Sector changed? */
000016  6820              LDR      r0,[r4,#0]
000018  8942              LDRH     r2,[r0,#0xa]
00001a  0952              LSRS     r2,r2,#5
00001c  fbb7f3f2          UDIV     r3,r7,r2
000020  fb027213          MLS      r2,r2,r3,r7
000024  2a00              CMP      r2,#0
000026  d159              BNE      |L8.220|
000028  1c49              ADDS     r1,r1,#1
;;;1201   		dp->sect++;					/* Next sector */
;;;1202   
;;;1203   		if (!dp->clust) {		/* Static table */
00002a  6121              STR      r1,[r4,#0x10]
00002c  68e1              LDR      r1,[r4,#0xc]
00002e  b309              CBZ      r1,|L8.116|
;;;1204   			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
;;;1205   				return FR_NO_FILE;
;;;1206   		}
;;;1207   		else {					/* Dynamic table */
;;;1208   			if (((i / (SS(dp->fs) / SZ_DIR)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
000030  8942              LDRH     r2,[r0,#0xa]
000032  7883              LDRB     r3,[r0,#2]
000034  0952              LSRS     r2,r2,#5
000036  fbb7f2f2          UDIV     r2,r7,r2
00003a  1e5b              SUBS     r3,r3,#1
00003c  421a              TST      r2,r3
00003e  d14d              BNE      |L8.220|
;;;1209   				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
000040  f7fffffe          BL       get_fat
000044  4605              MOV      r5,r0
;;;1210   				if (clst <= 1) return FR_INT_ERR;
000046  2801              CMP      r0,#1
000048  d91c              BLS      |L8.132|
;;;1211   				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
00004a  1c68              ADDS     r0,r5,#1
00004c  d032              BEQ      |L8.180|
;;;1212   				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
00004e  6820              LDR      r0,[r4,#0]
000050  6981              LDR      r1,[r0,#0x18]
000052  42a9              CMP      r1,r5
000054  d83c              BHI      |L8.208|
;;;1213   #if !_FS_READONLY
;;;1214   					UINT c;
;;;1215   					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
000056  b186              CBZ      r6,|L8.122|
;;;1216   					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
000058  68e1              LDR      r1,[r4,#0xc]
00005a  f7fffffe          BL       create_chain
00005e  0005              MOVS     r5,r0
;;;1217   					if (clst == 0) return FR_DENIED;			/* No free cluster */
000060  d00e              BEQ      |L8.128|
;;;1218   					if (clst == 1) return FR_INT_ERR;
000062  2d01              CMP      r5,#1
000064  d00e              BEQ      |L8.132|
;;;1219   					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
000066  1c68              ADDS     r0,r5,#1
000068  d024              BEQ      |L8.180|
;;;1220   					/* Clean-up stretched table */
;;;1221   					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
00006a  6820              LDR      r0,[r4,#0]
00006c  f7fffffe          BL       sync_window
000070  bb00              CBNZ     r0,|L8.180|
000072  e009              B        |L8.136|
                  |L8.116|
000074  8900              LDRH     r0,[r0,#8]            ;1204
000076  42b8              CMP      r0,r7                 ;1204
000078  d830              BHI      |L8.220|
                  |L8.122|
00007a  2004              MOVS     r0,#4                 ;1215
                  |L8.124|
;;;1222   					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
;;;1223   					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
;;;1224   					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
;;;1225   						dp->fs->wflag = 1;
;;;1226   						if (sync_window(dp->fs)) return FR_DISK_ERR;
;;;1227   						dp->fs->winsect++;
;;;1228   					}
;;;1229   					dp->fs->winsect -= c;						/* Rewind window offset */
;;;1230   #else
;;;1231   					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT (this is to suppress warning) */
;;;1232   					return FR_NO_FILE;							/* Report EOT */
;;;1233   #endif
;;;1234   				}
;;;1235   				dp->clust = clst;				/* Initialize data for new cluster */
;;;1236   				dp->sect = clust2sect(dp->fs, clst);
;;;1237   			}
;;;1238   		}
;;;1239   	}
;;;1240   
;;;1241   	dp->index = (WORD)i;	/* Current index */
;;;1242   	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIR)) * SZ_DIR;	/* Current entry in the window */
;;;1243   
;;;1244   	return FR_OK;
;;;1245   }
00007c  e8bd81f0          POP      {r4-r8,pc}
                  |L8.128|
000080  2007              MOVS     r0,#7                 ;1217
000082  e7fb              B        |L8.124|
                  |L8.132|
000084  2002              MOVS     r0,#2                 ;1218
000086  e7f9              B        |L8.124|
                  |L8.136|
000088  6820              LDR      r0,[r4,#0]            ;1222
00008a  2100              MOVS     r1,#0                 ;1222
00008c  8942              LDRH     r2,[r0,#0xa]          ;1222
00008e  3034              ADDS     r0,r0,#0x34           ;1222
000090  f7fffffe          BL       mem_set
000094  4629              MOV      r1,r5                 ;1223
000096  6820              LDR      r0,[r4,#0]            ;1223
000098  f7fffffe          BL       clust2sect
00009c  6821              LDR      r1,[r4,#0]            ;1223
00009e  2600              MOVS     r6,#0                 ;1224
0000a0  f04f0801          MOV      r8,#1                 ;1211
0000a4  6308              STR      r0,[r1,#0x30]         ;1224
0000a6  e00c              B        |L8.194|
                  |L8.168|
0000a8  f8808004          STRB     r8,[r0,#4]            ;1225
0000ac  6820              LDR      r0,[r4,#0]            ;1226
0000ae  f7fffffe          BL       sync_window
0000b2  b108              CBZ      r0,|L8.184|
                  |L8.180|
0000b4  2001              MOVS     r0,#1                 ;1226
0000b6  e7e1              B        |L8.124|
                  |L8.184|
0000b8  6820              LDR      r0,[r4,#0]            ;1227
0000ba  6b01              LDR      r1,[r0,#0x30]         ;1227
0000bc  1c49              ADDS     r1,r1,#1              ;1227
0000be  1c76              ADDS     r6,r6,#1              ;1227
0000c0  6301              STR      r1,[r0,#0x30]         ;1227
                  |L8.194|
0000c2  6820              LDR      r0,[r4,#0]            ;1224
0000c4  7881              LDRB     r1,[r0,#2]            ;1224
0000c6  42b1              CMP      r1,r6                 ;1224
0000c8  d8ee              BHI      |L8.168|
0000ca  6b01              LDR      r1,[r0,#0x30]         ;1229
0000cc  1b89              SUBS     r1,r1,r6              ;1229
0000ce  6301              STR      r1,[r0,#0x30]         ;1229
                  |L8.208|
0000d0  60e5              STR      r5,[r4,#0xc]          ;1236
0000d2  4629              MOV      r1,r5                 ;1236
0000d4  6820              LDR      r0,[r4,#0]            ;1236
0000d6  f7fffffe          BL       clust2sect
0000da  6120              STR      r0,[r4,#0x10]         ;1236
                  |L8.220|
0000dc  80e7              STRH     r7,[r4,#6]            ;1241
0000de  6820              LDR      r0,[r4,#0]            ;1242
0000e0  8941              LDRH     r1,[r0,#0xa]          ;1242
0000e2  0949              LSRS     r1,r1,#5              ;1242
0000e4  fbb7f2f1          UDIV     r2,r7,r1              ;1242
0000e8  fb017112          MLS      r1,r1,r2,r7           ;1242
0000ec  2234              MOVS     r2,#0x34              ;1242
0000ee  eb021141          ADD      r1,r2,r1,LSL #5       ;1242
0000f2  4408              ADD      r0,r0,r1              ;1242
0000f4  6160              STR      r0,[r4,#0x14]         ;1244
0000f6  2000              MOVS     r0,#0                 ;1244
0000f8  e7c0              B        |L8.124|
;;;1246   
                          ENDP


                          AREA ||i.dir_read||, CODE, READONLY, ALIGN=2

                  dir_read PROC
;;;1572   static
;;;1573   FRESULT dir_read (
000000  e92d5ff3          PUSH     {r0,r1,r4-r12,lr}
;;;1574   	DIR* dp,		/* Pointer to the directory object */
;;;1575   	int vol			/* Filtered by 0:file/directory or 1:volume label */
;;;1576   )
;;;1577   {
;;;1578   	FRESULT res;
;;;1579   	BYTE a, c, *dir;
;;;1580   #if _USE_LFN
;;;1581   	BYTE ord = 0xFF, sum = 0xFF;
000004  25ff              MOVS     r5,#0xff
000006  4604              MOV      r4,r0                 ;1577
000008  462e              MOV      r6,r5
;;;1582   #endif
;;;1583   
;;;1584   	res = FR_NO_FILE;
00000a  2704              MOVS     r7,#4
00000c  f64f7aff          MOV      r10,#0xffff
000010  f04f0b00          MOV      r11,#0
000014  e067              B        |L9.230|
                  |L9.22|
;;;1585   	while (dp->sect) {
;;;1586   		res = move_window(dp->fs, dp->sect);
000016  6820              LDR      r0,[r4,#0]
000018  f7fffffe          BL       move_window
00001c  0007              MOVS     r7,r0
;;;1587   		if (res != FR_OK) break;
00001e  d166              BNE      |L9.238|
;;;1588   		dir = dp->dir;					/* Ptr to the directory entry of current index */
;;;1589   		c = dir[DIR_Name];
000020  6962              LDR      r2,[r4,#0x14]
000022  7810              LDRB     r0,[r2,#0]
;;;1590   		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
000024  b178              CBZ      r0,|L9.70|
;;;1591   		a = dir[DIR_Attr] & AM_MASK;
000026  7ad1              LDRB     r1,[r2,#0xb]
;;;1592   #if _USE_LFN	/* LFN configuration */
;;;1593   		if (c == DDE || (!_FS_RPATH && c == '.') || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
000028  28e5              CMP      r0,#0xe5
00002a  f001013f          AND      r1,r1,#0x3f           ;1591
00002e  d008              BEQ      |L9.66|
000030  f0210320          BIC      r3,r1,#0x20
000034  2b08              CMP      r3,#8
000036  d008              BEQ      |L9.74|
000038  2300              MOVS     r3,#0
                  |L9.58|
00003a  f8ddc004          LDR      r12,[sp,#4]
00003e  4563              CMP      r3,r12
000040  d005              BEQ      |L9.78|
                  |L9.66|
;;;1594   			ord = 0xFF;
000042  25ff              MOVS     r5,#0xff
000044  e040              B        |L9.200|
                  |L9.70|
000046  2704              MOVS     r7,#4                 ;1590
000048  e051              B        |L9.238|
                  |L9.74|
00004a  2301              MOVS     r3,#1                 ;1593
00004c  e7f5              B        |L9.58|
                  |L9.78|
;;;1595   		} else {
;;;1596   			if (a == AM_LFN) {			/* An LFN entry is found */
00004e  290f              CMP      r1,#0xf
000050  d001              BEQ      |L9.86|
;;;1597   				if (c & LLE) {			/* Is it start of LFN sequence? */
;;;1598   					sum = dir[LDIR_Chksum];
;;;1599   					c &= ~LLE; ord = c;
;;;1600   					dp->lfn_idx = dp->index;
;;;1601   				}
;;;1602   				/* Check LFN validity and capture it */
;;;1603   				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
;;;1604   			} else {					/* An SFN entry is found */
;;;1605   				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
000052  bbb5              CBNZ     r5,|L9.194|
000054  e03f              B        |L9.214|
                  |L9.86|
000056  0641              LSLS     r1,r0,#25             ;1597
000058  d505              BPL      |L9.102|
00005a  7b56              LDRB     r6,[r2,#0xd]          ;1598
00005c  f0200040          BIC      r0,r0,#0x40           ;1599
000060  88e1              LDRH     r1,[r4,#6]            ;1600
000062  4605              MOV      r5,r0                 ;1599
000064  8421              STRH     r1,[r4,#0x20]         ;1600
                  |L9.102|
000066  42a8              CMP      r0,r5                 ;1603
000068  d12c              BNE      |L9.196|
00006a  7b50              LDRB     r0,[r2,#0xd]          ;1603
00006c  42b0              CMP      r0,r6                 ;1603
00006e  d129              BNE      |L9.196|
000070  7810              LDRB     r0,[r2,#0]            ;1603
000072  f8df9084          LDR      r9,|L9.248|
000076  f000003f          AND      r0,r0,#0x3f           ;1603
00007a  1e40              SUBS     r0,r0,#1              ;1603
00007c  eb000180          ADD      r1,r0,r0,LSL #2       ;1603
000080  eb0101c0          ADD      r1,r1,r0,LSL #3       ;1603
000084  2000              MOVS     r0,#0                 ;1603
000086  69e7              LDR      r7,[r4,#0x1c]         ;1603
000088  2301              MOVS     r3,#1                 ;1603
00008a  46d4              MOV      r12,r10               ;1603
                  |L9.140|
00008c  f8198000          LDRB     r8,[r9,r0]            ;1603
000090  4490              ADD      r8,r8,r2              ;1603
000092  f8b88000          LDRH     r8,[r8,#0]            ;1603
000096  b133              CBZ      r3,|L9.166|
000098  29ff              CMP      r1,#0xff              ;1603
00009a  d213              BCS      |L9.196|
00009c  f8278011          STRH     r8,[r7,r1,LSL #1]     ;1603
0000a0  4643              MOV      r3,r8                 ;1603
0000a2  1c49              ADDS     r1,r1,#1              ;1603
0000a4  e001              B        |L9.170|
                  |L9.166|
0000a6  45e0              CMP      r8,r12                ;1603
0000a8  d10c              BNE      |L9.196|
                  |L9.170|
0000aa  1c40              ADDS     r0,r0,#1              ;1603
0000ac  280d              CMP      r0,#0xd               ;1603
0000ae  d3ed              BCC      |L9.140|
0000b0  7810              LDRB     r0,[r2,#0]            ;1603
0000b2  0640              LSLS     r0,r0,#25             ;1603
0000b4  d503              BPL      |L9.190|
0000b6  29ff              CMP      r1,#0xff              ;1603
0000b8  d204              BCS      |L9.196|
0000ba  f827b011          STRH     r11,[r7,r1,LSL #1]    ;1603
                  |L9.190|
0000be  1e6d              SUBS     r5,r5,#1              ;1603
0000c0  e001              B        |L9.198|
                  |L9.194|
0000c2  e00d              B        |L9.224|
                  |L9.196|
0000c4  25ff              MOVS     r5,#0xff              ;1603
                  |L9.198|
0000c6  b2ed              UXTB     r5,r5                 ;1603
                  |L9.200|
;;;1606   					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
;;;1607   				break;
;;;1608   			}
;;;1609   		}
;;;1610   #else		/* Non LFN configuration */
;;;1611   		if (c != DDE && (_FS_RPATH || c != '.') && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol)	/* Is it a valid entry? */
;;;1612   			break;
;;;1613   #endif
;;;1614   		res = dir_next(dp, 0);				/* Next entry */
0000c8  2100              MOVS     r1,#0
0000ca  4620              MOV      r0,r4
0000cc  f7fffffe          BL       dir_next
0000d0  0007              MOVS     r7,r0
;;;1615   		if (res != FR_OK) break;
0000d2  d008              BEQ      |L9.230|
0000d4  e00b              B        |L9.238|
                  |L9.214|
0000d6  4610              MOV      r0,r2                 ;1605
0000d8  f7fffffe          BL       sum_sfn
0000dc  42b0              CMP      r0,r6                 ;1605
0000de  d008              BEQ      |L9.242|
                  |L9.224|
0000e0  f8a4a020          STRH     r10,[r4,#0x20]        ;1606
0000e4  e005              B        |L9.242|
                  |L9.230|
0000e6  6921              LDR      r1,[r4,#0x10]         ;1585
0000e8  2900              CMP      r1,#0                 ;1585
0000ea  d194              BNE      |L9.22|
;;;1616   	}
;;;1617   
;;;1618   	if (res != FR_OK) dp->sect = 0;
0000ec  b10f              CBZ      r7,|L9.242|
                  |L9.238|
0000ee  f8c4b010          STR      r11,[r4,#0x10]
                  |L9.242|
;;;1619   
;;;1620   	return res;
0000f2  4638              MOV      r0,r7
;;;1621   }
0000f4  e8bd9ffc          POP      {r2-r12,pc}
;;;1622   #endif	/* _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2 */
                          ENDP

                  |L9.248|
                          DCD      ||.constdata||

                          AREA ||i.dir_register||, CODE, READONLY, ALIGN=2

                  dir_register PROC
;;;1631   static
;;;1632   FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;1633   	DIR* dp				/* Target directory with object name to be created */
;;;1634   )
;;;1635   {
000004  4604              MOV      r4,r0
;;;1636   	FRESULT res;
;;;1637   #if _USE_LFN	/* LFN configuration */
;;;1638   	UINT n, nent;
;;;1639   	BYTE sn[12], *fn, sum;
;;;1640   	WCHAR *lfn;
;;;1641   
;;;1642   
;;;1643   	fn = dp->fn; lfn = dp->lfn;
;;;1644   	mem_cpy(sn, fn, 12);
000006  220c              MOVS     r2,#0xc
000008  e9d47606          LDRD     r7,r6,[r4,#0x18]
00000c  4639              MOV      r1,r7
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       mem_cpy
;;;1645   
;;;1646   	if (_FS_RPATH && (sn[NSFLAG] & NS_DOT))		/* Cannot create dot entry */
000014  f89d000b          LDRB     r0,[sp,#0xb]
000018  0681              LSLS     r1,r0,#26
00001a  d503              BPL      |L10.36|
;;;1647   		return FR_INVALID_NAME;
00001c  2006              MOVS     r0,#6
                  |L10.30|
;;;1648   
;;;1649   	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
;;;1650   		fn[NSFLAG] = 0; dp->lfn = 0;			/* Find only SFN */
;;;1651   		for (n = 1; n < 100; n++) {
;;;1652   			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
;;;1653   			res = dir_find(dp);				/* Check if the name collides with existing SFN */
;;;1654   			if (res != FR_OK) break;
;;;1655   		}
;;;1656   		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
;;;1657   		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
;;;1658   		fn[NSFLAG] = sn[NSFLAG]; dp->lfn = lfn;
;;;1659   	}
;;;1660   
;;;1661   	if (sn[NSFLAG] & NS_LFN) {			/* When LFN is to be created, allocate entries for an SFN + LFNs. */
;;;1662   		for (n = 0; lfn[n]; n++) ;
;;;1663   		nent = (n + 25) / 13;
;;;1664   	} else {						/* Otherwise allocate an entry for an SFN  */
;;;1665   		nent = 1;
;;;1666   	}
;;;1667   	res = dir_alloc(dp, nent);		/* Allocate entries */
;;;1668   
;;;1669   	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
;;;1670   		res = dir_sdi(dp, dp->index - nent);
;;;1671   		if (res == FR_OK) {
;;;1672   			sum = sum_sfn(dp->fn);	/* Sum value of the SFN tied to the LFN */
;;;1673   			do {					/* Store LFN entries in bottom first */
;;;1674   				res = move_window(dp->fs, dp->sect);
;;;1675   				if (res != FR_OK) break;
;;;1676   				fit_lfn(dp->lfn, dp->dir, (BYTE)nent, sum);
;;;1677   				dp->fs->wflag = 1;
;;;1678   				res = dir_next(dp, 0);	/* Next entry */
;;;1679   			} while (res == FR_OK && --nent);
;;;1680   		}
;;;1681   	}
;;;1682   #else	/* Non LFN configuration */
;;;1683   	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
;;;1684   #endif
;;;1685   
;;;1686   	if (res == FR_OK) {				/* Set SFN entry */
;;;1687   		res = move_window(dp->fs, dp->sect);
;;;1688   		if (res == FR_OK) {
;;;1689   			mem_set(dp->dir, 0, SZ_DIR);	/* Clean the entry */
;;;1690   			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
;;;1691   #if _USE_LFN
;;;1692   			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
;;;1693   #endif
;;;1694   			dp->fs->wflag = 1;
;;;1695   		}
;;;1696   	}
;;;1697   
;;;1698   	return res;
;;;1699   }
00001e  b004              ADD      sp,sp,#0x10
000020  e8bd9ff0          POP      {r4-r12,pc}
                  |L10.36|
000024  07c0              LSLS     r0,r0,#31             ;1649
000026  d018              BEQ      |L10.90|
000028  2000              MOVS     r0,#0                 ;1650
00002a  72f8              STRB     r0,[r7,#0xb]          ;1650
00002c  2501              MOVS     r5,#1                 ;1651
00002e  61e0              STR      r0,[r4,#0x1c]         ;1651
                  |L10.48|
000030  462b              MOV      r3,r5                 ;1652
000032  4632              MOV      r2,r6                 ;1652
000034  4669              MOV      r1,sp                 ;1652
000036  4638              MOV      r0,r7                 ;1652
000038  f7fffffe          BL       gen_numname
00003c  4620              MOV      r0,r4                 ;1653
00003e  f7fffffe          BL       dir_find
000042  b910              CBNZ     r0,|L10.74|
000044  1c6d              ADDS     r5,r5,#1              ;1654
000046  2d64              CMP      r5,#0x64              ;1651
000048  d3f2              BCC      |L10.48|
                  |L10.74|
00004a  2d64              CMP      r5,#0x64              ;1656
00004c  d00b              BEQ      |L10.102|
00004e  2804              CMP      r0,#4                 ;1657
000050  d1e5              BNE      |L10.30|
000052  f89d000b          LDRB     r0,[sp,#0xb]          ;1658
000056  72f8              STRB     r0,[r7,#0xb]          ;1658
000058  61e6              STR      r6,[r4,#0x1c]         ;1658
                  |L10.90|
00005a  f89d000b          LDRB     r0,[sp,#0xb]          ;1661
00005e  0780              LSLS     r0,r0,#30             ;1661
000060  d50d              BPL      |L10.126|
000062  2000              MOVS     r0,#0                 ;1662
000064  e002              B        |L10.108|
                  |L10.102|
000066  2007              MOVS     r0,#7                 ;1656
000068  e7d9              B        |L10.30|
                  |L10.106|
00006a  1c40              ADDS     r0,r0,#1
                  |L10.108|
00006c  f8361010          LDRH     r1,[r6,r0,LSL #1]     ;1662
000070  2900              CMP      r1,#0                 ;1662
000072  d1fa              BNE      |L10.106|
000074  210d              MOVS     r1,#0xd               ;1663
000076  3019              ADDS     r0,r0,#0x19           ;1663
000078  fbb0f5f1          UDIV     r5,r0,r1              ;1663
00007c  e000              B        |L10.128|
                  |L10.126|
00007e  2501              MOVS     r5,#1                 ;1665
                  |L10.128|
000080  4629              MOV      r1,r5                 ;1667
000082  4620              MOV      r0,r4                 ;1667
000084  f7fffffe          BL       dir_alloc
000088  0006              MOVS     r6,r0                 ;1667
00008a  d16b              BNE      |L10.356|
00008c  1e6d              SUBS     r5,r5,#1              ;1669
00008e  d050              BEQ      |L10.306|
000090  88e0              LDRH     r0,[r4,#6]            ;1670
000092  1b41              SUBS     r1,r0,r5              ;1670
000094  4620              MOV      r0,r4                 ;1670
000096  f7fffffe          BL       dir_sdi
00009a  0006              MOVS     r6,r0                 ;1670
00009c  d162              BNE      |L10.356|
00009e  69a0              LDR      r0,[r4,#0x18]         ;1672
0000a0  f7fffffe          BL       sum_sfn
0000a4  f64f7aff          MOV      r10,#0xffff           ;1672
0000a8  9003              STR      r0,[sp,#0xc]          ;1672
                  |L10.170|
0000aa  6921              LDR      r1,[r4,#0x10]         ;1674
0000ac  6820              LDR      r0,[r4,#0]            ;1674
0000ae  f7fffffe          BL       move_window
0000b2  0006              MOVS     r6,r0                 ;1674
0000b4  d156              BNE      |L10.356|
0000b6  6961              LDR      r1,[r4,#0x14]         ;1676
0000b8  f8d4901c          LDR      r9,[r4,#0x1c]         ;1676
0000bc  9803              LDR      r0,[sp,#0xc]          ;1676
0000be  7348              STRB     r0,[r1,#0xd]          ;1676
0000c0  200f              MOVS     r0,#0xf               ;1676
0000c2  72c8              STRB     r0,[r1,#0xb]          ;1676
0000c4  2000              MOVS     r0,#0                 ;1676
0000c6  7308              STRB     r0,[r1,#0xc]          ;1676
0000c8  7688              STRB     r0,[r1,#0x1a]         ;1676
0000ca  b2ee              UXTB     r6,r5                 ;1676
0000cc  76c8              STRB     r0,[r1,#0x1b]         ;1676
0000ce  1e70              SUBS     r0,r6,#1              ;1676
0000d0  eb000280          ADD      r2,r0,r0,LSL #2       ;1676
0000d4  eb0203c0          ADD      r3,r2,r0,LSL #3       ;1676
0000d8  2200              MOVS     r2,#0                 ;1676
0000da  f8dfb08c          LDR      r11,|L10.360|
0000de  f1010801          ADD      r8,r1,#1              ;1676
0000e2  e001              B        |L10.232|
                  |L10.228|
0000e4  4550              CMP      r0,r10                ;1676
0000e6  d002              BEQ      |L10.238|
                  |L10.232|
0000e8  f8390013          LDRH     r0,[r9,r3,LSL #1]     ;1676
0000ec  1c5b              ADDS     r3,r3,#1              ;1676
                  |L10.238|
0000ee  f81bc002          LDRB     r12,[r11,r2]          ;1676
0000f2  f801000c          STRB     r0,[r1,r12]           ;1676
0000f6  f81b7002          LDRB     r7,[r11,r2]           ;1676
0000fa  ea4f2c10          LSR      r12,r0,#8             ;1676
0000fe  f807c008          STRB     r12,[r7,r8]           ;1676
000102  b900              CBNZ     r0,|L10.262|
000104  4650              MOV      r0,r10                ;1676
                  |L10.262|
000106  1c52              ADDS     r2,r2,#1              ;1676
000108  2a0d              CMP      r2,#0xd               ;1676
00010a  d3eb              BCC      |L10.228|
00010c  4550              CMP      r0,r10                ;1676
00010e  d002              BEQ      |L10.278|
000110  f8390013          LDRH     r0,[r9,r3,LSL #1]     ;1676
000114  b908              CBNZ     r0,|L10.282|
                  |L10.278|
000116  f0460640          ORR      r6,r6,#0x40           ;1676
                  |L10.282|
00011a  700e              STRB     r6,[r1,#0]            ;1676
00011c  6821              LDR      r1,[r4,#0]            ;1677
00011e  2001              MOVS     r0,#1                 ;1677
000120  7108              STRB     r0,[r1,#4]            ;1677
000122  2100              MOVS     r1,#0                 ;1678
000124  4620              MOV      r0,r4                 ;1678
000126  f7fffffe          BL       dir_next
00012a  0006              MOVS     r6,r0                 ;1678
00012c  d11a              BNE      |L10.356|
00012e  1e6d              SUBS     r5,r5,#1              ;1679
000130  d1bb              BNE      |L10.170|
                  |L10.306|
000132  6921              LDR      r1,[r4,#0x10]         ;1687
000134  6820              LDR      r0,[r4,#0]            ;1687
000136  f7fffffe          BL       move_window
00013a  0006              MOVS     r6,r0                 ;1687
00013c  d112              BNE      |L10.356|
00013e  2220              MOVS     r2,#0x20              ;1689
000140  2100              MOVS     r1,#0                 ;1689
000142  6960              LDR      r0,[r4,#0x14]         ;1689
000144  f7fffffe          BL       mem_set
000148  e9d40105          LDRD     r0,r1,[r4,#0x14]      ;1690
00014c  220b              MOVS     r2,#0xb               ;1690
00014e  f7fffffe          BL       mem_cpy
000152  69a0              LDR      r0,[r4,#0x18]         ;1692
000154  6961              LDR      r1,[r4,#0x14]         ;1692
000156  7ac0              LDRB     r0,[r0,#0xb]          ;1692
000158  f0000018          AND      r0,r0,#0x18           ;1692
00015c  7308              STRB     r0,[r1,#0xc]          ;1692
00015e  6821              LDR      r1,[r4,#0]            ;1694
000160  2001              MOVS     r0,#1                 ;1694
000162  7108              STRB     r0,[r1,#4]            ;1694
                  |L10.356|
000164  4630              MOV      r0,r6                 ;1698
000166  e75a              B        |L10.30|
;;;1700   #endif /* !_FS_READONLY */
                          ENDP

                  |L10.360|
                          DCD      ||.constdata||

                          AREA ||i.dir_remove||, CODE, READONLY, ALIGN=1

                  dir_remove PROC
;;;1709   static
;;;1710   FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1711   	DIR* dp				/* Directory object pointing the entry to be removed */
;;;1712   )
;;;1713   {
;;;1714   	FRESULT res;
;;;1715   #if _USE_LFN	/* LFN configuration */
;;;1716   	UINT i;
;;;1717   
;;;1718   	i = dp->index;	/* SFN index */
;;;1719   	res = dir_sdi(dp, (dp->lfn_idx == 0xFFFF) ? i : dp->lfn_idx);	/* Goto the SFN or top of the LFN entries */
000004  8c01              LDRH     r1,[r0,#0x20]
000006  4604              MOV      r4,r0                 ;1713
000008  88c6              LDRH     r6,[r0,#6]            ;1718
00000a  f5a1407f          SUB      r0,r1,#0xff00
00000e  38ff              SUBS     r0,r0,#0xff
000010  d100              BNE      |L11.20|
000012  4631              MOV      r1,r6
                  |L11.20|
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       dir_sdi
00001a  0005              MOVS     r5,r0
;;;1720   	if (res == FR_OK) {
00001c  d11e              BNE      |L11.92|
;;;1721   		do {
;;;1722   			res = move_window(dp->fs, dp->sect);
;;;1723   			if (res != FR_OK) break;
;;;1724   			mem_set(dp->dir, 0, SZ_DIR);	/* Clear and mark the entry "deleted" */
;;;1725   			*dp->dir = DDE;
00001e  27e5              MOVS     r7,#0xe5
;;;1726   			dp->fs->wflag = 1;
000020  f04f0801          MOV      r8,#1
                  |L11.36|
000024  6921              LDR      r1,[r4,#0x10]         ;1722
000026  6820              LDR      r0,[r4,#0]            ;1722
000028  f7fffffe          BL       move_window
00002c  0005              MOVS     r5,r0                 ;1722
00002e  d112              BNE      |L11.86|
000030  2220              MOVS     r2,#0x20              ;1724
000032  2100              MOVS     r1,#0                 ;1724
000034  6960              LDR      r0,[r4,#0x14]         ;1724
000036  f7fffffe          BL       mem_set
00003a  6960              LDR      r0,[r4,#0x14]         ;1725
00003c  7007              STRB     r7,[r0,#0]            ;1725
00003e  6821              LDR      r1,[r4,#0]
000040  f8818004          STRB     r8,[r1,#4]
;;;1727   			if (dp->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
000044  88e0              LDRH     r0,[r4,#6]
000046  42b0              CMP      r0,r6
000048  d208              BCS      |L11.92|
;;;1728   			res = dir_next(dp, 0);		/* Next entry */
00004a  2100              MOVS     r1,#0
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       dir_next
000052  0005              MOVS     r5,r0
;;;1729   		} while (res == FR_OK);
000054  d0e6              BEQ      |L11.36|
                  |L11.86|
;;;1730   		if (res == FR_NO_FILE) res = FR_INT_ERR;
000056  2d04              CMP      r5,#4
000058  d100              BNE      |L11.92|
00005a  2502              MOVS     r5,#2
                  |L11.92|
;;;1731   	}
;;;1732   
;;;1733   #else			/* Non LFN configuration */
;;;1734   	res = dir_sdi(dp, dp->index);
;;;1735   	if (res == FR_OK) {
;;;1736   		res = move_window(dp->fs, dp->sect);
;;;1737   		if (res == FR_OK) {
;;;1738   			mem_set(dp->dir, 0, SZ_DIR);	/* Clear and mark the entry "deleted" */
;;;1739   			*dp->dir = DDE;
;;;1740   			dp->fs->wflag = 1;
;;;1741   		}
;;;1742   	}
;;;1743   #endif
;;;1744   
;;;1745   	return res;
00005c  4628              MOV      r0,r5
;;;1746   }
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;1747   #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.dir_sdi||, CODE, READONLY, ALIGN=1

                  dir_sdi PROC
;;;1138   static
;;;1139   FRESULT dir_sdi (
000000  b570              PUSH     {r4-r6,lr}
;;;1140   	DIR* dp,		/* Pointer to directory object */
;;;1141   	UINT idx		/* Index of directory table */
;;;1142   )
;;;1143   {
;;;1144   	DWORD clst, sect;
;;;1145   	UINT ic;
;;;1146   
;;;1147   
;;;1148   	dp->index = (WORD)idx;	/* Current index */
000002  80c1              STRH     r1,[r0,#6]
;;;1149   	clst = dp->sclust;		/* Table start cluster (0:root) */
;;;1150   	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
000004  6883              LDR      r3,[r0,#8]
000006  460d              MOV      r5,r1                 ;1143
000008  4604              MOV      r4,r0                 ;1143
00000a  2b01              CMP      r3,#1
00000c  d03e              BEQ      |L12.140|
00000e  6820              LDR      r0,[r4,#0]
000010  6981              LDR      r1,[r0,#0x18]
000012  4299              CMP      r1,r3
000014  d93a              BLS      |L12.140|
;;;1151   		return FR_INT_ERR;
;;;1152   	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
000016  b923              CBNZ     r3,|L12.34|
000018  7801              LDRB     r1,[r0,#0]
00001a  2903              CMP      r1,#3
00001c  d107              BNE      |L12.46|
;;;1153   		clst = dp->fs->dirbase;
00001e  6a83              LDR      r3,[r0,#0x28]
000020  b12b              CBZ      r3,|L12.46|
                  |L12.34|
;;;1154   
;;;1155   	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
;;;1156   		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
;;;1157   			return FR_INT_ERR;
;;;1158   		sect = dp->fs->dirbase;
;;;1159   	}
;;;1160   	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
;;;1161   		ic = SS(dp->fs) / SZ_DIR * dp->fs->csize;	/* Entries per cluster */
000022  8941              LDRH     r1,[r0,#0xa]
000024  7880              LDRB     r0,[r0,#2]
000026  0949              LSRS     r1,r1,#5
000028  fb11f600          SMULBB   r6,r1,r0
;;;1162   		while (idx >= ic) {	/* Follow cluster chain */
00002c  e010              B        |L12.80|
                  |L12.46|
00002e  8901              LDRH     r1,[r0,#8]            ;1156
000030  42a9              CMP      r1,r5                 ;1156
000032  d92b              BLS      |L12.140|
000034  6a80              LDR      r0,[r0,#0x28]         ;1158
000036  e011              B        |L12.92|
                  |L12.56|
;;;1163   			clst = get_fat(dp->fs, clst);				/* Get next cluster */
000038  f7fffffe          BL       get_fat
00003c  4603              MOV      r3,r0
;;;1164   			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
00003e  1c40              ADDS     r0,r0,#1
000040  d022              BEQ      |L12.136|
;;;1165   			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
000042  2b02              CMP      r3,#2
000044  d322              BCC      |L12.140|
000046  6820              LDR      r0,[r4,#0]
000048  6980              LDR      r0,[r0,#0x18]
00004a  4298              CMP      r0,r3
00004c  d91e              BLS      |L12.140|
;;;1166   				return FR_INT_ERR;
;;;1167   			idx -= ic;
00004e  1bad              SUBS     r5,r5,r6
                  |L12.80|
000050  6820              LDR      r0,[r4,#0]            ;1162
000052  42b5              CMP      r5,r6                 ;1162
;;;1168   		}
;;;1169   		sect = clust2sect(dp->fs, clst);
000054  4619              MOV      r1,r3
000056  d2ef              BCS      |L12.56|
000058  f7fffffe          BL       clust2sect
                  |L12.92|
;;;1170   	}
;;;1171   	dp->clust = clst;	/* Current cluster# */
;;;1172   	if (!sect) return FR_INT_ERR;
00005c  60e3              STR      r3,[r4,#0xc]
00005e  b1a8              CBZ      r0,|L12.140|
;;;1173   	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIR);					/* Sector# of the directory entry */
000060  6821              LDR      r1,[r4,#0]
000062  894a              LDRH     r2,[r1,#0xa]
000064  0952              LSRS     r2,r2,#5
000066  fbb5f2f2          UDIV     r2,r5,r2
00006a  4410              ADD      r0,r0,r2
;;;1174   	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
00006c  6120              STR      r0,[r4,#0x10]
00006e  8948              LDRH     r0,[r1,#0xa]
000070  0940              LSRS     r0,r0,#5
000072  fbb5f2f0          UDIV     r2,r5,r0
000076  fb005012          MLS      r0,r0,r2,r5
00007a  2234              MOVS     r2,#0x34
00007c  eb021040          ADD      r0,r2,r0,LSL #5
000080  4408              ADD      r0,r0,r1
;;;1175   
;;;1176   	return FR_OK;
000082  6160              STR      r0,[r4,#0x14]
000084  2000              MOVS     r0,#0
;;;1177   }
000086  bd70              POP      {r4-r6,pc}
                  |L12.136|
000088  2001              MOVS     r0,#1                 ;1164
00008a  bd70              POP      {r4-r6,pc}
                  |L12.140|
00008c  2002              MOVS     r0,#2                 ;1172
00008e  bd70              POP      {r4-r6,pc}
;;;1178   
                          ENDP


                          AREA ||i.f_chdir||, CODE, READONLY, ALIGN=1

                  f_chdir PROC
;;;2899   
;;;2900   FRESULT f_chdir (
000000  b511              PUSH     {r0,r4,lr}
;;;2901   	const TCHAR* path	/* Pointer to the directory path */
;;;2902   )
;;;2903   {
000002  f5ad7d0d          SUB      sp,sp,#0x234
;;;2904   	FRESULT res;
;;;2905   	DIR dj;
;;;2906   	DEF_NAMEBUF;
;;;2907   
;;;2908   
;;;2909   	/* Get logical drive number */
;;;2910   	res = find_volume(&dj.fs, &path, 0);
000006  2200              MOVS     r2,#0
000008  a98d              ADD      r1,sp,#0x234
00000a  a880              ADD      r0,sp,#0x200
00000c  f7fffffe          BL       find_volume
000010  0004              MOVS     r4,r0
;;;2911   	if (res == FR_OK) {
000012  d10b              BNE      |L13.44|
;;;2912   		INIT_BUF(dj);
000014  a889              ADD      r0,sp,#0x224
000016  9086              STR      r0,[sp,#0x218]
000018  f8cdd21c          STR      sp,[sp,#0x21c]
;;;2913   		res = follow_path(&dj, path);		/* Follow the path */
00001c  a880              ADD      r0,sp,#0x200
00001e  998d              LDR      r1,[sp,#0x234]
000020  f7fffffe          BL       follow_path
000024  0004              MOVS     r4,r0
;;;2914   		FREE_BUF();
;;;2915   		if (res == FR_OK) {					/* Follow completed */
000026  d005              BEQ      |L13.52|
;;;2916   			if (!dj.dir) {
;;;2917   				dj.fs->cdir = dj.sclust;	/* Start directory itself */
;;;2918   			} else {
;;;2919   				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
;;;2920   					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
;;;2921   				else
;;;2922   					res = FR_NO_PATH;		/* Reached but a file */
;;;2923   			}
;;;2924   		}
;;;2925   		if (res == FR_NO_FILE) res = FR_NO_PATH;
000028  2c04              CMP      r4,#4
00002a  d011              BEQ      |L13.80|
                  |L13.44|
;;;2926   	}
;;;2927   
;;;2928   	LEAVE_FF(dj.fs, res);
;;;2929   }
00002c  f50d7d0e          ADD      sp,sp,#0x238
000030  4620              MOV      r0,r4                 ;2928
000032  bd10              POP      {r4,pc}
                  |L13.52|
000034  9885              LDR      r0,[sp,#0x214]        ;2916
000036  b148              CBZ      r0,|L13.76|
000038  7ac0              LDRB     r0,[r0,#0xb]          ;2919
00003a  06c0              LSLS     r0,r0,#27             ;2919
00003c  d508              BPL      |L13.80|
00003e  9985              LDR      r1,[sp,#0x214]        ;2920
000040  9880              LDR      r0,[sp,#0x200]        ;2920
000042  f7fffffe          BL       ld_clust
                  |L13.70|
000046  9980              LDR      r1,[sp,#0x200]        ;2917
000048  6148              STR      r0,[r1,#0x14]         ;2917
00004a  e7ef              B        |L13.44|
                  |L13.76|
00004c  9882              LDR      r0,[sp,#0x208]        ;2917
00004e  e7fa              B        |L13.70|
                  |L13.80|
000050  2405              MOVS     r4,#5                 ;2922
000052  e7eb              B        |L13.44|
;;;2930   
                          ENDP


                          AREA ||i.f_chdrive||, CODE, READONLY, ALIGN=2

                  f_chdrive PROC
;;;2882   #if _VOLUMES >= 2
;;;2883   FRESULT f_chdrive (
000000  b501              PUSH     {r0,lr}
;;;2884   	const TCHAR* path		/* Drive number */
;;;2885   )
;;;2886   {
;;;2887   	int vol;
;;;2888   
;;;2889   
;;;2890   	vol = get_ldnumber(&path);
000002  4668              MOV      r0,sp
000004  f7fffffe          BL       get_ldnumber
;;;2891   	if (vol < 0) return FR_INVALID_DRIVE;
000008  2800              CMP      r0,#0
00000a  da01              BGE      |L14.16|
00000c  200b              MOVS     r0,#0xb
;;;2892   
;;;2893   	CurrVol = (BYTE)vol;
;;;2894   
;;;2895   	return FR_OK;
;;;2896   }
00000e  bd08              POP      {r3,pc}
                  |L14.16|
000010  4901              LDR      r1,|L14.24|
000012  7008              STRB     r0,[r1,#0]            ;2893
000014  2000              MOVS     r0,#0                 ;2895
000016  bd08              POP      {r3,pc}
;;;2897   #endif
                          ENDP

                  |L14.24|
                          DCD      ||.data||

                          AREA ||i.f_chmod||, CODE, READONLY, ALIGN=1

                  f_chmod PROC
;;;3603   
;;;3604   FRESULT f_chmod (
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;3605   	const TCHAR* path,	/* Pointer to the file path */
;;;3606   	BYTE value,			/* Attribute bits */
;;;3607   	BYTE mask			/* Attribute mask to change */
;;;3608   )
;;;3609   {
000002  f5ad7d0c          SUB      sp,sp,#0x230
000006  4615              MOV      r5,r2
000008  460c              MOV      r4,r1
;;;3610   	FRESULT res;
;;;3611   	DIR dj;
;;;3612   	BYTE *dir;
;;;3613   	DEF_NAMEBUF;
;;;3614   
;;;3615   
;;;3616   	/* Get logical drive number */
;;;3617   	res = find_volume(&dj.fs, &path, 1);
00000a  2201              MOVS     r2,#1
00000c  a98c              ADD      r1,sp,#0x230
00000e  a880              ADD      r0,sp,#0x200
000010  f7fffffe          BL       find_volume
;;;3618   	if (res == FR_OK) {
000014  2800              CMP      r0,#0
000016  d11c              BNE      |L15.82|
;;;3619   		INIT_BUF(dj);
000018  a889              ADD      r0,sp,#0x224
00001a  9086              STR      r0,[sp,#0x218]
00001c  f8cdd21c          STR      sp,[sp,#0x21c]
;;;3620   		res = follow_path(&dj, path);		/* Follow the file path */
000020  a880              ADD      r0,sp,#0x200
000022  998c              LDR      r1,[sp,#0x230]
000024  f7fffffe          BL       follow_path
;;;3621   		FREE_BUF();
;;;3622   		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT))
000028  2800              CMP      r0,#0
00002a  d112              BNE      |L15.82|
00002c  9886              LDR      r0,[sp,#0x218]
00002e  7ac0              LDRB     r0,[r0,#0xb]
000030  0680              LSLS     r0,r0,#26
000032  d411              BMI      |L15.88|
;;;3623   			res = FR_INVALID_NAME;
;;;3624   		if (res == FR_OK) {
;;;3625   			dir = dj.dir;
;;;3626   			if (!dir) {						/* Is it a root directory? */
000034  9885              LDR      r0,[sp,#0x214]
000036  b178              CBZ      r0,|L15.88|
;;;3627   				res = FR_INVALID_NAME;
;;;3628   			} else {						/* File or sub directory */
;;;3629   				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
000038  f0050227          AND      r2,r5,#0x27
;;;3630   				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
00003c  7ac1              LDRB     r1,[r0,#0xb]
00003e  4014              ANDS     r4,r4,r2
000040  4391              BICS     r1,r1,r2
000042  430c              ORRS     r4,r4,r1
000044  72c4              STRB     r4,[r0,#0xb]
;;;3631   				dj.fs->wflag = 1;
000046  9980              LDR      r1,[sp,#0x200]
000048  2001              MOVS     r0,#1
00004a  7108              STRB     r0,[r1,#4]
;;;3632   				res = sync_fs(dj.fs);
00004c  9880              LDR      r0,[sp,#0x200]
00004e  f7fffffe          BL       sync_fs
                  |L15.82|
;;;3633   			}
;;;3634   		}
;;;3635   	}
;;;3636   
;;;3637   	LEAVE_FF(dj.fs, res);
;;;3638   }
000052  f50d7d0f          ADD      sp,sp,#0x23c
000056  bd30              POP      {r4,r5,pc}
                  |L15.88|
000058  2006              MOVS     r0,#6                 ;3627
00005a  e7fa              B        |L15.82|
;;;3639   
                          ENDP


                          AREA ||i.f_close||, CODE, READONLY, ALIGN=1

                  f_close PROC
;;;2843   
;;;2844   FRESULT f_close (
000000  b510              PUSH     {r4,lr}
;;;2845   	FIL *fp		/* Pointer to the file object to be closed */
;;;2846   )
;;;2847   {
000002  4604              MOV      r4,r0
;;;2848   	FRESULT res;
;;;2849   
;;;2850   
;;;2851   #if !_FS_READONLY
;;;2852   	res = f_sync(fp);					/* Flush cached data */
000004  f7fffffe          BL       f_sync
;;;2853   	if (res == FR_OK)
000008  2800              CMP      r0,#0
00000a  d106              BNE      |L16.26|
;;;2854   #endif
;;;2855   	{
;;;2856   		res = validate(fp);				/* Lock volume */
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       validate
;;;2857   		if (res == FR_OK) {
000012  2800              CMP      r0,#0
000014  d101              BNE      |L16.26|
;;;2858   #if _FS_REENTRANT
;;;2859   			FATFS *fs = fp->fs;
;;;2860   #endif
;;;2861   #if _FS_LOCK
;;;2862   			res = dec_lock(fp->lockid);	/* Decrement file open counter */
;;;2863   			if (res == FR_OK)
;;;2864   #endif
;;;2865   				fp->fs = 0;				/* Invalidate file object */
000016  2100              MOVS     r1,#0
000018  6021              STR      r1,[r4,#0]
                  |L16.26|
;;;2866   #if _FS_REENTRANT
;;;2867   			unlock_fs(fs, FR_OK);		/* Unlock volume */
;;;2868   #endif
;;;2869   		}
;;;2870   	}
;;;2871   	return res;
;;;2872   }
00001a  bd10              POP      {r4,pc}
;;;2873   
                          ENDP


                          AREA ||i.f_closedir||, CODE, READONLY, ALIGN=1

                  f_closedir PROC
;;;3229   
;;;3230   FRESULT f_closedir (
000000  b510              PUSH     {r4,lr}
;;;3231   	DIR *dp		/* Pointer to the directory object to be closed */
;;;3232   )
;;;3233   {
000002  4604              MOV      r4,r0
;;;3234   	FRESULT res;
;;;3235   
;;;3236   
;;;3237   	res = validate(dp);
000004  f7fffffe          BL       validate
;;;3238   	if (res == FR_OK) {
000008  2800              CMP      r0,#0
00000a  d101              BNE      |L17.16|
;;;3239   #if _FS_REENTRANT
;;;3240   		FATFS *fs = dp->fs;
;;;3241   #endif
;;;3242   #if _FS_LOCK
;;;3243   		if (dp->lockid)				/* Decrement sub-directory open counter */
;;;3244   			res = dec_lock(dp->lockid);
;;;3245   		if (res == FR_OK)
;;;3246   #endif
;;;3247   			dp->fs = 0;				/* Invalidate directory object */
00000c  2100              MOVS     r1,#0
00000e  6021              STR      r1,[r4,#0]
                  |L17.16|
;;;3248   #if _FS_REENTRANT
;;;3249   		unlock_fs(fs, FR_OK);		/* Unlock volume */
;;;3250   #endif
;;;3251   	}
;;;3252   	return res;
;;;3253   }
000010  bd10              POP      {r4,pc}
;;;3254   
                          ENDP


                          AREA ||i.f_getfree||, CODE, READONLY, ALIGN=1

                  f_getfree PROC
;;;3338   
;;;3339   FRESULT f_getfree (
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;3340   	const TCHAR* path,	/* Path name of the logical drive number */
;;;3341   	DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
;;;3342   	FATFS** fatfs		/* Pointer to return pointer to corresponding file system object */
;;;3343   )
;;;3344   {
000004  4614              MOV      r4,r2
000006  468a              MOV      r10,r1
;;;3345   	FRESULT res;
;;;3346   	FATFS *fs;
;;;3347   	DWORD n, clst, sect, stat;
;;;3348   	UINT i;
;;;3349   	BYTE fat, *p;
;;;3350   
;;;3351   
;;;3352   	/* Get logical drive number */
;;;3353   	res = find_volume(fatfs, &path, 0);
000008  2200              MOVS     r2,#0
00000a  4669              MOV      r1,sp
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       find_volume
;;;3354   	fs = *fatfs;
;;;3355   	if (res == FR_OK) {
000012  6825              LDR      r5,[r4,#0]
000014  ea5f0800          MOVS     r8,r0                 ;3353
000018  d14e              BNE      |L18.184|
;;;3356   		/* If free_clust is valid, return it without full cluster scan */
;;;3357   		if (fs->free_clust <= fs->n_fatent - 2) {
00001a  69af              LDR      r7,[r5,#0x18]
00001c  6928              LDR      r0,[r5,#0x10]
00001e  1eb9              SUBS     r1,r7,#2
000020  4288              CMP      r0,r1
000022  d802              BHI      |L18.42|
;;;3358   			*nclst = fs->free_clust;
000024  f8ca0000          STR      r0,[r10,#0]
000028  e046              B        |L18.184|
                  |L18.42|
;;;3359   		} else {
;;;3360   			/* Get number of free clusters */
;;;3361   			fat = fs->fs_type;
00002a  f8959000          LDRB     r9,[r5,#0]
;;;3362   			n = 0;
00002e  2400              MOVS     r4,#0
;;;3363   			if (fat == FS_FAT12) {
000030  f1b90f01          CMP      r9,#1
000034  d001              BEQ      |L18.58|
;;;3364   				clst = 2;
;;;3365   				do {
;;;3366   					stat = get_fat(fs, clst);
;;;3367   					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
;;;3368   					if (stat == 1) { res = FR_INT_ERR; break; }
;;;3369   					if (stat == 0) n++;
;;;3370   				} while (++clst < fs->n_fatent);
;;;3371   			} else {
;;;3372   				clst = fs->n_fatent;
;;;3373   				sect = fs->fatbase;
;;;3374   				i = 0; p = 0;
;;;3375   				do {
000036  6a6e              LDR      r6,[r5,#0x24]
000038  e016              B        |L18.104|
                  |L18.58|
00003a  2602              MOVS     r6,#2                 ;3364
                  |L18.60|
00003c  4631              MOV      r1,r6                 ;3366
00003e  4628              MOV      r0,r5                 ;3366
000040  f7fffffe          BL       get_fat
000044  1c41              ADDS     r1,r0,#1              ;3367
000046  d003              BEQ      |L18.80|
000048  2801              CMP      r0,#1                 ;3368
00004a  d003              BEQ      |L18.84|
00004c  b128              CBZ      r0,|L18.90|
00004e  e005              B        |L18.92|
                  |L18.80|
000050  2001              MOVS     r0,#1                 ;3367
000052  e000              B        |L18.86|
                  |L18.84|
000054  2002              MOVS     r0,#2                 ;3368
                  |L18.86|
000056  4680              MOV      r8,r0                 ;3368
000058  e027              B        |L18.170|
                  |L18.90|
00005a  1c64              ADDS     r4,r4,#1              ;3368
                  |L18.92|
00005c  69a8              LDR      r0,[r5,#0x18]         ;3370
00005e  1c76              ADDS     r6,r6,#1              ;3370
000060  4286              CMP      r6,r0                 ;3370
000062  d3eb              BCC      |L18.60|
000064  e021              B        |L18.170|
                  |L18.102|
;;;3376   					if (!i) {
000066  b951              CBNZ     r1,|L18.126|
                  |L18.104|
;;;3377   						res = move_window(fs, sect++);
000068  4631              MOV      r1,r6
00006a  1c76              ADDS     r6,r6,#1
00006c  4628              MOV      r0,r5
00006e  f7fffffe          BL       move_window
000072  ea5f0800          MOVS     r8,r0
;;;3378   						if (res != FR_OK) break;
000076  d118              BNE      |L18.170|
;;;3379   						p = fs->win;
;;;3380   						i = SS(fs);
000078  8969              LDRH     r1,[r5,#0xa]
00007a  f1050034          ADD      r0,r5,#0x34           ;3379
                  |L18.126|
;;;3381   					}
;;;3382   					if (fat == FS_FAT16) {
00007e  f1b90f02          CMP      r9,#2
000082  d007              BEQ      |L18.148|
;;;3383   						if (LD_WORD(p) == 0) n++;
;;;3384   						p += 2; i -= 2;
;;;3385   					} else {
;;;3386   						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
000084  7802              LDRB     r2,[r0,#0]
000086  f8d03001          LDR      r3,[r0,#1]
00008a  ea422203          ORR      r2,r2,r3,LSL #8
00008e  0112              LSLS     r2,r2,#4
000090  d006              BEQ      |L18.160|
000092  e006              B        |L18.162|
                  |L18.148|
000094  8802              LDRH     r2,[r0,#0]            ;3383
000096  b902              CBNZ     r2,|L18.154|
000098  1c64              ADDS     r4,r4,#1              ;3383
                  |L18.154|
00009a  1c80              ADDS     r0,r0,#2              ;3383
00009c  1e89              SUBS     r1,r1,#2              ;3383
00009e  e002              B        |L18.166|
                  |L18.160|
0000a0  1c64              ADDS     r4,r4,#1              ;3384
                  |L18.162|
0000a2  1d00              ADDS     r0,r0,#4              ;3384
0000a4  1f09              SUBS     r1,r1,#4              ;3384
                  |L18.166|
0000a6  1e7f              SUBS     r7,r7,#1              ;3384
;;;3387   						p += 4; i -= 4;
;;;3388   					}
;;;3389   				} while (--clst);
0000a8  d1dd              BNE      |L18.102|
                  |L18.170|
;;;3390   			}
;;;3391   			fs->free_clust = n;
;;;3392   			fs->fsi_flag |= 1;
0000aa  612c              STR      r4,[r5,#0x10]
0000ac  7968              LDRB     r0,[r5,#5]
0000ae  f0400001          ORR      r0,r0,#1
0000b2  7168              STRB     r0,[r5,#5]
;;;3393   			*nclst = n;
0000b4  f8ca4000          STR      r4,[r10,#0]
                  |L18.184|
;;;3394   		}
;;;3395   	}
;;;3396   	LEAVE_FF(fs, res);
0000b8  4640              MOV      r0,r8
;;;3397   }
0000ba  e8bd8ffe          POP      {r1-r11,pc}
;;;3398   
                          ENDP


                          AREA ||i.f_getlabel||, CODE, READONLY, ALIGN=1

                  f_getlabel PROC
;;;3771   
;;;3772   FRESULT f_getlabel (
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;3773   	const TCHAR* path,	/* Path name of the logical drive number */
;;;3774   	TCHAR* label,		/* Pointer to a buffer to return the volume label */
;;;3775   	DWORD* vsn			/* Pointer to a variable to return the volume serial number */
;;;3776   )
;;;3777   {
000002  b08a              SUB      sp,sp,#0x28
000004  4617              MOV      r7,r2
000006  460d              MOV      r5,r1
;;;3778   	FRESULT res;
;;;3779   	DIR dj;
;;;3780   	UINT i, j;
;;;3781   
;;;3782   
;;;3783   	/* Get logical drive number */
;;;3784   	res = find_volume(&dj.fs, &path, 0);
000008  2200              MOVS     r2,#0
00000a  a90a              ADD      r1,sp,#0x28
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       find_volume
000012  0004              MOVS     r4,r0
;;;3785   
;;;3786   	/* Get volume label */
;;;3787   	if (res == FR_OK && label) {
000014  d136              BNE      |L19.132|
000016  b1fd              CBZ      r5,|L19.88|
;;;3788   		dj.sclust = 0;					/* Open root directory */
000018  2600              MOVS     r6,#0
;;;3789   		res = dir_sdi(&dj, 0);
00001a  4631              MOV      r1,r6
00001c  4668              MOV      r0,sp
00001e  9602              STR      r6,[sp,#8]
000020  f7fffffe          BL       dir_sdi
000024  0004              MOVS     r4,r0
;;;3790   		if (res == FR_OK) {
000026  d12d              BNE      |L19.132|
;;;3791   			res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
000028  2101              MOVS     r1,#1
00002a  4668              MOV      r0,sp
00002c  f7fffffe          BL       dir_read
000030  0004              MOVS     r4,r0
;;;3792   			if (res == FR_OK) {			/* A volume label is exist */
000032  d10b              BNE      |L19.76|
;;;3793   #if _USE_LFN && _LFN_UNICODE
;;;3794   				WCHAR w;
;;;3795   				i = j = 0;
;;;3796   				do {
;;;3797   					w = (i < 11) ? dj.dir[i++] : ' ';
;;;3798   					if (IsDBCS1(w) && i < 11 && IsDBCS2(dj.dir[i]))
;;;3799   						w = w << 8 | dj.dir[i++];
;;;3800   					label[j++] = ff_convert(w, 1);	/* OEM -> Unicode */
;;;3801   				} while (j < 11);
;;;3802   #else
;;;3803   				mem_cpy(label, dj.dir, 11);
000034  220b              MOVS     r2,#0xb
000036  4628              MOV      r0,r5
000038  9905              LDR      r1,[sp,#0x14]
00003a  f7fffffe          BL       mem_cpy
;;;3804   #endif
;;;3805   				j = 11;
00003e  200b              MOVS     r0,#0xb
                  |L19.64|
;;;3806   				do {
;;;3807   					label[j] = 0;
000040  542e              STRB     r6,[r5,r0]
;;;3808   					if (!j) break;
000042  b118              CBZ      r0,|L19.76|
000044  1e40              SUBS     r0,r0,#1
;;;3809   				} while (label[--j] == ' ');
000046  5c29              LDRB     r1,[r5,r0]
000048  2920              CMP      r1,#0x20
00004a  d0f9              BEQ      |L19.64|
                  |L19.76|
;;;3810   			}
;;;3811   			if (res == FR_NO_FILE) {	/* No label, return nul string */
00004c  2c04              CMP      r4,#4
00004e  d001              BEQ      |L19.84|
;;;3812   				label[0] = 0;
;;;3813   				res = FR_OK;
;;;3814   			}
;;;3815   		}
;;;3816   	}
;;;3817   
;;;3818   	/* Get volume serial number */
;;;3819   	if (res == FR_OK && vsn) {
000050  b114              CBZ      r4,|L19.88|
000052  e017              B        |L19.132|
                  |L19.84|
000054  702e              STRB     r6,[r5,#0]            ;3812
000056  2400              MOVS     r4,#0                 ;3813
                  |L19.88|
000058  b1a7              CBZ      r7,|L19.132|
;;;3820   		res = move_window(dj.fs, dj.fs->volbase);
00005a  9800              LDR      r0,[sp,#0]
00005c  6a01              LDR      r1,[r0,#0x20]
00005e  f7fffffe          BL       move_window
000062  0004              MOVS     r4,r0
;;;3821   		if (res == FR_OK) {
000064  d10e              BNE      |L19.132|
;;;3822   			i = dj.fs->fs_type == FS_FAT32 ? BS_VolID32 : BS_VolID;
000066  9800              LDR      r0,[sp,#0]
000068  7800              LDRB     r0,[r0,#0]
00006a  2803              CMP      r0,#3
00006c  d00d              BEQ      |L19.138|
00006e  2027              MOVS     r0,#0x27
                  |L19.112|
;;;3823   			*vsn = LD_DWORD(&dj.fs->win[i]);
000070  f1000134          ADD      r1,r0,#0x34
000074  9a00              LDR      r2,[sp,#0]
000076  3035              ADDS     r0,r0,#0x35
000078  4410              ADD      r0,r0,r2
00007a  5c51              LDRB     r1,[r2,r1]
00007c  6800              LDR      r0,[r0,#0]
00007e  ea412000          ORR      r0,r1,r0,LSL #8
000082  6038              STR      r0,[r7,#0]
                  |L19.132|
;;;3824   		}
;;;3825   	}
;;;3826   
;;;3827   	LEAVE_FF(dj.fs, res);
;;;3828   }
000084  b00d              ADD      sp,sp,#0x34
000086  4620              MOV      r0,r4                 ;3827
000088  bdf0              POP      {r4-r7,pc}
                  |L19.138|
00008a  2043              MOVS     r0,#0x43              ;3822
00008c  e7f0              B        |L19.112|
;;;3829   
                          ENDP


                          AREA ||i.f_gets||, CODE, READONLY, ALIGN=1

                  f_gets PROC
;;;4312   
;;;4313   TCHAR* f_gets (
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;4314   	TCHAR* buff,	/* Pointer to the string buffer to read */
;;;4315   	int len,		/* Size of string buffer (characters) */
;;;4316   	FIL* fp			/* Pointer to the file object */
;;;4317   )
;;;4318   {
;;;4319   	int n = 0;
000004  2500              MOVS     r5,#0
000006  4690              MOV      r8,r2                 ;4318
000008  4607              MOV      r7,r0                 ;4318
;;;4320   	TCHAR c, *p = buff;
00000a  4604              MOV      r4,r0
00000c  1e4e              SUBS     r6,r1,#1
00000e  e011              B        |L20.52|
                  |L20.16|
;;;4321   	BYTE s[2];
;;;4322   	UINT rc;
;;;4323   
;;;4324   
;;;4325   	while (n < len - 1) {	/* Read characters until buffer gets filled */
;;;4326   #if _USE_LFN && _LFN_UNICODE
;;;4327   #if _STRF_ENCODE == 3		/* Read a character in UTF-8 */
;;;4328   		f_read(fp, s, 1, &rc);
;;;4329   		if (rc != 1) break;
;;;4330   		c = s[0];
;;;4331   		if (c >= 0x80) {
;;;4332   			if (c < 0xC0) continue;	/* Skip stray trailer */
;;;4333   			if (c < 0xE0) {			/* Two-byte sequence */
;;;4334   				f_read(fp, s, 1, &rc);
;;;4335   				if (rc != 1) break;
;;;4336   				c = (c & 0x1F) << 6 | (s[0] & 0x3F);
;;;4337   				if (c < 0x80) c = '?';
;;;4338   			} else {
;;;4339   				if (c < 0xF0) {		/* Three-byte sequence */
;;;4340   					f_read(fp, s, 2, &rc);
;;;4341   					if (rc != 2) break;
;;;4342   					c = c << 12 | (s[0] & 0x3F) << 6 | (s[1] & 0x3F);
;;;4343   					if (c < 0x800) c = '?';
;;;4344   				} else {			/* Reject four-byte sequence */
;;;4345   					c = '?';
;;;4346   				}
;;;4347   			}
;;;4348   		}
;;;4349   #elif _STRF_ENCODE == 2		/* Read a character in UTF-16BE */
;;;4350   		f_read(fp, s, 2, &rc);
;;;4351   		if (rc != 2) break;
;;;4352   		c = s[1] + (s[0] << 8);
;;;4353   #elif _STRF_ENCODE == 1		/* Read a character in UTF-16LE */
;;;4354   		f_read(fp, s, 2, &rc);
;;;4355   		if (rc != 2) break;
;;;4356   		c = s[0] + (s[1] << 8);
;;;4357   #else						/* Read a character in ANSI/OEM */
;;;4358   		f_read(fp, s, 1, &rc);
;;;4359   		if (rc != 1) break;
;;;4360   		c = s[0];
;;;4361   		if (IsDBCS1(c)) {
;;;4362   			f_read(fp, s, 1, &rc);
;;;4363   			if (rc != 1) break;
;;;4364   			c = (c << 8) + s[0];
;;;4365   		}
;;;4366   		c = ff_convert(c, 1);	/* OEM -> Unicode */
;;;4367   		if (!c) c = '?';
;;;4368   #endif
;;;4369   #else						/* Read a character without conversion */
;;;4370   		f_read(fp, s, 1, &rc);
000010  ab01              ADD      r3,sp,#4
000012  2201              MOVS     r2,#1
000014  4669              MOV      r1,sp
000016  4640              MOV      r0,r8
000018  f7fffffe          BL       f_read
;;;4371   		if (rc != 1) break;
00001c  9801              LDR      r0,[sp,#4]
00001e  2801              CMP      r0,#1
000020  d10a              BNE      |L20.56|
;;;4372   		c = s[0];
000022  f89d0000          LDRB     r0,[sp,#0]
;;;4373   #endif
;;;4374   		if (_USE_STRFUNC == 2 && c == '\r') continue;	/* Strip '\r' */
000026  280d              CMP      r0,#0xd
000028  d004              BEQ      |L20.52|
;;;4375   		*p++ = c;
00002a  1c6d              ADDS     r5,r5,#1
00002c  f8040b01          STRB     r0,[r4],#1
;;;4376   		n++;
;;;4377   		if (c == '\n') break;		/* Break on EOL */
000030  280a              CMP      r0,#0xa
000032  d001              BEQ      |L20.56|
                  |L20.52|
000034  42b5              CMP      r5,r6                 ;4325
000036  dbeb              BLT      |L20.16|
                  |L20.56|
;;;4378   	}
;;;4379   	*p = 0;
000038  2000              MOVS     r0,#0
00003a  7020              STRB     r0,[r4,#0]
;;;4380   	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
00003c  b115              CBZ      r5,|L20.68|
00003e  4638              MOV      r0,r7
                  |L20.64|
;;;4381   }
000040  e8bd81fc          POP      {r2-r8,pc}
                  |L20.68|
000044  2000              MOVS     r0,#0                 ;4380
000046  e7fb              B        |L20.64|
;;;4382   
                          ENDP


                          AREA ||i.f_lseek||, CODE, READONLY, ALIGN=1

                  f_lseek PROC
;;;3015   
;;;3016   FRESULT f_lseek (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;3017   	FIL* fp,		/* Pointer to the file object */
;;;3018   	DWORD ofs		/* File pointer from top of file */
;;;3019   )
;;;3020   {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;3021   	FRESULT res;
;;;3022   
;;;3023   
;;;3024   	res = validate(fp);					/* Check validity of the object */
000008  f7fffffe          BL       validate
00000c  ea5f0800          MOVS     r8,r0
;;;3025   	if (res != FR_OK) LEAVE_FF(fp->fs, res);
000010  d17b              BNE      |L21.266|
;;;3026   	if (fp->err)						/* Check error */
000012  79e0              LDRB     r0,[r4,#7]
000014  2800              CMP      r0,#0
000016  d178              BNE      |L21.266|
;;;3027   		LEAVE_FF(fp->fs, (FRESULT)fp->err);
;;;3028   
;;;3029   #if _USE_FASTSEEK
;;;3030   	if (fp->cltbl) {	/* Fast seek */
;;;3031   		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
;;;3032   
;;;3033   		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
;;;3034   			tbl = fp->cltbl;
;;;3035   			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
;;;3036   			cl = fp->sclust;			/* Top of the chain */
;;;3037   			if (cl) {
;;;3038   				do {
;;;3039   					/* Get a fragment */
;;;3040   					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
;;;3041   					do {
;;;3042   						pcl = cl; ncl++;
;;;3043   						cl = get_fat(fp->fs, cl);
;;;3044   						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
;;;3045   						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;3046   					} while (cl == pcl + 1);
;;;3047   					if (ulen <= tlen) {		/* Store the length and top of the fragment */
;;;3048   						*tbl++ = ncl; *tbl++ = tcl;
;;;3049   					}
;;;3050   				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
;;;3051   			}
;;;3052   			*fp->cltbl = ulen;	/* Number of items used */
;;;3053   			if (ulen <= tlen)
;;;3054   				*tbl = 0;		/* Terminate table */
;;;3055   			else
;;;3056   				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
;;;3057   
;;;3058   		} else {						/* Fast seek */
;;;3059   			if (ofs > fp->fsize)		/* Clip offset at the file size */
;;;3060   				ofs = fp->fsize;
;;;3061   			fp->fptr = ofs;				/* Set file pointer */
;;;3062   			if (ofs) {
;;;3063   				fp->clust = clmt_clust(fp, ofs - 1);
;;;3064   				dsc = clust2sect(fp->fs, fp->clust);
;;;3065   				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
;;;3066   				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
;;;3067   				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
;;;3068   #if !_FS_TINY
;;;3069   #if !_FS_READONLY
;;;3070   					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
;;;3071   						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
;;;3072   							ABORT(fp->fs, FR_DISK_ERR);
;;;3073   						fp->flag &= ~FA__DIRTY;
;;;3074   					}
;;;3075   #endif
;;;3076   					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
;;;3077   						ABORT(fp->fs, FR_DISK_ERR);
;;;3078   #endif
;;;3079   					fp->dsect = dsc;
;;;3080   				}
;;;3081   			}
;;;3082   		}
;;;3083   	} else
;;;3084   #endif
;;;3085   
;;;3086   	/* Normal Seek */
;;;3087   	{
;;;3088   		DWORD clst, bcs, nsect, ifptr;
;;;3089   
;;;3090   		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
000018  68e0              LDR      r0,[r4,#0xc]
00001a  42a8              CMP      r0,r5
00001c  d203              BCS      |L21.38|
;;;3091   #if !_FS_READONLY
;;;3092   			 && !(fp->flag & FA_WRITE)
00001e  79a1              LDRB     r1,[r4,#6]
000020  0789              LSLS     r1,r1,#30
000022  d400              BMI      |L21.38|
;;;3093   #endif
;;;3094   			) ofs = fp->fsize;
000024  4605              MOV      r5,r0
                  |L21.38|
;;;3095   
;;;3096   		ifptr = fp->fptr;
;;;3097   		fp->fptr = nsect = 0;
000026  2700              MOVS     r7,#0
000028  68a1              LDR      r1,[r4,#8]
00002a  f04f0901          MOV      r9,#1                 ;3088
;;;3098   		if (ofs) {
00002e  60a7              STR      r7,[r4,#8]
000030  b30d              CBZ      r5,|L21.118|
;;;3099   			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
000032  6820              LDR      r0,[r4,#0]
;;;3100   			if (ifptr > 0 &&
;;;3101   				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
;;;3102   				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
;;;3103   				ofs -= fp->fptr;
;;;3104   				clst = fp->clust;
;;;3105   			} else {									/* When seek to back cluster, */
;;;3106   				clst = fp->sclust;						/* start from the first cluster */
;;;3107   #if !_FS_READONLY
;;;3108   				if (clst == 0) {						/* If no cluster chain, create a new chain */
;;;3109   					clst = create_chain(fp->fs, 0);
;;;3110   					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
000034  f04f0a02          MOV      r10,#2
000038  7886              LDRB     r6,[r0,#2]            ;3099
00003a  8942              LDRH     r2,[r0,#0xa]          ;3099
00003c  4356              MULS     r6,r2,r6              ;3099
00003e  b169              CBZ      r1,|L21.92|
000040  1e6a              SUBS     r2,r5,#1              ;3101
000042  1e49              SUBS     r1,r1,#1              ;3101
000044  fbb2f2f6          UDIV     r2,r2,r6              ;3101
000048  fbb1f3f6          UDIV     r3,r1,r6              ;3101
00004c  429a              CMP      r2,r3                 ;3101
00004e  d305              BCC      |L21.92|
000050  1e70              SUBS     r0,r6,#1              ;3102
000052  4381              BICS     r1,r1,r0              ;3102
000054  1a6d              SUBS     r5,r5,r1              ;3103
000056  60a1              STR      r1,[r4,#8]            ;3104
000058  6961              LDR      r1,[r4,#0x14]         ;3104
00005a  e00b              B        |L21.116|
                  |L21.92|
00005c  6921              LDR      r1,[r4,#0x10]         ;3108
00005e  b941              CBNZ     r1,|L21.114|
000060  2100              MOVS     r1,#0                 ;3109
000062  f7fffffe          BL       create_chain
000066  4601              MOV      r1,r0                 ;3109
000068  2801              CMP      r0,#1
00006a  d04b              BEQ      |L21.260|
;;;3111   					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
00006c  1c48              ADDS     r0,r1,#1
00006e  d05a              BEQ      |L21.294|
;;;3112   					fp->sclust = clst;
000070  6121              STR      r1,[r4,#0x10]
                  |L21.114|
;;;3113   				}
;;;3114   #endif
;;;3115   				fp->clust = clst;
000072  6161              STR      r1,[r4,#0x14]
                  |L21.116|
;;;3116   			}
;;;3117   			if (clst != 0) {
000074  b9d1              CBNZ     r1,|L21.172|
                  |L21.118|
000076  e02d              B        |L21.212|
                  |L21.120|
;;;3118   				while (ofs > bcs) {						/* Cluster following loop */
;;;3119   #if !_FS_READONLY
;;;3120   					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
000078  79a0              LDRB     r0,[r4,#6]
00007a  0780              LSLS     r0,r0,#30
00007c  6820              LDR      r0,[r4,#0]
00007e  d505              BPL      |L21.140|
;;;3121   						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
000080  f7fffffe          BL       create_chain
000084  0001              MOVS     r1,r0
;;;3122   						if (clst == 0) {				/* When disk gets full, clip file size */
000086  d104              BNE      |L21.146|
;;;3123   							ofs = bcs; break;
000088  4635              MOV      r5,r6
00008a  e011              B        |L21.176|
                  |L21.140|
;;;3124   						}
;;;3125   					} else
;;;3126   #endif
;;;3127   						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
00008c  f7fffffe          BL       get_fat
000090  4601              MOV      r1,r0
                  |L21.146|
;;;3128   					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
000092  1c48              ADDS     r0,r1,#1
000094  d047              BEQ      |L21.294|
;;;3129   					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
000096  2901              CMP      r1,#1
000098  d934              BLS      |L21.260|
00009a  6820              LDR      r0,[r4,#0]
00009c  6980              LDR      r0,[r0,#0x18]
00009e  4288              CMP      r0,r1
0000a0  d930              BLS      |L21.260|
;;;3130   					fp->clust = clst;
;;;3131   					fp->fptr += bcs;
0000a2  6161              STR      r1,[r4,#0x14]
0000a4  68a0              LDR      r0,[r4,#8]
;;;3132   					ofs -= bcs;
0000a6  1bad              SUBS     r5,r5,r6
0000a8  4430              ADD      r0,r0,r6              ;3131
0000aa  60a0              STR      r0,[r4,#8]
                  |L21.172|
0000ac  42b5              CMP      r5,r6                 ;3118
0000ae  d8e3              BHI      |L21.120|
                  |L21.176|
;;;3133   				}
;;;3134   				fp->fptr += ofs;
0000b0  68a0              LDR      r0,[r4,#8]
0000b2  4428              ADD      r0,r0,r5
;;;3135   				if (ofs % SS(fp->fs)) {
0000b4  60a0              STR      r0,[r4,#8]
0000b6  6820              LDR      r0,[r4,#0]
0000b8  8942              LDRH     r2,[r0,#0xa]
0000ba  fbb5f3f2          UDIV     r3,r5,r2
0000be  fb025213          MLS      r2,r2,r3,r5
0000c2  b13a              CBZ      r2,|L21.212|
;;;3136   					nsect = clust2sect(fp->fs, clst);	/* Current sector */
0000c4  f7fffffe          BL       clust2sect
;;;3137   					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
0000c8  b1e0              CBZ      r0,|L21.260|
;;;3138   					nsect += ofs / SS(fp->fs);
0000ca  6821              LDR      r1,[r4,#0]
0000cc  8949              LDRH     r1,[r1,#0xa]
0000ce  fbb5f1f1          UDIV     r1,r5,r1
0000d2  180f              ADDS     r7,r1,r0
                  |L21.212|
;;;3139   				}
;;;3140   			}
;;;3141   		}
;;;3142   		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
0000d4  6820              LDR      r0,[r4,#0]
0000d6  68a1              LDR      r1,[r4,#8]
0000d8  8942              LDRH     r2,[r0,#0xa]
0000da  fbb1f3f2          UDIV     r3,r1,r2
0000de  fb021113          MLS      r1,r2,r3,r1
0000e2  b329              CBZ      r1,|L21.304|
0000e4  69a2              LDR      r2,[r4,#0x18]
0000e6  42ba              CMP      r2,r7
0000e8  d022              BEQ      |L21.304|
;;;3143   #if !_FS_TINY
;;;3144   #if !_FS_READONLY
;;;3145   			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
0000ea  79a1              LDRB     r1,[r4,#6]
;;;3146   				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
0000ec  f1040524          ADD      r5,r4,#0x24
0000f0  0649              LSLS     r1,r1,#25             ;3145
0000f2  d510              BPL      |L21.278|
0000f4  7840              LDRB     r0,[r0,#1]
0000f6  2301              MOVS     r3,#1
0000f8  4629              MOV      r1,r5
0000fa  f7fffffe          BL       disk_write
0000fe  b990              CBNZ     r0,|L21.294|
000100  e005              B        |L21.270|
000102  e002              B        |L21.266|
                  |L21.260|
000104  f884a007          STRB     r10,[r4,#7]           ;3137
000108  2002              MOVS     r0,#2                 ;3137
                  |L21.266|
;;;3147   					ABORT(fp->fs, FR_DISK_ERR);
;;;3148   				fp->flag &= ~FA__DIRTY;
;;;3149   			}
;;;3150   #endif
;;;3151   			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
;;;3152   				ABORT(fp->fs, FR_DISK_ERR);
;;;3153   #endif
;;;3154   			fp->dsect = nsect;
;;;3155   		}
;;;3156   #if !_FS_READONLY
;;;3157   		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
;;;3158   			fp->fsize = fp->fptr;
;;;3159   			fp->flag |= FA__WRITTEN;
;;;3160   		}
;;;3161   #endif
;;;3162   	}
;;;3163   
;;;3164   	LEAVE_FF(fp->fs, res);
;;;3165   }
00010a  e8bd87f0          POP      {r4-r10,pc}
                  |L21.270|
00010e  79a0              LDRB     r0,[r4,#6]            ;3148
000110  f0200040          BIC      r0,r0,#0x40           ;3148
000114  71a0              STRB     r0,[r4,#6]            ;3148
                  |L21.278|
000116  6820              LDR      r0,[r4,#0]            ;3151
000118  2301              MOVS     r3,#1                 ;3151
00011a  463a              MOV      r2,r7                 ;3151
00011c  7840              LDRB     r0,[r0,#1]            ;3151
00011e  4629              MOV      r1,r5                 ;3151
000120  f7fffffe          BL       disk_read
000124  b118              CBZ      r0,|L21.302|
                  |L21.294|
000126  f8849007          STRB     r9,[r4,#7]            ;3152
00012a  2001              MOVS     r0,#1                 ;3152
00012c  e7ed              B        |L21.266|
                  |L21.302|
00012e  61a7              STR      r7,[r4,#0x18]         ;3154
                  |L21.304|
000130  e9d40102          LDRD     r0,r1,[r4,#8]         ;3154
000134  4288              CMP      r0,r1                 ;3157
000136  d904              BLS      |L21.322|
000138  60e0              STR      r0,[r4,#0xc]          ;3159
00013a  79a0              LDRB     r0,[r4,#6]            ;3159
00013c  f0400020          ORR      r0,r0,#0x20           ;3159
000140  71a0              STRB     r0,[r4,#6]            ;3159
                  |L21.322|
000142  4640              MOV      r0,r8                 ;3164
000144  e7e1              B        |L21.266|
;;;3166   
                          ENDP


                          AREA ||i.f_mkdir||, CODE, READONLY, ALIGN=1

                  f_mkdir PROC
;;;3529   
;;;3530   FRESULT f_mkdir (
000000  e92d4ff1          PUSH     {r0,r4-r11,lr}
;;;3531   	const TCHAR* path		/* Pointer to the directory path */
;;;3532   )
;;;3533   {
000004  f5ad7d0e          SUB      sp,sp,#0x238
;;;3534   	FRESULT res;
;;;3535   	DIR dj;
;;;3536   	BYTE *dir, n;
;;;3537   	DWORD dsc, dcl, pcl, tm = GET_FATTIME();
000008  f7fffffe          BL       get_fattime
00000c  4606              MOV      r6,r0
;;;3538   	DEF_NAMEBUF;
;;;3539   
;;;3540   
;;;3541   	/* Get logical drive number */
;;;3542   	res = find_volume(&dj.fs, &path, 1);
00000e  2201              MOVS     r2,#1
000010  a98e              ADD      r1,sp,#0x238
000012  a880              ADD      r0,sp,#0x200
000014  f7fffffe          BL       find_volume
000018  0004              MOVS     r4,r0
;;;3543   	if (res == FR_OK) {
00001a  d10b              BNE      |L22.52|
;;;3544   		INIT_BUF(dj);
00001c  a88b              ADD      r0,sp,#0x22c
00001e  9086              STR      r0,[sp,#0x218]
000020  f8cdd21c          STR      sp,[sp,#0x21c]
;;;3545   		res = follow_path(&dj, path);			/* Follow the file path */
000024  a880              ADD      r0,sp,#0x200
000026  998e              LDR      r1,[sp,#0x238]
000028  f7fffffe          BL       follow_path
00002c  0004              MOVS     r4,r0
;;;3546   		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
00002e  d002              BEQ      |L22.54|
;;;3547   		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT))
000030  2c04              CMP      r4,#4
000032  d002              BEQ      |L22.58|
                  |L22.52|
000034  e09a              B        |L22.364|
                  |L22.54|
000036  2408              MOVS     r4,#8                 ;3546
000038  e098              B        |L22.364|
                  |L22.58|
00003a  9886              LDR      r0,[sp,#0x218]
00003c  7ac0              LDRB     r0,[r0,#0xb]
00003e  0680              LSLS     r0,r0,#26
000040  d501              BPL      |L22.70|
;;;3548   			res = FR_INVALID_NAME;
000042  2406              MOVS     r4,#6
000044  e092              B        |L22.364|
                  |L22.70|
;;;3549   		if (res == FR_NO_FILE) {				/* Can create a new directory */
;;;3550   			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
000046  2100              MOVS     r1,#0
000048  9880              LDR      r0,[sp,#0x200]
00004a  f7fffffe          BL       create_chain
00004e  ea5f0800          MOVS     r8,r0
;;;3551   			res = FR_OK;
000052  f04f0400          MOV      r4,#0
;;;3552   			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
000056  d003              BEQ      |L22.96|
;;;3553   			if (dcl == 1) res = FR_INT_ERR;
000058  f1b80f01          CMP      r8,#1
00005c  d002              BEQ      |L22.100|
00005e  e002              B        |L22.102|
                  |L22.96|
000060  2407              MOVS     r4,#7                 ;3552
000062  e000              B        |L22.102|
                  |L22.100|
000064  2402              MOVS     r4,#2
                  |L22.102|
;;;3554   			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
000066  f1b83fff          CMP      r8,#0xffffffff
00006a  d001              BEQ      |L22.112|
;;;3555   			if (res == FR_OK)					/* Flush FAT */
00006c  b114              CBZ      r4,|L22.116|
00006e  e063              B        |L22.312|
                  |L22.112|
000070  2401              MOVS     r4,#1                 ;3554
000072  e061              B        |L22.312|
                  |L22.116|
;;;3556   				res = sync_window(dj.fs);
000074  9880              LDR      r0,[sp,#0x200]
000076  f7fffffe          BL       sync_window
00007a  0004              MOVS     r4,r0
00007c  d15c              BNE      |L22.312|
;;;3557   			if (res == FR_OK) {					/* Initialize the new directory table */
;;;3558   				dsc = clust2sect(dj.fs, dcl);
00007e  4641              MOV      r1,r8
000080  9880              LDR      r0,[sp,#0x200]
000082  f7fffffe          BL       clust2sect
;;;3559   				dir = dj.fs->win;
;;;3560   				mem_set(dir, 0, SS(dj.fs));
000086  9d80              LDR      r5,[sp,#0x200]
000088  4607              MOV      r7,r0                 ;3558
00008a  2100              MOVS     r1,#0
00008c  896a              LDRH     r2,[r5,#0xa]
00008e  3534              ADDS     r5,r5,#0x34
000090  4628              MOV      r0,r5
000092  f7fffffe          BL       mem_set
;;;3561   				mem_set(dir+DIR_Name, ' ', 11);	/* Create "." entry */
000096  220b              MOVS     r2,#0xb
000098  2120              MOVS     r1,#0x20
00009a  4628              MOV      r0,r5
00009c  f7fffffe          BL       mem_set
;;;3562   				dir[DIR_Name] = '.';
0000a0  242e              MOVS     r4,#0x2e
0000a2  702c              STRB     r4,[r5,#0]
;;;3563   				dir[DIR_Attr] = AM_DIR;
0000a4  2010              MOVS     r0,#0x10
0000a6  72e8              STRB     r0,[r5,#0xb]
;;;3564   				ST_DWORD(dir+DIR_WrtTime, tm);
0000a8  b2f0              UXTB     r0,r6
0000aa  908a              STR      r0,[sp,#0x228]
0000ac  75a8              STRB     r0,[r5,#0x16]
0000ae  f3c62007          UBFX     r0,r6,#8,#8
0000b2  9089              STR      r0,[sp,#0x224]
0000b4  75e8              STRB     r0,[r5,#0x17]
0000b6  f3c64b07          UBFX     r11,r6,#16,#8
0000ba  f885b018          STRB     r11,[r5,#0x18]
0000be  ea4f6a16          LSR      r10,r6,#24
0000c2  f885a019          STRB     r10,[r5,#0x19]
;;;3565   				st_clust(dir, dcl);
0000c6  4641              MOV      r1,r8
0000c8  4628              MOV      r0,r5
0000ca  f7fffffe          BL       st_clust
;;;3566   				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
0000ce  f1050020          ADD      r0,r5,#0x20
0000d2  2220              MOVS     r2,#0x20
0000d4  4629              MOV      r1,r5
0000d6  4606              MOV      r6,r0
0000d8  f7fffffe          BL       mem_cpy
;;;3567   				dir[SZ_DIR+1] = '.'; pcl = dj.sclust;
0000dc  f8854021          STRB     r4,[r5,#0x21]
;;;3568   				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
0000e0  9880              LDR      r0,[sp,#0x200]
0000e2  9982              LDR      r1,[sp,#0x208]
0000e4  7800              LDRB     r0,[r0,#0]
0000e6  2803              CMP      r0,#3
0000e8  d104              BNE      |L22.244|
0000ea  9880              LDR      r0,[sp,#0x200]
0000ec  6a80              LDR      r0,[r0,#0x28]
0000ee  4288              CMP      r0,r1
0000f0  d100              BNE      |L22.244|
;;;3569   					pcl = 0;
0000f2  2100              MOVS     r1,#0
                  |L22.244|
0000f4  4630              MOV      r0,r6
;;;3570   				st_clust(dir+SZ_DIR, pcl);
0000f6  f7fffffe          BL       st_clust
;;;3571   				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
0000fa  9880              LDR      r0,[sp,#0x200]
0000fc  f04f0901          MOV      r9,#1                 ;3542
000100  7886              LDRB     r6,[r0,#2]
000102  e012              B        |L22.298|
                  |L22.260|
;;;3572   					dj.fs->winsect = dsc++;
000104  9880              LDR      r0,[sp,#0x200]
;;;3573   					dj.fs->wflag = 1;
000106  6307              STR      r7,[r0,#0x30]
000108  9980              LDR      r1,[sp,#0x200]
;;;3574   					res = sync_window(dj.fs);
00010a  1c7f              ADDS     r7,r7,#1
00010c  f8819004          STRB     r9,[r1,#4]            ;3573
000110  9880              LDR      r0,[sp,#0x200]
000112  f7fffffe          BL       sync_window
000116  0004              MOVS     r4,r0
;;;3575   					if (res != FR_OK) break;
000118  d10e              BNE      |L22.312|
;;;3576   					mem_set(dir, 0, SS(dj.fs));
00011a  9880              LDR      r0,[sp,#0x200]
00011c  2100              MOVS     r1,#0
00011e  8942              LDRH     r2,[r0,#0xa]
000120  4628              MOV      r0,r5
000122  f7fffffe          BL       mem_set
000126  1e76              SUBS     r6,r6,#1
000128  b2f6              UXTB     r6,r6                 ;3571
                  |L22.298|
00012a  2e00              CMP      r6,#0                 ;3571
00012c  d1ea              BNE      |L22.260|
;;;3577   				}
;;;3578   			}
;;;3579   			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
00012e  a880              ADD      r0,sp,#0x200
000130  f7fffffe          BL       dir_register
000134  0004              MOVS     r4,r0
000136  d004              BEQ      |L22.322|
                  |L22.312|
;;;3580   			if (res != FR_OK) {
;;;3581   				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
000138  4641              MOV      r1,r8
00013a  9880              LDR      r0,[sp,#0x200]
00013c  f7fffffe          BL       remove_chain
000140  e014              B        |L22.364|
                  |L22.322|
;;;3582   			} else {
;;;3583   				dir = dj.dir;
;;;3584   				dir[DIR_Attr] = AM_DIR;				/* Attribute */
000142  9885              LDR      r0,[sp,#0x214]
000144  2110              MOVS     r1,#0x10
000146  72c1              STRB     r1,[r0,#0xb]
;;;3585   				ST_DWORD(dir+DIR_WrtTime, tm);		/* Created time */
000148  998a              LDR      r1,[sp,#0x228]
00014a  7581              STRB     r1,[r0,#0x16]
00014c  9989              LDR      r1,[sp,#0x224]
00014e  75c1              STRB     r1,[r0,#0x17]
000150  f880b018          STRB     r11,[r0,#0x18]
000154  f880a019          STRB     r10,[r0,#0x19]
;;;3586   				st_clust(dir, dcl);					/* Table start cluster */
000158  4641              MOV      r1,r8
00015a  f7fffffe          BL       st_clust
;;;3587   				dj.fs->wflag = 1;
00015e  9980              LDR      r1,[sp,#0x200]
000160  f8819004          STRB     r9,[r1,#4]
;;;3588   				res = sync_fs(dj.fs);
000164  9880              LDR      r0,[sp,#0x200]
000166  f7fffffe          BL       sync_fs
00016a  4604              MOV      r4,r0
                  |L22.364|
;;;3589   			}
;;;3590   		}
;;;3591   		FREE_BUF();
;;;3592   	}
;;;3593   
;;;3594   	LEAVE_FF(dj.fs, res);
;;;3595   }
00016c  f50d7d0f          ADD      sp,sp,#0x23c
000170  4620              MOV      r0,r4                 ;3594
000172  e8bd8ff0          POP      {r4-r11,pc}
;;;3596   
                          ENDP


                          AREA ||i.f_mkfs||, CODE, READONLY, ALIGN=2

                  f_mkfs PROC
;;;3994   
;;;3995   FRESULT f_mkfs (
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;3996   	const TCHAR* path,	/* Logical drive number */
;;;3997   	BYTE sfd,			/* Partitioning rule 0:FDISK, 1:SFD */
;;;3998   	UINT au				/* Size of allocation unit in unit of byte or sector */
;;;3999   )
;;;4000   {
000004  b086              SUB      sp,sp,#0x18
000006  4690              MOV      r8,r2
;;;4001   
;;;4002   	static const WORD vst[] = { 1024,   512,  256,  128,   64,    32,   16,    8,    4,    2,   0};
;;;4003   	static const WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
;;;4004   	int vol;
;;;4005   	BYTE fmt, md, sys, *tbl, pdrv, part;
;;;4006   	DWORD n_clst, vs, n, wsect;
;;;4007   	UINT i;
;;;4008   	DWORD b_vol, b_fat, b_dir, b_data;	/* LBA */
;;;4009   	DWORD n_vol, n_rsv, n_fat, n_dir;	/* Size */
;;;4010   	FATFS *fs;
;;;4011   	DSTATUS stat;
;;;4012   	/* Check mounted drive and clear work area */
;;;4013   	if (sfd > 1) return FR_INVALID_PARAMETER;
000008  9807              LDR      r0,[sp,#0x1c]
00000a  2801              CMP      r0,#1
00000c  d903              BLS      |L23.22|
00000e  2013              MOVS     r0,#0x13
                  |L23.16|
;;;4014   	vol = get_ldnumber(&path);
;;;4015   	if (vol < 0) return FR_INVALID_DRIVE;
;;;4016   	fs = FatFs[vol];
;;;4017   	if (!fs) return FR_NOT_ENABLED;
;;;4018   	fs->fs_type = 0;
;;;4019   	pdrv = LD2PD(vol);	/* Physical drive */
;;;4020   	part = LD2PT(vol);	/* Partition (0:auto detect, 1-4:get from partition table)*/
;;;4021   
;;;4022   	/* Get disk statics */
;;;4023   	stat = disk_initialize(pdrv);
;;;4024   
;;;4025   	if (stat & STA_NOINIT) return FR_NOT_READY;
;;;4026   	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
;;;4027   #if _MAX_SS != _MIN_SS		/* Get disk sector size */
;;;4028   	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS || SS(fs) < _MIN_SS)
;;;4029   		return FR_DISK_ERR;
;;;4030   #endif
;;;4031   	if (_MULTI_PARTITION && part) {
;;;4032   		/* Get partition information from partition table in the MBR */
;;;4033   		if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
;;;4034   		if (LD_WORD(fs->win+BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
;;;4035   		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
;;;4036   		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
;;;4037   		b_vol = LD_DWORD(tbl+8);	/* Volume start sector */
;;;4038   		n_vol = LD_DWORD(tbl+12);	/* Volume size */
;;;4039   	} else {
;;;4040   		/* Create a partition in this function */
;;;4041   		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
;;;4042   			return FR_DISK_ERR;
;;;4043   		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
;;;4044   		n_vol -= b_vol;				/* Volume size */
;;;4045   	}
;;;4046   
;;;4047   	if (au & (au - 1)) au = 0;
;;;4048   	if (!au) {						/* AU auto selection */
;;;4049   		vs = n_vol / (2000 / (SS(fs) / 512));
;;;4050   		for (i = 0; vs < vst[i]; i++) ;
;;;4051   		au = cst[i];
;;;4052   	}
;;;4053   	if (au >= _MIN_SS) au /= SS(fs);	/* Number of sectors per cluster */
;;;4054   	if (!au) au = 1;
;;;4055   	if (au > 128) au = 128;
;;;4056   
;;;4057   	/* Pre-compute number of clusters and FAT sub-type */
;;;4058   	n_clst = n_vol / au;
;;;4059   	fmt = FS_FAT12;
;;;4060   	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
;;;4061   	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
;;;4062   
;;;4063   	/* Determine offset and size of FAT structure */
;;;4064   	if (fmt == FS_FAT32) {
;;;4065   		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
;;;4066   		n_rsv = 32;
;;;4067   		n_dir = 0;
;;;4068   	} else {
;;;4069   		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
;;;4070   		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
;;;4071   		n_rsv = 1;
;;;4072   		n_dir = (DWORD)N_ROOTDIR * SZ_DIR / SS(fs);
;;;4073   	}
;;;4074   	b_fat = b_vol + n_rsv;				/* FAT area start sector */
;;;4075   	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
;;;4076   	b_data = b_dir + n_dir;				/* Data area start sector */
;;;4077   	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
;;;4078   
;;;4079   	/* Align data start sector to erase block boundary (for flash memory media) */
;;;4080   	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
;;;4081   	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
;;;4082   	n = (n - b_data) / N_FATS;
;;;4083   	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
;;;4084   		n_rsv += n;
;;;4085   		b_fat += n;
;;;4086   	} else {					/* FAT12/16: Expand FAT size */
;;;4087   		n_fat += n;
;;;4088   	}
;;;4089   
;;;4090   	/* Determine number of clusters and final check of validity of the FAT sub-type */
;;;4091   	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
;;;4092   	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
;;;4093   		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
;;;4094   		return FR_MKFS_ABORTED;
;;;4095   
;;;4096   	/* Determine system ID in the partition table */
;;;4097   	if (fmt == FS_FAT32) {
;;;4098   		sys = 0x0C;		/* FAT32X */
;;;4099   	} else {
;;;4100   		if (fmt == FS_FAT12 && n_vol < 0x10000) {
;;;4101   			sys = 0x01;	/* FAT12(<65536) */
;;;4102   		} else {
;;;4103   			sys = (n_vol < 0x10000) ? 0x04 : 0x06;	/* FAT16(<65536) : FAT12/16(>=65536) */
;;;4104   		}
;;;4105   	}
;;;4106   
;;;4107   	if (_MULTI_PARTITION && part) {
;;;4108   		/* Update system ID in the partition table */
;;;4109   		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
;;;4110   		tbl[4] = sys;
;;;4111   		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to teh MBR */
;;;4112   			return FR_DISK_ERR;
;;;4113   		md = 0xF8;
;;;4114   	} else {
;;;4115   		if (sfd) {	/* No partition table (SFD) */
;;;4116   			md = 0xF0;
;;;4117   		} else {	/* Create partition table (FDISK) */
;;;4118   			mem_set(fs->win, 0, SS(fs));
;;;4119   			tbl = fs->win+MBR_Table;	/* Create partition table for single partition in the drive */
;;;4120   			tbl[1] = 1;						/* Partition start head */
;;;4121   			tbl[2] = 1;						/* Partition start sector */
;;;4122   			tbl[3] = 0;						/* Partition start cylinder */
;;;4123   			tbl[4] = sys;					/* System type */
;;;4124   			tbl[5] = 254;					/* Partition end head */
;;;4125   			n = (b_vol + n_vol) / 63 / 255;
;;;4126   			tbl[6] = (BYTE)(n >> 2 | 63);	/* Partition end sector */
;;;4127   			tbl[7] = (BYTE)n;				/* End cylinder */
;;;4128   			ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
;;;4129   			ST_DWORD(tbl+12, n_vol);		/* Partition size in LBA */
;;;4130   			ST_WORD(fs->win+BS_55AA, 0xAA55);	/* MBR signature */
;;;4131   			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR */
;;;4132   				return FR_DISK_ERR;
;;;4133   			md = 0xF8;
;;;4134   		}
;;;4135   	}
;;;4136   
;;;4137   	/* Create BPB in the VBR */
;;;4138   	tbl = fs->win;							/* Clear sector */
;;;4139   	mem_set(tbl, 0, SS(fs));
;;;4140   	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
;;;4141   	i = SS(fs);								/* Sector size */
;;;4142   	ST_WORD(tbl+BPB_BytsPerSec, i);
;;;4143   	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
;;;4144   	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);		/* Reserved sectors */
;;;4145   	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
;;;4146   	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of root directory entries */
;;;4147   	ST_WORD(tbl+BPB_RootEntCnt, i);
;;;4148   	if (n_vol < 0x10000) {					/* Number of total sectors */
;;;4149   		ST_WORD(tbl+BPB_TotSec16, n_vol);
;;;4150   	} else {
;;;4151   		ST_DWORD(tbl+BPB_TotSec32, n_vol);
;;;4152   	}
;;;4153   	tbl[BPB_Media] = md;					/* Media descriptor */
;;;4154   	ST_WORD(tbl+BPB_SecPerTrk, 63);			/* Number of sectors per track */
;;;4155   	ST_WORD(tbl+BPB_NumHeads, 255);			/* Number of heads */
;;;4156   	ST_DWORD(tbl+BPB_HiddSec, b_vol);		/* Hidden sectors */
;;;4157   	n = GET_FATTIME();						/* Use current time as VSN */
;;;4158   	if (fmt == FS_FAT32) {
;;;4159   		ST_DWORD(tbl+BS_VolID32, n);		/* VSN */
;;;4160   		ST_DWORD(tbl+BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
;;;4161   		ST_DWORD(tbl+BPB_RootClus, 2);		/* Root directory start cluster (2) */
;;;4162   		ST_WORD(tbl+BPB_FSInfo, 1);			/* FSINFO record offset (VBR+1) */
;;;4163   		ST_WORD(tbl+BPB_BkBootSec, 6);		/* Backup boot record offset (VBR+6) */
;;;4164   		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
;;;4165   		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
;;;4166   		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
;;;4167   	} else {
;;;4168   		ST_DWORD(tbl+BS_VolID, n);			/* VSN */
;;;4169   		ST_WORD(tbl+BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
;;;4170   		tbl[BS_DrvNum] = 0x80;				/* Drive number */
;;;4171   		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
;;;4172   		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
;;;4173   	}
;;;4174   	ST_WORD(tbl+BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
;;;4175   	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
;;;4176   		return FR_DISK_ERR;
;;;4177   	if (fmt == FS_FAT32)					/* Write backup VBR if needed (VBR+6) */
;;;4178   		disk_write(pdrv, tbl, b_vol + 6, 1);
;;;4179   
;;;4180   	/* Initialize FAT area */
;;;4181   	wsect = b_fat;
;;;4182   	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
;;;4183   		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
;;;4184   		n = md;								/* Media descriptor byte */
;;;4185   		if (fmt != FS_FAT32) {
;;;4186   			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
;;;4187   			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT12/16) */
;;;4188   		} else {
;;;4189   			n |= 0xFFFFFF00;
;;;4190   			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT32) */
;;;4191   			ST_DWORD(tbl+4, 0xFFFFFFFF);
;;;4192   			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
;;;4193   		}
;;;4194   		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
;;;4195   			return FR_DISK_ERR;
;;;4196   		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
;;;4197   		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
;;;4198   			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
;;;4199   				return FR_DISK_ERR;
;;;4200   		}
;;;4201   	}
;;;4202   
;;;4203   	/* Initialize root directory */
;;;4204   	i = (fmt == FS_FAT32) ? au : (UINT)n_dir;
;;;4205   	do {
;;;4206   		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
;;;4207   			return FR_DISK_ERR;
;;;4208   	} while (--i);
;;;4209   
;;;4210   #if _USE_TRIM	/* Erase data area if needed */
;;;4211   	{
;;;4212   		DWORD eb[2];
;;;4213   
;;;4214   		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
;;;4215   		disk_ioctl(pdrv, CTRL_TRIM, eb);
;;;4216   	}
;;;4217   #endif
;;;4218   
;;;4219   	/* Create FSINFO if needed */
;;;4220   	if (fmt == FS_FAT32) {
;;;4221   		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
;;;4222   		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
;;;4223   		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
;;;4224   		ST_DWORD(tbl+FSI_Nxt_Free, 2);				/* Last allocated cluster# */
;;;4225   		ST_WORD(tbl+BS_55AA, 0xAA55);
;;;4226   		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR+1) */
;;;4227   		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR+7) */
;;;4228   	}
;;;4229   
;;;4230   	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
;;;4231   }
000010  b009              ADD      sp,sp,#0x24
000012  e8bd8ff0          POP      {r4-r11,pc}
                  |L23.22|
000016  a806              ADD      r0,sp,#0x18           ;4014
000018  f7fffffe          BL       get_ldnumber
00001c  2800              CMP      r0,#0                 ;4015
00001e  da01              BGE      |L23.36|
000020  200b              MOVS     r0,#0xb               ;4015
                  |L23.34|
000022  e7f5              B        |L23.16|
                  |L23.36|
000024  49f8              LDR      r1,|L23.1032|
000026  f8516020          LDR      r6,[r1,r0,LSL #2]     ;4016
00002a  b14e              CBZ      r6,|L23.64|
00002c  2100              MOVS     r1,#0                 ;4018
00002e  7031              STRB     r1,[r6,#0]            ;4018
000030  b2c0              UXTB     r0,r0                 ;4019
000032  9002              STR      r0,[sp,#8]            ;4023
000034  f7fffffe          BL       disk_initialize
000038  07c1              LSLS     r1,r0,#31             ;4025
00003a  d003              BEQ      |L23.68|
00003c  2003              MOVS     r0,#3                 ;4025
00003e  e7e7              B        |L23.16|
                  |L23.64|
000040  200c              MOVS     r0,#0xc               ;4017
000042  e7e5              B        |L23.16|
                  |L23.68|
000044  0740              LSLS     r0,r0,#29             ;4026
000046  d501              BPL      |L23.76|
000048  200a              MOVS     r0,#0xa               ;4026
00004a  e7e1              B        |L23.16|
                  |L23.76|
00004c  f106020a          ADD      r2,r6,#0xa            ;4028
000050  2102              MOVS     r1,#2                 ;4028
000052  9802              LDR      r0,[sp,#8]            ;4028
000054  f7fffffe          BL       disk_ioctl
000058  2800              CMP      r0,#0                 ;4028
                  |L23.90|
00005a  d176              BNE      |L23.330|
00005c  8970              LDRH     r0,[r6,#0xa]          ;4028
00005e  f5b05f80          CMP      r0,#0x1000            ;4028
000062  d872              BHI      |L23.330|
000064  f5b07f00          CMP      r0,#0x200             ;4028
                  |L23.104|
000068  d36f              BCC      |L23.330|
00006a  aa03              ADD      r2,sp,#0xc            ;4041
00006c  2101              MOVS     r1,#1                 ;4041
00006e  9802              LDR      r0,[sp,#8]            ;4041
000070  f7fffffe          BL       disk_ioctl
000074  2800              CMP      r0,#0                 ;4041
000076  d1f0              BNE      |L23.90|
000078  9803              LDR      r0,[sp,#0xc]          ;4041
00007a  2880              CMP      r0,#0x80              ;4041
00007c  d3f4              BCC      |L23.104|
00007e  9907              LDR      r1,[sp,#0x1c]         ;4043
000080  b109              CBZ      r1,|L23.134|
000082  2100              MOVS     r1,#0                 ;4043
000084  e000              B        |L23.136|
                  |L23.134|
000086  213f              MOVS     r1,#0x3f              ;4043
                  |L23.136|
000088  468a              MOV      r10,r1                ;4043
00008a  eba0010a          SUB      r1,r0,r10             ;4044
00008e  f1a80201          SUB      r2,r8,#1              ;4047
000092  ea180f02          TST      r8,r2                 ;4047
000096  9103              STR      r1,[sp,#0xc]          ;4044
000098  d102              BNE      |L23.160|
00009a  f1b80f00          CMP      r8,#0                 ;4048
00009e  d113              BNE      |L23.200|
                  |L23.160|
0000a0  8970              LDRH     r0,[r6,#0xa]          ;4049
0000a2  f44f62fa          MOV      r2,#0x7d0             ;4049
0000a6  0a40              LSRS     r0,r0,#9              ;4049
0000a8  fbb2f0f0          UDIV     r0,r2,r0              ;4049
0000ac  fbb1f2f0          UDIV     r2,r1,r0              ;4049
0000b0  2000              MOVS     r0,#0                 ;4050
0000b2  4bd6              LDR      r3,|L23.1036|
0000b4  e000              B        |L23.184|
                  |L23.182|
0000b6  1c40              ADDS     r0,r0,#1              ;4050
                  |L23.184|
0000b8  f8335010          LDRH     r5,[r3,r0,LSL #1]     ;4050
0000bc  4295              CMP      r5,r2                 ;4050
0000be  d8fa              BHI      |L23.182|
0000c0  4ad2              LDR      r2,|L23.1036|
0000c2  3216              ADDS     r2,r2,#0x16           ;4051
0000c4  f8328010          LDRH     r8,[r2,r0,LSL #1]     ;4051
                  |L23.200|
0000c8  f5b87f00          CMP      r8,#0x200             ;4053
0000cc  d302              BCC      |L23.212|
0000ce  8972              LDRH     r2,[r6,#0xa]          ;4053
0000d0  fbb8f8f2          UDIV     r8,r8,r2              ;4053
                  |L23.212|
0000d4  f1b80f00          CMP      r8,#0                 ;4054
0000d8  d012              BEQ      |L23.256|
0000da  f1b80f80          CMP      r8,#0x80              ;4055
0000de  d901              BLS      |L23.228|
0000e0  2080              MOVS     r0,#0x80              ;4055
                  |L23.226|
0000e2  4680              MOV      r8,r0                 ;4054
                  |L23.228|
0000e4  fbb1f0f8          UDIV     r0,r1,r8              ;4058
0000e8  2701              MOVS     r7,#1                 ;4059
0000ea  f64072f6          MOV      r2,#0xff6             ;4060
0000ee  4290              CMP      r0,r2                 ;4060
0000f0  d300              BCC      |L23.244|
0000f2  2702              MOVS     r7,#2                 ;4060
                  |L23.244|
0000f4  f64f72f6          MOV      r2,#0xfff6            ;4061
0000f8  4290              CMP      r0,r2                 ;4061
0000fa  d303              BCC      |L23.260|
0000fc  2703              MOVS     r7,#3                 ;4061
0000fe  e025              B        |L23.332|
                  |L23.256|
000100  2001              MOVS     r0,#1                 ;4054
000102  e7ee              B        |L23.226|
                  |L23.260|
000104  2f03              CMP      r7,#3                 ;4064
000106  d021              BEQ      |L23.332|
000108  2f01              CMP      r7,#1                 ;4069
00010a  d029              BEQ      |L23.352|
00010c  0042              LSLS     r2,r0,#1              ;4069
00010e  1d12              ADDS     r2,r2,#4              ;4069
                  |L23.272|
000110  8970              LDRH     r0,[r6,#0xa]          ;4070
000112  1e52              SUBS     r2,r2,#1              ;4070
000114  4402              ADD      r2,r2,r0              ;4070
000116  fbb2f9f0          UDIV     r9,r2,r0              ;4070
00011a  2501              MOVS     r5,#1                 ;4071
00011c  03aa              LSLS     r2,r5,#14             ;4072
00011e  fbb2f0f0          UDIV     r0,r2,r0              ;4072
                  |L23.290|
000122  9004              STR      r0,[sp,#0x10]         ;4075
000124  eb0a0b05          ADD      r11,r10,r5            ;4074
000128  9a04              LDR      r2,[sp,#0x10]         ;4076
00012a  eb0b0009          ADD      r0,r11,r9             ;4075
00012e  1884              ADDS     r4,r0,r2              ;4076
000130  eb040208          ADD      r2,r4,r8              ;4077
000134  eba2000a          SUB      r0,r2,r10             ;4077
000138  4288              CMP      r0,r1                 ;4077
00013a  d844              BHI      |L23.454|
00013c  466a              MOV      r2,sp                 ;4080
00013e  2103              MOVS     r1,#3                 ;4080
000140  9802              LDR      r0,[sp,#8]            ;4080
000142  f7fffffe          BL       disk_ioctl
000146  b9b0              CBNZ     r0,|L23.374|
000148  e010              B        |L23.364|
                  |L23.330|
00014a  e0ff              B        |L23.844|
                  |L23.332|
00014c  8972              LDRH     r2,[r6,#0xa]          ;4065
00014e  2307              MOVS     r3,#7                 ;4065
000150  eb030080          ADD      r0,r3,r0,LSL #2       ;4065
000154  4410              ADD      r0,r0,r2              ;4065
000156  fbb0f9f2          UDIV     r9,r0,r2              ;4065
00015a  2520              MOVS     r5,#0x20              ;4066
00015c  2000              MOVS     r0,#0                 ;4067
00015e  e7e0              B        |L23.290|
                  |L23.352|
000160  eb000040          ADD      r0,r0,r0,LSL #1       ;4069
000164  1c40              ADDS     r0,r0,#1              ;4069
000166  0842              LSRS     r2,r0,#1              ;4069
000168  1cd2              ADDS     r2,r2,#3              ;4069
00016a  e7d1              B        |L23.272|
                  |L23.364|
00016c  9800              LDR      r0,[sp,#0]            ;4080
00016e  b110              CBZ      r0,|L23.374|
000170  f5b04f00          CMP      r0,#0x8000            ;4080
000174  d901              BLS      |L23.378|
                  |L23.374|
000176  2001              MOVS     r0,#1                 ;4080
000178  9000              STR      r0,[sp,#0]            ;4080
                  |L23.378|
00017a  1821              ADDS     r1,r4,r0              ;4081
00017c  1e40              SUBS     r0,r0,#1              ;4081
00017e  1e49              SUBS     r1,r1,#1              ;4081
000180  4381              BICS     r1,r1,r0              ;4081
000182  1b08              SUBS     r0,r1,r4              ;4082
000184  9000              STR      r0,[sp,#0]            ;4083
000186  2f03              CMP      r7,#3                 ;4083
000188  d010              BEQ      |L23.428|
00018a  4481              ADD      r9,r9,r0              ;4087
                  |L23.396|
00018c  9803              LDR      r0,[sp,#0xc]          ;4091
00018e  9904              LDR      r1,[sp,#0x10]         ;4091
000190  1b42              SUBS     r2,r0,r5              ;4091
000192  eba20209          SUB      r2,r2,r9              ;4091
000196  1a52              SUBS     r2,r2,r1              ;4091
000198  fbb2f1f8          UDIV     r1,r2,r8              ;4091
00019c  9105              STR      r1,[sp,#0x14]         ;4092
00019e  2f02              CMP      r7,#2                 ;4092
0001a0  d007              BEQ      |L23.434|
0001a2  2f03              CMP      r7,#3                 ;4093
0001a4  d00a              BEQ      |L23.444|
0001a6  2f01              CMP      r7,#1                 ;4100
0001a8  d011              BEQ      |L23.462|
0001aa  e015              B        |L23.472|
                  |L23.428|
0001ac  4405              ADD      r5,r5,r0              ;4084
0001ae  4483              ADD      r11,r11,r0            ;4085
0001b0  e7ec              B        |L23.396|
                  |L23.434|
0001b2  f64072f6          MOV      r2,#0xff6             ;4092
0001b6  4291              CMP      r1,r2                 ;4092
0001b8  d305              BCC      |L23.454|
0001ba  e00d              B        |L23.472|
                  |L23.444|
0001bc  4608              MOV      r0,r1                 ;4093
0001be  f64f71f6          MOV      r1,#0xfff6            ;4093
0001c2  4288              CMP      r0,r1                 ;4093
0001c4  d201              BCS      |L23.458|
                  |L23.454|
0001c6  200e              MOVS     r0,#0xe               ;4094
0001c8  e722              B        |L23.16|
                  |L23.458|
0001ca  240c              MOVS     r4,#0xc               ;4098
0001cc  e00a              B        |L23.484|
                  |L23.462|
0001ce  f5b03f80          CMP      r0,#0x10000           ;4100
0001d2  d206              BCS      |L23.482|
0001d4  2401              MOVS     r4,#1                 ;4101
0001d6  e005              B        |L23.484|
                  |L23.472|
0001d8  f5b03f80          CMP      r0,#0x10000           ;4103
0001dc  d201              BCS      |L23.482|
0001de  2404              MOVS     r4,#4                 ;4103
0001e0  e000              B        |L23.484|
                  |L23.482|
0001e2  2406              MOVS     r4,#6                 ;4103
                  |L23.484|
0001e4  9807              LDR      r0,[sp,#0x1c]         ;4115
0001e6  b108              CBZ      r0,|L23.492|
0001e8  20f0              MOVS     r0,#0xf0              ;4116
0001ea  e038              B        |L23.606|
                  |L23.492|
0001ec  8972              LDRH     r2,[r6,#0xa]          ;4118
0001ee  f1060034          ADD      r0,r6,#0x34           ;4118
0001f2  2100              MOVS     r1,#0                 ;4118
0001f4  9001              STR      r0,[sp,#4]            ;4118
0001f6  f7fffffe          BL       mem_set
0001fa  f50670f9          ADD      r0,r6,#0x1f2          ;4119
0001fe  2101              MOVS     r1,#1                 ;4120
000200  7041              STRB     r1,[r0,#1]            ;4120
000202  7081              STRB     r1,[r0,#2]            ;4121
000204  2200              MOVS     r2,#0                 ;4122
000206  70c2              STRB     r2,[r0,#3]            ;4122
000208  7104              STRB     r4,[r0,#4]            ;4123
00020a  21fe              MOVS     r1,#0xfe              ;4124
00020c  7141              STRB     r1,[r0,#5]            ;4124
00020e  9b03              LDR      r3,[sp,#0xc]          ;4125
000210  eb0a0103          ADD      r1,r10,r3             ;4125
000214  f64363c1          MOV      r3,#0x3ec1            ;4125
000218  fbb1f1f3          UDIV     r1,r1,r3              ;4125
00021c  233f              MOVS     r3,#0x3f              ;4126
00021e  ea430491          ORR      r4,r3,r1,LSR #2       ;4126
000222  9100              STR      r1,[sp,#0]            ;4126
000224  7184              STRB     r4,[r0,#6]            ;4126
000226  71c1              STRB     r1,[r0,#7]            ;4127
000228  7203              STRB     r3,[r0,#8]            ;4128
00022a  7242              STRB     r2,[r0,#9]            ;4128
00022c  7282              STRB     r2,[r0,#0xa]          ;4128
00022e  72c2              STRB     r2,[r0,#0xb]          ;4128
000230  9903              LDR      r1,[sp,#0xc]          ;4129
000232  7301              STRB     r1,[r0,#0xc]          ;4129
000234  0a0a              LSRS     r2,r1,#8              ;4129
000236  7342              STRB     r2,[r0,#0xd]          ;4129
000238  0c0a              LSRS     r2,r1,#16             ;4129
00023a  7382              STRB     r2,[r0,#0xe]          ;4129
00023c  0e09              LSRS     r1,r1,#24             ;4129
00023e  73c1              STRB     r1,[r0,#0xf]          ;4129
000240  2055              MOVS     r0,#0x55              ;4130
000242  f8860232          STRB     r0,[r6,#0x232]        ;4130
000246  20aa              MOVS     r0,#0xaa              ;4130
000248  f8860233          STRB     r0,[r6,#0x233]        ;4130
00024c  e9dd1001          LDRD     r1,r0,[sp,#4]         ;4131
000250  2301              MOVS     r3,#1                 ;4131
000252  2200              MOVS     r2,#0                 ;4131
000254  f7fffffe          BL       disk_write
000258  2800              CMP      r0,#0                 ;4131
00025a  d177              BNE      |L23.844|
00025c  20f8              MOVS     r0,#0xf8              ;4133
                  |L23.606|
00025e  9001              STR      r0,[sp,#4]            ;4139
000260  f1060434          ADD      r4,r6,#0x34           ;4138
000264  8972              LDRH     r2,[r6,#0xa]          ;4139
000266  2100              MOVS     r1,#0                 ;4139
000268  4620              MOV      r0,r4                 ;4139
00026a  f7fffffe          BL       mem_set
00026e  220b              MOVS     r2,#0xb               ;4140
000270  a167              ADR      r1,|L23.1040|
000272  4620              MOV      r0,r4                 ;4140
000274  f7fffffe          BL       mem_cpy
000278  8970              LDRH     r0,[r6,#0xa]          ;4141
00027a  72e0              STRB     r0,[r4,#0xb]          ;4142
00027c  0a00              LSRS     r0,r0,#8              ;4142
00027e  7320              STRB     r0,[r4,#0xc]          ;4142
000280  f884800d          STRB     r8,[r4,#0xd]          ;4143
000284  73a5              STRB     r5,[r4,#0xe]          ;4144
000286  0a28              LSRS     r0,r5,#8              ;4144
000288  73e0              STRB     r0,[r4,#0xf]          ;4144
00028a  2001              MOVS     r0,#1                 ;4145
00028c  7420              STRB     r0,[r4,#0x10]         ;4145
00028e  2f03              CMP      r7,#3                 ;4146
000290  d00b              BEQ      |L23.682|
000292  0240              LSLS     r0,r0,#9              ;4146
                  |L23.660|
000294  7460              STRB     r0,[r4,#0x11]         ;4147
000296  0a00              LSRS     r0,r0,#8              ;4147
000298  74a0              STRB     r0,[r4,#0x12]         ;4147
00029a  9803              LDR      r0,[sp,#0xc]          ;4148
00029c  f5b03f80          CMP      r0,#0x10000           ;4148
0002a0  d205              BCS      |L23.686|
0002a2  74e0              STRB     r0,[r4,#0x13]         ;4149
0002a4  0a00              LSRS     r0,r0,#8              ;4149
0002a6  7520              STRB     r0,[r4,#0x14]         ;4149
0002a8  e00c              B        |L23.708|
                  |L23.682|
0002aa  2000              MOVS     r0,#0                 ;4146
0002ac  e7f2              B        |L23.660|
                  |L23.686|
0002ae  f8840020          STRB     r0,[r4,#0x20]         ;4151
0002b2  0a01              LSRS     r1,r0,#8              ;4151
0002b4  f8841021          STRB     r1,[r4,#0x21]         ;4151
0002b8  0c01              LSRS     r1,r0,#16             ;4151
0002ba  f8841022          STRB     r1,[r4,#0x22]         ;4151
0002be  0e00              LSRS     r0,r0,#24             ;4151
0002c0  f8840023          STRB     r0,[r4,#0x23]         ;4151
                  |L23.708|
0002c4  9801              LDR      r0,[sp,#4]            ;4153
0002c6  7560              STRB     r0,[r4,#0x15]         ;4153
0002c8  203f              MOVS     r0,#0x3f              ;4154
0002ca  7620              STRB     r0,[r4,#0x18]         ;4154
0002cc  2000              MOVS     r0,#0                 ;4154
0002ce  7660              STRB     r0,[r4,#0x19]         ;4154
0002d0  21ff              MOVS     r1,#0xff              ;4155
0002d2  76a1              STRB     r1,[r4,#0x1a]         ;4155
0002d4  76e0              STRB     r0,[r4,#0x1b]         ;4155
0002d6  f884a01c          STRB     r10,[r4,#0x1c]        ;4156
0002da  ea4f201a          LSR      r0,r10,#8             ;4156
0002de  7760              STRB     r0,[r4,#0x1d]         ;4156
0002e0  ea4f401a          LSR      r0,r10,#16            ;4156
0002e4  77a0              STRB     r0,[r4,#0x1e]         ;4156
0002e6  ea4f601a          LSR      r0,r10,#24            ;4156
0002ea  77e0              STRB     r0,[r4,#0x1f]         ;4156
0002ec  f7fffffe          BL       get_fattime
0002f0  2180              MOVS     r1,#0x80              ;4055
0002f2  2229              MOVS     r2,#0x29              ;4165
0002f4  9000              STR      r0,[sp,#0]            ;4158
0002f6  2f03              CMP      r7,#3                 ;4158
0002f8  d029              BEQ      |L23.846|
0002fa  f8840027          STRB     r0,[r4,#0x27]         ;4168
0002fe  0a03              LSRS     r3,r0,#8              ;4168
000300  f8843028          STRB     r3,[r4,#0x28]         ;4168
000304  0c03              LSRS     r3,r0,#16             ;4168
000306  f8843029          STRB     r3,[r4,#0x29]         ;4168
00030a  0e00              LSRS     r0,r0,#24             ;4168
00030c  f884002a          STRB     r0,[r4,#0x2a]         ;4168
000310  f8849016          STRB     r9,[r4,#0x16]         ;4169
000314  ea4f2019          LSR      r0,r9,#8              ;4169
000318  75e0              STRB     r0,[r4,#0x17]         ;4169
00031a  f8841024          STRB     r1,[r4,#0x24]         ;4170
00031e  f8842026          STRB     r2,[r4,#0x26]         ;4171
000322  2213              MOVS     r2,#0x13              ;4172
000324  a13d              ADR      r1,|L23.1052|
000326  f104002b          ADD      r0,r4,#0x2b           ;4172
                  |L23.810|
00032a  f7fffffe          BL       mem_cpy
00032e  2055              MOVS     r0,#0x55              ;4174
000330  f88401fe          STRB     r0,[r4,#0x1fe]        ;4174
000334  20aa              MOVS     r0,#0xaa              ;4174
000336  f88401ff          STRB     r0,[r4,#0x1ff]        ;4174
00033a  2301              MOVS     r3,#1                 ;4175
00033c  4652              MOV      r2,r10                ;4175
00033e  4621              MOV      r1,r4                 ;4175
000340  9802              LDR      r0,[sp,#8]            ;4175
000342  f7fffffe          BL       disk_write
000346  2800              CMP      r0,#0                 ;4175
000348  d100              BNE      |L23.844|
00034a  e036              B        |L23.954|
                  |L23.844|
00034c  e0d9              B        |L23.1282|
                  |L23.846|
00034e  f8840043          STRB     r0,[r4,#0x43]         ;4159
000352  0a03              LSRS     r3,r0,#8              ;4159
000354  f8843044          STRB     r3,[r4,#0x44]         ;4159
000358  0c03              LSRS     r3,r0,#16             ;4159
00035a  f8843045          STRB     r3,[r4,#0x45]         ;4159
00035e  0e00              LSRS     r0,r0,#24             ;4159
000360  f8840046          STRB     r0,[r4,#0x46]         ;4159
000364  f8849024          STRB     r9,[r4,#0x24]         ;4160
000368  ea4f2019          LSR      r0,r9,#8              ;4160
00036c  f8840025          STRB     r0,[r4,#0x25]         ;4160
000370  ea4f4019          LSR      r0,r9,#16             ;4160
000374  f8840026          STRB     r0,[r4,#0x26]         ;4160
000378  ea4f6019          LSR      r0,r9,#24             ;4160
00037c  f8840027          STRB     r0,[r4,#0x27]         ;4160
000380  2002              MOVS     r0,#2                 ;4161
000382  f884002c          STRB     r0,[r4,#0x2c]         ;4161
000386  2000              MOVS     r0,#0                 ;4161
000388  f884002d          STRB     r0,[r4,#0x2d]         ;4161
00038c  f884002e          STRB     r0,[r4,#0x2e]         ;4161
000390  f884002f          STRB     r0,[r4,#0x2f]         ;4161
000394  2301              MOVS     r3,#1                 ;4162
000396  f8843030          STRB     r3,[r4,#0x30]         ;4162
00039a  f8840031          STRB     r0,[r4,#0x31]         ;4162
00039e  2306              MOVS     r3,#6                 ;4163
0003a0  f8843032          STRB     r3,[r4,#0x32]         ;4163
0003a4  f8840033          STRB     r0,[r4,#0x33]         ;4163
0003a8  f8841040          STRB     r1,[r4,#0x40]         ;4164
0003ac  f8842042          STRB     r2,[r4,#0x42]         ;4165
0003b0  2213              MOVS     r2,#0x13              ;4166
0003b2  a11f              ADR      r1,|L23.1072|
0003b4  f1040047          ADD      r0,r4,#0x47           ;4166
0003b8  e7b7              B        |L23.810|
                  |L23.954|
0003ba  2f03              CMP      r7,#3                 ;4177
0003bc  d106              BNE      |L23.972|
0003be  2301              MOVS     r3,#1                 ;4178
0003c0  f10a0206          ADD      r2,r10,#6             ;4178
0003c4  4621              MOV      r1,r4                 ;4178
0003c6  9802              LDR      r0,[sp,#8]            ;4178
0003c8  f7fffffe          BL       disk_write
                  |L23.972|
0003cc  465d              MOV      r5,r11                ;4181
0003ce  f04f0b00          MOV      r11,#0                ;4182
                  |L23.978|
0003d2  8972              LDRH     r2,[r6,#0xa]          ;4183
0003d4  2100              MOVS     r1,#0                 ;4183
0003d6  4620              MOV      r0,r4                 ;4183
0003d8  f7fffffe          BL       mem_set
0003dc  9801              LDR      r0,[sp,#4]            ;4184
0003de  9000              STR      r0,[sp,#0]            ;4185
0003e0  2f03              CMP      r7,#3                 ;4185
0003e2  d031              BEQ      |L23.1096|
0003e4  2f01              CMP      r7,#1                 ;4186
0003e6  d02d              BEQ      |L23.1092|
0003e8  f06f01ff          MVN      r1,#0xff              ;4186
                  |L23.1004|
0003ec  4301              ORRS     r1,r1,r0              ;4186
0003ee  9100              STR      r1,[sp,#0]            ;4187
0003f0  7021              STRB     r1,[r4,#0]            ;4187
0003f2  9800              LDR      r0,[sp,#0]            ;4187
0003f4  0a00              LSRS     r0,r0,#8              ;4187
0003f6  7060              STRB     r0,[r4,#1]            ;4187
0003f8  9800              LDR      r0,[sp,#0]            ;4187
0003fa  0c00              LSRS     r0,r0,#16             ;4187
0003fc  70a0              STRB     r0,[r4,#2]            ;4187
0003fe  9800              LDR      r0,[sp,#0]            ;4187
000400  0e00              LSRS     r0,r0,#24             ;4187
000402  70e0              STRB     r0,[r4,#3]            ;4187
000404  e037              B        |L23.1142|
000406  0000              DCW      0x0000
                  |L23.1032|
                          DCD      ||.data||+0x4
                  |L23.1036|
                          DCD      ||.constdata||+0xe
                  |L23.1040|
000410  ebfe904d          DCB      235,254,144,"MSDOS5.0",0
000414  53444f53
000418  352e3000
                  |L23.1052|
00041c  4e4f204e          DCB      "NO NAME    FAT     ",0
000420  414d4520
000424  20202046
000428  41542020
00042c  20202000
                  |L23.1072|
000430  4e4f204e          DCB      "NO NAME    FAT32   ",0
000434  414d4520
000438  20202046
00043c  41543332
000440  20202000
                  |L23.1092|
000444  4949              LDR      r1,|L23.1388|
000446  e7d1              B        |L23.1004|
                  |L23.1096|
000448  f06000ff          ORN      r0,r0,#0xff           ;4189
00044c  9000              STR      r0,[sp,#0]            ;4190
00044e  7020              STRB     r0,[r4,#0]            ;4190
000450  9800              LDR      r0,[sp,#0]            ;4190
000452  0a00              LSRS     r0,r0,#8              ;4190
000454  7060              STRB     r0,[r4,#1]            ;4190
000456  9800              LDR      r0,[sp,#0]            ;4190
000458  0c00              LSRS     r0,r0,#16             ;4190
00045a  70a0              STRB     r0,[r4,#2]            ;4190
00045c  9800              LDR      r0,[sp,#0]            ;4190
00045e  0e00              LSRS     r0,r0,#24             ;4190
000460  70e0              STRB     r0,[r4,#3]            ;4190
000462  20ff              MOVS     r0,#0xff              ;4191
000464  7120              STRB     r0,[r4,#4]            ;4191
000466  7160              STRB     r0,[r4,#5]            ;4191
000468  71a0              STRB     r0,[r4,#6]            ;4191
00046a  71e0              STRB     r0,[r4,#7]            ;4191
00046c  7220              STRB     r0,[r4,#8]            ;4192
00046e  7260              STRB     r0,[r4,#9]            ;4192
000470  72a0              STRB     r0,[r4,#0xa]          ;4192
000472  200f              MOVS     r0,#0xf               ;4192
000474  72e0              STRB     r0,[r4,#0xb]          ;4192
                  |L23.1142|
000476  462a              MOV      r2,r5                 ;4194
000478  1c6d              ADDS     r5,r5,#1              ;4194
00047a  2301              MOVS     r3,#1                 ;4194
00047c  4621              MOV      r1,r4                 ;4194
00047e  9802              LDR      r0,[sp,#8]            ;4194
000480  f7fffffe          BL       disk_write
000484  bbe8              CBNZ     r0,|L23.1282|
000486  8972              LDRH     r2,[r6,#0xa]          ;4196
000488  2100              MOVS     r1,#0                 ;4196
00048a  4620              MOV      r0,r4                 ;4196
00048c  f7fffffe          BL       mem_set
000490  2001              MOVS     r0,#1                 ;4197
000492  e009              B        |L23.1192|
                  |L23.1172|
000494  462a              MOV      r2,r5                 ;4198
000496  1c6d              ADDS     r5,r5,#1              ;4198
000498  2301              MOVS     r3,#1                 ;4198
00049a  4621              MOV      r1,r4                 ;4198
00049c  9802              LDR      r0,[sp,#8]            ;4198
00049e  f7fffffe          BL       disk_write
0004a2  bb70              CBNZ     r0,|L23.1282|
0004a4  9800              LDR      r0,[sp,#0]            ;4197
0004a6  1c40              ADDS     r0,r0,#1              ;4197
                  |L23.1192|
0004a8  9000              STR      r0,[sp,#0]            ;4197
0004aa  4548              CMP      r0,r9                 ;4197
0004ac  d3f2              BCC      |L23.1172|
0004ae  f10b0001          ADD      r0,r11,#1             ;4182
0004b2  ea5f0b00          MOVS     r11,r0                ;4182
0004b6  d08c              BEQ      |L23.978|
0004b8  2f03              CMP      r7,#3                 ;4204
0004ba  d009              BEQ      |L23.1232|
0004bc  9e04              LDR      r6,[sp,#0x10]         ;4204
                  |L23.1214|
0004be  462a              MOV      r2,r5                 ;4206
0004c0  1c6d              ADDS     r5,r5,#1              ;4206
0004c2  2301              MOVS     r3,#1                 ;4206
0004c4  4621              MOV      r1,r4                 ;4206
0004c6  9802              LDR      r0,[sp,#8]            ;4206
0004c8  f7fffffe          BL       disk_write
0004cc  b9c8              CBNZ     r0,|L23.1282|
0004ce  e001              B        |L23.1236|
                  |L23.1232|
0004d0  4646              MOV      r6,r8                 ;4204
0004d2  e7f4              B        |L23.1214|
                  |L23.1236|
0004d4  1e76              SUBS     r6,r6,#1              ;4204
0004d6  d1f2              BNE      |L23.1214|
0004d8  2f03              CMP      r7,#3                 ;4220
0004da  d13c              BNE      |L23.1366|
0004dc  2052              MOVS     r0,#0x52              ;4221
0004de  7020              STRB     r0,[r4,#0]            ;4221
0004e0  7060              STRB     r0,[r4,#1]            ;4221
0004e2  2261              MOVS     r2,#0x61              ;4221
0004e4  70a2              STRB     r2,[r4,#2]            ;4221
0004e6  2041              MOVS     r0,#0x41              ;4221
0004e8  70e0              STRB     r0,[r4,#3]            ;4221
0004ea  2172              MOVS     r1,#0x72              ;4222
0004ec  f88411e4          STRB     r1,[r4,#0x1e4]        ;4222
0004f0  f88411e5          STRB     r1,[r4,#0x1e5]        ;4222
0004f4  f88401e6          STRB     r0,[r4,#0x1e6]        ;4222
0004f8  f88421e7          STRB     r2,[r4,#0x1e7]        ;4222
0004fc  9805              LDR      r0,[sp,#0x14]         ;4223
0004fe  1e40              SUBS     r0,r0,#1              ;4223
000500  e000              B        |L23.1284|
                  |L23.1282|
000502  e030              B        |L23.1382|
                  |L23.1284|
000504  f88401e8          STRB     r0,[r4,#0x1e8]        ;4223
000508  0a01              LSRS     r1,r0,#8              ;4223
00050a  f88411e9          STRB     r1,[r4,#0x1e9]        ;4223
00050e  0c01              LSRS     r1,r0,#16             ;4223
000510  f88411ea          STRB     r1,[r4,#0x1ea]        ;4223
000514  0e00              LSRS     r0,r0,#24             ;4223
000516  f88401eb          STRB     r0,[r4,#0x1eb]        ;4223
00051a  2002              MOVS     r0,#2                 ;4224
00051c  f88401ec          STRB     r0,[r4,#0x1ec]        ;4224
000520  2000              MOVS     r0,#0                 ;4224
000522  f88401ed          STRB     r0,[r4,#0x1ed]        ;4224
000526  f88401ee          STRB     r0,[r4,#0x1ee]        ;4224
00052a  f88401ef          STRB     r0,[r4,#0x1ef]        ;4224
00052e  2055              MOVS     r0,#0x55              ;4225
000530  f88401fe          STRB     r0,[r4,#0x1fe]        ;4225
000534  20aa              MOVS     r0,#0xaa              ;4225
000536  f88401ff          STRB     r0,[r4,#0x1ff]        ;4225
00053a  2301              MOVS     r3,#1                 ;4226
00053c  f10a0201          ADD      r2,r10,#1             ;4226
000540  4621              MOV      r1,r4                 ;4226
000542  9802              LDR      r0,[sp,#8]            ;4226
000544  f7fffffe          BL       disk_write
000548  2301              MOVS     r3,#1                 ;4227
00054a  f10a0207          ADD      r2,r10,#7             ;4227
00054e  4621              MOV      r1,r4                 ;4227
000550  9802              LDR      r0,[sp,#8]            ;4227
000552  f7fffffe          BL       disk_write
                  |L23.1366|
000556  2200              MOVS     r2,#0                 ;4230
000558  4611              MOV      r1,r2                 ;4230
00055a  9802              LDR      r0,[sp,#8]            ;4230
00055c  f7fffffe          BL       disk_ioctl
000560  2800              CMP      r0,#0                 ;4230
000562  f43fad5e          BEQ      |L23.34|
                  |L23.1382|
000566  2001              MOVS     r0,#1                 ;4230
000568  e552              B        |L23.16|
;;;4232   
                          ENDP

00056a  0000              DCW      0x0000
                  |L23.1388|
                          DCD      0x00ffff00

                          AREA ||i.f_mount||, CODE, READONLY, ALIGN=2

                  f_mount PROC
;;;2389   
;;;2390   FRESULT f_mount (
000000  b517              PUSH     {r0-r2,r4,lr}
;;;2391   	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
;;;2392   	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
;;;2393   	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
;;;2394   )
;;;2395   {
000002  b081              SUB      sp,sp,#4
000004  4614              MOV      r4,r2
;;;2396   	FATFS *cfs;
;;;2397   	int vol;
;;;2398   	FRESULT res;
;;;2399   	const TCHAR *rp = path;
000006  9802              LDR      r0,[sp,#8]
;;;2400   
;;;2401   
;;;2402   	vol = get_ldnumber(&rp);
000008  9000              STR      r0,[sp,#0]
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       get_ldnumber
;;;2403   	if (vol < 0) return FR_INVALID_DRIVE;
000010  2800              CMP      r0,#0
000012  da02              BGE      |L24.26|
000014  200b              MOVS     r0,#0xb
                  |L24.22|
;;;2404   	cfs = FatFs[vol];					/* Pointer to fs object */
;;;2405   
;;;2406   	if (cfs) {
;;;2407   #if _FS_LOCK
;;;2408   		clear_lock(cfs);
;;;2409   #endif
;;;2410   #if _FS_REENTRANT						/* Discard sync object of the current volume */
;;;2411   		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
;;;2412   #endif
;;;2413   		cfs->fs_type = 0;				/* Clear old fs object */
;;;2414   	}
;;;2415   
;;;2416   	if (fs) {
;;;2417   		fs->fs_type = 0;				/* Clear new fs object */
;;;2418   #if _FS_REENTRANT						/* Create sync object for the new volume */
;;;2419   		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
;;;2420   #endif
;;;2421   	}
;;;2422   	FatFs[vol] = fs;					/* Register new fs object */
;;;2423   
;;;2424   	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
;;;2425   
;;;2426   	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
;;;2427   	LEAVE_FF(fs, res);
;;;2428   }
000016  b004              ADD      sp,sp,#0x10
000018  bd10              POP      {r4,pc}
                  |L24.26|
00001a  4b0b              LDR      r3,|L24.72|
00001c  2200              MOVS     r2,#0                 ;2404
00001e  f8531020          LDR      r1,[r3,r0,LSL #2]     ;2404
000022  b101              CBZ      r1,|L24.38|
000024  700a              STRB     r2,[r1,#0]            ;2413
                  |L24.38|
000026  9901              LDR      r1,[sp,#4]            ;2416
000028  2900              CMP      r1,#0                 ;2416
00002a  d000              BEQ      |L24.46|
00002c  700a              STRB     r2,[r1,#0]            ;2417
                  |L24.46|
00002e  f8431020          STR      r1,[r3,r0,LSL #2]     ;2422
000032  d001              BEQ      |L24.56|
000034  2c01              CMP      r4,#1                 ;2424
000036  d001              BEQ      |L24.60|
                  |L24.56|
000038  2000              MOVS     r0,#0                 ;2424
00003a  e7ec              B        |L24.22|
                  |L24.60|
00003c  2200              MOVS     r2,#0                 ;2426
00003e  a902              ADD      r1,sp,#8              ;2426
000040  a801              ADD      r0,sp,#4              ;2426
000042  f7fffffe          BL       find_volume
000046  e7e6              B        |L24.22|
;;;2429   
                          ENDP

                  |L24.72|
                          DCD      ||.data||+0x4

                          AREA ||i.f_open||, CODE, READONLY, ALIGN=1

                  f_open PROC
;;;2436   
;;;2437   FRESULT f_open (
000000  e92d47f7          PUSH     {r0-r2,r4-r10,lr}
;;;2438   	FIL* fp,			/* Pointer to the blank file object */
;;;2439   	const TCHAR* path,	/* Pointer to the file name */
;;;2440   	BYTE mode			/* Access mode and file open mode flags */
;;;2441   )
;;;2442   {
000004  f5ad7d0d          SUB      sp,sp,#0x234
000008  0006              MOVS     r6,r0
00000a  d00e              BEQ      |L25.42|
;;;2443   	FRESULT res;
;;;2444   	DIR dj;
;;;2445   	BYTE *dir;
;;;2446   	DEF_NAMEBUF;
;;;2447   
;;;2448   
;;;2449   	if (!fp) return FR_INVALID_OBJECT;
;;;2450   	fp->fs = 0;			/* Clear file object */
00000c  f04f0800          MOV      r8,#0
;;;2451   
;;;2452   	/* Get logical drive number */
;;;2453   #if !_FS_READONLY
;;;2454   	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
000010  f002071f          AND      r7,r2,#0x1f
;;;2455   	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
000014  f0270201          BIC      r2,r7,#1
000018  a98e              ADD      r1,sp,#0x238
00001a  a880              ADD      r0,sp,#0x200
00001c  f8c68000          STR      r8,[r6,#0]
000020  f7fffffe          BL       find_volume
000024  0005              MOVS     r5,r0
;;;2456   #else
;;;2457   	mode &= FA_READ;
;;;2458   	res = find_volume(&dj.fs, &path, 0);
;;;2459   #endif
;;;2460   	if (res == FR_OK) {
000026  d005              BEQ      |L25.52|
000028  e088              B        |L25.316|
                  |L25.42|
00002a  2009              MOVS     r0,#9                 ;2449
                  |L25.44|
;;;2461   		INIT_BUF(dj);
;;;2462   		res = follow_path(&dj, path);	/* Follow the file path */
;;;2463   		dir = dj.dir;
;;;2464   #if !_FS_READONLY	/* R/W configuration */
;;;2465   		if (res == FR_OK) {
;;;2466   			if (!dir)	/* Default directory itself */
;;;2467   				res = FR_INVALID_NAME;
;;;2468   #if _FS_LOCK
;;;2469   			else
;;;2470   				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
;;;2471   #endif
;;;2472   		}
;;;2473   		/* Create or Open a file */
;;;2474   		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
;;;2475   			DWORD dw, cl;
;;;2476   
;;;2477   			if (res != FR_OK) {					/* No file, create new */
;;;2478   				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
;;;2479   #if _FS_LOCK
;;;2480   					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
;;;2481   #else
;;;2482   					res = dir_register(&dj);
;;;2483   #endif
;;;2484   				mode |= FA_CREATE_ALWAYS;		/* File is created */
;;;2485   				dir = dj.dir;					/* New entry */
;;;2486   			}
;;;2487   			else {								/* Any object is already existing */
;;;2488   				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
;;;2489   					res = FR_DENIED;
;;;2490   				} else {
;;;2491   					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
;;;2492   						res = FR_EXIST;
;;;2493   				}
;;;2494   			}
;;;2495   			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
;;;2496   				dw = GET_FATTIME();				/* Created time */
;;;2497   				ST_DWORD(dir+DIR_CrtTime, dw);
;;;2498   				dir[DIR_Attr] = 0;				/* Reset attribute */
;;;2499   				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
;;;2500   				cl = ld_clust(dj.fs, dir);		/* Get start cluster */
;;;2501   				st_clust(dir, 0);				/* cluster = 0 */
;;;2502   				dj.fs->wflag = 1;
;;;2503   				if (cl) {						/* Remove the cluster chain if exist */
;;;2504   					dw = dj.fs->winsect;
;;;2505   					res = remove_chain(dj.fs, cl);
;;;2506   					if (res == FR_OK) {
;;;2507   						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
;;;2508   						res = move_window(dj.fs, dw);
;;;2509   					}
;;;2510   				}
;;;2511   			}
;;;2512   		}
;;;2513   		else {	/* Open an existing file */
;;;2514   			if (res == FR_OK) {					/* Follow succeeded */
;;;2515   				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
;;;2516   					res = FR_NO_FILE;
;;;2517   				} else {
;;;2518   					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
;;;2519   						res = FR_DENIED;
;;;2520   				}
;;;2521   			}
;;;2522   		}
;;;2523   		if (res == FR_OK) {
;;;2524   			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
;;;2525   				mode |= FA__WRITTEN;
;;;2526   			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
;;;2527   			fp->dir_ptr = dir;
;;;2528   #if _FS_LOCK
;;;2529   			fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
;;;2530   			if (!fp->lockid) res = FR_INT_ERR;
;;;2531   #endif
;;;2532   		}
;;;2533   
;;;2534   #else				/* R/O configuration */
;;;2535   		if (res == FR_OK) {					/* Follow succeeded */
;;;2536   			dir = dj.dir;
;;;2537   			if (!dir) {						/* Current directory itself */
;;;2538   				res = FR_INVALID_NAME;
;;;2539   			} else {
;;;2540   				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
;;;2541   					res = FR_NO_FILE;
;;;2542   			}
;;;2543   		}
;;;2544   #endif
;;;2545   		FREE_BUF();
;;;2546   
;;;2547   		if (res == FR_OK) {
;;;2548   			fp->flag = mode;					/* File access mode */
;;;2549   			fp->err = 0;						/* Clear error flag */
;;;2550   			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
;;;2551   			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
;;;2552   			fp->fptr = 0;						/* File pointer */
;;;2553   			fp->dsect = 0;
;;;2554   #if _USE_FASTSEEK
;;;2555   			fp->cltbl = 0;						/* Normal seek mode */
;;;2556   #endif
;;;2557   			fp->fs = dj.fs;	 					/* Validate file object */
;;;2558   			fp->id = fp->fs->id;
;;;2559   		}
;;;2560   	}
;;;2561   
;;;2562   	LEAVE_FF(dj.fs, res);
;;;2563   }
00002c  f50d7d10          ADD      sp,sp,#0x240
000030  e8bd87f0          POP      {r4-r10,pc}
                  |L25.52|
000034  a889              ADD      r0,sp,#0x224          ;2461
000036  9086              STR      r0,[sp,#0x218]        ;2461
000038  f8cdd21c          STR      sp,[sp,#0x21c]        ;2461
00003c  a880              ADD      r0,sp,#0x200          ;2462
00003e  998e              LDR      r1,[sp,#0x238]        ;2462
000040  f7fffffe          BL       follow_path
000044  9c85              LDR      r4,[sp,#0x214]        ;2465
000046  0005              MOVS     r5,r0                 ;2462
000048  d101              BNE      |L25.78|
00004a  b904              CBNZ     r4,|L25.78|
00004c  2506              MOVS     r5,#6                 ;2467
                  |L25.78|
00004e  f0170f1c          TST      r7,#0x1c              ;2474
000052  d04a              BEQ      |L25.234|
000054  b155              CBZ      r5,|L25.108|
000056  2d04              CMP      r5,#4                 ;2478
000058  d103              BNE      |L25.98|
00005a  a880              ADD      r0,sp,#0x200          ;2482
00005c  f7fffffe          BL       dir_register
000060  4605              MOV      r5,r0                 ;2482
                  |L25.98|
000062  9c85              LDR      r4,[sp,#0x214]        ;2485
000064  f0470708          ORR      r7,r7,#8              ;2484
000068  b145              CBZ      r5,|L25.124|
00006a  e067              B        |L25.316|
                  |L25.108|
00006c  7ae0              LDRB     r0,[r4,#0xb]          ;2488
00006e  f0100f11          TST      r0,#0x11              ;2488
000072  d144              BNE      |L25.254|
000074  0778              LSLS     r0,r7,#29             ;2491
000076  d501              BPL      |L25.124|
000078  2508              MOVS     r5,#8                 ;2492
00007a  e05f              B        |L25.316|
                  |L25.124|
00007c  0738              LSLS     r0,r7,#28             ;2495
00007e  d544              BPL      |L25.266|
000080  f7fffffe          BL       get_fattime
000084  73a0              STRB     r0,[r4,#0xe]          ;2497
000086  0a01              LSRS     r1,r0,#8              ;2497
000088  73e1              STRB     r1,[r4,#0xf]          ;2497
00008a  0c01              LSRS     r1,r0,#16             ;2497
00008c  7421              STRB     r1,[r4,#0x10]         ;2497
00008e  0e00              LSRS     r0,r0,#24             ;2497
000090  7460              STRB     r0,[r4,#0x11]         ;2497
000092  f884800b          STRB     r8,[r4,#0xb]          ;2498
000096  f884801c          STRB     r8,[r4,#0x1c]         ;2499
00009a  f884801d          STRB     r8,[r4,#0x1d]         ;2499
00009e  f884801e          STRB     r8,[r4,#0x1e]         ;2499
0000a2  f884801f          STRB     r8,[r4,#0x1f]         ;2499
0000a6  4621              MOV      r1,r4                 ;2500
0000a8  9880              LDR      r0,[sp,#0x200]        ;2500
0000aa  f7fffffe          BL       ld_clust
0000ae  4681              MOV      r9,r0                 ;2500
0000b0  2100              MOVS     r1,#0                 ;2501
0000b2  4620              MOV      r0,r4                 ;2501
0000b4  f7fffffe          BL       st_clust
0000b8  9980              LDR      r1,[sp,#0x200]        ;2502
0000ba  2001              MOVS     r0,#1                 ;2502
0000bc  f1b90f00          CMP      r9,#0                 ;2503
0000c0  7108              STRB     r0,[r1,#4]            ;2502
0000c2  d020              BEQ      |L25.262|
0000c4  9880              LDR      r0,[sp,#0x200]        ;2504
0000c6  4649              MOV      r1,r9                 ;2505
0000c8  f8d0a030          LDR      r10,[r0,#0x30]        ;2505
0000cc  f7fffffe          BL       remove_chain
0000d0  0005              MOVS     r5,r0                 ;2505
0000d2  d133              BNE      |L25.316|
0000d4  9980              LDR      r1,[sp,#0x200]        ;2507
0000d6  f1a90001          SUB      r0,r9,#1              ;2507
0000da  60c8              STR      r0,[r1,#0xc]          ;2508
0000dc  4651              MOV      r1,r10                ;2508
0000de  9880              LDR      r0,[sp,#0x200]        ;2508
0000e0  f7fffffe          BL       move_window
0000e4  1e05              SUBS     r5,r0,#0              ;2508
0000e6  d00c              BEQ      |L25.258|
0000e8  e028              B        |L25.316|
                  |L25.234|
0000ea  bb3d              CBNZ     r5,|L25.316|
0000ec  7ae0              LDRB     r0,[r4,#0xb]          ;2515
0000ee  06c1              LSLS     r1,r0,#27             ;2515
0000f0  d501              BPL      |L25.246|
0000f2  2504              MOVS     r5,#4                 ;2516
0000f4  e022              B        |L25.316|
                  |L25.246|
0000f6  07b9              LSLS     r1,r7,#30             ;2518
0000f8  d503              BPL      |L25.258|
0000fa  07c0              LSLS     r0,r0,#31             ;2518
0000fc  d001              BEQ      |L25.258|
                  |L25.254|
0000fe  2507              MOVS     r5,#7                 ;2519
000100  e01c              B        |L25.316|
                  |L25.258|
000102  0738              LSLS     r0,r7,#28             ;2524
000104  d501              BPL      |L25.266|
                  |L25.262|
000106  f0470720          ORR      r7,r7,#0x20           ;2525
                  |L25.266|
00010a  9880              LDR      r0,[sp,#0x200]        ;2526
00010c  4621              MOV      r1,r4                 ;2550
00010e  6b00              LDR      r0,[r0,#0x30]         ;2526
000110  e9c60407          STRD     r0,r4,[r6,#0x1c]      ;2526
000114  71b7              STRB     r7,[r6,#6]            ;2548
000116  f8868007          STRB     r8,[r6,#7]            ;2549
00011a  4647              MOV      r7,r8                 ;2549
00011c  9880              LDR      r0,[sp,#0x200]        ;2550
00011e  f7fffffe          BL       ld_clust
000122  6130              STR      r0,[r6,#0x10]         ;2551
000124  7f20              LDRB     r0,[r4,#0x1c]         ;2551
000126  f8d4101d          LDR      r1,[r4,#0x1d]         ;2551
00012a  ea402001          ORR      r0,r0,r1,LSL #8       ;2551
00012e  e9c67002          STRD     r7,r0,[r6,#8]         ;2551
000132  61b7              STR      r7,[r6,#0x18]         ;2557
000134  9880              LDR      r0,[sp,#0x200]        ;2557
000136  6030              STR      r0,[r6,#0]            ;2558
000138  88c0              LDRH     r0,[r0,#6]            ;2558
00013a  80b0              STRH     r0,[r6,#4]            ;2558
                  |L25.316|
00013c  4628              MOV      r0,r5                 ;2562
00013e  e775              B        |L25.44|
;;;2564   
                          ENDP


                          AREA ||i.f_opendir||, CODE, READONLY, ALIGN=1

                  f_opendir PROC
;;;3173   
;;;3174   FRESULT f_opendir (
000000  b513              PUSH     {r0,r1,r4,lr}
;;;3175   	DIR* dp,			/* Pointer to directory object to create */
;;;3176   	const TCHAR* path	/* Pointer to the directory path */
;;;3177   )
;;;3178   {
000002  f5ad7d04          SUB      sp,sp,#0x210
000006  0004              MOVS     r4,r0
000008  d006              BEQ      |L26.24|
;;;3179   	FRESULT res;
;;;3180   	FATFS* fs;
;;;3181   	DEF_NAMEBUF;
;;;3182   
;;;3183   
;;;3184   	if (!dp) return FR_INVALID_OBJECT;
;;;3185   
;;;3186   	/* Get logical drive number */
;;;3187   	res = find_volume(&fs, &path, 0);
00000a  2200              MOVS     r2,#0
00000c  a985              ADD      r1,sp,#0x214
00000e  a880              ADD      r0,sp,#0x200
000010  f7fffffe          BL       find_volume
;;;3188   	if (res == FR_OK) {
000014  b120              CBZ      r0,|L26.32|
000016  e022              B        |L26.94|
                  |L26.24|
000018  2009              MOVS     r0,#9                 ;3184
                  |L26.26|
;;;3189   		dp->fs = fs;
;;;3190   		INIT_BUF(*dp);
;;;3191   		res = follow_path(dp, path);			/* Follow the path to the directory */
;;;3192   		FREE_BUF();
;;;3193   		if (res == FR_OK) {						/* Follow completed */
;;;3194   			if (dp->dir) {						/* It is not the origin directory itself */
;;;3195   				if (dp->dir[DIR_Attr] & AM_DIR)	/* The object is a sub directory */
;;;3196   					dp->sclust = ld_clust(fs, dp->dir);
;;;3197   				else							/* The object is a file */
;;;3198   					res = FR_NO_PATH;
;;;3199   			}
;;;3200   			if (res == FR_OK) {
;;;3201   				dp->id = fs->id;
;;;3202   				res = dir_sdi(dp, 0);			/* Rewind directory */
;;;3203   #if _FS_LOCK
;;;3204   				if (res == FR_OK) {
;;;3205   					if (dp->sclust) {
;;;3206   						dp->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
;;;3207   						if (!dp->lockid)
;;;3208   							res = FR_TOO_MANY_OPEN_FILES;
;;;3209   					} else {
;;;3210   						dp->lockid = 0;	/* Root directory need not to be locked */
;;;3211   					}
;;;3212   				}
;;;3213   #endif
;;;3214   			}
;;;3215   		}
;;;3216   		if (res == FR_NO_FILE) res = FR_NO_PATH;
;;;3217   	}
;;;3218   	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
;;;3219   
;;;3220   	LEAVE_FF(fs, res);
;;;3221   }
00001a  f50d7d06          ADD      sp,sp,#0x218
00001e  bd10              POP      {r4,pc}
                  |L26.32|
000020  9880              LDR      r0,[sp,#0x200]        ;3189
000022  6020              STR      r0,[r4,#0]            ;3190
000024  a881              ADD      r0,sp,#0x204          ;3190
000026  61a0              STR      r0,[r4,#0x18]         ;3190
000028  f8c4d01c          STR      sp,[r4,#0x1c]         ;3190
00002c  4620              MOV      r0,r4                 ;3191
00002e  9985              LDR      r1,[sp,#0x214]        ;3191
000030  f7fffffe          BL       follow_path
000034  b978              CBNZ     r0,|L26.86|
000036  6961              LDR      r1,[r4,#0x14]         ;3194
000038  b131              CBZ      r1,|L26.72|
00003a  7ac8              LDRB     r0,[r1,#0xb]          ;3195
00003c  06c0              LSLS     r0,r0,#27             ;3195
00003e  d511              BPL      |L26.100|
000040  9880              LDR      r0,[sp,#0x200]        ;3196
000042  f7fffffe          BL       ld_clust
000046  60a0              STR      r0,[r4,#8]            ;3196
                  |L26.72|
000048  9880              LDR      r0,[sp,#0x200]        ;3201
00004a  2100              MOVS     r1,#0                 ;3202
00004c  88c0              LDRH     r0,[r0,#6]            ;3201
00004e  80a0              STRH     r0,[r4,#4]            ;3201
000050  4620              MOV      r0,r4                 ;3202
000052  f7fffffe          BL       dir_sdi
                  |L26.86|
000056  2804              CMP      r0,#4                 ;3216
000058  d004              BEQ      |L26.100|
00005a  2800              CMP      r0,#0                 ;3218
00005c  d0dd              BEQ      |L26.26|
                  |L26.94|
00005e  2100              MOVS     r1,#0                 ;3218
000060  6021              STR      r1,[r4,#0]            ;3218
000062  e7da              B        |L26.26|
                  |L26.100|
000064  2005              MOVS     r0,#5                 ;3198
000066  e7fa              B        |L26.94|
;;;3222   
                          ENDP


                          AREA ||i.f_printf||, CODE, READONLY, ALIGN=1

                  f_printf PROC
;;;4508   
;;;4509   int f_printf (
000000  b40f              PUSH     {r0-r3}
;;;4510   	FIL* fp,			/* Pointer to the file object */
;;;4511   	const TCHAR* fmt,	/* Pointer to the format string */
;;;4512   	...					/* Optional arguments... */
;;;4513   )
;;;4514   {
000002  e92d47f0          PUSH     {r4-r10,lr}
000006  b09a              SUB      sp,sp,#0x68
;;;4515   	va_list arp;
;;;4516   	BYTE f, r;
;;;4517   	UINT nw, i, j, w;
;;;4518   	DWORD v;
;;;4519   	TCHAR c, d, s[16], *p;
;;;4520   	putbuff pb;
;;;4521   
;;;4522   
;;;4523   	pb.fp = fp;				/* Initialize output buffer */
;;;4524   	pb.nchr = pb.idx = 0;
;;;4525   
;;;4526   	va_start(arp, fmt);
000008  ae24              ADD      r6,sp,#0x90
00000a  9002              STR      r0,[sp,#8]            ;4524
00000c  2000              MOVS     r0,#0                 ;4524
00000e  9003              STR      r0,[sp,#0xc]          ;4524
000010  f10d0954          ADD      r9,sp,#0x54           ;4519
000014  9004              STR      r0,[sp,#0x10]         ;4519
                  |L27.22|
;;;4527   
;;;4528   	for (;;) {
;;;4529   		c = *fmt++;
000016  9823              LDR      r0,[sp,#0x8c]
000018  f8101b01          LDRB     r1,[r0],#1
;;;4530   		if (c == 0) break;			/* End of string */
00001c  9023              STR      r0,[sp,#0x8c]
00001e  2900              CMP      r1,#0
000020  d073              BEQ      |L27.266|
;;;4531   		if (c != '%') {				/* Non escape character */
000022  2925              CMP      r1,#0x25
000024  d003              BEQ      |L27.46|
                  |L27.38|
;;;4532   			putc_bfd(&pb, c);
000026  a802              ADD      r0,sp,#8
000028  f7fffffe          BL       putc_bfd
;;;4533   			continue;
00002c  e7f3              B        |L27.22|
                  |L27.46|
;;;4534   		}
;;;4535   		w = f = 0;
00002e  2500              MOVS     r5,#0
;;;4536   		c = *fmt++;
000030  f8101b01          LDRB     r1,[r0],#1
000034  462f              MOV      r7,r5                 ;4535
;;;4537   		if (c == '0') {				/* Flag: '0' padding */
000036  9023              STR      r0,[sp,#0x8c]
000038  2930              CMP      r1,#0x30
00003a  d002              BEQ      |L27.66|
;;;4538   			f = 1; c = *fmt++;
;;;4539   		} else {
;;;4540   			if (c == '-') {			/* Flag: left justified */
00003c  292d              CMP      r1,#0x2d
00003e  d002              BEQ      |L27.70|
000040  e00f              B        |L27.98|
                  |L27.66|
000042  2501              MOVS     r5,#1                 ;4538
000044  e000              B        |L27.72|
                  |L27.70|
;;;4541   				f = 2; c = *fmt++;
000046  2502              MOVS     r5,#2
                  |L27.72|
000048  f8101b01          LDRB     r1,[r0],#1
00004c  9023              STR      r0,[sp,#0x8c]
00004e  e008              B        |L27.98|
                  |L27.80|
;;;4542   			}
;;;4543   		}
;;;4544   		while (IsDigit(c)) {		/* Precision */
;;;4545   			w = w * 10 + c - '0';
000050  eb070087          ADD      r0,r7,r7,LSL #2
000054  eb010740          ADD      r7,r1,r0,LSL #1
;;;4546   			c = *fmt++;
000058  9823              LDR      r0,[sp,#0x8c]
00005a  3f30              SUBS     r7,r7,#0x30
00005c  f8101b01          LDRB     r1,[r0],#1
000060  9023              STR      r0,[sp,#0x8c]
                  |L27.98|
000062  f1a10030          SUB      r0,r1,#0x30           ;4544
000066  2809              CMP      r0,#9                 ;4544
000068  d9f2              BLS      |L27.80|
;;;4547   		}
;;;4548   		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
00006a  296c              CMP      r1,#0x6c
00006c  d001              BEQ      |L27.114|
00006e  294c              CMP      r1,#0x4c
000070  d105              BNE      |L27.126|
                  |L27.114|
;;;4549   			f |= 4; c = *fmt++;
000072  9823              LDR      r0,[sp,#0x8c]
000074  f0450504          ORR      r5,r5,#4
000078  f8101b01          LDRB     r1,[r0],#1
00007c  9023              STR      r0,[sp,#0x8c]
                  |L27.126|
;;;4550   		}
;;;4551   		if (!c) break;
00007e  2900              CMP      r1,#0
000080  d043              BEQ      |L27.266|
;;;4552   		d = c;
;;;4553   		if (IsLower(d)) d -= 0x20;
000082  f1a10061          SUB      r0,r1,#0x61
000086  460a              MOV      r2,r1                 ;4552
000088  2819              CMP      r0,#0x19
00008a  d801              BHI      |L27.144|
00008c  3a20              SUBS     r2,r2,#0x20
00008e  b2d2              UXTB     r2,r2
                  |L27.144|
;;;4554   		switch (d) {				/* Type is... */
000090  2a4f              CMP      r2,#0x4f
000092  d040              BEQ      |L27.278|
000094  dc06              BGT      |L27.164|
000096  2a42              CMP      r2,#0x42
000098  d03b              BEQ      |L27.274|
00009a  2a43              CMP      r2,#0x43
00009c  d036              BEQ      |L27.268|
00009e  2a44              CMP      r2,#0x44
0000a0  d1c1              BNE      |L27.38|
0000a2  e03a              B        |L27.282|
                  |L27.164|
0000a4  2a53              CMP      r2,#0x53
0000a6  d008              BEQ      |L27.186|
0000a8  2a55              CMP      r2,#0x55
0000aa  d036              BEQ      |L27.282|
0000ac  2a58              CMP      r2,#0x58
0000ae  d1ba              BNE      |L27.38|
;;;4555   		case 'S' :					/* String */
;;;4556   			p = va_arg(arp, TCHAR*);
;;;4557   			for (j = 0; p[j]; j++) ;
;;;4558   			if (!(f & 2)) {
;;;4559   				while (j++ < w) putc_bfd(&pb, ' ');
;;;4560   			}
;;;4561   			while (*p) putc_bfd(&pb, *p++);
;;;4562   			while (j++ < w) putc_bfd(&pb, ' ');
;;;4563   			continue;
;;;4564   		case 'C' :					/* Character */
;;;4565   			putc_bfd(&pb, (TCHAR)va_arg(arp, int)); continue;
;;;4566   		case 'B' :					/* Binary */
;;;4567   			r = 2; break;
;;;4568   		case 'O' :					/* Octal */
;;;4569   			r = 8; break;
;;;4570   		case 'D' :					/* Signed decimal */
;;;4571   		case 'U' :					/* Unsigned decimal */
;;;4572   			r = 10; break;
;;;4573   		case 'X' :					/* Hexdecimal */
;;;4574   			r = 16; break;
0000b0  2310              MOVS     r3,#0x10
                  |L27.178|
;;;4575   		default:					/* Unknown type (pass-through) */
;;;4576   			putc_bfd(&pb, c); continue;
;;;4577   		}
;;;4578   
;;;4579   		/* Get an argument and put it in numeral */
;;;4580   		v = (f & 4) ? (DWORD)va_arg(arp, long) : ((d == 'D') ? (DWORD)(long)va_arg(arp, int) : (DWORD)va_arg(arp, unsigned int));
0000b2  ce01              LDM      r6!,{r0}
;;;4581   		if (d == 'D' && (v & 0x80000000)) {
0000b4  2a44              CMP      r2,#0x44
0000b6  d032              BEQ      |L27.286|
0000b8  e036              B        |L27.296|
                  |L27.186|
0000ba  f8568b04          LDR      r8,[r6],#4            ;4556
0000be  2400              MOVS     r4,#0                 ;4557
0000c0  e000              B        |L27.196|
                  |L27.194|
0000c2  1c64              ADDS     r4,r4,#1              ;4557
                  |L27.196|
0000c4  f8180004          LDRB     r0,[r8,r4]            ;4557
0000c8  2800              CMP      r0,#0                 ;4557
0000ca  d1fa              BNE      |L27.194|
0000cc  07a8              LSLS     r0,r5,#30             ;4558
0000ce  d504              BPL      |L27.218|
0000d0  e00d              B        |L27.238|
                  |L27.210|
0000d2  2120              MOVS     r1,#0x20              ;4559
0000d4  a802              ADD      r0,sp,#8              ;4559
0000d6  f7fffffe          BL       putc_bfd
                  |L27.218|
0000da  4620              MOV      r0,r4                 ;4559
0000dc  1c64              ADDS     r4,r4,#1              ;4559
0000de  42b8              CMP      r0,r7                 ;4559
0000e0  d3f7              BCC      |L27.210|
0000e2  e004              B        |L27.238|
                  |L27.228|
0000e4  f1080801          ADD      r8,r8,#1              ;4561
0000e8  a802              ADD      r0,sp,#8              ;4561
0000ea  f7fffffe          BL       putc_bfd
                  |L27.238|
0000ee  f8981000          LDRB     r1,[r8,#0]            ;4561
0000f2  2900              CMP      r1,#0                 ;4561
0000f4  d1f6              BNE      |L27.228|
0000f6  e003              B        |L27.256|
                  |L27.248|
0000f8  2120              MOVS     r1,#0x20              ;4562
0000fa  a802              ADD      r0,sp,#8              ;4562
0000fc  f7fffffe          BL       putc_bfd
                  |L27.256|
000100  4620              MOV      r0,r4                 ;4562
000102  1c64              ADDS     r4,r4,#1              ;4562
000104  42b8              CMP      r0,r7                 ;4562
                  |L27.262|
000106  d286              BCS      |L27.22|
000108  e7f6              B        |L27.248|
                  |L27.266|
00010a  e054              B        |L27.438|
                  |L27.268|
00010c  f8161b04          LDRB     r1,[r6],#4            ;4565
000110  e789              B        |L27.38|
                  |L27.274|
000112  2302              MOVS     r3,#2                 ;4567
000114  e7cd              B        |L27.178|
                  |L27.278|
000116  2308              MOVS     r3,#8                 ;4569
000118  e7cb              B        |L27.178|
                  |L27.282|
00011a  230a              MOVS     r3,#0xa               ;4572
00011c  e7c9              B        |L27.178|
                  |L27.286|
00011e  2800              CMP      r0,#0
000120  da02              BGE      |L27.296|
;;;4582   			v = 0 - v;
000122  4240              RSBS     r0,r0,#0
;;;4583   			f |= 8;
000124  f0450508          ORR      r5,r5,#8
                  |L27.296|
;;;4584   		}
;;;4585   		i = 0;
000128  2400              MOVS     r4,#0
00012a  46cc              MOV      r12,r9                ;4519
                  |L27.300|
;;;4586   		do {
;;;4587   			d = (TCHAR)(v % r); v /= r;
00012c  fbb0f2f3          UDIV     r2,r0,r3
000130  fb030212          MLS      r2,r3,r2,r0
000134  fbb0f0f3          UDIV     r0,r0,r3
000138  b2d2              UXTB     r2,r2
;;;4588   			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
00013a  2a09              CMP      r2,#9
00013c  d905              BLS      |L27.330|
00013e  2978              CMP      r1,#0x78
000140  d015              BEQ      |L27.366|
000142  f04f0807          MOV      r8,#7
                  |L27.326|
000146  4442              ADD      r2,r2,r8
000148  b2d2              UXTB     r2,r2
                  |L27.330|
00014a  3230              ADDS     r2,r2,#0x30
;;;4589   			s[i++] = d + '0';
00014c  f80c2004          STRB     r2,[r12,r4]
000150  1c64              ADDS     r4,r4,#1
;;;4590   		} while (v && i < sizeof s / sizeof s[0]);
000152  b108              CBZ      r0,|L27.344|
000154  2c10              CMP      r4,#0x10
000156  d3e9              BCC      |L27.300|
                  |L27.344|
;;;4591   		if (f & 8) s[i++] = '-';
000158  0728              LSLS     r0,r5,#28
00015a  d503              BPL      |L27.356|
00015c  202d              MOVS     r0,#0x2d
00015e  f8090004          STRB     r0,[r9,r4]
000162  1c64              ADDS     r4,r4,#1
                  |L27.356|
;;;4592   		j = i; d = (f & 1) ? '0' : ' ';
000164  46a0              MOV      r8,r4
000166  07e8              LSLS     r0,r5,#31
000168  d004              BEQ      |L27.372|
00016a  2030              MOVS     r0,#0x30
00016c  e003              B        |L27.374|
                  |L27.366|
00016e  f04f0827          MOV      r8,#0x27              ;4588
000172  e7e8              B        |L27.326|
                  |L27.372|
000174  2020              MOVS     r0,#0x20
                  |L27.374|
000176  4682              MOV      r10,r0
;;;4593   		while (!(f & 2) && j++ < w) putc_bfd(&pb, d);
000178  e003              B        |L27.386|
                  |L27.378|
00017a  4651              MOV      r1,r10
00017c  a802              ADD      r0,sp,#8
00017e  f7fffffe          BL       putc_bfd
                  |L27.386|
000182  07a8              LSLS     r0,r5,#30
000184  d404              BMI      |L27.400|
000186  4641              MOV      r1,r8
000188  f1080801          ADD      r8,r8,#1
00018c  42b9              CMP      r1,r7
00018e  d3f4              BCC      |L27.378|
                  |L27.400|
000190  464d              MOV      r5,r9                 ;4519
                  |L27.402|
000192  1e64              SUBS     r4,r4,#1              ;4519
;;;4594   		do putc_bfd(&pb, s[--i]); while (i);
000194  a802              ADD      r0,sp,#8
000196  5d29              LDRB     r1,[r5,r4]
000198  f7fffffe          BL       putc_bfd
00019c  2c00              CMP      r4,#0
00019e  d1f8              BNE      |L27.402|
0001a0  e003              B        |L27.426|
                  |L27.418|
;;;4595   		while (j++ < w) putc_bfd(&pb, d);
0001a2  4651              MOV      r1,r10
0001a4  a802              ADD      r0,sp,#8
0001a6  f7fffffe          BL       putc_bfd
                  |L27.426|
0001aa  4641              MOV      r1,r8
0001ac  f1080801          ADD      r8,r8,#1
0001b0  42b9              CMP      r1,r7
0001b2  d2a8              BCS      |L27.262|
0001b4  e7f5              B        |L27.418|
                  |L27.438|
;;;4596   	}
;;;4597   
;;;4598   	va_end(arp);
;;;4599   
;;;4600   	if (   pb.idx >= 0		/* Flush buffered characters to the file */
0001b6  9803              LDR      r0,[sp,#0xc]
0001b8  2800              CMP      r0,#0
0001ba  db10              BLT      |L27.478|
;;;4601   		&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
0001bc  4602              MOV      r2,r0
0001be  ab01              ADD      r3,sp,#4
0001c0  a905              ADD      r1,sp,#0x14
0001c2  9802              LDR      r0,[sp,#8]
0001c4  f7fffffe          BL       f_write
0001c8  b948              CBNZ     r0,|L27.478|
;;;4602   		&& (UINT)pb.idx == nw) return pb.nchr;
0001ca  9901              LDR      r1,[sp,#4]
0001cc  9803              LDR      r0,[sp,#0xc]
0001ce  4288              CMP      r0,r1
0001d0  d105              BNE      |L27.478|
0001d2  9804              LDR      r0,[sp,#0x10]
                  |L27.468|
;;;4603   	return EOF;
;;;4604   }
0001d4  b01a              ADD      sp,sp,#0x68
0001d6  e8bd07f0          POP      {r4-r10}
0001da  f85dfb14          LDR      pc,[sp],#0x14
                  |L27.478|
0001de  f04f30ff          MOV      r0,#0xffffffff        ;4603
0001e2  e7f7              B        |L27.468|
;;;4605   
                          ENDP


                          AREA ||i.f_putc||, CODE, READONLY, ALIGN=1

                  f_putc PROC
;;;4453   
;;;4454   int f_putc (
000000  b500              PUSH     {lr}
;;;4455   	TCHAR c,	/* A character to be output */
;;;4456   	FIL* fp		/* Pointer to the file object */
;;;4457   )
;;;4458   {
000002  b095              SUB      sp,sp,#0x54
;;;4459   	putbuff pb;
;;;4460   	UINT nw;
;;;4461   
;;;4462   
;;;4463   	pb.fp = fp;			/* Initialize output buffer */
;;;4464   	pb.nchr = pb.idx = 0;
000004  9102              STR      r1,[sp,#8]
000006  2100              MOVS     r1,#0
000008  9103              STR      r1,[sp,#0xc]
;;;4465   
;;;4466   	putc_bfd(&pb, c);	/* Put a character */
00000a  9104              STR      r1,[sp,#0x10]
00000c  4601              MOV      r1,r0
00000e  a802              ADD      r0,sp,#8
000010  f7fffffe          BL       putc_bfd
;;;4467   
;;;4468   	if (   pb.idx >= 0	/* Flush buffered characters to the file */
000014  9803              LDR      r0,[sp,#0xc]
000016  2800              CMP      r0,#0
000018  db0d              BLT      |L28.54|
;;;4469   		&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
00001a  4602              MOV      r2,r0
00001c  ab01              ADD      r3,sp,#4
00001e  a905              ADD      r1,sp,#0x14
000020  9802              LDR      r0,[sp,#8]
000022  f7fffffe          BL       f_write
000026  b930              CBNZ     r0,|L28.54|
;;;4470   		&& (UINT)pb.idx == nw) return pb.nchr;
000028  9901              LDR      r1,[sp,#4]
00002a  9803              LDR      r0,[sp,#0xc]
00002c  4288              CMP      r0,r1
00002e  d102              BNE      |L28.54|
000030  9804              LDR      r0,[sp,#0x10]
                  |L28.50|
;;;4471   	return EOF;
;;;4472   }
000032  b015              ADD      sp,sp,#0x54
000034  bd00              POP      {pc}
                  |L28.54|
000036  f04f30ff          MOV      r0,#0xffffffff        ;4471
00003a  e7fa              B        |L28.50|
;;;4473   
                          ENDP


                          AREA ||i.f_puts||, CODE, READONLY, ALIGN=1

                  f_puts PROC
;;;4480   
;;;4481   int f_puts (
000000  b510              PUSH     {r4,lr}
;;;4482   	const TCHAR* str,	/* Pointer to the string to be output */
;;;4483   	FIL* fp				/* Pointer to the file object */
;;;4484   )
;;;4485   {
000002  b096              SUB      sp,sp,#0x58
000004  4604              MOV      r4,r0
;;;4486   	putbuff pb;
;;;4487   	UINT nw;
;;;4488   
;;;4489   
;;;4490   	pb.fp = fp;				/* Initialize output buffer */
;;;4491   	pb.nchr = pb.idx = 0;
000006  2000              MOVS     r0,#0
000008  e9cd1002          STRD     r1,r0,[sp,#8]
00000c  9004              STR      r0,[sp,#0x10]         ;4485
00000e  e003              B        |L29.24|
                  |L29.16|
;;;4492   
;;;4493   	while (*str)			/* Put the string */
;;;4494   		putc_bfd(&pb, *str++);
000010  a802              ADD      r0,sp,#8
000012  1c64              ADDS     r4,r4,#1
000014  f7fffffe          BL       putc_bfd
                  |L29.24|
000018  7821              LDRB     r1,[r4,#0]            ;4493
00001a  2900              CMP      r1,#0                 ;4493
00001c  d1f8              BNE      |L29.16|
;;;4495   
;;;4496   	if (   pb.idx >= 0		/* Flush buffered characters to the file */
00001e  9803              LDR      r0,[sp,#0xc]
000020  2800              CMP      r0,#0
000022  db0d              BLT      |L29.64|
;;;4497   		&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
000024  4602              MOV      r2,r0
000026  ab01              ADD      r3,sp,#4
000028  a905              ADD      r1,sp,#0x14
00002a  9802              LDR      r0,[sp,#8]
00002c  f7fffffe          BL       f_write
000030  b930              CBNZ     r0,|L29.64|
;;;4498   		&& (UINT)pb.idx == nw) return pb.nchr;
000032  9901              LDR      r1,[sp,#4]
000034  9803              LDR      r0,[sp,#0xc]
000036  4288              CMP      r0,r1
000038  d102              BNE      |L29.64|
00003a  9804              LDR      r0,[sp,#0x10]
                  |L29.60|
;;;4499   	return EOF;
;;;4500   }
00003c  b016              ADD      sp,sp,#0x58
00003e  bd10              POP      {r4,pc}
                  |L29.64|
000040  f04f30ff          MOV      r0,#0xffffffff        ;4499
000044  e7fa              B        |L29.60|
;;;4501   
                          ENDP


                          AREA ||i.f_read||, CODE, READONLY, ALIGN=1

                  f_read PROC
;;;2571   
;;;2572   FRESULT f_read (
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;2573   	FIL* fp, 		/* Pointer to the file object */
;;;2574   	void* buff,		/* Pointer to data buffer */
;;;2575   	UINT btr,		/* Number of bytes to read */
;;;2576   	UINT* br		/* Pointer to number of bytes read */
;;;2577   )
;;;2578   {
;;;2579   	FRESULT res;
;;;2580   	DWORD clst, sect, remain;
;;;2581   	UINT rcnt, cc;
;;;2582   	BYTE csect, *rbuff = (BYTE*)buff;
000004  4689              MOV      r9,r1
;;;2583   
;;;2584   
;;;2585   	*br = 0;	/* Clear read byte counter */
000006  2100              MOVS     r1,#0
000008  469a              MOV      r10,r3                ;2578
00000a  4616              MOV      r6,r2                 ;2578
00000c  4604              MOV      r4,r0                 ;2578
;;;2586   
;;;2587   	res = validate(fp);							/* Check validity */
00000e  6019              STR      r1,[r3,#0]
000010  f7fffffe          BL       validate
;;;2588   	if (res != FR_OK) LEAVE_FF(fp->fs, res);
000014  2800              CMP      r0,#0
000016  d112              BNE      |L30.62|
;;;2589   	if (fp->err)								/* Check error */
000018  79e0              LDRB     r0,[r4,#7]
00001a  2800              CMP      r0,#0
00001c  d10f              BNE      |L30.62|
;;;2590   		LEAVE_FF(fp->fs, (FRESULT)fp->err);
;;;2591   	if (!(fp->flag & FA_READ)) 					/* Check access mode */
00001e  79a0              LDRB     r0,[r4,#6]
000020  07c0              LSLS     r0,r0,#31
000022  d00b              BEQ      |L30.60|
000024  e9d41002          LDRD     r1,r0,[r4,#8]
;;;2592   		LEAVE_FF(fp->fs, FR_DENIED);
;;;2593   	remain = fp->fsize - fp->fptr;
000028  1a40              SUBS     r0,r0,r1
;;;2594   	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
;;;2595   
;;;2596   	for ( ;  btr;								/* Repeat until all data read */
;;;2597   		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
;;;2598   		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
;;;2599   			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
;;;2600   			if (!csect) {						/* On the cluster boundary? */
;;;2601   				if (fp->fptr == 0) {			/* On the top of the file? */
;;;2602   					clst = fp->sclust;			/* Follow from the origin */
;;;2603   				} else {						/* Middle or end of the file */
;;;2604   #if _USE_FASTSEEK
;;;2605   					if (fp->cltbl)
;;;2606   						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
;;;2607   					else
;;;2608   #endif
;;;2609   						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
;;;2610   				}
;;;2611   				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
;;;2612   				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;2613   				fp->clust = clst;				/* Update current cluster */
;;;2614   			}
;;;2615   			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
;;;2616   			if (!sect) ABORT(fp->fs, FR_INT_ERR);
;;;2617   			sect += csect;
;;;2618   			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
;;;2619   			if (cc) {							/* Read maximum contiguous sectors directly */
;;;2620   				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
;;;2621   					cc = fp->fs->csize - csect;
;;;2622   				if (disk_read(fp->fs->drv, rbuff, sect, cc) != RES_OK)
;;;2623   					ABORT(fp->fs, FR_DISK_ERR);
;;;2624   #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
;;;2625   #if _FS_TINY
;;;2626   				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
;;;2627   					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
;;;2628   #else
;;;2629   				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
;;;2630   					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
00002a  f1040124          ADD      r1,r4,#0x24
00002e  f04f0b01          MOV      r11,#1                ;2612
000032  9100              STR      r1,[sp,#0]            ;2594
000034  4286              CMP      r6,r0                 ;2594
000036  d900              BLS      |L30.58|
000038  4606              MOV      r6,r0                 ;2594
                  |L30.58|
00003a  e08b              B        |L30.340|
                  |L30.60|
00003c  2007              MOVS     r0,#7                 ;2592
                  |L30.62|
;;;2631   #endif
;;;2632   #endif
;;;2633   				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
;;;2634   				continue;
;;;2635   			}
;;;2636   #if !_FS_TINY
;;;2637   			if (fp->dsect != sect) {			/* Load data sector if not in cache */
;;;2638   #if !_FS_READONLY
;;;2639   				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
;;;2640   					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
;;;2641   						ABORT(fp->fs, FR_DISK_ERR);
;;;2642   					fp->flag &= ~FA__DIRTY;
;;;2643   				}
;;;2644   #endif
;;;2645   				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
;;;2646   					ABORT(fp->fs, FR_DISK_ERR);
;;;2647   			}
;;;2648   #endif
;;;2649   			fp->dsect = sect;
;;;2650   		}
;;;2651   		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
;;;2652   		if (rcnt > btr) rcnt = btr;
;;;2653   #if _FS_TINY
;;;2654   		if (move_window(fp->fs, fp->dsect) != FR_OK)		/* Move sector window */
;;;2655   			ABORT(fp->fs, FR_DISK_ERR);
;;;2656   		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
;;;2657   #else
;;;2658   		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
;;;2659   #endif
;;;2660   	}
;;;2661   
;;;2662   	LEAVE_FF(fp->fs, FR_OK);
;;;2663   }
00003e  e8bd8ff8          POP      {r3-r11,pc}
                  |L30.66|
000042  6822              LDR      r2,[r4,#0]            ;2598
000044  68a0              LDR      r0,[r4,#8]            ;2598
000046  8951              LDRH     r1,[r2,#0xa]          ;2598
000048  fbb0f3f1          UDIV     r3,r0,r1              ;2598
00004c  fb010313          MLS      r3,r1,r3,r0           ;2598
000050  2b00              CMP      r3,#0                 ;2598
000052  d160              BNE      |L30.278|
000054  fbb0f1f1          UDIV     r1,r0,r1              ;2599
000058  7893              LDRB     r3,[r2,#2]            ;2599
00005a  1e5b              SUBS     r3,r3,#1              ;2599
00005c  4019              ANDS     r1,r1,r3              ;2599
00005e  f01105ff          ANDS     r5,r1,#0xff           ;2599
000062  d109              BNE      |L30.120|
000064  b308              CBZ      r0,|L30.170|
000066  4610              MOV      r0,r2                 ;2609
000068  6961              LDR      r1,[r4,#0x14]         ;2609
00006a  f7fffffe          BL       get_fat
                  |L30.110|
00006e  2802              CMP      r0,#2                 ;2611
000070  d31d              BCC      |L30.174|
000072  1c41              ADDS     r1,r0,#1              ;2612
000074  d049              BEQ      |L30.266|
000076  6160              STR      r0,[r4,#0x14]         ;2613
                  |L30.120|
000078  6961              LDR      r1,[r4,#0x14]         ;2615
00007a  6820              LDR      r0,[r4,#0]            ;2615
00007c  f7fffffe          BL       clust2sect
000080  b1a8              CBZ      r0,|L30.174|
000082  eb000805          ADD      r8,r0,r5              ;2617
000086  6820              LDR      r0,[r4,#0]            ;2618
000088  8941              LDRH     r1,[r0,#0xa]          ;2618
00008a  fbb6f7f1          UDIV     r7,r6,r1              ;2618
00008e  b327              CBZ      r7,|L30.218|
000090  7881              LDRB     r1,[r0,#2]            ;2620
000092  19ea              ADDS     r2,r5,r7              ;2620
000094  428a              CMP      r2,r1                 ;2620
000096  d900              BLS      |L30.154|
000098  1b4f              SUBS     r7,r1,r5              ;2621
                  |L30.154|
00009a  7840              LDRB     r0,[r0,#1]            ;2622
00009c  463b              MOV      r3,r7                 ;2622
00009e  4642              MOV      r2,r8                 ;2622
0000a0  4649              MOV      r1,r9                 ;2622
0000a2  f7fffffe          BL       disk_read
0000a6  bb80              CBNZ     r0,|L30.266|
0000a8  e004              B        |L30.180|
                  |L30.170|
0000aa  6920              LDR      r0,[r4,#0x10]         ;2602
0000ac  e7df              B        |L30.110|
                  |L30.174|
0000ae  2002              MOVS     r0,#2                 ;2616
0000b0  71e0              STRB     r0,[r4,#7]            ;2616
0000b2  e7c4              B        |L30.62|
                  |L30.180|
0000b4  79a0              LDRB     r0,[r4,#6]            ;2629
0000b6  0640              LSLS     r0,r0,#25             ;2629
0000b8  d50b              BPL      |L30.210|
0000ba  69a1              LDR      r1,[r4,#0x18]         ;2629
0000bc  eba10008          SUB      r0,r1,r8              ;2629
0000c0  42b8              CMP      r0,r7                 ;2629
0000c2  d206              BCS      |L30.210|
0000c4  6821              LDR      r1,[r4,#0]            ;2630
0000c6  894a              LDRH     r2,[r1,#0xa]          ;2630
0000c8  9900              LDR      r1,[sp,#0]            ;2630
0000ca  fb009002          MLA      r0,r0,r2,r9           ;2630
0000ce  f7fffffe          BL       mem_cpy
                  |L30.210|
0000d2  6820              LDR      r0,[r4,#0]            ;2633
0000d4  8945              LDRH     r5,[r0,#0xa]          ;2633
0000d6  437d              MULS     r5,r7,r5              ;2633
0000d8  e032              B        |L30.320|
                  |L30.218|
0000da  69a2              LDR      r2,[r4,#0x18]         ;2637
0000dc  4542              CMP      r2,r8                 ;2637
0000de  d018              BEQ      |L30.274|
0000e0  79a1              LDRB     r1,[r4,#6]            ;2639
0000e2  0649              LSLS     r1,r1,#25             ;2639
0000e4  d509              BPL      |L30.250|
0000e6  7840              LDRB     r0,[r0,#1]            ;2640
0000e8  2301              MOVS     r3,#1                 ;2640
0000ea  9900              LDR      r1,[sp,#0]            ;2640
0000ec  f7fffffe          BL       disk_write
0000f0  b958              CBNZ     r0,|L30.266|
0000f2  79a0              LDRB     r0,[r4,#6]            ;2642
0000f4  f0200040          BIC      r0,r0,#0x40           ;2642
0000f8  71a0              STRB     r0,[r4,#6]            ;2642
                  |L30.250|
0000fa  6820              LDR      r0,[r4,#0]            ;2645
0000fc  2301              MOVS     r3,#1                 ;2645
0000fe  4642              MOV      r2,r8                 ;2645
000100  7840              LDRB     r0,[r0,#1]            ;2645
000102  9900              LDR      r1,[sp,#0]            ;2645
000104  f7fffffe          BL       disk_read
000108  b118              CBZ      r0,|L30.274|
                  |L30.266|
00010a  f884b007          STRB     r11,[r4,#7]           ;2646
00010e  2001              MOVS     r0,#1                 ;2646
000110  e795              B        |L30.62|
                  |L30.274|
000112  f8c48018          STR      r8,[r4,#0x18]         ;2649
                  |L30.278|
000116  6820              LDR      r0,[r4,#0]            ;2651
000118  68a1              LDR      r1,[r4,#8]            ;2651
00011a  8940              LDRH     r0,[r0,#0xa]          ;2651
00011c  fbb1f2f0          UDIV     r2,r1,r0              ;2651
000120  fb001212          MLS      r2,r0,r2,r1           ;2651
000124  1a85              SUBS     r5,r0,r2              ;2651
000126  42b5              CMP      r5,r6                 ;2652
000128  d900              BLS      |L30.300|
00012a  4635              MOV      r5,r6                 ;2652
                  |L30.300|
00012c  fbb1f2f0          UDIV     r2,r1,r0              ;2658
000130  fb001012          MLS      r0,r0,r2,r1           ;2658
000134  1901              ADDS     r1,r0,r4              ;2658
000136  462a              MOV      r2,r5                 ;2658
000138  4648              MOV      r0,r9                 ;2658
00013a  3124              ADDS     r1,r1,#0x24           ;2658
00013c  f7fffffe          BL       mem_cpy
                  |L30.320|
000140  68a0              LDR      r0,[r4,#8]            ;2597
000142  44a9              ADD      r9,r9,r5              ;2597
000144  4428              ADD      r0,r0,r5              ;2597
000146  60a0              STR      r0,[r4,#8]            ;2597
000148  f8da0000          LDR      r0,[r10,#0]           ;2597
00014c  1941              ADDS     r1,r0,r5              ;2597
00014e  1b76              SUBS     r6,r6,r5              ;2597
000150  f8ca1000          STR      r1,[r10,#0]           ;2597
                  |L30.340|
000154  2e00              CMP      r6,#0                 ;2596
000156  f47faf74          BNE      |L30.66|
00015a  2000              MOVS     r0,#0                 ;2662
00015c  e76f              B        |L30.62|
;;;2664   
                          ENDP


                          AREA ||i.f_readdir||, CODE, READONLY, ALIGN=1

                  f_readdir PROC
;;;3261   
;;;3262   FRESULT f_readdir (
000000  b570              PUSH     {r4-r6,lr}
;;;3263   	DIR* dp,			/* Pointer to the open directory object */
;;;3264   	FILINFO* fno		/* Pointer to file information to return */
;;;3265   )
;;;3266   {
000002  f5ad7d04          SUB      sp,sp,#0x210
000006  460e              MOV      r6,r1
000008  4604              MOV      r4,r0
;;;3267   	FRESULT res;
;;;3268   	DEF_NAMEBUF;
;;;3269   
;;;3270   
;;;3271   	res = validate(dp);						/* Check validity of the object */
00000a  f7fffffe          BL       validate
;;;3272   	if (res == FR_OK) {
00000e  2800              CMP      r0,#0
000010  d119              BNE      |L31.70|
;;;3273   		if (!fno) {
000012  b1de              CBZ      r6,|L31.76|
;;;3274   			res = dir_sdi(dp, 0);			/* Rewind the directory object */
;;;3275   		} else {
;;;3276   			INIT_BUF(*dp);
000014  a880              ADD      r0,sp,#0x200
000016  61a0              STR      r0,[r4,#0x18]
000018  f8c4d01c          STR      sp,[r4,#0x1c]
;;;3277   			res = dir_read(dp, 0);			/* Read an item */
00001c  2100              MOVS     r1,#0
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       dir_read
000024  2500              MOVS     r5,#0
;;;3278   			if (res == FR_NO_FILE) {		/* Reached end of directory */
000026  2804              CMP      r0,#4
000028  d015              BEQ      |L31.86|
;;;3279   				dp->sect = 0;
;;;3280   				res = FR_OK;
;;;3281   			}
;;;3282   			if (res == FR_OK) {				/* A valid entry is found */
00002a  2800              CMP      r0,#0
00002c  d10b              BNE      |L31.70|
                  |L31.46|
;;;3283   				get_fileinfo(dp, fno);		/* Get the object information */
00002e  4631              MOV      r1,r6
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       get_fileinfo
;;;3284   				res = dir_next(dp, 0);		/* Increment index for next */
000036  2100              MOVS     r1,#0
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       dir_next
;;;3285   				if (res == FR_NO_FILE) {
00003e  2804              CMP      r0,#4
000040  d101              BNE      |L31.70|
;;;3286   					dp->sect = 0;
;;;3287   					res = FR_OK;
000042  2000              MOVS     r0,#0
000044  6125              STR      r5,[r4,#0x10]
                  |L31.70|
;;;3288   				}
;;;3289   			}
;;;3290   			FREE_BUF();
;;;3291   		}
;;;3292   	}
;;;3293   
;;;3294   	LEAVE_FF(dp->fs, res);
;;;3295   }
000046  f50d7d04          ADD      sp,sp,#0x210
00004a  bd70              POP      {r4-r6,pc}
                  |L31.76|
00004c  2100              MOVS     r1,#0                 ;3274
00004e  4620              MOV      r0,r4                 ;3274
000050  f7fffffe          BL       dir_sdi
000054  e7f7              B        |L31.70|
                  |L31.86|
000056  6125              STR      r5,[r4,#0x10]         ;3280
000058  e7e9              B        |L31.46|
;;;3296   
                          ENDP


                          AREA ||i.f_rename||, CODE, READONLY, ALIGN=1

                  f_rename PROC
;;;3646   
;;;3647   FRESULT f_rename (
000000  b533              PUSH     {r0,r1,r4,r5,lr}
;;;3648   	const TCHAR* path_old,	/* Pointer to the object to be renamed */
;;;3649   	const TCHAR* path_new	/* Pointer to the new name */
;;;3650   )
;;;3651   {
000002  f5ad7d1b          SUB      sp,sp,#0x26c
;;;3652   	FRESULT res;
;;;3653   	DIR djo, djn;
;;;3654   	BYTE buf[21], *dir;
;;;3655   	DWORD dw;
;;;3656   	DEF_NAMEBUF;
;;;3657   
;;;3658   
;;;3659   	/* Get logical drive number of the source object */
;;;3660   	res = find_volume(&djo.fs, &path_old, 1);
000006  2201              MOVS     r2,#1
000008  a99b              ADD      r1,sp,#0x26c
00000a  a880              ADD      r0,sp,#0x200
00000c  f7fffffe          BL       find_volume
;;;3661   	if (res == FR_OK) {
000010  2800              CMP      r0,#0
000012  d110              BNE      |L32.54|
;;;3662   		djn.fs = djo.fs;
000014  9880              LDR      r0,[sp,#0x200]
;;;3663   		INIT_BUF(djo);
000016  9089              STR      r0,[sp,#0x224]
000018  a898              ADD      r0,sp,#0x260
00001a  9086              STR      r0,[sp,#0x218]
00001c  f8cdd21c          STR      sp,[sp,#0x21c]
;;;3664   		res = follow_path(&djo, path_old);		/* Check old object */
000020  a880              ADD      r0,sp,#0x200
000022  999b              LDR      r1,[sp,#0x26c]
000024  f7fffffe          BL       follow_path
;;;3665   		if (_FS_RPATH && res == FR_OK && (djo.fn[NSFLAG] & NS_DOT))
000028  2800              CMP      r0,#0
00002a  d104              BNE      |L32.54|
00002c  9886              LDR      r0,[sp,#0x218]
00002e  7ac0              LDRB     r0,[r0,#0xb]
000030  0680              LSLS     r0,r0,#26
000032  d503              BPL      |L32.60|
;;;3666   			res = FR_INVALID_NAME;
000034  2006              MOVS     r0,#6
                  |L32.54|
;;;3667   #if _FS_LOCK
;;;3668   		if (res == FR_OK) res = chk_lock(&djo, 2);
;;;3669   #endif
;;;3670   		if (res == FR_OK) {						/* Old object is found */
;;;3671   			if (!djo.dir) {						/* Is root dir? */
;;;3672   				res = FR_NO_FILE;
;;;3673   			} else {
;;;3674   				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except name */
;;;3675   				mem_cpy(&djn, &djo, sizeof (DIR));		/* Duplicate the directory object */
;;;3676   				if (get_ldnumber(&path_new) >= 0)		/* Snip drive number off and ignore it */
;;;3677   					res = follow_path(&djn, path_new);	/* and make sure if new object name is not conflicting */
;;;3678   				else
;;;3679   					res = FR_INVALID_DRIVE;
;;;3680   				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
;;;3681   				if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
;;;3682   /* Start of critical section that any interruption can cause a cross-link */
;;;3683   					res = dir_register(&djn);			/* Register the new entry */
;;;3684   					if (res == FR_OK) {
;;;3685   						dir = djn.dir;					/* Copy object information except name */
;;;3686   						mem_cpy(dir+13, buf+2, 19);
;;;3687   						dir[DIR_Attr] = buf[0] | AM_ARC;
;;;3688   						djo.fs->wflag = 1;
;;;3689   						if ((dir[DIR_Attr] & AM_DIR) && djo.sclust != djn.sclust) {	/* Update .. entry in the directory if needed */
;;;3690   							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
;;;3691   							if (!dw) {
;;;3692   								res = FR_INT_ERR;
;;;3693   							} else {
;;;3694   								res = move_window(djo.fs, dw);
;;;3695   								dir = djo.fs->win+SZ_DIR;	/* .. entry */
;;;3696   								if (res == FR_OK && dir[1] == '.') {
;;;3697   									st_clust(dir, djn.sclust);
;;;3698   									djo.fs->wflag = 1;
;;;3699   								}
;;;3700   							}
;;;3701   						}
;;;3702   						if (res == FR_OK) {
;;;3703   							res = dir_remove(&djo);		/* Remove old entry */
;;;3704   							if (res == FR_OK)
;;;3705   								res = sync_fs(djo.fs);
;;;3706   						}
;;;3707   					}
;;;3708   /* End of critical section */
;;;3709   				}
;;;3710   			}
;;;3711   		}
;;;3712   		FREE_BUF();
;;;3713   	}
;;;3714   
;;;3715   	LEAVE_FF(djo.fs, res);
;;;3716   }
000036  f50d7d1d          ADD      sp,sp,#0x274
00003a  bd30              POP      {r4,r5,pc}
                  |L32.60|
00003c  9885              LDR      r0,[sp,#0x214]        ;3671
00003e  b3e8              CBZ      r0,|L32.188|
000040  f100010b          ADD      r1,r0,#0xb            ;3674
000044  2215              MOVS     r2,#0x15              ;3674
000046  a892              ADD      r0,sp,#0x248          ;3674
000048  f7fffffe          BL       mem_cpy
00004c  2224              MOVS     r2,#0x24              ;3675
00004e  a980              ADD      r1,sp,#0x200          ;3675
000050  a889              ADD      r0,sp,#0x224          ;3675
000052  f7fffffe          BL       mem_cpy
000056  a89c              ADD      r0,sp,#0x270          ;3676
000058  f7fffffe          BL       get_ldnumber
00005c  2800              CMP      r0,#0                 ;3676
00005e  db3c              BLT      |L32.218|
000060  a889              ADD      r0,sp,#0x224          ;3677
000062  999c              LDR      r1,[sp,#0x270]        ;3677
000064  f7fffffe          BL       follow_path
000068  b348              CBZ      r0,|L32.190|
00006a  2804              CMP      r0,#4                 ;3681
00006c  d1e3              BNE      |L32.54|
00006e  a889              ADD      r0,sp,#0x224          ;3683
000070  f7fffffe          BL       dir_register
000074  2800              CMP      r0,#0                 ;3684
000076  d1de              BNE      |L32.54|
000078  9c8e              LDR      r4,[sp,#0x238]        ;3686
00007a  2213              MOVS     r2,#0x13              ;3686
00007c  f20d214a          ADD      r1,sp,#0x24a          ;3686
000080  f104000d          ADD      r0,r4,#0xd            ;3686
000084  f7fffffe          BL       mem_cpy
000088  f89d0248          LDRB     r0,[sp,#0x248]        ;3687
00008c  2501              MOVS     r5,#1                 ;3688
00008e  f0400020          ORR      r0,r0,#0x20           ;3687
000092  72e0              STRB     r0,[r4,#0xb]          ;3687
000094  9880              LDR      r0,[sp,#0x200]        ;3688
000096  7105              STRB     r5,[r0,#4]            ;3688
000098  7ae0              LDRB     r0,[r4,#0xb]          ;3689
00009a  06c0              LSLS     r0,r0,#27             ;3689
00009c  d529              BPL      |L32.242|
00009e  998b              LDR      r1,[sp,#0x22c]        ;3689
0000a0  9882              LDR      r0,[sp,#0x208]        ;3689
0000a2  4288              CMP      r0,r1                 ;3689
0000a4  d025              BEQ      |L32.242|
0000a6  4621              MOV      r1,r4                 ;3690
0000a8  9880              LDR      r0,[sp,#0x200]        ;3690
0000aa  f7fffffe          BL       ld_clust
0000ae  4601              MOV      r1,r0                 ;3690
0000b0  9880              LDR      r0,[sp,#0x200]        ;3690
0000b2  f7fffffe          BL       clust2sect
0000b6  0001              MOVS     r1,r0                 ;3690
0000b8  d013              BEQ      |L32.226|
0000ba  e001              B        |L32.192|
                  |L32.188|
0000bc  e00b              B        |L32.214|
                  |L32.190|
0000be  e00e              B        |L32.222|
                  |L32.192|
0000c0  9880              LDR      r0,[sp,#0x200]        ;3694
0000c2  f7fffffe          BL       move_window
0000c6  9a80              LDR      r2,[sp,#0x200]        ;3695
0000c8  3254              ADDS     r2,r2,#0x54           ;3695
0000ca  2800              CMP      r0,#0                 ;3696
0000cc  d1b3              BNE      |L32.54|
0000ce  7850              LDRB     r0,[r2,#1]            ;3696
0000d0  282e              CMP      r0,#0x2e              ;3696
0000d2  d008              BEQ      |L32.230|
0000d4  e00d              B        |L32.242|
                  |L32.214|
0000d6  2004              MOVS     r0,#4                 ;3672
0000d8  e7ad              B        |L32.54|
                  |L32.218|
0000da  200b              MOVS     r0,#0xb               ;3679
0000dc  e7ab              B        |L32.54|
                  |L32.222|
0000de  2008              MOVS     r0,#8                 ;3680
0000e0  e7a9              B        |L32.54|
                  |L32.226|
0000e2  2002              MOVS     r0,#2                 ;3692
0000e4  e7a7              B        |L32.54|
                  |L32.230|
0000e6  4610              MOV      r0,r2                 ;3697
0000e8  998b              LDR      r1,[sp,#0x22c]        ;3697
0000ea  f7fffffe          BL       st_clust
0000ee  9880              LDR      r0,[sp,#0x200]        ;3698
0000f0  7105              STRB     r5,[r0,#4]            ;3698
                  |L32.242|
0000f2  a880              ADD      r0,sp,#0x200          ;3703
0000f4  f7fffffe          BL       dir_remove
0000f8  2800              CMP      r0,#0                 ;3704
0000fa  d19c              BNE      |L32.54|
0000fc  9880              LDR      r0,[sp,#0x200]        ;3705
0000fe  f7fffffe          BL       sync_fs
000102  e798              B        |L32.54|
;;;3717   
                          ENDP


                          AREA ||i.f_setlabel||, CODE, READONLY, ALIGN=2

                  f_setlabel PROC
;;;3836   
;;;3837   FRESULT f_setlabel (
000000  e92d43f1          PUSH     {r0,r4-r9,lr}
;;;3838   	const TCHAR* label	/* Pointer to the volume label to set */
;;;3839   )
;;;3840   {
000004  b08c              SUB      sp,sp,#0x30
;;;3841   	FRESULT res;
;;;3842   	DIR dj;
;;;3843   	BYTE vn[11];
;;;3844   	UINT i, j, sl;
;;;3845   	WCHAR w;
;;;3846   	DWORD tm;
;;;3847   
;;;3848   
;;;3849   	/* Get logical drive number */
;;;3850   	res = find_volume(&dj.fs, &label, 1);
000006  2201              MOVS     r2,#1
000008  a90c              ADD      r1,sp,#0x30
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       find_volume
;;;3851   	if (res) LEAVE_FF(dj.fs, res);
000010  2800              CMP      r0,#0
000012  d145              BNE      |L33.160|
;;;3852   
;;;3853   	/* Create a volume label in directory form */
;;;3854   	vn[0] = 0;
000014  4681              MOV      r9,r0
000016  f88d9024          STRB     r9,[sp,#0x24]
;;;3855   	for (sl = 0; label[sl]; sl++) ;				/* Get name length */
00001a  464d              MOV      r5,r9
00001c  980c              LDR      r0,[sp,#0x30]
00001e  e000              B        |L33.34|
                  |L33.32|
000020  1c6d              ADDS     r5,r5,#1
                  |L33.34|
000022  5d41              LDRB     r1,[r0,r5]
000024  2900              CMP      r1,#0
000026  d1fb              BNE      |L33.32|
000028  e000              B        |L33.44|
                  |L33.42|
00002a  1e6d              SUBS     r5,r5,#1
                  |L33.44|
;;;3856   	for ( ; sl && label[sl-1] == ' '; sl--) ;	/* Remove trailing spaces */
00002c  b39d              CBZ      r5,|L33.150|
00002e  1941              ADDS     r1,r0,r5
000030  f8111c01          LDRB     r1,[r1,#-1]
000034  2920              CMP      r1,#0x20
000036  d0f8              BEQ      |L33.42|
;;;3857   	if (sl) {	/* Create volume label in directory form */
;;;3858   		i = j = 0;
000038  2400              MOVS     r4,#0
00003a  4626              MOV      r6,r4
00003c  f10d0824          ADD      r8,sp,#0x24           ;3843
                  |L33.64|
;;;3859   		do {
;;;3860   #if _USE_LFN && _LFN_UNICODE
;;;3861   			w = ff_convert(ff_wtoupper(label[i++]), 0);
;;;3862   #else
;;;3863   			w = (BYTE)label[i++];
000040  990c              LDR      r1,[sp,#0x30]
000042  5d88              LDRB     r0,[r1,r6]
;;;3864   			if (IsDBCS1(w))
000044  1c76              ADDS     r6,r6,#1
000046  f1a00281          SUB      r2,r0,#0x81
00004a  2a7d              CMP      r2,#0x7d
00004c  d810              BHI      |L33.112|
;;;3865   				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
00004e  2c0a              CMP      r4,#0xa
000050  d20d              BCS      |L33.110|
000052  42ae              CMP      r6,r5
000054  d20b              BCS      |L33.110|
000056  5d89              LDRB     r1,[r1,r6]
000058  f1a10240          SUB      r2,r1,#0x40
00005c  2a3e              CMP      r2,#0x3e
00005e  d902              BLS      |L33.102|
000060  3a40              SUBS     r2,r2,#0x40
000062  2a7e              CMP      r2,#0x7e
000064  d803              BHI      |L33.110|
                  |L33.102|
000066  ea412000          ORR      r0,r1,r0,LSL #8
00006a  1c76              ADDS     r6,r6,#1
00006c  e000              B        |L33.112|
                  |L33.110|
00006e  2000              MOVS     r0,#0
                  |L33.112|
;;;3866   #if _USE_LFN
;;;3867   			w = ff_convert(ff_wtoupper(ff_convert(w, 1)), 0);
000070  2101              MOVS     r1,#1
000072  f7fffffe          BL       ff_convert
000076  f7fffffe          BL       ff_wtoupper
00007a  2100              MOVS     r1,#0
00007c  f7fffffe          BL       ff_convert
000080  0007              MOVS     r7,r0
;;;3868   #else
;;;3869   			if (IsLower(w)) w -= 0x20;			/* To upper ASCII characters */
;;;3870   #ifdef _EXCVT
;;;3871   			if (w >= 0x80) w = ExCvt[w - 0x80];	/* To upper extended characters (SBCS cfg) */
;;;3872   #else
;;;3873   			if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended characters (ASCII cfg) */
;;;3874   #endif
;;;3875   #endif
;;;3876   #endif
;;;3877   			if (!w || chk_chr("\"*+,.:;<=>\?[]|\x7F", w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) /* Reject invalid characters for volume label */
000082  d00c              BEQ      |L33.158|
000084  4601              MOV      r1,r0
000086  a035              ADR      r0,|L33.348|
000088  f7fffffe          BL       chk_chr
00008c  b938              CBNZ     r0,|L33.158|
00008e  2fff              CMP      r7,#0xff
000090  d902              BLS      |L33.152|
000092  200a              MOVS     r0,#0xa
000094  e001              B        |L33.154|
                  |L33.150|
000096  e018              B        |L33.202|
                  |L33.152|
000098  200b              MOVS     r0,#0xb
                  |L33.154|
00009a  42a0              CMP      r0,r4
00009c  d803              BHI      |L33.166|
                  |L33.158|
;;;3878   				LEAVE_FF(dj.fs, FR_INVALID_NAME);
00009e  2006              MOVS     r0,#6
                  |L33.160|
;;;3879   			if (w >= 0x100) vn[j++] = (BYTE)(w >> 8);
;;;3880   			vn[j++] = (BYTE)w;
;;;3881   		} while (i < sl);
;;;3882   		while (j < 11) vn[j++] = ' ';
;;;3883   	}
;;;3884   
;;;3885   	/* Set volume label */
;;;3886   	dj.sclust = 0;					/* Open root directory */
;;;3887   	res = dir_sdi(&dj, 0);
;;;3888   	if (res == FR_OK) {
;;;3889   		res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
;;;3890   		if (res == FR_OK) {			/* A volume label is found */
;;;3891   			if (vn[0]) {
;;;3892   				mem_cpy(dj.dir, vn, 11);	/* Change the volume label name */
;;;3893   				tm = GET_FATTIME();
;;;3894   				ST_DWORD(dj.dir+DIR_WrtTime, tm);
;;;3895   			} else {
;;;3896   				dj.dir[0] = DDE;			/* Remove the volume label */
;;;3897   			}
;;;3898   			dj.fs->wflag = 1;
;;;3899   			res = sync_fs(dj.fs);
;;;3900   		} else {					/* No volume label is found or error */
;;;3901   			if (res == FR_NO_FILE) {
;;;3902   				res = FR_OK;
;;;3903   				if (vn[0]) {				/* Create volume label as new */
;;;3904   					res = dir_alloc(&dj, 1);	/* Allocate an entry for volume label */
;;;3905   					if (res == FR_OK) {
;;;3906   						mem_set(dj.dir, 0, SZ_DIR);	/* Set volume label */
;;;3907   						mem_cpy(dj.dir, vn, 11);
;;;3908   						dj.dir[DIR_Attr] = AM_VOL;
;;;3909   						tm = GET_FATTIME();
;;;3910   						ST_DWORD(dj.dir+DIR_WrtTime, tm);
;;;3911   						dj.fs->wflag = 1;
;;;3912   						res = sync_fs(dj.fs);
;;;3913   					}
;;;3914   				}
;;;3915   			}
;;;3916   		}
;;;3917   	}
;;;3918   
;;;3919   	LEAVE_FF(dj.fs, res);
;;;3920   }
0000a0  b00d              ADD      sp,sp,#0x34
0000a2  e8bd83f0          POP      {r4-r9,pc}
                  |L33.166|
0000a6  2fff              CMP      r7,#0xff              ;3879
0000a8  d903              BLS      |L33.178|
0000aa  0a39              LSRS     r1,r7,#8              ;3879
0000ac  f8081004          STRB     r1,[r8,r4]            ;3879
0000b0  1c64              ADDS     r4,r4,#1              ;3879
                  |L33.178|
0000b2  4640              MOV      r0,r8                 ;3880
0000b4  f8087004          STRB     r7,[r8,r4]            ;3880
0000b8  1c64              ADDS     r4,r4,#1              ;3880
0000ba  42ae              CMP      r6,r5                 ;3881
0000bc  d3c0              BCC      |L33.64|
0000be  2120              MOVS     r1,#0x20              ;3882
                  |L33.192|
0000c0  2c0b              CMP      r4,#0xb               ;3882
0000c2  d202              BCS      |L33.202|
0000c4  5501              STRB     r1,[r0,r4]            ;3882
0000c6  1c64              ADDS     r4,r4,#1              ;3882
0000c8  e7fa              B        |L33.192|
                  |L33.202|
0000ca  2100              MOVS     r1,#0                 ;3887
0000cc  4668              MOV      r0,sp                 ;3887
0000ce  f8cd9008          STR      r9,[sp,#8]            ;3887
0000d2  f7fffffe          BL       dir_sdi
0000d6  2800              CMP      r0,#0                 ;3888
0000d8  d1e2              BNE      |L33.160|
0000da  2101              MOVS     r1,#1                 ;3889
0000dc  4668              MOV      r0,sp                 ;3889
0000de  f7fffffe          BL       dir_read
0000e2  2401              MOVS     r4,#1                 ;3850
0000e4  b338              CBZ      r0,|L33.310|
0000e6  2804              CMP      r0,#4                 ;3901
0000e8  d1da              BNE      |L33.160|
0000ea  f89d1024          LDRB     r1,[sp,#0x24]         ;3903
0000ee  2000              MOVS     r0,#0                 ;3902
0000f0  2900              CMP      r1,#0                 ;3903
0000f2  d0d5              BEQ      |L33.160|
0000f4  2101              MOVS     r1,#1                 ;3904
0000f6  4668              MOV      r0,sp                 ;3904
0000f8  f7fffffe          BL       dir_alloc
0000fc  2800              CMP      r0,#0                 ;3905
0000fe  d1cf              BNE      |L33.160|
000100  2220              MOVS     r2,#0x20              ;3906
000102  2100              MOVS     r1,#0                 ;3906
000104  9805              LDR      r0,[sp,#0x14]         ;3906
000106  f7fffffe          BL       mem_set
00010a  220b              MOVS     r2,#0xb               ;3907
00010c  a909              ADD      r1,sp,#0x24           ;3907
00010e  9805              LDR      r0,[sp,#0x14]         ;3907
000110  f7fffffe          BL       mem_cpy
000114  9905              LDR      r1,[sp,#0x14]         ;3908
000116  2008              MOVS     r0,#8                 ;3908
000118  72c8              STRB     r0,[r1,#0xb]          ;3908
                  |L33.282|
00011a  f7fffffe          BL       get_fattime
00011e  9905              LDR      r1,[sp,#0x14]         ;3910
000120  7588              STRB     r0,[r1,#0x16]         ;3910
000122  9a05              LDR      r2,[sp,#0x14]         ;3910
000124  0a01              LSRS     r1,r0,#8              ;3910
000126  75d1              STRB     r1,[r2,#0x17]         ;3910
000128  9a05              LDR      r2,[sp,#0x14]         ;3910
00012a  0c01              LSRS     r1,r0,#16             ;3910
00012c  0e00              LSRS     r0,r0,#24             ;3910
00012e  7611              STRB     r1,[r2,#0x18]         ;3910
000130  9905              LDR      r1,[sp,#0x14]         ;3910
000132  7648              STRB     r0,[r1,#0x19]         ;3910
000134  e00b              B        |L33.334|
                  |L33.310|
000136  f89d0024          LDRB     r0,[sp,#0x24]         ;3891
00013a  b128              CBZ      r0,|L33.328|
00013c  220b              MOVS     r2,#0xb               ;3892
00013e  a909              ADD      r1,sp,#0x24           ;3892
000140  9805              LDR      r0,[sp,#0x14]         ;3892
000142  f7fffffe          BL       mem_cpy
000146  e7e8              B        |L33.282|
                  |L33.328|
000148  9905              LDR      r1,[sp,#0x14]         ;3896
00014a  20e5              MOVS     r0,#0xe5              ;3896
00014c  7008              STRB     r0,[r1,#0]            ;3896
                  |L33.334|
00014e  9800              LDR      r0,[sp,#0]            ;3898
000150  7104              STRB     r4,[r0,#4]            ;3898
000152  9800              LDR      r0,[sp,#0]            ;3899
000154  f7fffffe          BL       sync_fs
000158  e7a2              B        |L33.160|
;;;3921   
                          ENDP

00015a  0000              DCW      0x0000
                  |L33.348|
00015c  222a2b2c          DCB      """*+,.:;<=>?[]|",127,0
000160  2e3a3b3c
000164  3d3e3f5b
000168  5d7c7f00

                          AREA ||i.f_stat||, CODE, READONLY, ALIGN=1

                  f_stat PROC
;;;3303   
;;;3304   FRESULT f_stat (
000000  b533              PUSH     {r0,r1,r4,r5,lr}
;;;3305   	const TCHAR* path,	/* Pointer to the file path */
;;;3306   	FILINFO* fno		/* Pointer to file information to return */
;;;3307   )
;;;3308   {
000002  f5ad7d0d          SUB      sp,sp,#0x234
000006  460d              MOV      r5,r1
;;;3309   	FRESULT res;
;;;3310   	DIR dj;
;;;3311   	DEF_NAMEBUF;
;;;3312   
;;;3313   
;;;3314   	/* Get logical drive number */
;;;3315   	res = find_volume(&dj.fs, &path, 0);
000008  2200              MOVS     r2,#0
00000a  a98d              ADD      r1,sp,#0x234
00000c  a880              ADD      r0,sp,#0x200
00000e  f7fffffe          BL       find_volume
000012  0004              MOVS     r4,r0
;;;3316   	if (res == FR_OK) {
000014  d112              BNE      |L34.60|
;;;3317   		INIT_BUF(dj);
000016  a889              ADD      r0,sp,#0x224
000018  9086              STR      r0,[sp,#0x218]
00001a  f8cdd21c          STR      sp,[sp,#0x21c]
;;;3318   		res = follow_path(&dj, path);	/* Follow the file path */
00001e  a880              ADD      r0,sp,#0x200
000020  998d              LDR      r1,[sp,#0x234]
000022  f7fffffe          BL       follow_path
000026  0004              MOVS     r4,r0
;;;3319   		if (res == FR_OK) {				/* Follow completed */
000028  d108              BNE      |L34.60|
;;;3320   			if (dj.dir) {		/* Found an object */
00002a  9885              LDR      r0,[sp,#0x214]
00002c  b128              CBZ      r0,|L34.58|
;;;3321   				if (fno) get_fileinfo(&dj, fno);
00002e  b12d              CBZ      r5,|L34.60|
000030  4629              MOV      r1,r5
000032  a880              ADD      r0,sp,#0x200
000034  f7fffffe          BL       get_fileinfo
000038  e000              B        |L34.60|
                  |L34.58|
;;;3322   			} else {			/* It is root directory */
;;;3323   				res = FR_INVALID_NAME;
00003a  2406              MOVS     r4,#6
                  |L34.60|
;;;3324   			}
;;;3325   		}
;;;3326   		FREE_BUF();
;;;3327   	}
;;;3328   
;;;3329   	LEAVE_FF(dj.fs, res);
;;;3330   }
00003c  f50d7d0f          ADD      sp,sp,#0x23c
000040  4620              MOV      r0,r4                 ;3329
000042  bd30              POP      {r4,r5,pc}
;;;3331   
                          ENDP


                          AREA ||i.f_sync||, CODE, READONLY, ALIGN=1

                  f_sync PROC
;;;2794   
;;;2795   FRESULT f_sync (
000000  b570              PUSH     {r4-r6,lr}
;;;2796   	FIL* fp		/* Pointer to the file object */
;;;2797   )
;;;2798   {
000002  4604              MOV      r4,r0
;;;2799   	FRESULT res;
;;;2800   	DWORD tm;
;;;2801   	BYTE *dir;
;;;2802   
;;;2803   
;;;2804   	res = validate(fp);					/* Check validity of the object */
000004  f7fffffe          BL       validate
;;;2805   	if (res == FR_OK) {
000008  2800              CMP      r0,#0
00000a  d10e              BNE      |L35.42|
;;;2806   		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
00000c  79a1              LDRB     r1,[r4,#6]
00000e  068a              LSLS     r2,r1,#26
000010  d50b              BPL      |L35.42|
;;;2807   			/* Write-back dirty buffer */
;;;2808   #if !_FS_TINY
;;;2809   			if (fp->flag & FA__DIRTY) {
000012  0648              LSLS     r0,r1,#25
000014  d50e              BPL      |L35.52|
;;;2810   				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
000016  6820              LDR      r0,[r4,#0]
000018  2301              MOVS     r3,#1
00001a  f1040124          ADD      r1,r4,#0x24
00001e  7840              LDRB     r0,[r0,#1]
000020  69a2              LDR      r2,[r4,#0x18]
000022  f7fffffe          BL       disk_write
000026  b108              CBZ      r0,|L35.44|
;;;2811   					LEAVE_FF(fp->fs, FR_DISK_ERR);
000028  2001              MOVS     r0,#1
                  |L35.42|
;;;2812   				fp->flag &= ~FA__DIRTY;
;;;2813   			}
;;;2814   #endif
;;;2815   			/* Update the directory entry */
;;;2816   			res = move_window(fp->fs, fp->dir_sect);
;;;2817   			if (res == FR_OK) {
;;;2818   				dir = fp->dir_ptr;
;;;2819   				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
;;;2820   				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
;;;2821   				st_clust(dir, fp->sclust);					/* Update start cluster */
;;;2822   				tm = GET_FATTIME();							/* Update updated time */
;;;2823   				ST_DWORD(dir+DIR_WrtTime, tm);
;;;2824   				ST_WORD(dir+DIR_LstAccDate, 0);
;;;2825   				fp->flag &= ~FA__WRITTEN;
;;;2826   				fp->fs->wflag = 1;
;;;2827   				res = sync_fs(fp->fs);
;;;2828   			}
;;;2829   		}
;;;2830   	}
;;;2831   
;;;2832   	LEAVE_FF(fp->fs, res);
;;;2833   }
00002a  bd70              POP      {r4-r6,pc}
                  |L35.44|
00002c  79a0              LDRB     r0,[r4,#6]            ;2812
00002e  f0200040          BIC      r0,r0,#0x40           ;2812
000032  71a0              STRB     r0,[r4,#6]            ;2812
                  |L35.52|
000034  69e1              LDR      r1,[r4,#0x1c]         ;2816
000036  6820              LDR      r0,[r4,#0]            ;2816
000038  f7fffffe          BL       move_window
00003c  2800              CMP      r0,#0                 ;2817
00003e  d1f4              BNE      |L35.42|
000040  6a25              LDR      r5,[r4,#0x20]         ;2819
000042  7ae8              LDRB     r0,[r5,#0xb]          ;2819
000044  f0400020          ORR      r0,r0,#0x20           ;2819
000048  72e8              STRB     r0,[r5,#0xb]          ;2819
00004a  7b20              LDRB     r0,[r4,#0xc]          ;2820
00004c  7728              STRB     r0,[r5,#0x1c]         ;2820
00004e  89a0              LDRH     r0,[r4,#0xc]          ;2820
000050  0a00              LSRS     r0,r0,#8              ;2820
000052  7768              STRB     r0,[r5,#0x1d]         ;2820
000054  68e0              LDR      r0,[r4,#0xc]          ;2820
000056  0c00              LSRS     r0,r0,#16             ;2820
000058  77a8              STRB     r0,[r5,#0x1e]         ;2820
00005a  68e0              LDR      r0,[r4,#0xc]          ;2820
00005c  0e00              LSRS     r0,r0,#24             ;2820
00005e  77e8              STRB     r0,[r5,#0x1f]         ;2820
000060  4628              MOV      r0,r5                 ;2821
000062  6921              LDR      r1,[r4,#0x10]         ;2821
000064  f7fffffe          BL       st_clust
000068  f7fffffe          BL       get_fattime
00006c  75a8              STRB     r0,[r5,#0x16]         ;2823
00006e  0a01              LSRS     r1,r0,#8              ;2823
000070  75e9              STRB     r1,[r5,#0x17]         ;2823
000072  0c01              LSRS     r1,r0,#16             ;2823
000074  7629              STRB     r1,[r5,#0x18]         ;2823
000076  0e00              LSRS     r0,r0,#24             ;2823
000078  7668              STRB     r0,[r5,#0x19]         ;2823
00007a  2000              MOVS     r0,#0                 ;2824
00007c  74a8              STRB     r0,[r5,#0x12]         ;2824
00007e  74e8              STRB     r0,[r5,#0x13]         ;2824
000080  79a0              LDRB     r0,[r4,#6]            ;2825
000082  f0200020          BIC      r0,r0,#0x20           ;2825
000086  71a0              STRB     r0,[r4,#6]            ;2825
000088  6821              LDR      r1,[r4,#0]            ;2826
00008a  2001              MOVS     r0,#1                 ;2826
00008c  7108              STRB     r0,[r1,#4]            ;2826
00008e  6820              LDR      r0,[r4,#0]            ;2827
000090  e8bd4070          POP      {r4-r6,lr}            ;2827
000094  f7ffbffe          B.W      sync_fs
;;;2834   
                          ENDP


                          AREA ||i.f_truncate||, CODE, READONLY, ALIGN=1

                  f_truncate PROC
;;;3405   
;;;3406   FRESULT f_truncate (
000000  b570              PUSH     {r4-r6,lr}
;;;3407   	FIL* fp		/* Pointer to the file object */
;;;3408   )
;;;3409   {
000002  4604              MOV      r4,r0
;;;3410   	FRESULT res;
;;;3411   	DWORD ncl;
;;;3412   
;;;3413   
;;;3414   	res = validate(fp);						/* Check validity of the object */
000004  f7fffffe          BL       validate
000008  0005              MOVS     r5,r0
;;;3415   	if (res == FR_OK) {
00000a  d13d              BNE      |L36.136|
;;;3416   		if (fp->err) {						/* Check error */
00000c  79e0              LDRB     r0,[r4,#7]
00000e  b118              CBZ      r0,|L36.24|
;;;3417   			res = (FRESULT)fp->err;
000010  4605              MOV      r5,r0
;;;3418   		} else {
;;;3419   			if (!(fp->flag & FA_WRITE))		/* Check access mode */
;;;3420   				res = FR_DENIED;
;;;3421   		}
;;;3422   	}
;;;3423   	if (res == FR_OK) {
000012  0028              MOVS     r0,r5
000014  d005              BEQ      |L36.34|
000016  e037              B        |L36.136|
                  |L36.24|
000018  79a0              LDRB     r0,[r4,#6]            ;3419
00001a  0780              LSLS     r0,r0,#30             ;3419
00001c  d401              BMI      |L36.34|
00001e  2507              MOVS     r5,#7                 ;3420
000020  e032              B        |L36.136|
                  |L36.34|
000022  e9d40102          LDRD     r0,r1,[r4,#8]         ;3420
;;;3424   		if (fp->fsize > fp->fptr) {
000026  4281              CMP      r1,r0
000028  d92e              BLS      |L36.136|
;;;3425   			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
;;;3426   			fp->flag |= FA__WRITTEN;
00002a  60e0              STR      r0,[r4,#0xc]
00002c  79a1              LDRB     r1,[r4,#6]
00002e  f0410120          ORR      r1,r1,#0x20
000032  71a1              STRB     r1,[r4,#6]
;;;3427   			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
000034  b150              CBZ      r0,|L36.76|
;;;3428   				res = remove_chain(fp->fs, fp->sclust);
;;;3429   				fp->sclust = 0;
;;;3430   			} else {				/* When truncate a part of the file, remove remaining clusters */
;;;3431   				ncl = get_fat(fp->fs, fp->clust);
000036  6961              LDR      r1,[r4,#0x14]
000038  6820              LDR      r0,[r4,#0]
00003a  f7fffffe          BL       get_fat
00003e  4606              MOV      r6,r0
;;;3432   				res = FR_OK;
;;;3433   				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
000040  1c40              ADDS     r0,r0,#1
000042  d00b              BEQ      |L36.92|
;;;3434   				if (ncl == 1) res = FR_INT_ERR;
000044  2e01              CMP      r6,#1
000046  d00b              BEQ      |L36.96|
;;;3435   				if (res == FR_OK && ncl < fp->fs->n_fatent) {
000048  b165              CBZ      r5,|L36.100|
00004a  e01c              B        |L36.134|
                  |L36.76|
00004c  6921              LDR      r1,[r4,#0x10]         ;3428
00004e  6820              LDR      r0,[r4,#0]            ;3428
000050  f7fffffe          BL       remove_chain
000054  4605              MOV      r5,r0                 ;3428
000056  2000              MOVS     r0,#0                 ;3429
000058  6120              STR      r0,[r4,#0x10]         ;3429
00005a  e013              B        |L36.132|
                  |L36.92|
00005c  2501              MOVS     r5,#1                 ;3433
00005e  e012              B        |L36.134|
                  |L36.96|
000060  2502              MOVS     r5,#2                 ;3434
000062  e010              B        |L36.134|
                  |L36.100|
000064  6820              LDR      r0,[r4,#0]
000066  6981              LDR      r1,[r0,#0x18]
000068  42b1              CMP      r1,r6
00006a  d90f              BLS      |L36.140|
;;;3436   					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
00006c  f06f4270          MVN      r2,#0xf0000000
000070  6961              LDR      r1,[r4,#0x14]
000072  f7fffffe          BL       put_fat
000076  0005              MOVS     r5,r0
;;;3437   					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
000078  d105              BNE      |L36.134|
00007a  4631              MOV      r1,r6
00007c  6820              LDR      r0,[r4,#0]
00007e  f7fffffe          BL       remove_chain
000082  4605              MOV      r5,r0
                  |L36.132|
;;;3438   				}
;;;3439   			}
;;;3440   #if !_FS_TINY
;;;3441   			if (res == FR_OK && (fp->flag & FA__DIRTY)) {
000084  b115              CBZ      r5,|L36.140|
                  |L36.134|
;;;3442   				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
;;;3443   					res = FR_DISK_ERR;
;;;3444   				else
;;;3445   					fp->flag &= ~FA__DIRTY;
;;;3446   			}
;;;3447   #endif
;;;3448   		}
;;;3449   		if (res != FR_OK) fp->err = (FRESULT)res;
000086  71e5              STRB     r5,[r4,#7]
                  |L36.136|
;;;3450   	}
;;;3451   
;;;3452   	LEAVE_FF(fp->fs, res);
000088  4628              MOV      r0,r5
;;;3453   }
00008a  bd70              POP      {r4-r6,pc}
                  |L36.140|
00008c  79a0              LDRB     r0,[r4,#6]            ;3441
00008e  0640              LSLS     r0,r0,#25             ;3441
000090  d5fa              BPL      |L36.136|
000092  6820              LDR      r0,[r4,#0]            ;3442
000094  2301              MOVS     r3,#1                 ;3442
000096  f1040124          ADD      r1,r4,#0x24           ;3442
00009a  7840              LDRB     r0,[r0,#1]            ;3442
00009c  69a2              LDR      r2,[r4,#0x18]         ;3442
00009e  f7fffffe          BL       disk_write
0000a2  2800              CMP      r0,#0                 ;3442
0000a4  d1da              BNE      |L36.92|
0000a6  79a0              LDRB     r0,[r4,#6]            ;3445
0000a8  f0200040          BIC      r0,r0,#0x40           ;3445
0000ac  71a0              STRB     r0,[r4,#6]            ;3445
0000ae  e7eb              B        |L36.136|
;;;3454   
                          ENDP


                          AREA ||i.f_unlink||, CODE, READONLY, ALIGN=1

                  f_unlink PROC
;;;3461   
;;;3462   FRESULT f_unlink (
000000  b511              PUSH     {r0,r4,lr}
;;;3463   	const TCHAR* path		/* Pointer to the file or directory path */
;;;3464   )
;;;3465   {
000002  f5ad7d15          SUB      sp,sp,#0x254
;;;3466   	FRESULT res;
;;;3467   	DIR dj, sdj;
;;;3468   	BYTE *dir;
;;;3469   	DWORD dclst = 0;
000006  2400              MOVS     r4,#0
;;;3470   	DEF_NAMEBUF;
;;;3471   
;;;3472   
;;;3473   	/* Get logical drive number */
;;;3474   	res = find_volume(&dj.fs, &path, 1);
000008  2201              MOVS     r2,#1
00000a  a995              ADD      r1,sp,#0x254
00000c  a880              ADD      r0,sp,#0x200
00000e  f7fffffe          BL       find_volume
;;;3475   	if (res == FR_OK) {
000012  2800              CMP      r0,#0
000014  d114              BNE      |L37.64|
;;;3476   		INIT_BUF(dj);
000016  a892              ADD      r0,sp,#0x248
000018  9086              STR      r0,[sp,#0x218]
00001a  f8cdd21c          STR      sp,[sp,#0x21c]
;;;3477   		res = follow_path(&dj, path);		/* Follow the file path */
00001e  a880              ADD      r0,sp,#0x200
000020  9995              LDR      r1,[sp,#0x254]
000022  f7fffffe          BL       follow_path
;;;3478   		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT))
000026  2800              CMP      r0,#0
000028  d10a              BNE      |L37.64|
00002a  9886              LDR      r0,[sp,#0x218]
00002c  7ac0              LDRB     r0,[r0,#0xb]
00002e  0680              LSLS     r0,r0,#26
000030  d405              BMI      |L37.62|
;;;3479   			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
;;;3480   #if _FS_LOCK
;;;3481   		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open object */
;;;3482   #endif
;;;3483   		if (res == FR_OK) {					/* The object is accessible */
;;;3484   			dir = dj.dir;
;;;3485   			if (!dir) {
000032  9985              LDR      r1,[sp,#0x214]
000034  b119              CBZ      r1,|L37.62|
;;;3486   				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
;;;3487   			} else {
;;;3488   				if (dir[DIR_Attr] & AM_RDO)
000036  7ac8              LDRB     r0,[r1,#0xb]
000038  07c2              LSLS     r2,r0,#31
00003a  d120              BNE      |L37.126|
00003c  e003              B        |L37.70|
                  |L37.62|
00003e  2006              MOVS     r0,#6                 ;3479
                  |L37.64|
;;;3489   					res = FR_DENIED;		/* Cannot remove R/O object */
;;;3490   			}
;;;3491   			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
;;;3492   				dclst = ld_clust(dj.fs, dir);
;;;3493   				if (!dclst) {
;;;3494   					res = FR_INT_ERR;
;;;3495   				} else {					/* Make sure the sub-directory is empty */
;;;3496   					mem_cpy(&sdj, &dj, sizeof (DIR));
;;;3497   					sdj.sclust = dclst;
;;;3498   					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
;;;3499   					if (res == FR_OK) {
;;;3500   						res = dir_read(&sdj, 0);	/* Read an item */
;;;3501   						if (res == FR_OK		/* Not empty directory */
;;;3502   #if _FS_RPATH
;;;3503   						|| dclst == dj.fs->cdir	/* or current directory */
;;;3504   #endif
;;;3505   						) res = FR_DENIED;
;;;3506   						if (res == FR_NO_FILE) res = FR_OK;	/* It is empty */
;;;3507   					}
;;;3508   				}
;;;3509   			}
;;;3510   			if (res == FR_OK) {
;;;3511   				res = dir_remove(&dj);		/* Remove the directory entry */
;;;3512   				if (res == FR_OK && dclst)	/* Remove the cluster chain if exist */
;;;3513   					res = remove_chain(dj.fs, dclst);
;;;3514   				if (res == FR_OK) res = sync_fs(dj.fs);
;;;3515   			}
;;;3516   		}
;;;3517   		FREE_BUF();
;;;3518   	}
;;;3519   
;;;3520   	LEAVE_FF(dj.fs, res);
;;;3521   }
000040  f50d7d16          ADD      sp,sp,#0x258
000044  bd10              POP      {r4,pc}
                  |L37.70|
000046  06c0              LSLS     r0,r0,#27             ;3491
000048  d521              BPL      |L37.142|
00004a  9880              LDR      r0,[sp,#0x200]        ;3492
00004c  f7fffffe          BL       ld_clust
000050  0004              MOVS     r4,r0                 ;3492
000052  d016              BEQ      |L37.130|
000054  2224              MOVS     r2,#0x24              ;3496
000056  a980              ADD      r1,sp,#0x200          ;3496
000058  a889              ADD      r0,sp,#0x224          ;3496
00005a  f7fffffe          BL       mem_cpy
00005e  2102              MOVS     r1,#2                 ;3498
000060  a889              ADD      r0,sp,#0x224          ;3498
000062  948b              STR      r4,[sp,#0x22c]        ;3498
000064  f7fffffe          BL       dir_sdi
000068  2800              CMP      r0,#0                 ;3499
00006a  d1e9              BNE      |L37.64|
00006c  2100              MOVS     r1,#0                 ;3500
00006e  a889              ADD      r0,sp,#0x224          ;3500
000070  f7fffffe          BL       dir_read
000074  b118              CBZ      r0,|L37.126|
000076  9980              LDR      r1,[sp,#0x200]        ;3503
000078  6949              LDR      r1,[r1,#0x14]         ;3503
00007a  42a1              CMP      r1,r4                 ;3503
00007c  d103              BNE      |L37.134|
                  |L37.126|
00007e  2007              MOVS     r0,#7                 ;3505
000080  e7de              B        |L37.64|
                  |L37.130|
000082  2002              MOVS     r0,#2                 ;3494
000084  e7dc              B        |L37.64|
                  |L37.134|
000086  2804              CMP      r0,#4                 ;3506
000088  d001              BEQ      |L37.142|
00008a  2800              CMP      r0,#0                 ;3510
00008c  d1d8              BNE      |L37.64|
                  |L37.142|
00008e  a880              ADD      r0,sp,#0x200          ;3511
000090  f7fffffe          BL       dir_remove
000094  2800              CMP      r0,#0                 ;3512
000096  d1d3              BNE      |L37.64|
000098  b12c              CBZ      r4,|L37.166|
00009a  4621              MOV      r1,r4                 ;3513
00009c  9880              LDR      r0,[sp,#0x200]        ;3513
00009e  f7fffffe          BL       remove_chain
0000a2  2800              CMP      r0,#0                 ;3513
0000a4  d1cc              BNE      |L37.64|
                  |L37.166|
0000a6  9880              LDR      r0,[sp,#0x200]        ;3514
0000a8  f7fffffe          BL       sync_fs
0000ac  e7c8              B        |L37.64|
;;;3522   
                          ENDP


                          AREA ||i.f_utime||, CODE, READONLY, ALIGN=1

                  f_utime PROC
;;;3724   
;;;3725   FRESULT f_utime (
000000  b513              PUSH     {r0,r1,r4,lr}
;;;3726   	const TCHAR* path,	/* Pointer to the file/directory name */
;;;3727   	const FILINFO* fno	/* Pointer to the time stamp to be set */
;;;3728   )
;;;3729   {
000002  f5ad7d0c          SUB      sp,sp,#0x230
000006  460c              MOV      r4,r1
;;;3730   	FRESULT res;
;;;3731   	DIR dj;
;;;3732   	BYTE *dir;
;;;3733   	DEF_NAMEBUF;
;;;3734   
;;;3735   
;;;3736   	/* Get logical drive number */
;;;3737   	res = find_volume(&dj.fs, &path, 1);
000008  2201              MOVS     r2,#1
00000a  a98c              ADD      r1,sp,#0x230
00000c  a880              ADD      r0,sp,#0x200
00000e  f7fffffe          BL       find_volume
;;;3738   	if (res == FR_OK) {
000012  2800              CMP      r0,#0
000014  d11f              BNE      |L38.86|
;;;3739   		INIT_BUF(dj);
000016  a889              ADD      r0,sp,#0x224
000018  9086              STR      r0,[sp,#0x218]
00001a  f8cdd21c          STR      sp,[sp,#0x21c]
;;;3740   		res = follow_path(&dj, path);	/* Follow the file path */
00001e  a880              ADD      r0,sp,#0x200
000020  998c              LDR      r1,[sp,#0x230]
000022  f7fffffe          BL       follow_path
;;;3741   		FREE_BUF();
;;;3742   		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT))
000026  2800              CMP      r0,#0
000028  d115              BNE      |L38.86|
00002a  9886              LDR      r0,[sp,#0x218]
00002c  7ac0              LDRB     r0,[r0,#0xb]
00002e  0680              LSLS     r0,r0,#26
000030  d414              BMI      |L38.92|
;;;3743   			res = FR_INVALID_NAME;
;;;3744   		if (res == FR_OK) {
;;;3745   			dir = dj.dir;
;;;3746   			if (!dir) {					/* Root directory */
000032  9885              LDR      r0,[sp,#0x214]
000034  b190              CBZ      r0,|L38.92|
;;;3747   				res = FR_INVALID_NAME;
;;;3748   			} else {					/* File or sub-directory */
;;;3749   				ST_WORD(dir+DIR_WrtTime, fno->ftime);
000036  79a1              LDRB     r1,[r4,#6]
000038  7581              STRB     r1,[r0,#0x16]
00003a  88e1              LDRH     r1,[r4,#6]
00003c  0a09              LSRS     r1,r1,#8
00003e  75c1              STRB     r1,[r0,#0x17]
;;;3750   				ST_WORD(dir+DIR_WrtDate, fno->fdate);
000040  7921              LDRB     r1,[r4,#4]
000042  7601              STRB     r1,[r0,#0x18]
000044  88a1              LDRH     r1,[r4,#4]
000046  0a09              LSRS     r1,r1,#8
000048  7641              STRB     r1,[r0,#0x19]
;;;3751   				dj.fs->wflag = 1;
00004a  9980              LDR      r1,[sp,#0x200]
00004c  2001              MOVS     r0,#1
00004e  7108              STRB     r0,[r1,#4]
;;;3752   				res = sync_fs(dj.fs);
000050  9880              LDR      r0,[sp,#0x200]
000052  f7fffffe          BL       sync_fs
                  |L38.86|
;;;3753   			}
;;;3754   		}
;;;3755   	}
;;;3756   
;;;3757   	LEAVE_FF(dj.fs, res);
;;;3758   }
000056  f50d7d0e          ADD      sp,sp,#0x238
00005a  bd10              POP      {r4,pc}
                  |L38.92|
00005c  2006              MOVS     r0,#6                 ;3747
00005e  e7fa              B        |L38.86|
;;;3759   
                          ENDP


                          AREA ||i.f_write||, CODE, READONLY, ALIGN=1

                  f_write PROC
;;;2672   
;;;2673   FRESULT f_write (
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;2674   	FIL* fp,			/* Pointer to the file object */
;;;2675   	const void *buff,	/* Pointer to the data to be written */
;;;2676   	UINT btw,			/* Number of bytes to write */
;;;2677   	UINT* bw			/* Pointer to number of bytes written */
;;;2678   )
;;;2679   {
;;;2680   	FRESULT res;
;;;2681   	DWORD clst, sect;
;;;2682   	UINT wcnt, cc;
;;;2683   	const BYTE *wbuff = (const BYTE*)buff;
000004  4689              MOV      r9,r1
;;;2684   	BYTE csect;
;;;2685   
;;;2686   
;;;2687   	*bw = 0;	/* Clear write byte counter */
000006  2100              MOVS     r1,#0
000008  469a              MOV      r10,r3                ;2679
00000a  4615              MOV      r5,r2                 ;2679
00000c  4604              MOV      r4,r0                 ;2679
;;;2688   
;;;2689   	res = validate(fp);						/* Check validity */
00000e  6019              STR      r1,[r3,#0]
000010  f7fffffe          BL       validate
;;;2690   	if (res != FR_OK) LEAVE_FF(fp->fs, res);
000014  2800              CMP      r0,#0
000016  d106              BNE      |L39.38|
;;;2691   	if (fp->err)							/* Check error */
000018  79e0              LDRB     r0,[r4,#7]
00001a  2800              CMP      r0,#0
00001c  d103              BNE      |L39.38|
;;;2692   		LEAVE_FF(fp->fs, (FRESULT)fp->err);
;;;2693   	if (!(fp->flag & FA_WRITE))				/* Check access mode */
00001e  79a0              LDRB     r0,[r4,#6]
000020  0780              LSLS     r0,r0,#30
000022  d402              BMI      |L39.42|
;;;2694   		LEAVE_FF(fp->fs, FR_DENIED);
000024  2007              MOVS     r0,#7
                  |L39.38|
;;;2695   	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
;;;2696   
;;;2697   	for ( ;  btw;							/* Repeat until all data written */
;;;2698   		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
;;;2699   		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
;;;2700   			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
;;;2701   			if (!csect) {					/* On the cluster boundary? */
;;;2702   				if (fp->fptr == 0) {		/* On the top of the file? */
;;;2703   					clst = fp->sclust;		/* Follow from the origin */
;;;2704   					if (clst == 0)			/* When no cluster is allocated, */
;;;2705   						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
;;;2706   				} else {					/* Middle or end of the file */
;;;2707   #if _USE_FASTSEEK
;;;2708   					if (fp->cltbl)
;;;2709   						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
;;;2710   					else
;;;2711   #endif
;;;2712   						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
;;;2713   				}
;;;2714   				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
;;;2715   				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
;;;2716   				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;2717   				fp->clust = clst;			/* Update current cluster */
;;;2718   				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
;;;2719   			}
;;;2720   #if _FS_TINY
;;;2721   			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
;;;2722   				ABORT(fp->fs, FR_DISK_ERR);
;;;2723   #else
;;;2724   			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
;;;2725   				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
;;;2726   					ABORT(fp->fs, FR_DISK_ERR);
;;;2727   				fp->flag &= ~FA__DIRTY;
;;;2728   			}
;;;2729   #endif
;;;2730   			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
;;;2731   			if (!sect) ABORT(fp->fs, FR_INT_ERR);
;;;2732   			sect += csect;
;;;2733   			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
;;;2734   			if (cc) {						/* Write maximum contiguous sectors directly */
;;;2735   				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
;;;2736   					cc = fp->fs->csize - csect;
;;;2737   				if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
;;;2738   					ABORT(fp->fs, FR_DISK_ERR);
;;;2739   #if _FS_MINIMIZE <= 2
;;;2740   #if _FS_TINY
;;;2741   				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
;;;2742   					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
;;;2743   					fp->fs->wflag = 0;
;;;2744   				}
;;;2745   #else
;;;2746   				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
;;;2747   					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
;;;2748   					fp->flag &= ~FA__DIRTY;
;;;2749   				}
;;;2750   #endif
;;;2751   #endif
;;;2752   				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
;;;2753   				continue;
;;;2754   			}
;;;2755   #if _FS_TINY
;;;2756   			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
;;;2757   				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
;;;2758   				fp->fs->winsect = sect;
;;;2759   			}
;;;2760   #else
;;;2761   			if (fp->dsect != sect) {		/* Fill sector cache with file data */
;;;2762   				if (fp->fptr < fp->fsize &&
;;;2763   					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
;;;2764   						ABORT(fp->fs, FR_DISK_ERR);
;;;2765   			}
;;;2766   #endif
;;;2767   			fp->dsect = sect;
;;;2768   		}
;;;2769   		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
;;;2770   		if (wcnt > btw) wcnt = btw;
;;;2771   #if _FS_TINY
;;;2772   		if (move_window(fp->fs, fp->dsect) != FR_OK)	/* Move sector window */
;;;2773   			ABORT(fp->fs, FR_DISK_ERR);
;;;2774   		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
;;;2775   		fp->fs->wflag = 1;
;;;2776   #else
;;;2777   		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
;;;2778   		fp->flag |= FA__DIRTY;
;;;2779   #endif
;;;2780   	}
;;;2781   
;;;2782   	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
;;;2783   	fp->flag |= FA__WRITTEN;						/* Set file change flag */
;;;2784   
;;;2785   	LEAVE_FF(fp->fs, FR_OK);
;;;2786   }
000026  e8bd8ff8          POP      {r3-r11,pc}
                  |L39.42|
00002a  68a0              LDR      r0,[r4,#8]            ;2695
00002c  f1040124          ADD      r1,r4,#0x24           ;2725
000030  1942              ADDS     r2,r0,r5              ;2695
000032  f04f0b01          MOV      r11,#1                ;2681
000036  9100              STR      r1,[sp,#0]            ;2695
000038  4282              CMP      r2,r0                 ;2695
00003a  d376              BCC      |L39.298|
00003c  e09c              B        |L39.376|
                  |L39.62|
00003e  6822              LDR      r2,[r4,#0]            ;2699
000040  68a0              LDR      r0,[r4,#8]            ;2699
000042  8951              LDRH     r1,[r2,#0xa]          ;2699
000044  fbb0f3f1          UDIV     r3,r0,r1              ;2699
000048  fb010313          MLS      r3,r1,r3,r0           ;2699
00004c  2b00              CMP      r3,#0                 ;2699
00004e  d170              BNE      |L39.306|
000050  fbb0f1f1          UDIV     r1,r0,r1              ;2700
000054  7893              LDRB     r3,[r2,#2]            ;2700
000056  1e5b              SUBS     r3,r3,#1              ;2700
000058  4019              ANDS     r1,r1,r3              ;2700
00005a  f01106ff          ANDS     r6,r1,#0xff           ;2700
00005e  d112              BNE      |L39.134|
000060  b108              CBZ      r0,|L39.102|
000062  6961              LDR      r1,[r4,#0x14]         ;2712
000064  e002              B        |L39.108|
                  |L39.102|
000066  6920              LDR      r0,[r4,#0x10]         ;2704
000068  b928              CBNZ     r0,|L39.118|
00006a  2100              MOVS     r1,#0                 ;2705
                  |L39.108|
00006c  4610              MOV      r0,r2                 ;2705
00006e  f7fffffe          BL       create_chain
000072  2800              CMP      r0,#0                 ;2714
000074  d059              BEQ      |L39.298|
                  |L39.118|
000076  2801              CMP      r0,#1                 ;2715
000078  d02d              BEQ      |L39.214|
00007a  1c41              ADDS     r1,r0,#1              ;2716
00007c  d051              BEQ      |L39.290|
00007e  6160              STR      r0,[r4,#0x14]         ;2718
000080  6921              LDR      r1,[r4,#0x10]         ;2718
000082  b901              CBNZ     r1,|L39.134|
000084  6120              STR      r0,[r4,#0x10]         ;2718
                  |L39.134|
000086  79a0              LDRB     r0,[r4,#6]            ;2724
000088  0640              LSLS     r0,r0,#25             ;2724
00008a  d50b              BPL      |L39.164|
00008c  6820              LDR      r0,[r4,#0]            ;2725
00008e  2301              MOVS     r3,#1                 ;2725
000090  69a2              LDR      r2,[r4,#0x18]         ;2725
000092  7840              LDRB     r0,[r0,#1]            ;2725
000094  9900              LDR      r1,[sp,#0]            ;2725
000096  f7fffffe          BL       disk_write
00009a  bb98              CBNZ     r0,|L39.260|
00009c  79a0              LDRB     r0,[r4,#6]            ;2727
00009e  f0200040          BIC      r0,r0,#0x40           ;2727
0000a2  71a0              STRB     r0,[r4,#6]            ;2727
                  |L39.164|
0000a4  6961              LDR      r1,[r4,#0x14]         ;2730
0000a6  6820              LDR      r0,[r4,#0]            ;2730
0000a8  f7fffffe          BL       clust2sect
0000ac  b198              CBZ      r0,|L39.214|
0000ae  eb000806          ADD      r8,r0,r6              ;2732
0000b2  6820              LDR      r0,[r4,#0]            ;2733
0000b4  8941              LDRH     r1,[r0,#0xa]          ;2733
0000b6  fbb5f7f1          UDIV     r7,r5,r1              ;2733
0000ba  b327              CBZ      r7,|L39.262|
0000bc  7881              LDRB     r1,[r0,#2]            ;2735
0000be  19f2              ADDS     r2,r6,r7              ;2735
0000c0  428a              CMP      r2,r1                 ;2735
0000c2  d900              BLS      |L39.198|
0000c4  1b8f              SUBS     r7,r1,r6              ;2736
                  |L39.198|
0000c6  7840              LDRB     r0,[r0,#1]            ;2737
0000c8  463b              MOV      r3,r7                 ;2737
0000ca  4642              MOV      r2,r8                 ;2737
0000cc  4649              MOV      r1,r9                 ;2737
0000ce  f7fffffe          BL       disk_write
0000d2  b9b8              CBNZ     r0,|L39.260|
0000d4  e002              B        |L39.220|
                  |L39.214|
0000d6  2002              MOVS     r0,#2                 ;2731
0000d8  71e0              STRB     r0,[r4,#7]            ;2731
0000da  e7a4              B        |L39.38|
                  |L39.220|
0000dc  69a1              LDR      r1,[r4,#0x18]         ;2746
0000de  eba10008          SUB      r0,r1,r8              ;2746
0000e2  42b8              CMP      r0,r7                 ;2746
0000e4  d20a              BCS      |L39.252|
0000e6  6821              LDR      r1,[r4,#0]            ;2747
0000e8  894a              LDRH     r2,[r1,#0xa]          ;2747
0000ea  fb009102          MLA      r1,r0,r2,r9           ;2747
0000ee  9800              LDR      r0,[sp,#0]            ;2747
0000f0  f7fffffe          BL       mem_cpy
0000f4  79a0              LDRB     r0,[r4,#6]            ;2748
0000f6  f0200040          BIC      r0,r0,#0x40           ;2748
0000fa  71a0              STRB     r0,[r4,#6]            ;2748
                  |L39.252|
0000fc  6820              LDR      r0,[r4,#0]            ;2752
0000fe  8946              LDRH     r6,[r0,#0xa]          ;2752
000100  437e              MULS     r6,r7,r6              ;2752
000102  e02f              B        |L39.356|
                  |L39.260|
000104  e00d              B        |L39.290|
                  |L39.262|
000106  69a2              LDR      r2,[r4,#0x18]         ;2761
000108  4542              CMP      r2,r8                 ;2761
00010a  d010              BEQ      |L39.302|
00010c  e9d41202          LDRD     r1,r2,[r4,#8]         ;2761
000110  4291              CMP      r1,r2                 ;2762
000112  d20c              BCS      |L39.302|
000114  7840              LDRB     r0,[r0,#1]            ;2763
000116  2301              MOVS     r3,#1                 ;2763
000118  4642              MOV      r2,r8                 ;2763
00011a  9900              LDR      r1,[sp,#0]            ;2763
00011c  f7fffffe          BL       disk_read
000120  b128              CBZ      r0,|L39.302|
                  |L39.290|
000122  f884b007          STRB     r11,[r4,#7]           ;2764
000126  2001              MOVS     r0,#1                 ;2764
000128  e77d              B        |L39.38|
                  |L39.298|
00012a  e028              B        |L39.382|
00012c  e001              B        |L39.306|
                  |L39.302|
00012e  f8c48018          STR      r8,[r4,#0x18]         ;2767
                  |L39.306|
000132  6820              LDR      r0,[r4,#0]            ;2769
000134  68a1              LDR      r1,[r4,#8]            ;2769
000136  8940              LDRH     r0,[r0,#0xa]          ;2769
000138  fbb1f2f0          UDIV     r2,r1,r0              ;2769
00013c  fb001212          MLS      r2,r0,r2,r1           ;2769
000140  1a86              SUBS     r6,r0,r2              ;2769
000142  42ae              CMP      r6,r5                 ;2770
000144  d900              BLS      |L39.328|
000146  462e              MOV      r6,r5                 ;2770
                  |L39.328|
000148  fbb1f2f0          UDIV     r2,r1,r0              ;2777
00014c  fb001012          MLS      r0,r0,r2,r1           ;2777
000150  4420              ADD      r0,r0,r4              ;2777
000152  4632              MOV      r2,r6                 ;2777
000154  4649              MOV      r1,r9                 ;2777
000156  3024              ADDS     r0,r0,#0x24           ;2777
000158  f7fffffe          BL       mem_cpy
00015c  79a0              LDRB     r0,[r4,#6]            ;2778
00015e  f0400040          ORR      r0,r0,#0x40           ;2778
000162  71a0              STRB     r0,[r4,#6]            ;2778
                  |L39.356|
000164  68a0              LDR      r0,[r4,#8]            ;2698
000166  44b1              ADD      r9,r9,r6              ;2698
000168  4430              ADD      r0,r0,r6              ;2698
00016a  60a0              STR      r0,[r4,#8]            ;2698
00016c  f8da0000          LDR      r0,[r10,#0]           ;2698
000170  1981              ADDS     r1,r0,r6              ;2698
000172  1bad              SUBS     r5,r5,r6              ;2698
000174  f8ca1000          STR      r1,[r10,#0]           ;2698
                  |L39.376|
000178  2d00              CMP      r5,#0                 ;2697
00017a  f47faf60          BNE      |L39.62|
                  |L39.382|
00017e  e9d40102          LDRD     r0,r1,[r4,#8]         ;2697
000182  4288              CMP      r0,r1                 ;2782
000184  d900              BLS      |L39.392|
000186  60e0              STR      r0,[r4,#0xc]          ;2782
                  |L39.392|
000188  79a0              LDRB     r0,[r4,#6]            ;2783
00018a  f0400020          ORR      r0,r0,#0x20           ;2783
00018e  71a0              STRB     r0,[r4,#6]            ;2783
000190  2000              MOVS     r0,#0                 ;2785
000192  e748              B        |L39.38|
;;;2787   
                          ENDP


                          AREA ||i.find_volume||, CODE, READONLY, ALIGN=2

                  find_volume PROC
;;;2185   static
;;;2186   FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;2187   	FATFS** rfs,		/* Pointer to pointer to the found file system object */
;;;2188   	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
;;;2189   	BYTE wmode			/* !=0: Check write protection for write access */
;;;2190   )
;;;2191   {
;;;2192   	BYTE fmt;
;;;2193   	int vol;
;;;2194   	DSTATUS stat;
;;;2195   	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
;;;2196   	WORD nrsv;
;;;2197   	FATFS *fs;
;;;2198   
;;;2199   
;;;2200   	/* Get logical drive number from the path name */
;;;2201   	*rfs = 0;
000004  f04f0900          MOV      r9,#0
000008  4607              MOV      r7,r0                 ;2191
;;;2202   	vol = get_ldnumber(path);
00000a  f8c09000          STR      r9,[r0,#0]
00000e  4616              MOV      r6,r2                 ;2191
000010  4608              MOV      r0,r1
000012  f7fffffe          BL       get_ldnumber
000016  0005              MOVS     r5,r0
;;;2203   	if (vol < 0) return FR_INVALID_DRIVE;
000018  d503              BPL      |L40.34|
00001a  200b              MOVS     r0,#0xb
                  |L40.28|
;;;2204   
;;;2205   	/* Check if the file system object is valid or not */
;;;2206   	fs = FatFs[vol];					/* Get pointer to the file system object */
;;;2207   	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
;;;2208   
;;;2209   	ENTER_FF(fs);						/* Lock the volume */
;;;2210   	*rfs = fs;							/* Return pointer to the file system object */
;;;2211   
;;;2212   	if (fs->fs_type) {					/* If the volume has been mounted */
;;;2213   		stat = disk_status(fs->drv);
;;;2214   		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
;;;2215   			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
;;;2216   				return FR_WRITE_PROTECTED;
;;;2217   			return FR_OK;				/* The file system object is valid */
;;;2218   		}
;;;2219   	}
;;;2220   
;;;2221   	/* The file system object is not valid. */
;;;2222   	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
;;;2223   
;;;2224   	fs->fs_type = 0;					/* Clear the file system object */
;;;2225   	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
;;;2226   	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
;;;2227   	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
;;;2228   		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
;;;2229   	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
;;;2230   		return FR_WRITE_PROTECTED;
;;;2231   #if _MAX_SS != _MIN_SS						/* Get sector size (multiple sector size cfg only) */
;;;2232   	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
;;;2233   		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
;;;2234   #endif
;;;2235   	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
;;;2236   	bsect = 0;
;;;2237   	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
;;;2238   	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
;;;2239   		UINT i;
;;;2240   		DWORD br[4];
;;;2241   
;;;2242   		for (i = 0; i < 4; i++) {			/* Get partition offset */
;;;2243   			BYTE *pt = fs->win+MBR_Table + i * SZ_PTE;
;;;2244   			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
;;;2245   		}
;;;2246   		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
;;;2247   		if (i) i--;
;;;2248   		do {								/* Find an FAT volume */
;;;2249   			bsect = br[i];
;;;2250   			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
;;;2251   		} while (!LD2PT(vol) && fmt && ++i < 4);
;;;2252   	}
;;;2253   	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
;;;2254   	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
;;;2255   
;;;2256   	/* An FAT volume is found. Following code initializes the file system object */
;;;2257   
;;;2258   	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
;;;2259   		return FR_NO_FILESYSTEM;
;;;2260   
;;;2261   	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
;;;2262   	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
;;;2263   	fs->fsize = fasize;
;;;2264   
;;;2265   	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
;;;2266   	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
;;;2267   		return FR_NO_FILESYSTEM;
;;;2268   	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
;;;2269   
;;;2270   	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
;;;2271   	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
;;;2272   		return FR_NO_FILESYSTEM;
;;;2273   
;;;2274   	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
;;;2275   	if (fs->n_rootdir % (SS(fs) / SZ_DIR))				/* (Must be sector aligned) */
;;;2276   		return FR_NO_FILESYSTEM;
;;;2277   
;;;2278   	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
;;;2279   	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
;;;2280   
;;;2281   	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
;;;2282   	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
;;;2283   
;;;2284   	/* Determine the FAT sub type */
;;;2285   	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
;;;2286   	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
;;;2287   	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
;;;2288   	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
;;;2289   	fmt = FS_FAT12;
;;;2290   	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
;;;2291   	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
;;;2292   
;;;2293   	/* Boundaries and Limits */
;;;2294   	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
;;;2295   	fs->volbase = bsect;								/* Volume start sector */
;;;2296   	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
;;;2297   	fs->database = bsect + sysect;						/* Data start sector */
;;;2298   	if (fmt == FS_FAT32) {
;;;2299   		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
;;;2300   		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
;;;2301   		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
;;;2302   	} else {
;;;2303   		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
;;;2304   		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
;;;2305   		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
;;;2306   			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
;;;2307   	}
;;;2308   	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
;;;2309   		return FR_NO_FILESYSTEM;
;;;2310   
;;;2311   #if !_FS_READONLY
;;;2312   	/* Initialize cluster allocation information */
;;;2313   	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
;;;2314   
;;;2315   	/* Get fsinfo if available */
;;;2316   	fs->fsi_flag = 0x80;
;;;2317   #if (_FS_NOFSINFO & 3) != 3
;;;2318   	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
;;;2319   		&& LD_WORD(fs->win+BPB_FSInfo) == 1
;;;2320   		&& move_window(fs, bsect + 1) == FR_OK)
;;;2321   	{
;;;2322   		fs->fsi_flag = 0;
;;;2323   		if (LD_WORD(fs->win+BS_55AA) == 0xAA55	/* Load FSINFO data if available */
;;;2324   			&& LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252
;;;2325   			&& LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272)
;;;2326   		{
;;;2327   #if (_FS_NOFSINFO & 1) == 0
;;;2328   			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
;;;2329   #endif
;;;2330   #if (_FS_NOFSINFO & 2) == 0
;;;2331   			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
;;;2332   #endif
;;;2333   		}
;;;2334   	}
;;;2335   #endif
;;;2336   #endif
;;;2337   	fs->fs_type = fmt;	/* FAT sub-type */
;;;2338   	fs->id = ++Fsid;	/* File system mount ID */
;;;2339   #if _FS_RPATH
;;;2340   	fs->cdir = 0;		/* Set current directory to root */
;;;2341   #endif
;;;2342   #if _FS_LOCK			/* Clear file lock semaphores */
;;;2343   	clear_lock(fs);
;;;2344   #endif
;;;2345   
;;;2346   	return FR_OK;
;;;2347   }
00001c  b004              ADD      sp,sp,#0x10
00001e  e8bd87f0          POP      {r4-r10,pc}
                  |L40.34|
000022  488e              LDR      r0,|L40.604|
000024  f8504025          LDR      r4,[r0,r5,LSL #2]     ;2206
000028  b18c              CBZ      r4,|L40.78|
00002a  603c              STR      r4,[r7,#0]            ;2212
00002c  7820              LDRB     r0,[r4,#0]            ;2212
00002e  b120              CBZ      r0,|L40.58|
000030  7860              LDRB     r0,[r4,#1]            ;2213
000032  f7fffffe          BL       disk_status
000036  07c1              LSLS     r1,r0,#31             ;2214
000038  d00b              BEQ      |L40.82|
                  |L40.58|
00003a  f8849000          STRB     r9,[r4,#0]            ;2224
00003e  b2e8              UXTB     r0,r5                 ;2225
000040  7060              STRB     r0,[r4,#1]            ;2225
000042  f7fffffe          BL       disk_initialize
000046  07c1              LSLS     r1,r0,#31             ;2227
000048  d008              BEQ      |L40.92|
00004a  2003              MOVS     r0,#3                 ;2228
00004c  e7e6              B        |L40.28|
                  |L40.78|
00004e  200c              MOVS     r0,#0xc               ;2207
000050  e7e4              B        |L40.28|
                  |L40.82|
000052  b10e              CBZ      r6,|L40.88|
000054  0740              LSLS     r0,r0,#29             ;2215
000056  d404              BMI      |L40.98|
                  |L40.88|
000058  2000              MOVS     r0,#0                 ;2217
00005a  e7df              B        |L40.28|
                  |L40.92|
00005c  b11e              CBZ      r6,|L40.102|
00005e  0740              LSLS     r0,r0,#29             ;2229
000060  d501              BPL      |L40.102|
                  |L40.98|
000062  200a              MOVS     r0,#0xa               ;2230
000064  e7da              B        |L40.28|
                  |L40.102|
000066  7860              LDRB     r0,[r4,#1]            ;2232
000068  f104020a          ADD      r2,r4,#0xa            ;2232
00006c  2102              MOVS     r1,#2                 ;2232
00006e  f7fffffe          BL       disk_ioctl
000072  bba0              CBNZ     r0,|L40.222|
000074  8960              LDRH     r0,[r4,#0xa]          ;2233
000076  f5b07f00          CMP      r0,#0x200             ;2233
00007a  d331              BCC      |L40.224|
00007c  f5b05f80          CMP      r0,#0x1000            ;2233
000080  d82e              BHI      |L40.224|
000082  2500              MOVS     r5,#0                 ;2236
000084  4629              MOV      r1,r5                 ;2237
000086  4620              MOV      r0,r4                 ;2237
000088  f7fffffe          BL       check_fs
00008c  2801              CMP      r0,#1                 ;2238
00008e  d122              BNE      |L40.214|
000090  2000              MOVS     r0,#0                 ;2242
000092  466e              MOV      r6,sp                 ;2240
                  |L40.148|
000094  eb041100          ADD      r1,r4,r0,LSL #4       ;2243
000098  f89121f6          LDRB     r2,[r1,#0x1f6]        ;2244
00009c  f50171f9          ADD      r1,r1,#0x1f2          ;2244
0000a0  b12a              CBZ      r2,|L40.174|
0000a2  7a0a              LDRB     r2,[r1,#8]            ;2244
0000a4  f8d11009          LDR      r1,[r1,#9]            ;2244
0000a8  ea422101          ORR      r1,r2,r1,LSL #8       ;2244
0000ac  e000              B        |L40.176|
                  |L40.174|
0000ae  2100              MOVS     r1,#0                 ;2244
                  |L40.176|
0000b0  f8461020          STR      r1,[r6,r0,LSL #2]     ;2244
0000b4  1c40              ADDS     r0,r0,#1              ;2244
0000b6  2804              CMP      r0,#4                 ;2242
0000b8  d3ec              BCC      |L40.148|
0000ba  2700              MOVS     r7,#0                 ;2246
                  |L40.188|
0000bc  f8565027          LDR      r5,[r6,r7,LSL #2]     ;2249
0000c0  b125              CBZ      r5,|L40.204|
0000c2  4629              MOV      r1,r5                 ;2250
0000c4  4620              MOV      r0,r4                 ;2250
0000c6  f7fffffe          BL       check_fs
0000ca  e000              B        |L40.206|
                  |L40.204|
0000cc  2002              MOVS     r0,#2                 ;2250
                  |L40.206|
0000ce  b148              CBZ      r0,|L40.228|
0000d0  1c7f              ADDS     r7,r7,#1              ;2251
0000d2  2f04              CMP      r7,#4                 ;2251
0000d4  d3f2              BCC      |L40.188|
                  |L40.214|
0000d6  2803              CMP      r0,#3                 ;2253
0000d8  d002              BEQ      |L40.224|
0000da  bbe8              CBNZ     r0,|L40.344|
0000dc  e002              B        |L40.228|
                  |L40.222|
0000de  e7ff              B        |L40.224|
                  |L40.224|
0000e0  2001              MOVS     r0,#1                 ;2253
0000e2  e79b              B        |L40.28|
                  |L40.228|
0000e4  f8b4003f          LDRH     r0,[r4,#0x3f]         ;2258
0000e8  8962              LDRH     r2,[r4,#0xa]          ;2258
0000ea  4290              CMP      r0,r2                 ;2258
0000ec  d163              BNE      |L40.438|
0000ee  f8b4004a          LDRH     r0,[r4,#0x4a]         ;2261
0000f2  b928              CBNZ     r0,|L40.256|
0000f4  f8940058          LDRB     r0,[r4,#0x58]         ;2262
0000f8  f8d41059          LDR      r1,[r4,#0x59]         ;2262
0000fc  ea402001          ORR      r0,r0,r1,LSL #8       ;2262
                  |L40.256|
000100  61e0              STR      r0,[r4,#0x1c]         ;2265
000102  f8947044          LDRB     r7,[r4,#0x44]         ;2265
000106  4682              MOV      r10,r0                ;2263
000108  70e7              STRB     r7,[r4,#3]            ;2265
00010a  2f01              CMP      r7,#1                 ;2266
00010c  d001              BEQ      |L40.274|
00010e  2f02              CMP      r7,#2                 ;2266
000110  d151              BNE      |L40.438|
                  |L40.274|
000112  f8946041          LDRB     r6,[r4,#0x41]         ;2270
000116  4347              MULS     r7,r0,r7              ;2268
000118  70a6              STRB     r6,[r4,#2]            ;2270
00011a  b1ee              CBZ      r6,|L40.344|
00011c  1e70              SUBS     r0,r6,#1              ;2271
00011e  4206              TST      r6,r0                 ;2271
000120  d149              BNE      |L40.438|
000122  f8b41045          LDRH     r1,[r4,#0x45]         ;2274
000126  ea4f1c52          LSR      r12,r2,#5             ;2275
00012a  fbb1f0fc          UDIV     r0,r1,r12             ;2275
00012e  fb0c1010          MLS      r0,r12,r0,r1          ;2275
000132  8121              STRH     r1,[r4,#8]            ;2274
000134  b980              CBNZ     r0,|L40.344|
000136  f8b40047          LDRH     r0,[r4,#0x47]         ;2278
00013a  b928              CBNZ     r0,|L40.328|
00013c  f8940054          LDRB     r0,[r4,#0x54]         ;2279
000140  f8d43055          LDR      r3,[r4,#0x55]         ;2279
000144  ea402003          ORR      r0,r0,r3,LSL #8       ;2279
                  |L40.328|
000148  f8b43042          LDRH     r3,[r4,#0x42]         ;2281
00014c  b123              CBZ      r3,|L40.344|
00014e  fbb1fcfc          UDIV     r12,r1,r12            ;2285
000152  eb030807          ADD      r8,r3,r7              ;2285
000156  e000              B        |L40.346|
                  |L40.344|
000158  e02d              B        |L40.438|
                  |L40.346|
00015a  44c4              ADD      r12,r12,r8            ;2285
00015c  4560              CMP      r0,r12                ;2286
00015e  d32a              BCC      |L40.438|
000160  eba0000c          SUB      r0,r0,r12             ;2287
000164  fbb0f0f6          UDIV     r0,r0,r6              ;2287
000168  b328              CBZ      r0,|L40.438|
00016a  2601              MOVS     r6,#1                 ;2289
00016c  f64078f6          MOV      r8,#0xff6             ;2290
000170  4540              CMP      r0,r8                 ;2290
000172  d300              BCC      |L40.374|
000174  2602              MOVS     r6,#2                 ;2290
                  |L40.374|
000176  f64f78f6          MOV      r8,#0xfff6            ;2291
00017a  4540              CMP      r0,r8                 ;2291
00017c  d300              BCC      |L40.384|
00017e  2603              MOVS     r6,#3                 ;2291
                  |L40.384|
000180  1c80              ADDS     r0,r0,#2              ;2291
000182  44ac              ADD      r12,r12,r5            ;2297
000184  f8c4c02c          STR      r12,[r4,#0x2c]        ;2298
000188  442b              ADD      r3,r3,r5              ;2296
00018a  61a0              STR      r0,[r4,#0x18]         ;2298
00018c  e9c45308          STRD     r5,r3,[r4,#0x20]      ;2298
000190  2e03              CMP      r6,#3                 ;2298
000192  d012              BEQ      |L40.442|
000194  b179              CBZ      r1,|L40.438|
000196  19d9              ADDS     r1,r3,r7              ;2304
000198  62a1              STR      r1,[r4,#0x28]         ;2305
00019a  2e02              CMP      r6,#2                 ;2305
00019c  d018              BEQ      |L40.464|
00019e  f0000101          AND      r1,r0,#1              ;2306
0001a2  eb000040          ADD      r0,r0,r0,LSL #1       ;2306
0001a6  eb010050          ADD      r0,r1,r0,LSR #1       ;2306
                  |L40.426|
0001aa  1e40              SUBS     r0,r0,#1              ;2306
0001ac  4410              ADD      r0,r0,r2              ;2308
0001ae  fbb0f1f2          UDIV     r1,r0,r2              ;2308
0001b2  4551              CMP      r1,r10                ;2308
0001b4  d90e              BLS      |L40.468|
                  |L40.438|
0001b6  200d              MOVS     r0,#0xd               ;2309
0001b8  e730              B        |L40.28|
                  |L40.442|
0001ba  2900              CMP      r1,#0                 ;2299
0001bc  d1fb              BNE      |L40.438|
0001be  f8941060          LDRB     r1,[r4,#0x60]         ;2300
0001c2  f8d43061          LDR      r3,[r4,#0x61]         ;2300
0001c6  0080              LSLS     r0,r0,#2              ;2301
0001c8  ea412103          ORR      r1,r1,r3,LSL #8       ;2300
0001cc  62a1              STR      r1,[r4,#0x28]         ;2301
0001ce  e7ec              B        |L40.426|
                  |L40.464|
0001d0  0040              LSLS     r0,r0,#1              ;2306
0001d2  e7ea              B        |L40.426|
                  |L40.468|
0001d4  f04f30ff          MOV      r0,#0xffffffff        ;2313
0001d8  6120              STR      r0,[r4,#0x10]         ;2313
0001da  60e0              STR      r0,[r4,#0xc]          ;2316
0001dc  2080              MOVS     r0,#0x80              ;2316
0001de  7160              STRB     r0,[r4,#5]            ;2316
0001e0  2e03              CMP      r6,#3                 ;2318
0001e2  d130              BNE      |L40.582|
0001e4  f8b40064          LDRH     r0,[r4,#0x64]         ;2319
0001e8  2801              CMP      r0,#1                 ;2319
0001ea  d12c              BNE      |L40.582|
0001ec  4620              MOV      r0,r4                 ;2320
0001ee  1c69              ADDS     r1,r5,#1              ;2320
0001f0  f7fffffe          BL       move_window
0001f4  bb38              CBNZ     r0,|L40.582|
0001f6  f8849005          STRB     r9,[r4,#5]            ;2322
0001fa  f8b40232          LDRH     r0,[r4,#0x232]        ;2323
0001fe  f5a0412a          SUB      r1,r0,#0xaa00         ;2323
000202  3955              SUBS     r1,r1,#0x55           ;2323
000204  d11f              BNE      |L40.582|
000206  f8940034          LDRB     r0,[r4,#0x34]         ;2324
00020a  f8d41035          LDR      r1,[r4,#0x35]         ;2324
00020e  ea402001          ORR      r0,r0,r1,LSL #8       ;2324
000212  4913              LDR      r1,|L40.608|
000214  4288              CMP      r0,r1                 ;2324
000216  d116              BNE      |L40.582|
000218  f8940218          LDRB     r0,[r4,#0x218]        ;2325
00021c  f8d41219          LDR      r1,[r4,#0x219]        ;2325
000220  ea402001          ORR      r0,r0,r1,LSL #8       ;2325
000224  490f              LDR      r1,|L40.612|
000226  4288              CMP      r0,r1                 ;2325
000228  d10d              BNE      |L40.582|
00022a  f894021c          LDRB     r0,[r4,#0x21c]        ;2328
00022e  f8d4121d          LDR      r1,[r4,#0x21d]        ;2328
000232  ea402001          ORR      r0,r0,r1,LSL #8       ;2328
000236  6120              STR      r0,[r4,#0x10]         ;2331
000238  f8940220          LDRB     r0,[r4,#0x220]        ;2331
00023c  f8d41221          LDR      r1,[r4,#0x221]        ;2331
000240  ea402001          ORR      r0,r0,r1,LSL #8       ;2331
000244  60e0              STR      r0,[r4,#0xc]          ;2331
                  |L40.582|
000246  4905              LDR      r1,|L40.604|
000248  7026              STRB     r6,[r4,#0]            ;2337
00024a  1f09              SUBS     r1,r1,#4              ;2338
00024c  8848              LDRH     r0,[r1,#2]            ;2338  ; Fsid
00024e  1c40              ADDS     r0,r0,#1              ;2338
000250  8048              STRH     r0,[r1,#2]            ;2338
000252  80e0              STRH     r0,[r4,#6]            ;2338
000254  f8c49014          STR      r9,[r4,#0x14]         ;2346
000258  e6fe              B        |L40.88|
;;;2348   
                          ENDP

00025a  0000              DCW      0x0000
                  |L40.604|
                          DCD      ||.data||+0x4
                  |L40.608|
                          DCD      0x41615252
                  |L40.612|
                          DCD      0x61417272

                          AREA ||i.follow_path||, CODE, READONLY, ALIGN=1

                  follow_path PROC
;;;2036   static
;;;2037   FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;2038   	DIR* dp,			/* Directory object to return last directory and found object */
;;;2039   	const TCHAR* path	/* Full-path string to find a file or directory */
;;;2040   )
;;;2041   {
000002  4604              MOV      r4,r0
;;;2042   	FRESULT res;
;;;2043   	BYTE *dir, ns;
;;;2044   
;;;2045   
;;;2046   #if _FS_RPATH
;;;2047   	if (*path == '/' || *path == '\\') {	/* There is a heading separator */
000004  9901              LDR      r1,[sp,#4]
000006  2500              MOVS     r5,#0
000008  7808              LDRB     r0,[r1,#0]
00000a  282f              CMP      r0,#0x2f
00000c  d00e              BEQ      |L41.44|
00000e  285c              CMP      r0,#0x5c
000010  d00c              BEQ      |L41.44|
;;;2048   		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
;;;2049   	} else {								/* No heading separator */
;;;2050   		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
000012  6820              LDR      r0,[r4,#0]
000014  6940              LDR      r0,[r0,#0x14]
000016  60a0              STR      r0,[r4,#8]
                  |L41.24|
;;;2051   	}
;;;2052   #else
;;;2053   	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
;;;2054   		path++;
;;;2055   	dp->sclust = 0;							/* Always start from the root directory */
;;;2056   #endif
;;;2057   
;;;2058   	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
000018  9801              LDR      r0,[sp,#4]
00001a  7800              LDRB     r0,[r0,#0]
00001c  2820              CMP      r0,#0x20
00001e  d209              BCS      |L41.52|
;;;2059   		res = dir_sdi(dp, 0);
000020  2100              MOVS     r1,#0
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       dir_sdi
;;;2060   		dp->dir = 0;
000028  6165              STR      r5,[r4,#0x14]
                  |L41.42|
;;;2061   	} else {								/* Follow path */
;;;2062   		for (;;) {
;;;2063   			res = create_name(dp, &path);	/* Get a segment name of the path */
;;;2064   			if (res != FR_OK) break;
;;;2065   			res = dir_find(dp);				/* Find an object with the sagment name */
;;;2066   			ns = dp->fn[NSFLAG];
;;;2067   			if (res != FR_OK) {				/* Failed to find the object */
;;;2068   				if (res == FR_NO_FILE) {	/* Object is not found */
;;;2069   					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
;;;2070   						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
;;;2071   						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
;;;2072   						res = FR_OK;					/* Ended at the root directroy. Function completed. */
;;;2073   					} else {							/* Could not find the object */
;;;2074   						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
;;;2075   					}
;;;2076   				}
;;;2077   				break;
;;;2078   			}
;;;2079   			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
;;;2080   			dir = dp->dir;						/* Follow the sub-directory */
;;;2081   			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
;;;2082   				res = FR_NO_PATH; break;
;;;2083   			}
;;;2084   			dp->sclust = ld_clust(dp->fs, dir);
;;;2085   		}
;;;2086   	}
;;;2087   
;;;2088   	return res;
;;;2089   }
00002a  bd7c              POP      {r2-r6,pc}
                  |L41.44|
00002c  1c49              ADDS     r1,r1,#1
00002e  9101              STR      r1,[sp,#4]            ;2048
000030  60a5              STR      r5,[r4,#8]            ;2048
000032  e7f1              B        |L41.24|
                  |L41.52|
000034  a901              ADD      r1,sp,#4              ;2063
000036  4620              MOV      r0,r4                 ;2063
000038  f7fffffe          BL       create_name
00003c  2800              CMP      r0,#0                 ;2064
00003e  d1f4              BNE      |L41.42|
000040  4620              MOV      r0,r4                 ;2065
000042  f7fffffe          BL       dir_find
000046  69a1              LDR      r1,[r4,#0x18]         ;2066
000048  7ac9              LDRB     r1,[r1,#0xb]          ;2066
00004a  b168              CBZ      r0,|L41.104|
00004c  2804              CMP      r0,#4                 ;2068
00004e  d1ec              BNE      |L41.42|
000050  068a              LSLS     r2,r1,#26             ;2069
000052  d505              BPL      |L41.96|
000054  60a5              STR      r5,[r4,#8]            ;2070
000056  6165              STR      r5,[r4,#0x14]         ;2071
000058  0748              LSLS     r0,r1,#29             ;2071
00005a  d5eb              BPL      |L41.52|
00005c  2000              MOVS     r0,#0                 ;2072
                  |L41.94|
00005e  bd7c              POP      {r2-r6,pc}
                  |L41.96|
000060  0749              LSLS     r1,r1,#29             ;2074
000062  d4fc              BMI      |L41.94|
                  |L41.100|
000064  2005              MOVS     r0,#5                 ;2074
                  |L41.102|
000066  bd7c              POP      {r2-r6,pc}
                  |L41.104|
000068  0749              LSLS     r1,r1,#29             ;2079
00006a  d4fc              BMI      |L41.102|
00006c  6961              LDR      r1,[r4,#0x14]         ;2081
00006e  7ac8              LDRB     r0,[r1,#0xb]          ;2081
000070  06c0              LSLS     r0,r0,#27             ;2081
000072  d5f7              BPL      |L41.100|
000074  6820              LDR      r0,[r4,#0]            ;2084
000076  f7fffffe          BL       ld_clust
00007a  60a0              STR      r0,[r4,#8]            ;2071
00007c  e7da              B        |L41.52|
;;;2090   
                          ENDP


                          AREA ||i.gen_numname||, CODE, READONLY, ALIGN=2

                  gen_numname PROC
;;;1432   static
;;;1433   void gen_numname (
000000  b57c              PUSH     {r2-r6,lr}
;;;1434   	BYTE* dst,			/* Pointer to the buffer to store numbered SFN */
;;;1435   	const BYTE* src,	/* Pointer to SFN */
;;;1436   	const WCHAR* lfn,	/* Pointer to LFN */
;;;1437   	UINT seq			/* Sequence number */
;;;1438   )
;;;1439   {
000002  4616              MOV      r6,r2
000004  461c              MOV      r4,r3
000006  4605              MOV      r5,r0
;;;1440   	BYTE ns[8], c;
;;;1441   	UINT i, j;
;;;1442   
;;;1443   
;;;1444   	mem_cpy(dst, src, 11);
000008  220b              MOVS     r2,#0xb
00000a  f7fffffe          BL       mem_cpy
;;;1445   
;;;1446   	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
00000e  2c05              CMP      r4,#5
000010  d911              BLS      |L42.54|
;;;1447   		WCHAR wc;
;;;1448   		DWORD sr = seq;
;;;1449   
;;;1450   		while (*lfn) {	/* Create a CRC */
;;;1451   			wc = *lfn++;
;;;1452   			for (i = 0; i < 16; i++) {
;;;1453   				sr = (sr << 1) + (wc & 1);
;;;1454   				wc >>= 1;
;;;1455   				if (sr & 0x10000) sr ^= 0x11021;
000012  4a1d              LDR      r2,|L42.136|
000014  e00c              B        |L42.48|
                  |L42.22|
000016  2100              MOVS     r1,#0                 ;1452
000018  1cb6              ADDS     r6,r6,#2              ;1452
                  |L42.26|
00001a  4623              MOV      r3,r4                 ;1453
00001c  4604              MOV      r4,r0                 ;1453
00001e  f363045f          BFI      r4,r3,#1,#31          ;1453
000022  0840              LSRS     r0,r0,#1              ;1454
000024  03e3              LSLS     r3,r4,#15
000026  d500              BPL      |L42.42|
000028  4054              EORS     r4,r4,r2
                  |L42.42|
00002a  1c49              ADDS     r1,r1,#1
00002c  2910              CMP      r1,#0x10              ;1452
00002e  d3f4              BCC      |L42.26|
                  |L42.48|
000030  8830              LDRH     r0,[r6,#0]            ;1450
000032  2800              CMP      r0,#0                 ;1450
000034  d1ef              BNE      |L42.22|
                  |L42.54|
;;;1456   			}
;;;1457   		}
;;;1458   		seq = (UINT)sr;
;;;1459   	}
;;;1460   
;;;1461   	/* itoa (hexdecimal) */
;;;1462   	i = 7;
000036  2207              MOVS     r2,#7
000038  466b              MOV      r3,sp                 ;1440
                  |L42.58|
;;;1463   	do {
;;;1464   		c = (seq % 16) + '0';
00003a  f004000f          AND      r0,r4,#0xf
00003e  3030              ADDS     r0,r0,#0x30
;;;1465   		if (c > '9') c += 7;
000040  2839              CMP      r0,#0x39
000042  d900              BLS      |L42.70|
000044  1dc0              ADDS     r0,r0,#7
                  |L42.70|
;;;1466   		ns[i--] = c;
000046  5498              STRB     r0,[r3,r2]
000048  1e52              SUBS     r2,r2,#1
;;;1467   		seq /= 16;
00004a  0924              LSRS     r4,r4,#4
;;;1468   	} while (seq);
00004c  d1f5              BNE      |L42.58|
;;;1469   	ns[i] = '~';
00004e  207e              MOVS     r0,#0x7e
;;;1470   
;;;1471   	/* Append the number */
;;;1472   	for (j = 0; j < i && dst[j] != ' '; j++) {
000050  2100              MOVS     r1,#0
000052  5498              STRB     r0,[r3,r2]            ;1469
000054  1e54              SUBS     r4,r2,#1              ;1466
000056  e006              B        |L42.102|
                  |L42.88|
000058  3881              SUBS     r0,r0,#0x81
;;;1473   		if (IsDBCS1(dst[j])) {
00005a  287d              CMP      r0,#0x7d
00005c  d802              BHI      |L42.100|
;;;1474   			if (j == i - 1) break;
00005e  42a1              CMP      r1,r4
000060  d006              BEQ      |L42.112|
000062  1c49              ADDS     r1,r1,#1
                  |L42.100|
000064  1c49              ADDS     r1,r1,#1
                  |L42.102|
000066  4291              CMP      r1,r2                 ;1472
000068  d202              BCS      |L42.112|
00006a  5c68              LDRB     r0,[r5,r1]            ;1472
00006c  2820              CMP      r0,#0x20              ;1472
00006e  d1f3              BNE      |L42.88|
                  |L42.112|
;;;1475   			j++;
;;;1476   		}
;;;1477   	}
;;;1478   	do {
;;;1479   		dst[j++] = (i < 8) ? ns[i++] : ' ';
000070  2a08              CMP      r2,#8
000072  d202              BCS      |L42.122|
000074  5c98              LDRB     r0,[r3,r2]
000076  1c52              ADDS     r2,r2,#1
000078  e000              B        |L42.124|
                  |L42.122|
00007a  2020              MOVS     r0,#0x20
                  |L42.124|
00007c  5468              STRB     r0,[r5,r1]
00007e  1c49              ADDS     r1,r1,#1
;;;1480   	} while (j < 8);
000080  2908              CMP      r1,#8
000082  d3f5              BCC      |L42.112|
;;;1481   }
000084  bd7c              POP      {r2-r6,pc}
;;;1482   #endif
                          ENDP

000086  0000              DCW      0x0000
                  |L42.136|
                          DCD      0x00011021

                          AREA ||i.get_fat||, CODE, READONLY, ALIGN=1

                  get_fat PROC
;;;876    
;;;877    DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x0FFFFFFF:Cluster status */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;878    	FATFS* fs,	/* File system object */
;;;879    	DWORD clst	/* FAT item index (cluster#) to get the value */
;;;880    )
;;;881    {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;882    	UINT wc, bc;
;;;883    	BYTE *p;
;;;884    	DWORD val;
;;;885    
;;;886    
;;;887    	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
000008  2902              CMP      r1,#2
00000a  d30b              BCC      |L43.36|
00000c  69a0              LDR      r0,[r4,#0x18]
00000e  42a8              CMP      r0,r5
000010  d908              BLS      |L43.36|
;;;888    		val = 1;	/* Internal error */
;;;889    
;;;890    	} else {
;;;891    		val = 0xFFFFFFFF;	/* Default value falls on disk error */
;;;892    
;;;893    		switch (fs->fs_type) {
000012  7820              LDRB     r0,[r4,#0]
000014  f04f36ff          MOV      r6,#0xffffffff        ;891
000018  2801              CMP      r0,#1
00001a  d007              BEQ      |L43.44|
00001c  2802              CMP      r0,#2
00001e  d034              BEQ      |L43.138|
000020  2803              CMP      r0,#3
000022  d046              BEQ      |L43.178|
                  |L43.36|
;;;894    		case FS_FAT12 :
;;;895    			bc = (UINT)clst; bc += bc / 2;
;;;896    			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
;;;897    			wc = fs->win[bc++ % SS(fs)];
;;;898    			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
;;;899    			wc |= fs->win[bc % SS(fs)] << 8;
;;;900    			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
;;;901    			break;
;;;902    
;;;903    		case FS_FAT16 :
;;;904    			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
;;;905    			p = &fs->win[clst * 2 % SS(fs)];
;;;906    			val = LD_WORD(p);
;;;907    			break;
;;;908    
;;;909    		case FS_FAT32 :
;;;910    			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
;;;911    			p = &fs->win[clst * 4 % SS(fs)];
;;;912    			val = LD_DWORD(p) & 0x0FFFFFFF;
;;;913    			break;
;;;914    
;;;915    		default:
;;;916    			val = 1;	/* Internal error */
000024  2601              MOVS     r6,#1
                  |L43.38|
;;;917    		}
;;;918    	}
;;;919    
;;;920    	return val;
000026  4630              MOV      r0,r6
;;;921    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L43.44|
00002c  8960              LDRH     r0,[r4,#0xa]          ;896
00002e  eb050755          ADD      r7,r5,r5,LSR #1       ;895
000032  fbb7f0f0          UDIV     r0,r7,r0              ;896
000036  6a61              LDR      r1,[r4,#0x24]         ;896
000038  4401              ADD      r1,r1,r0              ;896
00003a  4620              MOV      r0,r4                 ;896
00003c  f7fffffe          BL       move_window
000040  2800              CMP      r0,#0                 ;896
000042  d1f0              BNE      |L43.38|
000044  8960              LDRH     r0,[r4,#0xa]          ;897
000046  fbb7f1f0          UDIV     r1,r7,r0              ;897
00004a  fb007111          MLS      r1,r0,r1,r7           ;897
00004e  1c7f              ADDS     r7,r7,#1              ;897
000050  fbb7f0f0          UDIV     r0,r7,r0              ;898
000054  4421              ADD      r1,r1,r4              ;897
000056  f8918034          LDRB     r8,[r1,#0x34]         ;897
00005a  6a61              LDR      r1,[r4,#0x24]         ;898
00005c  4401              ADD      r1,r1,r0              ;898
00005e  4620              MOV      r0,r4                 ;898
000060  f7fffffe          BL       move_window
000064  2800              CMP      r0,#0                 ;898
000066  d1de              BNE      |L43.38|
000068  8960              LDRH     r0,[r4,#0xa]          ;899
00006a  fbb7f1f0          UDIV     r1,r7,r0              ;899
00006e  fb007011          MLS      r0,r0,r1,r7           ;899
000072  4420              ADD      r0,r0,r4              ;899
000074  f8901034          LDRB     r1,[r0,#0x34]         ;899
000078  ea482001          ORR      r0,r8,r1,LSL #8       ;899
00007c  07e9              LSLS     r1,r5,#31             ;900
00007e  d001              BEQ      |L43.132|
000080  0906              LSRS     r6,r0,#4              ;900
000082  e7d0              B        |L43.38|
                  |L43.132|
000084  f3c0060b          UBFX     r6,r0,#0,#12          ;900
000088  e7cd              B        |L43.38|
                  |L43.138|
00008a  8960              LDRH     r0,[r4,#0xa]          ;904
00008c  6a61              LDR      r1,[r4,#0x24]         ;904
00008e  0840              LSRS     r0,r0,#1              ;904
000090  fbb5f0f0          UDIV     r0,r5,r0              ;904
000094  4401              ADD      r1,r1,r0              ;904
000096  4620              MOV      r0,r4                 ;904
000098  f7fffffe          BL       move_window
00009c  2800              CMP      r0,#0                 ;904
00009e  d1c2              BNE      |L43.38|
0000a0  8961              LDRH     r1,[r4,#0xa]          ;905
0000a2  0068              LSLS     r0,r5,#1              ;905
0000a4  fbb0f2f1          UDIV     r2,r0,r1              ;905
0000a8  fb010012          MLS      r0,r1,r2,r0           ;905
0000ac  4420              ADD      r0,r0,r4              ;905
0000ae  8e86              LDRH     r6,[r0,#0x34]         ;906
0000b0  e7b9              B        |L43.38|
                  |L43.178|
0000b2  8960              LDRH     r0,[r4,#0xa]          ;910
0000b4  6a61              LDR      r1,[r4,#0x24]         ;910
0000b6  0880              LSRS     r0,r0,#2              ;910
0000b8  fbb5f0f0          UDIV     r0,r5,r0              ;910
0000bc  4401              ADD      r1,r1,r0              ;910
0000be  4620              MOV      r0,r4                 ;910
0000c0  f7fffffe          BL       move_window
0000c4  2800              CMP      r0,#0                 ;910
0000c6  d1ae              BNE      |L43.38|
0000c8  8961              LDRH     r1,[r4,#0xa]          ;911
0000ca  00a8              LSLS     r0,r5,#2              ;911
0000cc  fbb0f2f1          UDIV     r2,r0,r1              ;911
0000d0  fb010012          MLS      r0,r1,r2,r0           ;911
0000d4  4420              ADD      r0,r0,r4              ;911
0000d6  f8901034          LDRB     r1,[r0,#0x34]         ;912
0000da  f8d00035          LDR      r0,[r0,#0x35]         ;912
0000de  ea412000          ORR      r0,r1,r0,LSL #8       ;912
0000e2  f0204670          BIC      r6,r0,#0xf0000000     ;912
0000e6  e79e              B        |L43.38|
;;;922    
                          ENDP


                          AREA ||i.get_fileinfo||, CODE, READONLY, ALIGN=1

                  get_fileinfo PROC
;;;1756   static
;;;1757   void get_fileinfo (		/* No return code */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1758   	DIR* dp,			/* Pointer to the directory object */
;;;1759   	FILINFO* fno	 	/* Pointer to the file information to be filled */
;;;1760   )
;;;1761   {
000004  460e              MOV      r6,r1
;;;1762   	UINT i;
;;;1763   	TCHAR *p, c;
;;;1764   
;;;1765   
;;;1766   	p = fno->fname;
000006  f1010509          ADD      r5,r1,#9
00000a  6901              LDR      r1,[r0,#0x10]         ;1761
00000c  b369              CBZ      r1,|L44.106|
;;;1767   	if (dp->sect) {		/* Get SFN */
;;;1768   		BYTE *dir = dp->dir;
;;;1769   
;;;1770   		i = 0;
00000e  2100              MOVS     r1,#0
;;;1771   		while (i < 11) {		/* Copy name body and extension */
;;;1772   			c = (TCHAR)dir[i++];
;;;1773   			if (c == ' ') continue;			/* Skip padding spaces */
;;;1774   			if (c == NDDE) c = (TCHAR)DDE;	/* Restore replaced DDE character */
;;;1775   			if (i == 9) *p++ = '.';			/* Insert a . if extension is exist */
000010  6943              LDR      r3,[r0,#0x14]
000012  272e              MOVS     r7,#0x2e
                  |L44.20|
000014  5c5a              LDRB     r2,[r3,r1]            ;1772
000016  1c49              ADDS     r1,r1,#1              ;1772
000018  2a20              CMP      r2,#0x20              ;1773
00001a  d018              BEQ      |L44.78|
00001c  2a05              CMP      r2,#5                 ;1774
00001e  d100              BNE      |L44.34|
000020  22e5              MOVS     r2,#0xe5              ;1774
                  |L44.34|
000022  2909              CMP      r1,#9
000024  d101              BNE      |L44.42|
000026  f8057b01          STRB     r7,[r5],#1
                  |L44.42|
;;;1776   #if _USE_LFN
;;;1777   			if (IsUpper(c) && (dir[DIR_NTres] & (i >= 9 ? NS_EXT : NS_BODY)))
00002a  f1a20441          SUB      r4,r2,#0x41
00002e  2c19              CMP      r4,#0x19
000030  d80b              BHI      |L44.74|
000032  f893c00c          LDRB     r12,[r3,#0xc]
000036  2909              CMP      r1,#9
000038  d301              BCC      |L44.62|
00003a  2410              MOVS     r4,#0x10
00003c  e000              B        |L44.64|
                  |L44.62|
00003e  2408              MOVS     r4,#8
                  |L44.64|
000040  ea1c0f04          TST      r12,r4
000044  d001              BEQ      |L44.74|
000046  3220              ADDS     r2,r2,#0x20
;;;1778   				c += 0x20;			/* To lower */
000048  b2d2              UXTB     r2,r2
                  |L44.74|
;;;1779   #if _LFN_UNICODE
;;;1780   			if (IsDBCS1(c) && i != 8 && i != 11 && IsDBCS2(dir[i]))
;;;1781   				c = c << 8 | dir[i++];
;;;1782   			c = ff_convert(c, 1);	/* OEM -> Unicode */
;;;1783   			if (!c) c = '?';
;;;1784   #endif
;;;1785   #endif
;;;1786   			*p++ = c;
00004a  f8052b01          STRB     r2,[r5],#1
                  |L44.78|
00004e  290b              CMP      r1,#0xb               ;1771
000050  d3e0              BCC      |L44.20|
;;;1787   		}
;;;1788   		fno->fattrib = dir[DIR_Attr];				/* Attribute */
000052  7ad9              LDRB     r1,[r3,#0xb]
000054  7231              STRB     r1,[r6,#8]
;;;1789   		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
000056  7f19              LDRB     r1,[r3,#0x1c]
000058  f8d3201d          LDR      r2,[r3,#0x1d]
00005c  ea412102          ORR      r1,r1,r2,LSL #8
;;;1790   		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
000060  6031              STR      r1,[r6,#0]
000062  8b19              LDRH     r1,[r3,#0x18]
000064  80b1              STRH     r1,[r6,#4]
;;;1791   		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
000066  8ad9              LDRH     r1,[r3,#0x16]
000068  80f1              STRH     r1,[r6,#6]
                  |L44.106|
;;;1792   	}
;;;1793   	*p = 0;		/* Terminate SFN string by a \0 */
00006a  f04f0800          MOV      r8,#0
00006e  f8858000          STRB     r8,[r5,#0]
;;;1794   
;;;1795   #if _USE_LFN
;;;1796   	if (fno->lfname) {
000072  69b7              LDR      r7,[r6,#0x18]
000074  2f00              CMP      r7,#0
000076  d022              BEQ      |L44.190|
;;;1797   		WCHAR w, *lfn;
;;;1798   
;;;1799   		i = 0; p = fno->lfname;
;;;1800   		if (dp->sect && fno->lfsize && dp->lfn_idx != 0xFFFF) {	/* Get LFN if available */
000078  6901              LDR      r1,[r0,#0x10]
00007a  2400              MOVS     r4,#0                 ;1799
00007c  b1e9              CBZ      r1,|L44.186|
00007e  69f1              LDR      r1,[r6,#0x1c]
000080  b1d9              CBZ      r1,|L44.186|
000082  8c01              LDRH     r1,[r0,#0x20]
000084  f5a1427f          SUB      r2,r1,#0xff00
000088  3aff              SUBS     r2,r2,#0xff
00008a  d016              BEQ      |L44.186|
;;;1801   			lfn = dp->lfn;
;;;1802   			while ((w = *lfn++) != 0) {		/* Get an LFN character */
00008c  69c5              LDR      r5,[r0,#0x1c]
00008e  e010              B        |L44.178|
                  |L44.144|
;;;1803   #if !_LFN_UNICODE
;;;1804   				w = ff_convert(w, 0);		/* Unicode -> OEM */
000090  2100              MOVS     r1,#0
000092  f7fffffe          BL       ff_convert
;;;1805   				if (!w) { i = 0; break; }	/* No LFN if it could not be converted */
000096  b140              CBZ      r0,|L44.170|
;;;1806   				if (_DF1S && w >= 0x100)	/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
000098  28ff              CMP      r0,#0xff
00009a  d902              BLS      |L44.162|
;;;1807   					p[i++] = (TCHAR)(w >> 8);
00009c  0a01              LSRS     r1,r0,#8
00009e  5539              STRB     r1,[r7,r4]
0000a0  1c64              ADDS     r4,r4,#1
                  |L44.162|
;;;1808   #endif
;;;1809   				if (i >= fno->lfsize - 1) { i = 0; break; }	/* No LFN if buffer overflow */
0000a2  69f1              LDR      r1,[r6,#0x1c]
0000a4  1e49              SUBS     r1,r1,#1
0000a6  42a1              CMP      r1,r4
0000a8  d801              BHI      |L44.174|
                  |L44.170|
0000aa  2400              MOVS     r4,#0
0000ac  e005              B        |L44.186|
                  |L44.174|
;;;1810   				p[i++] = (TCHAR)w;
0000ae  5538              STRB     r0,[r7,r4]
0000b0  1c64              ADDS     r4,r4,#1
                  |L44.178|
0000b2  f8350b02          LDRH     r0,[r5],#2            ;1802
0000b6  2800              CMP      r0,#0                 ;1802
0000b8  d1ea              BNE      |L44.144|
                  |L44.186|
;;;1811   			}
;;;1812   		}
;;;1813   		p[i] = 0;	/* Terminate LFN string by a \0 */
0000ba  f8078004          STRB     r8,[r7,r4]
                  |L44.190|
;;;1814   	}
;;;1815   #endif
;;;1816   }
0000be  e8bd81f0          POP      {r4-r8,pc}
;;;1817   #endif /* _FS_MINIMIZE <= 1 || _FS_RPATH >= 2*/
                          ENDP


                          AREA ||i.get_ldnumber||, CODE, READONLY, ALIGN=2

                  get_ldnumber PROC
;;;2098   static
;;;2099   int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
000000  b510              PUSH     {r4,lr}
;;;2100   	const TCHAR** path	/* Pointer to pointer to the path name */
;;;2101   )
;;;2102   {
000002  4603              MOV      r3,r0
;;;2103   	const TCHAR *tp, *tt;
;;;2104   	UINT i;
;;;2105   	int vol = -1;
000004  f04f30ff          MOV      r0,#0xffffffff
000008  681c              LDR      r4,[r3,#0]            ;2102
00000a  2c00              CMP      r4,#0                 ;2102
00000c  d013              BEQ      |L45.54|
00000e  4621              MOV      r1,r4                 ;2102
;;;2106   
;;;2107   
;;;2108   	if (*path) {	/* If the pointer is not a null */
;;;2109   		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
000010  e000              B        |L45.20|
                  |L45.18|
000012  1c49              ADDS     r1,r1,#1
                  |L45.20|
000014  780a              LDRB     r2,[r1,#0]
000016  2a20              CMP      r2,#0x20
000018  d30e              BCC      |L45.56|
00001a  2a3a              CMP      r2,#0x3a
00001c  d1f9              BNE      |L45.18|
;;;2110   		if (*tt == ':') {	/* If a ':' is exist in the path name */
;;;2111   			tp = *path;
;;;2112   			i = *tp++ - '0'; 
00001e  f8142b01          LDRB     r2,[r4],#1
000022  3a30              SUBS     r2,r2,#0x30
;;;2113   			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
000024  2a0a              CMP      r2,#0xa
000026  d206              BCS      |L45.54|
000028  428c              CMP      r4,r1
00002a  d104              BNE      |L45.54|
;;;2114   				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
00002c  2a02              CMP      r2,#2
00002e  d202              BCS      |L45.54|
;;;2115   					vol = (int)i;
000030  1c49              ADDS     r1,r1,#1
000032  4610              MOV      r0,r2
;;;2116   					*path = ++tt;
000034  6019              STR      r1,[r3,#0]
                  |L45.54|
;;;2117   				}
;;;2118   			} else {	/* No numeric drive number */
;;;2119   #if _STR_VOLUME_ID		/* Find string drive id */
;;;2120   				static const char* const str[] = {_VOLUME_STRS};
;;;2121   				const char *sp;
;;;2122   				char c;
;;;2123   				TCHAR tc;
;;;2124   
;;;2125   				i = 0; tt++;
;;;2126   				do {
;;;2127   					sp = str[i]; tp = *path;
;;;2128   					do {	/* Compare a string drive id with path name */
;;;2129   						c = *sp++; tc = *tp++;
;;;2130   						if (IsLower(tc)) tc -= 0x20;
;;;2131   					} while (c && (TCHAR)c == tc);
;;;2132   				} while ((c || tp != tt) && ++i < _VOLUMES);	/* Repeat for each id until pattern match */
;;;2133   				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
;;;2134   					vol = (int)i;
;;;2135   					*path = tt;
;;;2136   				}
;;;2137   #endif
;;;2138   			}
;;;2139   			return vol;
;;;2140   		}
;;;2141   #if _FS_RPATH && _VOLUMES >= 2
;;;2142   		vol = CurrVol;	/* Current drive */
;;;2143   #else
;;;2144   		vol = 0;		/* Drive 0 */
;;;2145   #endif
;;;2146   	}
;;;2147   	return vol;
;;;2148   }
000036  bd10              POP      {r4,pc}
                  |L45.56|
000038  4801              LDR      r0,|L45.64|
00003a  7800              LDRB     r0,[r0,#0]            ;2142  ; CurrVol
00003c  bd10              POP      {r4,pc}
;;;2149   
                          ENDP

00003e  0000              DCW      0x0000
                  |L45.64|
                          DCD      ||.data||

                          AREA ||i.ld_clust||, CODE, READONLY, ALIGN=1

                  ld_clust PROC
;;;1291   static
;;;1292   DWORD ld_clust (
000000  4602              MOV      r2,r0
;;;1293   	FATFS* fs,	/* Pointer to the fs object */
;;;1294   	BYTE* dir	/* Pointer to the directory entry */
;;;1295   )
;;;1296   {
;;;1297   	DWORD cl;
;;;1298   
;;;1299   	cl = LD_WORD(dir+DIR_FstClusLO);
000002  8b48              LDRH     r0,[r1,#0x1a]
;;;1300   	if (fs->fs_type == FS_FAT32)
000004  7812              LDRB     r2,[r2,#0]
000006  2a03              CMP      r2,#3
000008  d102              BNE      |L46.16|
;;;1301   		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
00000a  8a89              LDRH     r1,[r1,#0x14]
00000c  ea404001          ORR      r0,r0,r1,LSL #16
                  |L46.16|
;;;1302   
;;;1303   	return cl;
;;;1304   }
000010  4770              BX       lr
;;;1305   
                          ENDP


                          AREA ||i.mem_cpy||, CODE, READONLY, ALIGN=1

                  mem_cpy PROC
;;;565    static
;;;566    void mem_cpy (void* dst, const void* src, UINT cnt) {
000000  e003              B        |L47.10|
                  |L47.2|
;;;567    	BYTE *d = (BYTE*)dst;
;;;568    	const BYTE *s = (const BYTE*)src;
;;;569    
;;;570    #if _WORD_ACCESS == 1
;;;571    	while (cnt >= sizeof (int)) {
;;;572    		*(int*)d = *(int*)s;
;;;573    		d += sizeof (int); s += sizeof (int);
;;;574    		cnt -= sizeof (int);
;;;575    	}
;;;576    #endif
;;;577    	while (cnt--)
;;;578    		*d++ = *s++;
000002  f8113b01          LDRB     r3,[r1],#1
000006  f8003b01          STRB     r3,[r0],#1
                  |L47.10|
00000a  1e52              SUBS     r2,r2,#1
00000c  d2f9              BCS      |L47.2|
;;;579    }
00000e  4770              BX       lr
;;;580    
                          ENDP


                          AREA ||i.mem_set||, CODE, READONLY, ALIGN=1

                  mem_set PROC
;;;582    static
;;;583    void mem_set (void* dst, int val, UINT cnt) {
000000  b2c9              UXTB     r1,r1
000002  e001              B        |L48.8|
                  |L48.4|
;;;584    	BYTE *d = (BYTE*)dst;
;;;585    
;;;586    	while (cnt--)
;;;587    		*d++ = (BYTE)val;
000004  f8001b01          STRB     r1,[r0],#1
                  |L48.8|
000008  1e52              SUBS     r2,r2,#1
00000a  d2fb              BCS      |L48.4|
;;;588    }
00000c  4770              BX       lr
;;;589    
                          ENDP


                          AREA ||i.move_window||, CODE, READONLY, ALIGN=1

                  move_window PROC
;;;787    static
;;;788    FRESULT move_window (
000000  b570              PUSH     {r4-r6,lr}
;;;789    	FATFS* fs,		/* File system object */
;;;790    	DWORD sector	/* Sector number to make appearance in the fs->win[] */
;;;791    )
;;;792    {
000002  4604              MOV      r4,r0
;;;793    	FRESULT res = FR_OK;
;;;794    
;;;795    
;;;796    	if (sector != fs->winsect) {	/* Window offset changed? */
000004  6b00              LDR      r0,[r0,#0x30]
000006  460e              MOV      r6,r1                 ;792
000008  2500              MOVS     r5,#0                 ;793
00000a  42b0              CMP      r0,r6
00000c  d00f              BEQ      |L49.46|
;;;797    #if !_FS_READONLY
;;;798    		res = sync_window(fs);		/* Write-back changes */
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       sync_window
000014  0005              MOVS     r5,r0
;;;799    #endif
;;;800    		if (res == FR_OK) {			/* Fill sector window with new data */
000016  d10a              BNE      |L49.46|
;;;801    			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
000018  7860              LDRB     r0,[r4,#1]
00001a  2301              MOVS     r3,#1
00001c  4632              MOV      r2,r6
00001e  f1040134          ADD      r1,r4,#0x34
000022  f7fffffe          BL       disk_read
000026  b108              CBZ      r0,|L49.44|
;;;802    				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
000028  1e6e              SUBS     r6,r5,#1
;;;803    				res = FR_DISK_ERR;
00002a  2501              MOVS     r5,#1
                  |L49.44|
;;;804    			}
;;;805    			fs->winsect = sector;
00002c  6326              STR      r6,[r4,#0x30]
                  |L49.46|
;;;806    		}
;;;807    	}
;;;808    	return res;
00002e  4628              MOV      r0,r5
;;;809    }
000030  bd70              POP      {r4-r6,pc}
;;;810    
                          ENDP


                          AREA ||i.put_fat||, CODE, READONLY, ALIGN=1

                  put_fat PROC
;;;931    #if !_FS_READONLY
;;;932    FRESULT put_fat (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;933    	FATFS* fs,	/* File system object */
;;;934    	DWORD clst,	/* FAT item index (cluster#) to be set */
;;;935    	DWORD val	/* New value to mark the cluster */
;;;936    )
;;;937    {
000004  4616              MOV      r6,r2
000006  460d              MOV      r5,r1
000008  4604              MOV      r4,r0
;;;938    	UINT bc;
;;;939    	BYTE *p;
;;;940    	FRESULT res;
;;;941    
;;;942    
;;;943    	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
00000a  2902              CMP      r1,#2
00000c  d302              BCC      |L50.20|
00000e  69a0              LDR      r0,[r4,#0x18]
000010  42a8              CMP      r0,r5
000012  d802              BHI      |L50.26|
                  |L50.20|
;;;944    		res = FR_INT_ERR;
000014  2002              MOVS     r0,#2
                  |L50.22|
;;;945    
;;;946    	} else {
;;;947    		switch (fs->fs_type) {
;;;948    		case FS_FAT12 :
;;;949    			bc = (UINT)clst; bc += bc / 2;
;;;950    			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
;;;951    			if (res != FR_OK) break;
;;;952    			p = &fs->win[bc++ % SS(fs)];
;;;953    			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
;;;954    			fs->wflag = 1;
;;;955    			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
;;;956    			if (res != FR_OK) break;
;;;957    			p = &fs->win[bc % SS(fs)];
;;;958    			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
;;;959    			fs->wflag = 1;
;;;960    			break;
;;;961    
;;;962    		case FS_FAT16 :
;;;963    			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
;;;964    			if (res != FR_OK) break;
;;;965    			p = &fs->win[clst * 2 % SS(fs)];
;;;966    			ST_WORD(p, (WORD)val);
;;;967    			fs->wflag = 1;
;;;968    			break;
;;;969    
;;;970    		case FS_FAT32 :
;;;971    			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
;;;972    			if (res != FR_OK) break;
;;;973    			p = &fs->win[clst * 4 % SS(fs)];
;;;974    			val |= LD_DWORD(p) & 0xF0000000;
;;;975    			ST_DWORD(p, val);
;;;976    			fs->wflag = 1;
;;;977    			break;
;;;978    
;;;979    		default :
;;;980    			res = FR_INT_ERR;
;;;981    		}
;;;982    	}
;;;983    
;;;984    	return res;
;;;985    }
000016  e8bd87f0          POP      {r4-r10,pc}
                  |L50.26|
00001a  7820              LDRB     r0,[r4,#0]            ;947
00001c  f00608ff          AND      r8,r6,#0xff           ;953
000020  f04f0901          MOV      r9,#1                 ;947
000024  2801              CMP      r0,#1                 ;947
000026  d025              BEQ      |L50.116|
000028  2802              CMP      r0,#2                 ;947
00002a  d05f              BEQ      |L50.236|
00002c  2803              CMP      r0,#3                 ;947
00002e  d1f1              BNE      |L50.20|
000030  8960              LDRH     r0,[r4,#0xa]          ;971
000032  6a61              LDR      r1,[r4,#0x24]         ;971
000034  0880              LSRS     r0,r0,#2              ;971
000036  fbb5f0f0          UDIV     r0,r5,r0              ;971
00003a  4401              ADD      r1,r1,r0              ;971
00003c  4620              MOV      r0,r4                 ;971
00003e  f7fffffe          BL       move_window
000042  2800              CMP      r0,#0                 ;972
000044  d1e7              BNE      |L50.22|
000046  8962              LDRH     r2,[r4,#0xa]          ;973
000048  00a9              LSLS     r1,r5,#2              ;973
00004a  fbb1f3f2          UDIV     r3,r1,r2              ;973
00004e  fb021113          MLS      r1,r2,r3,r1           ;973
000052  4421              ADD      r1,r1,r4              ;973
000054  f04f4370          MOV      r3,#0xf0000000        ;974
000058  f8d12035          LDR      r2,[r1,#0x35]         ;974
00005c  ea032202          AND      r2,r3,r2,LSL #8       ;974
000060  4332              ORRS     r2,r2,r6              ;974
000062  f8012f34          STRB     r2,[r1,#0x34]!        ;975
000066  0a13              LSRS     r3,r2,#8              ;975
000068  704b              STRB     r3,[r1,#1]            ;975
00006a  0c13              LSRS     r3,r2,#16             ;975
00006c  708b              STRB     r3,[r1,#2]            ;975
00006e  0e12              LSRS     r2,r2,#24             ;975
000070  70ca              STRB     r2,[r1,#3]            ;975
000072  e052              B        |L50.282|
                  |L50.116|
000074  8960              LDRH     r0,[r4,#0xa]          ;950
000076  eb050755          ADD      r7,r5,r5,LSR #1       ;949
00007a  fbb7f0f0          UDIV     r0,r7,r0              ;950
00007e  6a61              LDR      r1,[r4,#0x24]         ;950
000080  4401              ADD      r1,r1,r0              ;950
000082  4620              MOV      r0,r4                 ;950
000084  f7fffffe          BL       move_window
000088  2800              CMP      r0,#0                 ;951
00008a  d1c4              BNE      |L50.22|
00008c  8960              LDRH     r0,[r4,#0xa]          ;952
00008e  fbb7f1f0          UDIV     r1,r7,r0              ;952
000092  fb007011          MLS      r0,r0,r1,r7           ;952
000096  4420              ADD      r0,r0,r4              ;952
000098  3034              ADDS     r0,r0,#0x34           ;952
00009a  1c7f              ADDS     r7,r7,#1              ;952
00009c  07e9              LSLS     r1,r5,#31             ;953
00009e  d003              BEQ      |L50.168|
0000a0  7801              LDRB     r1,[r0,#0]            ;953
0000a2  f368111f          BFI      r1,r8,#4,#28          ;953
0000a6  e000              B        |L50.170|
                  |L50.168|
0000a8  4631              MOV      r1,r6                 ;953
                  |L50.170|
0000aa  7001              STRB     r1,[r0,#0]            ;953
0000ac  f8849004          STRB     r9,[r4,#4]            ;954
0000b0  8960              LDRH     r0,[r4,#0xa]          ;955
0000b2  6a61              LDR      r1,[r4,#0x24]         ;955
0000b4  fbb7f0f0          UDIV     r0,r7,r0              ;955
0000b8  4401              ADD      r1,r1,r0              ;955
0000ba  4620              MOV      r0,r4                 ;955
0000bc  f7fffffe          BL       move_window
0000c0  2800              CMP      r0,#0                 ;956
0000c2  d1a8              BNE      |L50.22|
0000c4  8961              LDRH     r1,[r4,#0xa]          ;957
0000c6  fbb7f2f1          UDIV     r2,r7,r1              ;957
0000ca  fb017112          MLS      r1,r1,r2,r7           ;957
0000ce  4421              ADD      r1,r1,r4              ;957
0000d0  3134              ADDS     r1,r1,#0x34           ;957
0000d2  07ea              LSLS     r2,r5,#31             ;958
0000d4  d002              BEQ      |L50.220|
0000d6  f3c61207          UBFX     r2,r6,#4,#8           ;958
0000da  e005              B        |L50.232|
                  |L50.220|
0000dc  780a              LDRB     r2,[r1,#0]            ;958
0000de  f3c62303          UBFX     r3,r6,#8,#4           ;958
0000e2  f00202f0          AND      r2,r2,#0xf0           ;958
0000e6  431a              ORRS     r2,r2,r3              ;958
                  |L50.232|
0000e8  700a              STRB     r2,[r1,#0]            ;958
0000ea  e016              B        |L50.282|
                  |L50.236|
0000ec  8960              LDRH     r0,[r4,#0xa]          ;963
0000ee  6a61              LDR      r1,[r4,#0x24]         ;963
0000f0  0840              LSRS     r0,r0,#1              ;963
0000f2  fbb5f0f0          UDIV     r0,r5,r0              ;963
0000f6  4401              ADD      r1,r1,r0              ;963
0000f8  4620              MOV      r0,r4                 ;963
0000fa  f7fffffe          BL       move_window
0000fe  2800              CMP      r0,#0                 ;964
000100  d189              BNE      |L50.22|
000102  8962              LDRH     r2,[r4,#0xa]          ;965
000104  0069              LSLS     r1,r5,#1              ;965
000106  fbb1f3f2          UDIV     r3,r1,r2              ;965
00010a  fb021113          MLS      r1,r2,r3,r1           ;965
00010e  4421              ADD      r1,r1,r4              ;965
000110  0a32              LSRS     r2,r6,#8              ;966
000112  f8818034          STRB     r8,[r1,#0x34]         ;966
000116  f8812035          STRB     r2,[r1,#0x35]         ;966
                  |L50.282|
00011a  f8849004          STRB     r9,[r4,#4]            ;959
00011e  e77a              B        |L50.22|
;;;986    #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.putc_bfd||, CODE, READONLY, ALIGN=1

                  putc_bfd PROC
;;;4398   static
;;;4399   void putc_bfd (
000000  b5f8              PUSH     {r3-r7,lr}
;;;4400   	putbuff* pb,
;;;4401   	TCHAR c
;;;4402   )
;;;4403   {
000002  460e              MOV      r6,r1
000004  4604              MOV      r4,r0
;;;4404   	UINT bw;
;;;4405   	int i;
;;;4406   
;;;4407   
;;;4408   	if (_USE_STRFUNC == 2 && c == '\n')	 /* LF -> CRLF conversion */
000006  290a              CMP      r1,#0xa
000008  d102              BNE      |L51.16|
;;;4409   		putc_bfd(pb, '\r');
00000a  210d              MOVS     r1,#0xd
00000c  f7fffffe          BL       putc_bfd
                  |L51.16|
;;;4410   
;;;4411   	i = pb->idx;	/* Buffer write index (-1:error) */
;;;4412   	if (i < 0) return;
000010  6865              LDR      r5,[r4,#4]
000012  2d00              CMP      r5,#0
000014  db16              BLT      |L51.68|
;;;4413   
;;;4414   #if _USE_LFN && _LFN_UNICODE
;;;4415   #if _STRF_ENCODE == 3			/* Write a character in UTF-8 */
;;;4416   	if (c < 0x80) {				/* 7-bit */
;;;4417   		pb->buf[i++] = (BYTE)c;
;;;4418   	} else {
;;;4419   		if (c < 0x800) {		/* 11-bit */
;;;4420   			pb->buf[i++] = (BYTE)(0xC0 | c >> 6);
;;;4421   		} else {				/* 16-bit */
;;;4422   			pb->buf[i++] = (BYTE)(0xE0 | c >> 12);
;;;4423   			pb->buf[i++] = (BYTE)(0x80 | (c >> 6 & 0x3F));
;;;4424   		}
;;;4425   		pb->buf[i++] = (BYTE)(0x80 | (c & 0x3F));
;;;4426   	}
;;;4427   #elif _STRF_ENCODE == 2			/* Write a character in UTF-16BE */
;;;4428   	pb->buf[i++] = (BYTE)(c >> 8);
;;;4429   	pb->buf[i++] = (BYTE)c;
;;;4430   #elif _STRF_ENCODE == 1			/* Write a character in UTF-16LE */
;;;4431   	pb->buf[i++] = (BYTE)c;
;;;4432   	pb->buf[i++] = (BYTE)(c >> 8);
;;;4433   #else							/* Write a character in ANSI/OEM */
;;;4434   	c = ff_convert(c, 0);	/* Unicode -> OEM */
;;;4435   	if (!c) c = '?';
;;;4436   	if (c >= 0x100)
;;;4437   		pb->buf[i++] = (BYTE)(c >> 8);
;;;4438   	pb->buf[i++] = (BYTE)c;
;;;4439   #endif
;;;4440   #else							/* Write a character without conversion */
;;;4441   	pb->buf[i++] = (BYTE)c;
000016  1960              ADDS     r0,r4,r5
000018  1c6d              ADDS     r5,r5,#1
00001a  7306              STRB     r6,[r0,#0xc]
;;;4442   #endif
;;;4443   
;;;4444   	if (i >= (int)(sizeof pb->buf) - 3) {	/* Write buffered characters to the file */
00001c  2d3d              CMP      r5,#0x3d
00001e  db0d              BLT      |L51.60|
;;;4445   		f_write(pb->fp, pb->buf, (UINT)i, &bw);
000020  466b              MOV      r3,sp
000022  462a              MOV      r2,r5
000024  f104010c          ADD      r1,r4,#0xc
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       f_write
;;;4446   		i = (bw == (UINT)i) ? 0 : -1;
00002e  9800              LDR      r0,[sp,#0]
000030  42a8              CMP      r0,r5
000032  d101              BNE      |L51.56|
000034  2500              MOVS     r5,#0
000036  e001              B        |L51.60|
                  |L51.56|
000038  f04f35ff          MOV      r5,#0xffffffff
                  |L51.60|
;;;4447   	}
;;;4448   	pb->idx = i;
;;;4449   	pb->nchr++;
00003c  6065              STR      r5,[r4,#4]
00003e  68a0              LDR      r0,[r4,#8]
000040  1c40              ADDS     r0,r0,#1
000042  60a0              STR      r0,[r4,#8]
                  |L51.68|
;;;4450   }
000044  bdf8              POP      {r3-r7,pc}
;;;4451   
                          ENDP


                          AREA ||i.remove_chain||, CODE, READONLY, ALIGN=1

                  remove_chain PROC
;;;995    static
;;;996    FRESULT remove_chain (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;997    	FATFS* fs,			/* File system object */
;;;998    	DWORD clst			/* Cluster# to remove a chain from */
;;;999    )
;;;1000   {
000004  460f              MOV      r7,r1
000006  4604              MOV      r4,r0
;;;1001   	FRESULT res;
;;;1002   	DWORD nxt;
;;;1003   #if _USE_TRIM
;;;1004   	DWORD scl = clst, ecl = clst, rt[2];
;;;1005   #endif
;;;1006   
;;;1007   	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
000008  2902              CMP      r1,#2
00000a  d316              BCC      |L52.58|
00000c  69a0              LDR      r0,[r4,#0x18]
00000e  42b8              CMP      r0,r7
000010  d913              BLS      |L52.58|
;;;1008   		res = FR_INT_ERR;
;;;1009   
;;;1010   	} else {
;;;1011   		res = FR_OK;
000012  2600              MOVS     r6,#0
;;;1012   		while (clst < fs->n_fatent) {			/* Not a last link? */
000014  e01f              B        |L52.86|
                  |L52.22|
;;;1013   			nxt = get_fat(fs, clst);			/* Get cluster status */
000016  4639              MOV      r1,r7
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       get_fat
00001e  0005              MOVS     r5,r0
;;;1014   			if (nxt == 0) break;				/* Empty cluster? */
000020  d01c              BEQ      |L52.92|
;;;1015   			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
000022  2d01              CMP      r5,#1
000024  d009              BEQ      |L52.58|
;;;1016   			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
000026  1c68              ADDS     r0,r5,#1
000028  d009              BEQ      |L52.62|
;;;1017   			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
00002a  2200              MOVS     r2,#0
00002c  4639              MOV      r1,r7
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       put_fat
000034  0006              MOVS     r6,r0
;;;1018   			if (res != FR_OK) break;
000036  d111              BNE      |L52.92|
000038  e003              B        |L52.66|
                  |L52.58|
00003a  2602              MOVS     r6,#2                 ;1015
00003c  e00e              B        |L52.92|
                  |L52.62|
00003e  2601              MOVS     r6,#1                 ;1016
000040  e00c              B        |L52.92|
                  |L52.66|
;;;1019   			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
000042  6920              LDR      r0,[r4,#0x10]
000044  1c41              ADDS     r1,r0,#1
000046  d005              BEQ      |L52.84|
000048  1c40              ADDS     r0,r0,#1
;;;1020   				fs->free_clust++;
;;;1021   				fs->fsi_flag |= 1;
00004a  6120              STR      r0,[r4,#0x10]
00004c  7960              LDRB     r0,[r4,#5]
00004e  f0400001          ORR      r0,r0,#1
000052  7160              STRB     r0,[r4,#5]
                  |L52.84|
;;;1022   			}
;;;1023   #if _USE_TRIM
;;;1024   			if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
;;;1025   				ecl = nxt;
;;;1026   			} else {				/* End of contiguous clusters */ 
;;;1027   				rt[0] = clust2sect(fs, scl);					/* Start sector */
;;;1028   				rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
;;;1029   				disk_ioctl(fs->drv, CTRL_TRIM, rt);				/* Erase the block */
;;;1030   				scl = ecl = nxt;
;;;1031   			}
;;;1032   #endif
;;;1033   			clst = nxt;	/* Next cluster */
000054  462f              MOV      r7,r5
                  |L52.86|
000056  69a0              LDR      r0,[r4,#0x18]         ;1012
000058  42b8              CMP      r0,r7                 ;1012
00005a  d8dc              BHI      |L52.22|
                  |L52.92|
;;;1034   		}
;;;1035   	}
;;;1036   
;;;1037   	return res;
00005c  4630              MOV      r0,r6
;;;1038   }
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;1039   #endif
                          ENDP


                          AREA ||i.st_clust||, CODE, READONLY, ALIGN=1

                  st_clust PROC
;;;1308   static
;;;1309   void st_clust (
000000  7681              STRB     r1,[r0,#0x1a]
;;;1310   	BYTE* dir,	/* Pointer to the directory entry */
;;;1311   	DWORD cl	/* Value to be set */
;;;1312   )
;;;1313   {
;;;1314   	ST_WORD(dir+DIR_FstClusLO, cl);
000002  0a0a              LSRS     r2,r1,#8
000004  76c2              STRB     r2,[r0,#0x1b]
;;;1315   	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
000006  0c0a              LSRS     r2,r1,#16
000008  7502              STRB     r2,[r0,#0x14]
00000a  0e09              LSRS     r1,r1,#24
00000c  7541              STRB     r1,[r0,#0x15]
;;;1316   }
00000e  4770              BX       lr
;;;1317   #endif
                          ENDP


                          AREA ||i.sum_sfn||, CODE, READONLY, ALIGN=1

                  sum_sfn PROC
;;;1491   static
;;;1492   BYTE sum_sfn (
000000  4601              MOV      r1,r0
;;;1493   	const BYTE* dir		/* Pointer to the SFN entry */
;;;1494   )
;;;1495   {
;;;1496   	BYTE sum = 0;
000002  2000              MOVS     r0,#0
;;;1497   	UINT n = 11;
000004  220b              MOVS     r2,#0xb
                  |L54.6|
;;;1498   
;;;1499   	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
000006  0843              LSRS     r3,r0,#1
000008  eb0310c0          ADD      r0,r3,r0,LSL #7
00000c  f8113b01          LDRB     r3,[r1],#1
000010  1e52              SUBS     r2,r2,#1
000012  4418              ADD      r0,r0,r3
000014  b2c0              UXTB     r0,r0
000016  d1f6              BNE      |L54.6|
;;;1500   	return sum;
;;;1501   }
000018  4770              BX       lr
;;;1502   #endif
                          ENDP


                          AREA ||i.sync_fs||, CODE, READONLY, ALIGN=1

                  sync_fs PROC
;;;818    static
;;;819    FRESULT sync_fs (	/* FR_OK: successful, FR_DISK_ERR: failed */
000000  b570              PUSH     {r4-r6,lr}
;;;820    	FATFS* fs		/* File system object */
;;;821    )
;;;822    {
000002  4604              MOV      r4,r0
;;;823    	FRESULT res;
;;;824    
;;;825    
;;;826    	res = sync_window(fs);
000004  f7fffffe          BL       sync_window
000008  0005              MOVS     r5,r0
;;;827    	if (res == FR_OK) {
00000a  d14f              BNE      |L55.172|
;;;828    		/* Update FSINFO sector if needed */
;;;829    		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
00000c  7820              LDRB     r0,[r4,#0]
00000e  2803              CMP      r0,#3
000010  d145              BNE      |L55.158|
000012  7960              LDRB     r0,[r4,#5]
000014  2801              CMP      r0,#1
000016  d142              BNE      |L55.158|
;;;830    			/* Create FSINFO structure */
;;;831    			mem_set(fs->win, 0, SS(fs));
000018  f1040034          ADD      r0,r4,#0x34
00001c  8962              LDRH     r2,[r4,#0xa]
00001e  2100              MOVS     r1,#0
000020  4606              MOV      r6,r0
000022  f7fffffe          BL       mem_set
;;;832    			ST_WORD(fs->win+BS_55AA, 0xAA55);
000026  2055              MOVS     r0,#0x55
000028  f8840232          STRB     r0,[r4,#0x232]
00002c  20aa              MOVS     r0,#0xaa
00002e  f8840233          STRB     r0,[r4,#0x233]
;;;833    			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
000032  2052              MOVS     r0,#0x52
000034  f8840034          STRB     r0,[r4,#0x34]
000038  f8840035          STRB     r0,[r4,#0x35]
00003c  2261              MOVS     r2,#0x61
00003e  f8842036          STRB     r2,[r4,#0x36]
000042  2041              MOVS     r0,#0x41
000044  f8840037          STRB     r0,[r4,#0x37]
;;;834    			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
000048  2172              MOVS     r1,#0x72
00004a  f8841218          STRB     r1,[r4,#0x218]
00004e  f8841219          STRB     r1,[r4,#0x219]
000052  f884021a          STRB     r0,[r4,#0x21a]
000056  f884221b          STRB     r2,[r4,#0x21b]
;;;835    			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
00005a  6920              LDR      r0,[r4,#0x10]
00005c  f884021c          STRB     r0,[r4,#0x21c]
000060  0a01              LSRS     r1,r0,#8
000062  f884121d          STRB     r1,[r4,#0x21d]
000066  0c01              LSRS     r1,r0,#16
000068  f884121e          STRB     r1,[r4,#0x21e]
00006c  0e00              LSRS     r0,r0,#24
00006e  f884021f          STRB     r0,[r4,#0x21f]
;;;836    			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
000072  68e0              LDR      r0,[r4,#0xc]
000074  f8840220          STRB     r0,[r4,#0x220]
000078  0a01              LSRS     r1,r0,#8
00007a  f8841221          STRB     r1,[r4,#0x221]
00007e  0c01              LSRS     r1,r0,#16
000080  f8841222          STRB     r1,[r4,#0x222]
000084  0e00              LSRS     r0,r0,#24
000086  f8840223          STRB     r0,[r4,#0x223]
;;;837    			/* Write it into the FSINFO sector */
;;;838    			fs->winsect = fs->volbase + 1;
00008a  6a22              LDR      r2,[r4,#0x20]
;;;839    			disk_write(fs->drv, fs->win, fs->winsect, 1);
00008c  2301              MOVS     r3,#1
00008e  1c52              ADDS     r2,r2,#1              ;838
000090  6322              STR      r2,[r4,#0x30]
000092  7860              LDRB     r0,[r4,#1]
000094  4631              MOV      r1,r6
000096  f7fffffe          BL       disk_write
;;;840    			fs->fsi_flag = 0;
00009a  2000              MOVS     r0,#0
00009c  7160              STRB     r0,[r4,#5]
                  |L55.158|
;;;841    		}
;;;842    		/* Make sure that no pending write process in the physical drive */
;;;843    		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
00009e  2200              MOVS     r2,#0
0000a0  7860              LDRB     r0,[r4,#1]
0000a2  4611              MOV      r1,r2
0000a4  f7fffffe          BL       disk_ioctl
0000a8  b100              CBZ      r0,|L55.172|
;;;844    			res = FR_DISK_ERR;
0000aa  2501              MOVS     r5,#1
                  |L55.172|
;;;845    	}
;;;846    
;;;847    	return res;
0000ac  4628              MOV      r0,r5
;;;848    }
0000ae  bd70              POP      {r4-r6,pc}
;;;849    #endif
                          ENDP


                          AREA ||i.sync_window||, CODE, READONLY, ALIGN=1

                  sync_window PROC
;;;758    static
;;;759    FRESULT sync_window (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;760    	FATFS* fs		/* File system object */
;;;761    )
;;;762    {
000004  4604              MOV      r4,r0
;;;763    	DWORD wsect;
;;;764    	UINT nf;
;;;765    	FRESULT res = FR_OK;
;;;766    
;;;767    
;;;768    	if (fs->wflag) {	/* Write back the sector if it is dirty */
000006  7900              LDRB     r0,[r0,#4]
000008  2700              MOVS     r7,#0                 ;765
00000a  b1f8              CBZ      r0,|L56.76|
;;;769    		wsect = fs->winsect;	/* Current sector number */
;;;770    		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
00000c  6b26              LDR      r6,[r4,#0x30]
00000e  f1040134          ADD      r1,r4,#0x34
000012  7860              LDRB     r0,[r4,#1]
000014  2301              MOVS     r3,#1
000016  4632              MOV      r2,r6
000018  4688              MOV      r8,r1
00001a  f7fffffe          BL       disk_write
00001e  b108              CBZ      r0,|L56.36|
;;;771    			res = FR_DISK_ERR;
000020  2701              MOVS     r7,#1
000022  e013              B        |L56.76|
                  |L56.36|
;;;772    		} else {
;;;773    			fs->wflag = 0;
000024  2000              MOVS     r0,#0
000026  7120              STRB     r0,[r4,#4]
;;;774    			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
000028  6a60              LDR      r0,[r4,#0x24]
00002a  69e1              LDR      r1,[r4,#0x1c]
00002c  1a30              SUBS     r0,r6,r0
00002e  4288              CMP      r0,r1
000030  d20c              BCS      |L56.76|
;;;775    				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
000032  78e5              LDRB     r5,[r4,#3]
000034  e008              B        |L56.72|
                  |L56.54|
;;;776    					wsect += fs->fsize;
000036  69e0              LDR      r0,[r4,#0x1c]
;;;777    					disk_write(fs->drv, fs->win, wsect, 1);
000038  2301              MOVS     r3,#1
00003a  4406              ADD      r6,r6,r0              ;776
00003c  7860              LDRB     r0,[r4,#1]
00003e  4632              MOV      r2,r6
000040  4641              MOV      r1,r8
000042  f7fffffe          BL       disk_write
000046  1e6d              SUBS     r5,r5,#1
                  |L56.72|
000048  2d02              CMP      r5,#2                 ;775
00004a  d2f4              BCS      |L56.54|
                  |L56.76|
;;;778    				}
;;;779    			}
;;;780    		}
;;;781    	}
;;;782    	return res;
00004c  4638              MOV      r0,r7
;;;783    }
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;784    #endif
                          ENDP


                          AREA ||i.validate||, CODE, READONLY, ALIGN=1

                  validate PROC
;;;2356   static
;;;2357   FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
000000  b510              PUSH     {r4,lr}
;;;2358   	void* obj		/* Pointer to the object FIL/DIR to check validity */
;;;2359   )
;;;2360   {
000002  b138              CBZ      r0,|L57.20|
;;;2361   	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */
;;;2362   
;;;2363   
;;;2364   	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
000004  6801              LDR      r1,[r0,#0]
000006  b129              CBZ      r1,|L57.20|
000008  780a              LDRB     r2,[r1,#0]
00000a  b11a              CBZ      r2,|L57.20|
00000c  88ca              LDRH     r2,[r1,#6]
00000e  8880              LDRH     r0,[r0,#4]
000010  4282              CMP      r2,r0
000012  d001              BEQ      |L57.24|
                  |L57.20|
;;;2365   		return FR_INVALID_OBJECT;
000014  2009              MOVS     r0,#9
                  |L57.22|
;;;2366   
;;;2367   	ENTER_FF(fil->fs);		/* Lock file system */
;;;2368   
;;;2369   	if (disk_status(fil->fs->drv) & STA_NOINIT)
;;;2370   		return FR_NOT_READY;
;;;2371   
;;;2372   	return FR_OK;
;;;2373   }
000016  bd10              POP      {r4,pc}
                  |L57.24|
000018  7848              LDRB     r0,[r1,#1]            ;2369
00001a  f7fffffe          BL       disk_status
00001e  07c0              LSLS     r0,r0,#31             ;2369
000020  d0f9              BEQ      |L57.22|
000022  2003              MOVS     r0,#3                 ;2370
000024  bd10              POP      {r4,pc}
;;;2374   
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  LfnOfs
000000  01030507          DCB      0x01,0x03,0x05,0x07
000004  090e1012          DCB      0x09,0x0e,0x10,0x12
000008  1416181c          DCB      0x14,0x16,0x18,0x1c
00000c  1e00              DCB      0x1e,0x00
                  vst
00000e  0400              DCW      0x0400
000010  02000100          DCW      0x0200,0x0100
000014  00800040          DCW      0x0080,0x0040
000018  00200010          DCW      0x0020,0x0010
00001c  00080004          DCW      0x0008,0x0004
000020  00020000          DCW      0x0002,0x0000
                  ||cst||
000024  80004000          DCW      0x8000,0x4000
000028  20001000          DCW      0x2000,0x1000
00002c  08004000          DCW      0x0800,0x4000
000030  20001000          DCW      0x2000,0x1000
000034  08000400          DCW      0x0800,0x0400
000038  0200              DCW      0x0200

                          AREA ||.data||, DATA, ALIGN=2

                  CurrVol
000000  0000              DCB      0x00,0x00
                  Fsid
000002  0000              DCB      0x00,0x00
                  FatFs
                          %        8

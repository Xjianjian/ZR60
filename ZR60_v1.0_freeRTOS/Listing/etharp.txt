; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\etharp.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\etharp.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\ZR60_v1.0_freeRTOS -I..\..\Lwip\App -I..\..\Lwip\Bsp -I..\..\Lwip\Bsp\LAN8742A -I..\..\Lwip\lwip-1.4.1 -I..\..\Lwip\lwip-1.4.1\port -I..\..\Lwip\lwip-1.4.1\port\arch -I..\..\Lwip\lwip-1.4.1\port\Standalone -I..\..\Lwip\lwip-1.4.1\src\include -I..\..\Lwip\lwip-1.4.1\src\include\ipv4 -I..\..\Lwip\lwip-1.4.1\src\include\lwip -I..\..\Lwip\lwip-1.4.1\src\include\netif -I..\..\Ecal\BtnFltr -I..\..\Ecal\UartComn -I..\..\Ecal\MemIf -I..\..\APP -I..\..\APP\BlackListMng -I..\..\APP\SeverNewsPush -I..\..\APP\NewsPull -I..\..\Ecal -I..\..\Ecal\JsonIf -I..\..\Ecal\Mcu_Init -I..\..\Service -I..\..\Complex -I..\..\Complex\FATFS -I..\..\FreeRTOS\Source\include -I..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\FreeRTOS -I.\RTE\_ZR60 -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=..\..\output\etharp.crf ..\..\Lwip\lwip-1.4.1\src\netif\etharp.c]
                          THUMB

                          AREA ||i.etharp_arp_input||, CODE, READONLY, ALIGN=2

                  etharp_arp_input PROC
;;;687    static void
;;;688    etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;689    {
000004  4690              MOV      r8,r2
000006  4689              MOV      r9,r1
000008  0005              MOVS     r5,r0
00000a  d010              BEQ      |L1.46|
;;;690      struct etharp_hdr *hdr;
;;;691      struct eth_hdr *ethhdr;
;;;692      /* these are aligned properly, whereas the ARP header fields might not be */
;;;693      ip_addr_t sipaddr, dipaddr;
;;;694      u8_t for_us;
;;;695    #if LWIP_AUTOIP
;;;696      const u8_t * ethdst_hwaddr;
;;;697    #endif /* LWIP_AUTOIP */
;;;698    
;;;699      LWIP_ERROR("netif != NULL", (netif != NULL), return;);
;;;700    
;;;701      /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
;;;702         since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
;;;703      if (p->len < SIZEOF_ETHARP_PACKET) {
00000c  f8b8000a          LDRH     r0,[r8,#0xa]
000010  282a              CMP      r0,#0x2a
000012  d366              BCC      |L1.226|
;;;704        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
;;;705          ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len,
;;;706          (s16_t)SIZEOF_ETHARP_PACKET));
;;;707        ETHARP_STATS_INC(etharp.lenerr);
;;;708        ETHARP_STATS_INC(etharp.drop);
;;;709        pbuf_free(p);
;;;710        return;
;;;711      }
;;;712    
;;;713      ethhdr = (struct eth_hdr *)p->payload;
;;;714      hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
000014  f8d86004          LDR      r6,[r8,#4]
;;;715    #if ETHARP_SUPPORT_VLAN
;;;716      if (ethhdr->type == PP_HTONS(ETHTYPE_VLAN)) {
;;;717        hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
;;;718      }
;;;719    #endif /* ETHARP_SUPPORT_VLAN */
;;;720    
;;;721      /* RFC 826 "Packet Reception": */
;;;722      if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
000018  f44f7a80          MOV      r10,#0x100
00001c  4634              MOV      r4,r6                 ;714
00001e  f8340f0e          LDRH     r0,[r4,#0xe]!
000022  4550              CMP      r0,r10
000024  d15d              BNE      |L1.226|
;;;723          (hdr->hwlen != ETHARP_HWADDR_LEN) ||
000026  7920              LDRB     r0,[r4,#4]
000028  2806              CMP      r0,#6
00002a  d15a              BNE      |L1.226|
00002c  e004              B        |L1.56|
                  |L1.46|
00002e  a02f              ADR      r0,|L1.236|
000030  f7fffffe          BL       __2printf
                  |L1.52|
;;;724          (hdr->protolen != sizeof(ip_addr_t)) ||
;;;725          (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
;;;726        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
;;;727          ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
;;;728          hdr->hwtype, hdr->hwlen, hdr->proto, hdr->protolen));
;;;729        ETHARP_STATS_INC(etharp.proterr);
;;;730        ETHARP_STATS_INC(etharp.drop);
;;;731        pbuf_free(p);
;;;732        return;
;;;733      }
;;;734      ETHARP_STATS_INC(etharp.recv);
;;;735    
;;;736    #if LWIP_AUTOIP
;;;737      /* We have to check if a host already has configured our random
;;;738       * created link local address and continously check if there is
;;;739       * a host with this IP-address so we can detect collisions */
;;;740      autoip_arp_reply(netif, hdr);
;;;741    #endif /* LWIP_AUTOIP */
;;;742    
;;;743      /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
;;;744       * structure packing (not using structure copy which breaks strict-aliasing rules). */
;;;745      IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
;;;746      IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
;;;747    
;;;748      /* this interface is not configured? */
;;;749      if (ip_addr_isany(&netif->ip_addr)) {
;;;750        for_us = 0;
;;;751      } else {
;;;752        /* ARP packet directed to us? */
;;;753        for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
;;;754      }
;;;755    
;;;756      /* ARP message directed to us?
;;;757          -> add IP address in ARP cache; assume requester wants to talk to us,
;;;758             can result in directly sending the queued packets for this host.
;;;759         ARP message not directed to us?
;;;760          ->  update the source IP address in the cache, if present */
;;;761      etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
;;;762                       for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);
;;;763    
;;;764      /* now act on the message itself */
;;;765      switch (hdr->opcode) {
;;;766      /* ARP request? */
;;;767      case PP_HTONS(ARP_REQUEST):
;;;768        /* ARP request. If it asked for our address, we send out a
;;;769         * reply. In any case, we time-stamp any existing ARP entry,
;;;770         * and possiby send out an IP packet that was queued on it. */
;;;771    
;;;772        LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
;;;773        /* ARP request for our address? */
;;;774        if (for_us) {
;;;775    
;;;776          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
;;;777          /* Re-use pbuf to send ARP reply.
;;;778             Since we are re-using an existing pbuf, we can't call etharp_raw since
;;;779             that would allocate a new pbuf. */
;;;780          hdr->opcode = htons(ARP_REPLY);
;;;781    
;;;782          IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
;;;783          IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
;;;784    
;;;785          LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
;;;786                      (netif->hwaddr_len == ETHARP_HWADDR_LEN));
;;;787    #if LWIP_AUTOIP
;;;788          /* If we are using Link-Local, all ARP packets that contain a Link-Local
;;;789           * 'sender IP address' MUST be sent using link-layer broadcast instead of
;;;790           * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
;;;791          ethdst_hwaddr = ip_addr_islinklocal(&netif->ip_addr) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
;;;792    #endif /* LWIP_AUTOIP */
;;;793    
;;;794          ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
;;;795    #if LWIP_AUTOIP
;;;796          ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
;;;797    #else  /* LWIP_AUTOIP */
;;;798          ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
;;;799    #endif /* LWIP_AUTOIP */
;;;800          ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
;;;801          ETHADDR16_COPY(&ethhdr->src, ethaddr);
;;;802    
;;;803          /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
;;;804             are already correct, we tested that before */
;;;805    
;;;806          /* return ARP reply */
;;;807          netif->linkoutput(netif, p);
;;;808        /* we are not configured? */
;;;809        } else if (ip_addr_isany(&netif->ip_addr)) {
;;;810          /* { for_us == 0 and netif->ip_addr.addr == 0 } */
;;;811          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: we are unconfigured, ARP request ignored.\n"));
;;;812        /* request was not directed to us */
;;;813        } else {
;;;814          /* { for_us == 0 and netif->ip_addr.addr != 0 } */
;;;815          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
;;;816        }
;;;817        break;
;;;818      case PP_HTONS(ARP_REPLY):
;;;819        /* ARP reply. We already updated the ARP cache earlier. */
;;;820        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP reply\n"));
;;;821    #if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
;;;822        /* DHCP wants to know about ARP replies from any host with an
;;;823         * IP address also offered to us by the DHCP server. We do not
;;;824         * want to take a duplicate IP address on a single network.
;;;825         * @todo How should we handle redundant (fail-over) interfaces? */
;;;826        dhcp_arp_reply(netif, &sipaddr);
;;;827    #endif /* (LWIP_DHCP && DHCP_DOES_ARP_CHECK) */
;;;828        break;
;;;829      default:
;;;830        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
;;;831        ETHARP_STATS_INC(etharp.err);
;;;832        break;
;;;833      }
;;;834      /* free ARP packet */
;;;835      pbuf_free(p);
;;;836    }
000034  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.56|
000038  7960              LDRB     r0,[r4,#5]            ;724
00003a  2804              CMP      r0,#4                 ;724
00003c  d151              BNE      |L1.226|
00003e  8860              LDRH     r0,[r4,#2]            ;725
000040  2808              CMP      r0,#8                 ;725
000042  d14e              BNE      |L1.226|
000044  f8d4000e          LDR      r0,[r4,#0xe]          ;745
000048  9000              STR      r0,[sp,#0]            ;746
00004a  69a1              LDR      r1,[r4,#0x18]         ;746
00004c  1d28              ADDS     r0,r5,#4              ;749
00004e  d005              BEQ      |L1.92|
000050  6868              LDR      r0,[r5,#4]            ;749
000052  b118              CBZ      r0,|L1.92|
000054  4281              CMP      r1,r0                 ;753
000056  d101              BNE      |L1.92|
000058  2701              MOVS     r7,#1                 ;753
00005a  e000              B        |L1.94|
                  |L1.92|
00005c  2700              MOVS     r7,#0                 ;753
                  |L1.94|
00005e  b10f              CBZ      r7,|L1.100|
000060  2301              MOVS     r3,#1                 ;762
000062  e000              B        |L1.102|
                  |L1.100|
000064  2302              MOVS     r3,#2                 ;762
                  |L1.102|
000066  f1040208          ADD      r2,r4,#8              ;762
00006a  4669              MOV      r1,sp                 ;762
00006c  4628              MOV      r0,r5                 ;762
00006e  f7fffffe          BL       etharp_update_arp_entry
000072  88e0              LDRH     r0,[r4,#6]            ;765
000074  4550              CMP      r0,r10                ;765
000076  d003              BEQ      |L1.128|
000078  f5b07f00          CMP      r0,#0x200             ;765
00007c  d131              BNE      |L1.226|
00007e  e02c              B        |L1.218|
                  |L1.128|
000080  b357              CBZ      r7,|L1.216|
000082  2002              MOVS     r0,#2                 ;780
000084  f7fffffe          BL       lwip_htons
000088  80e0              STRH     r0,[r4,#6]            ;780
00008a  f8d4000e          LDR      r0,[r4,#0xe]          ;782
00008e  61a0              STR      r0,[r4,#0x18]         ;782
000090  6868              LDR      r0,[r5,#4]            ;783
000092  f8c4000e          STR      r0,[r4,#0xe]          ;783
000096  f895002a          LDRB     r0,[r5,#0x2a]         ;785
00009a  2806              CMP      r0,#6                 ;785
00009c  d002              BEQ      |L1.164|
00009e  4817              LDR      r0,|L1.252|
0000a0  f7fffffe          BL       __2printf
                  |L1.164|
0000a4  68a0              LDR      r0,[r4,#8]            ;794
0000a6  f8c40012          STR      r0,[r4,#0x12]         ;794
0000aa  89a0              LDRH     r0,[r4,#0xc]          ;794
0000ac  82e0              STRH     r0,[r4,#0x16]         ;794
0000ae  68a0              LDR      r0,[r4,#8]            ;798
0000b0  6030              STR      r0,[r6,#0]            ;798
0000b2  89a0              LDRH     r0,[r4,#0xc]          ;798
0000b4  80b0              STRH     r0,[r6,#4]            ;798
0000b6  f8d91000          LDR      r1,[r9,#0]            ;800
0000ba  60a1              STR      r1,[r4,#8]            ;800
0000bc  f8b90004          LDRH     r0,[r9,#4]            ;800
0000c0  81a0              STRH     r0,[r4,#0xc]          ;800
0000c2  f8d91000          LDR      r1,[r9,#0]            ;801
0000c6  f8c61006          STR      r1,[r6,#6]            ;801
0000ca  f8b90004          LDRH     r0,[r9,#4]            ;801
0000ce  8170              STRH     r0,[r6,#0xa]          ;801
0000d0  69aa              LDR      r2,[r5,#0x18]         ;807
0000d2  4641              MOV      r1,r8                 ;807
0000d4  4628              MOV      r0,r5                 ;807
0000d6  4790              BLX      r2                    ;807
                  |L1.216|
0000d8  e003              B        |L1.226|
                  |L1.218|
0000da  4669              MOV      r1,sp                 ;826
0000dc  4628              MOV      r0,r5                 ;826
0000de  f7fffffe          BL       dhcp_arp_reply
                  |L1.226|
0000e2  4640              MOV      r0,r8                 ;835
0000e4  f7fffffe          BL       pbuf_free
0000e8  e7a4              B        |L1.52|
;;;837    
                          ENDP

0000ea  0000              DCW      0x0000
                  |L1.236|
0000ec  6e657469          DCB      "netif != NULL",0
0000f0  6620213d
0000f4  204e554c
0000f8  4c00    
0000fa  00                DCB      0
0000fb  00                DCB      0
                  |L1.252|
                          DCD      ||.conststring||

                          AREA ||i.etharp_cleanup_netif||, CODE, READONLY, ALIGN=2

                  etharp_cleanup_netif PROC
;;;578     */
;;;579    void etharp_cleanup_netif(struct netif *netif)
000000  b570              PUSH     {r4-r6,lr}
;;;580    {
;;;581      u8_t i;
;;;582    
;;;583      for (i = 0; i < ARP_TABLE_SIZE; ++i) {
;;;584        u8_t state = arp_table[i].state;
000002  4e0a              LDR      r6,|L2.44|
000004  4605              MOV      r5,r0                 ;580
000006  2400              MOVS     r4,#0                 ;583
                  |L2.8|
000008  eb040084          ADD      r0,r4,r4,LSL #2
00000c  eb060080          ADD      r0,r6,r0,LSL #2
000010  7c81              LDRB     r1,[r0,#0x12]
;;;585        if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
000012  b129              CBZ      r1,|L2.32|
000014  6880              LDR      r0,[r0,#8]
000016  42a8              CMP      r0,r5
000018  d102              BNE      |L2.32|
;;;586          etharp_free_entry(i);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       etharp_free_entry
                  |L2.32|
000020  1c64              ADDS     r4,r4,#1
000022  b2e4              UXTB     r4,r4                 ;583
000024  2c0a              CMP      r4,#0xa               ;583
000026  d3ef              BCC      |L2.8|
;;;587        }
;;;588      }
;;;589    }
000028  bd70              POP      {r4-r6,pc}
;;;590    
                          ENDP

00002a  0000              DCW      0x0000
                  |L2.44|
                          DCD      ||.bss||

                          AREA ||i.etharp_find_addr||, CODE, READONLY, ALIGN=2

                  etharp_find_addr PROC
;;;602    s8_t
;;;603    etharp_find_addr(struct netif *netif, ip_addr_t *ipaddr,
000000  b570              PUSH     {r4-r6,lr}
;;;604             struct eth_addr **eth_ret, ip_addr_t **ip_ret)
;;;605    {
000002  461c              MOV      r4,r3
000004  0015              MOVS     r5,r2
000006  460e              MOV      r6,r1
000008  d000              BEQ      |L3.12|
;;;606      s8_t i;
;;;607    
;;;608      LWIP_ASSERT("eth_ret != NULL && ip_ret != NULL",
00000a  b914              CBNZ     r4,|L3.18|
                  |L3.12|
00000c  a00c              ADR      r0,|L3.64|
00000e  f7fffffe          BL       __2printf
                  |L3.18|
;;;609        eth_ret != NULL && ip_ret != NULL);
;;;610    
;;;611      LWIP_UNUSED_ARG(netif);
;;;612    
;;;613      i = etharp_find_entry(ipaddr, ETHARP_FLAG_FIND_ONLY);
000012  2102              MOVS     r1,#2
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       etharp_find_entry
;;;614      if((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
00001a  2800              CMP      r0,#0
00001c  db0d              BLT      |L3.58|
00001e  4911              LDR      r1,|L3.100|
000020  eb000280          ADD      r2,r0,r0,LSL #2
000024  eb010182          ADD      r1,r1,r2,LSL #2
000028  7c8a              LDRB     r2,[r1,#0x12]
00002a  2a02              CMP      r2,#2
00002c  d305              BCC      |L3.58|
;;;615          *eth_ret = &arp_table[i].ethaddr;
00002e  f101020c          ADD      r2,r1,#0xc
000032  1d09              ADDS     r1,r1,#4
;;;616          *ip_ret = &arp_table[i].ipaddr;
000034  602a              STR      r2,[r5,#0]
;;;617          return i;
000036  6021              STR      r1,[r4,#0]
;;;618      }
;;;619      return -1;
;;;620    }
000038  bd70              POP      {r4-r6,pc}
                  |L3.58|
00003a  f04f30ff          MOV      r0,#0xffffffff        ;619
00003e  bd70              POP      {r4-r6,pc}
;;;621    
                          ENDP

                  |L3.64|
000040  6574685f          DCB      "eth_ret != NULL && ip_ret != NULL",0
000044  72657420
000048  213d204e
00004c  554c4c20
000050  26262069
000054  705f7265
000058  7420213d
00005c  204e554c
000060  4c00    
000062  00                DCB      0
000063  00                DCB      0
                  |L3.100|
                          DCD      ||.bss||

                          AREA ||i.etharp_find_entry||, CODE, READONLY, ALIGN=2

                  etharp_find_entry PROC
;;;265    static s8_t
;;;266    etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
000000  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;267    {
000004  4680              MOV      r8,r0
;;;268      s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
000006  200a              MOVS     r0,#0xa
000008  b085              SUB      sp,sp,#0x14           ;267
;;;269      s8_t empty = ARP_TABLE_SIZE;
;;;270      u8_t i = 0, age_pending = 0, age_stable = 0;
00000a  2400              MOVS     r4,#0
00000c  9002              STR      r0,[sp,#8]            ;268
00000e  4607              MOV      r7,r0                 ;269
000010  46a3              MOV      r11,r4
000012  46a2              MOV      r10,r4
;;;271      /* oldest entry with packets on queue */
;;;272      s8_t old_queue = ARP_TABLE_SIZE;
000014  9001              STR      r0,[sp,#4]
;;;273      /* its age */
;;;274      u8_t age_queue = 0;
000016  46a1              MOV      r9,r4
000018  9000              STR      r0,[sp,#0]
                  |L4.26|
;;;275    
;;;276      /**
;;;277       * a) do a search through the cache, remember candidates
;;;278       * b) select candidate entry
;;;279       * c) create new entry
;;;280       */
;;;281    
;;;282      /* a) in a single search sweep, do all of this
;;;283       * 1) remember the first empty entry (if any)
;;;284       * 2) remember the oldest stable entry (if any)
;;;285       * 3) remember the oldest pending entry without queued packets (if any)
;;;286       * 4) remember the oldest pending entry with queued packets (if any)
;;;287       * 5) search for a matching IP entry, either pending or stable
;;;288       *    until 5 matches, or all entries are searched for.
;;;289       */
;;;290    
;;;291      for (i = 0; i < ARP_TABLE_SIZE; ++i) {
;;;292        u8_t state = arp_table[i].state;
00001a  4942              LDR      r1,|L4.292|
00001c  eb040084          ADD      r0,r4,r4,LSL #2
000020  eb010680          ADD      r6,r1,r0,LSL #2
000024  9003              STR      r0,[sp,#0xc]
000026  7cb5              LDRB     r5,[r6,#0x12]
;;;293        /* no empty entry found yet and now we do find one? */
;;;294        if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
000028  2f0a              CMP      r7,#0xa
00002a  d013              BEQ      |L4.84|
;;;295          LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
;;;296          /* remember first empty entry */
;;;297          empty = i;
;;;298        } else if (state != ETHARP_STATE_EMPTY) {
00002c  b305              CBZ      r5,|L4.112|
                  |L4.46|
;;;299          LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
00002e  2d01              CMP      r5,#1
000030  d004              BEQ      |L4.60|
000032  2d02              CMP      r5,#2
000034  d202              BCS      |L4.60|
000036  a03c              ADR      r0,|L4.296|
000038  f7fffffe          BL       __2printf
                  |L4.60|
;;;300            state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
;;;301          /* if given, does IP address match IP address in ARP entry? */
;;;302          if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
00003c  f1b80f00          CMP      r8,#0
000040  d00c              BEQ      |L4.92|
000042  f8d80000          LDR      r0,[r8,#0]
000046  6871              LDR      r1,[r6,#4]
000048  4288              CMP      r0,r1
00004a  d107              BNE      |L4.92|
                  |L4.76|
;;;303            LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
;;;304            /* found exact IP address match, simply bail out */
;;;305            return i;
00004c  b260              SXTB     r0,r4
                  |L4.78|
;;;306          }
;;;307          /* pending entry? */
;;;308          if (state == ETHARP_STATE_PENDING) {
;;;309            /* pending with queued packets? */
;;;310            if (arp_table[i].q != NULL) {
;;;311              if (arp_table[i].ctime >= age_queue) {
;;;312                old_queue = i;
;;;313                age_queue = arp_table[i].ctime;
;;;314              }
;;;315            } else
;;;316            /* pending without queued packets? */
;;;317            {
;;;318              if (arp_table[i].ctime >= age_pending) {
;;;319                old_pending = i;
;;;320                age_pending = arp_table[i].ctime;
;;;321              }
;;;322            }
;;;323          /* stable entry? */
;;;324          } else if (state >= ETHARP_STATE_STABLE) {
;;;325    #if ETHARP_SUPPORT_STATIC_ENTRIES
;;;326            /* don't record old_stable for static entries since they never expire */
;;;327            if (state < ETHARP_STATE_STATIC)
;;;328    #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
;;;329            {
;;;330              /* remember entry with oldest stable entry in oldest, its age in maxtime */
;;;331              if (arp_table[i].ctime >= age_stable) {
;;;332                old_stable = i;
;;;333                age_stable = arp_table[i].ctime;
;;;334              }
;;;335            }
;;;336          }
;;;337        }
;;;338      }
;;;339      /* { we have no match } => try to create a new entry */
;;;340       
;;;341      /* don't create new entry, only search? */
;;;342      if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
;;;343          /* or no empty entry found and not allowed to recycle? */
;;;344          ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
;;;345        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty entry found and not allowed to recycle\n"));
;;;346        return (s8_t)ERR_MEM;
;;;347      }
;;;348      
;;;349      /* b) choose the least destructive entry to recycle:
;;;350       * 1) empty entry
;;;351       * 2) oldest stable entry
;;;352       * 3) oldest pending entry without queued packets
;;;353       * 4) oldest pending entry with queued packets
;;;354       * 
;;;355       * { ETHARP_FLAG_TRY_HARD is set at this point }
;;;356       */ 
;;;357    
;;;358      /* 1) empty entry available? */
;;;359      if (empty < ARP_TABLE_SIZE) {
;;;360        i = empty;
;;;361        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
;;;362      } else {
;;;363        /* 2) found recyclable stable entry? */
;;;364        if (old_stable < ARP_TABLE_SIZE) {
;;;365          /* recycle oldest stable*/
;;;366          i = old_stable;
;;;367          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
;;;368          /* no queued packets should exist on stable entries */
;;;369          LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
;;;370        /* 3) found recyclable pending entry without queued packets? */
;;;371        } else if (old_pending < ARP_TABLE_SIZE) {
;;;372          /* recycle oldest pending */
;;;373          i = old_pending;
;;;374          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
;;;375        /* 4) found recyclable pending entry with queued packets? */
;;;376        } else if (old_queue < ARP_TABLE_SIZE) {
;;;377          /* recycle oldest pending (queued packets are free in etharp_free_entry) */
;;;378          i = old_queue;
;;;379          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
;;;380          /* no empty or recyclable entries found */
;;;381        } else {
;;;382          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entries found\n"));
;;;383          return (s8_t)ERR_MEM;
;;;384        }
;;;385    
;;;386        /* { empty or recyclable entry found } */
;;;387        LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
;;;388        etharp_free_entry(i);
;;;389      }
;;;390    
;;;391      LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
;;;392      LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
;;;393        arp_table[i].state == ETHARP_STATE_EMPTY);
;;;394    
;;;395      /* IP address given? */
;;;396      if (ipaddr != NULL) {
;;;397        /* set IP address */
;;;398        ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
;;;399      }
;;;400      arp_table[i].ctime = 0;
;;;401      return (err_t)i;
;;;402    }
00004e  b007              ADD      sp,sp,#0x1c
000050  e8bd8ff0          POP      {r4-r11,pc}
                  |L4.84|
000054  2d00              CMP      r5,#0                 ;294
000056  d1ea              BNE      |L4.46|
000058  b267              SXTB     r7,r4                 ;297
00005a  e009              B        |L4.112|
                  |L4.92|
00005c  2d01              CMP      r5,#1                 ;308
00005e  d015              BEQ      |L4.140|
000060  2d02              CMP      r5,#2                 ;324
000062  d305              BCC      |L4.112|
000064  7cf0              LDRB     r0,[r6,#0x13]         ;331
000066  4550              CMP      r0,r10                ;331
000068  d302              BCC      |L4.112|
00006a  b261              SXTB     r1,r4                 ;332
00006c  4682              MOV      r10,r0                ;333
00006e  9101              STR      r1,[sp,#4]            ;333
                  |L4.112|
000070  1c64              ADDS     r4,r4,#1              ;333
000072  b2e4              UXTB     r4,r4                 ;291
000074  2c0a              CMP      r4,#0xa               ;291
000076  d3d0              BCC      |L4.26|
000078  9806              LDR      r0,[sp,#0x18]         ;342
00007a  0781              LSLS     r1,r0,#30             ;342
00007c  f04f30ff          MOV      r0,#0xffffffff        ;346
000080  d4e5              BMI      |L4.78|
000082  2f0a              CMP      r7,#0xa               ;344
000084  d015              BEQ      |L4.178|
000086  da17              BGE      |L4.184|
000088  b2fc              UXTB     r4,r7                 ;360
00008a  e032              B        |L4.242|
                  |L4.140|
00008c  4825              LDR      r0,|L4.292|
00008e  9903              LDR      r1,[sp,#0xc]          ;310
000090  f8500021          LDR      r0,[r0,r1,LSL #2]     ;310
000094  2800              CMP      r0,#0                 ;310
000096  7cf0              LDRB     r0,[r6,#0x13]         ;318
000098  d005              BEQ      |L4.166|
00009a  4548              CMP      r0,r9                 ;311
00009c  d3e8              BCC      |L4.112|
00009e  b261              SXTB     r1,r4                 ;312
0000a0  4681              MOV      r9,r0                 ;313
0000a2  9100              STR      r1,[sp,#0]            ;313
0000a4  e7e4              B        |L4.112|
                  |L4.166|
0000a6  4558              CMP      r0,r11                ;318
0000a8  d3e2              BCC      |L4.112|
0000aa  b261              SXTB     r1,r4                 ;319
0000ac  4683              MOV      r11,r0                ;320
0000ae  9102              STR      r1,[sp,#8]            ;320
0000b0  e7de              B        |L4.112|
                  |L4.178|
0000b2  9906              LDR      r1,[sp,#0x18]         ;344
0000b4  07c9              LSLS     r1,r1,#31             ;344
0000b6  d0ca              BEQ      |L4.78|
                  |L4.184|
0000b8  9901              LDR      r1,[sp,#4]            ;364
0000ba  290a              CMP      r1,#0xa               ;364
0000bc  da0a              BGE      |L4.212|
0000be  b2cc              UXTB     r4,r1                 ;366
0000c0  4818              LDR      r0,|L4.292|
0000c2  eb040184          ADD      r1,r4,r4,LSL #2       ;369
0000c6  f8500021          LDR      r0,[r0,r1,LSL #2]     ;369
0000ca  b150              CBZ      r0,|L4.226|
0000cc  a026              ADR      r0,|L4.360|
0000ce  f7fffffe          BL       __2printf
0000d2  e006              B        |L4.226|
                  |L4.212|
0000d4  9902              LDR      r1,[sp,#8]            ;371
0000d6  290a              CMP      r1,#0xa               ;371
0000d8  db02              BLT      |L4.224|
0000da  9900              LDR      r1,[sp,#0]            ;376
0000dc  290a              CMP      r1,#0xa               ;376
0000de  dab6              BGE      |L4.78|
                  |L4.224|
0000e0  b2cc              UXTB     r4,r1                 ;378
                  |L4.226|
0000e2  2c0a              CMP      r4,#0xa               ;387
0000e4  d302              BCC      |L4.236|
0000e6  a026              ADR      r0,|L4.384|
0000e8  f7fffffe          BL       __2printf
                  |L4.236|
0000ec  4620              MOV      r0,r4                 ;388
0000ee  f7fffffe          BL       etharp_free_entry
                  |L4.242|
0000f2  2c0a              CMP      r4,#0xa               ;391
0000f4  d302              BCC      |L4.252|
0000f6  a022              ADR      r0,|L4.384|
0000f8  f7fffffe          BL       __2printf
                  |L4.252|
0000fc  4809              LDR      r0,|L4.292|
0000fe  eb040184          ADD      r1,r4,r4,LSL #2       ;392
000102  eb000581          ADD      r5,r0,r1,LSL #2       ;392
000106  7ca8              LDRB     r0,[r5,#0x12]         ;392
000108  b110              CBZ      r0,|L4.272|
00010a  a022              ADR      r0,|L4.404|
00010c  f7fffffe          BL       __2printf
                  |L4.272|
000110  f1b80f00          CMP      r8,#0                 ;396
000114  d002              BEQ      |L4.284|
000116  f8d80000          LDR      r0,[r8,#0]            ;398
00011a  6068              STR      r0,[r5,#4]            ;398
                  |L4.284|
00011c  2000              MOVS     r0,#0                 ;400
00011e  74e8              STRB     r0,[r5,#0x13]         ;400
000120  e794              B        |L4.76|
;;;403    
                          ENDP

000122  0000              DCW      0x0000
                  |L4.292|
                          DCD      ||.bss||
                  |L4.296|
000128  73746174          DCB      "state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_"
00012c  65203d3d
000130  20455448
000134  4152505f
000138  53544154
00013c  455f5045
000140  4e44494e
000144  47207c7c
000148  20737461
00014c  7465203e
000150  3d204554
000154  48415250
000158  5f535441
00015c  54455f  
00015f  53544142          DCB      "STABLE",0
000163  4c4500  
000166  00                DCB      0
000167  00                DCB      0
                  |L4.360|
000168  6172705f          DCB      "arp_table[i].q == NULL",0
00016c  7461626c
000170  655b695d
000174  2e71203d
000178  3d204e55
00017c  4c4c00  
00017f  00                DCB      0
                  |L4.384|
000180  69203c20          DCB      "i < ARP_TABLE_SIZE",0
000184  4152505f
000188  5441424c
00018c  455f5349
000190  5a4500  
000193  00                DCB      0
                  |L4.404|
000194  6172705f          DCB      "arp_table[i].state == ETHARP_STATE_EMPTY",0
000198  7461626c
00019c  655b695d
0001a0  2e737461
0001a4  7465203d
0001a8  3d204554
0001ac  48415250
0001b0  5f535441
0001b4  54455f45
0001b8  4d505459
0001bc  00      
0001bd  00                DCB      0
0001be  00                DCB      0
0001bf  00                DCB      0

                          AREA ||i.etharp_free_entry||, CODE, READONLY, ALIGN=2

                  etharp_free_entry PROC
;;;176    static void
;;;177    etharp_free_entry(int i)
000000  b570              PUSH     {r4-r6,lr}
;;;178    {
;;;179      /* remove from SNMP ARP index tree */
;;;180      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
;;;181      /* and empty packet queue */
;;;182      if (arp_table[i].q != NULL) {
000002  4d07              LDR      r5,|L5.32|
000004  eb000480          ADD      r4,r0,r0,LSL #2
000008  2600              MOVS     r6,#0
00000a  f8550024          LDR      r0,[r5,r4,LSL #2]
00000e  b118              CBZ      r0,|L5.24|
;;;183        /* remove all queued packets */
;;;184        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
;;;185        free_etharp_q(arp_table[i].q);
000010  f7fffffe          BL       pbuf_free
;;;186        arp_table[i].q = NULL;
000014  f8456024          STR      r6,[r5,r4,LSL #2]
                  |L5.24|
;;;187      }
;;;188      /* recycle entry for re-use */
;;;189      arp_table[i].state = ETHARP_STATE_EMPTY;
000018  eb050084          ADD      r0,r5,r4,LSL #2
00001c  7486              STRB     r6,[r0,#0x12]
;;;190    #ifdef LWIP_DEBUG
;;;191      /* for debugging, clean out the complete entry */
;;;192      arp_table[i].ctime = 0;
;;;193      arp_table[i].netif = NULL;
;;;194      ip_addr_set_zero(&arp_table[i].ipaddr);
;;;195      arp_table[i].ethaddr = ethzero;
;;;196    #endif /* LWIP_DEBUG */
;;;197    }
00001e  bd70              POP      {r4-r6,pc}
;;;198    
                          ENDP

                  |L5.32|
                          DCD      ||.bss||

                          AREA ||i.etharp_output||, CODE, READONLY, ALIGN=2

                  etharp_output PROC
;;;878    err_t
;;;879    etharp_output(struct netif *netif, struct pbuf *q, ip_addr_t *ipaddr)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;880    {
000004  4615              MOV      r5,r2
000006  460e              MOV      r6,r1
000008  0004              MOVS     r4,r0
00000a  d102              BNE      |L6.18|
;;;881      struct eth_addr *dest;
;;;882      struct eth_addr mcastaddr;
;;;883      ip_addr_t *dst_addr = ipaddr;
;;;884    
;;;885      LWIP_ASSERT("netif != NULL", netif != NULL);
00000c  a03f              ADR      r0,|L6.268|
00000e  f7fffffe          BL       __2printf
                  |L6.18|
;;;886      LWIP_ASSERT("q != NULL", q != NULL);
000012  b916              CBNZ     r6,|L6.26|
000014  a041              ADR      r0,|L6.284|
000016  f7fffffe          BL       __2printf
                  |L6.26|
;;;887      LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
00001a  b915              CBNZ     r5,|L6.34|
00001c  a042              ADR      r0,|L6.296|
00001e  f7fffffe          BL       __2printf
                  |L6.34|
;;;888    
;;;889      /* make room for Ethernet header - should not fail */
;;;890      if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
000022  210e              MOVS     r1,#0xe
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       pbuf_header
00002a  b118              CBZ      r0,|L6.52|
;;;891        /* bail out */
;;;892        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
;;;893          ("etharp_output: could not allocate room for header.\n"));
;;;894        LINK_STATS_INC(link.lenerr);
;;;895        return ERR_BUF;
00002c  f06f0001          MVN      r0,#1
                  |L6.48|
;;;896      }
;;;897    
;;;898      /* Determine on destination hardware address. Broadcasts and multicasts
;;;899       * are special, other IP addresses are looked up in the ARP table. */
;;;900    
;;;901      /* broadcast destination IP address? */
;;;902      if (ip_addr_isbroadcast(ipaddr, netif)) {
;;;903        /* broadcast on Ethernet also */
;;;904        dest = (struct eth_addr *)&ethbroadcast;
;;;905      /* multicast destination IP address? */
;;;906      } else if (ip_addr_ismulticast(ipaddr)) {
;;;907        /* Hash IP multicast address to MAC address.*/
;;;908        mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
;;;909        mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
;;;910        mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
;;;911        mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
;;;912        mcastaddr.addr[4] = ip4_addr3(ipaddr);
;;;913        mcastaddr.addr[5] = ip4_addr4(ipaddr);
;;;914        /* destination Ethernet address is multicast */
;;;915        dest = &mcastaddr;
;;;916      /* unicast destination IP address? */
;;;917      } else {
;;;918        s8_t i;
;;;919        /* outside local network? if so, this can neither be a global broadcast nor
;;;920           a subnet broadcast. */
;;;921        if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
;;;922            !ip_addr_islinklocal(ipaddr)) {
;;;923    #if LWIP_AUTOIP
;;;924          struct ip_hdr *iphdr = (struct ip_hdr*)((u8_t*)q->payload +
;;;925            sizeof(struct eth_hdr));
;;;926          /* According to RFC 3297, chapter 2.6.2 (Forwarding Rules), a packet with
;;;927             a link-local source address must always be "directly to its destination
;;;928             on the same physical link. The host MUST NOT send the packet to any
;;;929             router for forwarding". */
;;;930          if (!ip_addr_islinklocal(&iphdr->src))
;;;931    #endif /* LWIP_AUTOIP */
;;;932          {
;;;933            /* interface has default gateway? */
;;;934            if (!ip_addr_isany(&netif->gw)) {
;;;935              /* send to hardware address of default gateway IP address */
;;;936              dst_addr = &(netif->gw);
;;;937            /* no default gateway available */
;;;938            } else {
;;;939              /* no route to destination error (default gateway missing) */
;;;940              return ERR_RTE;
;;;941            }
;;;942          }
;;;943        }
;;;944    #if LWIP_NETIF_HWADDRHINT
;;;945        if (netif->addr_hint != NULL) {
;;;946          /* per-pcb cached entry was given */
;;;947          u8_t etharp_cached_entry = *(netif->addr_hint);
;;;948          if (etharp_cached_entry < ARP_TABLE_SIZE) {
;;;949    #endif /* LWIP_NETIF_HWADDRHINT */
;;;950            if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
;;;951                (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
;;;952              /* the per-pcb-cached entry is stable and the right one! */
;;;953              ETHARP_STATS_INC(etharp.cachehit);
;;;954              return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
;;;955            }
;;;956    #if LWIP_NETIF_HWADDRHINT
;;;957          }
;;;958        }
;;;959    #endif /* LWIP_NETIF_HWADDRHINT */
;;;960    
;;;961        /* find stable entry: do this here since this is a critical path for
;;;962           throughput and etharp_find_entry() is kind of slow */
;;;963        for (i = 0; i < ARP_TABLE_SIZE; i++) {
;;;964          if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
;;;965              (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
;;;966            /* found an existing, stable entry */
;;;967            ETHARP_SET_HINT(netif, i);
;;;968            return etharp_output_to_arp_index(netif, q, i);
;;;969          }
;;;970        }
;;;971        /* no stable entry found, use the (slower) query function:
;;;972           queue on destination Ethernet address belonging to ipaddr */
;;;973        return etharp_query(netif, dst_addr, q);
;;;974      }
;;;975    
;;;976      /* continuation for multicast/broadcast destinations */
;;;977      /* obtain source Ethernet address of the given interface */
;;;978      /* send packet directly on the link */
;;;979      return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
;;;980    }
000030  e8bd81fc          POP      {r2-r8,pc}
                  |L6.52|
000034  4621              MOV      r1,r4                 ;902
000036  6828              LDR      r0,[r5,#0]            ;902
000038  f7fffffe          BL       ip4_addr_isbroadcast
00003c  b108              CBZ      r0,|L6.66|
00003e  4b3e              LDR      r3,|L6.312|
000040  e03c              B        |L6.188|
                  |L6.66|
000042  6828              LDR      r0,[r5,#0]            ;906
000044  f3c01103          UBFX     r1,r0,#4,#4           ;906
000048  290e              CMP      r1,#0xe               ;906
00004a  d022              BEQ      |L6.146|
00004c  68a1              LDR      r1,[r4,#8]            ;921
00004e  6863              LDR      r3,[r4,#4]            ;921
000050  ea000201          AND      r2,r0,r1              ;921
000054  400b              ANDS     r3,r3,r1              ;921
000056  429a              CMP      r2,r3                 ;921
000058  d00b              BEQ      |L6.114|
00005a  b280              UXTH     r0,r0                 ;922
00005c  f5a0417e          SUB      r1,r0,#0xfe00         ;922
000060  39a9              SUBS     r1,r1,#0xa9           ;922
000062  d006              BEQ      |L6.114|
000064  f1140f0c          CMN      r4,#0xc               ;934
000068  d02f              BEQ      |L6.202|
00006a  68e0              LDR      r0,[r4,#0xc]          ;934
00006c  b368              CBZ      r0,|L6.202|
00006e  f104050c          ADD      r5,r4,#0xc            ;936
                  |L6.114|
000072  4b32              LDR      r3,|L6.316|
000074  4a32              LDR      r2,|L6.320|
000076  7818              LDRB     r0,[r3,#0]            ;950  ; etharp_cached_entry
000078  eb000180          ADD      r1,r0,r0,LSL #2       ;950
00007c  eb020181          ADD      r1,r2,r1,LSL #2       ;950
000080  7c8f              LDRB     r7,[r1,#0x12]         ;950
000082  2f02              CMP      r7,#2                 ;950
000084  d324              BCC      |L6.208|
000086  682f              LDR      r7,[r5,#0]            ;951
000088  6849              LDR      r1,[r1,#4]            ;951
00008a  428f              CMP      r7,r1                 ;951
00008c  d120              BNE      |L6.208|
00008e  4602              MOV      r2,r0                 ;951
000090  e02c              B        |L6.236|
                  |L6.146|
000092  2001              MOVS     r0,#1                 ;908
000094  f88d0000          STRB     r0,[sp,#0]            ;908
000098  2000              MOVS     r0,#0                 ;909
00009a  f88d0001          STRB     r0,[sp,#1]            ;909
00009e  205e              MOVS     r0,#0x5e              ;910
0000a0  f88d0002          STRB     r0,[sp,#2]            ;910
0000a4  7868              LDRB     r0,[r5,#1]            ;911
0000a6  466b              MOV      r3,sp                 ;915
0000a8  f000007f          AND      r0,r0,#0x7f           ;911
0000ac  f88d0003          STRB     r0,[sp,#3]            ;911
0000b0  78a8              LDRB     r0,[r5,#2]            ;912
0000b2  f88d0004          STRB     r0,[sp,#4]            ;912
0000b6  78e8              LDRB     r0,[r5,#3]            ;913
0000b8  f88d0005          STRB     r0,[sp,#5]            ;913
                  |L6.188|
0000bc  f104022b          ADD      r2,r4,#0x2b           ;979
0000c0  4631              MOV      r1,r6                 ;979
0000c2  4620              MOV      r0,r4                 ;979
0000c4  f7fffffe          BL       etharp_send_ip
0000c8  e7b2              B        |L6.48|
                  |L6.202|
0000ca  f06f0003          MVN      r0,#3                 ;940
0000ce  e7af              B        |L6.48|
                  |L6.208|
0000d0  2000              MOVS     r0,#0                 ;963
                  |L6.210|
0000d2  eb000180          ADD      r1,r0,r0,LSL #2       ;964
0000d6  eb020181          ADD      r1,r2,r1,LSL #2       ;964
0000da  7c8f              LDRB     r7,[r1,#0x12]         ;964
0000dc  2f02              CMP      r7,#2                 ;964
0000de  d30a              BCC      |L6.246|
0000e0  682f              LDR      r7,[r5,#0]            ;965
0000e2  6849              LDR      r1,[r1,#4]            ;965
0000e4  428f              CMP      r7,r1                 ;965
0000e6  d106              BNE      |L6.246|
0000e8  b2c2              UXTB     r2,r0                 ;967
0000ea  701a              STRB     r2,[r3,#0]            ;967
                  |L6.236|
0000ec  4631              MOV      r1,r6                 ;968
0000ee  4620              MOV      r0,r4                 ;968
0000f0  f7fffffe          BL       etharp_output_to_arp_index
0000f4  e79c              B        |L6.48|
                  |L6.246|
0000f6  1c40              ADDS     r0,r0,#1
0000f8  b240              SXTB     r0,r0                 ;963
0000fa  280a              CMP      r0,#0xa               ;963
0000fc  dbe9              BLT      |L6.210|
0000fe  4632              MOV      r2,r6                 ;973
000100  4629              MOV      r1,r5                 ;973
000102  4620              MOV      r0,r4                 ;973
000104  f7fffffe          BL       etharp_query
000108  e792              B        |L6.48|
;;;981    
                          ENDP

00010a  0000              DCW      0x0000
                  |L6.268|
00010c  6e657469          DCB      "netif != NULL",0
000110  6620213d
000114  204e554c
000118  4c00    
00011a  00                DCB      0
00011b  00                DCB      0
                  |L6.284|
00011c  7120213d          DCB      "q != NULL",0
000120  204e554c
000124  4c00    
000126  00                DCB      0
000127  00                DCB      0
                  |L6.296|
000128  69706164          DCB      "ipaddr != NULL",0
00012c  64722021
000130  3d204e55
000134  4c4c00  
000137  00                DCB      0
                  |L6.312|
                          DCD      ||.constdata||
                  |L6.316|
                          DCD      ||.data||
                  |L6.320|
                          DCD      ||.bss||

                          AREA ||i.etharp_output_to_arp_index||, CODE, READONLY, ALIGN=2

                  etharp_output_to_arp_index PROC
;;;841    static err_t
;;;842    etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
000000  b570              PUSH     {r4-r6,lr}
;;;843    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;844      LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
000006  4811              LDR      r0,|L7.76|
000008  eb020182          ADD      r1,r2,r2,LSL #2
00000c  eb000481          ADD      r4,r0,r1,LSL #2
000010  7ca0              LDRB     r0,[r4,#0x12]
000012  2802              CMP      r0,#2
000014  d202              BCS      |L7.28|
000016  a00e              ADR      r0,|L7.80|
000018  f7fffffe          BL       __2printf
                  |L7.28|
;;;845                  arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
;;;846      /* if arp table entry is about to expire: re-request it,
;;;847         but only if its state is ETHARP_STATE_STABLE to prevent flooding the
;;;848         network with ARP requests if this address is used frequently. */
;;;849      if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
00001c  7ca0              LDRB     r0,[r4,#0x12]
00001e  2802              CMP      r0,#2
000020  d109              BNE      |L7.54|
;;;850          (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
000022  7ce0              LDRB     r0,[r4,#0x13]
000024  28e4              CMP      r0,#0xe4
000026  d306              BCC      |L7.54|
;;;851        if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
000028  1d21              ADDS     r1,r4,#4
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       etharp_request
000030  b908              CBNZ     r0,|L7.54|
;;;852          arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
000032  2003              MOVS     r0,#3
000034  74a0              STRB     r0,[r4,#0x12]
                  |L7.54|
;;;853        }
;;;854      }
;;;855      
;;;856      return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
000036  f104030c          ADD      r3,r4,#0xc
00003a  f105022b          ADD      r2,r5,#0x2b
00003e  4631              MOV      r1,r6
000040  4628              MOV      r0,r5
000042  e8bd4070          POP      {r4-r6,lr}
000046  f7ffbffe          B.W      etharp_send_ip
;;;857        &arp_table[arp_idx].ethaddr);
;;;858    }
;;;859    
                          ENDP

00004a  0000              DCW      0x0000
                  |L7.76|
                          DCD      ||.bss||
                  |L7.80|
000050  6172705f          DCB      "arp_table[arp_idx].state >= ETHARP_STATE_STABLE",0
000054  7461626c
000058  655b6172
00005c  705f6964
000060  785d2e73
000064  74617465
000068  203e3d20
00006c  45544841
000070  52505f53
000074  54415445
000078  5f535441
00007c  424c4500

                          AREA ||i.etharp_query||, CODE, READONLY, ALIGN=2

                  etharp_query PROC
;;;1015   err_t
;;;1016   etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;1017   {
000004  b082              SUB      sp,sp,#8
000006  4688              MOV      r8,r1
;;;1018     struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
000008  9802              LDR      r0,[sp,#8]
;;;1019     err_t result = ERR_MEM;
00000a  f04f3bff          MOV      r11,#0xffffffff
00000e  302b              ADDS     r0,r0,#0x2b           ;1018
;;;1020     s8_t i; /* ARP entry index */
;;;1021   
;;;1022     /* non-unicast address? */
;;;1023     if (ip_addr_isbroadcast(ipaddr, netif) ||
000010  9000              STR      r0,[sp,#0]
000012  6808              LDR      r0,[r1,#0]
000014  4616              MOV      r6,r2                 ;1017
000016  465f              MOV      r7,r11                ;1019
000018  9902              LDR      r1,[sp,#8]
00001a  f7fffffe          BL       ip4_addr_isbroadcast
00001e  bb18              CBNZ     r0,|L8.104|
;;;1024         ip_addr_ismulticast(ipaddr) ||
000020  f8d80000          LDR      r0,[r8,#0]
000024  f3c01103          UBFX     r1,r0,#4,#4
000028  290e              CMP      r1,#0xe
00002a  d01d              BEQ      |L8.104|
;;;1025         ip_addr_isany(ipaddr)) {
00002c  f1b80f00          CMP      r8,#0
000030  d01a              BEQ      |L8.104|
000032  b1c8              CBZ      r0,|L8.104|
;;;1026       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
;;;1027       return ERR_ARG;
;;;1028     }
;;;1029   
;;;1030     /* find entry in ARP cache, ask to create entry if queueing packet */
;;;1031     i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
000034  2101              MOVS     r1,#1
000036  4640              MOV      r0,r8
000038  f7fffffe          BL       etharp_find_entry
00003c  0004              MOVS     r4,r0
;;;1032   
;;;1033     /* could not find or create entry? */
;;;1034     if (i < 0) {
00003e  d415              BMI      |L8.108|
;;;1035       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
;;;1036       if (q) {
;;;1037         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
;;;1038         ETHARP_STATS_INC(etharp.memerr);
;;;1039       }
;;;1040       return (err_t)i;
;;;1041     }
;;;1042   
;;;1043     /* mark a fresh entry as pending (we just sent a request) */
;;;1044     if (arp_table[i].state == ETHARP_STATE_EMPTY) {
000040  f8dfa0c8          LDR      r10,|L8.268|
000044  eb040984          ADD      r9,r4,r4,LSL #2
000048  eb0a0589          ADD      r5,r10,r9,LSL #2
00004c  7ca8              LDRB     r0,[r5,#0x12]
00004e  b180              CBZ      r0,|L8.114|
;;;1045       arp_table[i].state = ETHARP_STATE_PENDING;
;;;1046     }
;;;1047   
;;;1048     /* { i is either a STABLE or (new or existing) PENDING entry } */
;;;1049     LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
000050  2801              CMP      r0,#1
000052  d010              BEQ      |L8.118|
000054  2802              CMP      r0,#2
000056  d205              BCS      |L8.100|
000058  a02d              ADR      r0,|L8.272|
00005a  f7fffffe          BL       __2printf
;;;1050     ((arp_table[i].state == ETHARP_STATE_PENDING) ||
;;;1051      (arp_table[i].state >= ETHARP_STATE_STABLE)));
;;;1052   
;;;1053     /* do we have a pending entry? or an implicit query request? */
;;;1054     if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
00005e  7ca8              LDRB     r0,[r5,#0x12]
000060  2801              CMP      r0,#1
000062  d008              BEQ      |L8.118|
                  |L8.100|
000064  b13e              CBZ      r6,|L8.118|
000066  e00d              B        |L8.132|
                  |L8.104|
000068  f06f000d          MVN      r0,#0xd               ;1027
                  |L8.108|
;;;1055       /* try to resolve it; send out ARP request */
;;;1056       result = etharp_request(netif, ipaddr);
;;;1057       if (result != ERR_OK) {
;;;1058         /* ARP request couldn't be sent */
;;;1059         /* We don't re-send arp request in etharp_tmr, but we still queue packets,
;;;1060            since this failure could be temporary, and the next packet calling
;;;1061            etharp_query again could lead to sending the queued packets. */
;;;1062       }
;;;1063       if (q == NULL) {
;;;1064         return result;
;;;1065       }
;;;1066     }
;;;1067   
;;;1068     /* packet given? */
;;;1069     LWIP_ASSERT("q != NULL", q != NULL);
;;;1070     /* stable entry? */
;;;1071     if (arp_table[i].state >= ETHARP_STATE_STABLE) {
;;;1072       /* we have a valid IP->Ethernet address mapping */
;;;1073       ETHARP_SET_HINT(netif, i);
;;;1074       /* send the packet */
;;;1075       result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
;;;1076     /* pending entry? (either just created or already pending */
;;;1077     } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
;;;1078       /* entry is still pending, queue the given packet 'q' */
;;;1079       struct pbuf *p;
;;;1080       int copy_needed = 0;
;;;1081       /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
;;;1082        * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
;;;1083        * PBUF_ROMs can be left as they are, since ROM must not get changed. */
;;;1084       p = q;
;;;1085       while (p) {
;;;1086         LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
;;;1087         if(p->type != PBUF_ROM) {
;;;1088           copy_needed = 1;
;;;1089           break;
;;;1090         }
;;;1091         p = p->next;
;;;1092       }
;;;1093       if(copy_needed) {
;;;1094         /* copy the whole packet into new pbufs */
;;;1095         p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
;;;1096         if(p != NULL) {
;;;1097           if (pbuf_copy(p, q) != ERR_OK) {
;;;1098             pbuf_free(p);
;;;1099             p = NULL;
;;;1100           }
;;;1101         }
;;;1102       } else {
;;;1103         /* referencing the old pbuf is enough */
;;;1104         p = q;
;;;1105         pbuf_ref(p);
;;;1106       }
;;;1107       /* packet could be taken over? */
;;;1108       if (p != NULL) {
;;;1109         /* queue packet ... */
;;;1110   #if ARP_QUEUEING
;;;1111         struct etharp_q_entry *new_entry;
;;;1112         /* allocate a new arp queue entry */
;;;1113         new_entry = (struct etharp_q_entry *)memp_malloc(MEMP_ARP_QUEUE);
;;;1114         if (new_entry != NULL) {
;;;1115           new_entry->next = 0;
;;;1116           new_entry->p = p;
;;;1117           if(arp_table[i].q != NULL) {
;;;1118             /* queue was already existent, append the new entry to the end */
;;;1119             struct etharp_q_entry *r;
;;;1120             r = arp_table[i].q;
;;;1121             while (r->next != NULL) {
;;;1122               r = r->next;
;;;1123             }
;;;1124             r->next = new_entry;
;;;1125           } else {
;;;1126             /* queue did not exist, first item in queue */
;;;1127             arp_table[i].q = new_entry;
;;;1128           }
;;;1129           LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
;;;1130           result = ERR_OK;
;;;1131         } else {
;;;1132           /* the pool MEMP_ARP_QUEUE is empty */
;;;1133           pbuf_free(p);
;;;1134           LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
;;;1135           result = ERR_MEM;
;;;1136         }
;;;1137   #else /* ARP_QUEUEING */
;;;1138         /* always queue one packet per ARP request only, freeing a previously queued packet */
;;;1139         if (arp_table[i].q != NULL) {
;;;1140           LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: dropped previously queued packet %p for ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
;;;1141           pbuf_free(arp_table[i].q);
;;;1142         }
;;;1143         arp_table[i].q = p;
;;;1144         result = ERR_OK;
;;;1145         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
;;;1146   #endif /* ARP_QUEUEING */
;;;1147       } else {
;;;1148         ETHARP_STATS_INC(etharp.memerr);
;;;1149         LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
;;;1150         result = ERR_MEM;
;;;1151       }
;;;1152     }
;;;1153     return result;
;;;1154   }
00006c  b005              ADD      sp,sp,#0x14
00006e  e8bd8ff0          POP      {r4-r11,pc}
                  |L8.114|
000072  2001              MOVS     r0,#1                 ;1045
000074  74a8              STRB     r0,[r5,#0x12]         ;1045
                  |L8.118|
000076  4641              MOV      r1,r8                 ;1056
000078  9802              LDR      r0,[sp,#8]            ;1056
00007a  f7fffffe          BL       etharp_request
00007e  4607              MOV      r7,r0                 ;1056
000080  2e00              CMP      r6,#0                 ;1063
000082  d0f3              BEQ      |L8.108|
                  |L8.132|
000084  7ca8              LDRB     r0,[r5,#0x12]         ;1071
000086  2802              CMP      r0,#2                 ;1071
000088  d30a              BCC      |L8.160|
00008a  482b              LDR      r0,|L8.312|
00008c  f105030c          ADD      r3,r5,#0xc            ;1075
000090  4631              MOV      r1,r6                 ;1075
000092  7004              STRB     r4,[r0,#0]            ;1073
000094  9a00              LDR      r2,[sp,#0]            ;1075
000096  9802              LDR      r0,[sp,#8]            ;1075
000098  f7fffffe          BL       etharp_send_ip
00009c  4607              MOV      r7,r0                 ;1075
00009e  e033              B        |L8.264|
                  |L8.160|
0000a0  46d0              MOV      r8,r10                ;1077
0000a2  2801              CMP      r0,#1                 ;1077
0000a4  d130              BNE      |L8.264|
0000a6  2500              MOVS     r5,#0                 ;1080
0000a8  4634              MOV      r4,r6                 ;1084
                  |L8.170|
0000aa  8960              LDRH     r0,[r4,#0xa]          ;1086
0000ac  8921              LDRH     r1,[r4,#8]            ;1086
0000ae  4288              CMP      r0,r1                 ;1086
0000b0  d104              BNE      |L8.188|
0000b2  6820              LDR      r0,[r4,#0]            ;1086
0000b4  b110              CBZ      r0,|L8.188|
0000b6  a021              ADR      r0,|L8.316|
0000b8  f7fffffe          BL       __2printf
                  |L8.188|
0000bc  7b20              LDRB     r0,[r4,#0xc]          ;1087
0000be  2801              CMP      r0,#1                 ;1087
0000c0  d103              BNE      |L8.202|
0000c2  6824              LDR      r4,[r4,#0]            ;1091
0000c4  2c00              CMP      r4,#0                 ;1091
0000c6  d1f0              BNE      |L8.170|
0000c8  b175              CBZ      r5,|L8.232|
                  |L8.202|
0000ca  8921              LDRH     r1,[r4,#8]            ;1095
0000cc  2200              MOVS     r2,#0                 ;1095
0000ce  2003              MOVS     r0,#3                 ;1095
0000d0  f7fffffe          BL       pbuf_alloc
0000d4  0005              MOVS     r5,r0                 ;1095
0000d6  d016              BEQ      |L8.262|
0000d8  4631              MOV      r1,r6                 ;1097
0000da  f7fffffe          BL       pbuf_copy
0000de  b140              CBZ      r0,|L8.242|
0000e0  4628              MOV      r0,r5                 ;1098
0000e2  f7fffffe          BL       pbuf_free
0000e6  e00e              B        |L8.262|
                  |L8.232|
0000e8  4635              MOV      r5,r6                 ;1104
0000ea  4630              MOV      r0,r6                 ;1105
0000ec  f7fffffe          BL       pbuf_ref
0000f0  b14d              CBZ      r5,|L8.262|
                  |L8.242|
0000f2  f8580029          LDR      r0,[r8,r9,LSL #2]     ;1139
0000f6  4644              MOV      r4,r8                 ;1139
0000f8  b108              CBZ      r0,|L8.254|
0000fa  f7fffffe          BL       pbuf_free
                  |L8.254|
0000fe  f8445029          STR      r5,[r4,r9,LSL #2]     ;1143
000102  2700              MOVS     r7,#0                 ;1144
000104  e000              B        |L8.264|
                  |L8.262|
000106  465f              MOV      r7,r11                ;1150
                  |L8.264|
000108  4638              MOV      r0,r7                 ;1153
00010a  e7af              B        |L8.108|
;;;1155   
                          ENDP

                  |L8.268|
                          DCD      ||.bss||
                  |L8.272|
000110  6172705f          DCB      "arp_table[i].state == PENDING or STABLE",0
000114  7461626c
000118  655b695d
00011c  2e737461
000120  7465203d
000124  3d205045
000128  4e44494e
00012c  47206f72
000130  20535441
000134  424c4500
                  |L8.312|
                          DCD      ||.data||
                  |L8.316|
00013c  6e6f2070          DCB      "no packet queues allowed!",0
000140  61636b65
000144  74207175
000148  65756573
00014c  20616c6c
000150  6f776564
000154  2100    
000156  00                DCB      0
000157  00                DCB      0

                          AREA ||i.etharp_raw||, CODE, READONLY, ALIGN=2

                  etharp_raw PROC
;;;1174   err_t
;;;1175   etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1176              const struct eth_addr *ethdst_addr,
;;;1177              const struct eth_addr *hwsrc_addr, const ip_addr_t *ipsrc_addr,
;;;1178              const struct eth_addr *hwdst_addr, const ip_addr_t *ipdst_addr,
;;;1179              const u16_t opcode)
;;;1180   {
000004  4698              MOV      r8,r3
000006  f8ddb02c          LDR      r11,[sp,#0x2c]
00000a  4691              MOV      r9,r2
00000c  468a              MOV      r10,r1
00000e  0007              MOVS     r7,r0
000010  d102              BNE      |L9.24|
;;;1181     struct pbuf *p;
;;;1182     err_t result = ERR_OK;
;;;1183     struct eth_hdr *ethhdr;
;;;1184     struct etharp_hdr *hdr;
;;;1185   #if LWIP_AUTOIP
;;;1186     const u8_t * ethdst_hwaddr;
;;;1187   #endif /* LWIP_AUTOIP */
;;;1188   
;;;1189     LWIP_ASSERT("netif != NULL", netif != NULL);
000012  a02c              ADR      r0,|L9.196|
000014  f7fffffe          BL       __2printf
                  |L9.24|
;;;1190   
;;;1191     /* allocate a pbuf for the outgoing ARP request packet */
;;;1192     p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
000018  2200              MOVS     r2,#0
00001a  212a              MOVS     r1,#0x2a
00001c  2003              MOVS     r0,#3
00001e  f7fffffe          BL       pbuf_alloc
000022  0006              MOVS     r6,r0
;;;1193     /* could allocate a pbuf for an ARP request? */
;;;1194     if (p == NULL) {
000024  d04b              BEQ      |L9.190|
;;;1195       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
;;;1196         ("etharp_raw: could not allocate pbuf for ARP request.\n"));
;;;1197       ETHARP_STATS_INC(etharp.memerr);
;;;1198       return ERR_MEM;
;;;1199     }
;;;1200     LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
000026  8970              LDRH     r0,[r6,#0xa]
000028  282a              CMP      r0,#0x2a
00002a  d202              BCS      |L9.50|
00002c  a029              ADR      r0,|L9.212|
00002e  f7fffffe          BL       __2printf
                  |L9.50|
;;;1201                 (p->len >= SIZEOF_ETHARP_PACKET));
;;;1202   
;;;1203     ethhdr = (struct eth_hdr *)p->payload;
;;;1204     hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
;;;1205     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
;;;1206     hdr->opcode = htons(opcode);
000032  6875              LDR      r5,[r6,#4]
000034  980d              LDR      r0,[sp,#0x34]
000036  f105040e          ADD      r4,r5,#0xe
00003a  f7fffffe          BL       lwip_htons
00003e  80e0              STRH     r0,[r4,#6]
;;;1207   
;;;1208     LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
000040  f897002a          LDRB     r0,[r7,#0x2a]
000044  2806              CMP      r0,#6
000046  d002              BEQ      |L9.78|
000048  482f              LDR      r0,|L9.264|
00004a  f7fffffe          BL       __2printf
                  |L9.78|
;;;1209                 (netif->hwaddr_len == ETHARP_HWADDR_LEN));
;;;1210   #if LWIP_AUTOIP
;;;1211     /* If we are using Link-Local, all ARP packets that contain a Link-Local
;;;1212      * 'sender IP address' MUST be sent using link-layer broadcast instead of
;;;1213      * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
;;;1214     ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
;;;1215   #endif /* LWIP_AUTOIP */
;;;1216     /* Write the ARP MAC-Addresses */
;;;1217     ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
00004e  f8d81000          LDR      r1,[r8,#0]
000052  60a1              STR      r1,[r4,#8]
000054  f8b80004          LDRH     r0,[r8,#4]
000058  81a0              STRH     r0,[r4,#0xc]
;;;1218     ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
00005a  f8db1000          LDR      r1,[r11,#0]
00005e  f8c41012          STR      r1,[r4,#0x12]
000062  f8bb0004          LDRH     r0,[r11,#4]
000066  82e0              STRH     r0,[r4,#0x16]
;;;1219     /* Write the Ethernet MAC-Addresses */
;;;1220   #if LWIP_AUTOIP
;;;1221     ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
;;;1222   #else  /* LWIP_AUTOIP */
;;;1223     ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
000068  f8d91000          LDR      r1,[r9,#0]
00006c  6029              STR      r1,[r5,#0]
00006e  f8b90004          LDRH     r0,[r9,#4]
000072  80a8              STRH     r0,[r5,#4]
;;;1224   #endif /* LWIP_AUTOIP */
;;;1225     ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
000074  f8da1000          LDR      r1,[r10,#0]
000078  f8c51006          STR      r1,[r5,#6]
00007c  f8ba0004          LDRH     r0,[r10,#4]
000080  8168              STRH     r0,[r5,#0xa]
;;;1226     /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
;;;1227      * structure packing. */ 
;;;1228     IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
000082  980a              LDR      r0,[sp,#0x28]
;;;1229     IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
;;;1230   
;;;1231     hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
;;;1232     hdr->proto = PP_HTONS(ETHTYPE_IP);
;;;1233     /* set hwlen and protolen */
;;;1234     hdr->hwlen = ETHARP_HWADDR_LEN;
;;;1235     hdr->protolen = sizeof(ip_addr_t);
;;;1236   
;;;1237     ethhdr->type = PP_HTONS(ETHTYPE_ARP);
;;;1238     /* send ARP query */
;;;1239     result = netif->linkoutput(netif, p);
000084  4631              MOV      r1,r6
000086  6800              LDR      r0,[r0,#0]            ;1228
000088  f8c4000e          STR      r0,[r4,#0xe]          ;1228
00008c  980c              LDR      r0,[sp,#0x30]         ;1229
00008e  6800              LDR      r0,[r0,#0]            ;1229
000090  61a0              STR      r0,[r4,#0x18]         ;1229
000092  f44f7080          MOV      r0,#0x100             ;1231
000096  8020              STRH     r0,[r4,#0]            ;1231
000098  2008              MOVS     r0,#8                 ;1232
00009a  8060              STRH     r0,[r4,#2]            ;1232
00009c  2006              MOVS     r0,#6                 ;1234
00009e  7120              STRB     r0,[r4,#4]            ;1234
0000a0  2004              MOVS     r0,#4                 ;1235
0000a2  7160              STRB     r0,[r4,#5]            ;1235
0000a4  f44f60c1          MOV      r0,#0x608             ;1237
0000a8  81a8              STRH     r0,[r5,#0xc]          ;1237
0000aa  69ba              LDR      r2,[r7,#0x18]
0000ac  4638              MOV      r0,r7
0000ae  4790              BLX      r2
0000b0  4604              MOV      r4,r0
;;;1240     ETHARP_STATS_INC(etharp.xmit);
;;;1241     /* free ARP query packet */
;;;1242     pbuf_free(p);
0000b2  4630              MOV      r0,r6
0000b4  f7fffffe          BL       pbuf_free
;;;1243     p = NULL;
;;;1244     /* could not allocate pbuf for ARP request */
;;;1245   
;;;1246     return result;
0000b8  4620              MOV      r0,r4
                  |L9.186|
;;;1247   }
0000ba  e8bd9ff0          POP      {r4-r12,pc}
                  |L9.190|
0000be  f04f30ff          MOV      r0,#0xffffffff        ;1198
0000c2  e7fa              B        |L9.186|
;;;1248   
                          ENDP

                  |L9.196|
0000c4  6e657469          DCB      "netif != NULL",0
0000c8  6620213d
0000cc  204e554c
0000d0  4c00    
0000d2  00                DCB      0
0000d3  00                DCB      0
                  |L9.212|
0000d4  63686563          DCB      "check that first pbuf can hold struct etharp_hdr",0
0000d8  6b207468
0000dc  61742066
0000e0  69727374
0000e4  20706275
0000e8  66206361
0000ec  6e20686f
0000f0  6c642073
0000f4  74727563
0000f8  74206574
0000fc  68617270
000100  5f686472
000104  00      
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0
                  |L9.264|
                          DCD      ||.conststring||

                          AREA ||i.etharp_request||, CODE, READONLY, ALIGN=2

                  etharp_request PROC
;;;1258   err_t
;;;1259   etharp_request(struct netif *netif, ip_addr_t *ipaddr)
000000  b51f              PUSH     {r0-r4,lr}
;;;1260   {
;;;1261     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
;;;1262     return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
000002  2301              MOVS     r3,#1
000004  4c06              LDR      r4,|L10.32|
000006  1d02              ADDS     r2,r0,#4
000008  e9cd1302          STRD     r1,r3,[sp,#8]
00000c  e9cd2400          STRD     r2,r4,[sp,#0]
000010  f100032b          ADD      r3,r0,#0x2b
000014  4619              MOV      r1,r3
000016  1fa2              SUBS     r2,r4,#6
000018  f7fffffe          BL       etharp_raw
;;;1263                       (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
;;;1264                       ipaddr, ARP_REQUEST);
;;;1265   }
00001c  b004              ADD      sp,sp,#0x10
00001e  bd10              POP      {r4,pc}
;;;1266   #endif /* LWIP_ARP */
                          ENDP

                  |L10.32|
                          DCD      ||.constdata||+0x6

                          AREA ||i.etharp_send_ip||, CODE, READONLY, ALIGN=2

                  etharp_send_ip PROC
;;;414    static err_t
;;;415    etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;416    {
000004  4605              MOV      r5,r0
;;;417      struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
;;;418    
;;;419      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
000006  f890002a          LDRB     r0,[r0,#0x2a]
00000a  684c              LDR      r4,[r1,#4]
00000c  461e              MOV      r6,r3                 ;416
00000e  4617              MOV      r7,r2                 ;416
000010  4688              MOV      r8,r1                 ;416
000012  2806              CMP      r0,#6
000014  d002              BEQ      |L11.28|
000016  480a              LDR      r0,|L11.64|
000018  f7fffffe          BL       __2printf
                  |L11.28|
;;;420                  (netif->hwaddr_len == ETHARP_HWADDR_LEN));
;;;421      ETHADDR32_COPY(&ethhdr->dest, dst);
00001c  6830              LDR      r0,[r6,#0]
00001e  6020              STR      r0,[r4,#0]
000020  88b0              LDRH     r0,[r6,#4]
000022  80a0              STRH     r0,[r4,#4]
;;;422      ETHADDR16_COPY(&ethhdr->src, src);
000024  6838              LDR      r0,[r7,#0]
000026  f8c40006          STR      r0,[r4,#6]
00002a  88b8              LDRH     r0,[r7,#4]
00002c  8160              STRH     r0,[r4,#0xa]
;;;423      ethhdr->type = PP_HTONS(ETHTYPE_IP);
00002e  2008              MOVS     r0,#8
000030  81a0              STRH     r0,[r4,#0xc]
;;;424      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
;;;425      /* send the packet */
;;;426      return netif->linkoutput(netif, p);
000032  4641              MOV      r1,r8
000034  4628              MOV      r0,r5
000036  69aa              LDR      r2,[r5,#0x18]
000038  e8bd41f0          POP      {r4-r8,lr}
00003c  4710              BX       r2
;;;427    }
;;;428    
                          ENDP

00003e  0000              DCW      0x0000
                  |L11.64|
                          DCD      ||.conststring||

                          AREA ||i.etharp_tmr||, CODE, READONLY, ALIGN=2

                  etharp_tmr PROC
;;;205    void
;;;206    etharp_tmr(void)
000000  b570              PUSH     {r4-r6,lr}
;;;207    {
;;;208      u8_t i;
;;;209    
;;;210      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
;;;211      /* remove expired entries from the ARP table */
;;;212      for (i = 0; i < ARP_TABLE_SIZE; ++i) {
;;;213        u8_t state = arp_table[i].state;
000002  4d10              LDR      r5,|L12.68|
000004  2400              MOVS     r4,#0                 ;212
                  |L12.6|
000006  eb040084          ADD      r0,r4,r4,LSL #2
00000a  eb050080          ADD      r0,r5,r0,LSL #2
00000e  7c82              LDRB     r2,[r0,#0x12]
;;;214        if (state != ETHARP_STATE_EMPTY
000010  b192              CBZ      r2,|L12.56|
;;;215    #if ETHARP_SUPPORT_STATIC_ENTRIES
;;;216          && (state != ETHARP_STATE_STATIC)
;;;217    #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
;;;218          ) {
;;;219          arp_table[i].ctime++;
000012  7cc1              LDRB     r1,[r0,#0x13]
000014  1c49              ADDS     r1,r1,#1
000016  b2c9              UXTB     r1,r1
000018  74c1              STRB     r1,[r0,#0x13]
;;;220          if ((arp_table[i].ctime >= ARP_MAXAGE) ||
00001a  29f0              CMP      r1,#0xf0
00001c  d206              BCS      |L12.44|
;;;221              ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
00001e  2a01              CMP      r2,#1
000020  d002              BEQ      |L12.40|
;;;222               (arp_table[i].ctime >= ARP_MAXPENDING))) {
;;;223            /* pending or stable entry has become old! */
;;;224            LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
;;;225                 arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
;;;226            /* clean up entries that have just been expired */
;;;227            etharp_free_entry(i);
;;;228          }
;;;229          else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
000022  2a03              CMP      r2,#3
000024  d006              BEQ      |L12.52|
000026  e007              B        |L12.56|
                  |L12.40|
000028  2902              CMP      r1,#2                 ;222
00002a  d305              BCC      |L12.56|
                  |L12.44|
00002c  4620              MOV      r0,r4                 ;227
00002e  f7fffffe          BL       etharp_free_entry
000032  e001              B        |L12.56|
                  |L12.52|
;;;230            /* Reset state to stable, so that the next transmitted packet will
;;;231               re-send an ARP request. */
;;;232            arp_table[i].state = ETHARP_STATE_STABLE;
000034  2102              MOVS     r1,#2
000036  7481              STRB     r1,[r0,#0x12]
                  |L12.56|
000038  1c64              ADDS     r4,r4,#1
00003a  b2e4              UXTB     r4,r4                 ;212
00003c  2c0a              CMP      r4,#0xa               ;212
00003e  d3e2              BCC      |L12.6|
;;;233          }
;;;234    #if ARP_QUEUEING
;;;235          /* still pending entry? (not expired) */
;;;236          if (arp_table[i].state == ETHARP_STATE_PENDING) {
;;;237            /* resend an ARP query here? */
;;;238          }
;;;239    #endif /* ARP_QUEUEING */
;;;240        }
;;;241      }
;;;242    }
000040  bd70              POP      {r4-r6,pc}
;;;243    
                          ENDP

000042  0000              DCW      0x0000
                  |L12.68|
                          DCD      ||.bss||

                          AREA ||i.etharp_update_arp_entry||, CODE, READONLY, ALIGN=2

                  etharp_update_arp_entry PROC
;;;447    static err_t
;;;448    etharp_update_arp_entry(struct netif *netif, ip_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;449    {
000004  4604              MOV      r4,r0
;;;450      s8_t i;
;;;451      LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
000006  f890002a          LDRB     r0,[r0,#0x2a]
00000a  461f              MOV      r7,r3                 ;449
00000c  4615              MOV      r5,r2                 ;449
00000e  460e              MOV      r6,r1                 ;449
000010  2806              CMP      r0,#6
000012  d002              BEQ      |L13.26|
000014  a01c              ADR      r0,|L13.136|
000016  f7fffffe          BL       __2printf
                  |L13.26|
;;;452      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
;;;453        ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
;;;454        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
;;;455        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
;;;456      /* non-unicast address? */
;;;457      if (ip_addr_isany(ipaddr) ||
00001a  b386              CBZ      r6,|L13.126|
00001c  6830              LDR      r0,[r6,#0]
00001e  b370              CBZ      r0,|L13.126|
;;;458          ip_addr_isbroadcast(ipaddr, netif) ||
000020  4621              MOV      r1,r4
000022  f7fffffe          BL       ip4_addr_isbroadcast
000026  bb50              CBNZ     r0,|L13.126|
;;;459          ip_addr_ismulticast(ipaddr)) {
000028  7830              LDRB     r0,[r6,#0]
00002a  f3c01003          UBFX     r0,r0,#4,#4
00002e  280e              CMP      r0,#0xe
000030  d026              BEQ      |L13.128|
;;;460        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
;;;461        return ERR_ARG;
;;;462      }
;;;463      /* find or create ARP entry */
;;;464      i = etharp_find_entry(ipaddr, flags);
000032  4639              MOV      r1,r7
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       etharp_find_entry
;;;465      /* bail out if no entry could be found */
;;;466      if (i < 0) {
00003a  2800              CMP      r0,#0
00003c  db1d              BLT      |L13.122|
;;;467        return (err_t)i;
;;;468      }
;;;469    
;;;470    #if ETHARP_SUPPORT_STATIC_ENTRIES
;;;471      if (flags & ETHARP_FLAG_STATIC_ENTRY) {
;;;472        /* record static type */
;;;473        arp_table[i].state = ETHARP_STATE_STATIC;
;;;474      } else
;;;475    #endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
;;;476      {
;;;477        /* mark it stable */
;;;478        arp_table[i].state = ETHARP_STATE_STABLE;
00003e  4a1c              LDR      r2,|L13.176|
000040  eb000180          ADD      r1,r0,r0,LSL #2
000044  eb020081          ADD      r0,r2,r1,LSL #2
000048  2302              MOVS     r3,#2
00004a  7483              STRB     r3,[r0,#0x12]
;;;479      }
;;;480    
;;;481      /* record network interface */
;;;482      arp_table[i].netif = netif;
;;;483      /* insert in SNMP ARP index tree */
;;;484      snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);
;;;485    
;;;486      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
;;;487      /* update address */
;;;488      ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
00004c  6084              STR      r4,[r0,#8]
00004e  682b              LDR      r3,[r5,#0]
000050  60c3              STR      r3,[r0,#0xc]
000052  88ab              LDRH     r3,[r5,#4]
000054  8203              STRH     r3,[r0,#0x10]
;;;489      /* reset time stamp */
;;;490      arp_table[i].ctime = 0;
000056  2300              MOVS     r3,#0
000058  74c3              STRB     r3,[r0,#0x13]
;;;491      /* this is where we will send out queued packets! */
;;;492    #if ARP_QUEUEING
;;;493      while (arp_table[i].q != NULL) {
;;;494        struct pbuf *p;
;;;495        /* remember remainder of queue */
;;;496        struct etharp_q_entry *q = arp_table[i].q;
;;;497        /* pop first item off the queue */
;;;498        arp_table[i].q = q->next;
;;;499        /* get the packet pointer */
;;;500        p = q->p;
;;;501        /* now queue entry can be freed */
;;;502        memp_free(MEMP_ARP_QUEUE, q);
;;;503    #else /* ARP_QUEUEING */
;;;504      if (arp_table[i].q != NULL) {
00005a  f8526021          LDR      r6,[r2,r1,LSL #2]
00005e  b15e              CBZ      r6,|L13.120|
;;;505        struct pbuf *p = arp_table[i].q;
;;;506        arp_table[i].q = NULL;
000060  f8423021          STR      r3,[r2,r1,LSL #2]
;;;507    #endif /* ARP_QUEUEING */
;;;508        /* send the queued IP packet */
;;;509        etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
000064  462b              MOV      r3,r5
000066  f104022b          ADD      r2,r4,#0x2b
00006a  4631              MOV      r1,r6
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       etharp_send_ip
;;;510        /* free the queued IP packet */
;;;511        pbuf_free(p);
000072  4630              MOV      r0,r6
000074  f7fffffe          BL       pbuf_free
                  |L13.120|
;;;512      }
;;;513      return ERR_OK;
000078  2000              MOVS     r0,#0
                  |L13.122|
;;;514    }
00007a  e8bd81f0          POP      {r4-r8,pc}
                  |L13.126|
00007e  e7ff              B        |L13.128|
                  |L13.128|
000080  f06f000d          MVN      r0,#0xd               ;461
000084  e7f9              B        |L13.122|
;;;515    
                          ENDP

000086  0000              DCW      0x0000
                  |L13.136|
000088  6e657469          DCB      "netif->hwaddr_len == ETHARP_HWADDR_LEN",0
00008c  662d3e68
000090  77616464
000094  725f6c65
000098  6e203d3d
00009c  20455448
0000a0  4152505f
0000a4  48574144
0000a8  44525f4c
0000ac  454e00  
0000af  00                DCB      0
                  |L13.176|
                          DCD      ||.bss||

                          AREA ||i.ethernet_input||, CODE, READONLY, ALIGN=2

                  ethernet_input PROC
;;;1276   err_t
;;;1277   ethernet_input(struct pbuf *p, struct netif *netif)
000000  b570              PUSH     {r4-r6,lr}
;;;1278   {
000002  4604              MOV      r4,r0
;;;1279     struct eth_hdr* ethhdr;
;;;1280     u16_t type;
;;;1281   #if LWIP_ARP || ETHARP_SUPPORT_VLAN
;;;1282     s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
;;;1283   #endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */
;;;1284   
;;;1285     if (p->len <= SIZEOF_ETH_HDR) {
000004  8940              LDRH     r0,[r0,#0xa]
000006  460d              MOV      r5,r1                 ;1278
000008  280e              CMP      r0,#0xe
00000a  d93e              BLS      |L14.138|
;;;1286       /* a packet with only an ethernet header (or less) is not valid for us */
;;;1287       ETHARP_STATS_INC(etharp.proterr);
;;;1288       ETHARP_STATS_INC(etharp.drop);
;;;1289       goto free_and_return;
;;;1290     }
;;;1291   
;;;1292     /* points to packet payload, which starts with an Ethernet header */
;;;1293     ethhdr = (struct eth_hdr *)p->payload;
;;;1294     LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE,
;;;1295       ("ethernet_input: dest:%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F", src:%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F", type:%"X16_F"\n",
;;;1296        (unsigned)ethhdr->dest.addr[0], (unsigned)ethhdr->dest.addr[1], (unsigned)ethhdr->dest.addr[2],
;;;1297        (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
;;;1298        (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
;;;1299        (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
;;;1300        (unsigned)htons(ethhdr->type)));
;;;1301   
;;;1302     type = ethhdr->type;
00000c  6860              LDR      r0,[r4,#4]
;;;1303   #if ETHARP_SUPPORT_VLAN
;;;1304     if (type == PP_HTONS(ETHTYPE_VLAN)) {
;;;1305       struct eth_vlan_hdr *vlan = (struct eth_vlan_hdr*)(((char*)ethhdr) + SIZEOF_ETH_HDR);
;;;1306       if (p->len <= SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR) {
;;;1307         /* a packet with only an ethernet/vlan header (or less) is not valid for us */
;;;1308         ETHARP_STATS_INC(etharp.proterr);
;;;1309         ETHARP_STATS_INC(etharp.drop);
;;;1310         goto free_and_return;
;;;1311       }
;;;1312   #if defined(ETHARP_VLAN_CHECK) || defined(ETHARP_VLAN_CHECK_FN) /* if not, allow all VLANs */
;;;1313   #ifdef ETHARP_VLAN_CHECK_FN
;;;1314       if (!ETHARP_VLAN_CHECK_FN(ethhdr, vlan)) {
;;;1315   #elif defined(ETHARP_VLAN_CHECK)
;;;1316       if (VLAN_ID(vlan) != ETHARP_VLAN_CHECK) {
;;;1317   #endif
;;;1318         /* silently ignore this packet: not for our VLAN */
;;;1319         pbuf_free(p);
;;;1320         return ERR_OK;
;;;1321       }
;;;1322   #endif /* defined(ETHARP_VLAN_CHECK) || defined(ETHARP_VLAN_CHECK_FN) */
;;;1323       type = vlan->tpid;
;;;1324       ip_hdr_offset = SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR;
;;;1325     }
;;;1326   #endif /* ETHARP_SUPPORT_VLAN */
;;;1327   
;;;1328   #if LWIP_ARP_FILTER_NETIF
;;;1329     netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
;;;1330   #endif /* LWIP_ARP_FILTER_NETIF*/
;;;1331   
;;;1332     if (ethhdr->dest.addr[0] & 1) {
00000e  7801              LDRB     r1,[r0,#0]
000010  8986              LDRH     r6,[r0,#0xc]          ;1302
000012  07ca              LSLS     r2,r1,#31
000014  d014              BEQ      |L14.64|
;;;1333       /* this might be a multicast or broadcast packet */
;;;1334       if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
000016  2901              CMP      r1,#1
000018  d005              BEQ      |L14.38|
;;;1335         if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
;;;1336             (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
;;;1337           /* mark the pbuf as link-layer multicast */
;;;1338           p->flags |= PBUF_FLAG_LLMCAST;
;;;1339         }
;;;1340       } else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
00001a  2206              MOVS     r2,#6
00001c  491d              LDR      r1,|L14.148|
00001e  f7fffffe          BL       memcmp
000022  b148              CBZ      r0,|L14.56|
000024  e00c              B        |L14.64|
                  |L14.38|
000026  7841              LDRB     r1,[r0,#1]            ;1335
000028  b951              CBNZ     r1,|L14.64|
00002a  7880              LDRB     r0,[r0,#2]            ;1336
00002c  285e              CMP      r0,#0x5e              ;1336
00002e  d107              BNE      |L14.64|
000030  7b60              LDRB     r0,[r4,#0xd]          ;1338
000032  f0400010          ORR      r0,r0,#0x10           ;1338
000036  e002              B        |L14.62|
                  |L14.56|
;;;1341         /* mark the pbuf as link-layer broadcast */
;;;1342         p->flags |= PBUF_FLAG_LLBCAST;
000038  7b60              LDRB     r0,[r4,#0xd]
00003a  f0400008          ORR      r0,r0,#8
                  |L14.62|
00003e  7360              STRB     r0,[r4,#0xd]
                  |L14.64|
;;;1343       }
;;;1344     }
;;;1345   
;;;1346     switch (type) {
000040  2e08              CMP      r6,#8
000042  d003              BEQ      |L14.76|
000044  f5b66fc1          CMP      r6,#0x608
000048  d11f              BNE      |L14.138|
00004a  e012              B        |L14.114|
                  |L14.76|
;;;1347   #if LWIP_ARP
;;;1348       /* IP packet? */
;;;1349       case PP_HTONS(ETHTYPE_IP):
;;;1350         if (!(netif->flags & NETIF_FLAG_ETHARP)) {
00004c  f8950031          LDRB     r0,[r5,#0x31]
000050  0680              LSLS     r0,r0,#26
000052  d51a              BPL      |L14.138|
;;;1351           goto free_and_return;
;;;1352         }
;;;1353   #if ETHARP_TRUST_IP_MAC
;;;1354         /* update ARP table */
;;;1355         etharp_ip_input(netif, p);
;;;1356   #endif /* ETHARP_TRUST_IP_MAC */
;;;1357         /* skip Ethernet header */
;;;1358         if(pbuf_header(p, -ip_hdr_offset)) {
000054  f06f010d          MVN      r1,#0xd
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       pbuf_header
00005e  b118              CBZ      r0,|L14.104|
;;;1359           LWIP_ASSERT("Can't move over header in packet", 0);
000060  a00d              ADR      r0,|L14.152|
000062  f7fffffe          BL       __2printf
;;;1360           goto free_and_return;
000066  e010              B        |L14.138|
                  |L14.104|
;;;1361         } else {
;;;1362           /* pass to IP layer */
;;;1363           ip_input(p, netif);
000068  4629              MOV      r1,r5
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       ip_input
000070  e009              B        |L14.134|
                  |L14.114|
;;;1364         }
;;;1365         break;
;;;1366         
;;;1367       case PP_HTONS(ETHTYPE_ARP):
;;;1368         if (!(netif->flags & NETIF_FLAG_ETHARP)) {
000072  f8950031          LDRB     r0,[r5,#0x31]
000076  0680              LSLS     r0,r0,#26
000078  d507              BPL      |L14.138|
;;;1369           goto free_and_return;
;;;1370         }
;;;1371         /* pass p to ARP module */
;;;1372         etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
00007a  4622              MOV      r2,r4
00007c  f105012b          ADD      r1,r5,#0x2b
000080  4628              MOV      r0,r5
000082  f7fffffe          BL       etharp_arp_input
                  |L14.134|
;;;1373         break;
;;;1374   #endif /* LWIP_ARP */
;;;1375   #if PPPOE_SUPPORT
;;;1376       case PP_HTONS(ETHTYPE_PPPOEDISC): /* PPP Over Ethernet Discovery Stage */
;;;1377         pppoe_disc_input(netif, p);
;;;1378         break;
;;;1379   
;;;1380       case PP_HTONS(ETHTYPE_PPPOE): /* PPP Over Ethernet Session Stage */
;;;1381         pppoe_data_input(netif, p);
;;;1382         break;
;;;1383   #endif /* PPPOE_SUPPORT */
;;;1384   
;;;1385       default:
;;;1386         ETHARP_STATS_INC(etharp.proterr);
;;;1387         ETHARP_STATS_INC(etharp.drop);
;;;1388         goto free_and_return;
;;;1389     }
;;;1390   
;;;1391     /* This means the pbuf is freed or consumed,
;;;1392        so the caller doesn't have to free it again */
;;;1393     return ERR_OK;
000086  2000              MOVS     r0,#0
;;;1394   
;;;1395   free_and_return:
;;;1396     pbuf_free(p);
;;;1397     return ERR_OK;
;;;1398   }
000088  bd70              POP      {r4-r6,pc}
                  |L14.138|
00008a  4620              MOV      r0,r4                 ;1396
00008c  f7fffffe          BL       pbuf_free
000090  e7f9              B        |L14.134|
;;;1399   #endif /* LWIP_ARP || LWIP_ETHERNET */
                          ENDP

000092  0000              DCW      0x0000
                  |L14.148|
                          DCD      ||.constdata||
                  |L14.152|
000098  43616e27          DCB      "Can't move over header in packet",0
00009c  74206d6f
0000a0  7665206f
0000a4  76657220
0000a8  68656164
0000ac  65722069
0000b0  6e207061
0000b4  636b6574
0000b8  00      
0000b9  00                DCB      0
0000ba  00                DCB      0
0000bb  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  arp_table
                          %        200

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  ethbroadcast
000000  ffffffff          DCB      0xff,0xff,0xff,0xff
000004  ffff              DCB      0xff,0xff
                  ethzero
000006  0000              DCB      0x00,0x00
000008  00000000          DCB      0x00,0x00,0x00,0x00

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  6e657469          DCB      "netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN"
000004  662d3e68
000008  77616464
00000c  725f6c65
000010  6e206d75
000014  73742062
000018  65207468
00001c  65207361
000020  6d652061
000024  73204554
000028  48415250
00002c  5f485741
000030  4444525f
000034  4c454e  
000037  20666f72          DCB      " for etharp!",0
00003b  20657468
00003f  61727021
000043  00      

                          AREA ||.data||, DATA, ALIGN=0

                  etharp_cached_entry
000000  00                DCB      0x00

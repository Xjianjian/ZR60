; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\pbuf.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\pbuf.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\ZR60_v1.0_freeRTOS -I..\..\Lwip\App -I..\..\Lwip\Bsp -I..\..\Lwip\Bsp\LAN8742A -I..\..\Lwip\lwip-1.4.1 -I..\..\Lwip\lwip-1.4.1\port -I..\..\Lwip\lwip-1.4.1\port\arch -I..\..\Lwip\lwip-1.4.1\port\Standalone -I..\..\Lwip\lwip-1.4.1\src\include -I..\..\Lwip\lwip-1.4.1\src\include\ipv4 -I..\..\Lwip\lwip-1.4.1\src\include\lwip -I..\..\Lwip\lwip-1.4.1\src\include\netif -I..\..\Ecal\BtnFltr -I..\..\Ecal\UartComn -I..\..\Ecal\MemIf -I..\..\APP -I..\..\APP\BlackListMng -I..\..\APP\SeverNewsPush -I..\..\APP\NewsPull -I..\..\Ecal -I..\..\Ecal\JsonIf -I..\..\Ecal\Mcu_Init -I..\..\Service -I..\..\Complex -I..\..\Complex\FATFS -I..\..\FreeRTOS\Source\include -I..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\FreeRTOS -I.\RTE\_ZR60 -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=..\..\output\pbuf.crf ..\..\Lwip\lwip-1.4.1\src\core\pbuf.c]
                          THUMB

                          AREA ||i.pbuf_alloc||, CODE, READONLY, ALIGN=2

                  pbuf_alloc PROC
;;;207    struct pbuf *
;;;208    pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;209    {
000004  4690              MOV      r8,r2
000006  460e              MOV      r6,r1
000008  b138              CBZ      r0,|L1.26|
;;;210      struct pbuf *p, *q, *r;
;;;211      u16_t offset;
;;;212      s32_t rem_len; /* remaining length */
;;;213      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));
;;;214    
;;;215      /* determine header offset */
;;;216      switch (layer) {
00000a  2801              CMP      r0,#1
00000c  d007              BEQ      |L1.30|
00000e  2802              CMP      r0,#2
000010  d007              BEQ      |L1.34|
000012  2803              CMP      r0,#3
000014  d007              BEQ      |L1.38|
;;;217      case PBUF_TRANSPORT:
;;;218        /* add room for transport (often TCP) layer header */
;;;219        offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
;;;220        break;
;;;221      case PBUF_IP:
;;;222        /* add room for IP layer header */
;;;223        offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
;;;224        break;
;;;225      case PBUF_LINK:
;;;226        /* add room for link layer header */
;;;227        offset = PBUF_LINK_HLEN;
;;;228        break;
;;;229      case PBUF_RAW:
;;;230        offset = 0;
;;;231        break;
;;;232      default:
;;;233        LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
000016  a060              ADR      r0,|L1.408|
;;;234        return NULL;
000018  e013              B        |L1.66|
                  |L1.26|
00001a  2536              MOVS     r5,#0x36              ;219
00001c  e004              B        |L1.40|
                  |L1.30|
00001e  2522              MOVS     r5,#0x22              ;223
000020  e002              B        |L1.40|
                  |L1.34|
000022  250e              MOVS     r5,#0xe               ;227
000024  e000              B        |L1.40|
                  |L1.38|
000026  2500              MOVS     r5,#0                 ;230
                  |L1.40|
;;;235      }
;;;236    
;;;237      switch (type) {
000028  0010              MOVS     r0,r2
00002a  f04f0b01          MOV      r11,#1                ;209
00002e  f04f0a00          MOV      r10,#0                ;209
000032  d07d              BEQ      |L1.304|
000034  2801              CMP      r0,#1
                  |L1.54|
000036  d073              BEQ      |L1.288|
000038  2802              CMP      r0,#2
00003a  d0fc              BEQ      |L1.54|
00003c  2a03              CMP      r2,#3
00003e  d003              BEQ      |L1.72|
;;;238      case PBUF_POOL:
;;;239        /* allocate head of pbuf chain into p */
;;;240        p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
;;;241        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
;;;242        if (p == NULL) {
;;;243          PBUF_POOL_IS_EMPTY();
;;;244          return NULL;
;;;245        }
;;;246        p->type = type;
;;;247        p->next = NULL;
;;;248    
;;;249        /* make the payload pointer point 'offset' bytes into pbuf data memory */
;;;250        p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
;;;251        LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
;;;252                ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
;;;253        /* the total length of the pbuf chain is the requested size */
;;;254        p->tot_len = length;
;;;255        /* set the length of the first pbuf in the chain */
;;;256        p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
;;;257        LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
;;;258                    ((u8_t*)p->payload + p->len <=
;;;259                     (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
;;;260        LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
;;;261          (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
;;;262        /* set reference count (needed here in case we fail) */
;;;263        p->ref = 1;
;;;264    
;;;265        /* now allocate the tail of the pbuf chain */
;;;266    
;;;267        /* remember first pbuf for linkage in next iteration */
;;;268        r = p;
;;;269        /* remaining length to be allocated */
;;;270        rem_len = length - p->len;
;;;271        /* any remaining pbufs to be allocated? */
;;;272        while (rem_len > 0) {
;;;273          q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
;;;274          if (q == NULL) {
;;;275            PBUF_POOL_IS_EMPTY();
;;;276            /* free chain so far allocated */
;;;277            pbuf_free(p);
;;;278            /* bail out unsuccesfully */
;;;279            return NULL;
;;;280          }
;;;281          q->type = type;
;;;282          q->flags = 0;
;;;283          q->next = NULL;
;;;284          /* make previous pbuf point to this pbuf */
;;;285          r->next = q;
;;;286          /* set total length of this pbuf and next in chain */
;;;287          LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
;;;288          q->tot_len = (u16_t)rem_len;
;;;289          /* this pbuf length is pool size, unless smaller sized tail */
;;;290          q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
;;;291          q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
;;;292          LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
;;;293                  ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
;;;294          LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
;;;295                      ((u8_t*)p->payload + p->len <=
;;;296                       (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
;;;297          q->ref = 1;
;;;298          /* calculate remaining length to be allocated */
;;;299          rem_len -= q->len;
;;;300          /* remember this pbuf for linkage in next iteration */
;;;301          r = q;
;;;302        }
;;;303        /* end of chain */
;;;304        /*r->next = NULL;*/
;;;305    
;;;306        break;
;;;307      case PBUF_RAM:
;;;308        /* If pbuf is to be allocated in RAM, allocate memory for it. */
;;;309        p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
;;;310        if (p == NULL) {
;;;311          return NULL;
;;;312        }
;;;313        /* Set up internal structure of the pbuf. */
;;;314        p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
;;;315        p->len = p->tot_len = length;
;;;316        p->next = NULL;
;;;317        p->type = type;
;;;318    
;;;319        LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
;;;320               ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
;;;321        break;
;;;322      /* pbuf references existing (non-volatile static constant) ROM payload? */
;;;323      case PBUF_ROM:
;;;324      /* pbuf references existing (externally allocated) RAM payload? */
;;;325      case PBUF_REF:
;;;326        /* only allocate memory for the pbuf structure */
;;;327        p = (struct pbuf *)memp_malloc(MEMP_PBUF);
;;;328        if (p == NULL) {
;;;329          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;330                      ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
;;;331                      (type == PBUF_ROM) ? "ROM" : "REF"));
;;;332          return NULL;
;;;333        }
;;;334        /* caller must set this field properly, afterwards */
;;;335        p->payload = NULL;
;;;336        p->len = p->tot_len = length;
;;;337        p->next = NULL;
;;;338        p->type = type;
;;;339        break;
;;;340      default:
;;;341        LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
000040  a05c              ADR      r0,|L1.436|
                  |L1.66|
000042  f7fffffe          BL       __2printf
000046  e0a5              B        |L1.404|
                  |L1.72|
000048  2008              MOVS     r0,#8                 ;240
00004a  f7fffffe          BL       memp_malloc
00004e  0004              MOVS     r4,r0                 ;240
000050  d017              BEQ      |L1.130|
000052  1960              ADDS     r0,r4,r5              ;250
000054  3013              ADDS     r0,r0,#0x13           ;250
000056  f884800c          STRB     r8,[r4,#0xc]          ;246
00005a  f0200003          BIC      r0,r0,#3              ;250
00005e  e9c4a000          STRD     r10,r0,[r4,#0]        ;250
000062  0780              LSLS     r0,r0,#30             ;251
000064  d002              BEQ      |L1.108|
000066  a05a              ADR      r0,|L1.464|
000068  f7fffffe          BL       __2printf
                  |L1.108|
00006c  1ced              ADDS     r5,r5,#3              ;254
00006e  f0250003          BIC      r0,r5,#3              ;256
000072  f2a050b4          SUB      r0,r0,#0x5b4          ;256
000076  4245              RSBS     r5,r0,#0              ;256
000078  8126              STRH     r6,[r4,#8]            ;254
00007a  42b5              CMP      r5,r6                 ;256
00007c  dd05              BLE      |L1.138|
00007e  4630              MOV      r0,r6                 ;256
000080  e004              B        |L1.140|
                  |L1.130|
000082  495f              LDR      r1,|L1.512|
000084  f881b000          STRB     r11,[r1,#0]           ;256
000088  e084              B        |L1.404|
                  |L1.138|
00008a  4628              MOV      r0,r5                 ;244
                  |L1.140|
00008c  b280              UXTH     r0,r0                 ;256
00008e  8160              STRH     r0,[r4,#0xa]          ;256
000090  6861              LDR      r1,[r4,#4]            ;257
000092  f20459c4          ADD      r9,r4,#0x5c4          ;257
000096  4401              ADD      r1,r1,r0              ;257
000098  4549              CMP      r1,r9                 ;257
00009a  d902              BLS      |L1.162|
00009c  a059              ADR      r0,|L1.516|
00009e  f7fffffe          BL       __2printf
                  |L1.162|
0000a2  2d00              CMP      r5,#0                 ;260
0000a4  dc02              BGT      |L1.172|
0000a6  a064              ADR      r0,|L1.568|
0000a8  f7fffffe          BL       __2printf
                  |L1.172|
0000ac  f8a4b00e          STRH     r11,[r4,#0xe]         ;263
0000b0  8961              LDRH     r1,[r4,#0xa]          ;270
0000b2  4627              MOV      r7,r4                 ;268
0000b4  1a76              SUBS     r6,r6,r1              ;270
0000b6  e02f              B        |L1.280|
                  |L1.184|
0000b8  2008              MOVS     r0,#8                 ;273
0000ba  f7fffffe          BL       memp_malloc
0000be  0005              MOVS     r5,r0                 ;273
0000c0  d02f              BEQ      |L1.290|
0000c2  f885800c          STRB     r8,[r5,#0xc]          ;281
0000c6  f885a00d          STRB     r10,[r5,#0xd]         ;282
0000ca  f8c5a000          STR      r10,[r5,#0]           ;285
0000ce  f64f70ff          MOV      r0,#0xffff            ;287
0000d2  603d              STR      r5,[r7,#0]            ;287
0000d4  4286              CMP      r6,r0                 ;287
0000d6  db02              BLT      |L1.222|
0000d8  a064              ADR      r0,|L1.620|
0000da  f7fffffe          BL       __2printf
                  |L1.222|
0000de  b2b0              UXTH     r0,r6                 ;288
0000e0  f24051b4          MOV      r1,#0x5b4             ;290
0000e4  8128              STRH     r0,[r5,#8]            ;288
0000e6  4288              CMP      r0,r1                 ;290
0000e8  d300              BCC      |L1.236|
0000ea  4608              MOV      r0,r1                 ;290
                  |L1.236|
0000ec  8168              STRH     r0,[r5,#0xa]          ;290
0000ee  f1050010          ADD      r0,r5,#0x10           ;291
0000f2  6068              STR      r0,[r5,#4]            ;292
0000f4  0780              LSLS     r0,r0,#30             ;292
0000f6  d002              BEQ      |L1.254|
0000f8  a061              ADR      r0,|L1.640|
0000fa  f7fffffe          BL       __2printf
                  |L1.254|
0000fe  8961              LDRH     r1,[r4,#0xa]          ;294
000100  6860              LDR      r0,[r4,#4]            ;294
000102  4401              ADD      r1,r1,r0              ;294
000104  4549              CMP      r1,r9                 ;294
000106  d902              BLS      |L1.270|
000108  a03e              ADR      r0,|L1.516|
00010a  f7fffffe          BL       __2printf
                  |L1.270|
00010e  f8a5b00e          STRH     r11,[r5,#0xe]         ;297
000112  8968              LDRH     r0,[r5,#0xa]          ;299
000114  462f              MOV      r7,r5                 ;301
000116  1a36              SUBS     r6,r6,r0              ;299
                  |L1.280|
000118  2e00              CMP      r6,#0                 ;272
00011a  dccd              BGT      |L1.184|
00011c  e033              B        |L1.390|
00011e  e007              B        |L1.304|
                  |L1.288|
000120  e024              B        |L1.364|
                  |L1.290|
000122  4937              LDR      r1,|L1.512|
000124  f881b000          STRB     r11,[r1,#0]           ;272
000128  4620              MOV      r0,r4                 ;277
00012a  f7fffffe          BL       pbuf_free
00012e  e031              B        |L1.404|
                  |L1.304|
000130  f1050013          ADD      r0,r5,#0x13           ;309
000134  f0200103          BIC      r1,r0,#3              ;309
000138  1cf0              ADDS     r0,r6,#3              ;309
00013a  f0200003          BIC      r0,r0,#3              ;309
00013e  4408              ADD      r0,r0,r1              ;309
000140  b280              UXTH     r0,r0                 ;309
000142  f7fffffe          BL       mem_malloc
000146  1e04              SUBS     r4,r0,#0              ;309
000148  d022              BEQ      |L1.400|
00014a  1960              ADDS     r0,r4,r5              ;314
00014c  3013              ADDS     r0,r0,#0x13           ;314
00014e  f0200003          BIC      r0,r0,#3              ;314
000152  6060              STR      r0,[r4,#4]            ;315
000154  8126              STRH     r6,[r4,#8]            ;315
000156  8166              STRH     r6,[r4,#0xa]          ;315
000158  f8c4a000          STR      r10,[r4,#0]           ;317
00015c  f884a00c          STRB     r10,[r4,#0xc]         ;317
000160  0780              LSLS     r0,r0,#30             ;319
000162  d010              BEQ      |L1.390|
000164  a052              ADR      r0,|L1.688|
000166  f7fffffe          BL       __2printf
00016a  e00c              B        |L1.390|
                  |L1.364|
00016c  2007              MOVS     r0,#7                 ;327
00016e  f7fffffe          BL       memp_malloc
000172  0004              MOVS     r4,r0                 ;327
000174  d00e              BEQ      |L1.404|
000176  f8c4a004          STR      r10,[r4,#4]           ;336
00017a  8126              STRH     r6,[r4,#8]            ;336
00017c  8166              STRH     r6,[r4,#0xa]          ;336
00017e  f8c4a000          STR      r10,[r4,#0]           ;338
000182  f884800c          STRB     r8,[r4,#0xc]          ;338
                  |L1.390|
;;;342        return NULL;
;;;343      }
;;;344      /* set reference count */
;;;345      p->ref = 1;
000186  f8a4b00e          STRH     r11,[r4,#0xe]
;;;346      /* set flags */
;;;347      p->flags = 0;
00018a  f884a00d          STRB     r10,[r4,#0xd]
;;;348      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
;;;349      return p;
00018e  4620              MOV      r0,r4
                  |L1.400|
;;;350    }
000190  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.404|
000194  2000              MOVS     r0,#0                 ;332
000196  e7fb              B        |L1.400|
;;;351    
                          ENDP

                  |L1.408|
000198  70627566          DCB      "pbuf_alloc: bad pbuf layer",0
00019c  5f616c6c
0001a0  6f633a20
0001a4  62616420
0001a8  70627566
0001ac  206c6179
0001b0  657200  
0001b3  00                DCB      0
                  |L1.436|
0001b4  70627566          DCB      "pbuf_alloc: erroneous type",0
0001b8  5f616c6c
0001bc  6f633a20
0001c0  6572726f
0001c4  6e656f75
0001c8  73207479
0001cc  706500  
0001cf  00                DCB      0
                  |L1.464|
0001d0  70627566          DCB      "pbuf_alloc: pbuf p->payload properly aligned",0
0001d4  5f616c6c
0001d8  6f633a20
0001dc  70627566
0001e0  20702d3e
0001e4  7061796c
0001e8  6f616420
0001ec  70726f70
0001f0  65726c79
0001f4  20616c69
0001f8  676e6564
0001fc  00      
0001fd  00                DCB      0
0001fe  00                DCB      0
0001ff  00                DCB      0
                  |L1.512|
                          DCD      ||.data||
                  |L1.516|
000204  63686563          DCB      "check p->payload + p->len does not overflow pbuf",0
000208  6b20702d
00020c  3e706179
000210  6c6f6164
000214  202b2070
000218  2d3e6c65
00021c  6e20646f
000220  6573206e
000224  6f74206f
000228  76657266
00022c  6c6f7720
000230  70627566
000234  00      
000235  00                DCB      0
000236  00                DCB      0
000237  00                DCB      0
                  |L1.568|
000238  50425546          DCB      "PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",0
00023c  5f504f4f
000240  4c5f4255
000244  4653495a
000248  45206d75
00024c  73742062
000250  65206269
000254  67676572
000258  20746861
00025c  6e204d45
000260  4d5f414c
000264  49474e4d
000268  454e5400
                  |L1.620|
00026c  72656d5f          DCB      "rem_len < max_u16_t",0
000270  6c656e20
000274  3c206d61
000278  785f7531
00027c  365f7400
                  |L1.640|
000280  70627566          DCB      "pbuf_alloc: pbuf q->payload properly aligned",0
000284  5f616c6c
000288  6f633a20
00028c  70627566
000290  20712d3e
000294  7061796c
000298  6f616420
00029c  70726f70
0002a0  65726c79
0002a4  20616c69
0002a8  676e6564
0002ac  00      
0002ad  00                DCB      0
0002ae  00                DCB      0
0002af  00                DCB      0
                  |L1.688|
0002b0  70627566          DCB      "pbuf_alloc: pbuf->payload properly aligned",0
0002b4  5f616c6c
0002b8  6f633a20
0002bc  70627566
0002c0  2d3e7061
0002c4  796c6f61
0002c8  64207072
0002cc  6f706572
0002d0  6c792061
0002d4  6c69676e
0002d8  656400  
0002db  00                DCB      0

                          AREA ||i.pbuf_alloced_custom||, CODE, READONLY, ALIGN=2

                  pbuf_alloced_custom PROC
;;;367    struct pbuf*
;;;368    pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_custom *p,
000000  b570              PUSH     {r4-r6,lr}
;;;369                        void *payload_mem, u16_t payload_mem_len)
;;;370    {
000002  e9dd4504          LDRD     r4,r5,[sp,#0x10]
000006  b148              CBZ      r0,|L2.28|
;;;371      u16_t offset;
;;;372      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloced_custom(length=%"U16_F")\n", length));
;;;373    
;;;374      /* determine header offset */
;;;375      switch (l) {
000008  2801              CMP      r0,#1
00000a  d009              BEQ      |L2.32|
00000c  2802              CMP      r0,#2
00000e  d009              BEQ      |L2.36|
000010  2803              CMP      r0,#3
000012  d009              BEQ      |L2.40|
;;;376      case PBUF_TRANSPORT:
;;;377        /* add room for transport (often TCP) layer header */
;;;378        offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
;;;379        break;
;;;380      case PBUF_IP:
;;;381        /* add room for IP layer header */
;;;382        offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
;;;383        break;
;;;384      case PBUF_LINK:
;;;385        /* add room for link layer header */
;;;386        offset = PBUF_LINK_HLEN;
;;;387        break;
;;;388      case PBUF_RAW:
;;;389        offset = 0;
;;;390        break;
;;;391      default:
;;;392        LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
000014  a011              ADR      r0,|L2.92|
000016  f7fffffe          BL       __2printf
;;;393        return NULL;
00001a  e00c              B        |L2.54|
                  |L2.28|
00001c  2036              MOVS     r0,#0x36              ;378
00001e  e004              B        |L2.42|
                  |L2.32|
000020  2022              MOVS     r0,#0x22              ;382
000022  e002              B        |L2.42|
                  |L2.36|
000024  200e              MOVS     r0,#0xe               ;386
000026  e000              B        |L2.42|
                  |L2.40|
000028  2000              MOVS     r0,#0                 ;389
                  |L2.42|
00002a  1cc0              ADDS     r0,r0,#3              ;389
;;;394      }
;;;395    
;;;396      if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
00002c  f0200003          BIC      r0,r0,#3
000030  1846              ADDS     r6,r0,r1
000032  42ae              CMP      r6,r5
000034  d901              BLS      |L2.58|
                  |L2.54|
;;;397        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("pbuf_alloced_custom(length=%"U16_F") buffer too short\n", length));
;;;398        return NULL;
000036  2000              MOVS     r0,#0
;;;399      }
;;;400    
;;;401      p->pbuf.next = NULL;
;;;402      if (payload_mem != NULL) {
;;;403        p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
;;;404      } else {
;;;405        p->pbuf.payload = NULL;
;;;406      }
;;;407      p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
;;;408      p->pbuf.len = p->pbuf.tot_len = length;
;;;409      p->pbuf.type = type;
;;;410      p->pbuf.ref = 1;
;;;411      return &p->pbuf;
;;;412    }
000038  bd70              POP      {r4-r6,pc}
                  |L2.58|
00003a  2500              MOVS     r5,#0                 ;401
00003c  601d              STR      r5,[r3,#0]            ;402
00003e  b114              CBZ      r4,|L2.70|
000040  4420              ADD      r0,r0,r4              ;403
000042  6058              STR      r0,[r3,#4]            ;403
000044  e000              B        |L2.72|
                  |L2.70|
000046  605d              STR      r5,[r3,#4]            ;405
                  |L2.72|
000048  2002              MOVS     r0,#2                 ;407
00004a  7358              STRB     r0,[r3,#0xd]          ;407
00004c  8119              STRH     r1,[r3,#8]            ;408
00004e  8159              STRH     r1,[r3,#0xa]          ;408
000050  731a              STRB     r2,[r3,#0xc]          ;409
000052  2001              MOVS     r0,#1                 ;410
000054  81d8              STRH     r0,[r3,#0xe]          ;410
000056  4618              MOV      r0,r3                 ;411
000058  bd70              POP      {r4-r6,pc}
;;;413    #endif /* LWIP_SUPPORT_CUSTOM_PBUF */
                          ENDP

00005a  0000              DCW      0x0000
                  |L2.92|
00005c  70627566          DCB      "pbuf_alloced_custom: bad pbuf layer",0
000060  5f616c6c
000064  6f636564
000068  5f637573
00006c  746f6d3a
000070  20626164
000074  20706275
000078  66206c61
00007c  79657200

                          AREA ||i.pbuf_cat||, CODE, READONLY, ALIGN=2

                  pbuf_cat PROC
;;;745    void
;;;746    pbuf_cat(struct pbuf *h, struct pbuf *t)
000000  b570              PUSH     {r4-r6,lr}
;;;747    {
000002  460d              MOV      r5,r1
000004  b100              CBZ      r0,|L3.8|
;;;748      struct pbuf *p;
;;;749    
;;;750      LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
000006  b925              CBNZ     r5,|L3.18|
                  |L3.8|
000008  e8bd4070          POP      {r4-r6,lr}
00000c  a00e              ADR      r0,|L3.72|
00000e  f7ffbffe          B.W      __2printf
                  |L3.18|
;;;751                 ((h != NULL) && (t != NULL)), return;);
;;;752    
;;;753      /* proceed to last pbuf of chain */
;;;754      for (p = h; p->next != NULL; p = p->next) {
000012  4604              MOV      r4,r0
000014  6800              LDR      r0,[r0,#0]
000016  b120              CBZ      r0,|L3.34|
;;;755        /* add total length of second chain to all totals of first chain */
;;;756        p->tot_len += t->tot_len;
000018  8921              LDRH     r1,[r4,#8]
00001a  892a              LDRH     r2,[r5,#8]
00001c  4411              ADD      r1,r1,r2
00001e  8121              STRH     r1,[r4,#8]
000020  e7f7              B        |L3.18|
                  |L3.34|
;;;757      }
;;;758      /* { p is last pbuf of first h chain, p->next == NULL } */
;;;759      LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
000022  8920              LDRH     r0,[r4,#8]
000024  8961              LDRH     r1,[r4,#0xa]
000026  4288              CMP      r0,r1
000028  d007              BEQ      |L3.58|
00002a  a015              ADR      r0,|L3.128|
00002c  f7fffffe          BL       __2printf
000030  6820              LDR      r0,[r4,#0]
000032  b110              CBZ      r0,|L3.58|
;;;760      LWIP_ASSERT("p->next == NULL", p->next == NULL);
000034  a01e              ADR      r0,|L3.176|
000036  f7fffffe          BL       __2printf
                  |L3.58|
;;;761      /* add total length of second chain to last pbuf total of first chain */
;;;762      p->tot_len += t->tot_len;
00003a  8920              LDRH     r0,[r4,#8]
00003c  8929              LDRH     r1,[r5,#8]
00003e  4408              ADD      r0,r0,r1
000040  8120              STRH     r0,[r4,#8]
;;;763      /* chain last pbuf of head (p) with first of tail (t) */
;;;764      p->next = t;
000042  6025              STR      r5,[r4,#0]
;;;765      /* p->next now references t, but the caller will drop its reference to t,
;;;766       * so netto there is no change to the reference count of t.
;;;767       */
;;;768    }
000044  bd70              POP      {r4-r6,pc}
;;;769    
                          ENDP

000046  0000              DCW      0x0000
                  |L3.72|
000048  28682021          DCB      "(h != NULL) && (t != NULL) (programmer violates API)",0
00004c  3d204e55
000050  4c4c2920
000054  26262028
000058  7420213d
00005c  204e554c
000060  4c292028
000064  70726f67
000068  72616d6d
00006c  65722076
000070  696f6c61
000074  74657320
000078  41504929
00007c  00      
00007d  00                DCB      0
00007e  00                DCB      0
00007f  00                DCB      0
                  |L3.128|
000080  702d3e74          DCB      "p->tot_len == p->len (of last pbuf in chain)",0
000084  6f745f6c
000088  656e203d
00008c  3d20702d
000090  3e6c656e
000094  20286f66
000098  206c6173
00009c  74207062
0000a0  75662069
0000a4  6e206368
0000a8  61696e29
0000ac  00      
0000ad  00                DCB      0
0000ae  00                DCB      0
0000af  00                DCB      0
                  |L3.176|
0000b0  702d3e6e          DCB      "p->next == NULL",0
0000b4  65787420
0000b8  3d3d204e
0000bc  554c4c00

                          AREA ||i.pbuf_chain||, CODE, READONLY, ALIGN=1

                  pbuf_chain PROC
;;;786    void
;;;787    pbuf_chain(struct pbuf *h, struct pbuf *t)
000000  b510              PUSH     {r4,lr}
;;;788    {
000002  460c              MOV      r4,r1
;;;789      pbuf_cat(h, t);
000004  f7fffffe          BL       pbuf_cat
;;;790      /* t is now referenced by h */
;;;791      pbuf_ref(t);
000008  4620              MOV      r0,r4
00000a  e8bd4010          POP      {r4,lr}
00000e  f7ffbffe          B.W      pbuf_ref
;;;792      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
;;;793    }
;;;794    
                          ENDP


                          AREA ||i.pbuf_clen||, CODE, READONLY, ALIGN=1

                  pbuf_clen PROC
;;;704    u8_t
;;;705    pbuf_clen(struct pbuf *p)
000000  2100              MOVS     r1,#0
;;;706    {
000002  e002              B        |L5.10|
                  |L5.4|
000004  1c49              ADDS     r1,r1,#1
;;;707      u8_t len;
;;;708    
;;;709      len = 0;
;;;710      while (p != NULL) {
;;;711        ++len;
;;;712        p = p->next;
000006  6800              LDR      r0,[r0,#0]
000008  b2c9              UXTB     r1,r1                 ;711
                  |L5.10|
00000a  2800              CMP      r0,#0                 ;710
00000c  d1fa              BNE      |L5.4|
;;;713      }
;;;714      return len;
00000e  4608              MOV      r0,r1
;;;715    }
000010  4770              BX       lr
;;;716    
                          ENDP


                          AREA ||i.pbuf_coalesce||, CODE, READONLY, ALIGN=2

                  pbuf_coalesce PROC
;;;1010   struct pbuf*
;;;1011   pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
000000  b570              PUSH     {r4-r6,lr}
;;;1012   {
000002  4604              MOV      r4,r0
;;;1013     struct pbuf *q;
;;;1014     err_t err;
;;;1015     if (p->next == NULL) {
000004  6800              LDR      r0,[r0,#0]
000006  460b              MOV      r3,r1                 ;1012
000008  b190              CBZ      r0,|L6.48|
;;;1016       return p;
;;;1017     }
;;;1018     q = pbuf_alloc(layer, p->tot_len, PBUF_RAM);
00000a  8921              LDRH     r1,[r4,#8]
00000c  2200              MOVS     r2,#0
00000e  4618              MOV      r0,r3
000010  f7fffffe          BL       pbuf_alloc
000014  0005              MOVS     r5,r0
;;;1019     if (q == NULL) {
000016  d00b              BEQ      |L6.48|
;;;1020       /* @todo: what do we do now? */
;;;1021       return p;
;;;1022     }
;;;1023     err = pbuf_copy(q, p);
000018  4621              MOV      r1,r4
00001a  f7fffffe          BL       pbuf_copy
;;;1024     LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
00001e  b110              CBZ      r0,|L6.38|
000020  a004              ADR      r0,|L6.52|
000022  f7fffffe          BL       __2printf
                  |L6.38|
;;;1025     pbuf_free(p);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       pbuf_free
;;;1026     return q;
00002c  4628              MOV      r0,r5
;;;1027   }
00002e  bd70              POP      {r4-r6,pc}
                  |L6.48|
000030  4620              MOV      r0,r4                 ;1021
000032  bd70              POP      {r4-r6,pc}
;;;1028   
                          ENDP

                  |L6.52|
000034  70627566          DCB      "pbuf_copy failed",0
000038  5f636f70
00003c  79206661
000040  696c6564
000044  00      
000045  00                DCB      0
000046  00                DCB      0
000047  00                DCB      0

                          AREA ||i.pbuf_copy||, CODE, READONLY, ALIGN=2

                  pbuf_copy PROC
;;;852    err_t
;;;853    pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;854    {
;;;855      u16_t offset_to=0, offset_from=0, len;
000004  f04f0700          MOV      r7,#0
000008  460c              MOV      r4,r1                 ;854
00000a  0005              MOVS     r5,r0                 ;854
00000c  463e              MOV      r6,r7
;;;856    
;;;857      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
;;;858        (void*)p_to, (void*)p_from));
;;;859    
;;;860      /* is the target big enough to hold the source? */
;;;861      LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
00000e  f06f090d          MVN      r9,#0xd
000012  d004              BEQ      |L7.30|
000014  b11c              CBZ      r4,|L7.30|
000016  8928              LDRH     r0,[r5,#8]
000018  8921              LDRH     r1,[r4,#8]
00001a  4288              CMP      r0,r1
00001c  d201              BCS      |L7.34|
                  |L7.30|
00001e  a028              ADR      r0,|L7.192|
000020  e039              B        |L7.150|
                  |L7.34|
;;;862                 (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);
;;;863    
;;;864      /* iterate through pbuf chain */
;;;865      do
;;;866      {
;;;867        /* copy one part of the original chain */
;;;868        if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
;;;869          /* complete current p_from fits into current p_to */
;;;870          len = p_from->len - offset_from;
;;;871        } else {
;;;872          /* current p_from does not fit into current p_to */
;;;873          len = p_to->len - offset_to;
;;;874        }
;;;875        MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
;;;876        offset_to += len;
;;;877        offset_from += len;
;;;878        LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
;;;879        LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
;;;880        if (offset_from >= p_from->len) {
;;;881          /* on to next p_from (if any) */
;;;882          offset_from = 0;
;;;883          p_from = p_from->next;
;;;884        }
;;;885        if (offset_to == p_to->len) {
;;;886          /* on to next p_to (if any) */
;;;887          offset_to = 0;
;;;888          p_to = p_to->next;
;;;889          LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
;;;890        }
;;;891    
;;;892        if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
;;;893          /* don't copy more than one packet! */
;;;894          LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
000022  f06f0a05          MVN      r10,#5
                  |L7.38|
000026  8968              LDRH     r0,[r5,#0xa]          ;868
000028  8961              LDRH     r1,[r4,#0xa]          ;868
00002a  1bc0              SUBS     r0,r0,r7              ;868
00002c  1b89              SUBS     r1,r1,r6              ;868
00002e  4288              CMP      r0,r1                 ;868
000030  db01              BLT      |L7.54|
000032  b288              UXTH     r0,r1                 ;870
000034  e000              B        |L7.56|
                  |L7.54|
000036  b280              UXTH     r0,r0                 ;873
                  |L7.56|
000038  4680              MOV      r8,r0                 ;873
00003a  6860              LDR      r0,[r4,#4]            ;875
00003c  4642              MOV      r2,r8                 ;875
00003e  1981              ADDS     r1,r0,r6              ;875
000040  6868              LDR      r0,[r5,#4]            ;875
000042  4438              ADD      r0,r0,r7              ;875
000044  f7fffffe          BL       __aeabi_memcpy
000048  eb070008          ADD      r0,r7,r8              ;876
00004c  b287              UXTH     r7,r0                 ;876
00004e  eb060008          ADD      r0,r6,r8              ;877
000052  b286              UXTH     r6,r0                 ;877
000054  8968              LDRH     r0,[r5,#0xa]          ;878
000056  42b8              CMP      r0,r7                 ;878
000058  d202              BCS      |L7.96|
00005a  a025              ADR      r0,|L7.240|
00005c  f7fffffe          BL       __2printf
                  |L7.96|
000060  8960              LDRH     r0,[r4,#0xa]          ;879
000062  42b0              CMP      r0,r6                 ;879
000064  d202              BCS      |L7.108|
000066  a028              ADR      r0,|L7.264|
000068  f7fffffe          BL       __2printf
                  |L7.108|
00006c  8960              LDRH     r0,[r4,#0xa]          ;880
00006e  42b0              CMP      r0,r6                 ;880
000070  d801              BHI      |L7.118|
000072  6824              LDR      r4,[r4,#0]            ;883
000074  2600              MOVS     r6,#0                 ;882
                  |L7.118|
000076  8968              LDRH     r0,[r5,#0xa]          ;885
000078  42b8              CMP      r0,r7                 ;885
00007a  d102              BNE      |L7.130|
00007c  682d              LDR      r5,[r5,#0]            ;888
00007e  2700              MOVS     r7,#0                 ;887
000080  b13d              CBZ      r5,|L7.146|
                  |L7.130|
000082  b16c              CBZ      r4,|L7.160|
000084  8960              LDRH     r0,[r4,#0xa]          ;892
000086  8921              LDRH     r1,[r4,#8]            ;892
000088  4288              CMP      r0,r1                 ;892
00008a  d109              BNE      |L7.160|
00008c  6820              LDR      r0,[r4,#0]
00008e  b970              CBNZ     r0,|L7.174|
000090  e006              B        |L7.160|
                  |L7.146|
000092  b19c              CBZ      r4,|L7.188|
000094  a023              ADR      r0,|L7.292|
                  |L7.150|
000096  f7fffffe          BL       __2printf
00009a  4648              MOV      r0,r9                 ;889
                  |L7.156|
;;;895                     (p_from->next == NULL), return ERR_VAL;);
;;;896        }
;;;897        if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
;;;898          /* don't copy more than one packet! */
;;;899          LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
;;;900                      (p_to->next == NULL), return ERR_VAL;);
;;;901        }
;;;902      } while (p_from);
;;;903      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
;;;904      return ERR_OK;
;;;905    }
00009c  e8bd87f0          POP      {r4-r10,pc}
                  |L7.160|
0000a0  b155              CBZ      r5,|L7.184|
0000a2  8968              LDRH     r0,[r5,#0xa]          ;897
0000a4  8929              LDRH     r1,[r5,#8]            ;897
0000a6  4288              CMP      r0,r1                 ;897
0000a8  d106              BNE      |L7.184|
0000aa  6828              LDR      r0,[r5,#0]            ;899
0000ac  b120              CBZ      r0,|L7.184|
                  |L7.174|
0000ae  a021              ADR      r0,|L7.308|
0000b0  f7fffffe          BL       __2printf
0000b4  4650              MOV      r0,r10                ;899
0000b6  e7f1              B        |L7.156|
                  |L7.184|
0000b8  2c00              CMP      r4,#0                 ;902
0000ba  d1b4              BNE      |L7.38|
                  |L7.188|
0000bc  2000              MOVS     r0,#0                 ;904
0000be  e7ed              B        |L7.156|
;;;906    
                          ENDP

                  |L7.192|
0000c0  70627566          DCB      "pbuf_copy: target not big enough to hold source",0
0000c4  5f636f70
0000c8  793a2074
0000cc  61726765
0000d0  74206e6f
0000d4  74206269
0000d8  6720656e
0000dc  6f756768
0000e0  20746f20
0000e4  686f6c64
0000e8  20736f75
0000ec  72636500
                  |L7.240|
0000f0  6f666673          DCB      "offset_to <= p_to->len",0
0000f4  65745f74
0000f8  6f203c3d
0000fc  20705f74
000100  6f2d3e6c
000104  656e00  
000107  00                DCB      0
                  |L7.264|
000108  6f666673          DCB      "offset_from <= p_from->len",0
00010c  65745f66
000110  726f6d20
000114  3c3d2070
000118  5f66726f
00011c  6d2d3e6c
000120  656e00  
000123  00                DCB      0
                  |L7.292|
000124  705f746f          DCB      "p_to != NULL",0
000128  20213d20
00012c  4e554c4c
000130  00      
000131  00                DCB      0
000132  00                DCB      0
000133  00                DCB      0
                  |L7.308|
000134  70627566          DCB      "pbuf_copy() does not allow packet queues!\n",0
000138  5f636f70
00013c  79282920
000140  646f6573
000144  206e6f74
000148  20616c6c
00014c  6f772070
000150  61636b65
000154  74207175
000158  65756573
00015c  210a00  
00015f  00                DCB      0

                          AREA ||i.pbuf_copy_partial||, CODE, READONLY, ALIGN=2

                  pbuf_copy_partial PROC
;;;918    u16_t
;;;919    pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;920    {
000004  4616              MOV      r6,r2
000006  4689              MOV      r9,r1
;;;921      struct pbuf *p;
;;;922      u16_t left;
;;;923      u16_t buf_copy_len;
;;;924      u16_t copied_total = 0;
000008  f04f0800          MOV      r8,#0
00000c  b128              CBZ      r0,|L8.26|
;;;925    
;;;926      LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
;;;927      LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
00000e  f1b90f00          CMP      r9,#0
000012  d004              BEQ      |L8.30|
;;;928    
;;;929      left = 0;
000014  2700              MOVS     r7,#0
;;;930    
;;;931      if((buf == NULL) || (dataptr == NULL)) {
;;;932        return 0;
;;;933      }
;;;934    
;;;935      /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
;;;936      for(p = buf; len != 0 && p != NULL; p = p->next) {
000016  4604              MOV      r4,r0
000018  e025              B        |L8.102|
                  |L8.26|
00001a  a015              ADR      r0,|L8.112|
00001c  e000              B        |L8.32|
                  |L8.30|
00001e  a01c              ADR      r0,|L8.144|
                  |L8.32|
000020  f7fffffe          BL       __2printf
000024  2000              MOVS     r0,#0                 ;927
                  |L8.38|
;;;937        if ((offset != 0) && (offset >= p->len)) {
;;;938          /* don't copy from this buffer -> on to the next */
;;;939          offset -= p->len;
;;;940        } else {
;;;941          /* copy from this buffer. maybe only partially. */
;;;942          buf_copy_len = p->len - offset;
;;;943          if (buf_copy_len > len)
;;;944              buf_copy_len = len;
;;;945          /* copy the necessary parts of the buffer */
;;;946          MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
;;;947          copied_total += buf_copy_len;
;;;948          left += buf_copy_len;
;;;949          len -= buf_copy_len;
;;;950          offset = 0;
;;;951        }
;;;952      }
;;;953      return copied_total;
;;;954    }
000026  e8bd87f0          POP      {r4-r10,pc}
                  |L8.42|
00002a  b12b              CBZ      r3,|L8.56|
00002c  8960              LDRH     r0,[r4,#0xa]          ;937
00002e  4298              CMP      r0,r3                 ;937
000030  d802              BHI      |L8.56|
000032  1a18              SUBS     r0,r3,r0              ;939
000034  b283              UXTH     r3,r0                 ;939
000036  e015              B        |L8.100|
                  |L8.56|
000038  8960              LDRH     r0,[r4,#0xa]          ;942
00003a  1ac0              SUBS     r0,r0,r3              ;942
00003c  b285              UXTH     r5,r0                 ;942
00003e  42b5              CMP      r5,r6                 ;943
000040  d900              BLS      |L8.68|
000042  4635              MOV      r5,r6                 ;944
                  |L8.68|
000044  6860              LDR      r0,[r4,#4]            ;946
000046  462a              MOV      r2,r5                 ;946
000048  18c1              ADDS     r1,r0,r3              ;946
00004a  eb090007          ADD      r0,r9,r7              ;946
00004e  f7fffffe          BL       __aeabi_memcpy
000052  eb080005          ADD      r0,r8,r5              ;947
000056  fa1ff880          UXTH     r8,r0                 ;947
00005a  1978              ADDS     r0,r7,r5              ;948
00005c  b287              UXTH     r7,r0                 ;948
00005e  1b70              SUBS     r0,r6,r5              ;949
000060  b286              UXTH     r6,r0                 ;949
000062  2300              MOVS     r3,#0                 ;950
                  |L8.100|
000064  6824              LDR      r4,[r4,#0]            ;936
                  |L8.102|
000066  b10e              CBZ      r6,|L8.108|
000068  2c00              CMP      r4,#0                 ;936
00006a  d1de              BNE      |L8.42|
                  |L8.108|
00006c  4640              MOV      r0,r8                 ;953
00006e  e7da              B        |L8.38|
;;;955    
                          ENDP

                  |L8.112|
000070  70627566          DCB      "pbuf_copy_partial: invalid buf",0
000074  5f636f70
000078  795f7061
00007c  72746961
000080  6c3a2069
000084  6e76616c
000088  69642062
00008c  756600  
00008f  00                DCB      0
                  |L8.144|
000090  70627566          DCB      "pbuf_copy_partial: invalid dataptr",0
000094  5f636f70
000098  795f7061
00009c  72746961
0000a0  6c3a2069
0000a4  6e76616c
0000a8  69642064
0000ac  61746170
0000b0  747200  
0000b3  00                DCB      0

                          AREA ||i.pbuf_dechain||, CODE, READONLY, ALIGN=2

                  pbuf_dechain PROC
;;;803    struct pbuf *
;;;804    pbuf_dechain(struct pbuf *p)
000000  b570              PUSH     {r4-r6,lr}
;;;805    {
000002  6805              LDR      r5,[r0,#0]
000004  4604              MOV      r4,r0
;;;806      struct pbuf *q;
;;;807      u8_t tail_gone = 1;
000006  2601              MOVS     r6,#1
000008  b1a5              CBZ      r5,|L9.52|
;;;808      /* tail */
;;;809      q = p->next;
;;;810      /* pbuf has successor in chain? */
;;;811      if (q != NULL) {
;;;812        /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
;;;813        LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
00000a  8920              LDRH     r0,[r4,#8]
00000c  8961              LDRH     r1,[r4,#0xa]
00000e  1a40              SUBS     r0,r0,r1
000010  8929              LDRH     r1,[r5,#8]
000012  4288              CMP      r0,r1
000014  d002              BEQ      |L9.28|
000016  a00d              ADR      r0,|L9.76|
000018  f7fffffe          BL       __2printf
                  |L9.28|
;;;814        /* enforce invariant if assertion is disabled */
;;;815        q->tot_len = p->tot_len - p->len;
00001c  8920              LDRH     r0,[r4,#8]
00001e  8961              LDRH     r1,[r4,#0xa]
000020  1a40              SUBS     r0,r0,r1
000022  8128              STRH     r0,[r5,#8]
;;;816        /* decouple pbuf from remainder */
;;;817        p->next = NULL;
000024  2000              MOVS     r0,#0
;;;818        /* total length of pbuf p is its own length only */
;;;819        p->tot_len = p->len;
000026  6020              STR      r0,[r4,#0]
000028  8960              LDRH     r0,[r4,#0xa]
00002a  8120              STRH     r0,[r4,#8]
;;;820        /* q is no longer referenced by p, free it */
;;;821        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
;;;822        tail_gone = pbuf_free(q);
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       pbuf_free
000032  4606              MOV      r6,r0
                  |L9.52|
;;;823        if (tail_gone > 0) {
;;;824          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE,
;;;825                      ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
;;;826        }
;;;827        /* return remaining tail or NULL if deallocated */
;;;828      }
;;;829      /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
;;;830      LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
000034  8920              LDRH     r0,[r4,#8]
000036  8961              LDRH     r1,[r4,#0xa]
000038  4288              CMP      r0,r1
00003a  d002              BEQ      |L9.66|
00003c  a00c              ADR      r0,|L9.112|
00003e  f7fffffe          BL       __2printf
                  |L9.66|
;;;831      return ((tail_gone > 0) ? NULL : q);
000042  b10e              CBZ      r6,|L9.72|
000044  2000              MOVS     r0,#0
;;;832    }
000046  bd70              POP      {r4-r6,pc}
                  |L9.72|
000048  4628              MOV      r0,r5                 ;831
00004a  bd70              POP      {r4-r6,pc}
;;;833    
                          ENDP

                  |L9.76|
00004c  702d3e74          DCB      "p->tot_len == p->len + q->tot_len",0
000050  6f745f6c
000054  656e203d
000058  3d20702d
00005c  3e6c656e
000060  202b2071
000064  2d3e746f
000068  745f6c65
00006c  6e00    
00006e  00                DCB      0
00006f  00                DCB      0
                  |L9.112|
000070  702d3e74          DCB      "p->tot_len == p->len",0
000074  6f745f6c
000078  656e203d
00007c  3d20702d
000080  3e6c656e
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0

                          AREA ||i.pbuf_free||, CODE, READONLY, ALIGN=2

                  pbuf_free PROC
;;;618    u8_t
;;;619    pbuf_free(struct pbuf *p)
000000  b570              PUSH     {r4-r6,lr}
;;;620    {
000002  0004              MOVS     r4,r0
000004  d00e              BEQ      |L10.36|
;;;621      u16_t type;
;;;622      struct pbuf *q;
;;;623      u8_t count;
;;;624    
;;;625      if (p == NULL) {
;;;626        LWIP_ASSERT("p != NULL", p != NULL);
;;;627        /* if assertions are disabled, proceed with debug output */
;;;628        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;629          ("pbuf_free(p == NULL) was called.\n"));
;;;630        return 0;
;;;631      }
;;;632      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));
;;;633    
;;;634      PERF_START;
;;;635    
;;;636      LWIP_ASSERT("pbuf_free: sane type",
000006  7b20              LDRB     r0,[r4,#0xc]
000008  b140              CBZ      r0,|L10.28|
00000a  2801              CMP      r0,#1
00000c  d006              BEQ      |L10.28|
00000e  2802              CMP      r0,#2
000010  d004              BEQ      |L10.28|
000012  2803              CMP      r0,#3
000014  d002              BEQ      |L10.28|
000016  a01d              ADR      r0,|L10.140|
000018  f7fffffe          BL       __2printf
                  |L10.28|
;;;637        p->type == PBUF_RAM || p->type == PBUF_ROM ||
;;;638        p->type == PBUF_REF || p->type == PBUF_POOL);
;;;639    
;;;640      count = 0;
00001c  2500              MOVS     r5,#0
                  |L10.30|
;;;641      /* de-allocate all consecutive pbufs from the head of the chain that
;;;642       * obtain a zero reference count after decrementing*/
;;;643      while (p != NULL) {
;;;644        u16_t ref;
;;;645        SYS_ARCH_DECL_PROTECT(old_level);
;;;646        /* Since decrementing ref cannot be guaranteed to be a single machine operation
;;;647         * we must protect it. We put the new ref into a local variable to prevent
;;;648         * further protection. */
;;;649        SYS_ARCH_PROTECT(old_level);
;;;650        /* all pbufs in a chain are referenced at least once */
;;;651        LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
00001e  89e0              LDRH     r0,[r4,#0xe]
000020  b128              CBZ      r0,|L10.46|
000022  e007              B        |L10.52|
                  |L10.36|
000024  a01f              ADR      r0,|L10.164|
000026  f7fffffe          BL       __2printf
00002a  2000              MOVS     r0,#0                 ;630
;;;652        /* decrease reference count (number of pointers to pbuf) */
;;;653        ref = --(p->ref);
;;;654        SYS_ARCH_UNPROTECT(old_level);
;;;655        /* this pbuf is no longer referenced to? */
;;;656        if (ref == 0) {
;;;657          /* remember next pbuf in chain for next iteration */
;;;658          q = p->next;
;;;659          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
;;;660          type = p->type;
;;;661    #if LWIP_SUPPORT_CUSTOM_PBUF
;;;662          /* is this a custom pbuf? */
;;;663          if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
;;;664            struct pbuf_custom *pc = (struct pbuf_custom*)p;
;;;665            LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
;;;666            pc->custom_free_function(p);
;;;667          } else
;;;668    #endif /* LWIP_SUPPORT_CUSTOM_PBUF */
;;;669          {
;;;670            /* is this a pbuf from the pool? */
;;;671            if (type == PBUF_POOL) {
;;;672              memp_free(MEMP_PBUF_POOL, p);
;;;673            /* is this a ROM or RAM referencing pbuf? */
;;;674            } else if (type == PBUF_ROM || type == PBUF_REF) {
;;;675              memp_free(MEMP_PBUF, p);
;;;676            /* type == PBUF_RAM */
;;;677            } else {
;;;678              mem_free(p);
;;;679            }
;;;680          }
;;;681          count++;
;;;682          /* proceed to next pbuf */
;;;683          p = q;
;;;684        /* p->ref > 0, this pbuf is still referenced to */
;;;685        /* (and so the remaining pbufs in chain as well) */
;;;686        } else {
;;;687          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
;;;688          /* stop walking through the chain */
;;;689          p = NULL;
;;;690        }
;;;691      }
;;;692      PERF_STOP("pbuf_free");
;;;693      /* return number of de-allocated pbufs */
;;;694      return count;
;;;695    }
00002c  bd70              POP      {r4-r6,pc}
                  |L10.46|
00002e  a020              ADR      r0,|L10.176|
000030  f7fffffe          BL       __2printf
                  |L10.52|
000034  89e0              LDRH     r0,[r4,#0xe]          ;653
000036  1e40              SUBS     r0,r0,#1              ;653
000038  0400              LSLS     r0,r0,#16             ;653
00003a  0c00              LSRS     r0,r0,#16             ;653
00003c  81e0              STRH     r0,[r4,#0xe]          ;653
00003e  d11a              BNE      |L10.118|
000040  7b61              LDRB     r1,[r4,#0xd]          ;663
000042  7b20              LDRB     r0,[r4,#0xc]          ;660
000044  6826              LDR      r6,[r4,#0]            ;663
000046  0789              LSLS     r1,r1,#30             ;663
000048  d508              BPL      |L10.92|
00004a  6920              LDR      r0,[r4,#0x10]         ;665
00004c  b910              CBNZ     r0,|L10.84|
00004e  a01e              ADR      r0,|L10.200|
000050  f7fffffe          BL       __2printf
                  |L10.84|
000054  6921              LDR      r1,[r4,#0x10]         ;666
000056  4620              MOV      r0,r4                 ;666
000058  4788              BLX      r1                    ;666
00005a  e008              B        |L10.110|
                  |L10.92|
00005c  2803              CMP      r0,#3                 ;671
00005e  d00c              BEQ      |L10.122|
000060  2801              CMP      r0,#1                 ;674
000062  d00d              BEQ      |L10.128|
000064  2802              CMP      r0,#2                 ;674
000066  d00b              BEQ      |L10.128|
000068  4620              MOV      r0,r4                 ;678
00006a  f7fffffe          BL       mem_free
                  |L10.110|
00006e  1c6d              ADDS     r5,r5,#1              ;678
000070  b2ed              UXTB     r5,r5                 ;681
000072  0034              MOVS     r4,r6                 ;683
000074  d1d3              BNE      |L10.30|
                  |L10.118|
000076  4628              MOV      r0,r5                 ;694
000078  bd70              POP      {r4-r6,pc}
                  |L10.122|
00007a  4621              MOV      r1,r4                 ;672
00007c  2008              MOVS     r0,#8                 ;672
00007e  e001              B        |L10.132|
                  |L10.128|
000080  4621              MOV      r1,r4                 ;675
000082  2007              MOVS     r0,#7                 ;675
                  |L10.132|
000084  f7fffffe          BL       memp_free
000088  e7f1              B        |L10.110|
;;;696    
                          ENDP

00008a  0000              DCW      0x0000
                  |L10.140|
00008c  70627566          DCB      "pbuf_free: sane type",0
000090  5f667265
000094  653a2073
000098  616e6520
00009c  74797065
0000a0  00      
0000a1  00                DCB      0
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L10.164|
0000a4  7020213d          DCB      "p != NULL",0
0000a8  204e554c
0000ac  4c00    
0000ae  00                DCB      0
0000af  00                DCB      0
                  |L10.176|
0000b0  70627566          DCB      "pbuf_free: p->ref > 0",0
0000b4  5f667265
0000b8  653a2070
0000bc  2d3e7265
0000c0  66203e20
0000c4  3000    
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L10.200|
0000c8  70632d3e          DCB      "pc->custom_free_function != NULL",0
0000cc  63757374
0000d0  6f6d5f66
0000d4  7265655f
0000d8  66756e63
0000dc  74696f6e
0000e0  20213d20
0000e4  4e554c4c
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0

                          AREA ||i.pbuf_free_ooseq||, CODE, READONLY, ALIGN=2

                  pbuf_free_ooseq PROC
;;;117    void
;;;118    pbuf_free_ooseq(void)
000000  b570              PUSH     {r4-r6,lr}
;;;119    {
;;;120      struct tcp_pcb* pcb;
;;;121      SYS_ARCH_DECL_PROTECT(old_level);
;;;122    
;;;123      SYS_ARCH_PROTECT(old_level);
;;;124      pbuf_free_ooseq_pending = 0;
000002  4808              LDR      r0,|L11.36|
000004  2500              MOVS     r5,#0
000006  7005              STRB     r5,[r0,#0]
;;;125      SYS_ARCH_UNPROTECT(old_level);
;;;126    
;;;127      for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
000008  4807              LDR      r0,|L11.40|
00000a  6804              LDR      r4,[r0,#0]            ;119  ; tcp_active_pcbs
00000c  e006              B        |L11.28|
                  |L11.14|
;;;128        if (NULL != pcb->ooseq) {
00000e  6f60              LDR      r0,[r4,#0x74]
000010  b118              CBZ      r0,|L11.26|
;;;129          /** Free the ooseq pbufs of one PCB only */
;;;130          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n"));
;;;131          tcp_segs_free(pcb->ooseq);
000012  f7fffffe          BL       tcp_segs_free
;;;132    	  TCP_DEBUG_USART_PRINTF_S(" tcp_segs_free(pcb->ooseq);\n");
;;;133          pcb->ooseq = NULL;
;;;134          return;
000016  6765              STR      r5,[r4,#0x74]
;;;135        }
;;;136      }
;;;137    }
000018  bd70              POP      {r4-r6,pc}
                  |L11.26|
00001a  68e4              LDR      r4,[r4,#0xc]          ;127
                  |L11.28|
00001c  2c00              CMP      r4,#0                 ;127
00001e  d1f6              BNE      |L11.14|
000020  bd70              POP      {r4-r6,pc}
;;;138    
                          ENDP

000022  0000              DCW      0x0000
                  |L11.36|
                          DCD      ||.data||
                  |L11.40|
                          DCD      tcp_active_pcbs

                          AREA ||i.pbuf_get_at||, CODE, READONLY, ALIGN=1

                  pbuf_get_at PROC
;;;1077   u8_t
;;;1078   pbuf_get_at(struct pbuf* p, u16_t offset)
000000  e002              B        |L12.8|
                  |L12.2|
;;;1079   {
;;;1080     u16_t copy_from = offset;
;;;1081     struct pbuf* q = p;
;;;1082   
;;;1083     /* get the correct pbuf */
;;;1084     while ((q != NULL) && (q->len <= copy_from)) {
;;;1085       copy_from -= q->len;
000002  1a89              SUBS     r1,r1,r2
;;;1086       q = q->next;
000004  6800              LDR      r0,[r0,#0]
000006  b289              UXTH     r1,r1                 ;1085
                  |L12.8|
000008  2800              CMP      r0,#0                 ;1084
00000a  d004              BEQ      |L12.22|
00000c  8942              LDRH     r2,[r0,#0xa]          ;1084
00000e  428a              CMP      r2,r1                 ;1084
000010  d9f7              BLS      |L12.2|
;;;1087     }
;;;1088     /* return requested data if pbuf is OK */
;;;1089     if ((q != NULL) && (q->len > copy_from)) {
;;;1090       return ((u8_t*)q->payload)[copy_from];
000012  6840              LDR      r0,[r0,#4]
000014  5c40              LDRB     r0,[r0,r1]
                  |L12.22|
;;;1091     }
;;;1092     return 0;
;;;1093   }
000016  4770              BX       lr
;;;1094   
                          ENDP


                          AREA ||i.pbuf_header||, CODE, READONLY, ALIGN=2

                  pbuf_header PROC
;;;511    u8_t
;;;512    pbuf_header(struct pbuf *p, s16_t header_size_increment)
000000  b570              PUSH     {r4-r6,lr}
;;;513    {
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d102              BNE      |L13.14|
;;;514      u16_t type;
;;;515      void *payload;
;;;516      u16_t increment_magnitude;
;;;517    
;;;518      LWIP_ASSERT("p != NULL", p != NULL);
000008  a01a              ADR      r0,|L13.116|
00000a  f7fffffe          BL       __2printf
                  |L13.14|
;;;519      if ((header_size_increment == 0) || (p == NULL)) {
00000e  b14d              CBZ      r5,|L13.36|
000010  b144              CBZ      r4,|L13.36|
;;;520        return 0;
;;;521      }
;;;522     
;;;523      if (header_size_increment < 0){
000012  2d00              CMP      r5,#0
000014  da08              BGE      |L13.40|
;;;524        increment_magnitude = -header_size_increment;
000016  4268              RSBS     r0,r5,#0
000018  b281              UXTH     r1,r0
;;;525        /* Check that we aren't going to move off the end of the pbuf */
;;;526        LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
00001a  8960              LDRH     r0,[r4,#0xa]
00001c  4288              CMP      r0,r1
00001e  d204              BCS      |L13.42|
000020  a017              ADR      r0,|L13.128|
000022  e00c              B        |L13.62|
                  |L13.36|
000024  2000              MOVS     r0,#0                 ;520
;;;527      } else {
;;;528        increment_magnitude = header_size_increment;
;;;529    #if 0
;;;530        /* Can't assert these as some callers speculatively call
;;;531             pbuf_header() to see if it's OK.  Will return 1 below instead. */
;;;532        /* Check that we've got the correct type of pbuf to work with */
;;;533        LWIP_ASSERT("p->type == PBUF_RAM || p->type == PBUF_POOL", 
;;;534                    p->type == PBUF_RAM || p->type == PBUF_POOL);
;;;535        /* Check that we aren't going to move off the beginning of the pbuf */
;;;536        LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
;;;537                    (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
;;;538    #endif
;;;539      }
;;;540    
;;;541      type = p->type;
;;;542      /* remember current payload pointer */
;;;543      payload = p->payload;
;;;544    
;;;545      /* pbuf types containing payloads? */
;;;546      if (type == PBUF_RAM || type == PBUF_POOL) {
;;;547        /* set new payload pointer */
;;;548        p->payload = (u8_t *)p->payload - header_size_increment;
;;;549        /* boundary check fails? */
;;;550        if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
;;;551          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;552            ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
;;;553            (void *)p->payload, (void *)(p + 1)));
;;;554          /* restore old payload pointer */
;;;555          p->payload = payload;
;;;556          /* bail out unsuccesfully */
;;;557          return 1;
;;;558        }
;;;559      /* pbuf types refering to external payloads? */
;;;560      } else if (type == PBUF_REF || type == PBUF_ROM) {
;;;561        /* hide a header in the payload? */
;;;562        if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
;;;563          /* increase payload pointer */
;;;564          p->payload = (u8_t *)p->payload - header_size_increment;
;;;565        } else {
;;;566          /* cannot expand payload to front (yet!)
;;;567           * bail out unsuccesfully */
;;;568          return 1;
;;;569        }
;;;570      } else {
;;;571        /* Unknown type */
;;;572        LWIP_ASSERT("bad pbuf type", 0);
;;;573        return 1;
;;;574      }
;;;575      /* modify pbuf length fields */
;;;576      p->len += header_size_increment;
;;;577      p->tot_len += header_size_increment;
;;;578    
;;;579      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
;;;580        (void *)payload, (void *)p->payload, header_size_increment));
;;;581    
;;;582      return 0;
;;;583    }
000026  bd70              POP      {r4-r6,pc}
                  |L13.40|
000028  b2a9              UXTH     r1,r5                 ;528
                  |L13.42|
00002a  7b20              LDRB     r0,[r4,#0xc]          ;541
00002c  6862              LDR      r2,[r4,#4]            ;546
00002e  b148              CBZ      r0,|L13.68|
000030  2803              CMP      r0,#3                 ;546
000032  d007              BEQ      |L13.68|
000034  2802              CMP      r0,#2                 ;560
000036  d00d              BEQ      |L13.84|
000038  2801              CMP      r0,#1                 ;560
00003a  d00b              BEQ      |L13.84|
00003c  a018              ADR      r0,|L13.160|
                  |L13.62|
00003e  f7fffffe          BL       __2printf
000042  e015              B        |L13.112|
                  |L13.68|
000044  1b50              SUBS     r0,r2,r5              ;548
000046  f1040110          ADD      r1,r4,#0x10           ;550
00004a  6060              STR      r0,[r4,#4]            ;550
00004c  4288              CMP      r0,r1                 ;550
00004e  d208              BCS      |L13.98|
000050  6062              STR      r2,[r4,#4]            ;557
000052  e00d              B        |L13.112|
                  |L13.84|
000054  2d00              CMP      r5,#0                 ;562
000056  da0b              BGE      |L13.112|
000058  8960              LDRH     r0,[r4,#0xa]          ;562
00005a  4288              CMP      r0,r1                 ;562
00005c  d308              BCC      |L13.112|
00005e  1b50              SUBS     r0,r2,r5              ;564
000060  6060              STR      r0,[r4,#4]            ;564
                  |L13.98|
000062  8960              LDRH     r0,[r4,#0xa]          ;576
000064  4428              ADD      r0,r0,r5              ;576
000066  8160              STRH     r0,[r4,#0xa]          ;576
000068  8920              LDRH     r0,[r4,#8]            ;577
00006a  4428              ADD      r0,r0,r5              ;577
00006c  8120              STRH     r0,[r4,#8]            ;577
00006e  e7d9              B        |L13.36|
                  |L13.112|
000070  2001              MOVS     r0,#1                 ;568
000072  bd70              POP      {r4-r6,pc}
;;;584    
                          ENDP

                  |L13.116|
000074  7020213d          DCB      "p != NULL",0
000078  204e554c
00007c  4c00    
00007e  00                DCB      0
00007f  00                DCB      0
                  |L13.128|
000080  696e6372          DCB      "increment_magnitude <= p->len",0
000084  656d656e
000088  745f6d61
00008c  676e6974
000090  75646520
000094  3c3d2070
000098  2d3e6c65
00009c  6e00    
00009e  00                DCB      0
00009f  00                DCB      0
                  |L13.160|
0000a0  62616420          DCB      "bad pbuf type",0
0000a4  70627566
0000a8  20747970
0000ac  6500    
0000ae  00                DCB      0
0000af  00                DCB      0

                          AREA ||i.pbuf_memcmp||, CODE, READONLY, ALIGN=1

                  pbuf_memcmp PROC
;;;1104   u16_t
;;;1105   pbuf_memcmp(struct pbuf* p, u16_t offset, const void* s2, u16_t n)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1106   {
000002  4617              MOV      r7,r2
000004  460e              MOV      r6,r1
000006  4605              MOV      r5,r0
;;;1107     u16_t start = offset;
;;;1108     struct pbuf* q = p;
;;;1109   
;;;1110     /* get the correct pbuf */
;;;1111     while ((q != NULL) && (q->len <= start)) {
;;;1112       start -= q->len;
;;;1113       q = q->next;
000008  e002              B        |L14.16|
                  |L14.10|
00000a  1a30              SUBS     r0,r6,r0              ;1112
00000c  682d              LDR      r5,[r5,#0]
00000e  b286              UXTH     r6,r0                 ;1112
                  |L14.16|
000010  b1ad              CBZ      r5,|L14.62|
000012  8968              LDRH     r0,[r5,#0xa]          ;1111
000014  42b0              CMP      r0,r6                 ;1111
000016  d9f8              BLS      |L14.10|
;;;1114     }
;;;1115     /* return requested data if pbuf is OK */
;;;1116     if ((q != NULL) && (q->len > start)) {
;;;1117       u16_t i;
;;;1118       for(i = 0; i < n; i++) {
000018  2400              MOVS     r4,#0
00001a  e00c              B        |L14.54|
                  |L14.28|
;;;1119         u8_t a = pbuf_get_at(q, start + i);
00001c  1930              ADDS     r0,r6,r4
00001e  b281              UXTH     r1,r0
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       pbuf_get_at
;;;1120         u8_t b = ((u8_t*)s2)[i];
000026  5d39              LDRB     r1,[r7,r4]
;;;1121         if (a != b) {
000028  f1040401          ADD      r4,r4,#1
00002c  4288              CMP      r0,r1
00002e  d001              BEQ      |L14.52|
;;;1122           return i+1;
000030  b2a0              UXTH     r0,r4
;;;1123         }
;;;1124       }
;;;1125       return 0;
;;;1126     }
;;;1127     return 0xffff;
;;;1128   }
000032  bdf0              POP      {r4-r7,pc}
                  |L14.52|
000034  b2a4              UXTH     r4,r4                 ;1118
                  |L14.54|
000036  429c              CMP      r4,r3                 ;1118
000038  d3f0              BCC      |L14.28|
00003a  2000              MOVS     r0,#0                 ;1125
00003c  bdf0              POP      {r4-r7,pc}
                  |L14.62|
00003e  f64f70ff          MOV      r0,#0xffff            ;1127
000042  bdf0              POP      {r4-r7,pc}
;;;1129   
                          ENDP


                          AREA ||i.pbuf_memfind||, CODE, READONLY, ALIGN=1

                  pbuf_memfind PROC
;;;1140   u16_t
;;;1141   pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1142   {
000004  4607              MOV      r7,r0
;;;1143     u16_t i;
;;;1144     u16_t max = p->tot_len - mem_len;
000006  8900              LDRH     r0,[r0,#8]
000008  4616              MOV      r6,r2                 ;1142
00000a  4688              MOV      r8,r1                 ;1142
00000c  1b81              SUBS     r1,r0,r6
00000e  b28d              UXTH     r5,r1
;;;1145     if (p->tot_len >= mem_len + start_offset) {
000010  18d1              ADDS     r1,r2,r3
000012  4288              CMP      r0,r1
000014  d30c              BCC      |L15.48|
;;;1146       for(i = start_offset; i <= max; ) {
000016  461c              MOV      r4,r3
000018  e008              B        |L15.44|
                  |L15.26|
;;;1147         u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
00001a  4633              MOV      r3,r6
00001c  4642              MOV      r2,r8
00001e  4621              MOV      r1,r4
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       pbuf_memcmp
;;;1148         if (plus == 0) {
000026  b138              CBZ      r0,|L15.56|
;;;1149           return i;
;;;1150         } else {
;;;1151           i += plus;
000028  4420              ADD      r0,r0,r4
00002a  b284              UXTH     r4,r0
                  |L15.44|
00002c  42ac              CMP      r4,r5                 ;1146
00002e  d9f4              BLS      |L15.26|
                  |L15.48|
;;;1152         }
;;;1153       }
;;;1154     }
;;;1155     return 0xFFFF;
000030  f64f70ff          MOV      r0,#0xffff
                  |L15.52|
;;;1156   }
000034  e8bd81f0          POP      {r4-r8,pc}
                  |L15.56|
000038  4620              MOV      r0,r4                 ;1149
00003a  e7fb              B        |L15.52|
;;;1157   
                          ENDP


                          AREA ||i.pbuf_realloc||, CODE, READONLY, ALIGN=2

                  pbuf_realloc PROC
;;;430    void
;;;431    pbuf_realloc(struct pbuf *p, u16_t new_len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;432    {
000004  460d              MOV      r5,r1
000006  0004              MOVS     r4,r0
000008  d102              BNE      |L16.16|
;;;433      struct pbuf *q;
;;;434      u16_t rem_len; /* remaining length */
;;;435      s32_t grow;
;;;436    
;;;437      LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
00000a  a021              ADR      r0,|L16.144|
00000c  f7fffffe          BL       __2printf
                  |L16.16|
;;;438      LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
000010  7b20              LDRB     r0,[r4,#0xc]
000012  2803              CMP      r0,#3
000014  d007              BEQ      |L16.38|
000016  2801              CMP      r0,#1
000018  d005              BEQ      |L16.38|
00001a  b120              CBZ      r0,|L16.38|
00001c  2802              CMP      r0,#2
00001e  d002              BEQ      |L16.38|
000020  a021              ADR      r0,|L16.168|
000022  f7fffffe          BL       __2printf
                  |L16.38|
;;;439                  p->type == PBUF_ROM ||
;;;440                  p->type == PBUF_RAM ||
;;;441                  p->type == PBUF_REF);
;;;442    
;;;443      /* desired length larger than current length? */
;;;444      if (new_len >= p->tot_len) {
000026  8920              LDRH     r0,[r4,#8]
000028  42a8              CMP      r0,r5
00002a  d92e              BLS      |L16.138|
;;;445        /* enlarging not yet supported */
;;;446        return;
;;;447      }
;;;448    
;;;449      /* the pbuf chain grows by (new_len - p->tot_len) bytes
;;;450       * (which may be negative in case of shrinking) */
;;;451      grow = new_len - p->tot_len;
00002c  1a2e              SUBS     r6,r5,r0
;;;452    
;;;453      /* first, step over any pbufs that should remain in the chain */
;;;454      rem_len = new_len;
;;;455      q = p;
;;;456      /* should this pbuf be kept? */
;;;457      while (rem_len > q->len) {
;;;458        /* decrease remaining length by pbuf length */
;;;459        rem_len -= q->len;
;;;460        /* decrease total length indicator */
;;;461        LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
00002e  f64f77ff          MOV      r7,#0xffff
000032  e00e              B        |L16.82|
                  |L16.52|
000034  1a28              SUBS     r0,r5,r0              ;459
000036  b285              UXTH     r5,r0                 ;459
000038  42be              CMP      r6,r7
00003a  db02              BLT      |L16.66|
00003c  a021              ADR      r0,|L16.196|
00003e  f7fffffe          BL       __2printf
                  |L16.66|
;;;462        q->tot_len += (u16_t)grow;
000042  8920              LDRH     r0,[r4,#8]
000044  4430              ADD      r0,r0,r6
000046  8120              STRH     r0,[r4,#8]
;;;463        /* proceed to next pbuf in chain */
;;;464        q = q->next;
000048  6824              LDR      r4,[r4,#0]
;;;465        LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
00004a  b914              CBNZ     r4,|L16.82|
00004c  a022              ADR      r0,|L16.216|
00004e  f7fffffe          BL       __2printf
                  |L16.82|
000052  8960              LDRH     r0,[r4,#0xa]          ;457
000054  42a8              CMP      r0,r5                 ;457
000056  d3ed              BCC      |L16.52|
;;;466      }
;;;467      /* we have now reached the new last pbuf (in q) */
;;;468      /* rem_len == desired length for pbuf q */
;;;469    
;;;470      /* shrink allocated memory for PBUF_RAM */
;;;471      /* (other types merely adjust their length fields */
;;;472      if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
000058  7b20              LDRB     r0,[r4,#0xc]
00005a  b970              CBNZ     r0,|L16.122|
00005c  8960              LDRH     r0,[r4,#0xa]
00005e  42a8              CMP      r0,r5
000060  d00b              BEQ      |L16.122|
;;;473        /* reallocate and adjust the length of the pbuf that will be split */
;;;474        q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
000062  88a0              LDRH     r0,[r4,#4]
000064  1b00              SUBS     r0,r0,r4
000066  4428              ADD      r0,r0,r5
000068  b281              UXTH     r1,r0
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       mem_trim
000070  0004              MOVS     r4,r0
;;;475        LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
000072  d102              BNE      |L16.122|
000074  a01e              ADR      r0,|L16.240|
000076  f7fffffe          BL       __2printf
                  |L16.122|
;;;476      }
;;;477      /* adjust length fields for new last pbuf */
;;;478      q->len = rem_len;
00007a  8165              STRH     r5,[r4,#0xa]
;;;479      q->tot_len = q->len;
00007c  8125              STRH     r5,[r4,#8]
;;;480    
;;;481      /* any remaining pbufs in chain? */
;;;482      if (q->next != NULL) {
00007e  6820              LDR      r0,[r4,#0]
000080  b108              CBZ      r0,|L16.134|
;;;483        /* free remaining pbufs in chain */
;;;484        pbuf_free(q->next);
000082  f7fffffe          BL       pbuf_free
                  |L16.134|
;;;485      }
;;;486      /* q is last packet in chain */
;;;487      q->next = NULL;
000086  2000              MOVS     r0,#0
000088  6020              STR      r0,[r4,#0]
                  |L16.138|
;;;488    
;;;489    }
00008a  e8bd81f0          POP      {r4-r8,pc}
;;;490    
                          ENDP

00008e  0000              DCW      0x0000
                  |L16.144|
000090  70627566          DCB      "pbuf_realloc: p != NULL",0
000094  5f726561
000098  6c6c6f63
00009c  3a207020
0000a0  213d204e
0000a4  554c4c00
                  |L16.168|
0000a8  70627566          DCB      "pbuf_realloc: sane p->type",0
0000ac  5f726561
0000b0  6c6c6f63
0000b4  3a207361
0000b8  6e652070
0000bc  2d3e7479
0000c0  706500  
0000c3  00                DCB      0
                  |L16.196|
0000c4  67726f77          DCB      "grow < max_u16_t",0
0000c8  203c206d
0000cc  61785f75
0000d0  31365f74
0000d4  00      
0000d5  00                DCB      0
0000d6  00                DCB      0
0000d7  00                DCB      0
                  |L16.216|
0000d8  70627566          DCB      "pbuf_realloc: q != NULL",0
0000dc  5f726561
0000e0  6c6c6f63
0000e4  3a207120
0000e8  213d204e
0000ec  554c4c00
                  |L16.240|
0000f0  6d656d5f          DCB      "mem_trim returned q == NULL",0
0000f4  7472696d
0000f8  20726574
0000fc  75726e65
000100  64207120
000104  3d3d204e
000108  554c4c00

                          AREA ||i.pbuf_ref||, CODE, READONLY, ALIGN=1

                  pbuf_ref PROC
;;;723    void
;;;724    pbuf_ref(struct pbuf *p)
000000  2800              CMP      r0,#0
;;;725    {
000002  d002              BEQ      |L17.10|
;;;726      SYS_ARCH_DECL_PROTECT(old_level);
;;;727      /* pbuf given? */
;;;728      if (p != NULL) {
;;;729        SYS_ARCH_PROTECT(old_level);
;;;730        ++(p->ref);
000004  89c1              LDRH     r1,[r0,#0xe]
000006  1c49              ADDS     r1,r1,#1
000008  81c1              STRH     r1,[r0,#0xe]
                  |L17.10|
;;;731        SYS_ARCH_UNPROTECT(old_level);
;;;732      }
;;;733    }
00000a  4770              BX       lr
;;;734    
                          ENDP


                          AREA ||i.pbuf_strstr||, CODE, READONLY, ALIGN=1

                  pbuf_strstr PROC
;;;1168   u16_t
;;;1169   pbuf_strstr(struct pbuf* p, const char* substr)
000000  b570              PUSH     {r4-r6,lr}
;;;1170   {
000002  4605              MOV      r5,r0
000004  000c              MOVS     r4,r1
;;;1171     size_t substr_len;
;;;1172     if ((substr == NULL) || (substr[0] == 0) || (p->tot_len == 0xFFFF)) {
000006  f64f76ff          MOV      r6,#0xffff
00000a  d009              BEQ      |L18.32|
00000c  7820              LDRB     r0,[r4,#0]
00000e  b138              CBZ      r0,|L18.32|
000010  8928              LDRH     r0,[r5,#8]
000012  42b0              CMP      r0,r6
000014  d004              BEQ      |L18.32|
;;;1173       return 0xFFFF;
;;;1174     }
;;;1175     substr_len = strlen(substr);
000016  4608              MOV      r0,r1
000018  f7fffffe          BL       strlen
;;;1176     if (substr_len >= 0xFFFF) {
00001c  42b0              CMP      r0,r6
00001e  d301              BCC      |L18.36|
                  |L18.32|
;;;1177       return 0xFFFF;
000020  4630              MOV      r0,r6
;;;1178     }
;;;1179     return pbuf_memfind(p, substr, (u16_t)substr_len, 0);
;;;1180   }
000022  bd70              POP      {r4-r6,pc}
                  |L18.36|
000024  b282              UXTH     r2,r0                 ;1179
000026  4621              MOV      r1,r4                 ;1179
000028  4628              MOV      r0,r5                 ;1179
00002a  e8bd4070          POP      {r4-r6,lr}            ;1179
00002e  2300              MOVS     r3,#0                 ;1179
000030  f7ffbffe          B.W      pbuf_memfind
                          ENDP


                          AREA ||i.pbuf_take||, CODE, READONLY, ALIGN=2

                  pbuf_take PROC
;;;966    err_t
;;;967    pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;968    {
000004  4690              MOV      r8,r2
000006  4689              MOV      r9,r1
;;;969      struct pbuf *p;
;;;970      u16_t buf_copy_len;
;;;971      u16_t total_copy_len = len;
000008  4616              MOV      r6,r2
;;;972      u16_t copied_total = 0;
00000a  2700              MOVS     r7,#0
00000c  b148              CBZ      r0,|L19.34|
;;;973    
;;;974      LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
;;;975      LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return 0;);
00000e  f1b90f00          CMP      r9,#0
000012  d008              BEQ      |L19.38|
;;;976    
;;;977      if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
000014  8902              LDRH     r2,[r0,#8]
000016  42b2              CMP      r2,r6
000018  d209              BCS      |L19.46|
;;;978        return ERR_ARG;
00001a  f06f000d          MVN      r0,#0xd
                  |L19.30|
;;;979      }
;;;980    
;;;981      /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
;;;982      for(p = buf; total_copy_len != 0; p = p->next) {
;;;983        LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
;;;984        buf_copy_len = total_copy_len;
;;;985        if (buf_copy_len > p->len) {
;;;986          /* this pbuf cannot hold all remaining data */
;;;987          buf_copy_len = p->len;
;;;988        }
;;;989        /* copy the necessary parts of the buffer */
;;;990        MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
;;;991        total_copy_len -= buf_copy_len;
;;;992        copied_total += buf_copy_len;
;;;993      }
;;;994      LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
;;;995      return ERR_OK;
;;;996    }
00001e  e8bd87f0          POP      {r4-r10,pc}
                  |L19.34|
000022  a012              ADR      r0,|L19.108|
000024  e000              B        |L19.40|
                  |L19.38|
000026  a017              ADR      r0,|L19.132|
                  |L19.40|
000028  f7fffffe          BL       __2printf
00002c  e01b              B        |L19.102|
                  |L19.46|
00002e  4604              MOV      r4,r0                 ;982
000030  e013              B        |L19.90|
                  |L19.50|
000032  b914              CBNZ     r4,|L19.58|
000034  a01a              ADR      r0,|L19.160|
000036  f7fffffe          BL       __2printf
                  |L19.58|
00003a  8960              LDRH     r0,[r4,#0xa]          ;985
00003c  4635              MOV      r5,r6                 ;984
00003e  42a8              CMP      r0,r5                 ;985
000040  d200              BCS      |L19.68|
000042  4605              MOV      r5,r0                 ;987
                  |L19.68|
000044  eb090107          ADD      r1,r9,r7              ;990
000048  462a              MOV      r2,r5                 ;990
00004a  6860              LDR      r0,[r4,#4]            ;990
00004c  f7fffffe          BL       __aeabi_memcpy
000050  1b70              SUBS     r0,r6,r5              ;991
000052  b286              UXTH     r6,r0                 ;991
000054  1978              ADDS     r0,r7,r5              ;992
000056  6824              LDR      r4,[r4,#0]            ;982
000058  b287              UXTH     r7,r0                 ;992
                  |L19.90|
00005a  2e00              CMP      r6,#0                 ;982
00005c  d1e9              BNE      |L19.50|
00005e  4547              CMP      r7,r8                 ;994
000060  d001              BEQ      |L19.102|
000062  a015              ADR      r0,|L19.184|
000064  e7e0              B        |L19.40|
                  |L19.102|
000066  2000              MOVS     r0,#0                 ;995
000068  e7d9              B        |L19.30|
;;;997    
                          ENDP

00006a  0000              DCW      0x0000
                  |L19.108|
00006c  70627566          DCB      "pbuf_take: invalid buf",0
000070  5f74616b
000074  653a2069
000078  6e76616c
00007c  69642062
000080  756600  
000083  00                DCB      0
                  |L19.132|
000084  70627566          DCB      "pbuf_take: invalid dataptr",0
000088  5f74616b
00008c  653a2069
000090  6e76616c
000094  69642064
000098  61746170
00009c  747200  
00009f  00                DCB      0
                  |L19.160|
0000a0  70627566          DCB      "pbuf_take: invalid pbuf",0
0000a4  5f74616b
0000a8  653a2069
0000ac  6e76616c
0000b0  69642070
0000b4  62756600
                  |L19.184|
0000b8  64696420          DCB      "did not copy all data",0
0000bc  6e6f7420
0000c0  636f7079
0000c4  20616c6c
0000c8  20646174
0000cc  6100    
0000ce  00                DCB      0
0000cf  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=0

                  pbuf_free_ooseq_pending
000000  00                DCB      0x00

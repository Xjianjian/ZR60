; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\time_stamp.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\time_stamp.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\ZR60_v1.0_freeRTOS -I..\..\Lwip\App -I..\..\Lwip\Bsp -I..\..\Lwip\Bsp\LAN8742A -I..\..\Lwip\lwip-1.4.1 -I..\..\Lwip\lwip-1.4.1\port -I..\..\Lwip\lwip-1.4.1\port\arch -I..\..\Lwip\lwip-1.4.1\port\Standalone -I..\..\Lwip\lwip-1.4.1\src\include -I..\..\Lwip\lwip-1.4.1\src\include\ipv4 -I..\..\Lwip\lwip-1.4.1\src\include\lwip -I..\..\Lwip\lwip-1.4.1\src\include\netif -I..\..\Ecal\BtnFltr -I..\..\Ecal\UartComn -I..\..\Ecal\MemIf -I..\..\APP -I..\..\APP\BlackListMng -I..\..\APP\SeverNewsPush -I..\..\APP\NewsPull -I..\..\Ecal -I..\..\Ecal\JsonIf -I..\..\Ecal\Mcu_Init -I..\..\Service -I..\..\Complex -I..\..\Complex\FATFS -I..\..\FreeRTOS\Source\include -I..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\FreeRTOS -I.\RTE\_ZR60 -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=..\..\output\time_stamp.crf ..\..\Complex\timeStamp\time_stamp.c]
                          THUMB

                          AREA ||i.GetTick||, CODE, READONLY, ALIGN=1

                  GetTick PROC
;;;31     */
;;;32     uint32_t GetTick(struct rtc_time *tm)  
000000  b500              PUSH     {lr}
;;;33     {  
;;;34         struct tm stm;  
;;;35     
;;;36         stm.tm_year = tm->tm_year - 1900;  
000002  6941              LDR      r1,[r0,#0x14]
000004  b08b              SUB      sp,sp,#0x2c           ;33
000006  f2a1716c          SUB      r1,r1,#0x76c
;;;37         stm.tm_mon = tm->tm_mon - 1;  
00000a  9105              STR      r1,[sp,#0x14]
00000c  6901              LDR      r1,[r0,#0x10]
00000e  1e49              SUBS     r1,r1,#1
;;;38         stm.tm_mday = tm->tm_mday;  
000010  9104              STR      r1,[sp,#0x10]
000012  68c1              LDR      r1,[r0,#0xc]
;;;39         stm.tm_hour = tm->tm_hour - 8;  
000014  9103              STR      r1,[sp,#0xc]
000016  6881              LDR      r1,[r0,#8]
000018  3908              SUBS     r1,r1,#8
;;;40         stm.tm_min = tm->tm_min;  
00001a  9102              STR      r1,[sp,#8]
00001c  6841              LDR      r1,[r0,#4]
;;;41         stm.tm_sec = tm->tm_sec;  
00001e  9101              STR      r1,[sp,#4]
000020  6800              LDR      r0,[r0,#0]
;;;42       
;;;43         return mktime(&stm);  
000022  9000              STR      r0,[sp,#0]
000024  4668              MOV      r0,sp
000026  f7fffffe          BL       mktime
;;;44     }
00002a  b00b              ADD      sp,sp,#0x2c
00002c  bd00              POP      {pc}
;;;45     
                          ENDP


                          AREA ||i.check_passwd||, CODE, READONLY, ALIGN=2

                  check_passwd PROC
;;;133    */
;;;134    uint32_t  check_passwd(u32 type_value,u8 mach_type)
000000  b510              PUSH     {r4,lr}
;;;135    {
;;;136    	 u32 now_value;
;;;137         u32 value1,value2,value3;
;;;138    
;;;139    	switch(mach_type)
000002  2901              CMP      r1,#1
000004  d003              BEQ      |L2.14|
000006  2902              CMP      r1,#2
000008  d000              BEQ      |L2.12|
;;;140    	{
;;;141    		 case 1:
;;;142    		 {
;;;143    			value1 = type_value /100000;
;;;144    			value2 = type_value / 1000 %10;
;;;145    			value3 = type_value /10 % 10;
;;;146    			now_value = value1 * 100 + value2 * 10 + value3;
;;;147    			break;
;;;148    		 }
;;;149    		 case 2:
;;;150    		 {
;;;151    			// value1 = type_value /10000 %10;
;;;152    			// value2 = type_value/ 100 %10;
;;;153    			// value3 = type_value  % 10;
;;;154    			// now_value = value1 * 100 + value2 * 10 + value3;
;;;155    			now_value = type_value;
;;;156    			break;
;;;157    		 }
;;;158    		 default:
;;;159    		 {
;;;160    			 now_value = 0;
00000a  2000              MOVS     r0,#0
                  |L2.12|
;;;161    			 break;
;;;162    		 }		 		        
;;;163    	 }
;;;164    	return now_value;
;;;165    }
00000c  bd10              POP      {r4,pc}
                  |L2.14|
00000e  490d              LDR      r1,|L2.68|
000010  fbb0f3f1          UDIV     r3,r0,r1              ;143
000014  f44f717a          MOV      r1,#0x3e8             ;144
000018  fbb0f2f1          UDIV     r2,r0,r1              ;144
00001c  210a              MOVS     r1,#0xa               ;144
00001e  fbb2f4f1          UDIV     r4,r2,r1              ;144
000022  fbb0f0f1          UDIV     r0,r0,r1              ;145
000026  fb012214          MLS      r2,r1,r4,r2           ;144
00002a  fbb0f4f1          UDIV     r4,r0,r1              ;145
00002e  fb010014          MLS      r0,r1,r4,r0           ;145
000032  2164              MOVS     r1,#0x64              ;146
000034  434b              MULS     r3,r1,r3              ;146
000036  eb020182          ADD      r1,r2,r2,LSL #2       ;146
00003a  eb030141          ADD      r1,r3,r1,LSL #1       ;146
00003e  4408              ADD      r0,r0,r1              ;146
000040  bd10              POP      {r4,pc}
;;;166    
                          ENDP

000042  0000              DCW      0x0000
                  |L2.68|
                          DCD      0x000186a0

                          AREA ||i.generate_password||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  generate_password PROC
;;;175    ****/
;;;176    uint32_t  generate_password(u32 *passwd2,u32 *passwd1)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;177    {
;;;178    	u32 now_passwd;
;;;179        u32 value1,value2,value3,value4,value5,value6;
;;;180    		
;;;181    
;;;182    	value1 = (*passwd1 /100) *100000;
000004  680a              LDR      r2,[r1,#0]
000006  2464              MOVS     r4,#0x64
000008  fbb2f3f4          UDIV     r3,r2,r4
00000c  4918              LDR      r1,|L3.112|
00000e  434b              MULS     r3,r1,r3
;;;183    	value2 = (*passwd2 / 100) *10000;
000010  6801              LDR      r1,[r0,#0]
000012  f2427010          MOV      r0,#0x2710
000016  fbb1f4f4          UDIV     r4,r1,r4
00001a  4344              MULS     r4,r0,r4
;;;184    	value3 = (*passwd1 / 10 %10) * 1000;
00001c  200a              MOVS     r0,#0xa
00001e  fbb2f5f0          UDIV     r5,r2,r0
000022  fbb5f6f0          UDIV     r6,r5,r0
000026  fb005516          MLS      r5,r0,r6,r5
00002a  f44f767a          MOV      r6,#0x3e8
00002e  4375              MULS     r5,r6,r5
;;;185    	value4 = (*passwd2 / 10 %10) * 100;
000030  fbb1f6f0          UDIV     r6,r1,r0
000034  fbb6f7f0          UDIV     r7,r6,r0
000038  fb006617          MLS      r6,r0,r7,r6
00003c  2764              MOVS     r7,#0x64
00003e  437e              MULS     r6,r7,r6
;;;186    	value5 = (*passwd1  %10) *10;
000040  fbb2f7f0          UDIV     r7,r2,r0
000044  fb002217          MLS      r2,r0,r7,r2
;;;187    	value6 = *passwd2 % 10;
000048  fbb1f7f0          UDIV     r7,r1,r0
00004c  fb001017          MLS      r0,r0,r7,r1
;;;188    	now_passwd = value1 + value2 + value3 + value4 + value5 + value6 ;
000050  1919              ADDS     r1,r3,r4
000052  4429              ADD      r1,r1,r5
000054  eb020282          ADD      r2,r2,r2,LSL #2       ;186
000058  4431              ADD      r1,r1,r6
00005a  eb010142          ADD      r1,r1,r2,LSL #1
00005e  180c              ADDS     r4,r1,r0
;;;189    	USART_PRINTF_D("now_passwd is: %d\n",now_passwd);
000060  4621              MOV      r1,r4
000062  a004              ADR      r0,|L3.116|
000064  f7fffffe          BL       __2printf
;;;190    
;;;191    	return now_passwd;
000068  4620              MOV      r0,r4
;;;192    }
00006a  e8bd81f0          POP      {r4-r8,pc}
;;;193    
                          ENDP

00006e  0000              DCW      0x0000
                  |L3.112|
                          DCD      0x000186a0
                  |L3.116|
000074  6e6f775f          DCB      "now_passwd is: %d\n",0
000078  70617373
00007c  77642069
000080  733a2025
000084  640a00  
000087  00                DCB      0

                          AREA ||i.sm3_time_PasswordAuth||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  sm3_time_PasswordAuth PROC
;;;201    */
;;;202    uint8_t sm3_time_PasswordAuth(uint32_t now_time,struct sm3_info *sm,u8 n,u8 mach_type)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;203    {	
000004  4604              MOV      r4,r0
;;;204    	u8 pass_success = 0;
;;;205    	u8 type[3] = {64,64,8};
000006  a041              ADR      r0,|L4.268|
000008  b087              SUB      sp,sp,#0x1c           ;203
00000a  6800              LDR      r0,[r0,#0]
;;;206    	unsigned char build_num[8U] ={'F','F','F','F','F','F','F','F'};
00000c  9004              STR      r0,[sp,#0x10]
00000e  a040              ADR      r0,|L4.272|
000010  4688              MOV      r8,r1                 ;203
000012  e9d01000          LDRD     r1,r0,[r0,#0]
000016  e9cd1000          STRD     r1,r0,[sp,#0]
;;;207    	unsigned long i_num ;
;;;208    	u32 passwd ;
;;;209    	u32 b_passwd;
;;;210    	u32 test = 0;
00001a  2000              MOVS     r0,#0
;;;211    	int i;	
;;;212    	
;;;213    	USART_PRINTF_D("时间戳now_time is: %d\n",now_time);
00001c  9002              STR      r0,[sp,#8]
00001e  4699              MOV      r9,r3                 ;203
000020  4617              MOV      r7,r2                 ;203
000022  4621              MOV      r1,r4
000024  a03c              ADR      r0,|L4.280|
000026  f7fffffe          BL       __2printf
;;;214    	 switch(n)
;;;215    	 {
;;;216    		 case TIME_STAMP_PASSWORD:
;;;217    		 {
;;;218    			 USART_PRINTF_S("key is:\n");	
;;;219    			 USART_PRINTF_S(key_buf);	
;;;220    			 passwd =  check_passwd(atoi(key_buf),mach_type);
;;;221    			 i_num  = now_time/60 - 60;
00002a  253c              MOVS     r5,#0x3c
00002c  b127              CBZ      r7,|L4.56|
00002e  2f01              CMP      r7,#1                 ;214
000030  d00f              BEQ      |L4.82|
000032  2f02              CMP      r7,#2                 ;214
000034  d121              BNE      |L4.122|
000036  e016              B        |L4.102|
                  |L4.56|
000038  a13d              ADR      r1,|L4.304|
00003a  a040              ADR      r0,|L4.316|
00003c  f7fffffe          BL       __2printf
000040  493f              LDR      r1,|L4.320|
000042  a03e              ADR      r0,|L4.316|
000044  f7fffffe          BL       __2printf
000048  483d              LDR      r0,|L4.320|
00004a  f7fffffe          BL       atoi
00004e  4649              MOV      r1,r9                 ;220
;;;222    		 }
;;;223    		 break;
000050  e002              B        |L4.88|
                  |L4.82|
;;;224    		 case TIME_STAMP_SOUND:
;;;225    		 {
;;;226    			  passwd = 	check_passwd(ulong,mach_type);
000052  483c              LDR      r0,|L4.324|
000054  4649              MOV      r1,r9
000056  6800              LDR      r0,[r0,#0]  ; ulong
                  |L4.88|
000058  f7fffffe          BL       check_passwd
00005c  fbb4f4f5          UDIV     r4,r4,r5              ;221
000060  4606              MOV      r6,r0                 ;220
000062  3c3c              SUBS     r4,r4,#0x3c           ;221
000064  e009              B        |L4.122|
                  |L4.102|
;;;227    			  i_num  = now_time/60 - 60;
;;;228    		 }
;;;229    		 break;
;;;230    		 case TIME_STAMP_BLE:
;;;231    		 {
;;;232    			  passwd = 	check_passwd(atoi(BleValue),mach_type);
000066  4838              LDR      r0,|L4.328|
000068  f7fffffe          BL       atoi
00006c  4649              MOV      r1,r9
00006e  f7fffffe          BL       check_passwd
;;;233    			  i_num  = now_time/60 - 5;
000072  fbb4f4f5          UDIV     r4,r4,r5
000076  4606              MOV      r6,r0                 ;232
000078  1f64              SUBS     r4,r4,#5
                  |L4.122|
;;;234    		 }
;;;235    		break;				 	 
;;;236    	 }
;;;237    	 USART_PRINTF_D("passwd is: %d\n",passwd);				
00007a  4631              MOV      r1,r6
00007c  a033              ADR      r0,|L4.332|
00007e  f7fffffe          BL       __2printf
;;;238    				
;;;239    	for(i = 0 ; i < type[n] ;i++)
;;;240    	{
;;;241    		if(mach_type == 2)
;;;242    		{	
;;;243    			USART_PRINTF_S("门口机密码验证...\n");
;;;244    			test = get_sm3_pass(i_num , sm->community_id, sm->build_num, sm->cell_num);
000082  f1080008          ADD      r0,r8,#8
000086  2500              MOVS     r5,#0                 ;239
000088  f1080b10          ADD      r11,r8,#0x10
00008c  f10d0a10          ADD      r10,sp,#0x10          ;205
000090  9003              STR      r0,[sp,#0xc]          ;239
000092  e031              B        |L4.248|
                  |L4.148|
000094  f1b90f02          CMP      r9,#2                 ;241
000098  d00c              BEQ      |L4.180|
00009a  465b              MOV      r3,r11                ;241
;;;245    			b_passwd = get_sm3_pass(i_num , sm->community_id,build_num, sm->cell_num);
;;;246    			if(generate_password(&test,&b_passwd) == passwd )
;;;247    			{
;;;248    				USART_PRINTF_S("密码正确  √\n");
;;;249    				pass_success = 1;
;;;250    				return 1;	
;;;251    			}
;;;252    		}
;;;253    		else
;;;254    		{
;;;255    			if(passwd == get_sm3_pass(i_num , sm->community_id, sm->build_num, sm->cell_num))
00009c  4641              MOV      r1,r8
00009e  4620              MOV      r0,r4
0000a0  9a03              LDR      r2,[sp,#0xc]
0000a2  f7fffffe          BL       get_sm3_pass
0000a6  42b0              CMP      r0,r6
0000a8  d124              BNE      |L4.244|
;;;256    			{
;;;257    				USART_PRINTF_S("围墙机密码验证...\n");
0000aa  a12c              ADR      r1,|L4.348|
0000ac  a023              ADR      r0,|L4.316|
0000ae  f7fffffe          BL       __2printf
;;;258    				USART_PRINTF_S("密码正确  √\n");
;;;259    				pass_success = 1;
;;;260    				return 1;	
0000b2  e017              B        |L4.228|
                  |L4.180|
0000b4  a12e              ADR      r1,|L4.368|
0000b6  a021              ADR      r0,|L4.316|
0000b8  f7fffffe          BL       __2printf
0000bc  465b              MOV      r3,r11                ;243
0000be  4641              MOV      r1,r8                 ;244
0000c0  4620              MOV      r0,r4                 ;244
0000c2  9a03              LDR      r2,[sp,#0xc]          ;244
0000c4  f7fffffe          BL       get_sm3_pass
0000c8  9002              STR      r0,[sp,#8]            ;245
0000ca  465b              MOV      r3,r11                ;244
0000cc  466a              MOV      r2,sp                 ;245
0000ce  4641              MOV      r1,r8                 ;245
0000d0  4620              MOV      r0,r4                 ;245
0000d2  f7fffffe          BL       get_sm3_pass
0000d6  9005              STR      r0,[sp,#0x14]         ;246
0000d8  a905              ADD      r1,sp,#0x14           ;246
0000da  a802              ADD      r0,sp,#8              ;246
0000dc  f7fffffe          BL       generate_password
0000e0  42b0              CMP      r0,r6                 ;246
0000e2  d107              BNE      |L4.244|
                  |L4.228|
0000e4  a127              ADR      r1,|L4.388|
0000e6  a015              ADR      r0,|L4.316|
0000e8  f7fffffe          BL       __2printf
0000ec  2001              MOVS     r0,#1                 ;250
                  |L4.238|
;;;261    			}
;;;262    		}
;;;263    		i_num ++;
;;;264    	}
;;;265    				
;;;266    	USART_PRINTF_D("sm3密码验证失败,sm3密码验证数据信息：%s\n",sm);
;;;267    	return 0;
;;;268    }
0000ee  b007              ADD      sp,sp,#0x1c
0000f0  e8bd8ff0          POP      {r4-r11,pc}
                  |L4.244|
0000f4  1c64              ADDS     r4,r4,#1
0000f6  1c6d              ADDS     r5,r5,#1
                  |L4.248|
0000f8  f81a0007          LDRB     r0,[r10,r7]           ;239
0000fc  42a8              CMP      r0,r5                 ;239
0000fe  dcc9              BGT      |L4.148|
000100  4641              MOV      r1,r8                 ;266
000102  a024              ADR      r0,|L4.404|
000104  f7fffffe          BL       __2printf
000108  2000              MOVS     r0,#0                 ;267
00010a  e7f0              B        |L4.238|
;;;269    
                          ENDP

                  |L4.268|
00010c  40400800          DCB      "@@\b",0
                  |L4.272|
000110  46464646          DCB      "FFFFFFFF"
000114  46464646
                  |L4.280|
000118  cab1bce4          DCB      202,177,188,228,180,193,"now_time is: %d\n",0
00011c  b4c16e6f
000120  775f7469
000124  6d652069
000128  733a2025
00012c  640a00  
00012f  00                DCB      0
                  |L4.304|
000130  6b657920          DCB      "key is:\n",0
000134  69733a0a
000138  00      
000139  00                DCB      0
00013a  00                DCB      0
00013b  00                DCB      0
                  |L4.316|
00013c  25730a00          DCB      "%s\n",0
                  |L4.320|
                          DCD      ||.data||
                  |L4.324|
                          DCD      ulong
                  |L4.328|
                          DCD      BleValue
                  |L4.332|
00014c  70617373          DCB      "passwd is: %d\n",0
000150  77642069
000154  733a2025
000158  640a00  
00015b  00                DCB      0
                  |L4.348|
00015c  cea7c7bd          DCB      206,167,199,189,187,250,195,220,194,235,209,233,214,164,"."
000160  bbfac3dc
000164  c2ebd1e9
000168  d6a42e  
00016b  2e2e0a00          DCB      "..\n",0
00016f  00                DCB      0
                  |L4.368|
000170  c3c5bfda          DCB      195,197,191,218,187,250,195,220,194,235,209,233,214,164,"."
000174  bbfac3dc
000178  c2ebd1e9
00017c  d6a42e  
00017f  2e2e0a00          DCB      "..\n",0
000183  00                DCB      0
                  |L4.388|
000184  c3dcc2eb          DCB      195,220,194,235,213,253,200,183,"  ",161,204,"\n",0
000188  d5fdc8b7
00018c  2020a1cc
000190  0a00    
000192  00                DCB      0
000193  00                DCB      0
                  |L4.404|
000194  736d33c3          DCB      "sm3",195,220,194,235,209,233,214,164,202,167,176,220,","
000198  dcc2ebd1
00019c  e9d6a4ca
0001a0  a7b0dc2c
0001a4  736d33c3          DCB      "sm3",195,220,194,235,209,233,214,164,202,253,190,221,208
0001a8  dcc2ebd1
0001ac  e9d6a4ca
0001b0  fdbeddd0
0001b4  c5cfa2a3          DCB      197,207,162,163,186,"%s\n",0
0001b8  ba25730a
0001bc  00      
0001bd  00                DCB      0
0001be  00                DCB      0
0001bf  00                DCB      0

                          AREA ||i.timestamp_strBJtime||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  timestamp_strBJtime PROC
;;;53     */
;;;54     void timestamp_strBJtime(unsigned long timestamp, char *ftime)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;55     {
;;;56     	struct tm *tm_t;
;;;57     	timestamp = timestamp + 28800;//补充8小时秒数
000002  9800              LDR      r0,[sp,#0]
000004  460c              MOV      r4,r1                 ;55
000006  f50040e1          ADD      r0,r0,#0x7080
;;;58     	tm_t = localtime(&timestamp);
00000a  9000              STR      r0,[sp,#0]
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       localtime
000012  4603              MOV      r3,r0
;;;59     	strftime(ftime,15,"%Y%m%d%H%M%S",tm_t);
000014  a204              ADR      r2,|L5.40|
000016  210f              MOVS     r1,#0xf
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       strftime
;;;60     	USART_PRINTF_D("时间戳转换的当前时间：%s",ftime);
00001e  4621              MOV      r1,r4
000020  a005              ADR      r0,|L5.56|
000022  f7fffffe          BL       __2printf
;;;61     }
000026  bd1c              POP      {r2-r4,pc}
;;;62     
                          ENDP

                  |L5.40|
000028  2559256d          DCB      "%Y%m%d%H%M%S",0
00002c  25642548
000030  254d2553
000034  00      
000035  00                DCB      0
000036  00                DCB      0
000037  00                DCB      0
                  |L5.56|
000038  cab1bce4          DCB      202,177,188,228,180,193,215,170,187,187,181,196,181,177,199
00003c  b4c1d7aa
000040  bbbbb5c4
000044  b5b1c7  
000047  b0cab1bc          DCB      176,202,177,188,228,163,186,"%s",0
00004b  e4a3ba25
00004f  7300    
000051  00                DCB      0
000052  00                DCB      0
000053  00                DCB      0

                          AREA ||i.timestamp_timeCalibration||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  timestamp_timeCalibration PROC
;;;68     */
;;;69     void timestamp_timeCalibration(char *tm,uint8_t tmType)  
000000  b530              PUSH     {r4,r5,lr}
;;;70     {
000002  b091              SUB      sp,sp,#0x44
;;;71     	struct rtc_time stm;
;;;72     	time_stamp_Date Date;
;;;73     	u8 i;
;;;74     	u8 buf = 0U;
000004  2400              MOVS     r4,#0
000006  f88d4040          STRB     r4,[sp,#0x40]
;;;75     	
;;;76     	for(i = 0;i < 14U;i++)
00000a  4622              MOV      r2,r4
00000c  ad03              ADD      r5,sp,#0xc            ;72
                  |L6.14|
;;;77     	{
;;;78     		Date.currentdate[i] = tm[i];
00000e  5c83              LDRB     r3,[r0,r2]
000010  54ab              STRB     r3,[r5,r2]
000012  3b30              SUBS     r3,r3,#0x30
;;;79     		Date.currentdate[i] = (uint8_t)(Date.currentdate[i] - 0x30);
000014  54ab              STRB     r3,[r5,r2]
000016  1c52              ADDS     r2,r2,#1
000018  b2d2              UXTB     r2,r2                 ;76
00001a  2a0e              CMP      r2,#0xe               ;76
00001c  d3f7              BCC      |L6.14|
;;;80     	}
;;;81     	
;;;82     	stm.tm_year = Date.date.year[0U]*1000 + Date.date.year[1U]*100 + Date.date.year[2U]*10 + Date.date.year[3U];  
00001e  f89d000c          LDRB     r0,[sp,#0xc]
000022  f89d200f          LDRB     r2,[sp,#0xf]
000026  eb000340          ADD      r3,r0,r0,LSL #1
00002a  ebc310c0          RSB      r0,r3,r0,LSL #7
00002e  eb0202c0          ADD      r2,r2,r0,LSL #3
000032  f89d000d          LDRB     r0,[sp,#0xd]
000036  2364              MOVS     r3,#0x64
000038  fb10f303          SMULBB   r3,r0,r3
00003c  f89d000e          LDRB     r0,[sp,#0xe]
;;;83     	stm.tm_mon  = (Date.date.mon[0U]*10  + Date.date.mon[1U]);
;;;84     	stm.tm_mday = Date.date.mday[0U]*10 + Date.date.mday[1U];
;;;85     	if(TIME_STAMP_UNT == tmType)
000040  2901              CMP      r1,#1
000042  eb000080          ADD      r0,r0,r0,LSL #2       ;82
000046  eb030040          ADD      r0,r3,r0,LSL #1       ;82
00004a  4410              ADD      r0,r0,r2              ;82
00004c  900c              STR      r0,[sp,#0x30]         ;83
00004e  f89d0010          LDRB     r0,[sp,#0x10]         ;83
000052  f89d2011          LDRB     r2,[sp,#0x11]         ;83
000056  eb000080          ADD      r0,r0,r0,LSL #2       ;83
00005a  eb020040          ADD      r0,r2,r0,LSL #1       ;83
00005e  900b              STR      r0,[sp,#0x2c]         ;84
000060  f89d0012          LDRB     r0,[sp,#0x12]         ;84
000064  f89d2013          LDRB     r2,[sp,#0x13]         ;84
000068  eb000080          ADD      r0,r0,r0,LSL #2       ;84
00006c  eb020040          ADD      r0,r2,r0,LSL #1       ;84
000070  900a              STR      r0,[sp,#0x28]
;;;86     	{
;;;87     		stm.tm_hour = Date.date.hour[0U]*10 + Date.date.hour[1U] +8;
;;;88     	}
;;;89     	else
;;;90     	{
;;;91     		stm.tm_hour = Date.date.hour[0U]*10 + Date.date.hour[1U];
000072  f89d0014          LDRB     r0,[sp,#0x14]
000076  f89d1015          LDRB     r1,[sp,#0x15]
00007a  eb000080          ADD      r0,r0,r0,LSL #2
00007e  d02c              BEQ      |L6.218|
000080  eb010040          ADD      r0,r1,r0,LSL #1
                  |L6.132|
;;;92     	}
;;;93     	stm.tm_min  = Date.date.min[0U]*10  + Date.date.min[1U];
000084  9009              STR      r0,[sp,#0x24]
000086  f89d0016          LDRB     r0,[sp,#0x16]
00008a  f89d1017          LDRB     r1,[sp,#0x17]
00008e  eb000080          ADD      r0,r0,r0,LSL #2
000092  eb010040          ADD      r0,r1,r0,LSL #1
;;;94     	stm.tm_sec  = Date.date.sec[0U]*10  + Date.date.sec[1U];
000096  9008              STR      r0,[sp,#0x20]
000098  f89d0018          LDRB     r0,[sp,#0x18]
00009c  f89d1019          LDRB     r1,[sp,#0x19]
0000a0  eb000080          ADD      r0,r0,r0,LSL #2
0000a4  eb010040          ADD      r0,r1,r0,LSL #1
0000a8  e9dd1208          LDRD     r1,r2,[sp,#0x20]
0000ac  9007              STR      r0,[sp,#0x1c]
;;;95     	USART_PRINTF_DATE("设置到hym8563的时间：%d.%d.%d %d:%d:%d\n",stm.tm_year,stm.tm_mon,  \
0000ae  9200              STR      r2,[sp,#0]
0000b0  e9cd1001          STRD     r1,r0,[sp,#4]
0000b4  e9dd210b          LDRD     r2,r1,[sp,#0x2c]
0000b8  a018              ADR      r0,|L6.284|
0000ba  9b0a              LDR      r3,[sp,#0x28]
0000bc  f7fffffe          BL       __2printf
;;;96     					  stm.tm_mday,stm.tm_hour,stm.tm_min,stm.tm_sec);
;;;97     
;;;98     	buf |= STOP;
0000c0  f89d0040          LDRB     r0,[sp,#0x40]
;;;99     	if (hym8563_i2c_set_regs(RTC_CTL1, &buf, 1) == 0)
0000c4  2201              MOVS     r2,#1
0000c6  f0400020          ORR      r0,r0,#0x20           ;98
0000ca  f88d0040          STRB     r0,[sp,#0x40]         ;98
0000ce  a910              ADD      r1,sp,#0x40
0000d0  2000              MOVS     r0,#0
0000d2  f7fffffe          BL       hym8563_i2c_set_regs
0000d6  b128              CBZ      r0,|L6.228|
0000d8  e008              B        |L6.236|
                  |L6.218|
0000da  2208              MOVS     r2,#8                 ;87
0000dc  eb020040          ADD      r0,r2,r0,LSL #1       ;87
0000e0  4408              ADD      r0,r0,r1              ;87
0000e2  e7cf              B        |L6.132|
                  |L6.228|
;;;100    	{
;;;101    		USART_PRINTF_S("关闭hym8563成功  √\n");
0000e4  a117              ADR      r1,|L6.324|
0000e6  a01d              ADR      r0,|L6.348|
0000e8  f7fffffe          BL       __2printf
                  |L6.236|
;;;102    	}
;;;103    
;;;104    	/*
;;;105    	***
;;;106    	设置日期、时间
;;;107    	***	
;;;108    	*/	
;;;109    	if(hym8563_set_time(&stm) == 0)
0000ec  a807              ADD      r0,sp,#0x1c
0000ee  f7fffffe          BL       hym8563_set_time
0000f2  b918              CBNZ     r0,|L6.252|
;;;110    	{
;;;111    		USART_PRINTF_S("set hym8563 time成功  √\n");
0000f4  a11a              ADR      r1,|L6.352|
0000f6  a019              ADR      r0,|L6.348|
0000f8  f7fffffe          BL       __2printf
                  |L6.252|
;;;112    	}
;;;113    
;;;114    	/*
;;;115    	***
;;;116    	读取日期、时间
;;;117    	***	
;;;118    	*/	
;;;119    	buf = 0U;
0000fc  f88d4040          STRB     r4,[sp,#0x40]
;;;120    	if (hym8563_i2c_set_regs(RTC_CTL1, &buf, 1) == 0)
000100  2201              MOVS     r2,#1
000102  a910              ADD      r1,sp,#0x40
000104  2000              MOVS     r0,#0
000106  f7fffffe          BL       hym8563_i2c_set_regs
00010a  2800              CMP      r0,#0
00010c  d103              BNE      |L6.278|
;;;121    	{
;;;122    		USART_PRINTF_S("开启HYM863时钟  √\n");
00010e  a11b              ADR      r1,|L6.380|
000110  a012              ADR      r0,|L6.348|
000112  f7fffffe          BL       __2printf
                  |L6.278|
;;;123    	}
;;;124    }
000116  b011              ADD      sp,sp,#0x44
000118  bd30              POP      {r4,r5,pc}
;;;125    
                          ENDP

00011a  0000              DCW      0x0000
                  |L6.284|
00011c  c9e8d6c3          DCB      201,232,214,195,181,189,"hym8563",181,196,202,177,188,228
000120  b5bd6879
000124  6d383536
000128  33b5c4ca
00012c  b1bce4  
00012f  a3ba2564          DCB      163,186,"%d.%d.%d %d:%d:%d\n",0
000133  2e25642e
000137  25642025
00013b  643a2564
00013f  3a25640a
000143  00      
                  |L6.324|
000144  b9d8b1d5          DCB      185,216,177,213,"hym8563",179,201,185,166,"  ",161,204,"\n"
000148  68796d38
00014c  353633b3
000150  c9b9a620
000154  20a1cc0a
000158  00                DCB      0
000159  00                DCB      0
00015a  00                DCB      0
00015b  00                DCB      0
                  |L6.348|
00015c  25730a00          DCB      "%s\n",0
                  |L6.352|
000160  73657420          DCB      "set hym8563 time",179,201,185,166,"  ",161,204,"\n",0
000164  68796d38
000168  35363320
00016c  74696d65
000170  b3c9b9a6
000174  2020a1cc
000178  0a00    
00017a  00                DCB      0
00017b  00                DCB      0
                  |L6.380|
00017c  bfaac6f4          DCB      191,170,198,244,"HYM863",202,177,214,211,"  ",161,204,"\n"
000180  48594d38
000184  3633cab1
000188  d6d32020
00018c  a1cc0a  
00018f  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=0

                  key_buf
                          DCDU     0x00000000
000004  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\Complex\\timeStamp\\time_stamp.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_time_stamp_c_GetTick____REV16|
#line 138 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_time_stamp_c_GetTick____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_time_stamp_c_GetTick____REVSH|
#line 153
|__asm___12_time_stamp_c_GetTick____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_time_stamp_c_GetTick____RRX|
#line 328
|__asm___12_time_stamp_c_GetTick____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

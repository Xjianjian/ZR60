; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\port.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\port.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\ZR60_v1.0_freeRTOS -I..\..\Lwip\App -I..\..\Lwip\Bsp -I..\..\Lwip\Bsp\LAN8742A -I..\..\Lwip\lwip-1.4.1 -I..\..\Lwip\lwip-1.4.1\port -I..\..\Lwip\lwip-1.4.1\port\arch -I..\..\Lwip\lwip-1.4.1\port\Standalone -I..\..\Lwip\lwip-1.4.1\src\include -I..\..\Lwip\lwip-1.4.1\src\include\ipv4 -I..\..\Lwip\lwip-1.4.1\src\include\lwip -I..\..\Lwip\lwip-1.4.1\src\include\netif -I..\..\Ecal\BtnFltr -I..\..\Ecal\UartComn -I..\..\Ecal\MemIf -I..\..\APP -I..\..\APP\BlackListMng -I..\..\APP\SeverNewsPush -I..\..\APP\NewsPull -I..\..\Ecal -I..\..\Ecal\JsonIf -I..\..\Ecal\Mcu_Init -I..\..\Service -I..\..\Complex -I..\..\Complex\FATFS -I..\..\FreeRTOS\Source\include -I..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\FreeRTOS -I.\RTE\_ZR60 -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=..\..\output\port.crf ..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F\port.c]
                          THUMB

                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=2

                  SysTick_Handler PROC
;;;514    
;;;515    void xPortSysTickHandler( void )
000000  b510              PUSH     {r4,lr}
000002  2010              MOVS     r0,#0x10
000004  f3808811          MSR      BASEPRI,r0
000008  f3bf8f4f          DSB      
00000c  f3bf8f6f          ISB      
;;;516    {
;;;517    	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
;;;518    	executes all interrupts must be unmasked.  There is therefore no need to
;;;519    	save and then restore the interrupt mask value as its value is already
;;;520    	known. */
;;;521    	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
;;;522    	{
;;;523    		/* Increment the RTOS tick. */
;;;524    		if( xTaskIncrementTick() != pdFALSE )
000010  f7fffffe          BL       xTaskIncrementTick
000014  b118              CBZ      r0,|L1.30|
;;;525    		{
;;;526    			/* A context switch is required.  Context switching is performed in
;;;527    			the PendSV interrupt.  Pend the PendSV interrupt. */
;;;528    			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
000016  4904              LDR      r1,|L1.40|
000018  f04f5080          MOV      r0,#0x10000000
00001c  6008              STR      r0,[r1,#0]
                  |L1.30|
;;;529    		}
;;;530    	}
;;;531    	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
00001e  2000              MOVS     r0,#0
000020  f3808811          MSR      BASEPRI,r0
;;;532    }
000024  bd10              POP      {r4,pc}
;;;533    /*-----------------------------------------------------------*/
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      0xe000ed04

                          AREA ||i.prvTaskExitError||, CODE, READONLY, ALIGN=1

                  prvTaskExitError PROC
;;;258    
;;;259    static void prvTaskExitError( void )
000000  2010              MOVS     r0,#0x10
000002  f3808811          MSR      BASEPRI,r0
000006  f3bf8f4f          DSB      
00000a  f3bf8f6f          ISB      
                  |L2.14|
;;;260    {
;;;261    	/* A function that implements a task must not exit or attempt to return to
;;;262    	its caller as there is nothing to return to.  If a task wants to exit it
;;;263    	should instead call vTaskDelete( NULL ).
;;;264    
;;;265    	Artificially force an assert() to be triggered if configASSERT() is
;;;266    	defined, then stop here so application writers can catch the error. */
;;;267    	configASSERT( uxCriticalNesting == ~0UL );
;;;268    	portDISABLE_INTERRUPTS();
;;;269    	for( ;; );
00000e  e7fe              B        |L2.14|
;;;270    }
;;;271    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.pxPortInitialiseStack||, CODE, READONLY, ALIGN=2

                  pxPortInitialiseStack PROC
;;;228     */
;;;229    StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
000000  b510              PUSH     {r4,lr}
;;;230    {
;;;231    	/* Simulate the stack frame as it would be created by a context switch
;;;232    	interrupt. */
;;;233    
;;;234    	/* Offset added to account for the way the MCU uses the stack on entry/exit
;;;235    	of interrupts, and to ensure alignment. */
;;;236    	pxTopOfStack--;
000002  1f03              SUBS     r3,r0,#4
;;;237    
;;;238    	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
000004  f04f7480          MOV      r4,#0x1000000
;;;239    	pxTopOfStack--;
;;;240    	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
;;;241    	pxTopOfStack--;
;;;242    	*pxTopOfStack = ( StackType_t ) prvTaskExitError;	/* LR */
;;;243    
;;;244    	/* Save code space by skipping register initialisation. */
;;;245    	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
;;;246    	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
;;;247    
;;;248    	/* A save method is being used that requires each task to maintain its
;;;249    	own exec return value. */
;;;250    	pxTopOfStack--;
;;;251    	*pxTopOfStack = portINITIAL_EXEC_RETURN;
;;;252    
;;;253    	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
;;;254    
;;;255    	return pxTopOfStack;
000008  601c              STR      r4,[r3,#0]
00000a  1f1b              SUBS     r3,r3,#4
00000c  6019              STR      r1,[r3,#0]
00000e  1f19              SUBS     r1,r3,#4
000010  4b04              LDR      r3,|L3.36|
000012  600b              STR      r3,[r1,#0]
000014  3914              SUBS     r1,r1,#0x14
000016  600a              STR      r2,[r1,#0]
000018  1f09              SUBS     r1,r1,#4
00001a  f06f0202          MVN      r2,#2                 ;251
00001e  3844              SUBS     r0,r0,#0x44           ;251
000020  600a              STR      r2,[r1,#0]            ;251
;;;256    }
000022  bd10              POP      {r4,pc}
;;;257    /*-----------------------------------------------------------*/
                          ENDP

                  |L3.36|
                          DCD      prvTaskExitError

                          AREA ||i.vPortEndScheduler||, CODE, READONLY, ALIGN=1

                  vPortEndScheduler PROC
;;;416    
;;;417    void vPortEndScheduler( void )
000000  4770              BX       lr
;;;418    {
;;;419    	/* Not implemented in ports where there is nothing to return to.
;;;420    	Artificially force an assert. */
;;;421    	configASSERT( uxCriticalNesting == 1000UL );
;;;422    }
;;;423    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vPortEnterCritical||, CODE, READONLY, ALIGN=2

                  vPortEnterCritical PROC
;;;424    
;;;425    void vPortEnterCritical( void )
000000  2010              MOVS     r0,#0x10
000002  f3808811          MSR      BASEPRI,r0
000006  f3bf8f4f          DSB      
00000a  f3bf8f6f          ISB      
;;;426    {
;;;427    	portDISABLE_INTERRUPTS();
;;;428    	uxCriticalNesting++;
00000e  4802              LDR      r0,|L5.24|
000010  6801              LDR      r1,[r0,#0]  ; uxCriticalNesting
000012  1c49              ADDS     r1,r1,#1
000014  6001              STR      r1,[r0,#0]  ; uxCriticalNesting
;;;429    
;;;430    	/* This is not the interrupt safe version of the enter critical function so
;;;431    	assert() if it is being called from an interrupt context.  Only API
;;;432    	functions that end in "FromISR" can be used in an interrupt.  Only assert if
;;;433    	the critical nesting count is 1 to protect against recursive calls if the
;;;434    	assert function also uses a critical section. */
;;;435    	if( uxCriticalNesting == 1 )
;;;436    	{
;;;437    		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
;;;438    	}
;;;439    }
000016  4770              BX       lr
;;;440    /*-----------------------------------------------------------*/
                          ENDP

                  |L5.24|
                          DCD      ||.data||

                          AREA ||i.vPortExitCritical||, CODE, READONLY, ALIGN=2

                  vPortExitCritical PROC
;;;441    
;;;442    void vPortExitCritical( void )
000000  4903              LDR      r1,|L6.16|
;;;443    {
;;;444    	configASSERT( uxCriticalNesting );
;;;445    	uxCriticalNesting--;
000002  6808              LDR      r0,[r1,#0]  ; uxCriticalNesting
000004  1e40              SUBS     r0,r0,#1
000006  6008              STR      r0,[r1,#0]            ;443  ; uxCriticalNesting
000008  d101              BNE      |L6.14|
00000a  f3808811          MSR      BASEPRI,r0            ;443
                  |L6.14|
;;;446    	if( uxCriticalNesting == 0 )
;;;447    	{
;;;448    		portENABLE_INTERRUPTS();
;;;449    	}
;;;450    }
00000e  4770              BX       lr
;;;451    /*-----------------------------------------------------------*/
                          ENDP

                  |L6.16|
                          DCD      ||.data||

                          AREA ||i.vPortSetupTimerInterrupt||, CODE, READONLY, ALIGN=2

                  vPortSetupTimerInterrupt PROC
;;;693    
;;;694    	void vPortSetupTimerInterrupt( void )
000000  f04f20e0          MOV      r0,#0xe000e000
;;;695    	{
;;;696    		/* Calculate the constants required to configure the tick interrupt. */
;;;697    		#if configUSE_TICKLESS_IDLE == 1
;;;698    		{
;;;699    			ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
;;;700    			xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
;;;701    			ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
;;;702    		}
;;;703    		#endif /* configUSE_TICKLESS_IDLE */
;;;704    
;;;705    		/* Configure SysTick to interrupt at the requested rate. */
;;;706    		portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
000004  4902              LDR      r1,|L7.16|
000006  6141              STR      r1,[r0,#0x14]
;;;707    		portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
000008  2107              MOVS     r1,#7
00000a  6101              STR      r1,[r0,#0x10]
;;;708    	}
00000c  4770              BX       lr
;;;709    
                          ENDP

00000e  0000              DCW      0x0000
                  |L7.16|
                          DCD      0x0002903f

                          AREA ||i.xPortStartScheduler||, CODE, READONLY, ALIGN=2

                  xPortStartScheduler PROC
;;;331     */
;;;332    BaseType_t xPortStartScheduler( void )
000000  480c              LDR      r0,|L8.52|
;;;333    {
000002  b510              PUSH     {r4,lr}
;;;334    	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
;;;335    	See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
;;;336    	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );
;;;337    
;;;338    	/* This port can be used on all revisions of the Cortex-M7 core other than
;;;339    	the r0p1 parts.  r0p1 parts should use the port from the
;;;340    	/source/portable/GCC/ARM_CM7/r0p1 directory. */
;;;341    	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
;;;342    	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
;;;343    
;;;344    	#if( configASSERT_DEFINED == 1 )
;;;345    	{
;;;346    		volatile uint32_t ulOriginalPriority;
;;;347    		volatile uint8_t * const pucFirstUserPriorityRegister = ( uint8_t * ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
;;;348    		volatile uint8_t ucMaxPriorityValue;
;;;349    
;;;350    		/* Determine the maximum priority from which ISR safe FreeRTOS API
;;;351    		functions can be called.  ISR safe functions are those that end in
;;;352    		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
;;;353    		ensure interrupt entry is as fast and simple as possible.
;;;354    
;;;355    		Save the interrupt priority value that is about to be clobbered. */
;;;356    		ulOriginalPriority = *pucFirstUserPriorityRegister;
;;;357    
;;;358    		/* Determine the number of priority bits available.  First write to all
;;;359    		possible bits. */
;;;360    		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
;;;361    
;;;362    		/* Read the value back to see how many bits stuck. */
;;;363    		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
;;;364    
;;;365    		/* The kernel interrupt priority should be set to the lowest
;;;366    		priority. */
;;;367    		configASSERT( ucMaxPriorityValue == ( configKERNEL_INTERRUPT_PRIORITY & ucMaxPriorityValue ) );
;;;368    
;;;369    		/* Use the same mask on the maximum system call priority. */
;;;370    		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
;;;371    
;;;372    		/* Calculate the maximum acceptable priority group value for the number
;;;373    		of bits read back. */
;;;374    		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
;;;375    		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
;;;376    		{
;;;377    			ulMaxPRIGROUPValue--;
;;;378    			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
;;;379    		}
;;;380    
;;;381    		/* Shift the priority group value back to its position within the AIRCR
;;;382    		register. */
;;;383    		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
;;;384    		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
;;;385    
;;;386    		/* Restore the clobbered interrupt priority register to its original
;;;387    		value. */
;;;388    		*pucFirstUserPriorityRegister = ulOriginalPriority;
;;;389    	}
;;;390    	#endif /* conifgASSERT_DEFINED */
;;;391    
;;;392    	/* Make PendSV and SysTick the lowest priority interrupts. */
;;;393    	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
000004  6801              LDR      r1,[r0,#0]
000006  f4410170          ORR      r1,r1,#0xf00000
00000a  6001              STR      r1,[r0,#0]
;;;394    	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
00000c  6801              LDR      r1,[r0,#0]
00000e  f0414170          ORR      r1,r1,#0xf0000000
000012  6001              STR      r1,[r0,#0]
;;;395    
;;;396    	/* Start the timer that generates the tick ISR.  Interrupts are disabled
;;;397    	here already. */
;;;398    	vPortSetupTimerInterrupt();
000014  f7fffffe          BL       vPortSetupTimerInterrupt
;;;399    
;;;400    	/* Initialise the critical nesting count ready for the first task. */
;;;401    	uxCriticalNesting = 0;
000018  4907              LDR      r1,|L8.56|
00001a  2000              MOVS     r0,#0
;;;402    
;;;403    	/* Ensure the VFP is enabled - it should be anyway. */
;;;404    	prvEnableVFP();
00001c  6008              STR      r0,[r1,#0]  ; uxCriticalNesting
00001e  f7fffffe          BL       __asm___6_port_c_39a90d8d__prvEnableVFP
;;;405    
;;;406    	/* Lazy save always. */
;;;407    	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
000022  4806              LDR      r0,|L8.60|
000024  6801              LDR      r1,[r0,#0]
000026  f0414140          ORR      r1,r1,#0xc0000000
00002a  6001              STR      r1,[r0,#0]
;;;408    
;;;409    	/* Start the first task. */
;;;410    	prvStartFirstTask();
00002c  f7fffffe          BL       __asm___6_port_c_39a90d8d__prvStartFirstTask
;;;411    
;;;412    	/* Should not get here! */
;;;413    	return 0;
000030  2000              MOVS     r0,#0
;;;414    }
000032  bd10              POP      {r4,pc}
;;;415    /*-----------------------------------------------------------*/
                          ENDP

                  |L8.52|
                          DCD      0xe000ed20
                  |L8.56|
                          DCD      ||.data||
                  |L8.60|
                          DCD      0xe000ef34

                          AREA ||.data||, DATA, ALIGN=2

                  uxCriticalNesting
                          DCD      0xaaaaaaaa

;*** Start embedded assembler ***

#line 1 "..\\..\\FreeRTOS\\Source\\portable\\RVDS\\ARM_CM4F\\port.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |SVC_Handler|
#line 273
|SVC_Handler| PROC
#line 274

 PRESERVE8

 
 ldr r3, =pxCurrentTCB
 ldr r1, [r3]
 ldr r0, [r1]
 
 ldmia r0!, {r4-r11, r14}
 msr psp, r0
 isb
 mov r0, #0
 msr basepri, r0
 bx r14
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___6_port_c_39a90d8d__prvStartFirstTask|
#line 291
|__asm___6_port_c_39a90d8d__prvStartFirstTask| PROC
#line 292

 PRESERVE8

 
 ldr r0, =0xE000ED08
 ldr r0, [r0]
 ldr r0, [r0]
 
 msr msp, r0
 
 cpsie i
 cpsie f
 dsb
 isb
 
 svc 0
 nop
 nop
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___6_port_c_39a90d8d__prvEnableVFP|
#line 313
|__asm___6_port_c_39a90d8d__prvEnableVFP| PROC
#line 314

 PRESERVE8

 
 ldr.w r0, =0xE000ED88
 ldr r1, [r0]

 
 orr r1, r1, #( 0xf << 20 )
 str r1, [r0]
 bx r14
 nop
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |PendSV_Handler|
#line 453
|PendSV_Handler| PROC
#line 454

 extern uxCriticalNesting
 extern pxCurrentTCB
 extern vTaskSwitchContext

 PRESERVE8

 mrs r0, psp
 isb
 
 ldr r3, =pxCurrentTCB
 ldr r2, [r3]

 
 tst r14, #0x10
 it eq
 vstmdbeq r0!, {s16-s31}

 
 stmdb r0!, {r4-r11, r14}

 
 str r0, [r2]

 stmdb sp!, {r3}
 mov r0, #( 0x01 << (8 - 4) )
 msr basepri, r0
 dsb
 isb
 bl vTaskSwitchContext
 mov r0, #0
 msr basepri, r0
 ldmia sp!, {r3}

 
 ldr r1, [r3]
 ldr r0, [r1]

 
 ldmia r0!, {r4-r11, r14}

#line 496
 
 tst r14, #0x10
 it eq
 vldmiaeq r0!, {s16-s31}

 msr psp, r0
 isb
 
#line 510

 bx r14
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |vPortGetIPSR|
#line 713
|vPortGetIPSR| PROC
#line 714

 PRESERVE8

 mrs r0, ipsr
 bx r14
	ENDP

;*** End   embedded assembler ***

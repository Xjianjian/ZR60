; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\stm32f429_eth.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\stm32f429_eth.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\ZR60_v1.0_freeRTOS -I..\..\Lwip\App -I..\..\Lwip\Bsp -I..\..\Lwip\Bsp\LAN8742A -I..\..\Lwip\lwip-1.4.1 -I..\..\Lwip\lwip-1.4.1\port -I..\..\Lwip\lwip-1.4.1\port\arch -I..\..\Lwip\lwip-1.4.1\port\Standalone -I..\..\Lwip\lwip-1.4.1\src\include -I..\..\Lwip\lwip-1.4.1\src\include\ipv4 -I..\..\Lwip\lwip-1.4.1\src\include\lwip -I..\..\Lwip\lwip-1.4.1\src\include\netif -I..\..\Ecal\BtnFltr -I..\..\Ecal\UartComn -I..\..\Ecal\MemIf -I..\..\APP -I..\..\APP\BlackListMng -I..\..\APP\SeverNewsPush -I..\..\APP\NewsPull -I..\..\Ecal -I..\..\Ecal\JsonIf -I..\..\Ecal\Mcu_Init -I..\..\Service -I..\..\Complex -I..\..\Complex\FATFS -I..\..\FreeRTOS\Source\include -I..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\FreeRTOS -I.\RTE\_ZR60 -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=..\..\output\stm32f429_eth.crf ..\..\Lwip\Bsp\LAN8742A\stm32f429_eth.c]
                          THUMB

                          AREA ||i.ETH_BackPressureActivationCmd||, CODE, READONLY, ALIGN=2

                  ETH_BackPressureActivationCmd PROC
;;;768      */
;;;769    void ETH_BackPressureActivationCmd(FunctionalState NewState)   
000000  b508              PUSH     {r3,lr}
;;;770    { 
;;;771      __IO uint32_t tmpreg = 0;
000002  2100              MOVS     r1,#0
;;;772      /* Check the parameters */
;;;773      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;774      
;;;775      if (NewState != DISABLE)
;;;776      {
;;;777        /* Activate the MAC BackPressure operation */
;;;778        /* In Half duplex: during backpressure, when the MAC receives a new frame,
;;;779        the transmitter starts sending a JAM pattern resulting in a collision */
;;;780        ETH->MACFCR |= ETH_MACFCR_FCBBPA;
000004  9100              STR      r1,[sp,#0]
000006  4909              LDR      r1,|L1.44|
000008  2800              CMP      r0,#0                 ;775
;;;781      }
;;;782      else
;;;783      {
;;;784        /* Desactivate the MAC BackPressure operation */
;;;785        ETH->MACFCR &= ~ETH_MACFCR_FCBBPA;
00000a  6988              LDR      r0,[r1,#0x18]
00000c  d002              BEQ      |L1.20|
00000e  f0400001          ORR      r0,r0,#1              ;780
000012  e001              B        |L1.24|
                  |L1.20|
000014  f0200001          BIC      r0,r0,#1
                  |L1.24|
000018  6188              STR      r0,[r1,#0x18]
;;;786      }
;;;787    
;;;788      /* Wait until the write operation will be taken into account :
;;;789       at least four TX_CLK/RX_CLK clock cycles */
;;;790      tmpreg = ETH->MACFCR;
00001a  6988              LDR      r0,[r1,#0x18]
;;;791      _eth_delay_(ETH_REG_WRITE_DELAY);
00001c  9000              STR      r0,[sp,#0]
00001e  f64f70ff          MOV      r0,#0xffff
000022  f7fffffe          BL       ETH_Delay
;;;792      ETH->MACFCR = tmpreg;
000026  9800              LDR      r0,[sp,#0]
000028  6188              STR      r0,[r1,#0x18]
;;;793    }
00002a  bd08              POP      {r3,pc}
;;;794    
                          ENDP

                  |L1.44|
                          DCD      0x40028000

                          AREA ||i.ETH_CheckFrameReceived||, CODE, READONLY, ALIGN=2

                  ETH_CheckFrameReceived PROC
;;;1299     */
;;;1300   uint32_t ETH_CheckFrameReceived(void)
000000  4a1a              LDR      r2,|L2.108|
;;;1301   {
;;;1302     /* check if last segment */
;;;1303     if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
000002  6851              LDR      r1,[r2,#4]  ; DMARxDescToGet
000004  680b              LDR      r3,[r1,#0]
000006  4610              MOV      r0,r2
000008  2b00              CMP      r3,#0
;;;1304        ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET)) 
;;;1305     {
;;;1306       DMA_RX_FRAME_infos->Seg_Count++;
00000a  6880              LDR      r0,[r0,#8]
00000c  db0d              BLT      |L2.42|
00000e  680b              LDR      r3,[r1,#0]            ;1304
000010  05db              LSLS     r3,r3,#23             ;1304
000012  d50a              BPL      |L2.42|
000014  6883              LDR      r3,[r0,#8]
000016  1c5b              ADDS     r3,r3,#1
000018  6083              STR      r3,[r0,#8]
;;;1307       if (DMA_RX_FRAME_infos->Seg_Count == 1)
00001a  6883              LDR      r3,[r0,#8]
00001c  2b01              CMP      r3,#1
00001e  d100              BNE      |L2.34|
;;;1308       {
;;;1309         DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
000020  6001              STR      r1,[r0,#0]
                  |L2.34|
;;;1310       }
;;;1311       DMA_RX_FRAME_infos->LS_Rx_Desc = DMARxDescToGet;
000022  6851              LDR      r1,[r2,#4]  ; DMARxDescToGet
000024  6041              STR      r1,[r0,#4]
;;;1312       return 1;
000026  2001              MOVS     r0,#1
;;;1313     }
;;;1314   
;;;1315     /* check if first segment */
;;;1316     else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
;;;1317             ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET)&&
;;;1318               ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))
;;;1319     {
;;;1320       DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
;;;1321       DMA_RX_FRAME_infos->LS_Rx_Desc = NULL;
;;;1322       DMA_RX_FRAME_infos->Seg_Count = 1;   
;;;1323       DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
;;;1324     }
;;;1325   
;;;1326     /* check if intermediate segment */ 
;;;1327     else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
;;;1328             ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) == (uint32_t)RESET)&&
;;;1329               ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))
;;;1330     {
;;;1331       (DMA_RX_FRAME_infos->Seg_Count) ++;
;;;1332       DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
;;;1333     } 
;;;1334     return 0;
;;;1335   }
000028  4770              BX       lr
                  |L2.42|
00002a  680b              LDR      r3,[r1,#0]            ;1316
00002c  2b00              CMP      r3,#0                 ;1316
00002e  db0d              BLT      |L2.76|
000030  680b              LDR      r3,[r1,#0]            ;1317
000032  059b              LSLS     r3,r3,#22             ;1317
000034  d50a              BPL      |L2.76|
000036  680b              LDR      r3,[r1,#0]            ;1318
000038  05db              LSLS     r3,r3,#23             ;1318
00003a  d407              BMI      |L2.76|
00003c  6001              STR      r1,[r0,#0]            ;1320
00003e  2100              MOVS     r1,#0                 ;1321
000040  6041              STR      r1,[r0,#4]            ;1321
000042  2101              MOVS     r1,#1                 ;1322
000044  6081              STR      r1,[r0,#8]            ;1322
000046  6850              LDR      r0,[r2,#4]            ;1323  ; DMARxDescToGet
000048  68c0              LDR      r0,[r0,#0xc]          ;1323
00004a  e00c              B        |L2.102|
                  |L2.76|
00004c  680b              LDR      r3,[r1,#0]            ;1327
00004e  2b00              CMP      r3,#0                 ;1327
000050  db0a              BLT      |L2.104|
000052  680b              LDR      r3,[r1,#0]            ;1328
000054  059b              LSLS     r3,r3,#22             ;1328
000056  d407              BMI      |L2.104|
000058  680b              LDR      r3,[r1,#0]            ;1329
00005a  05db              LSLS     r3,r3,#23             ;1329
00005c  d404              BMI      |L2.104|
00005e  6883              LDR      r3,[r0,#8]            ;1331
000060  1c5b              ADDS     r3,r3,#1              ;1331
000062  6083              STR      r3,[r0,#8]            ;1331
000064  68c8              LDR      r0,[r1,#0xc]          ;1332
                  |L2.102|
000066  6050              STR      r0,[r2,#4]            ;1332  ; DMARxDescToGet
                  |L2.104|
000068  2000              MOVS     r0,#0                 ;1334
00006a  4770              BX       lr
;;;1336   
                          ENDP

                  |L2.108|
                          DCD      ||.data||

                          AREA ||i.ETH_DMAClearFlag||, CODE, READONLY, ALIGN=2

                  ETH_DMAClearFlag PROC
;;;1899     */
;;;1900   void ETH_DMAClearFlag(uint32_t ETH_DMA_FLAG)
000000  4901              LDR      r1,|L3.8|
;;;1901   {
;;;1902     /* Check the parameters */
;;;1903     assert_param(IS_ETH_DMA_FLAG(ETH_DMA_FLAG));
;;;1904     
;;;1905     /* Clear the selected ETHERNET DMA FLAG */
;;;1906     ETH->DMASR = (uint32_t) ETH_DMA_FLAG;
000002  6148              STR      r0,[r1,#0x14]
;;;1907   }
000004  4770              BX       lr
;;;1908   
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      0x40029000

                          AREA ||i.ETH_DMAClearITPendingBit||, CODE, READONLY, ALIGN=2

                  ETH_DMAClearITPendingBit PROC
;;;2011     */
;;;2012   void ETH_DMAClearITPendingBit(uint32_t ETH_DMA_IT)
000000  4901              LDR      r1,|L4.8|
;;;2013   {
;;;2014     /* Check the parameters */
;;;2015     assert_param(IS_ETH_DMA_IT(ETH_DMA_IT));
;;;2016     
;;;2017     /* Clear the selected ETHERNET DMA IT */
;;;2018     ETH->DMASR = (uint32_t) ETH_DMA_IT;
000002  6148              STR      r0,[r1,#0x14]
;;;2019   }
000004  4770              BX       lr
;;;2020   
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      0x40029000

                          AREA ||i.ETH_DMAITConfig||, CODE, READONLY, ALIGN=2

                  ETH_DMAITConfig PROC
;;;1932     */
;;;1933   void ETH_DMAITConfig(uint32_t ETH_DMA_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L5.20|
;;;1934   {
;;;1935     /* Check the parameters */
;;;1936     assert_param(IS_ETH_DMA_IT(ETH_DMA_IT));
;;;1937     assert_param(IS_FUNCTIONAL_STATE(NewState));  
;;;1938     
;;;1939     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1940     {
;;;1941       /* Enable the selected ETHERNET DMA interrupts */
;;;1942       ETH->DMAIER |= ETH_DMA_IT;
;;;1943     }
;;;1944     else
;;;1945     {
;;;1946       /* Disable the selected ETHERNET DMA interrupts */
;;;1947       ETH->DMAIER &=(~(uint32_t)ETH_DMA_IT);
000004  69d1              LDR      r1,[r2,#0x1c]
000006  d001              BEQ      |L5.12|
000008  4301              ORRS     r1,r1,r0              ;1942
00000a  e000              B        |L5.14|
                  |L5.12|
00000c  4381              BICS     r1,r1,r0
                  |L5.14|
00000e  61d1              STR      r1,[r2,#0x1c]         ;1942
;;;1948     }
;;;1949   }
000010  4770              BX       lr
;;;1950   
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x40029000

                          AREA ||i.ETH_DMAReceptionCmd||, CODE, READONLY, ALIGN=2

                  ETH_DMAReceptionCmd PROC
;;;2120     */
;;;2121   void ETH_DMAReceptionCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L6.24|
;;;2122   { 
;;;2123     /* Check the parameters */
;;;2124     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2125     
;;;2126     if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;2127     {
;;;2128       /* Enable the DMA reception */
;;;2129       ETH->DMAOMR |= ETH_DMAOMR_SR;  
;;;2130     }
;;;2131     else
;;;2132     {
;;;2133       /* Disable the DMA reception */
;;;2134       ETH->DMAOMR &= ~ETH_DMAOMR_SR;
000004  6988              LDR      r0,[r1,#0x18]
000006  d002              BEQ      |L6.14|
000008  f0400002          ORR      r0,r0,#2              ;2129
00000c  e001              B        |L6.18|
                  |L6.14|
00000e  f0200002          BIC      r0,r0,#2
                  |L6.18|
000012  6188              STR      r0,[r1,#0x18]         ;2129
;;;2135     }
;;;2136   }
000014  4770              BX       lr
;;;2137   
                          ENDP

000016  0000              DCW      0x0000
                  |L6.24|
                          DCD      0x40029000

                          AREA ||i.ETH_DMARxDescChainInit||, CODE, READONLY, ALIGN=2

                  ETH_DMARxDescChainInit PROC
;;;1254     */
;;;1255   void ETH_DMARxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff, uint32_t RxBuffCount)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1256   {
;;;1257     uint32_t i = 0;
;;;1258     ETH_DMADESCTypeDef *DMARxDesc;
;;;1259     
;;;1260     /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
;;;1261     DMARxDescToGet = DMARxDescTab; 
000002  4f12              LDR      r7,|L7.76|
000004  2300              MOVS     r3,#0                 ;1257
;;;1262     /* Fill each DMARxDesc descriptor with the right values */
;;;1263     for(i=0; i < RxBuffCount; i++)
;;;1264     {
;;;1265       /* Get the pointer on the ith member of the Rx Desc list */
;;;1266       DMARxDesc = DMARxDescTab+i;
;;;1267       /* Set Own bit of the Rx descriptor Status */
;;;1268       DMARxDesc->Status = ETH_DMARxDesc_OWN;
000006  f04f4c00          MOV      r12,#0x80000000
;;;1269   
;;;1270       /* Set Buffer1 size and Second Address Chained bit */
;;;1271       DMARxDesc->ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_RX_BUF_SIZE;  
00000a  f2445ef4          MOV      lr,#0x45f4
;;;1272       /* Set Buffer1 address pointer */
;;;1273       DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i*ETH_RX_BUF_SIZE]);
;;;1274   
;;;1275       /* Initialize the next descriptor with the Next Descriptor Polling Enable */
;;;1276       if(i < (RxBuffCount-1))
00000e  1e56              SUBS     r6,r2,#1
000010  6078              STR      r0,[r7,#4]            ;1256  ; DMARxDescToGet
000012  e013              B        |L7.60|
                  |L7.20|
000014  eb001443          ADD      r4,r0,r3,LSL #5       ;1266
000018  f8c4c000          STR      r12,[r4,#0]           ;1268
00001c  ebc315c3          RSB      r5,r3,r3,LSL #7       ;1273
000020  eb050545          ADD      r5,r5,r5,LSL #1       ;1273
000024  eb010585          ADD      r5,r1,r5,LSL #2       ;1273
000028  e9c4e501          STRD     lr,r5,[r4,#4]
00002c  42b3              CMP      r3,r6
00002e  d203              BCS      |L7.56|
;;;1277       {
;;;1278         /* Set next descriptor address register with next descriptor base address */
;;;1279         DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1); 
000030  f1040520          ADD      r5,r4,#0x20
000034  60e5              STR      r5,[r4,#0xc]
000036  e000              B        |L7.58|
                  |L7.56|
;;;1280       }
;;;1281       else
;;;1282       {
;;;1283         /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ 
;;;1284         DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab); 
000038  60e0              STR      r0,[r4,#0xc]
                  |L7.58|
00003a  1c5b              ADDS     r3,r3,#1
                  |L7.60|
00003c  4293              CMP      r3,r2                 ;1263
00003e  d3e9              BCC      |L7.20|
;;;1285       }
;;;1286     }
;;;1287   
;;;1288     /* Set Receive Descriptor List Address Register */
;;;1289     ETH->DMARDLAR = (uint32_t) DMARxDescTab;
000040  4903              LDR      r1,|L7.80|
000042  60c8              STR      r0,[r1,#0xc]
;;;1290   
;;;1291     DMA_RX_FRAME_infos = &RX_Frame_Descriptor;
000044  4803              LDR      r0,|L7.84|
000046  60b8              STR      r0,[r7,#8]  ; DMA_RX_FRAME_infos
;;;1292     
;;;1293   }
000048  bdf0              POP      {r4-r7,pc}
;;;1294   
                          ENDP

00004a  0000              DCW      0x0000
                  |L7.76|
                          DCD      ||.data||
                  |L7.80|
                          DCD      0x40029000
                  |L7.84|
                          DCD      ||area_number.91||

                          AREA ||i.ETH_DMARxDescReceiveITConfig||, CODE, READONLY, ALIGN=1

                  ETH_DMARxDescReceiveITConfig PROC
;;;1706     */
;;;1707   void ETH_DMARxDescReceiveITConfig(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState)
000000  6842              LDR      r2,[r0,#4]
;;;1708   {
000002  b111              CBZ      r1,|L8.10|
;;;1709     /* Check the parameters */
;;;1710     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1711     
;;;1712     if (NewState != DISABLE)
;;;1713     {
;;;1714       /* Enable the DMA Rx Desc receive interrupt */
;;;1715       DMARxDesc->ControlBufferSize &=(~(uint32_t)ETH_DMARxDesc_DIC);
000004  f0224100          BIC      r1,r2,#0x80000000
000008  e001              B        |L8.14|
                  |L8.10|
;;;1716     }
;;;1717     else
;;;1718     {
;;;1719       /* Disable the DMA Rx Desc receive interrupt */
;;;1720       DMARxDesc->ControlBufferSize |= ETH_DMARxDesc_DIC;
00000a  f0424100          ORR      r1,r2,#0x80000000
                  |L8.14|
00000e  6041              STR      r1,[r0,#4]            ;1715
;;;1721     }
;;;1722   }
000010  4770              BX       lr
;;;1723   
                          ENDP


                          AREA ||i.ETH_DMATransmissionCmd||, CODE, READONLY, ALIGN=2

                  ETH_DMATransmissionCmd PROC
;;;2097     */
;;;2098   void ETH_DMATransmissionCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L9.24|
;;;2099   { 
;;;2100     /* Check the parameters */
;;;2101     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2102     
;;;2103     if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;2104     {
;;;2105       /* Enable the DMA transmission */
;;;2106       ETH->DMAOMR |= ETH_DMAOMR_ST;  
;;;2107     }
;;;2108     else
;;;2109     {
;;;2110       /* Disable the DMA transmission */
;;;2111       ETH->DMAOMR &= ~ETH_DMAOMR_ST;
000004  6988              LDR      r0,[r1,#0x18]
000006  d002              BEQ      |L9.14|
000008  f4405000          ORR      r0,r0,#0x2000         ;2106
00000c  e001              B        |L9.18|
                  |L9.14|
00000e  f4205000          BIC      r0,r0,#0x2000
                  |L9.18|
000012  6188              STR      r0,[r1,#0x18]         ;2106
;;;2112     }
;;;2113   }
000014  4770              BX       lr
;;;2114   
                          ENDP

000016  0000              DCW      0x0000
                  |L9.24|
                          DCD      0x40029000

                          AREA ||i.ETH_DMATxDescBufferSizeConfig||, CODE, READONLY, ALIGN=1

                  ETH_DMATxDescBufferSizeConfig PROC
;;;1590     */
;;;1591   void ETH_DMATxDescBufferSizeConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t BufferSize1, uint32_t BufferSize2)
000000  6843              LDR      r3,[r0,#4]
;;;1592   {
;;;1593     /* Check the parameters */
;;;1594     assert_param(IS_ETH_DMATxDESC_BUFFER_SIZE(BufferSize1));
;;;1595     assert_param(IS_ETH_DMATxDESC_BUFFER_SIZE(BufferSize2));
;;;1596     
;;;1597     /* Set the DMA Tx Desc buffer1 and buffer2 sizes values */
;;;1598     DMATxDesc->ControlBufferSize |= (BufferSize1 | (BufferSize2 << ETH_DMATXDESC_BUFFER2_SIZESHIFT));
000002  ea414102          ORR      r1,r1,r2,LSL #16
000006  430b              ORRS     r3,r3,r1
000008  6043              STR      r3,[r0,#4]
;;;1599   }
00000a  4770              BX       lr
;;;1600   
                          ENDP


                          AREA ||i.ETH_DMATxDescCRCCmd||, CODE, READONLY, ALIGN=1

                  ETH_DMATxDescCRCCmd PROC
;;;1518     */
;;;1519   void ETH_DMATxDescCRCCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1520   {
;;;1521     /* Check the parameters */
;;;1522     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1523     
;;;1524     if (NewState != DISABLE)
;;;1525     {
;;;1526       /* Enable the selected DMA Tx Desc CRC */
;;;1527       DMATxDesc->Status &= (~(uint32_t)ETH_DMATxDesc_DC);
;;;1528     }
;;;1529     else
;;;1530     {
;;;1531       /* Disable the selected DMA Tx Desc CRC */
;;;1532       DMATxDesc->Status |= ETH_DMATxDesc_DC; 
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L11.12|
000006  f0216100          BIC      r1,r1,#0x8000000      ;1527
00000a  e001              B        |L11.16|
                  |L11.12|
00000c  f0416100          ORR      r1,r1,#0x8000000
                  |L11.16|
000010  6001              STR      r1,[r0,#0]            ;1527
;;;1533     }
;;;1534   }
000012  4770              BX       lr
;;;1535   
                          ENDP


                          AREA ||i.ETH_DMATxDescChainInit||, CODE, READONLY, ALIGN=2

                  ETH_DMATxDescChainInit PROC
;;;1343     */
;;;1344   void ETH_DMATxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, uint8_t* TxBuff, uint32_t TxBuffCount)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1345   {
;;;1346     uint32_t i = 0;
;;;1347     ETH_DMADESCTypeDef *DMATxDesc;
;;;1348     
;;;1349     /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
;;;1350     DMATxDescToSet = DMATxDescTab;
000002  4c0f              LDR      r4,|L12.64|
000004  2300              MOVS     r3,#0                 ;1346
;;;1351     /* Fill each DMATxDesc descriptor with the right values */   
;;;1352     for(i=0; i < TxBuffCount; i++)
;;;1353     {
;;;1354       /* Get the pointer on the ith member of the Tx Desc list */
;;;1355       DMATxDesc = DMATxDescTab + i;
;;;1356       /* Set Second Address Chained bit */
;;;1357       DMATxDesc->Status = ETH_DMATxDesc_TCH;  
000006  f44f1780          MOV      r7,#0x100000
;;;1358   
;;;1359       /* Set Buffer1 address pointer */
;;;1360       DMATxDesc->Buffer1Addr = (uint32_t)(&TxBuff[i*ETH_TX_BUF_SIZE]);
;;;1361       
;;;1362       /* Initialize the next descriptor with the Next Descriptor Polling Enable */
;;;1363       if(i < (TxBuffCount-1))
00000a  1e56              SUBS     r6,r2,#1
00000c  6020              STR      r0,[r4,#0]            ;1345  ; DMATxDescToSet
00000e  e011              B        |L12.52|
                  |L12.16|
000010  eb001443          ADD      r4,r0,r3,LSL #5       ;1355
000014  6027              STR      r7,[r4,#0]            ;1357
000016  ebc315c3          RSB      r5,r3,r3,LSL #7       ;1360
00001a  eb050545          ADD      r5,r5,r5,LSL #1       ;1360
00001e  eb010585          ADD      r5,r1,r5,LSL #2       ;1360
000022  60a5              STR      r5,[r4,#8]
000024  42b3              CMP      r3,r6
000026  d203              BCS      |L12.48|
;;;1364       {
;;;1365         /* Set next descriptor address register with next descriptor base address */
;;;1366         DMATxDesc->Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1);
000028  f1040520          ADD      r5,r4,#0x20
00002c  60e5              STR      r5,[r4,#0xc]
00002e  e000              B        |L12.50|
                  |L12.48|
;;;1367       }
;;;1368       else
;;;1369       {
;;;1370         /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ 
;;;1371         DMATxDesc->Buffer2NextDescAddr = (uint32_t) DMATxDescTab;  
000030  60e0              STR      r0,[r4,#0xc]
                  |L12.50|
000032  1c5b              ADDS     r3,r3,#1
                  |L12.52|
000034  4293              CMP      r3,r2                 ;1352
000036  d3eb              BCC      |L12.16|
;;;1372       }
;;;1373     }
;;;1374   
;;;1375     /* Set Transmit Desciptor List Address Register */
;;;1376     ETH->DMATDLAR = (uint32_t) DMATxDescTab;
000038  4902              LDR      r1,|L12.68|
00003a  6108              STR      r0,[r1,#0x10]
;;;1377   }
00003c  bdf0              POP      {r4-r7,pc}
;;;1378   
                          ENDP

00003e  0000              DCW      0x0000
                  |L12.64|
                          DCD      ||.data||
                  |L12.68|
                          DCD      0x40029000

                          AREA ||i.ETH_DMATxDescChecksumInsertionConfig||, CODE, READONLY, ALIGN=1

                  ETH_DMATxDescChecksumInsertionConfig PROC
;;;1502     */
;;;1503   void ETH_DMATxDescChecksumInsertionConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_Checksum)
000000  6802              LDR      r2,[r0,#0]
;;;1504   {
;;;1505     /* Check the parameters */
;;;1506     assert_param(IS_ETH_DMA_TXDESC_CHECKSUM(DMATxDesc_Checksum));
;;;1507     
;;;1508     /* Set the selected DMA Tx desc checksum insertion control */
;;;1509     DMATxDesc->Status |= DMATxDesc_Checksum;
000002  430a              ORRS     r2,r2,r1
000004  6002              STR      r2,[r0,#0]
;;;1510   }
000006  4770              BX       lr
;;;1511   
                          ENDP


                          AREA ||i.ETH_DMATxDescFrameSegmentConfig||, CODE, READONLY, ALIGN=1

                  ETH_DMATxDescFrameSegmentConfig PROC
;;;1482     */
;;;1483   void ETH_DMATxDescFrameSegmentConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_FrameSegment)
000000  6802              LDR      r2,[r0,#0]
;;;1484   {
;;;1485     /* Check the parameters */
;;;1486     assert_param(IS_ETH_DMA_TXDESC_SEGMENT(DMATxDesc_FrameSegment));
;;;1487     
;;;1488     /* Selects the DMA Tx Desc Frame segment */
;;;1489     DMATxDesc->Status |= DMATxDesc_FrameSegment;
000002  430a              ORRS     r2,r2,r1
000004  6002              STR      r2,[r0,#0]
;;;1490   }
000006  4770              BX       lr
;;;1491   
                          ENDP


                          AREA ||i.ETH_DMATxDescSecondAddressChainedCmd||, CODE, READONLY, ALIGN=1

                  ETH_DMATxDescSecondAddressChainedCmd PROC
;;;1542     */
;;;1543   void ETH_DMATxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1544   {
;;;1545     /* Check the parameters */
;;;1546     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1547     
;;;1548     if (NewState != DISABLE)
;;;1549     {
;;;1550       /* Enable the selected DMA Tx Desc second address chained */
;;;1551       DMATxDesc->Status |= ETH_DMATxDesc_TCH;  
;;;1552     }
;;;1553     else
;;;1554     {
;;;1555       /* Disable the selected DMA Tx Desc second address chained */
;;;1556       DMATxDesc->Status &=(~(uint32_t)ETH_DMATxDesc_TCH); 
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L15.12|
000006  f4411180          ORR      r1,r1,#0x100000       ;1551
00000a  e001              B        |L15.16|
                  |L15.12|
00000c  f4211180          BIC      r1,r1,#0x100000
                  |L15.16|
000010  6001              STR      r1,[r0,#0]            ;1551
;;;1557     }
;;;1558   }
000012  4770              BX       lr
;;;1559   
                          ENDP


                          AREA ||i.ETH_DMATxDescShortFramePaddingCmd||, CODE, READONLY, ALIGN=1

                  ETH_DMATxDescShortFramePaddingCmd PROC
;;;1566     */
;;;1567   void ETH_DMATxDescShortFramePaddingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1568   {
;;;1569     /* Check the parameters */
;;;1570     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1571     
;;;1572     if (NewState != DISABLE)
;;;1573     {
;;;1574       /* Enable the selected DMA Tx Desc padding for frame shorter than 64 bytes */
;;;1575       DMATxDesc->Status &= (~(uint32_t)ETH_DMATxDesc_DP);
;;;1576     }
;;;1577     else
;;;1578     {
;;;1579       /* Disable the selected DMA Tx Desc padding for frame shorter than 64 bytes*/
;;;1580       DMATxDesc->Status |= ETH_DMATxDesc_DP; 
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L16.12|
000006  f0216180          BIC      r1,r1,#0x4000000      ;1575
00000a  e001              B        |L16.16|
                  |L16.12|
00000c  f0416180          ORR      r1,r1,#0x4000000
                  |L16.16|
000010  6001              STR      r1,[r0,#0]            ;1575
;;;1581     }
;;;1582   }
000012  4770              BX       lr
;;;1583   
                          ENDP


                          AREA ||i.ETH_DMATxDescTransmitITConfig||, CODE, READONLY, ALIGN=1

                  ETH_DMATxDescTransmitITConfig PROC
;;;1456     */
;;;1457   void ETH_DMATxDescTransmitITConfig(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1458   {
;;;1459     /* Check the parameters */
;;;1460     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1461     
;;;1462     if (NewState != DISABLE)
;;;1463     {
;;;1464       /* Enable the DMA Tx Desc Transmit interrupt */
;;;1465       DMATxDesc->Status |= ETH_DMATxDesc_IC;
;;;1466     }
;;;1467     else
;;;1468     {
;;;1469       /* Disable the DMA Tx Desc Transmit interrupt */
;;;1470       DMATxDesc->Status &=(~(uint32_t)ETH_DMATxDesc_IC);
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L17.12|
000006  f0414180          ORR      r1,r1,#0x40000000     ;1465
00000a  e001              B        |L17.16|
                  |L17.12|
00000c  f0214180          BIC      r1,r1,#0x40000000
                  |L17.16|
000010  6001              STR      r1,[r0,#0]            ;1465
;;;1471     }
;;;1472   }
000012  4770              BX       lr
;;;1473   
                          ENDP


                          AREA ||i.ETH_DeInit||, CODE, READONLY, ALIGN=1

                  ETH_DeInit PROC
;;;117      */
;;;118    void ETH_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;119    {
;;;120      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_ETH_MAC, ENABLE);
000002  2101              MOVS     r1,#1
000004  064c              LSLS     r4,r1,#25
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       RCC_AHB1PeriphResetCmd
;;;121      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_ETH_MAC, DISABLE);
00000c  4620              MOV      r0,r4
00000e  e8bd4010          POP      {r4,lr}
000012  2100              MOVS     r1,#0
000014  f7ffbffe          B.W      RCC_AHB1PeriphResetCmd
;;;122    }
;;;123    
                          ENDP


                          AREA ||i.ETH_Delay||, CODE, READONLY, ALIGN=1

                  ETH_Delay PROC
;;;98       */
;;;99     void ETH_Delay(__IO uint32_t nCount)
000000  b501              PUSH     {r0,lr}
;;;100    {
000002  b081              SUB      sp,sp,#4
;;;101      __IO uint32_t index = 0; 
;;;102      for(index = nCount; index != 0; index--)
000004  9801              LDR      r0,[sp,#4]
                  |L19.6|
000006  9000              STR      r0,[sp,#0]
000008  2800              CMP      r0,#0
00000a  d001              BEQ      |L19.16|
00000c  1e40              SUBS     r0,r0,#1
00000e  e7fa              B        |L19.6|
                  |L19.16|
;;;103      {
;;;104      }
;;;105    }
000010  bd0c              POP      {r2,r3,pc}
;;;106    #endif /* USE_Delay*/
                          ENDP


                          AREA ||i.ETH_EnhancedDescriptorCmd||, CODE, READONLY, ALIGN=2

                  ETH_EnhancedDescriptorCmd PROC
;;;1776     */
;;;1777   void ETH_EnhancedDescriptorCmd(FunctionalState NewState)
000000  b508              PUSH     {r3,lr}
;;;1778   { 
;;;1779     __IO uint32_t tmpreg = 0;
000002  2100              MOVS     r1,#0
;;;1780     /* Check the parameters */
;;;1781     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1782     
;;;1783     if (NewState != DISABLE)
;;;1784     {
;;;1785       /* Enable enhanced descriptor structure */
;;;1786       ETH->DMABMR |= ETH_DMABMR_EDE;
000004  9100              STR      r1,[sp,#0]
000006  4909              LDR      r1,|L20.44|
000008  2800              CMP      r0,#0                 ;1783
;;;1787     }
;;;1788     else
;;;1789     {
;;;1790       /* Disable enhanced descriptor structure */
;;;1791       ETH->DMABMR &= ~ETH_DMABMR_EDE;
00000a  6808              LDR      r0,[r1,#0]
00000c  d002              BEQ      |L20.20|
00000e  f0400080          ORR      r0,r0,#0x80           ;1786
000012  e001              B        |L20.24|
                  |L20.20|
000014  f0200080          BIC      r0,r0,#0x80
                  |L20.24|
000018  6008              STR      r0,[r1,#0]
;;;1792     }
;;;1793     
;;;1794     /* Wait until the write operation will be taken into account :
;;;1795      at least four TX_CLK/RX_CLK clock cycles */
;;;1796     tmpreg = ETH->DMABMR;
00001a  6808              LDR      r0,[r1,#0]
;;;1797     _eth_delay_(ETH_REG_WRITE_DELAY);
00001c  9000              STR      r0,[sp,#0]
00001e  f64f70ff          MOV      r0,#0xffff
000022  f7fffffe          BL       ETH_Delay
;;;1798     ETH->DMABMR = tmpreg;
000026  9800              LDR      r0,[sp,#0]
000028  6008              STR      r0,[r1,#0]
;;;1799   }
00002a  bd08              POP      {r3,pc}
;;;1800   #endif /* USE_ENHANCED_DMA_DESCRIPTORS */
                          ENDP

                  |L20.44|
                          DCD      0x40029000

                          AREA ||i.ETH_FlushTransmitFIFO||, CODE, READONLY, ALIGN=2

                  ETH_FlushTransmitFIFO PROC
;;;2059     */
;;;2060   void ETH_FlushTransmitFIFO(void)
000000  4907              LDR      r1,|L21.32|
;;;2061   {
000002  b508              PUSH     {r3,lr}
;;;2062     __IO uint32_t tmpreg = 0;
;;;2063     /* Set the Flush Transmit FIFO bit */
;;;2064     ETH->DMAOMR |= ETH_DMAOMR_FTF;
000004  6988              LDR      r0,[r1,#0x18]
000006  f4401080          ORR      r0,r0,#0x100000
00000a  6188              STR      r0,[r1,#0x18]
;;;2065     
;;;2066     /* Wait until the write operation will be taken into account :
;;;2067      at least four TX_CLK/RX_CLK clock cycles */
;;;2068     tmpreg = ETH->DMAOMR;
00000c  6988              LDR      r0,[r1,#0x18]
;;;2069     _eth_delay_(ETH_REG_WRITE_DELAY);
00000e  9000              STR      r0,[sp,#0]
000010  f64f70ff          MOV      r0,#0xffff
000014  f7fffffe          BL       ETH_Delay
;;;2070     ETH->DMAOMR = tmpreg;
000018  9800              LDR      r0,[sp,#0]
00001a  6188              STR      r0,[r1,#0x18]
;;;2071   }
00001c  bd08              POP      {r3,pc}
;;;2072   
                          ENDP

00001e  0000              DCW      0x0000
                  |L21.32|
                          DCD      0x40029000

                          AREA ||i.ETH_GetBufferUnavailableMissedFrameCounter||, CODE, READONLY, ALIGN=2

                  ETH_GetBufferUnavailableMissedFrameCounter PROC
;;;2177     */
;;;2178   uint32_t ETH_GetBufferUnavailableMissedFrameCounter(void)
000000  4801              LDR      r0,|L22.8|
;;;2179   {
;;;2180     return ((uint32_t)(ETH->DMAMFBOCR) & ETH_DMAMFBOCR_MFC);
000002  6a00              LDR      r0,[r0,#0x20]
000004  b280              UXTH     r0,r0
;;;2181   }
000006  4770              BX       lr
;;;2182   
                          ENDP

                  |L22.8|
                          DCD      0x40029000

                          AREA ||i.ETH_GetCurrentRxBufferAddress||, CODE, READONLY, ALIGN=2

                  ETH_GetCurrentRxBufferAddress PROC
;;;2217     */
;;;2218   uint32_t ETH_GetCurrentRxBufferAddress(void)
000000  4801              LDR      r0,|L23.8|
;;;2219   {
;;;2220     return ((uint32_t)(ETH->DMACHRBAR));
000002  6d40              LDR      r0,[r0,#0x54]
;;;2221   }
000004  4770              BX       lr
;;;2222   
                          ENDP

000006  0000              DCW      0x0000
                  |L23.8|
                          DCD      0x40029000

                          AREA ||i.ETH_GetCurrentRxDescStartAddress||, CODE, READONLY, ALIGN=2

                  ETH_GetCurrentRxDescStartAddress PROC
;;;2197     */
;;;2198   uint32_t ETH_GetCurrentRxDescStartAddress(void)
000000  4801              LDR      r0,|L24.8|
;;;2199   {
;;;2200     return ((uint32_t)(ETH->DMACHRDR));
000002  6cc0              LDR      r0,[r0,#0x4c]
;;;2201   }
000004  4770              BX       lr
;;;2202   
                          ENDP

000006  0000              DCW      0x0000
                  |L24.8|
                          DCD      0x40029000

                          AREA ||i.ETH_GetCurrentTxBufferAddress||, CODE, READONLY, ALIGN=2

                  ETH_GetCurrentTxBufferAddress PROC
;;;2207     */
;;;2208   uint32_t ETH_GetCurrentTxBufferAddress(void)
000000  4801              LDR      r0,|L25.8|
;;;2209   {
;;;2210     return ((uint32_t)(ETH->DMACHTBAR));
000002  6d00              LDR      r0,[r0,#0x50]
;;;2211   }
000004  4770              BX       lr
;;;2212   
                          ENDP

000006  0000              DCW      0x0000
                  |L25.8|
                          DCD      0x40029000

                          AREA ||i.ETH_GetCurrentTxDescStartAddress||, CODE, READONLY, ALIGN=2

                  ETH_GetCurrentTxDescStartAddress PROC
;;;2187     */
;;;2188   uint32_t ETH_GetCurrentTxDescStartAddress(void)
000000  4801              LDR      r0,|L26.8|
;;;2189   {
;;;2190     return ((uint32_t)(ETH->DMACHTDR));
000002  6c80              LDR      r0,[r0,#0x48]
;;;2191   }
000004  4770              BX       lr
;;;2192   
                          ENDP

000006  0000              DCW      0x0000
                  |L26.8|
                          DCD      0x40029000

                          AREA ||i.ETH_GetDMAFlagStatus||, CODE, READONLY, ALIGN=2

                  ETH_GetDMAFlagStatus PROC
;;;1862     */
;;;1863   FlagStatus ETH_GetDMAFlagStatus(uint32_t ETH_DMA_FLAG)
000000  4a03              LDR      r2,|L27.16|
;;;1864   {  
000002  4601              MOV      r1,r0
;;;1865     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1866     /* Check the parameters */
;;;1867     assert_param(IS_ETH_DMA_GET_IT(ETH_DMA_FLAG));
;;;1868     if ((ETH->DMASR & ETH_DMA_FLAG) != (uint32_t)RESET)
000006  6952              LDR      r2,[r2,#0x14]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L27.14|
;;;1869     {
;;;1870       bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L27.14|
;;;1871     }
;;;1872     else
;;;1873     {
;;;1874       bitstatus = RESET;
;;;1875     }
;;;1876     return bitstatus;
;;;1877   }
00000e  4770              BX       lr
;;;1878   
                          ENDP

                  |L27.16|
                          DCD      0x40029000

                          AREA ||i.ETH_GetDMAITStatus||, CODE, READONLY, ALIGN=2

                  ETH_GetDMAITStatus PROC
;;;1974     */
;;;1975   ITStatus ETH_GetDMAITStatus(uint32_t ETH_DMA_IT)
000000  4a03              LDR      r2,|L28.16|
;;;1976   {  
000002  4601              MOV      r1,r0
;;;1977     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1978     /* Check the parameters */
;;;1979     assert_param(IS_ETH_DMA_GET_IT(ETH_DMA_IT));
;;;1980     if ((ETH->DMASR & ETH_DMA_IT) != (uint32_t)RESET)
000006  6952              LDR      r2,[r2,#0x14]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L28.14|
;;;1981     {
;;;1982       bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L28.14|
;;;1983     }
;;;1984     else
;;;1985     {
;;;1986       bitstatus = RESET;
;;;1987     }
;;;1988     return bitstatus;
;;;1989   }
00000e  4770              BX       lr
;;;1990   
                          ENDP

                  |L28.16|
                          DCD      0x40029000

                          AREA ||i.ETH_GetDMAOverflowStatus||, CODE, READONLY, ALIGN=2

                  ETH_GetDMAOverflowStatus PROC
;;;2145     */
;;;2146   FlagStatus ETH_GetDMAOverflowStatus(uint32_t ETH_DMA_Overflow)
000000  4a03              LDR      r2,|L29.16|
;;;2147   {
000002  4601              MOV      r1,r0
;;;2148     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;2149     /* Check the parameters */
;;;2150     assert_param(IS_ETH_DMA_GET_OVERFLOW(ETH_DMA_Overflow));
;;;2151     
;;;2152     if ((ETH->DMAMFBOCR & ETH_DMA_Overflow) != (uint32_t)RESET)
000006  6a12              LDR      r2,[r2,#0x20]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L29.14|
;;;2153     {
;;;2154       bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L29.14|
;;;2155     }
;;;2156     else
;;;2157     {
;;;2158       bitstatus = RESET;
;;;2159     }
;;;2160     return bitstatus;
;;;2161   }
00000e  4770              BX       lr
;;;2162   
                          ENDP

                  |L29.16|
                          DCD      0x40029000

                          AREA ||i.ETH_GetDMAPTPRxDescExtendedFlagStatus||, CODE, READONLY, ALIGN=1

                  ETH_GetDMAPTPRxDescExtendedFlagStatus PROC
;;;1658     */
;;;1659   FlagStatus ETH_GetDMAPTPRxDescExtendedFlagStatus(ETH_DMADESCTypeDef *DMAPTPRxDesc, uint32_t ETH_DMAPTPRxDescExtendedFlag)
000000  4602              MOV      r2,r0
;;;1660   {
;;;1661     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1662   
;;;1663     /* Check the parameters */
;;;1664     assert_param(IS_ETH_DMAPTPRxDESC_GET_EXTENDED_FLAG(ETH_DMAPTPRxDescExtendedFlag));
;;;1665   
;;;1666     if ((DMAPTPRxDesc->ExtendedStatus & ETH_DMAPTPRxDescExtendedFlag) != (uint32_t)RESET)
000004  6912              LDR      r2,[r2,#0x10]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L30.12|
;;;1667     {
;;;1668       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L30.12|
;;;1669     }
;;;1670     else
;;;1671     {
;;;1672       bitstatus = RESET;
;;;1673     }
;;;1674     return bitstatus;
;;;1675   }
00000c  4770              BX       lr
;;;1676   #endif /* USE_ENHANCED_DMA_DESCRIPTORS */
                          ENDP


                          AREA ||i.ETH_GetDMARxDescBufferSize||, CODE, READONLY, ALIGN=1

                  ETH_GetDMARxDescBufferSize PROC
;;;1732     */
;;;1733   uint32_t ETH_GetDMARxDescBufferSize(ETH_DMADESCTypeDef *DMARxDesc, uint32_t DMARxDesc_Buffer)
000000  6840              LDR      r0,[r0,#4]
;;;1734   {
000002  b111              CBZ      r1,|L31.10|
;;;1735     /* Check the parameters */
;;;1736     assert_param(IS_ETH_DMA_RXDESC_BUFFER(DMARxDesc_Buffer));
;;;1737     
;;;1738     if(DMARxDesc_Buffer != ETH_DMARxDesc_Buffer1)
;;;1739     {
;;;1740       /* Return the DMA Rx Desc buffer2 size */
;;;1741       return ((DMARxDesc->ControlBufferSize & ETH_DMARxDesc_RBS2) >> ETH_DMARXDESC_BUFFER2_SIZESHIFT); 
000004  f3c0400c          UBFX     r0,r0,#16,#13
;;;1742     }
;;;1743     else
;;;1744     {
;;;1745       /* Return the DMA Rx Desc buffer1 size */
;;;1746       return (DMARxDesc->ControlBufferSize & ETH_DMARxDesc_RBS1); 
;;;1747     }
;;;1748   }
000008  4770              BX       lr
                  |L31.10|
00000a  f3c0000c          UBFX     r0,r0,#0,#13          ;1746
00000e  4770              BX       lr
;;;1749   
                          ENDP


                          AREA ||i.ETH_GetDMARxDescFlagStatus||, CODE, READONLY, ALIGN=1

                  ETH_GetDMARxDescFlagStatus PROC
;;;1625     */
;;;1626   FlagStatus ETH_GetDMARxDescFlagStatus(ETH_DMADESCTypeDef *DMARxDesc, uint32_t ETH_DMARxDescFlag)
000000  4602              MOV      r2,r0
;;;1627   {
;;;1628     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1629     /* Check the parameters */
;;;1630     assert_param(IS_ETH_DMARxDESC_GET_FLAG(ETH_DMARxDescFlag));
;;;1631     if ((DMARxDesc->Status & ETH_DMARxDescFlag) != (uint32_t)RESET)
000004  6812              LDR      r2,[r2,#0]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L32.12|
;;;1632     {
;;;1633       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L32.12|
;;;1634     }
;;;1635     else
;;;1636     {
;;;1637       bitstatus = RESET;
;;;1638     }
;;;1639     return bitstatus;
;;;1640   }
00000c  4770              BX       lr
;;;1641   
                          ENDP


                          AREA ||i.ETH_GetDMARxDescFrameLength||, CODE, READONLY, ALIGN=1

                  ETH_GetDMARxDescFrameLength PROC
;;;1693     */
;;;1694   uint32_t ETH_GetDMARxDescFrameLength(ETH_DMADESCTypeDef *DMARxDesc)
000000  6800              LDR      r0,[r0,#0]
;;;1695   {
;;;1696     /* Return the Receive descriptor frame length */
;;;1697     return ((DMARxDesc->Status & ETH_DMARxDesc_FL) >> ETH_DMARXDESC_FRAME_LENGTHSHIFT);
000002  f3c0400d          UBFX     r0,r0,#16,#14
;;;1698   }
000006  4770              BX       lr
;;;1699   
                          ENDP


                          AREA ||i.ETH_GetDMATxDescCollisionCount||, CODE, READONLY, ALIGN=1

                  ETH_GetDMATxDescCollisionCount PROC
;;;1432     */
;;;1433   uint32_t ETH_GetDMATxDescCollisionCount(ETH_DMADESCTypeDef *DMATxDesc)
000000  6800              LDR      r0,[r0,#0]
;;;1434   {
;;;1435     /* Return the Receive descriptor frame length */
;;;1436     return ((DMATxDesc->Status & ETH_DMATxDesc_CC) >> ETH_DMATXDESC_COLLISION_COUNTSHIFT);
000002  f3c000c3          UBFX     r0,r0,#3,#4
;;;1437   }
000006  4770              BX       lr
;;;1438   
                          ENDP


                          AREA ||i.ETH_GetDMATxDescFlagStatus||, CODE, READONLY, ALIGN=1

                  ETH_GetDMATxDescFlagStatus PROC
;;;1410     */
;;;1411   FlagStatus ETH_GetDMATxDescFlagStatus(ETH_DMADESCTypeDef *DMATxDesc, uint32_t ETH_DMATxDescFlag)
000000  4602              MOV      r2,r0
;;;1412   {
;;;1413     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1414     /* Check the parameters */
;;;1415     assert_param(IS_ETH_DMATxDESC_GET_FLAG(ETH_DMATxDescFlag));
;;;1416     
;;;1417     if ((DMATxDesc->Status & ETH_DMATxDescFlag) != (uint32_t)RESET)
000004  6812              LDR      r2,[r2,#0]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L35.12|
;;;1418     {
;;;1419       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L35.12|
;;;1420     }
;;;1421     else
;;;1422     {
;;;1423       bitstatus = RESET;
;;;1424     }
;;;1425     return bitstatus;
;;;1426   }
00000c  4770              BX       lr
;;;1427   
                          ENDP


                          AREA ||i.ETH_GetFlowControlBusyStatus||, CODE, READONLY, ALIGN=2

                  ETH_GetFlowControlBusyStatus PROC
;;;729      */
;;;730    FlagStatus ETH_GetFlowControlBusyStatus(void)
000000  4903              LDR      r1,|L36.16|
;;;731    {
;;;732      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;733      /* The Flow Control register should not be written to until this bit is cleared */
;;;734      if ((ETH->MACFCR & ETH_MACFCR_FCBBPA) != (uint32_t)RESET)
000004  6989              LDR      r1,[r1,#0x18]
000006  07c9              LSLS     r1,r1,#31
000008  d000              BEQ      |L36.12|
;;;735      {
;;;736        bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L36.12|
;;;737      }
;;;738      else
;;;739      {
;;;740        bitstatus = RESET;
;;;741      }
;;;742      return bitstatus;
;;;743    }
00000c  4770              BX       lr
;;;744    
                          ENDP

00000e  0000              DCW      0x0000
                  |L36.16|
                          DCD      0x40028000

                          AREA ||i.ETH_GetFlushTransmitFIFOStatus||, CODE, READONLY, ALIGN=2

                  ETH_GetFlushTransmitFIFOStatus PROC
;;;2077     */
;;;2078   FlagStatus ETH_GetFlushTransmitFIFOStatus(void)
000000  4903              LDR      r1,|L37.16|
;;;2079   {   
;;;2080     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;2081     if ((ETH->DMAOMR & ETH_DMAOMR_FTF) != (uint32_t)RESET)
000004  6989              LDR      r1,[r1,#0x18]
000006  02c9              LSLS     r1,r1,#11
000008  d500              BPL      |L37.12|
;;;2082     {
;;;2083       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L37.12|
;;;2084     }
;;;2085     else
;;;2086     {
;;;2087       bitstatus = RESET;
;;;2088     }
;;;2089     return bitstatus; 
;;;2090   }
00000c  4770              BX       lr
;;;2091   
                          ENDP

00000e  0000              DCW      0x0000
                  |L37.16|
                          DCD      0x40029000

                          AREA ||i.ETH_GetMACAddress||, CODE, READONLY, ALIGN=2

                  ETH_GetMACAddress PROC
;;;916      */
;;;917    void ETH_GetMACAddress(uint32_t MacAddr, uint8_t *Addr)
000000  4a07              LDR      r2,|L38.32|
;;;918    {
;;;919      uint32_t tmpreg;
;;;920      /* Check the parameters */
;;;921      assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
;;;922      
;;;923      /* Get the selected MAC address high register */
;;;924      tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr));
000002  4402              ADD      r2,r2,r0
000004  6c10              LDR      r0,[r2,#0x40]
;;;925      
;;;926      /* Calculate the selected MAC address buffer */
;;;927      Addr[5] = ((tmpreg >> 8) & (uint8_t)0xFF);
000006  0a03              LSRS     r3,r0,#8
000008  714b              STRB     r3,[r1,#5]
;;;928      Addr[4] = (tmpreg & (uint8_t)0xFF);
00000a  7108              STRB     r0,[r1,#4]
;;;929      /* Load the selected MAC address low register */
;;;930      tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr));
00000c  6c50              LDR      r0,[r2,#0x44]
;;;931      /* Calculate the selected MAC address buffer */
;;;932      Addr[3] = ((tmpreg >> 24) & (uint8_t)0xFF);
00000e  0e02              LSRS     r2,r0,#24
000010  70ca              STRB     r2,[r1,#3]
;;;933      Addr[2] = ((tmpreg >> 16) & (uint8_t)0xFF);
000012  0c02              LSRS     r2,r0,#16
000014  708a              STRB     r2,[r1,#2]
;;;934      Addr[1] = ((tmpreg >> 8 ) & (uint8_t)0xFF);
000016  0a02              LSRS     r2,r0,#8
000018  704a              STRB     r2,[r1,#1]
;;;935      Addr[0] = (tmpreg & (uint8_t)0xFF);
00001a  7008              STRB     r0,[r1,#0]
;;;936    }
00001c  4770              BX       lr
;;;937    
                          ENDP

00001e  0000              DCW      0x0000
                  |L38.32|
                          DCD      0x40028000

                          AREA ||i.ETH_GetMACFlagStatus||, CODE, READONLY, ALIGN=2

                  ETH_GetMACFlagStatus PROC
;;;805      */
;;;806    FlagStatus ETH_GetMACFlagStatus(uint32_t ETH_MAC_FLAG)
000000  4a03              LDR      r2,|L39.16|
;;;807    {
000002  4601              MOV      r1,r0
;;;808      FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;809      /* Check the parameters */
;;;810      assert_param(IS_ETH_MAC_GET_FLAG(ETH_MAC_FLAG)); 
;;;811      if ((ETH->MACSR & ETH_MAC_FLAG) != (uint32_t)RESET)
000006  6b92              LDR      r2,[r2,#0x38]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L39.14|
;;;812      {
;;;813        bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L39.14|
;;;814      }
;;;815      else
;;;816      {
;;;817        bitstatus = RESET;
;;;818      }
;;;819      return bitstatus;
;;;820    }
00000e  4770              BX       lr
;;;821    
                          ENDP

                  |L39.16|
                          DCD      0x40028000

                          AREA ||i.ETH_GetMACITStatus||, CODE, READONLY, ALIGN=2

                  ETH_GetMACITStatus PROC
;;;832      */
;;;833    ITStatus ETH_GetMACITStatus(uint32_t ETH_MAC_IT)
000000  4a03              LDR      r2,|L40.16|
;;;834    {
000002  4601              MOV      r1,r0
;;;835      ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;836      /* Check the parameters */
;;;837      assert_param(IS_ETH_MAC_GET_IT(ETH_MAC_IT)); 
;;;838      if ((ETH->MACSR & ETH_MAC_IT) != (uint32_t)RESET)
000006  6b92              LDR      r2,[r2,#0x38]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L40.14|
;;;839      {
;;;840        bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L40.14|
;;;841      }
;;;842      else
;;;843      {
;;;844        bitstatus = RESET;
;;;845      }
;;;846      return bitstatus;
;;;847    }
00000e  4770              BX       lr
;;;848    
                          ENDP

                  |L40.16|
                          DCD      0x40028000

                          AREA ||i.ETH_GetMMCITStatus||, CODE, READONLY, ALIGN=2

                  ETH_GetMMCITStatus PROC
;;;2764     */
;;;2765   ITStatus ETH_GetMMCITStatus(uint32_t ETH_MMC_IT)
000000  2100              MOVS     r1,#0
;;;2766   {
;;;2767     ITStatus bitstatus = RESET;
;;;2768     /* Check the parameters */
;;;2769     assert_param(IS_ETH_MMC_GET_IT(ETH_MMC_IT)); 
;;;2770     
;;;2771     if ((ETH_MMC_IT & (uint32_t)0x10000000) != (uint32_t)RESET)
;;;2772     {
;;;2773       /* ETHERNET MMC Rx interrupts selected */
;;;2774       /* Check if the ETHERNET MMC Rx selected interrupt is enabled and occurred */ 
;;;2775       if ((((ETH->MMCRIR & ETH_MMC_IT) != (uint32_t)RESET)) && ((ETH->MMCRIMR & ETH_MMC_IT) == (uint32_t)RESET))
000002  4a08              LDR      r2,|L41.36|
000004  00c3              LSLS     r3,r0,#3              ;2771
000006  d502              BPL      |L41.14|
000008  f8d23104          LDR      r3,[r2,#0x104]
00000c  e001              B        |L41.18|
                  |L41.14|
;;;2776       {
;;;2777         bitstatus = SET;
;;;2778       }
;;;2779       else
;;;2780       {
;;;2781         bitstatus = RESET;
;;;2782       }
;;;2783     }
;;;2784     else
;;;2785     {
;;;2786       /* ETHERNET MMC Tx interrupts selected */
;;;2787       /* Check if the ETHERNET MMC Tx selected interrupt is enabled and occurred */  
;;;2788       if ((((ETH->MMCTIR & ETH_MMC_IT) != (uint32_t)RESET)) && ((ETH->MMCRIMR & ETH_MMC_IT) == (uint32_t)RESET))
00000e  f8d23108          LDR      r3,[r2,#0x108]
                  |L41.18|
000012  4203              TST      r3,r0
000014  d004              BEQ      |L41.32|
000016  f8d2210c          LDR      r2,[r2,#0x10c]
00001a  4202              TST      r2,r0
00001c  d100              BNE      |L41.32|
;;;2789       {
;;;2790         bitstatus = SET;
00001e  2101              MOVS     r1,#1
                  |L41.32|
;;;2791       }
;;;2792       else
;;;2793       {
;;;2794         bitstatus = RESET;
;;;2795       }  
;;;2796     }    
;;;2797     
;;;2798     return bitstatus;
000020  4608              MOV      r0,r1
;;;2799   }
000022  4770              BX       lr
;;;2800   
                          ENDP

                  |L41.36|
                          DCD      0x40028000

                          AREA ||i.ETH_GetMMCRegister||, CODE, READONLY, ALIGN=2

                  ETH_GetMMCRegister PROC
;;;2817     */
;;;2818   uint32_t ETH_GetMMCRegister(uint32_t ETH_MMCReg)
000000  4901              LDR      r1,|L42.8|
;;;2819   {
;;;2820     /* Check the parameters */
;;;2821     assert_param(IS_ETH_MMC_REGISTER(ETH_MMCReg));
;;;2822     
;;;2823     /* Return the selected register value */
;;;2824     return (*(__IO uint32_t *)(ETH_MAC_BASE + ETH_MMCReg));
000002  5840              LDR      r0,[r0,r1]
;;;2825   }
000004  4770              BX       lr
;;;2826   
                          ENDP

000006  0000              DCW      0x0000
                  |L42.8|
                          DCD      0x40028000

                          AREA ||i.ETH_GetPMTFlagStatus||, CODE, READONLY, ALIGN=2

                  ETH_GetPMTFlagStatus PROC
;;;2483     */
;;;2484   FlagStatus ETH_GetPMTFlagStatus(uint32_t ETH_PMT_FLAG)
000000  4a03              LDR      r2,|L43.16|
;;;2485   {
000002  4601              MOV      r1,r0
;;;2486     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;2487     /* Check the parameters */
;;;2488     assert_param(IS_ETH_PMT_GET_FLAG(ETH_PMT_FLAG));
;;;2489     
;;;2490     if ((ETH->MACPMTCSR & ETH_PMT_FLAG) != (uint32_t)RESET)
000006  6ad2              LDR      r2,[r2,#0x2c]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L43.14|
;;;2491     {
;;;2492       bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L43.14|
;;;2493     }
;;;2494     else
;;;2495     {
;;;2496       bitstatus = RESET;
;;;2497     }
;;;2498     return bitstatus;
;;;2499   }
00000e  4770              BX       lr
;;;2500   
                          ENDP

                  |L43.16|
                          DCD      0x40028000

                          AREA ||i.ETH_GetReceiveProcessState||, CODE, READONLY, ALIGN=2

                  ETH_GetReceiveProcessState PROC
;;;2049     */
;;;2050   uint32_t ETH_GetReceiveProcessState(void)
000000  4802              LDR      r0,|L44.12|
;;;2051   {
;;;2052     return ((uint32_t)(ETH->DMASR & ETH_DMASR_RS)); 
000002  6940              LDR      r0,[r0,#0x14]
000004  f0000040          AND      r0,r0,#0x40
;;;2053   }
000008  4770              BX       lr
;;;2054   
                          ENDP

00000a  0000              DCW      0x0000
                  |L44.12|
                          DCD      0x40029000

                          AREA ||i.ETH_GetRxOverflowMissedFrameCounter||, CODE, READONLY, ALIGN=2

                  ETH_GetRxOverflowMissedFrameCounter PROC
;;;2167     */
;;;2168   uint32_t ETH_GetRxOverflowMissedFrameCounter(void)
000000  4802              LDR      r0,|L45.12|
;;;2169   {
;;;2170     return ((uint32_t)((ETH->DMAMFBOCR & ETH_DMAMFBOCR_MFA)>>ETH_DMA_RX_OVERFLOW_MISSEDFRAMES_COUNTERSHIFT));
000002  6a00              LDR      r0,[r0,#0x20]
000004  f3c0404a          UBFX     r0,r0,#17,#11
;;;2171   }
000008  4770              BX       lr
;;;2172   
                          ENDP

00000a  0000              DCW      0x0000
                  |L45.12|
                          DCD      0x40029000

                          AREA ||i.ETH_GetRxPktSize||, CODE, READONLY, ALIGN=1

                  ETH_GetRxPktSize PROC
;;;1754     */
;;;1755   uint32_t ETH_GetRxPktSize(ETH_DMADESCTypeDef *DMARxDesc)
000000  6802              LDR      r2,[r0,#0]
;;;1756   {
;;;1757     uint32_t frameLength = 0;
000002  2100              MOVS     r1,#0
;;;1758     if(((DMARxDesc->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
000004  2a00              CMP      r2,#0
000006  db08              BLT      |L46.26|
;;;1759        ((DMARxDesc->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) &&
000008  6802              LDR      r2,[r0,#0]
00000a  0412              LSLS     r2,r2,#16
00000c  d405              BMI      |L46.26|
;;;1760          ((DMARxDesc->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET)) 
00000e  6802              LDR      r2,[r0,#0]
000010  05d2              LSLS     r2,r2,#23
000012  d502              BPL      |L46.26|
000014  6800              LDR      r0,[r0,#0]
000016  f3c0410d          UBFX     r1,r0,#16,#14
                  |L46.26|
;;;1761     {
;;;1762       /* Get the size of the packet: including 4 bytes of the CRC */
;;;1763       frameLength =  ETH_GetDMARxDescFrameLength(DMARxDesc);
;;;1764     }
;;;1765   
;;;1766     /* Return Frame Length */ 
;;;1767     return frameLength;
00001a  4608              MOV      r0,r1
;;;1768   }
00001c  4770              BX       lr
;;;1769   
                          ENDP


                          AREA ||i.ETH_GetSoftwareResetStatus||, CODE, READONLY, ALIGN=2

                  ETH_GetSoftwareResetStatus PROC
;;;1821     */
;;;1822   FlagStatus ETH_GetSoftwareResetStatus(void)
000000  4903              LDR      r1,|L47.16|
;;;1823   {
;;;1824     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1825     if((ETH->DMABMR & ETH_DMABMR_SR) != (uint32_t)RESET)
000004  6809              LDR      r1,[r1,#0]
000006  07c9              LSLS     r1,r1,#31
000008  d000              BEQ      |L47.12|
;;;1826     {
;;;1827       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L47.12|
;;;1828     }
;;;1829     else
;;;1830     {
;;;1831       bitstatus = RESET;
;;;1832     }
;;;1833     return bitstatus;
;;;1834   }
00000c  4770              BX       lr
;;;1835   
                          ENDP

00000e  0000              DCW      0x0000
                  |L47.16|
                          DCD      0x40029000

                          AREA ||i.ETH_GetTransmitProcessState||, CODE, READONLY, ALIGN=2

                  ETH_GetTransmitProcessState PROC
;;;2032     */
;;;2033   uint32_t ETH_GetTransmitProcessState(void)
000000  4802              LDR      r0,|L48.12|
;;;2034   {
;;;2035     return ((uint32_t)(ETH->DMASR & ETH_DMASR_TS)); 
000002  6940              LDR      r0,[r0,#0x14]
000004  f0000001          AND      r0,r0,#1
;;;2036   }
000008  4770              BX       lr
;;;2037   
                          ENDP

00000a  0000              DCW      0x0000
                  |L48.12|
                          DCD      0x40029000

                          AREA ||i.ETH_Get_Received_Frame||, CODE, READONLY, ALIGN=2

                  ETH_Get_Received_Frame PROC
;;;1068     */
;;;1069   FrameTypeDef ETH_Get_Received_Frame(void)
000000  b530              PUSH     {r4,r5,lr}
;;;1070   { 
;;;1071     uint32_t framelength = 0;
;;;1072     FrameTypeDef frame = {0,0,0}; 
;;;1073   
;;;1074     /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
;;;1075     framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARxDesc_FrameLengthShift) - 4;
000002  4b08              LDR      r3,|L49.36|
000004  6859              LDR      r1,[r3,#4]  ; DMARxDescToGet
000006  680a              LDR      r2,[r1,#0]
000008  f3c2440d          UBFX     r4,r2,#16,#14
;;;1076     frame.length = framelength;
;;;1077   
;;;1078     /* Get the address of the first frame descriptor and the buffer start address */ 
;;;1079     frame.descriptor = DMA_RX_FRAME_infos->FS_Rx_Desc;
00000c  689a              LDR      r2,[r3,#8]  ; DMA_RX_FRAME_infos
00000e  6815              LDR      r5,[r2,#0]
;;;1080     frame.buffer =(DMA_RX_FRAME_infos->FS_Rx_Desc)->Buffer1Addr;
000010  6812              LDR      r2,[r2,#0]
000012  6892              LDR      r2,[r2,#8]
;;;1081   
;;;1082     /* Update the ETHERNET DMA global Rx descriptor with next Rx descriptor */
;;;1083     /* Chained Mode */    
;;;1084     /* Selects the next DMA Rx descriptor list for next buffer to read */ 
;;;1085     DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
000014  68c9              LDR      r1,[r1,#0xc]
;;;1086   
;;;1087     /* Return Frame */
;;;1088     return (frame);
000016  6059              STR      r1,[r3,#4]  ; DMARxDescToGet
000018  1f24              SUBS     r4,r4,#4
00001a  6085              STR      r5,[r0,#8]
00001c  e9c04200          STRD     r4,r2,[r0,#0]
;;;1089   }
000020  bd30              POP      {r4,r5,pc}
;;;1090   
                          ENDP

000022  0000              DCW      0x0000
                  |L49.36|
                          DCD      ||.data||

                          AREA ||i.ETH_Get_Received_Frame_interrupt||, CODE, READONLY, ALIGN=2

                  ETH_Get_Received_Frame_interrupt PROC
;;;1097     */
;;;1098   FrameTypeDef ETH_Get_Received_Frame_interrupt(void)
000000  b538              PUSH     {r3-r5,lr}
;;;1099   { 
;;;1100     FrameTypeDef frame={0,0,0};
;;;1101     __IO uint32_t descriptor_scan_counter = 0; 
;;;1102     
;;;1103     /* scan descriptors owned by CPU */
;;;1104     while (((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET)&&
;;;1105            (descriptor_scan_counter<ETH_RXBUFNB))
;;;1106     {
;;;1107   
;;;1108       /* Just by security */
;;;1109       descriptor_scan_counter++;
;;;1110   
;;;1111       /* check if first segment in frame */
;;;1112       if(((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET)&&
000002  4b21              LDR      r3,|L50.136|
000004  2400              MOVS     r4,#0                 ;1100
;;;1113          ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))
;;;1114       {
;;;1115         DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
000006  9400              STR      r4,[sp,#0]
000008  e9d32101          LDRD     r2,r1,[r3,#4]         ;1099
00000c  e017              B        |L50.62|
                  |L50.14|
00000e  1c6d              ADDS     r5,r5,#1              ;1099
000010  9500              STR      r5,[sp,#0]            ;1112
000012  6815              LDR      r5,[r2,#0]            ;1112
000014  05ad              LSLS     r5,r5,#22             ;1112
000016  d507              BPL      |L50.40|
000018  6815              LDR      r5,[r2,#0]            ;1113
00001a  05ed              LSLS     r5,r5,#23             ;1113
00001c  d404              BMI      |L50.40|
00001e  600a              STR      r2,[r1,#0]
;;;1116         DMA_RX_FRAME_infos->Seg_Count = 1;   
000020  2201              MOVS     r2,#1
000022  608a              STR      r2,[r1,#8]
;;;1117         DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
000024  685a              LDR      r2,[r3,#4]  ; DMARxDescToGet
000026  e008              B        |L50.58|
                  |L50.40|
;;;1118       }
;;;1119   
;;;1120       /* check if intermediate segment */
;;;1121       else if (((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET)&&
000028  6815              LDR      r5,[r2,#0]
00002a  05ed              LSLS     r5,r5,#23
00002c  d411              BMI      |L50.82|
;;;1122                ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) == (uint32_t)RESET))
00002e  6815              LDR      r5,[r2,#0]
000030  05ad              LSLS     r5,r5,#22
000032  d40e              BMI      |L50.82|
;;;1123       {
;;;1124         (DMA_RX_FRAME_infos->Seg_Count) ++;
000034  688d              LDR      r5,[r1,#8]
000036  1c6d              ADDS     r5,r5,#1
000038  608d              STR      r5,[r1,#8]
                  |L50.58|
;;;1125         DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
00003a  68d2              LDR      r2,[r2,#0xc]
00003c  605a              STR      r2,[r3,#4]  ; DMARxDescToGet
                  |L50.62|
00003e  6815              LDR      r5,[r2,#0]            ;1104
000040  2d00              CMP      r5,#0                 ;1104
000042  db02              BLT      |L50.74|
000044  9d00              LDR      r5,[sp,#0]            ;1105
000046  2d10              CMP      r5,#0x10              ;1105
000048  d3e1              BCC      |L50.14|
                  |L50.74|
;;;1126       }
;;;1127   
;;;1128       /* should be last segment */
;;;1129       else
;;;1130       { 
;;;1131         /* last segment */
;;;1132         DMA_RX_FRAME_infos->LS_Rx_Desc = DMARxDescToGet;
;;;1133         
;;;1134         (DMA_RX_FRAME_infos->Seg_Count)++;
;;;1135   
;;;1136         /* first segment is last segment */
;;;1137         if ((DMA_RX_FRAME_infos->Seg_Count)==1)
;;;1138           DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
;;;1139   
;;;1140         /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
;;;1141         frame.length = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARxDesc_FrameLengthShift) - 4;
;;;1142   
;;;1143         /* Get the address of the buffer start address */ 
;;;1144         /* Check if more than one segment in the frame */
;;;1145         if (DMA_RX_FRAME_infos->Seg_Count >1)
;;;1146         {
;;;1147           frame.buffer =(DMA_RX_FRAME_infos->FS_Rx_Desc)->Buffer1Addr;
;;;1148         }
;;;1149         else 
;;;1150         {
;;;1151           frame.buffer = DMARxDescToGet->Buffer1Addr;
;;;1152         }
;;;1153   
;;;1154         frame.descriptor = DMA_RX_FRAME_infos->FS_Rx_Desc;
;;;1155   
;;;1156         /* Update the ETHERNET DMA global Rx descriptor with next Rx descriptor */      
;;;1157         DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
;;;1158   
;;;1159         /* Return Frame */
;;;1160         return (frame);  
;;;1161       }
;;;1162     }
;;;1163     return (frame); 
00004a  6004              STR      r4,[r0,#0]
00004c  6044              STR      r4,[r0,#4]
00004e  6084              STR      r4,[r0,#8]
;;;1164   }
000050  bd38              POP      {r3-r5,pc}
                  |L50.82|
000052  604a              STR      r2,[r1,#4]            ;1132
000054  688c              LDR      r4,[r1,#8]            ;1134
000056  1c64              ADDS     r4,r4,#1              ;1134
000058  608c              STR      r4,[r1,#8]            ;1134
00005a  688c              LDR      r4,[r1,#8]            ;1137
00005c  2c01              CMP      r4,#1                 ;1137
00005e  d100              BNE      |L50.98|
000060  600a              STR      r2,[r1,#0]            ;1138
                  |L50.98|
000062  685c              LDR      r4,[r3,#4]            ;1141  ; DMARxDescToGet
000064  6822              LDR      r2,[r4,#0]            ;1141
000066  f3c2450d          UBFX     r5,r2,#16,#14         ;1141
00006a  688a              LDR      r2,[r1,#8]            ;1145
00006c  1f2d              SUBS     r5,r5,#4              ;1145
00006e  2a01              CMP      r2,#1                 ;1145
000070  d902              BLS      |L50.120|
000072  680a              LDR      r2,[r1,#0]            ;1147
000074  6892              LDR      r2,[r2,#8]            ;1147
000076  e000              B        |L50.122|
                  |L50.120|
000078  68a2              LDR      r2,[r4,#8]            ;1151
                  |L50.122|
00007a  6809              LDR      r1,[r1,#0]            ;1154
00007c  68e4              LDR      r4,[r4,#0xc]          ;1157
00007e  605c              STR      r4,[r3,#4]            ;1160  ; DMARxDescToGet
000080  6005              STR      r5,[r0,#0]            ;1160
000082  e9c02101          STRD     r2,r1,[r0,#4]         ;1160
000086  bd38              POP      {r3-r5,pc}
;;;1165   
                          ENDP

                  |L50.136|
                          DCD      ||.data||

                          AREA ||i.ETH_GlobalUnicastWakeUpCmd||, CODE, READONLY, ALIGN=2

                  ETH_GlobalUnicastWakeUpCmd PROC
;;;2450     */
;;;2451   void ETH_GlobalUnicastWakeUpCmd(FunctionalState NewState)
000000  b508              PUSH     {r3,lr}
;;;2452   { 
;;;2453     __IO uint32_t tmpreg = 0;
000002  2100              MOVS     r1,#0
;;;2454     /* Check the parameters */
;;;2455     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2456   
;;;2457     if (NewState != DISABLE)
;;;2458     {
;;;2459       /* Enable the MAC Global Unicast Wake-Up */
;;;2460       ETH->MACPMTCSR |= ETH_MACPMTCSR_GU;
000004  9100              STR      r1,[sp,#0]
000006  4909              LDR      r1,|L51.44|
000008  2800              CMP      r0,#0                 ;2457
;;;2461     }
;;;2462     else
;;;2463     {
;;;2464       /* Disable the MAC Global Unicast Wake-Up */
;;;2465       ETH->MACPMTCSR &= ~ETH_MACPMTCSR_GU;
00000a  6ac8              LDR      r0,[r1,#0x2c]
00000c  d002              BEQ      |L51.20|
00000e  f4407000          ORR      r0,r0,#0x200          ;2460
000012  e001              B        |L51.24|
                  |L51.20|
000014  f4207000          BIC      r0,r0,#0x200
                  |L51.24|
000018  62c8              STR      r0,[r1,#0x2c]
;;;2466     }
;;;2467   
;;;2468     /* Wait until the write operation will be taken into account :
;;;2469      at least four TX_CLK/RX_CLK clock cycles */
;;;2470     tmpreg = ETH->MACPMTCSR;
00001a  6ac8              LDR      r0,[r1,#0x2c]
;;;2471     _eth_delay_(ETH_REG_WRITE_DELAY);
00001c  9000              STR      r0,[sp,#0]
00001e  f64f70ff          MOV      r0,#0xffff
000022  f7fffffe          BL       ETH_Delay
;;;2472     ETH->MACPMTCSR = tmpreg;
000026  9800              LDR      r0,[sp,#0]
000028  62c8              STR      r0,[r1,#0x2c]
;;;2473   }
00002a  bd08              POP      {r3,pc}
;;;2474   
                          ENDP

                  |L51.44|
                          DCD      0x40028000

                          AREA ||i.ETH_Init||, CODE, READONLY, ALIGN=2

                  ETH_Init PROC
;;;234      */
;;;235    uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct, uint16_t PHYAddress)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;236    {
000004  b086              SUB      sp,sp,#0x18
;;;237      uint32_t RegValue = 0, tmpreg = 0;
;;;238      __IO uint32_t i = 0;
000006  2700              MOVS     r7,#0
000008  4604              MOV      r4,r0                 ;236
;;;239      RCC_ClocksTypeDef  rcc_clocks;
;;;240      uint32_t hclk = 60000000;
;;;241      __IO uint32_t timeout = 0, err = ETH_SUCCESS;
00000a  2001              MOVS     r0,#1
;;;242      /* Check the parameters */
;;;243      /* MAC --------------------------*/ 
;;;244      assert_param(IS_ETH_AUTONEGOTIATION(ETH_InitStruct->ETH_AutoNegotiation));
;;;245      assert_param(IS_ETH_WATCHDOG(ETH_InitStruct->ETH_Watchdog));
;;;246      assert_param(IS_ETH_JABBER(ETH_InitStruct->ETH_Jabber));
;;;247      assert_param(IS_ETH_INTER_FRAME_GAP(ETH_InitStruct->ETH_InterFrameGap));
;;;248      assert_param(IS_ETH_CARRIER_SENSE(ETH_InitStruct->ETH_CarrierSense));
;;;249      assert_param(IS_ETH_SPEED(ETH_InitStruct->ETH_Speed));
;;;250      assert_param(IS_ETH_RECEIVE_OWN(ETH_InitStruct->ETH_ReceiveOwn));
;;;251      assert_param(IS_ETH_LOOPBACK_MODE(ETH_InitStruct->ETH_LoopbackMode));
;;;252      assert_param(IS_ETH_DUPLEX_MODE(ETH_InitStruct->ETH_Mode));
;;;253      assert_param(IS_ETH_CHECKSUM_OFFLOAD(ETH_InitStruct->ETH_ChecksumOffload));
;;;254      assert_param(IS_ETH_RETRY_TRANSMISSION(ETH_InitStruct->ETH_RetryTransmission));
;;;255      assert_param(IS_ETH_AUTOMATIC_PADCRC_STRIP(ETH_InitStruct->ETH_AutomaticPadCRCStrip));
;;;256      assert_param(IS_ETH_BACKOFF_LIMIT(ETH_InitStruct->ETH_BackOffLimit));
;;;257      assert_param(IS_ETH_DEFERRAL_CHECK(ETH_InitStruct->ETH_DeferralCheck));
;;;258      assert_param(IS_ETH_RECEIVE_ALL(ETH_InitStruct->ETH_ReceiveAll));
;;;259      assert_param(IS_ETH_SOURCE_ADDR_FILTER(ETH_InitStruct->ETH_SourceAddrFilter));
;;;260      assert_param(IS_ETH_CONTROL_FRAMES(ETH_InitStruct->ETH_PassControlFrames));
;;;261      assert_param(IS_ETH_BROADCAST_FRAMES_RECEPTION(ETH_InitStruct->ETH_BroadcastFramesReception));
;;;262      assert_param(IS_ETH_DESTINATION_ADDR_FILTER(ETH_InitStruct->ETH_DestinationAddrFilter));
;;;263      assert_param(IS_ETH_PROMISCUOUS_MODE(ETH_InitStruct->ETH_PromiscuousMode));
;;;264      assert_param(IS_ETH_MULTICAST_FRAMES_FILTER(ETH_InitStruct->ETH_MulticastFramesFilter));
;;;265      assert_param(IS_ETH_UNICAST_FRAMES_FILTER(ETH_InitStruct->ETH_UnicastFramesFilter));
;;;266      assert_param(IS_ETH_PAUSE_TIME(ETH_InitStruct->ETH_PauseTime));
;;;267      assert_param(IS_ETH_ZEROQUANTA_PAUSE(ETH_InitStruct->ETH_ZeroQuantaPause));
;;;268      assert_param(IS_ETH_PAUSE_LOW_THRESHOLD(ETH_InitStruct->ETH_PauseLowThreshold));
;;;269      assert_param(IS_ETH_UNICAST_PAUSE_FRAME_DETECT(ETH_InitStruct->ETH_UnicastPauseFrameDetect));
;;;270      assert_param(IS_ETH_RECEIVE_FLOWCONTROL(ETH_InitStruct->ETH_ReceiveFlowControl));
;;;271      assert_param(IS_ETH_TRANSMIT_FLOWCONTROL(ETH_InitStruct->ETH_TransmitFlowControl));
;;;272      assert_param(IS_ETH_VLAN_TAG_COMPARISON(ETH_InitStruct->ETH_VLANTagComparison));
;;;273      assert_param(IS_ETH_VLAN_TAG_IDENTIFIER(ETH_InitStruct->ETH_VLANTagIdentifier));
;;;274      /* DMA --------------------------*/
;;;275      assert_param(IS_ETH_DROP_TCPIP_CHECKSUM_FRAME(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame));
;;;276      assert_param(IS_ETH_RECEIVE_STORE_FORWARD(ETH_InitStruct->ETH_ReceiveStoreForward));
;;;277      assert_param(IS_ETH_FLUSH_RECEIVE_FRAME(ETH_InitStruct->ETH_FlushReceivedFrame));
;;;278      assert_param(IS_ETH_TRANSMIT_STORE_FORWARD(ETH_InitStruct->ETH_TransmitStoreForward));
;;;279      assert_param(IS_ETH_TRANSMIT_THRESHOLD_CONTROL(ETH_InitStruct->ETH_TransmitThresholdControl));
;;;280      assert_param(IS_ETH_FORWARD_ERROR_FRAMES(ETH_InitStruct->ETH_ForwardErrorFrames));
;;;281      assert_param(IS_ETH_FORWARD_UNDERSIZED_GOOD_FRAMES(ETH_InitStruct->ETH_ForwardUndersizedGoodFrames));
;;;282      assert_param(IS_ETH_RECEIVE_THRESHOLD_CONTROL(ETH_InitStruct->ETH_ReceiveThresholdControl));
;;;283      assert_param(IS_ETH_SECOND_FRAME_OPERATE(ETH_InitStruct->ETH_SecondFrameOperate));
;;;284      assert_param(IS_ETH_ADDRESS_ALIGNED_BEATS(ETH_InitStruct->ETH_AddressAlignedBeats));
;;;285      assert_param(IS_ETH_FIXED_BURST(ETH_InitStruct->ETH_FixedBurst));
;;;286      assert_param(IS_ETH_RXDMA_BURST_LENGTH(ETH_InitStruct->ETH_RxDMABurstLength));
;;;287      assert_param(IS_ETH_TXDMA_BURST_LENGTH(ETH_InitStruct->ETH_TxDMABurstLength));
;;;288      assert_param(IS_ETH_DMA_DESC_SKIP_LENGTH(ETH_InitStruct->ETH_DescriptorSkipLength));
;;;289      assert_param(IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(ETH_InitStruct->ETH_DMAArbitration));
;;;290      /*-------------------------------- MAC Config ------------------------------*/
;;;291      /*---------------------- ETHERNET MACMIIAR Configuration -------------------*/
;;;292      /* Get the ETHERNET MACMIIAR value */
;;;293      tmpreg = ETH->MACMIIAR;
00000c  9700              STR      r7,[sp,#0]
00000e  4e97              LDR      r6,|L52.620|
000010  e9cd0700          STRD     r0,r7,[sp,#0]
000014  6930              LDR      r0,[r6,#0x10]
000016  468a              MOV      r10,r1                ;236
;;;294      /* Clear CSR Clock Range CR[2:0] bits */
;;;295      tmpreg &= MACMIIAR_CR_MASK;
000018  f020051c          BIC      r5,r0,#0x1c
;;;296      /* Get hclk frequency value */
;;;297      RCC_GetClocksFreq(&rcc_clocks);
00001c  a802              ADD      r0,sp,#8
00001e  f7fffffe          BL       RCC_GetClocksFreq
;;;298      hclk = rcc_clocks.HCLK_Frequency;
;;;299      
;;;300      /* Set CR bits depending on hclk value */
;;;301      if((hclk >= 20000000)&&(hclk < 35000000))
000022  4993              LDR      r1,|L52.624|
000024  9803              LDR      r0,[sp,#0xc]
000026  4a93              LDR      r2,|L52.628|
000028  4401              ADD      r1,r1,r0
00002a  4291              CMP      r1,r2
00002c  d202              BCS      |L52.52|
;;;302      {
;;;303        /* CSR Clock Range between 20-35 MHz */
;;;304        tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div16;
00002e  f0450508          ORR      r5,r5,#8
000032  e016              B        |L52.98|
                  |L52.52|
;;;305      }
;;;306      else if((hclk >= 35000000)&&(hclk < 60000000))
000034  4990              LDR      r1,|L52.632|
000036  4a91              LDR      r2,|L52.636|
000038  4401              ADD      r1,r1,r0
00003a  4291              CMP      r1,r2
00003c  d202              BCS      |L52.68|
;;;307      {
;;;308        /* CSR Clock Range between 35-60 MHz */ 
;;;309        tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div26;
00003e  f045050c          ORR      r5,r5,#0xc
000042  e00e              B        |L52.98|
                  |L52.68|
;;;310      }  
;;;311      else if((hclk >= 60000000)&&(hclk < 100000000))
000044  498e              LDR      r1,|L52.640|
000046  4a8f              LDR      r2,|L52.644|
000048  4401              ADD      r1,r1,r0
00004a  4291              CMP      r1,r2
00004c  d309              BCC      |L52.98|
;;;312      {
;;;313        /* CSR Clock Range between 60-100 MHz */ 
;;;314        tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div42;
;;;315      }  
;;;316      else if((hclk >= 100000000)&&(hclk < 150000000))
00004e  498e              LDR      r1,|L52.648|
000050  4408              ADD      r0,r0,r1
000052  498e              LDR      r1,|L52.652|
000054  4288              CMP      r0,r1
000056  d202              BCS      |L52.94|
;;;317      {
;;;318        /* CSR Clock Range between 100-150 MHz */ 
;;;319        tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div62;
000058  f0450504          ORR      r5,r5,#4
00005c  e001              B        |L52.98|
                  |L52.94|
;;;320      }
;;;321      else /* ((hclk >= 150000000)&&(hclk <= 168000000)) */
;;;322      {
;;;323        /* CSR Clock Range between 150-168 MHz */ 
;;;324        tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div102;    
00005e  f0450510          ORR      r5,r5,#0x10
                  |L52.98|
;;;325      }
;;;326      
;;;327      /* Write to ETHERNET MAC MIIAR: Configure the ETHERNET CSR Clock Range */
;;;328      ETH->MACMIIAR = (uint32_t)tmpreg;  
000062  6135              STR      r5,[r6,#0x10]
;;;329      /*-------------------- PHY initialization and configuration ----------------*/
;;;330      /* Put the PHY in reset mode */
;;;331      if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_Reset)))
000064  f44f4200          MOV      r2,#0x8000
000068  2100              MOVS     r1,#0
00006a  4650              MOV      r0,r10
00006c  f7fffffe          BL       ETH_WritePHYRegister
;;;332      {
;;;333        /* Return ERROR in case of write timeout */
;;;334        err = ETH_ERROR;
;;;335        goto error;
;;;336      }
;;;337      
;;;338      /* Delay to assure PHY reset */
;;;339      _eth_delay_(PHY_RESET_DELAY);
;;;340      
;;;341      if(ETH_InitStruct->ETH_AutoNegotiation != ETH_AutoNegotiation_Disable)
;;;342      {
;;;343        /* We wait for linked status...*/
;;;344        do
;;;345        {
;;;346          timeout++;
;;;347        } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_Linked_Status) && (timeout < PHY_READ_TO));
;;;348        
;;;349        /* Return ERROR in case of timeout */
;;;350        if(timeout == PHY_READ_TO)
;;;351        {
;;;352          err = ETH_ERROR;
;;;353          goto error;
;;;354        }
;;;355        
;;;356        /* Reset Timeout counter */
;;;357        timeout = 0; 
;;;358        /* Enable Auto-Negotiation */
;;;359        if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_AutoNegotiation)))
;;;360        {
;;;361          /* Return ERROR in case of write timeout */
;;;362          err = ETH_ERROR;
;;;363        }
;;;364        
;;;365        /* Wait until the auto-negotiation will be completed */
;;;366        do
;;;367        {
;;;368          timeout++;
;;;369        } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_AutoNego_Complete) && (timeout < (uint32_t)PHY_READ_TO));
;;;370    
;;;371        /* Return ERROR in case of timeout */
;;;372        if(timeout == PHY_READ_TO)
;;;373        {
;;;374          err = ETH_ERROR;
;;;375          goto error;
;;;376        }
;;;377    
;;;378        /* Reset Timeout counter */
;;;379        timeout = 0;
;;;380        /* Read the result of the auto-negotiation */
;;;381        RegValue = ETH_ReadPHYRegister(PHYAddress, PHY_SR);
;;;382        /* Configure the MAC with the Duplex Mode fixed by the auto-negotiation process */
;;;383        if((RegValue & PHY_DUPLEX_STATUS) != (uint32_t)RESET)
;;;384        {
;;;385          /* Set Ethernet duplex mode to Full-duplex following the auto-negotiation */
;;;386          ETH_InitStruct->ETH_Mode = ETH_Mode_FullDuplex;  
000070  f44f6800          MOV      r8,#0x800
;;;387        }
;;;388        else
;;;389        {
;;;390          /* Set Ethernet duplex mode to Half-duplex following the auto-negotiation */
;;;391          ETH_InitStruct->ETH_Mode = ETH_Mode_HalfDuplex;           
;;;392        }
;;;393        /* Configure the MAC with the speed fixed by the auto-negotiation process */
;;;394        if(RegValue & PHY_SPEED_STATUS)
;;;395        {  
;;;396          /* Set Ethernet speed to 10M following the auto-negotiation */
;;;397          ETH_InitStruct->ETH_Speed = ETH_Speed_10M; 
;;;398        }
;;;399        else
;;;400        {   
;;;401          /* Set Ethernet speed to 100M following the auto-negotiation */ 
;;;402          ETH_InitStruct->ETH_Speed = ETH_Speed_100M;
000074  f44f4980          MOV      r9,#0x4000
000078  b1a0              CBZ      r0,|L52.164|
00007a  4885              LDR      r0,|L52.656|
00007c  f7fffffe          BL       ETH_Delay
000080  6820              LDR      r0,[r4,#0]            ;341
000082  b398              CBZ      r0,|L52.236|
000084  4d83              LDR      r5,|L52.660|
                  |L52.134|
000086  9801              LDR      r0,[sp,#4]            ;346
000088  2101              MOVS     r1,#1                 ;347
00008a  1c40              ADDS     r0,r0,#1              ;346
00008c  9001              STR      r0,[sp,#4]            ;347
00008e  4650              MOV      r0,r10                ;347
000090  f7fffffe          BL       ETH_ReadPHYRegister
000094  0740              LSLS     r0,r0,#29             ;347
000096  d402              BMI      |L52.158|
000098  9801              LDR      r0,[sp,#4]            ;347
00009a  42a8              CMP      r0,r5                 ;347
00009c  d3f3              BCC      |L52.134|
                  |L52.158|
00009e  9801              LDR      r0,[sp,#4]            ;350
0000a0  42a8              CMP      r0,r5                 ;350
0000a2  d101              BNE      |L52.168|
                  |L52.164|
0000a4  9700              STR      r7,[sp,#0]            ;335
0000a6  e03c              B        |L52.290|
                  |L52.168|
0000a8  f44f5280          MOV      r2,#0x1000            ;359
0000ac  2100              MOVS     r1,#0                 ;359
0000ae  4650              MOV      r0,r10                ;359
0000b0  9701              STR      r7,[sp,#4]            ;359
0000b2  f7fffffe          BL       ETH_WritePHYRegister
0000b6  b900              CBNZ     r0,|L52.186|
0000b8  9700              STR      r7,[sp,#0]            ;362
                  |L52.186|
0000ba  9801              LDR      r0,[sp,#4]            ;368
0000bc  2101              MOVS     r1,#1                 ;369
0000be  1c40              ADDS     r0,r0,#1              ;368
0000c0  9001              STR      r0,[sp,#4]            ;369
0000c2  4650              MOV      r0,r10                ;369
0000c4  f7fffffe          BL       ETH_ReadPHYRegister
0000c8  0680              LSLS     r0,r0,#26             ;369
0000ca  d402              BMI      |L52.210|
0000cc  9801              LDR      r0,[sp,#4]            ;369
0000ce  42a8              CMP      r0,r5                 ;369
0000d0  d3f3              BCC      |L52.186|
                  |L52.210|
0000d2  9801              LDR      r0,[sp,#4]            ;372
0000d4  42a8              CMP      r0,r5                 ;372
0000d6  d0e5              BEQ      |L52.164|
0000d8  211f              MOVS     r1,#0x1f              ;381
0000da  4650              MOV      r0,r10                ;381
0000dc  9701              STR      r7,[sp,#4]            ;381
0000de  f7fffffe          BL       ETH_ReadPHYRegister
0000e2  06c1              LSLS     r1,r0,#27             ;383
0000e4  d503              BPL      |L52.238|
0000e6  f8c48020          STR      r8,[r4,#0x20]         ;386
0000ea  e001              B        |L52.240|
                  |L52.236|
0000ec  e007              B        |L52.254|
                  |L52.238|
0000ee  6227              STR      r7,[r4,#0x20]         ;391
                  |L52.240|
0000f0  0740              LSLS     r0,r0,#29             ;394
0000f2  d501              BPL      |L52.248|
0000f4  6167              STR      r7,[r4,#0x14]         ;397
0000f6  e012              B        |L52.286|
                  |L52.248|
0000f8  f8c49014          STR      r9,[r4,#0x14]
0000fc  e00f              B        |L52.286|
                  |L52.254|
;;;403        }
;;;404    //		/* Get speed and duplex from PHY */
;;;405    //		ETH_EXTERN_GetSpeedAndDuplex(PHYAddress, ETH_InitStruct);
;;;406      }
;;;407      else
;;;408      {
;;;409        if(!ETH_WritePHYRegister(PHYAddress, PHY_BCR, ((uint16_t)(ETH_InitStruct->ETH_Mode >> 3) |
0000fe  6a20              LDR      r0,[r4,#0x20]
000100  6961              LDR      r1,[r4,#0x14]
000102  08c0              LSRS     r0,r0,#3
000104  ea400051          ORR      r0,r0,r1,LSR #1
000108  b282              UXTH     r2,r0
00010a  2100              MOVS     r1,#0
00010c  4650              MOV      r0,r10
00010e  f7fffffe          BL       ETH_WritePHYRegister
000112  b900              CBNZ     r0,|L52.278|
;;;410                                                       (uint16_t)(ETH_InitStruct->ETH_Speed >> 1))))
;;;411        {
;;;412          /* Return ERROR in case of write timeout */
;;;413          err = ETH_ERROR;
000114  9700              STR      r7,[sp,#0]
                  |L52.278|
;;;414        }  
;;;415        /* Delay to assure PHY configuration */
;;;416        _eth_delay_(PHY_CONFIG_DELAY);
000116  f06f407f          MVN      r0,#0xff000000
00011a  f7fffffe          BL       ETH_Delay
                  |L52.286|
;;;417      }
;;;418    error:
;;;419      if (err == ETH_ERROR) /* Auto-negotiation failed */
00011e  9800              LDR      r0,[sp,#0]
000120  b918              CBNZ     r0,|L52.298|
                  |L52.290|
;;;420      {
;;;421        /* Set Ethernet duplex mode to Full-duplex */
;;;422        ETH_InitStruct->ETH_Mode = ETH_Mode_FullDuplex;
;;;423    
;;;424        /* Set Ethernet speed to 100M */
;;;425        ETH_InitStruct->ETH_Speed = ETH_Speed_100M;
000122  f8c49014          STR      r9,[r4,#0x14]
000126  f8c48020          STR      r8,[r4,#0x20]
                  |L52.298|
;;;426      }
;;;427    
;;;428      /*------------------------ ETHERNET MACCR Configuration --------------------*/
;;;429        /* Get the ETHERNET MACCR value */
;;;430        tmpreg = ETH->MACCR;
00012a  6830              LDR      r0,[r6,#0]
;;;431        /* Clear WD, PCE, PS, TE and RE bits */
;;;432        tmpreg &= MACCR_CLEAR_MASK;
00012c  495a              LDR      r1,|L52.664|
00012e  4008              ANDS     r0,r0,r1
000130  e9d41201          LDRD     r1,r2,[r4,#4]
;;;433      /* Set the WD bit according to ETH_Watchdog value */
;;;434      /* Set the JD: bit according to ETH_Jabber value */
;;;435      /* Set the IFG bit according to ETH_InterFrameGap value */
;;;436      /* Set the DCRS bit according to ETH_CarrierSense value */
;;;437      /* Set the FES bit according to ETH_Speed value */ 
;;;438      /* Set the DO bit according to ETH_ReceiveOwn value */ 
;;;439      /* Set the LM bit according to ETH_LoopbackMode value */
;;;440      /* Set the DM bit according to ETH_Mode value */ 
;;;441      /* Set the IPCO bit according to ETH_ChecksumOffload value */
;;;442      /* Set the DR bit according to ETH_RetryTransmission value */
;;;443      /* Set the ACS bit according to ETH_AutomaticPadCRCStrip value */
;;;444      /* Set the BL bit according to ETH_BackOffLimit value */
;;;445      /* Set the DC bit according to ETH_DeferralCheck value */
;;;446          tmpreg |= (uint32_t)(ETH_InitStruct->ETH_Watchdog | 
000134  4311              ORRS     r1,r1,r2
000136  68e2              LDR      r2,[r4,#0xc]
000138  f8543f10          LDR      r3,[r4,#0x10]!
00013c  431a              ORRS     r2,r2,r3
00013e  4311              ORRS     r1,r1,r2
000140  6862              LDR      r2,[r4,#4]
000142  4311              ORRS     r1,r1,r2
000144  68a2              LDR      r2,[r4,#8]
000146  4311              ORRS     r1,r1,r2
000148  68e2              LDR      r2,[r4,#0xc]
00014a  4311              ORRS     r1,r1,r2
00014c  6922              LDR      r2,[r4,#0x10]
00014e  4311              ORRS     r1,r1,r2
000150  f8542f14          LDR      r2,[r4,#0x14]!
000154  4311              ORRS     r1,r1,r2
000156  6862              LDR      r2,[r4,#4]
000158  4311              ORRS     r1,r1,r2
00015a  68a2              LDR      r2,[r4,#8]
00015c  4311              ORRS     r1,r1,r2
00015e  68e2              LDR      r2,[r4,#0xc]
000160  4311              ORRS     r1,r1,r2
000162  6922              LDR      r2,[r4,#0x10]
000164  4311              ORRS     r1,r1,r2
000166  4301              ORRS     r1,r1,r0
;;;447                               ETH_InitStruct->ETH_Jabber | 
;;;448                               ETH_InitStruct->ETH_InterFrameGap |
;;;449                               ETH_InitStruct->ETH_CarrierSense |
;;;450                               ETH_InitStruct->ETH_Speed | 
;;;451                               ETH_InitStruct->ETH_ReceiveOwn |
;;;452                               ETH_InitStruct->ETH_LoopbackMode |
;;;453                               ETH_InitStruct->ETH_Mode | 
;;;454                               ETH_InitStruct->ETH_ChecksumOffload |    
;;;455                               ETH_InitStruct->ETH_RetryTransmission | 
;;;456                               ETH_InitStruct->ETH_AutomaticPadCRCStrip | 
;;;457                               ETH_InitStruct->ETH_BackOffLimit | 
;;;458                               ETH_InitStruct->ETH_DeferralCheck);
;;;459        /* Write to ETHERNET MACCR */
;;;460        ETH->MACCR = (uint32_t)tmpreg;
000168  6031              STR      r1,[r6,#0]
;;;461        
;;;462      /* Wait until the write operation will be taken into account :
;;;463       at least four TX_CLK/RX_CLK clock cycles */
;;;464        tmpreg = ETH->MACCR;
00016a  6831              LDR      r1,[r6,#0]
;;;465        _eth_delay_(ETH_REG_WRITE_DELAY);
00016c  f64f75ff          MOV      r5,#0xffff
000170  4628              MOV      r0,r5
000172  f7fffffe          BL       ETH_Delay
;;;466        ETH->MACCR = tmpreg; 
000176  6031              STR      r1,[r6,#0]
000178  e9f40105          LDRD     r0,r1,[r4,#0x14]!
;;;467      
;;;468      /*----------------------- ETHERNET MACFFR Configuration --------------------*/ 
;;;469      /* Set the RA bit according to ETH_ReceiveAll value */
;;;470      /* Set the SAF and SAIF bits according to ETH_SourceAddrFilter value */
;;;471      /* Set the PCF bit according to ETH_PassControlFrames value */
;;;472      /* Set the DBF bit according to ETH_BroadcastFramesReception value */
;;;473      /* Set the DAIF bit according to ETH_DestinationAddrFilter value */
;;;474      /* Set the PR bit according to ETH_PromiscuousMode value */
;;;475      /* Set the PM, HMC and HPF bits according to ETH_MulticastFramesFilter value */
;;;476      /* Set the HUC and HPF bits according to ETH_UnicastFramesFilter value */
;;;477      /* Write to ETHERNET MACFFR */  
;;;478      ETH->MACFFR = (uint32_t)(ETH_InitStruct->ETH_ReceiveAll | 
00017c  4308              ORRS     r0,r0,r1
00017e  e9d41202          LDRD     r1,r2,[r4,#8]
000182  4311              ORRS     r1,r1,r2
000184  4308              ORRS     r0,r0,r1
000186  6921              LDR      r1,[r4,#0x10]
000188  4308              ORRS     r0,r0,r1
00018a  6961              LDR      r1,[r4,#0x14]
00018c  4308              ORRS     r0,r0,r1
00018e  69a1              LDR      r1,[r4,#0x18]
000190  4308              ORRS     r0,r0,r1
000192  69e1              LDR      r1,[r4,#0x1c]
000194  4308              ORRS     r0,r0,r1
000196  6070              STR      r0,[r6,#4]
;;;479                               ETH_InitStruct->ETH_SourceAddrFilter |
;;;480                               ETH_InitStruct->ETH_PassControlFrames |
;;;481                               ETH_InitStruct->ETH_BroadcastFramesReception | 
;;;482                               ETH_InitStruct->ETH_DestinationAddrFilter |
;;;483                               ETH_InitStruct->ETH_PromiscuousMode |
;;;484                               ETH_InitStruct->ETH_MulticastFramesFilter |
;;;485                               ETH_InitStruct->ETH_UnicastFramesFilter);
;;;486    
;;;487      /* Wait until the write operation will be taken into account :
;;;488       at least four TX_CLK/RX_CLK clock cycles */
;;;489      tmpreg = ETH->MACFFR;
000198  6871              LDR      r1,[r6,#4]
;;;490      _eth_delay_(ETH_REG_WRITE_DELAY);
00019a  4628              MOV      r0,r5
00019c  f7fffffe          BL       ETH_Delay
;;;491      ETH->MACFFR = tmpreg;
0001a0  6071              STR      r1,[r6,#4]
;;;492    
;;;493      /*--------------- ETHERNET MACHTHR and MACHTLR Configuration ---------------*/
;;;494      /* Write to ETHERNET MACHTHR */
;;;495      ETH->MACHTHR = (uint32_t)ETH_InitStruct->ETH_HashTableHigh;
0001a2  6a20              LDR      r0,[r4,#0x20]
0001a4  60b0              STR      r0,[r6,#8]
;;;496    
;;;497      /* Write to ETHERNET MACHTLR */
;;;498      ETH->MACHTLR = (uint32_t)ETH_InitStruct->ETH_HashTableLow;
0001a6  6a60              LDR      r0,[r4,#0x24]
0001a8  60f0              STR      r0,[r6,#0xc]
;;;499      /*----------------------- ETHERNET MACFCR Configuration --------------------*/
;;;500    
;;;501      /* Get the ETHERNET MACFCR value */  
;;;502      tmpreg = ETH->MACFCR;
0001aa  69b0              LDR      r0,[r6,#0x18]
;;;503      /* Clear xx bits */
;;;504      tmpreg &= MACFCR_CLEAR_MASK;
0001ac  f64f7141          MOV      r1,#0xff41
0001b0  4008              ANDS     r0,r0,r1
0001b2  e9d4120b          LDRD     r1,r2,[r4,#0x2c]
;;;505    
;;;506      /* Set the PT bit according to ETH_PauseTime value */
;;;507      /* Set the DZPQ bit according to ETH_ZeroQuantaPause value */
;;;508      /* Set the PLT bit according to ETH_PauseLowThreshold value */
;;;509      /* Set the UP bit according to ETH_UnicastPauseFrameDetect value */
;;;510      /* Set the RFE bit according to ETH_ReceiveFlowControl value */
;;;511      /* Set the TFE bit according to ETH_TransmitFlowControl value */ 
;;;512      tmpreg |= (uint32_t)((ETH_InitStruct->ETH_PauseTime << 16) | 
0001b6  4311              ORRS     r1,r1,r2
0001b8  8d23              LDRH     r3,[r4,#0x28]
0001ba  6b62              LDR      r2,[r4,#0x34]
0001bc  ea424203          ORR      r2,r2,r3,LSL #16
0001c0  4311              ORRS     r1,r1,r2
0001c2  6ba2              LDR      r2,[r4,#0x38]
0001c4  4311              ORRS     r1,r1,r2
0001c6  6be2              LDR      r2,[r4,#0x3c]
0001c8  4311              ORRS     r1,r1,r2
0001ca  4301              ORRS     r1,r1,r0
;;;513                            ETH_InitStruct->ETH_ZeroQuantaPause |
;;;514                            ETH_InitStruct->ETH_PauseLowThreshold |
;;;515                            ETH_InitStruct->ETH_UnicastPauseFrameDetect | 
;;;516                            ETH_InitStruct->ETH_ReceiveFlowControl |
;;;517                            ETH_InitStruct->ETH_TransmitFlowControl); 
;;;518      /* Write to ETHERNET MACFCR */
;;;519      ETH->MACFCR = (uint32_t)tmpreg;
0001cc  61b1              STR      r1,[r6,#0x18]
;;;520      
;;;521      /* Wait until the write operation will be taken into account :
;;;522       at least four TX_CLK/RX_CLK clock cycles */
;;;523      tmpreg = ETH->MACFCR;
0001ce  69b1              LDR      r1,[r6,#0x18]
;;;524      _eth_delay_(ETH_REG_WRITE_DELAY);
0001d0  4628              MOV      r0,r5
0001d2  f7fffffe          BL       ETH_Delay
;;;525      ETH->MACFCR = tmpreg;
0001d6  61b1              STR      r1,[r6,#0x18]
0001d8  e9d40110          LDRD     r0,r1,[r4,#0x40]
;;;526    
;;;527      /*----------------------- ETHERNET MACVLANTR Configuration -----------------*/
;;;528      /* Set the ETV bit according to ETH_VLANTagComparison value */
;;;529      /* Set the VL bit according to ETH_VLANTagIdentifier value */  
;;;530      ETH->MACVLANTR = (uint32_t)(ETH_InitStruct->ETH_VLANTagComparison | 
0001dc  4308              ORRS     r0,r0,r1
0001de  61f0              STR      r0,[r6,#0x1c]
;;;531                                  ETH_InitStruct->ETH_VLANTagIdentifier);
;;;532    
;;;533      /* Wait until the write operation will be taken into account :
;;;534       at least four TX_CLK/RX_CLK clock cycles */
;;;535      tmpreg = ETH->MACVLANTR;
0001e0  69f1              LDR      r1,[r6,#0x1c]
;;;536      _eth_delay_(ETH_REG_WRITE_DELAY);
0001e2  4628              MOV      r0,r5
0001e4  f7fffffe          BL       ETH_Delay
;;;537      ETH->MACVLANTR = tmpreg;
0001e8  61f1              STR      r1,[r6,#0x1c]
;;;538    
;;;539      /*-------------------------------- DMA Config ------------------------------*/
;;;540      /*----------------------- ETHERNET DMAOMR Configuration --------------------*/
;;;541    
;;;542      /* Get the ETHERNET DMAOMR value */
;;;543      tmpreg = ETH->DMAOMR;
0001ea  492c              LDR      r1,|L52.668|
0001ec  6988              LDR      r0,[r1,#0x18]
;;;544      /* Clear xx bits */
;;;545      tmpreg &= DMAOMR_CLEAR_MASK;
0001ee  4a2c              LDR      r2,|L52.672|
0001f0  4010              ANDS     r0,r0,r2
0001f2  e9d42312          LDRD     r2,r3,[r4,#0x48]
;;;546      
;;;547      /* Set the DT bit according to ETH_DropTCPIPChecksumErrorFrame value */
;;;548      /* Set the RSF bit according to ETH_ReceiveStoreForward value */
;;;549      /* Set the DFF bit according to ETH_FlushReceivedFrame value */
;;;550      /* Set the TSF bit according to ETH_TransmitStoreForward value */
;;;551      /* Set the TTC bit according to ETH_TransmitThresholdControl value */
;;;552      /* Set the FEF bit according to ETH_ForwardErrorFrames value */
;;;553      /* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */
;;;554      /* Set the RTC bit according to ETH_ReceiveThresholdControl value */
;;;555      /* Set the OSF bit according to ETH_SecondFrameOperate value */
;;;556      tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
0001f6  431a              ORRS     r2,r2,r3
0001f8  e9d43614          LDRD     r3,r6,[r4,#0x50]
0001fc  4333              ORRS     r3,r3,r6
0001fe  431a              ORRS     r2,r2,r3
000200  6da3              LDR      r3,[r4,#0x58]
000202  431a              ORRS     r2,r2,r3
000204  6de3              LDR      r3,[r4,#0x5c]
000206  431a              ORRS     r2,r2,r3
000208  6e23              LDR      r3,[r4,#0x60]
00020a  431a              ORRS     r2,r2,r3
00020c  6e63              LDR      r3,[r4,#0x64]
00020e  431a              ORRS     r2,r2,r3
000210  6ea3              LDR      r3,[r4,#0x68]
000212  431a              ORRS     r2,r2,r3
000214  4302              ORRS     r2,r2,r0
;;;557                           ETH_InitStruct->ETH_ReceiveStoreForward |
;;;558                           ETH_InitStruct->ETH_FlushReceivedFrame |
;;;559                           ETH_InitStruct->ETH_TransmitStoreForward | 
;;;560                           ETH_InitStruct->ETH_TransmitThresholdControl |
;;;561                           ETH_InitStruct->ETH_ForwardErrorFrames |
;;;562                           ETH_InitStruct->ETH_ForwardUndersizedGoodFrames |
;;;563                           ETH_InitStruct->ETH_ReceiveThresholdControl |
;;;564                           ETH_InitStruct->ETH_SecondFrameOperate); 
;;;565      /* Write to ETHERNET DMAOMR */
;;;566      ETH->DMAOMR = (uint32_t)tmpreg;
000216  618a              STR      r2,[r1,#0x18]
;;;567    
;;;568      /* Wait until the write operation will be taken into account :
;;;569       at least four TX_CLK/RX_CLK clock cycles */
;;;570      tmpreg = ETH->DMAOMR;
000218  698e              LDR      r6,[r1,#0x18]
;;;571      _eth_delay_(ETH_REG_WRITE_DELAY);
00021a  4628              MOV      r0,r5
00021c  f7fffffe          BL       ETH_Delay
;;;572      ETH->DMAOMR = tmpreg;
000220  618e              STR      r6,[r1,#0x18]
000222  e9d4021b          LDRD     r0,r2,[r4,#0x6c]
;;;573    
;;;574      /*----------------------- ETHERNET DMABMR Configuration --------------------*/
;;;575      /* Set the AAL bit according to ETH_AddressAlignedBeats value */
;;;576      /* Set the FB bit according to ETH_FixedBurst value */
;;;577      /* Set the RPBL and 4*PBL bits according to ETH_RxDMABurstLength value */
;;;578      /* Set the PBL and 4*PBL bits according to ETH_TxDMABurstLength value */
;;;579      /* Set the DSL bit according to ETH_DesciptorSkipLength value */
;;;580      /* Set the PR and DA bits according to ETH_DMAArbitration value */
;;;581      ETH->DMABMR = (uint32_t)(ETH_InitStruct->ETH_AddressAlignedBeats | 
000226  4310              ORRS     r0,r0,r2
000228  6f62              LDR      r2,[r4,#0x74]
00022a  f8543f78          LDR      r3,[r4,#0x78]!
00022e  431a              ORRS     r2,r2,r3
000230  4310              ORRS     r0,r0,r2
000232  6862              LDR      r2,[r4,#4]
000234  ea400082          ORR      r0,r0,r2,LSL #2
000238  68a2              LDR      r2,[r4,#8]
00023a  4310              ORRS     r0,r0,r2
00023c  f4400000          ORR      r0,r0,#0x800000
000240  6008              STR      r0,[r1,#0]
;;;582                               ETH_InitStruct->ETH_FixedBurst |
;;;583                               ETH_InitStruct->ETH_RxDMABurstLength | /* !! if 4xPBL is selected for Tx or Rx it is applied for the other */
;;;584                               ETH_InitStruct->ETH_TxDMABurstLength | 
;;;585                               (ETH_InitStruct->ETH_DescriptorSkipLength << 2) |
;;;586                               ETH_InitStruct->ETH_DMAArbitration |
;;;587                               ETH_DMABMR_USP); /* Enable use of separate PBL for Rx and Tx */
;;;588    
;;;589      /* Wait until the write operation will be taken into account :
;;;590       at least four TX_CLK/RX_CLK clock cycles */
;;;591      tmpreg = ETH->DMABMR;
000242  680c              LDR      r4,[r1,#0]
;;;592      _eth_delay_(ETH_REG_WRITE_DELAY);
000244  4628              MOV      r0,r5
000246  f7fffffe          BL       ETH_Delay
;;;593      ETH->DMABMR = tmpreg;
00024a  600c              STR      r4,[r1,#0]
;;;594    
;;;595    #ifdef USE_ENHANCED_DMA_DESCRIPTORS
;;;596      /* Enable the Enhanced DMA descriptors */
;;;597      ETH->DMABMR |= ETH_DMABMR_EDE;
00024c  6808              LDR      r0,[r1,#0]
00024e  f0400080          ORR      r0,r0,#0x80
000252  6008              STR      r0,[r1,#0]
;;;598    
;;;599      /* Wait until the write operation will be taken into account :
;;;600       at least four TX_CLK/RX_CLK clock cycles */
;;;601      tmpreg = ETH->DMABMR;
000254  680c              LDR      r4,[r1,#0]
;;;602      _eth_delay_(ETH_REG_WRITE_DELAY);
000256  4628              MOV      r0,r5
000258  f7fffffe          BL       ETH_Delay
;;;603      ETH->DMABMR = tmpreg;
00025c  600c              STR      r4,[r1,#0]
;;;604    #endif /* USE_ENHANCED_DMA_DESCRIPTORS */
;;;605    
;;;606      /* Return Ethernet configuration success */
;;;607      if(err == ETH_SUCCESS)
00025e  9800              LDR      r0,[sp,#0]
000260  2801              CMP      r0,#1
000262  d000              BEQ      |L52.614|
;;;608      {
;;;609        /* Return Ethernet configuration success */
;;;610        return ETH_SUCCESS;
;;;611      }
;;;612      else /* Auto-negotiation failed */
;;;613      {
;;;614        /* Return Ethernet error */
;;;615        return ETH_ERROR;
000264  2000              MOVS     r0,#0
                  |L52.614|
;;;616      }
;;;617    }
000266  b006              ADD      sp,sp,#0x18
000268  e8bd87f0          POP      {r4-r10,pc}
;;;618    
                          ENDP

                  |L52.620|
                          DCD      0x40028000
                  |L52.624|
                          DCD      0xfeced300
                  |L52.628|
                          DCD      0x00e4e1c0
                  |L52.632|
                          DCD      0xfde9f140
                  |L52.636|
                          DCD      0x017d7840
                  |L52.640|
                          DCD      0xfc6c7900
                  |L52.644|
                          DCD      0x02625a00
                  |L52.648|
                          DCD      0xfa0a1f00
                  |L52.652|
                          DCD      0x02faf080
                  |L52.656|
                          DCD      0x000fffff
                  |L52.660|
                          DCD      0x0004ffff
                  |L52.664|
                          DCD      0xff20810f
                  |L52.668|
                          DCD      0x40029000
                  |L52.672|
                          DCD      0xf8de3f23

                          AREA ||i.ETH_InitiatePauseControlFrame||, CODE, READONLY, ALIGN=2

                  ETH_InitiatePauseControlFrame PROC
;;;749      */
;;;750    void ETH_InitiatePauseControlFrame(void)  
000000  4907              LDR      r1,|L53.32|
;;;751    { 
000002  b508              PUSH     {r3,lr}
;;;752      __IO uint32_t tmpreg = 0;
;;;753      /* When Set In full duplex MAC initiates pause control frame */
;;;754      ETH->MACFCR |= ETH_MACFCR_FCBBPA;
000004  6988              LDR      r0,[r1,#0x18]
000006  f0400001          ORR      r0,r0,#1
00000a  6188              STR      r0,[r1,#0x18]
;;;755      
;;;756      /* Wait until the write operation will be taken into account :
;;;757       at least four TX_CLK/RX_CLK clock cycles */
;;;758      tmpreg = ETH->MACFCR;
00000c  6988              LDR      r0,[r1,#0x18]
;;;759      _eth_delay_(ETH_REG_WRITE_DELAY);
00000e  9000              STR      r0,[sp,#0]
000010  f64f70ff          MOV      r0,#0xffff
000014  f7fffffe          BL       ETH_Delay
;;;760      ETH->MACFCR = tmpreg;
000018  9800              LDR      r0,[sp,#0]
00001a  6188              STR      r0,[r1,#0x18]
;;;761    }
00001c  bd08              POP      {r3,pc}
;;;762    
                          ENDP

00001e  0000              DCW      0x0000
                  |L53.32|
                          DCD      0x40028000

                          AREA ||i.ETH_MACAddressConfig||, CODE, READONLY, ALIGN=2

                  ETH_MACAddressConfig PROC
;;;888      */
;;;889    void ETH_MACAddressConfig(uint32_t MacAddr, uint8_t *Addr)
000000  4b05              LDR      r3,|L54.24|
;;;890    {
;;;891      uint32_t tmpreg;
;;;892      /* Check the parameters */
;;;893      assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
;;;894      
;;;895      /* Calculate the selected MAC address high register */
;;;896      tmpreg = ((uint32_t)Addr[5] << 8) | (uint32_t)Addr[4];
000002  888a              LDRH     r2,[r1,#4]
;;;897      /* Load the selected MAC address high register */
;;;898      (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg;
000004  4418              ADD      r0,r0,r3
000006  6402              STR      r2,[r0,#0x40]
;;;899      /* Calculate the selected MAC address low register */
;;;900      tmpreg = ((uint32_t)Addr[3] << 24) | ((uint32_t)Addr[2] << 16) | ((uint32_t)Addr[1] << 8) | Addr[0];
000008  780a              LDRB     r2,[r1,#0]
00000a  f8d11001          LDR      r1,[r1,#1]
00000e  ea422101          ORR      r1,r2,r1,LSL #8
;;;901      
;;;902      /* Load the selected MAC address low register */
;;;903      (*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr)) = tmpreg;
000012  6441              STR      r1,[r0,#0x44]
;;;904    }
000014  4770              BX       lr
;;;905    
                          ENDP

000016  0000              DCW      0x0000
                  |L54.24|
                          DCD      0x40028000

                          AREA ||i.ETH_MACAddressFilterConfig||, CODE, READONLY, ALIGN=2

                  ETH_MACAddressFilterConfig PROC
;;;989      */
;;;990    void ETH_MACAddressFilterConfig(uint32_t MacAddr, uint32_t Filter)
000000  b518              PUSH     {r3,r4,lr}
;;;991    {
;;;992      __IO uint32_t tmpreg = 0;
000002  2200              MOVS     r2,#0
;;;993      /* Check the parameters */
;;;994      assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
;;;995      assert_param(IS_ETH_MAC_ADDRESS_FILTER(Filter));
;;;996      
;;;997      if (Filter != ETH_MAC_AddressFilter_DA)
;;;998      {
;;;999        /* The selected ETHERNET MAC address is used to compare with the SA fields of the
;;;1000       received frame. */
;;;1001       (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_SA;
000004  9200              STR      r2,[sp,#0]
000006  4a0a              LDR      r2,|L55.48|
000008  1884              ADDS     r4,r0,r2
00000a  2908              CMP      r1,#8                 ;997
;;;1002     }
;;;1003     else
;;;1004     {
;;;1005       /* The selected ETHERNET MAC address is used to compare with the DA fields of the
;;;1006       received frame. */
;;;1007       (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_SA);
00000c  6c20              LDR      r0,[r4,#0x40]
00000e  d002              BEQ      |L55.22|
000010  f0404080          ORR      r0,r0,#0x40000000     ;1001
000014  e001              B        |L55.26|
                  |L55.22|
000016  f0204080          BIC      r0,r0,#0x40000000
                  |L55.26|
00001a  6420              STR      r0,[r4,#0x40]
;;;1008     }
;;;1009     
;;;1010     /* Wait until the write operation will be taken into account :
;;;1011      at least four TX_CLK/RX_CLK clock cycles */
;;;1012     tmpreg = (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr));
00001c  6c20              LDR      r0,[r4,#0x40]
;;;1013     _eth_delay_(ETH_REG_WRITE_DELAY);
00001e  9000              STR      r0,[sp,#0]
000020  f64f70ff          MOV      r0,#0xffff
000024  f7fffffe          BL       ETH_Delay
;;;1014     (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg;
000028  9800              LDR      r0,[sp,#0]
00002a  6420              STR      r0,[r4,#0x40]
;;;1015   }
00002c  bd18              POP      {r3,r4,pc}
;;;1016   
                          ENDP

00002e  0000              DCW      0x0000
                  |L55.48|
                          DCD      0x40028000

                          AREA ||i.ETH_MACAddressMaskBytesFilterConfig||, CODE, READONLY, ALIGN=2

                  ETH_MACAddressMaskBytesFilterConfig PROC
;;;1033     */
;;;1034   void ETH_MACAddressMaskBytesFilterConfig(uint32_t MacAddr, uint32_t MaskByte)
000000  b538              PUSH     {r3-r5,lr}
;;;1035   {
;;;1036     __IO uint32_t tmpreg = 0;
;;;1037     /* Check the parameters */
;;;1038     assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
;;;1039     assert_param(IS_ETH_MAC_ADDRESS_MASK(MaskByte));
;;;1040     
;;;1041     /* Clear MBC bits in the selected MAC address  high register */
;;;1042     (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_MBC);
000002  4a0d              LDR      r2,|L56.56|
000004  1884              ADDS     r4,r0,r2
000006  6c20              LDR      r0,[r4,#0x40]
000008  f020507c          BIC      r0,r0,#0x3f000000
00000c  6420              STR      r0,[r4,#0x40]
;;;1043     
;;;1044     /* Wait until the write operation will be taken into account :
;;;1045      at least four TX_CLK/RX_CLK clock cycles */
;;;1046     tmpreg = (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr));
00000e  6c20              LDR      r0,[r4,#0x40]
;;;1047     _eth_delay_(ETH_REG_WRITE_DELAY);
000010  f64f75ff          MOV      r5,#0xffff
000014  9000              STR      r0,[sp,#0]
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       ETH_Delay
;;;1048     (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg;
00001c  9800              LDR      r0,[sp,#0]
00001e  6420              STR      r0,[r4,#0x40]
;;;1049     
;;;1050     /* Set the selected Filter mask bytes */
;;;1051     (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= MaskByte;
000020  6c20              LDR      r0,[r4,#0x40]
000022  4308              ORRS     r0,r0,r1
000024  6420              STR      r0,[r4,#0x40]
;;;1052     
;;;1053     /* Wait until the write operation will be taken into account :
;;;1054      at least four TX_CLK/RX_CLK clock cycles */
;;;1055     tmpreg = (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr));
000026  6c20              LDR      r0,[r4,#0x40]
;;;1056     _eth_delay_(ETH_REG_WRITE_DELAY);
000028  9000              STR      r0,[sp,#0]
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       ETH_Delay
;;;1057     (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg;
000030  9800              LDR      r0,[sp,#0]
000032  6420              STR      r0,[r4,#0x40]
;;;1058   }
000034  bd38              POP      {r3-r5,pc}
;;;1059   
                          ENDP

000036  0000              DCW      0x0000
                  |L56.56|
                          DCD      0x40028000

                          AREA ||i.ETH_MACAddressPerfectFilterCmd||, CODE, READONLY, ALIGN=2

                  ETH_MACAddressPerfectFilterCmd PROC
;;;949      */
;;;950    void ETH_MACAddressPerfectFilterCmd(uint32_t MacAddr, FunctionalState NewState)
000000  b518              PUSH     {r3,r4,lr}
;;;951    {
;;;952      __IO uint32_t tmpreg = 0;
000002  2200              MOVS     r2,#0
;;;953      /* Check the parameters */
;;;954      assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
;;;955      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;956      
;;;957      if (NewState != DISABLE)
;;;958      {
;;;959        /* Enable the selected ETHERNET MAC address for perfect filtering */
;;;960        (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_AE;
000004  9200              STR      r2,[sp,#0]
000006  4a09              LDR      r2,|L57.44|
000008  1884              ADDS     r4,r0,r2
;;;961      }
;;;962      else
;;;963      {
;;;964        /* Disable the selected ETHERNET MAC address for perfect filtering */
;;;965        (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_AE);
00000a  6c20              LDR      r0,[r4,#0x40]
00000c  b111              CBZ      r1,|L57.20|
00000e  f0404000          ORR      r0,r0,#0x80000000     ;960
000012  e001              B        |L57.24|
                  |L57.20|
000014  f0204000          BIC      r0,r0,#0x80000000
                  |L57.24|
000018  6420              STR      r0,[r4,#0x40]
;;;966      }
;;;967      
;;;968      /* Wait until the write operation will be taken into account :
;;;969       at least four TX_CLK/RX_CLK clock cycles */
;;;970      tmpreg = (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr));
00001a  6c20              LDR      r0,[r4,#0x40]
;;;971      _eth_delay_(ETH_REG_WRITE_DELAY);
00001c  9000              STR      r0,[sp,#0]
00001e  f64f70ff          MOV      r0,#0xffff
000022  f7fffffe          BL       ETH_Delay
;;;972      (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg;
000026  9800              LDR      r0,[sp,#0]
000028  6420              STR      r0,[r4,#0x40]
;;;973    }
00002a  bd18              POP      {r3,r4,pc}
;;;974    
                          ENDP

                  |L57.44|
                          DCD      0x40028000

                          AREA ||i.ETH_MACITConfig||, CODE, READONLY, ALIGN=2

                  ETH_MACITConfig PROC
;;;859      */
;;;860    void ETH_MACITConfig(uint32_t ETH_MAC_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L58.20|
;;;861    {
;;;862      /* Check the parameters */
;;;863      assert_param(IS_ETH_MAC_IT(ETH_MAC_IT));
;;;864      assert_param(IS_FUNCTIONAL_STATE(NewState));  
;;;865      
;;;866      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;867      {
;;;868        /* Enable the selected ETHERNET MAC interrupts */
;;;869        ETH->MACIMR &= (~(uint32_t)ETH_MAC_IT);
;;;870      }
;;;871      else
;;;872      {
;;;873        /* Disable the selected ETHERNET MAC interrupts */
;;;874        ETH->MACIMR |= ETH_MAC_IT;
000004  6bd1              LDR      r1,[r2,#0x3c]
000006  d001              BEQ      |L58.12|
000008  4381              BICS     r1,r1,r0              ;869
00000a  e000              B        |L58.14|
                  |L58.12|
00000c  4301              ORRS     r1,r1,r0
                  |L58.14|
00000e  63d1              STR      r1,[r2,#0x3c]         ;869
;;;875      }
;;;876    }
000010  4770              BX       lr
;;;877    
                          ENDP

000012  0000              DCW      0x0000
                  |L58.20|
                          DCD      0x40028000

                          AREA ||i.ETH_MACReceptionCmd||, CODE, READONLY, ALIGN=2

                  ETH_MACReceptionCmd PROC
;;;700      */
;;;701    void ETH_MACReceptionCmd(FunctionalState NewState)
000000  b508              PUSH     {r3,lr}
;;;702    { 
;;;703      __IO uint32_t tmpreg = 0;
000002  2100              MOVS     r1,#0
;;;704      /* Check the parameters */
;;;705      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;706    
;;;707      if (NewState != DISABLE)
;;;708      {
;;;709        /* Enable the MAC reception */
;;;710        ETH->MACCR |= ETH_MACCR_RE;
000004  9100              STR      r1,[sp,#0]
000006  4909              LDR      r1,|L59.44|
000008  2800              CMP      r0,#0                 ;707
;;;711      }
;;;712      else
;;;713      {
;;;714        /* Disable the MAC reception */
;;;715        ETH->MACCR &= ~ETH_MACCR_RE; 
00000a  6808              LDR      r0,[r1,#0]
00000c  d002              BEQ      |L59.20|
00000e  f0400004          ORR      r0,r0,#4              ;710
000012  e001              B        |L59.24|
                  |L59.20|
000014  f0200004          BIC      r0,r0,#4
                  |L59.24|
000018  6008              STR      r0,[r1,#0]
;;;716      }
;;;717    
;;;718      /* Wait until the write operation will be taken into account :
;;;719       at least four TX_CLK/RX_CLK clock cycles */
;;;720      tmpreg = ETH->MACCR;
00001a  6808              LDR      r0,[r1,#0]
;;;721      _eth_delay_(ETH_REG_WRITE_DELAY);
00001c  9000              STR      r0,[sp,#0]
00001e  f64f70ff          MOV      r0,#0xffff
000022  f7fffffe          BL       ETH_Delay
;;;722      ETH->MACCR = tmpreg;
000026  9800              LDR      r0,[sp,#0]
000028  6008              STR      r0,[r1,#0]
;;;723    }
00002a  bd08              POP      {r3,pc}
;;;724    
                          ENDP

                  |L59.44|
                          DCD      0x40028000

                          AREA ||i.ETH_MACTransmissionCmd||, CODE, READONLY, ALIGN=2

                  ETH_MACTransmissionCmd PROC
;;;670      */
;;;671    void ETH_MACTransmissionCmd(FunctionalState NewState)
000000  b508              PUSH     {r3,lr}
;;;672    { 
;;;673      __IO uint32_t tmpreg = 0;
000002  2100              MOVS     r1,#0
;;;674      /* Check the parameters */
;;;675      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;676      
;;;677      if (NewState != DISABLE)
;;;678      {
;;;679        /* Enable the MAC transmission */
;;;680        ETH->MACCR |= ETH_MACCR_TE;
000004  9100              STR      r1,[sp,#0]
000006  4909              LDR      r1,|L60.44|
000008  2800              CMP      r0,#0                 ;677
;;;681      }
;;;682      else
;;;683      {
;;;684        /* Disable the MAC transmission */
;;;685        ETH->MACCR &= ~ETH_MACCR_TE;
00000a  6808              LDR      r0,[r1,#0]
00000c  d002              BEQ      |L60.20|
00000e  f0400008          ORR      r0,r0,#8              ;680
000012  e001              B        |L60.24|
                  |L60.20|
000014  f0200008          BIC      r0,r0,#8
                  |L60.24|
000018  6008              STR      r0,[r1,#0]
;;;686      }
;;;687    
;;;688      /* Wait until the write operation will be taken into account :
;;;689       at least four TX_CLK/RX_CLK clock cycles */
;;;690      tmpreg = ETH->MACCR;
00001a  6808              LDR      r0,[r1,#0]
;;;691      _eth_delay_(ETH_REG_WRITE_DELAY);
00001c  9000              STR      r0,[sp,#0]
00001e  f64f70ff          MOV      r0,#0xffff
000022  f7fffffe          BL       ETH_Delay
;;;692      ETH->MACCR = tmpreg;
000026  9800              LDR      r0,[sp,#0]
000028  6008              STR      r0,[r1,#0]
;;;693    }
00002a  bd08              POP      {r3,pc}
;;;694    
                          ENDP

                  |L60.44|
                          DCD      0x40028000

                          AREA ||i.ETH_MMCCounterFreezeCmd||, CODE, READONLY, ALIGN=2

                  ETH_MMCCounterFreezeCmd PROC
;;;2624     */
;;;2625   void ETH_MMCCounterFreezeCmd(FunctionalState NewState)
000000  4906              LDR      r1,|L61.28|
;;;2626   {
;;;2627     /* Check the parameters */
;;;2628     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2629     
;;;2630     if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;2631     {
;;;2632       /* Enable the MMC Counter Freeze */
;;;2633       ETH->MMCCR |= ETH_MMCCR_MCF;
;;;2634     }
;;;2635     else
;;;2636     {
;;;2637       /* Disable the MMC Counter Freeze */
;;;2638       ETH->MMCCR &= ~ETH_MMCCR_MCF;
000004  f8d10100          LDR      r0,[r1,#0x100]
000008  d002              BEQ      |L61.16|
00000a  f0400008          ORR      r0,r0,#8              ;2633
00000e  e001              B        |L61.20|
                  |L61.16|
000010  f0200008          BIC      r0,r0,#8
                  |L61.20|
000014  f8c10100          STR      r0,[r1,#0x100]        ;2633
;;;2639     }
;;;2640   }
000018  4770              BX       lr
;;;2641   
                          ENDP

00001a  0000              DCW      0x0000
                  |L61.28|
                          DCD      0x40028000

                          AREA ||i.ETH_MMCCounterFullPreset||, CODE, READONLY, ALIGN=2

                  ETH_MMCCounterFullPreset PROC
;;;2598     */
;;;2599   void ETH_MMCCounterFullPreset(void)
000000  4803              LDR      r0,|L62.16|
;;;2600   {
;;;2601     /* Preset and Initialize the MMC counters to almost-full value */
;;;2602     ETH->MMCCR |= ETH_MMCCR_MCFHP | ETH_MMCCR_MCP;
000002  f8d01100          LDR      r1,[r0,#0x100]
000006  f0410130          ORR      r1,r1,#0x30
00000a  f8c01100          STR      r1,[r0,#0x100]
;;;2603   }
00000e  4770              BX       lr
;;;2604   
                          ENDP

                  |L62.16|
                          DCD      0x40028000

                          AREA ||i.ETH_MMCCounterHalfPreset||, CODE, READONLY, ALIGN=2

                  ETH_MMCCounterHalfPreset PROC
;;;2609     */
;;;2610   void ETH_MMCCounterHalfPreset(void)
000000  4806              LDR      r0,|L63.28|
;;;2611   {
;;;2612     /* Preset the MMC counters to almost-full value */
;;;2613     ETH->MMCCR &= ~ETH_MMCCR_MCFHP;
000002  f8d01100          LDR      r1,[r0,#0x100]
000006  f0210120          BIC      r1,r1,#0x20
00000a  f8c01100          STR      r1,[r0,#0x100]
;;;2614     
;;;2615     /* Initialize the MMC counters to almost-half value */
;;;2616     ETH->MMCCR |= ETH_MMCCR_MCP;
00000e  f8d01100          LDR      r1,[r0,#0x100]
000012  f0410110          ORR      r1,r1,#0x10
000016  f8c01100          STR      r1,[r0,#0x100]
;;;2617   }
00001a  4770              BX       lr
;;;2618   
                          ENDP

                  |L63.28|
                          DCD      0x40028000

                          AREA ||i.ETH_MMCCounterRolloverCmd||, CODE, READONLY, ALIGN=2

                  ETH_MMCCounterRolloverCmd PROC
;;;2670     */
;;;2671   void ETH_MMCCounterRolloverCmd(FunctionalState NewState)
000000  4906              LDR      r1,|L64.28|
;;;2672   {
;;;2673     /* Check the parameters */
;;;2674     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2675     
;;;2676     if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;2677     {
;;;2678       /* Disable the MMC Counter Stop Rollover  */
;;;2679       ETH->MMCCR &= ~ETH_MMCCR_CSR;
;;;2680     }
;;;2681     else
;;;2682     {
;;;2683       /* Enable the MMC Counter Stop Rollover */
;;;2684       ETH->MMCCR |= ETH_MMCCR_CSR; 
000004  f8d10100          LDR      r0,[r1,#0x100]
000008  d002              BEQ      |L64.16|
00000a  f0200002          BIC      r0,r0,#2              ;2679
00000e  e001              B        |L64.20|
                  |L64.16|
000010  f0400002          ORR      r0,r0,#2
                  |L64.20|
000014  f8c10100          STR      r0,[r1,#0x100]        ;2679
;;;2685     }
;;;2686   }
000018  4770              BX       lr
;;;2687   
                          ENDP

00001a  0000              DCW      0x0000
                  |L64.28|
                          DCD      0x40028000

                          AREA ||i.ETH_MMCCountersReset||, CODE, READONLY, ALIGN=2

                  ETH_MMCCountersReset PROC
;;;2692     */
;;;2693   void ETH_MMCCountersReset(void)
000000  4803              LDR      r0,|L65.16|
;;;2694   {
;;;2695     /* Resets the MMC Counters */
;;;2696     ETH->MMCCR |= ETH_MMCCR_CR;
000002  f8d01100          LDR      r1,[r0,#0x100]
000006  f0410101          ORR      r1,r1,#1
00000a  f8c01100          STR      r1,[r0,#0x100]
;;;2697   }
00000e  4770              BX       lr
;;;2698   
                          ENDP

                  |L65.16|
                          DCD      0x40028000

                          AREA ||i.ETH_MMCITConfig||, CODE, READONLY, ALIGN=2

                  ETH_MMCITConfig PROC
;;;2713     */
;;;2714   void ETH_MMCITConfig(uint32_t ETH_MMC_IT, FunctionalState NewState)
000000  4a0c              LDR      r2,|L66.52|
;;;2715   { 
;;;2716     /* Check the parameters */
;;;2717     assert_param(IS_ETH_MMC_IT(ETH_MMC_IT));  
;;;2718     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2719     
;;;2720     if ((ETH_MMC_IT & (uint32_t)0x10000000) != (uint32_t)RESET)
000002  00c3              LSLS     r3,r0,#3
000004  d50b              BPL      |L66.30|
;;;2721     {
;;;2722       /* Remove Register mak from IT */
;;;2723       ETH_MMC_IT &= 0xEFFFFFFF;
;;;2724   
;;;2725       /* ETHERNET MMC Rx interrupts selected */
;;;2726       if (NewState != DISABLE)
000006  2900              CMP      r1,#0
;;;2727       {
;;;2728         /* Enable the selected ETHERNET MMC interrupts */
;;;2729         ETH->MMCRIMR &=(~(uint32_t)ETH_MMC_IT);
;;;2730       }
;;;2731       else
;;;2732       {
;;;2733         /* Disable the selected ETHERNET MMC interrupts */
;;;2734         ETH->MMCRIMR |= ETH_MMC_IT;    
000008  f8d2110c          LDR      r1,[r2,#0x10c]
00000c  f0205080          BIC      r0,r0,#0x10000000     ;2723
000010  d001              BEQ      |L66.22|
000012  4381              BICS     r1,r1,r0              ;2729
000014  e000              B        |L66.24|
                  |L66.22|
000016  4301              ORRS     r1,r1,r0
                  |L66.24|
000018  f8c2110c          STR      r1,[r2,#0x10c]
;;;2735       }
;;;2736     }
;;;2737     else
;;;2738     {
;;;2739       /* ETHERNET MMC Tx interrupts selected */
;;;2740       if (NewState != DISABLE)
;;;2741       {
;;;2742         /* Enable the selected ETHERNET MMC interrupts */
;;;2743         ETH->MMCTIMR &=(~(uint32_t)ETH_MMC_IT);
;;;2744       }
;;;2745       else
;;;2746       {
;;;2747         /* Disable the selected ETHERNET MMC interrupts */
;;;2748         ETH->MMCTIMR |= ETH_MMC_IT;    
;;;2749       }  
;;;2750     }
;;;2751   }
00001c  4770              BX       lr
                  |L66.30|
00001e  2900              CMP      r1,#0                 ;2740
000020  f8d21110          LDR      r1,[r2,#0x110]        ;2748
000024  d001              BEQ      |L66.42|
000026  4381              BICS     r1,r1,r0              ;2743
000028  e000              B        |L66.44|
                  |L66.42|
00002a  4301              ORRS     r1,r1,r0              ;2748
                  |L66.44|
00002c  f8c21110          STR      r1,[r2,#0x110]        ;2748
000030  4770              BX       lr
;;;2752   
                          ENDP

000032  0000              DCW      0x0000
                  |L66.52|
                          DCD      0x40028000

                          AREA ||i.ETH_MMCResetOnReadCmd||, CODE, READONLY, ALIGN=2

                  ETH_MMCResetOnReadCmd PROC
;;;2647     */
;;;2648   void ETH_MMCResetOnReadCmd(FunctionalState NewState)
000000  4906              LDR      r1,|L67.28|
;;;2649   {
;;;2650     /* Check the parameters */
;;;2651     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2652     
;;;2653     if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;2654     {
;;;2655       /* Enable the MMC Counter reset on read */
;;;2656       ETH->MMCCR |= ETH_MMCCR_ROR; 
;;;2657     }
;;;2658     else
;;;2659     {
;;;2660       /* Disable the MMC Counter reset on read */
;;;2661       ETH->MMCCR &= ~ETH_MMCCR_ROR;
000004  f8d10100          LDR      r0,[r1,#0x100]
000008  d002              BEQ      |L67.16|
00000a  f0400004          ORR      r0,r0,#4              ;2656
00000e  e001              B        |L67.20|
                  |L67.16|
000010  f0200004          BIC      r0,r0,#4
                  |L67.20|
000014  f8c10100          STR      r0,[r1,#0x100]        ;2656
;;;2662     }
;;;2663   }
000018  4770              BX       lr
;;;2664   
                          ENDP

00001a  0000              DCW      0x0000
                  |L67.28|
                          DCD      0x40028000

                          AREA ||i.ETH_MagicPacketDetectionCmd||, CODE, READONLY, ALIGN=2

                  ETH_MagicPacketDetectionCmd PROC
;;;2535     */
;;;2536   void ETH_MagicPacketDetectionCmd(FunctionalState NewState)
000000  b508              PUSH     {r3,lr}
;;;2537   { 
;;;2538     __IO uint32_t tmpreg = 0;
000002  2100              MOVS     r1,#0
;;;2539     /* Check the parameters */
;;;2540     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2541   
;;;2542     if (NewState != DISABLE)
;;;2543     {
;;;2544       /* Enable the MAC Magic Packet Detection */
;;;2545       ETH->MACPMTCSR |= ETH_MACPMTCSR_MPE;
000004  9100              STR      r1,[sp,#0]
000006  4909              LDR      r1,|L68.44|
000008  2800              CMP      r0,#0                 ;2542
;;;2546     }
;;;2547     else
;;;2548     {
;;;2549       /* Disable the MAC Magic Packet Detection */
;;;2550       ETH->MACPMTCSR &= ~ETH_MACPMTCSR_MPE;
00000a  6ac8              LDR      r0,[r1,#0x2c]
00000c  d002              BEQ      |L68.20|
00000e  f0400002          ORR      r0,r0,#2              ;2545
000012  e001              B        |L68.24|
                  |L68.20|
000014  f0200002          BIC      r0,r0,#2
                  |L68.24|
000018  62c8              STR      r0,[r1,#0x2c]
;;;2551     }
;;;2552   
;;;2553     /* Wait until the write operation will be taken into account :
;;;2554      at least four TX_CLK/RX_CLK clock cycles */
;;;2555     tmpreg = ETH->MACPMTCSR;
00001a  6ac8              LDR      r0,[r1,#0x2c]
;;;2556     _eth_delay_(ETH_REG_WRITE_DELAY);
00001c  9000              STR      r0,[sp,#0]
00001e  f64f70ff          MOV      r0,#0xffff
000022  f7fffffe          BL       ETH_Delay
;;;2557     ETH->MACPMTCSR = tmpreg;
000026  9800              LDR      r0,[sp,#0]
000028  62c8              STR      r0,[r1,#0x2c]
;;;2558   }
00002a  bd08              POP      {r3,pc}
;;;2559   
                          ENDP

                  |L68.44|
                          DCD      0x40028000

                          AREA ||i.ETH_PHYLoopBackCmd||, CODE, READONLY, ALIGN=1

                  ETH_PHYLoopBackCmd PROC
;;;2366     */
;;;2367   uint32_t ETH_PHYLoopBackCmd(uint16_t PHYAddress, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;2368   {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;2369     uint16_t tmpreg = 0;
;;;2370     /* Check the parameters */
;;;2371     assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
;;;2372     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2373   
;;;2374     /* Get the PHY configuration to update it */
;;;2375     tmpreg = ETH_ReadPHYRegister(PHYAddress, PHY_BCR); 
000006  2100              MOVS     r1,#0
000008  f7fffffe          BL       ETH_ReadPHYRegister
;;;2376   
;;;2377     if (NewState != DISABLE)
00000c  b114              CBZ      r4,|L69.20|
;;;2378     {
;;;2379       /* Enable the PHY loopback mode */
;;;2380       tmpreg |= PHY_Loopback;
00000e  f4404280          ORR      r2,r0,#0x4000
000012  e001              B        |L69.24|
                  |L69.20|
;;;2381     }
;;;2382     else
;;;2383     {
;;;2384       /* Disable the PHY loopback mode: normal mode */
;;;2385       tmpreg &= (uint16_t)(~(uint16_t)PHY_Loopback);
000014  f4204280          BIC      r2,r0,#0x4000
                  |L69.24|
;;;2386     }
;;;2387     /* Update the PHY control register with the new configuration */
;;;2388     if(ETH_WritePHYRegister(PHYAddress, PHY_BCR, tmpreg) != (uint32_t)RESET)
000018  2100              MOVS     r1,#0
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       ETH_WritePHYRegister
000020  2800              CMP      r0,#0
000022  d000              BEQ      |L69.38|
;;;2389     {
;;;2390       return ETH_SUCCESS;
000024  2001              MOVS     r0,#1
                  |L69.38|
;;;2391     }
;;;2392     else
;;;2393     {
;;;2394       /* Return SUCCESS */
;;;2395       return ETH_ERROR; 
;;;2396     }
;;;2397   }
000026  bd30              POP      {r4,r5,pc}
;;;2398   
                          ENDP


                          AREA ||i.ETH_PowerDownCmd||, CODE, READONLY, ALIGN=2

                  ETH_PowerDownCmd PROC
;;;2565     */
;;;2566   void ETH_PowerDownCmd(FunctionalState NewState)
000000  b508              PUSH     {r3,lr}
;;;2567   { 
;;;2568     __IO uint32_t tmpreg = 0;
000002  2100              MOVS     r1,#0
;;;2569     /* Check the parameters */
;;;2570     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2571     
;;;2572     if (NewState != DISABLE)
;;;2573     {
;;;2574       /* Enable the MAC Power Down */
;;;2575       /* This puts the MAC in power down mode */
;;;2576       ETH->MACPMTCSR |= ETH_MACPMTCSR_PD;
000004  9100              STR      r1,[sp,#0]
000006  4909              LDR      r1,|L70.44|
000008  2800              CMP      r0,#0                 ;2572
;;;2577     }
;;;2578     else
;;;2579     {
;;;2580       /* Disable the MAC Power Down */ 
;;;2581       ETH->MACPMTCSR &= ~ETH_MACPMTCSR_PD;
00000a  6ac8              LDR      r0,[r1,#0x2c]
00000c  d002              BEQ      |L70.20|
00000e  f0400001          ORR      r0,r0,#1              ;2576
000012  e001              B        |L70.24|
                  |L70.20|
000014  f0200001          BIC      r0,r0,#1
                  |L70.24|
000018  62c8              STR      r0,[r1,#0x2c]
;;;2582     }
;;;2583   
;;;2584     /* Wait until the write operation will be taken into account :
;;;2585      at least four TX_CLK/RX_CLK clock cycles */
;;;2586     tmpreg = ETH->MACPMTCSR;
00001a  6ac8              LDR      r0,[r1,#0x2c]
;;;2587     _eth_delay_(ETH_REG_WRITE_DELAY);
00001c  9000              STR      r0,[sp,#0]
00001e  f64f70ff          MOV      r0,#0xffff
000022  f7fffffe          BL       ETH_Delay
;;;2588     ETH->MACPMTCSR = tmpreg;
000026  9800              LDR      r0,[sp,#0]
000028  62c8              STR      r0,[r1,#0x2c]
;;;2589   }
00002a  bd08              POP      {r3,pc}
;;;2590   
                          ENDP

                  |L70.44|
                          DCD      0x40028000

                          AREA ||i.ETH_Prepare_Transmit_Descriptors||, CODE, READONLY, ALIGN=2

                  ETH_Prepare_Transmit_Descriptors PROC
;;;1170     */
;;;1171   uint32_t ETH_Prepare_Transmit_Descriptors(u16 FrameLength)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1172   {   
;;;1173     uint32_t buf_count =0, size=0,i=0;
;;;1174     __IO ETH_DMADESCTypeDef *DMATxDesc;
;;;1175   
;;;1176     /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
;;;1177     if((DMATxDescToSet->Status & ETH_DMATxDesc_OWN) != (u32)RESET)
000002  4e29              LDR      r6,|L71.168|
000004  2200              MOVS     r2,#0                 ;1173
000006  6831              LDR      r1,[r6,#0]  ; DMATxDescToSet
000008  680b              LDR      r3,[r1,#0]
00000a  2b00              CMP      r3,#0
00000c  da01              BGE      |L71.18|
;;;1178     {  
;;;1179       /* Return ERROR: OWN bit set */
;;;1180       return ETH_ERROR;
00000e  2000              MOVS     r0,#0
;;;1181     }
;;;1182   
;;;1183     DMATxDesc = DMATxDescToSet;
;;;1184     
;;;1185     if (FrameLength > ETH_TX_BUF_SIZE)
;;;1186     {
;;;1187       buf_count = FrameLength/ETH_TX_BUF_SIZE;
;;;1188       if (FrameLength%ETH_TX_BUF_SIZE) buf_count++;
;;;1189     }
;;;1190     else buf_count =1;
;;;1191   
;;;1192     if (buf_count ==1)
;;;1193     {
;;;1194       /*set LAST and FIRST segment */
;;;1195       DMATxDesc->Status |=ETH_DMATxDesc_FS|ETH_DMATxDesc_LS;
;;;1196       /* Set frame size */
;;;1197       DMATxDesc->ControlBufferSize = (FrameLength & ETH_DMATxDesc_TBS1);
;;;1198       /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
;;;1199       DMATxDesc->Status |= ETH_DMATxDesc_OWN;
;;;1200       DMATxDesc= (ETH_DMADESCTypeDef *)(DMATxDesc->Buffer2NextDescAddr);
;;;1201     }
;;;1202     else
;;;1203     {
;;;1204       for (i=0; i< buf_count; i++)
;;;1205       {
;;;1206         /* Clear FIRST and LAST segment bits */
;;;1207         DMATxDesc->Status &= ~(ETH_DMATxDesc_FS | ETH_DMATxDesc_LS);
;;;1208         
;;;1209         if (i==0) 
;;;1210         {
;;;1211           /* Setting the first segment bit */
;;;1212           DMATxDesc->Status |= ETH_DMATxDesc_FS;  
;;;1213         }
;;;1214   
;;;1215         /* Program size */
;;;1216         DMATxDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATxDesc_TBS1);
;;;1217         
;;;1218         if (i== (buf_count-1))
;;;1219         {
;;;1220           /* Setting the last segment bit */
;;;1221           DMATxDesc->Status |= ETH_DMATxDesc_LS;
;;;1222           size = FrameLength - (buf_count-1)*ETH_TX_BUF_SIZE;
;;;1223           DMATxDesc->ControlBufferSize = (size & ETH_DMATxDesc_TBS1);
;;;1224         }
;;;1225   
;;;1226         /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
;;;1227         DMATxDesc->Status |= ETH_DMATxDesc_OWN;
;;;1228   
;;;1229         DMATxDesc = (ETH_DMADESCTypeDef *)(DMATxDesc->Buffer2NextDescAddr);
;;;1230       }
;;;1231     }
;;;1232     
;;;1233     DMATxDescToSet = DMATxDesc;
;;;1234   
;;;1235     /* When Tx Buffer unavailable flag is set: clear it and resume transmission */
;;;1236     if ((ETH->DMASR & ETH_DMASR_TBUS) != (u32)RESET)
;;;1237     {
;;;1238       /* Clear TBUS ETHERNET DMA flag */
;;;1239       ETH->DMASR = ETH_DMASR_TBUS;
;;;1240       /* Resume DMA transmission*/
;;;1241       ETH->DMATPDR = 0;
;;;1242     }
;;;1243   
;;;1244     /* Return SUCCESS */
;;;1245     return ETH_SUCCESS;   
;;;1246   }
000010  bdf0              POP      {r4-r7,pc}
                  |L71.18|
000012  f24054f4          MOV      r4,#0x5f4             ;1185
000016  42a0              CMP      r0,r4                 ;1185
000018  d915              BLS      |L71.70|
00001a  fbb0f5f4          UDIV     r5,r0,r4              ;1188
00001e  fbb0f3f4          UDIV     r3,r0,r4              ;1187
000022  fb040515          MLS      r5,r4,r5,r0           ;1188
000026  b105              CBZ      r5,|L71.42|
000028  1c5b              ADDS     r3,r3,#1              ;1188
                  |L71.42|
00002a  2b01              CMP      r3,#1                 ;1192
00002c  d00b              BEQ      |L71.70|
00002e  f1c30701          RSB      r7,r3,#1              ;1222
000032  ebc717c7          RSB      r7,r7,r7,LSL #7       ;1222
000036  eb070747          ADD      r7,r7,r7,LSL #1       ;1222
00003a  eb000087          ADD      r0,r0,r7,LSL #2       ;1222
00003e  1e5d              SUBS     r5,r3,#1              ;1218
000040  f3c0000c          UBFX     r0,r0,#0,#13          ;1223
000044  e023              B        |L71.142|
                  |L71.70|
000046  680a              LDR      r2,[r1,#0]            ;1195
000048  f0425240          ORR      r2,r2,#0x30000000     ;1195
00004c  600a              STR      r2,[r1,#0]            ;1195
00004e  f3c0000c          UBFX     r0,r0,#0,#13          ;1197
000052  6048              STR      r0,[r1,#4]            ;1197
000054  6808              LDR      r0,[r1,#0]            ;1199
000056  f0404000          ORR      r0,r0,#0x80000000     ;1199
00005a  6008              STR      r0,[r1,#0]            ;1199
00005c  68c9              LDR      r1,[r1,#0xc]          ;1200
00005e  e018              B        |L71.146|
                  |L71.96|
000060  680f              LDR      r7,[r1,#0]            ;1207
000062  f0275740          BIC      r7,r7,#0x30000000     ;1207
000066  600f              STR      r7,[r1,#0]            ;1207
000068  b91a              CBNZ     r2,|L71.114|
00006a  680f              LDR      r7,[r1,#0]            ;1212
00006c  f0475780          ORR      r7,r7,#0x10000000     ;1212
000070  600f              STR      r7,[r1,#0]            ;1212
                  |L71.114|
000072  604c              STR      r4,[r1,#4]            ;1216
000074  42aa              CMP      r2,r5                 ;1218
000076  d104              BNE      |L71.130|
000078  680f              LDR      r7,[r1,#0]            ;1221
00007a  f0475700          ORR      r7,r7,#0x20000000     ;1221
00007e  600f              STR      r7,[r1,#0]            ;1221
000080  6048              STR      r0,[r1,#4]            ;1223
                  |L71.130|
000082  680f              LDR      r7,[r1,#0]            ;1227
000084  f0474700          ORR      r7,r7,#0x80000000     ;1227
000088  600f              STR      r7,[r1,#0]            ;1227
00008a  68c9              LDR      r1,[r1,#0xc]          ;1229
00008c  1c52              ADDS     r2,r2,#1              ;1229
                  |L71.142|
00008e  429a              CMP      r2,r3                 ;1204
000090  d3e6              BCC      |L71.96|
                  |L71.146|
000092  4806              LDR      r0,|L71.172|
000094  6031              STR      r1,[r6,#0]            ;1236  ; DMATxDescToSet
000096  6941              LDR      r1,[r0,#0x14]         ;1236
000098  0749              LSLS     r1,r1,#29             ;1236
00009a  d503              BPL      |L71.164|
00009c  2104              MOVS     r1,#4                 ;1239
00009e  6141              STR      r1,[r0,#0x14]         ;1239
0000a0  2100              MOVS     r1,#0                 ;1241
0000a2  6041              STR      r1,[r0,#4]            ;1241
                  |L71.164|
0000a4  2001              MOVS     r0,#1                 ;1245
0000a6  bdf0              POP      {r4-r7,pc}
;;;1247   
                          ENDP

                  |L71.168|
                          DCD      ||.data||
                  |L71.172|
                          DCD      0x40029000

                          AREA ||i.ETH_ReadPHYRegister||, CODE, READONLY, ALIGN=2

                  ETH_ReadPHYRegister PROC
;;;2272     */
;;;2273   uint16_t ETH_ReadPHYRegister(uint16_t PHYAddress, uint16_t PHYReg)
000000  b518              PUSH     {r3,r4,lr}
;;;2274   {
;;;2275     uint32_t tmpreg = 0;     
;;;2276     __IO uint32_t timeout = 0;
000002  2200              MOVS     r2,#0
;;;2277     /* Check the parameters */
;;;2278     assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
;;;2279     assert_param(IS_ETH_PHY_REG(PHYReg));
;;;2280     
;;;2281     /* Get the ETHERNET MACMIIAR value */
;;;2282     tmpreg = ETH->MACMIIAR;
000004  9200              STR      r2,[sp,#0]
000006  4a12              LDR      r2,|L72.80|
000008  6913              LDR      r3,[r2,#0x10]
;;;2283     /* Keep only the CSR Clock Range CR[2:0] bits value */
;;;2284     tmpreg &= ~MACMIIAR_CR_MASK;
;;;2285     /* Prepare the MII address register value */
;;;2286     tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA);/* Set the PHY device address */
00000a  f64f74ff          MOV      r4,#0xffff
00000e  f003031c          AND      r3,r3,#0x1c           ;2284
000012  ea0420c0          AND      r0,r4,r0,LSL #11
000016  4318              ORRS     r0,r0,r3
;;;2287     tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
000018  f44f63f8          MOV      r3,#0x7c0
00001c  ea031181          AND      r1,r3,r1,LSL #6
000020  4301              ORRS     r1,r1,r0
;;;2288     tmpreg &= ~ETH_MACMIIAR_MW;                              /* Set the read mode */
000022  f0210002          BIC      r0,r1,#2
;;;2289     tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
000026  f0400001          ORR      r0,r0,#1
;;;2290     /* Write the result value into the MII Address register */
;;;2291     ETH->MACMIIAR = tmpreg;
00002a  6110              STR      r0,[r2,#0x10]
;;;2292     /* Check for the Busy flag */
;;;2293     do
;;;2294     {
;;;2295       timeout++;
;;;2296       tmpreg = ETH->MACMIIAR;
;;;2297     } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_READ_TO));
00002c  4909              LDR      r1,|L72.84|
                  |L72.46|
00002e  9800              LDR      r0,[sp,#0]            ;2295
000030  1c40              ADDS     r0,r0,#1              ;2295
000032  9000              STR      r0,[sp,#0]            ;2296
000034  6910              LDR      r0,[r2,#0x10]         ;2296
000036  07c0              LSLS     r0,r0,#31
000038  d002              BEQ      |L72.64|
00003a  9800              LDR      r0,[sp,#0]
00003c  4288              CMP      r0,r1
00003e  d3f6              BCC      |L72.46|
                  |L72.64|
;;;2298     /* Return ERROR in case of timeout */
;;;2299     if(timeout == PHY_READ_TO)
000040  9800              LDR      r0,[sp,#0]
000042  4288              CMP      r0,r1
000044  d101              BNE      |L72.74|
;;;2300     {
;;;2301       return (uint16_t)ETH_ERROR;
000046  2000              MOVS     r0,#0
;;;2302     }
;;;2303     
;;;2304     /* Return data register value */
;;;2305     return (uint16_t)(ETH->MACMIIDR);
;;;2306   }
000048  bd18              POP      {r3,r4,pc}
                  |L72.74|
00004a  6950              LDR      r0,[r2,#0x14]         ;2305
00004c  b280              UXTH     r0,r0                 ;2305
00004e  bd18              POP      {r3,r4,pc}
;;;2307   
                          ENDP

                  |L72.80|
                          DCD      0x40028000
                  |L72.84|
                          DCD      0x0004ffff

                          AREA ||i.ETH_ResetWakeUpFrameFilterRegisterPointer||, CODE, READONLY, ALIGN=2

                  ETH_ResetWakeUpFrameFilterRegisterPointer PROC
;;;2406     */
;;;2407   void ETH_ResetWakeUpFrameFilterRegisterPointer(void)
000000  4907              LDR      r1,|L73.32|
;;;2408   {
000002  b508              PUSH     {r3,lr}
;;;2409     __IO uint32_t tmpreg = 0;
;;;2410     /* Resets the Remote Wake-up Frame Filter register pointer to 0x0000 */
;;;2411     ETH->MACPMTCSR |= ETH_MACPMTCSR_WFFRPR;
000004  6ac8              LDR      r0,[r1,#0x2c]
000006  f0404000          ORR      r0,r0,#0x80000000
00000a  62c8              STR      r0,[r1,#0x2c]
;;;2412     
;;;2413     /* Wait until the write operation will be taken into account :
;;;2414      at least four TX_CLK/RX_CLK clock cycles */
;;;2415     tmpreg = ETH->MACPMTCSR;
00000c  6ac8              LDR      r0,[r1,#0x2c]
;;;2416     _eth_delay_(ETH_REG_WRITE_DELAY);
00000e  9000              STR      r0,[sp,#0]
000010  f64f70ff          MOV      r0,#0xffff
000014  f7fffffe          BL       ETH_Delay
;;;2417     ETH->MACPMTCSR = tmpreg;
000018  9800              LDR      r0,[sp,#0]
00001a  62c8              STR      r0,[r1,#0x2c]
;;;2418   }
00001c  bd08              POP      {r3,pc}
;;;2419   
                          ENDP

00001e  0000              DCW      0x0000
                  |L73.32|
                          DCD      0x40028000

                          AREA ||i.ETH_ResumeDMAReception||, CODE, READONLY, ALIGN=2

                  ETH_ResumeDMAReception PROC
;;;2239     */
;;;2240   void ETH_ResumeDMAReception(void)
000000  4901              LDR      r1,|L74.8|
;;;2241   {
;;;2242     ETH->DMARPDR = 0;
000002  2000              MOVS     r0,#0
000004  6088              STR      r0,[r1,#8]
;;;2243   }
000006  4770              BX       lr
;;;2244   
                          ENDP

                  |L74.8|
                          DCD      0x40029000

                          AREA ||i.ETH_ResumeDMATransmission||, CODE, READONLY, ALIGN=2

                  ETH_ResumeDMATransmission PROC
;;;2228     */
;;;2229   void ETH_ResumeDMATransmission(void)
000000  4901              LDR      r1,|L75.8|
;;;2230   {
;;;2231     ETH->DMATPDR = 0;
000002  2000              MOVS     r0,#0
000004  6048              STR      r0,[r1,#4]
;;;2232   }
000006  4770              BX       lr
;;;2233   
                          ENDP

                  |L75.8|
                          DCD      0x40029000

                          AREA ||i.ETH_SetDMARxDescOwnBit||, CODE, READONLY, ALIGN=1

                  ETH_SetDMARxDescOwnBit PROC
;;;1682     */
;;;1683   void ETH_SetDMARxDescOwnBit(ETH_DMADESCTypeDef *DMARxDesc)
000000  6801              LDR      r1,[r0,#0]
;;;1684   {
;;;1685     /* Set the DMA Rx Desc Own bit */
;;;1686     DMARxDesc->Status |= ETH_DMARxDesc_OWN;
000002  f0414100          ORR      r1,r1,#0x80000000
000006  6001              STR      r1,[r0,#0]
;;;1687   }
000008  4770              BX       lr
;;;1688   
                          ENDP


                          AREA ||i.ETH_SetDMATxDescOwnBit||, CODE, READONLY, ALIGN=1

                  ETH_SetDMATxDescOwnBit PROC
;;;1443     */
;;;1444   void ETH_SetDMATxDescOwnBit(ETH_DMADESCTypeDef *DMATxDesc)
000000  6801              LDR      r1,[r0,#0]
;;;1445   {
;;;1446     /* Set the DMA Tx Desc Own bit */
;;;1447     DMATxDesc->Status |= ETH_DMATxDesc_OWN;
000002  f0414100          ORR      r1,r1,#0x80000000
000006  6001              STR      r1,[r0,#0]
;;;1448   }
000008  4770              BX       lr
;;;1449   
                          ENDP


                          AREA ||i.ETH_SetReceiveWatchdogTimer||, CODE, READONLY, ALIGN=2

                  ETH_SetReceiveWatchdogTimer PROC
;;;2249     */
;;;2250   void ETH_SetReceiveWatchdogTimer(uint8_t Value)
000000  4901              LDR      r1,|L78.8|
;;;2251   {
;;;2252     /* Set the DMA Receive status watchdog timer register */
;;;2253     ETH->DMARSWTR = Value;
000002  6248              STR      r0,[r1,#0x24]
;;;2254   }
000004  4770              BX       lr
;;;2255    
                          ENDP

000006  0000              DCW      0x0000
                  |L78.8|
                          DCD      0x40029000

                          AREA ||i.ETH_SetWakeUpFrameFilterRegister||, CODE, READONLY, ALIGN=2

                  ETH_SetWakeUpFrameFilterRegister PROC
;;;2424     */
;;;2425   void ETH_SetWakeUpFrameFilterRegister(uint32_t *Buffer)
000000  b578              PUSH     {r3-r6,lr}
;;;2426   {
000002  4605              MOV      r5,r0
;;;2427     __IO uint32_t tmpreg = 0;
000004  2000              MOVS     r0,#0
;;;2428     uint32_t i = 0;
;;;2429   
;;;2430     /* Fill Remote Wake-up Frame Filter register with Buffer data */
;;;2431     for(i =0; i<ETH_WAKEUP_REGISTER_LENGTH; i++)
;;;2432     {
;;;2433       /* Write each time to the same register */ 
;;;2434       ETH->MACRWUFFR = Buffer[i];
000006  4c09              LDR      r4,|L79.44|
000008  4601              MOV      r1,r0                 ;2428
;;;2435   
;;;2436       /* Wait until the write operation will be taken into account :
;;;2437        at least four TX_CLK/RX_CLK clock cycles */
;;;2438       tmpreg = ETH->MACRWUFFR;
;;;2439       _eth_delay_(ETH_REG_WRITE_DELAY);
00000a  f64f76ff          MOV      r6,#0xffff
00000e  9000              STR      r0,[sp,#0]
                  |L79.16|
000010  f8550021          LDR      r0,[r5,r1,LSL #2]     ;2434
000014  62a0              STR      r0,[r4,#0x28]         ;2434
000016  6aa0              LDR      r0,[r4,#0x28]         ;2438
000018  9000              STR      r0,[sp,#0]
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       ETH_Delay
;;;2440       ETH->MACRWUFFR = tmpreg;
000020  9800              LDR      r0,[sp,#0]
000022  62a0              STR      r0,[r4,#0x28]
000024  1c49              ADDS     r1,r1,#1
000026  2908              CMP      r1,#8                 ;2431
000028  d3f2              BCC      |L79.16|
;;;2441     }
;;;2442   }
00002a  bd78              POP      {r3-r6,pc}
;;;2443   
                          ENDP

                  |L79.44|
                          DCD      0x40028000

                          AREA ||i.ETH_SoftwareReset||, CODE, READONLY, ALIGN=2

                  ETH_SoftwareReset PROC
;;;1809     */
;;;1810   void ETH_SoftwareReset(void)
000000  4802              LDR      r0,|L80.12|
;;;1811   {
;;;1812     /* Set the SWR bit: resets all MAC subsystem internal registers and logic */
;;;1813     /* After reset all the registers holds their respective reset values */
;;;1814     ETH->DMABMR |= ETH_DMABMR_SR;
000002  6801              LDR      r1,[r0,#0]
000004  f0410101          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;1815   }
00000a  4770              BX       lr
;;;1816   
                          ENDP

                  |L80.12|
                          DCD      0x40029000

                          AREA ||i.ETH_Start||, CODE, READONLY, ALIGN=1

                  ETH_Start PROC
;;;623      */
;;;624    void ETH_Start(void)
000000  b500              PUSH     {lr}
;;;625    {
;;;626      /* Enable transmit state machine of the MAC for transmission on the MII */
;;;627      ETH_MACTransmissionCmd(ENABLE);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       ETH_MACTransmissionCmd
;;;628    
;;;629      /* Enable receive state machine of the MAC for reception from the MII */
;;;630      ETH_MACReceptionCmd(ENABLE);
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       ETH_MACReceptionCmd
;;;631    
;;;632      /* Flush Transmit FIFO */
;;;633      ETH_FlushTransmitFIFO();
00000e  f7fffffe          BL       ETH_FlushTransmitFIFO
;;;634    
;;;635      /* Start DMA transmission */
;;;636      ETH_DMATransmissionCmd(ENABLE);
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       ETH_DMATransmissionCmd
;;;637    
;;;638      /* Start DMA reception */
;;;639      ETH_DMAReceptionCmd(ENABLE);
000018  2001              MOVS     r0,#1
00001a  f85deb04          POP      {lr}
00001e  f7ffbffe          B.W      ETH_DMAReceptionCmd
;;;640    }
;;;641    
                          ENDP


                          AREA ||i.ETH_Stop||, CODE, READONLY, ALIGN=1

                  ETH_Stop PROC
;;;646      */
;;;647    void ETH_Stop(void)
000000  b500              PUSH     {lr}
;;;648    {  
;;;649      /* Stop DMA transmission */
;;;650      ETH_DMATransmissionCmd(DISABLE);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       ETH_DMATransmissionCmd
;;;651    
;;;652      /* Stop DMA reception */
;;;653      ETH_DMAReceptionCmd(DISABLE);
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       ETH_DMAReceptionCmd
;;;654    
;;;655      /* Disable receive state machine of the MAC for reception from the MII */
;;;656      ETH_MACReceptionCmd(DISABLE);
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       ETH_MACReceptionCmd
;;;657    
;;;658      /* Flush Transmit FIFO */
;;;659      ETH_FlushTransmitFIFO();
000014  f7fffffe          BL       ETH_FlushTransmitFIFO
;;;660    
;;;661      /* Disable transmit state machine of the MAC for transmission on the MII */
;;;662      ETH_MACTransmissionCmd(DISABLE);
000018  2000              MOVS     r0,#0
00001a  f85deb04          POP      {lr}
00001e  f7ffbffe          B.W      ETH_MACTransmissionCmd
;;;663    }
;;;664    
                          ENDP


                          AREA ||i.ETH_StructInit||, CODE, READONLY, ALIGN=1

                  ETH_StructInit PROC
;;;128      */
;;;129    void ETH_StructInit(ETH_InitTypeDef* ETH_InitStruct)
000000  2101              MOVS     r1,#1
;;;130    {
;;;131      /* ETH_InitStruct members default value */
;;;132      /*------------------------   MAC Configuration   ---------------------------*/
;;;133      
;;;134      /* PHY Auto-negotiation enabled */
;;;135      ETH_InitStruct->ETH_AutoNegotiation = ETH_AutoNegotiation_Enable;
;;;136      /* MAC watchdog enabled: cuts off long frame */
;;;137      ETH_InitStruct->ETH_Watchdog = ETH_Watchdog_Enable;
000002  6001              STR      r1,[r0,#0]
000004  2100              MOVS     r1,#0
;;;138      /* MAC Jabber enabled in Half-duplex mode */
;;;139      ETH_InitStruct->ETH_Jabber = ETH_Jabber_Enable;
000006  6041              STR      r1,[r0,#4]
;;;140      /* Ethernet interframe gap set to 96 bits */
;;;141      ETH_InitStruct->ETH_InterFrameGap = ETH_InterFrameGap_96Bit;
000008  6081              STR      r1,[r0,#8]
;;;142      /* Carrier Sense Enabled in Half-Duplex mode */
;;;143      ETH_InitStruct->ETH_CarrierSense = ETH_CarrierSense_Enable;
;;;144      /* PHY speed configured to 100Mbit/s */
;;;145      ETH_InitStruct->ETH_Speed = ETH_Speed_100M; 
00000a  f44f4280          MOV      r2,#0x4000
00000e  60c1              STR      r1,[r0,#0xc]
000010  e9c01204          STRD     r1,r2,[r0,#0x10]
;;;146      /* Receive own Frames in Half-Duplex mode enabled */
;;;147      ETH_InitStruct->ETH_ReceiveOwn = ETH_ReceiveOwn_Enable;
;;;148      /* MAC MII loopback disabled */ 
;;;149      ETH_InitStruct->ETH_LoopbackMode = ETH_LoopbackMode_Disable;
;;;150      /* Full-Duplex mode selected */
;;;151      ETH_InitStruct->ETH_Mode = ETH_Mode_FullDuplex;
000014  10d2              ASRS     r2,r2,#3
000016  6181              STR      r1,[r0,#0x18]
000018  e9c01207          STRD     r1,r2,[r0,#0x1c]
;;;152      /* IPv4 and TCP/UDP/ICMP frame Checksum Offload disabled */
;;;153      ETH_InitStruct->ETH_ChecksumOffload = ETH_ChecksumOffload_Disable;
;;;154      /* Retry Transmission enabled for half-duplex mode */ 
;;;155      ETH_InitStruct->ETH_RetryTransmission = ETH_RetryTransmission_Enable;
00001c  6241              STR      r1,[r0,#0x24]
;;;156      /* Automatic PAD/CRC strip disabled*/
;;;157      ETH_InitStruct->ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable;
00001e  6281              STR      r1,[r0,#0x28]
;;;158      /* half-duplex mode retransmission Backoff time_limit = 10 slot times*/ 
;;;159      ETH_InitStruct->ETH_BackOffLimit = ETH_BackOffLimit_10;
000020  62c1              STR      r1,[r0,#0x2c]
;;;160      /* half-duplex mode Deferral check disabled */
;;;161      ETH_InitStruct->ETH_DeferralCheck = ETH_DeferralCheck_Disable;
;;;162      /* Receive all frames disabled */
;;;163      ETH_InitStruct->ETH_ReceiveAll = ETH_ReceiveAll_Enable;
000022  0512              LSLS     r2,r2,#20
000024  6301              STR      r1,[r0,#0x30]
000026  e9c0120d          STRD     r1,r2,[r0,#0x34]
;;;164      /* Source address filtering (on the optional MAC addresses) disabled */
;;;165      ETH_InitStruct->ETH_SourceAddrFilter = ETH_SourceAddrFilter_Disable;
;;;166      /* Do not forward control frames that do not pass the address filtering */
;;;167      ETH_InitStruct->ETH_PassControlFrames = ETH_PassControlFrames_BlockAll;
00002a  2240              MOVS     r2,#0x40
00002c  e9c0120f          STRD     r1,r2,[r0,#0x3c]
;;;168      /* Disable reception of Broadcast frames */
;;;169      ETH_InitStruct->ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Disable;
000030  2220              MOVS     r2,#0x20
000032  e9c02111          STRD     r2,r1,[r0,#0x44]
;;;170      /* Normal Destination address filtering (not reverse addressing) */
;;;171      ETH_InitStruct->ETH_DestinationAddrFilter = ETH_DestinationAddrFilter_Normal;
;;;172      /* Promiscuous address filtering mode disabled */
;;;173      ETH_InitStruct->ETH_PromiscuousMode = ETH_PromiscuousMode_Disable;
;;;174      /* Perfect address filtering for multicast addresses */
;;;175      ETH_InitStruct->ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect;
000036  64c1              STR      r1,[r0,#0x4c]
;;;176      /* Perfect address filtering for unicast addresses */
;;;177      ETH_InitStruct->ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect;
000038  6501              STR      r1,[r0,#0x50]
;;;178      /* Initialize hash table high and low regs */
;;;179      ETH_InitStruct->ETH_HashTableHigh = 0x0;
00003a  6541              STR      r1,[r0,#0x54]
;;;180      ETH_InitStruct->ETH_HashTableLow = 0x0;
00003c  6581              STR      r1,[r0,#0x58]
;;;181      /* Flow control config (flow control disabled)*/
;;;182      ETH_InitStruct->ETH_PauseTime = 0x0;
;;;183      ETH_InitStruct->ETH_ZeroQuantaPause = ETH_ZeroQuantaPause_Disable;
00003e  2280              MOVS     r2,#0x80
000040  65c1              STR      r1,[r0,#0x5c]
000042  e9c01218          STRD     r1,r2,[r0,#0x60]
;;;184      ETH_InitStruct->ETH_PauseLowThreshold = ETH_PauseLowThreshold_Minus4;
;;;185      ETH_InitStruct->ETH_UnicastPauseFrameDetect = ETH_UnicastPauseFrameDetect_Disable;
000046  6681              STR      r1,[r0,#0x68]
;;;186      ETH_InitStruct->ETH_ReceiveFlowControl = ETH_ReceiveFlowControl_Disable;
000048  66c1              STR      r1,[r0,#0x6c]
;;;187      ETH_InitStruct->ETH_TransmitFlowControl = ETH_TransmitFlowControl_Disable;
00004a  6701              STR      r1,[r0,#0x70]
;;;188      /* VLANtag config (VLAN field not checked) */
;;;189      ETH_InitStruct->ETH_VLANTagComparison = ETH_VLANTagComparison_16Bit;
00004c  6741              STR      r1,[r0,#0x74]
;;;190      ETH_InitStruct->ETH_VLANTagIdentifier = 0x0;
;;;191      
;;;192      /*---------------------- DMA Configuration   -------------------------------*/
;;;193      
;;;194      /* Drops frames with with TCP/IP checksum errors */
;;;195      ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; 
00004e  04d2              LSLS     r2,r2,#19
000050  6781              STR      r1,[r0,#0x78]
000052  e9c0121f          STRD     r1,r2,[r0,#0x7c]
;;;196      /* Store and forward mode enabled for receive */
;;;197      ETH_InitStruct->ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;
000056  1052              ASRS     r2,r2,#1
;;;198      /* Flush received frame that created FIFO overflow */
;;;199      ETH_InitStruct->ETH_FlushReceivedFrame = ETH_FlushReceivedFrame_Enable;
;;;200      /* Store and forward mode enabled for transmit */
;;;201      ETH_InitStruct->ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;  
000058  e9c02121          STRD     r2,r1,[r0,#0x84]
00005c  1113              ASRS     r3,r2,#4
00005e  e9c03123          STRD     r3,r1,[r0,#0x8c]
;;;202      /* Threshold TXFIFO level set to 64 bytes (used when threshold mode is enabled) */
;;;203      ETH_InitStruct->ETH_TransmitThresholdControl = ETH_TransmitThresholdControl_64Bytes;
;;;204      /* Disable forwarding frames with errors (short frames, CRC,...)*/
;;;205      ETH_InitStruct->ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable;
;;;206      /* Disable undersized good frames */
;;;207      ETH_InitStruct->ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable;
000062  f8c01094          STR      r1,[r0,#0x94]
;;;208      /* Threshold RXFIFO level set to 64 bytes (used when Cut through mode is enabled) */
;;;209      ETH_InitStruct->ETH_ReceiveThresholdControl = ETH_ReceiveThresholdControl_64Bytes;
000066  f8c01098          STR      r1,[r0,#0x98]
00006a  f8c0109c          STR      r1,[r0,#0x9c]
00006e  e9c01228          STRD     r1,r2,[r0,#0xa0]
;;;210      /* Disable Operate on second frame (transmit a second frame to FIFO without 
;;;211      waiting status of previous frame*/
;;;212      ETH_InitStruct->ETH_SecondFrameOperate = ETH_SecondFrameOperate_Disable;
;;;213      /* DMA works on 32-bit aligned start source and destinations addresses */
;;;214      ETH_InitStruct->ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
;;;215      /* Enabled Fixed Burst Mode (mix of INC4, INC8, INC16 and SINGLE DMA transactions */
;;;216      ETH_InitStruct->ETH_FixedBurst = ETH_FixedBurst_Enable;
000072  1252              ASRS     r2,r2,#9
;;;217      /* DMA transfer max burst length = 32 beats = 32 x 32bits */
;;;218      ETH_InitStruct->ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;
000074  f8c020a8          STR      r2,[r0,#0xa8]
000078  0192              LSLS     r2,r2,#6
;;;219      ETH_InitStruct->ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;
00007a  f8c020ac          STR      r2,[r0,#0xac]
00007e  1252              ASRS     r2,r2,#9
000080  e9c0212c          STRD     r2,r1,[r0,#0xb0]
;;;220      /* DMA Ring mode skip length = 0 */
;;;221      ETH_InitStruct->ETH_DescriptorSkipLength = 0x0; 
;;;222      /* Equal priority (round-robin) between transmit and receive DMA engines */
;;;223      ETH_InitStruct->ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_1_1;
000084  f8c010b8          STR      r1,[r0,#0xb8]
;;;224    }
000088  4770              BX       lr
;;;225    
                          ENDP


                          AREA ||i.ETH_WakeUpFrameDetectionCmd||, CODE, READONLY, ALIGN=2

                  ETH_WakeUpFrameDetectionCmd PROC
;;;2506     */
;;;2507   void ETH_WakeUpFrameDetectionCmd(FunctionalState NewState)
000000  b508              PUSH     {r3,lr}
;;;2508   { 
;;;2509     __IO uint32_t tmpreg = 0;
000002  2100              MOVS     r1,#0
;;;2510     /* Check the parameters */
;;;2511     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2512     
;;;2513     if (NewState != DISABLE)
;;;2514     {
;;;2515       /* Enable the MAC Wake-Up Frame Detection */
;;;2516       ETH->MACPMTCSR |= ETH_MACPMTCSR_WFE;
000004  9100              STR      r1,[sp,#0]
000006  4909              LDR      r1,|L84.44|
000008  2800              CMP      r0,#0                 ;2513
;;;2517     }
;;;2518     else
;;;2519     {
;;;2520       /* Disable the MAC Wake-Up Frame Detection */ 
;;;2521       ETH->MACPMTCSR &= ~ETH_MACPMTCSR_WFE;
00000a  6ac8              LDR      r0,[r1,#0x2c]
00000c  d002              BEQ      |L84.20|
00000e  f0400004          ORR      r0,r0,#4              ;2516
000012  e001              B        |L84.24|
                  |L84.20|
000014  f0200004          BIC      r0,r0,#4
                  |L84.24|
000018  62c8              STR      r0,[r1,#0x2c]
;;;2522     }
;;;2523     /* Wait until the write operation will be taken into account :
;;;2524      at least four TX_CLK/RX_CLK clock cycles */
;;;2525     tmpreg = ETH->MACPMTCSR;
00001a  6ac8              LDR      r0,[r1,#0x2c]
;;;2526     _eth_delay_(ETH_REG_WRITE_DELAY);
00001c  9000              STR      r0,[sp,#0]
00001e  f64f70ff          MOV      r0,#0xffff
000022  f7fffffe          BL       ETH_Delay
;;;2527     ETH->MACPMTCSR = tmpreg;
000026  9800              LDR      r0,[sp,#0]
000028  62c8              STR      r0,[r1,#0x2c]
;;;2528   }
00002a  bd08              POP      {r3,pc}
;;;2529   
                          ENDP

                  |L84.44|
                          DCD      0x40028000

                          AREA ||i.ETH_WritePHYRegister||, CODE, READONLY, ALIGN=2

                  ETH_WritePHYRegister PROC
;;;2319     */
;;;2320   uint32_t ETH_WritePHYRegister(uint16_t PHYAddress, uint16_t PHYReg, uint16_t PHYValue)
000000  b538              PUSH     {r3-r5,lr}
;;;2321   {
;;;2322     uint32_t tmpreg = 0;
;;;2323     __IO uint32_t timeout = 0;
000002  2300              MOVS     r3,#0
;;;2324     /* Check the parameters */
;;;2325     assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
;;;2326     assert_param(IS_ETH_PHY_REG(PHYReg));
;;;2327   
;;;2328     /* Get the ETHERNET MACMIIAR value */
;;;2329     tmpreg = ETH->MACMIIAR;
000004  9300              STR      r3,[sp,#0]
000006  4b11              LDR      r3,|L85.76|
000008  691c              LDR      r4,[r3,#0x10]
;;;2330     /* Keep only the CSR Clock Range CR[2:0] bits value */
;;;2331     tmpreg &= ~MACMIIAR_CR_MASK;
;;;2332     /* Prepare the MII register address value */
;;;2333     tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
00000a  f64f75ff          MOV      r5,#0xffff
00000e  f004041c          AND      r4,r4,#0x1c           ;2331
000012  ea0520c0          AND      r0,r5,r0,LSL #11
000016  4320              ORRS     r0,r0,r4
;;;2334     tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
000018  f44f64f8          MOV      r4,#0x7c0
00001c  ea041181          AND      r1,r4,r1,LSL #6
000020  4301              ORRS     r1,r1,r0
;;;2335     tmpreg |= ETH_MACMIIAR_MW;                               /* Set the write mode */
;;;2336     tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
000022  f0410003          ORR      r0,r1,#3
;;;2337     /* Give the value to the MII data register */
;;;2338     ETH->MACMIIDR = PHYValue;
000026  615a              STR      r2,[r3,#0x14]
;;;2339     /* Write the result value into the MII Address register */
;;;2340     ETH->MACMIIAR = tmpreg;
000028  6118              STR      r0,[r3,#0x10]
;;;2341     /* Check for the Busy flag */
;;;2342     do
;;;2343     {
;;;2344       timeout++;
;;;2345       tmpreg = ETH->MACMIIAR;
;;;2346     } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_WRITE_TO));
00002a  4909              LDR      r1,|L85.80|
                  |L85.44|
00002c  9800              LDR      r0,[sp,#0]            ;2344
00002e  1c40              ADDS     r0,r0,#1              ;2344
000030  9000              STR      r0,[sp,#0]            ;2345
000032  6918              LDR      r0,[r3,#0x10]         ;2345
000034  07c0              LSLS     r0,r0,#31
000036  d002              BEQ      |L85.62|
000038  9800              LDR      r0,[sp,#0]
00003a  4288              CMP      r0,r1
00003c  d3f6              BCC      |L85.44|
                  |L85.62|
;;;2347     /* Return ERROR in case of timeout */
;;;2348     if(timeout == PHY_WRITE_TO)
00003e  9800              LDR      r0,[sp,#0]
000040  4288              CMP      r0,r1
000042  d101              BNE      |L85.72|
;;;2349     {
;;;2350       return ETH_ERROR;
000044  2000              MOVS     r0,#0
;;;2351     }
;;;2352   
;;;2353     /* Return SUCCESS */
;;;2354     return ETH_SUCCESS;  
;;;2355   }
000046  bd38              POP      {r3-r5,pc}
                  |L85.72|
000048  2001              MOVS     r0,#1                 ;2354
00004a  bd38              POP      {r3-r5,pc}
;;;2356   
                          ENDP

                  |L85.76|
                          DCD      0x40028000
                  |L85.80|
                          DCD      0x0004ffff

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  DMARxDscrTab
                          %        512

                          AREA ||area_number.88||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.88||, ||.bss||
                  DMATxDscrTab
                          %        256

                          AREA ||area_number.89||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.89||, ||.bss||
                  Rx_Buff
                          %        24384

                          AREA ||area_number.90||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.90||, ||.bss||
                  Tx_Buff
                          %        12192

                          AREA ||area_number.91||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.91||, ||.bss||
                  RX_Frame_Descriptor
                          %        12

                          AREA ||.data||, DATA, ALIGN=2

                  DMATxDescToSet
                          DCD      0x00000000
                  DMARxDescToGet
                          DCD      0x00000000
                  DMA_RX_FRAME_infos
                          DCD      0x00000000

                          AREA ||area_number.94||, DATA, ALIGN=2

                          EXPORTAS ||area_number.94||, ||.data||
                  Frame_Rx_index
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\Lwip\\Bsp\\LAN8742A\\stm32f429_eth.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f429_eth_c_9c257664____REV16|
#line 138 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f429_eth_c_9c257664____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f429_eth_c_9c257664____REVSH|
#line 153
|__asm___15_stm32f429_eth_c_9c257664____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f429_eth_c_9c257664____RRX|
#line 328
|__asm___15_stm32f429_eth_c_9c257664____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

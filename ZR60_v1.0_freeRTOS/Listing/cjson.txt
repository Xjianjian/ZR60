; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\cjson.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\cjson.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\ZR60_v1.0_freeRTOS -I..\..\Lwip\App -I..\..\Lwip\Bsp -I..\..\Lwip\Bsp\LAN8742A -I..\..\Lwip\lwip-1.4.1 -I..\..\Lwip\lwip-1.4.1\port -I..\..\Lwip\lwip-1.4.1\port\arch -I..\..\Lwip\lwip-1.4.1\port\Standalone -I..\..\Lwip\lwip-1.4.1\src\include -I..\..\Lwip\lwip-1.4.1\src\include\ipv4 -I..\..\Lwip\lwip-1.4.1\src\include\lwip -I..\..\Lwip\lwip-1.4.1\src\include\netif -I..\..\Ecal\BtnFltr -I..\..\Ecal\UartComn -I..\..\Ecal\MemIf -I..\..\APP -I..\..\APP\BlackListMng -I..\..\APP\SeverNewsPush -I..\..\APP\NewsPull -I..\..\Ecal -I..\..\Ecal\JsonIf -I..\..\Ecal\Mcu_Init -I..\..\Service -I..\..\Complex -I..\..\Complex\FATFS -I..\..\FreeRTOS\Source\include -I..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\FreeRTOS -I.\RTE\_ZR60 -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=..\..\output\cjson.crf ..\..\Ecal\JsonIf\cJSON.c]
                          THUMB

                          AREA ||i.add_item_to_array||, CODE, READONLY, ALIGN=1

                  add_item_to_array PROC
;;;1843   
;;;1844   static cJSON_bool add_item_to_array(cJSON *array, cJSON *item)
000000  b119              CBZ      r1,|L1.10|
;;;1845   {
;;;1846       cJSON *child = NULL;
;;;1847   
;;;1848       if ((item == NULL) || (array == NULL))
000002  b110              CBZ      r0,|L1.10|
;;;1849       {
;;;1850           return false;
;;;1851       }
;;;1852   
;;;1853       child = array->child;
;;;1854   
;;;1855       if (child == NULL)
000004  6882              LDR      r2,[r0,#8]
000006  b112              CBZ      r2,|L1.14|
000008  e004              B        |L1.20|
                  |L1.10|
00000a  2000              MOVS     r0,#0                 ;1850
;;;1856       {
;;;1857           /* list is empty, start new one */
;;;1858           array->child = item;
;;;1859       }
;;;1860       else
;;;1861       {
;;;1862           /* append to the end */
;;;1863           while (child->next)
;;;1864           {
;;;1865               child = child->next;
;;;1866           }
;;;1867           suffix_object(child, item);
;;;1868       }
;;;1869   
;;;1870       return true;
;;;1871   }
00000c  4770              BX       lr
                  |L1.14|
00000e  6081              STR      r1,[r0,#8]            ;1858
000010  e005              B        |L1.30|
                  |L1.18|
000012  4602              MOV      r2,r0                 ;1865
                  |L1.20|
000014  6810              LDR      r0,[r2,#0]            ;1863
000016  2800              CMP      r0,#0                 ;1863
000018  d1fb              BNE      |L1.18|
00001a  6011              STR      r1,[r2,#0]            ;1863
00001c  604a              STR      r2,[r1,#4]            ;1863
                  |L1.30|
00001e  2001              MOVS     r0,#1                 ;1870
000020  4770              BX       lr
;;;1872   
                          ENDP


                          AREA ||i.add_item_to_object||, CODE, READONLY, ALIGN=1

                  add_item_to_object PROC
;;;1894   
;;;1895   static cJSON_bool add_item_to_object(cJSON * const object, const char * const string, cJSON * const item, const internal_hooks * const hooks, const cJSON_bool constant_key)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1896   {
000004  460d              MOV      r5,r1
000006  9906              LDR      r1,[sp,#0x18]
000008  461f              MOV      r7,r3
00000a  4614              MOV      r4,r2
00000c  ea5f0800          MOVS     r8,r0
000010  d006              BEQ      |L2.32|
;;;1897       char *new_key = NULL;
;;;1898       int new_type = cJSON_Invalid;
;;;1899   
;;;1900       if ((object == NULL) || (string == NULL) || (item == NULL))
000012  b12d              CBZ      r5,|L2.32|
000014  b124              CBZ      r4,|L2.32|
;;;1901       {
;;;1902           return false;
;;;1903       }
;;;1904   
;;;1905       if (constant_key)
000016  b131              CBZ      r1,|L2.38|
;;;1906       {
;;;1907           new_key = (char*)cast_away_const(string);
;;;1908           new_type = item->type | cJSON_StringIsConst;
000018  68e0              LDR      r0,[r4,#0xc]
00001a  f4407600          ORR      r6,r0,#0x200
00001e  e00b              B        |L2.56|
                  |L2.32|
000020  2000              MOVS     r0,#0                 ;1902
                  |L2.34|
;;;1909       }
;;;1910       else
;;;1911       {
;;;1912           new_key = (char*)cJSON_strdup((const unsigned char*)string, hooks);
;;;1913           if (new_key == NULL)
;;;1914           {
;;;1915               return false;
;;;1916           }
;;;1917   
;;;1918           new_type = item->type & ~cJSON_StringIsConst;
;;;1919       }
;;;1920   
;;;1921       if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
;;;1922       {
;;;1923           hooks->deallocate(item->string);
;;;1924       }
;;;1925   
;;;1926       item->string = new_key;
;;;1927       item->type = new_type;
;;;1928   
;;;1929       return add_item_to_array(object, item);
;;;1930   }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L2.38|
000026  4619              MOV      r1,r3                 ;1912
000028  4628              MOV      r0,r5                 ;1912
00002a  f7fffffe          BL       cJSON_strdup
00002e  1e05              SUBS     r5,r0,#0              ;1912
000030  d0f7              BEQ      |L2.34|
000032  68e0              LDR      r0,[r4,#0xc]          ;1918
000034  f4207600          BIC      r6,r0,#0x200          ;1918
                  |L2.56|
000038  89a0              LDRH     r0,[r4,#0xc]          ;1921
00003a  0580              LSLS     r0,r0,#22             ;1921
00003c  d403              BMI      |L2.70|
00003e  6a20              LDR      r0,[r4,#0x20]         ;1921
000040  b108              CBZ      r0,|L2.70|
000042  6879              LDR      r1,[r7,#4]            ;1923
000044  4788              BLX      r1                    ;1923
                  |L2.70|
000046  60e6              STR      r6,[r4,#0xc]          ;1929
000048  4621              MOV      r1,r4                 ;1929
00004a  4640              MOV      r0,r8                 ;1929
00004c  6225              STR      r5,[r4,#0x20]         ;1929
00004e  e8bd41f0          POP      {r4-r8,lr}            ;1929
000052  f7ffbffe          B.W      add_item_to_array
;;;1931   
                          ENDP


                          AREA ||i.buffer_skip_whitespace||, CODE, READONLY, ALIGN=1

                  buffer_skip_whitespace PROC
;;;962    /* Utility to jump whitespace and cr/lf */
;;;963    static parse_buffer *buffer_skip_whitespace(parse_buffer * const buffer)
000000  b510              PUSH     {r4,lr}
;;;964    {
000002  b188              CBZ      r0,|L3.40|
;;;965        if ((buffer == NULL) || (buffer->content == NULL))
000004  6803              LDR      r3,[r0,#0]
000006  b17b              CBZ      r3,|L3.40|
;;;966        {
;;;967            return NULL;
;;;968        }
;;;969    
;;;970        while (can_access_at_index(buffer, 0) && (buffer_at_offset(buffer)[0] <= 32))
000008  6842              LDR      r2,[r0,#4]
                  |L3.10|
00000a  6881              LDR      r1,[r0,#8]
00000c  4291              CMP      r1,r2
00000e  d206              BCS      |L3.30|
000010  5c5c              LDRB     r4,[r3,r1]
000012  2c20              CMP      r4,#0x20
000014  d803              BHI      |L3.30|
000016  1c49              ADDS     r1,r1,#1
;;;971        {
;;;972           buffer->offset++;
000018  6081              STR      r1,[r0,#8]
00001a  2800              CMP      r0,#0
00001c  d1f5              BNE      |L3.10|
                  |L3.30|
;;;973        }
;;;974    
;;;975        if (buffer->offset == buffer->length)
00001e  4291              CMP      r1,r2
000020  d101              BNE      |L3.38|
000022  1e49              SUBS     r1,r1,#1
;;;976        {
;;;977            buffer->offset--;
000024  6081              STR      r1,[r0,#8]
                  |L3.38|
;;;978        }
;;;979    
;;;980        return buffer;
;;;981    }
000026  bd10              POP      {r4,pc}
                  |L3.40|
000028  2000              MOVS     r0,#0                 ;967
00002a  bd10              POP      {r4,pc}
;;;982    
                          ENDP


                          AREA ||i.cJSON_AddArrayToObject||, CODE, READONLY, ALIGN=2

                  cJSON_AddArrayToObject PROC
;;;2058   
;;;2059   CJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2060   {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;2061       cJSON *array = cJSON_CreateArray();
000006  f7fffffe          BL       cJSON_CreateArray
00000a  4606              MOV      r6,r0
;;;2062       if (add_item_to_object(object, name, array, &global_hooks, false))
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
000010  4b06              LDR      r3,|L4.44|
000012  4632              MOV      r2,r6
000014  4621              MOV      r1,r4
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       add_item_to_object
00001c  2800              CMP      r0,#0
;;;2063       {
;;;2064           return array;
;;;2065       }
;;;2066   
;;;2067       cJSON_Delete(array);
00001e  4630              MOV      r0,r6
000020  d102              BNE      |L4.40|
000022  f7fffffe          BL       cJSON_Delete
;;;2068       return NULL;
000026  2000              MOVS     r0,#0
                  |L4.40|
;;;2069   }
000028  bdf8              POP      {r3-r7,pc}
;;;2070   
                          ENDP

00002a  0000              DCW      0x0000
                  |L4.44|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_AddBoolToObject||, CODE, READONLY, ALIGN=2

                  cJSON_AddBoolToObject PROC
;;;1998   
;;;1999   CJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2000   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;2001       cJSON *bool_item = cJSON_CreateBool(boolean);
000006  4610              MOV      r0,r2
000008  f7fffffe          BL       cJSON_CreateBool
00000c  4606              MOV      r6,r0
;;;2002       if (add_item_to_object(object, name, bool_item, &global_hooks, false))
00000e  2000              MOVS     r0,#0
000010  9000              STR      r0,[sp,#0]
000012  4b06              LDR      r3,|L5.44|
000014  4632              MOV      r2,r6
000016  4621              MOV      r1,r4
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       add_item_to_object
00001e  2800              CMP      r0,#0
;;;2003       {
;;;2004           return bool_item;
;;;2005       }
;;;2006   
;;;2007       cJSON_Delete(bool_item);
000020  4630              MOV      r0,r6
000022  d102              BNE      |L5.42|
000024  f7fffffe          BL       cJSON_Delete
;;;2008       return NULL;
000028  2000              MOVS     r0,#0
                  |L5.42|
;;;2009   }
00002a  bdf8              POP      {r3-r7,pc}
;;;2010   
                          ENDP

                  |L5.44|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_AddFalseToObject||, CODE, READONLY, ALIGN=2

                  cJSON_AddFalseToObject PROC
;;;1986   
;;;1987   CJSON_PUBLIC(cJSON*) cJSON_AddFalseToObject(cJSON * const object, const char * const name)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1988   {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;1989       cJSON *false_item = cJSON_CreateFalse();
000006  f7fffffe          BL       cJSON_CreateFalse
00000a  4606              MOV      r6,r0
;;;1990       if (add_item_to_object(object, name, false_item, &global_hooks, false))
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
000010  4b06              LDR      r3,|L6.44|
000012  4632              MOV      r2,r6
000014  4621              MOV      r1,r4
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       add_item_to_object
00001c  2800              CMP      r0,#0
;;;1991       {
;;;1992           return false_item;
;;;1993       }
;;;1994   
;;;1995       cJSON_Delete(false_item);
00001e  4630              MOV      r0,r6
000020  d102              BNE      |L6.40|
000022  f7fffffe          BL       cJSON_Delete
;;;1996       return NULL;
000026  2000              MOVS     r0,#0
                  |L6.40|
;;;1997   }
000028  bdf8              POP      {r3-r7,pc}
;;;1998   
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_AddItemReferenceToArray||, CODE, READONLY, ALIGN=2

                  cJSON_AddItemReferenceToArray PROC
;;;1942   
;;;1943   CJSON_PUBLIC(void) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)
000000  b510              PUSH     {r4,lr}
;;;1944   {
000002  460a              MOV      r2,r1
000004  0004              MOVS     r4,r0
000006  d009              BEQ      |L7.28|
;;;1945       if (array == NULL)
;;;1946       {
;;;1947           return;
;;;1948       }
;;;1949   
;;;1950       add_item_to_array(array, create_reference(item, &global_hooks));
000008  4905              LDR      r1,|L7.32|
00000a  4610              MOV      r0,r2
00000c  f7fffffe          BL       create_reference
000010  4601              MOV      r1,r0
000012  4620              MOV      r0,r4
000014  e8bd4010          POP      {r4,lr}
000018  f7ffbffe          B.W      add_item_to_array
                  |L7.28|
;;;1951   }
00001c  bd10              POP      {r4,pc}
;;;1952   
                          ENDP

00001e  0000              DCW      0x0000
                  |L7.32|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_AddItemReferenceToObject||, CODE, READONLY, ALIGN=2

                  cJSON_AddItemReferenceToObject PROC
;;;1952   
;;;1953   CJSON_PUBLIC(void) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)
000000  b538              PUSH     {r3-r5,lr}
;;;1954   {
000002  460c              MOV      r4,r1
000004  0005              MOVS     r5,r0
000006  d00d              BEQ      |L8.36|
;;;1955       if ((object == NULL) || (string == NULL))
000008  2c00              CMP      r4,#0
00000a  d00b              BEQ      |L8.36|
;;;1956       {
;;;1957           return;
;;;1958       }
;;;1959   
;;;1960       add_item_to_object(object, string, create_reference(item, &global_hooks), &global_hooks, false);
00000c  4906              LDR      r1,|L8.40|
00000e  4610              MOV      r0,r2
000010  f7fffffe          BL       create_reference
000014  4602              MOV      r2,r0
000016  2000              MOVS     r0,#0
000018  9000              STR      r0,[sp,#0]
00001a  4b03              LDR      r3,|L8.40|
00001c  4621              MOV      r1,r4
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       add_item_to_object
                  |L8.36|
;;;1961   }
000024  bd38              POP      {r3-r5,pc}
;;;1962   
                          ENDP

000026  0000              DCW      0x0000
                  |L8.40|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_AddItemToArray||, CODE, READONLY, ALIGN=1

                  cJSON_AddItemToArray PROC
;;;1873   /* Add item to array/object. */
;;;1874   CJSON_PUBLIC(void) cJSON_AddItemToArray(cJSON *array, cJSON *item)
000000  f7ffbffe          B.W      add_item_to_array
;;;1875   {
;;;1876       add_item_to_array(array, item);
;;;1877   }
;;;1878   
                          ENDP


                          AREA ||i.cJSON_AddItemToObject||, CODE, READONLY, ALIGN=2

                  cJSON_AddItemToObject PROC
;;;1931   
;;;1932   CJSON_PUBLIC(void) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item)
000000  b508              PUSH     {r3,lr}
;;;1933   {
;;;1934       add_item_to_object(object, string, item, &global_hooks, false);
000002  2300              MOVS     r3,#0
000004  9300              STR      r3,[sp,#0]
000006  4b02              LDR      r3,|L10.16|
000008  f7fffffe          BL       add_item_to_object
;;;1935   }
00000c  bd08              POP      {r3,pc}
;;;1936   
                          ENDP

00000e  0000              DCW      0x0000
                  |L10.16|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_AddItemToObjectCS||, CODE, READONLY, ALIGN=2

                  cJSON_AddItemToObjectCS PROC
;;;1937   /* Add an item to an object with constant string as key */
;;;1938   CJSON_PUBLIC(void) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item)
000000  b508              PUSH     {r3,lr}
;;;1939   {
;;;1940       add_item_to_object(object, string, item, &global_hooks, true);
000002  2301              MOVS     r3,#1
000004  9300              STR      r3,[sp,#0]
000006  4b02              LDR      r3,|L11.16|
000008  f7fffffe          BL       add_item_to_object
;;;1941   }
00000c  bd08              POP      {r3,pc}
;;;1942   
                          ENDP

00000e  0000              DCW      0x0000
                  |L11.16|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_AddNullToObject||, CODE, READONLY, ALIGN=2

                  cJSON_AddNullToObject PROC
;;;1962   
;;;1963   CJSON_PUBLIC(cJSON*) cJSON_AddNullToObject(cJSON * const object, const char * const name)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1964   {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;1965       cJSON *null = cJSON_CreateNull();
000006  f7fffffe          BL       cJSON_CreateNull
00000a  4606              MOV      r6,r0
;;;1966       if (add_item_to_object(object, name, null, &global_hooks, false))
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
000010  4b06              LDR      r3,|L12.44|
000012  4632              MOV      r2,r6
000014  4621              MOV      r1,r4
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       add_item_to_object
00001c  2800              CMP      r0,#0
;;;1967       {
;;;1968           return null;
;;;1969       }
;;;1970   
;;;1971       cJSON_Delete(null);
00001e  4630              MOV      r0,r6
000020  d102              BNE      |L12.40|
000022  f7fffffe          BL       cJSON_Delete
;;;1972       return NULL;
000026  2000              MOVS     r0,#0
                  |L12.40|
;;;1973   }
000028  bdf8              POP      {r3-r7,pc}
;;;1974   
                          ENDP

00002a  0000              DCW      0x0000
                  |L12.44|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_AddNumberToObject||, CODE, READONLY, ALIGN=2

                  cJSON_AddNumberToObject PROC
;;;2010   
;;;2011   CJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2012   {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;2013       cJSON *number_item = cJSON_CreateNumber(number);
000006  f7fffffe          BL       cJSON_CreateNumber
00000a  4606              MOV      r6,r0
;;;2014       if (add_item_to_object(object, name, number_item, &global_hooks, false))
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
000010  4b06              LDR      r3,|L13.44|
000012  4632              MOV      r2,r6
000014  4621              MOV      r1,r4
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       add_item_to_object
00001c  2800              CMP      r0,#0
;;;2015       {
;;;2016           return number_item;
;;;2017       }
;;;2018   
;;;2019       cJSON_Delete(number_item);
00001e  4630              MOV      r0,r6
000020  d102              BNE      |L13.40|
000022  f7fffffe          BL       cJSON_Delete
;;;2020       return NULL;
000026  2000              MOVS     r0,#0
                  |L13.40|
;;;2021   }
000028  bdf8              POP      {r3-r7,pc}
;;;2022   
                          ENDP

00002a  0000              DCW      0x0000
                  |L13.44|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_AddObjectToObject||, CODE, READONLY, ALIGN=2

                  cJSON_AddObjectToObject PROC
;;;2046   
;;;2047   CJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2048   {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;2049       cJSON *object_item = cJSON_CreateObject();
000006  f7fffffe          BL       cJSON_CreateObject
00000a  4606              MOV      r6,r0
;;;2050       if (add_item_to_object(object, name, object_item, &global_hooks, false))
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
000010  4b06              LDR      r3,|L14.44|
000012  4632              MOV      r2,r6
000014  4621              MOV      r1,r4
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       add_item_to_object
00001c  2800              CMP      r0,#0
;;;2051       {
;;;2052           return object_item;
;;;2053       }
;;;2054   
;;;2055       cJSON_Delete(object_item);
00001e  4630              MOV      r0,r6
000020  d102              BNE      |L14.40|
000022  f7fffffe          BL       cJSON_Delete
;;;2056       return NULL;
000026  2000              MOVS     r0,#0
                  |L14.40|
;;;2057   }
000028  bdf8              POP      {r3-r7,pc}
;;;2058   
                          ENDP

00002a  0000              DCW      0x0000
                  |L14.44|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_AddRawToObject||, CODE, READONLY, ALIGN=2

                  cJSON_AddRawToObject PROC
;;;2034   
;;;2035   CJSON_PUBLIC(cJSON*) cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2036   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;2037       cJSON *raw_item = cJSON_CreateRaw(raw);
000006  4610              MOV      r0,r2
000008  f7fffffe          BL       cJSON_CreateRaw
00000c  4606              MOV      r6,r0
;;;2038       if (add_item_to_object(object, name, raw_item, &global_hooks, false))
00000e  2000              MOVS     r0,#0
000010  9000              STR      r0,[sp,#0]
000012  4b06              LDR      r3,|L15.44|
000014  4632              MOV      r2,r6
000016  4621              MOV      r1,r4
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       add_item_to_object
00001e  2800              CMP      r0,#0
;;;2039       {
;;;2040           return raw_item;
;;;2041       }
;;;2042   
;;;2043       cJSON_Delete(raw_item);
000020  4630              MOV      r0,r6
000022  d102              BNE      |L15.42|
000024  f7fffffe          BL       cJSON_Delete
;;;2044       return NULL;
000028  2000              MOVS     r0,#0
                  |L15.42|
;;;2045   }
00002a  bdf8              POP      {r3-r7,pc}
;;;2046   
                          ENDP

                  |L15.44|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_AddStringToObject||, CODE, READONLY, ALIGN=2

                  cJSON_AddStringToObject PROC
;;;2022   
;;;2023   CJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2024   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;2025       cJSON *string_item = cJSON_CreateString(string);
000006  4610              MOV      r0,r2
000008  f7fffffe          BL       cJSON_CreateString
00000c  4606              MOV      r6,r0
;;;2026       if (add_item_to_object(object, name, string_item, &global_hooks, false))
00000e  2000              MOVS     r0,#0
000010  9000              STR      r0,[sp,#0]
000012  4b06              LDR      r3,|L16.44|
000014  4632              MOV      r2,r6
000016  4621              MOV      r1,r4
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       add_item_to_object
00001e  2800              CMP      r0,#0
;;;2027       {
;;;2028           return string_item;
;;;2029       }
;;;2030   
;;;2031       cJSON_Delete(string_item);
000020  4630              MOV      r0,r6
000022  d102              BNE      |L16.42|
000024  f7fffffe          BL       cJSON_Delete
;;;2032       return NULL;
000028  2000              MOVS     r0,#0
                  |L16.42|
;;;2033   }
00002a  bdf8              POP      {r3-r7,pc}
;;;2034   
                          ENDP

                  |L16.44|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_AddTrueToObject||, CODE, READONLY, ALIGN=2

                  cJSON_AddTrueToObject PROC
;;;1974   
;;;1975   CJSON_PUBLIC(cJSON*) cJSON_AddTrueToObject(cJSON * const object, const char * const name)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1976   {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;1977       cJSON *true_item = cJSON_CreateTrue();
000006  f7fffffe          BL       cJSON_CreateTrue
00000a  4606              MOV      r6,r0
;;;1978       if (add_item_to_object(object, name, true_item, &global_hooks, false))
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
000010  4b06              LDR      r3,|L17.44|
000012  4632              MOV      r2,r6
000014  4621              MOV      r1,r4
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       add_item_to_object
00001c  2800              CMP      r0,#0
;;;1979       {
;;;1980           return true_item;
;;;1981       }
;;;1982   
;;;1983       cJSON_Delete(true_item);
00001e  4630              MOV      r0,r6
000020  d102              BNE      |L17.40|
000022  f7fffffe          BL       cJSON_Delete
;;;1984       return NULL;
000026  2000              MOVS     r0,#0
                  |L17.40|
;;;1985   }
000028  bdf8              POP      {r3-r7,pc}
;;;1986   
                          ENDP

00002a  0000              DCW      0x0000
                  |L17.44|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_Compare||, CODE, READONLY, ALIGN=1

                  cJSON_Compare PROC
;;;2798   
;;;2799   CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2800   {
000004  4616              MOV      r6,r2
000006  460c              MOV      r4,r1
000008  0005              MOVS     r5,r0
00000a  d045              BEQ      |L18.152|
;;;2801       if ((a == NULL) || (b == NULL) || ((a->type & 0xFF) != (b->type & 0xFF)) || cJSON_IsInvalid(a))
00000c  2c00              CMP      r4,#0
00000e  d07e              BEQ      |L18.270|
000010  7b28              LDRB     r0,[r5,#0xc]
000012  7b21              LDRB     r1,[r4,#0xc]
000014  4288              CMP      r0,r1
000016  d17a              BNE      |L18.270|
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       cJSON_IsInvalid
00001e  2800              CMP      r0,#0
000020  d175              BNE      |L18.270|
;;;2802       {
;;;2803           return false;
;;;2804       }
;;;2805   
;;;2806       /* check if type is valid */
;;;2807       switch (a->type & 0xFF)
000022  7b28              LDRB     r0,[r5,#0xc]
000024  2810              CMP      r0,#0x10
000026  d00f              BEQ      |L18.72|
000028  dc08              BGT      |L18.60|
00002a  2801              CMP      r0,#1
00002c  d00c              BEQ      |L18.72|
00002e  2802              CMP      r0,#2
000030  d00a              BEQ      |L18.72|
000032  2804              CMP      r0,#4
000034  d008              BEQ      |L18.72|
000036  2808              CMP      r0,#8
000038  d169              BNE      |L18.270|
00003a  e005              B        |L18.72|
                  |L18.60|
00003c  2820              CMP      r0,#0x20
00003e  d003              BEQ      |L18.72|
000040  2840              CMP      r0,#0x40
000042  d001              BEQ      |L18.72|
000044  2880              CMP      r0,#0x80
000046  d162              BNE      |L18.270|
                  |L18.72|
;;;2808       {
;;;2809           case cJSON_False:
;;;2810           case cJSON_True:
;;;2811           case cJSON_NULL:
;;;2812           case cJSON_Number:
;;;2813           case cJSON_String:
;;;2814           case cJSON_Raw:
;;;2815           case cJSON_Array:
;;;2816           case cJSON_Object:
;;;2817               break;
;;;2818   
;;;2819           default:
;;;2820               return false;
;;;2821       }
;;;2822   
;;;2823       /* identical objects are equal */
;;;2824       if (a == b)
000048  42a5              CMP      r5,r4
00004a  d05d              BEQ      |L18.264|
;;;2825       {
;;;2826           return true;
;;;2827       }
;;;2828   
;;;2829       switch (a->type & 0xFF)
00004c  2810              CMP      r0,#0x10
00004e  d01c              BEQ      |L18.138|
000050  dc08              BGT      |L18.100|
000052  2801              CMP      r0,#1
000054  d058              BEQ      |L18.264|
000056  2802              CMP      r0,#2
000058  d056              BEQ      |L18.264|
00005a  2804              CMP      r0,#4
00005c  d054              BEQ      |L18.264|
00005e  2808              CMP      r0,#8
000060  d155              BNE      |L18.270|
000062  e006              B        |L18.114|
                  |L18.100|
000064  2820              CMP      r0,#0x20
000066  d018              BEQ      |L18.154|
000068  2840              CMP      r0,#0x40
00006a  d028              BEQ      |L18.190|
00006c  2880              CMP      r0,#0x80
00006e  d14e              BNE      |L18.270|
000070  e00b              B        |L18.138|
                  |L18.114|
;;;2830       {
;;;2831           /* in these cases and equal type is enough */
;;;2832           case cJSON_False:
;;;2833           case cJSON_True:
;;;2834           case cJSON_NULL:
;;;2835               return true;
;;;2836   
;;;2837           case cJSON_Number:
;;;2838               if (a->valuedouble == b->valuedouble)
000072  ed941b06          VLDR     d1,[r4,#0x18]
000076  ed950b06          VLDR     d0,[r5,#0x18]
00007a  ec532b11          VMOV     r2,r3,d1
00007e  ec510b10          VMOV     r0,r1,d0
000082  f7fffffe          BL       __aeabi_cdcmpeq
000086  d142              BNE      |L18.270|
000088  e03e              B        |L18.264|
                  |L18.138|
;;;2839               {
;;;2840                   return true;
;;;2841               }
;;;2842               return false;
;;;2843   
;;;2844           case cJSON_String:
;;;2845           case cJSON_Raw:
;;;2846               if ((a->valuestring == NULL) || (b->valuestring == NULL))
00008a  6928              LDR      r0,[r5,#0x10]
00008c  b120              CBZ      r0,|L18.152|
00008e  6921              LDR      r1,[r4,#0x10]
000090  b111              CBZ      r1,|L18.152|
;;;2847               {
;;;2848                   return false;
;;;2849               }
;;;2850               if (strcmp(a->valuestring, b->valuestring) == 0)
000092  f7fffffe          BL       strcmp
000096  b3b8              CBZ      r0,|L18.264|
                  |L18.152|
000098  e039              B        |L18.270|
                  |L18.154|
;;;2851               {
;;;2852                   return true;
;;;2853               }
;;;2854   
;;;2855               return false;
;;;2856   
;;;2857           case cJSON_Array:
;;;2858           {
;;;2859               cJSON *a_element = a->child;
00009a  68ad              LDR      r5,[r5,#8]
;;;2860               cJSON *b_element = b->child;
00009c  68a4              LDR      r4,[r4,#8]
;;;2861   
;;;2862               for (; (a_element != NULL) && (b_element != NULL);)
00009e  e008              B        |L18.178|
                  |L18.160|
;;;2863               {
;;;2864                   if (!cJSON_Compare(a_element, b_element, case_sensitive))
0000a0  4632              MOV      r2,r6
0000a2  4621              MOV      r1,r4
0000a4  4628              MOV      r0,r5
0000a6  f7fffffe          BL       cJSON_Compare
0000aa  2800              CMP      r0,#0
0000ac  d02d              BEQ      |L18.266|
;;;2865                   {
;;;2866                       return false;
;;;2867                   }
;;;2868   
;;;2869                   a_element = a_element->next;
0000ae  682d              LDR      r5,[r5,#0]
;;;2870                   b_element = b_element->next;
0000b0  6824              LDR      r4,[r4,#0]
                  |L18.178|
0000b2  b10d              CBZ      r5,|L18.184|
0000b4  2c00              CMP      r4,#0                 ;2862
0000b6  d1f3              BNE      |L18.160|
                  |L18.184|
;;;2871               }
;;;2872   
;;;2873               /* one of the arrays is longer than the other */
;;;2874               if (a_element != b_element) {
0000b8  42a5              CMP      r5,r4
0000ba  d128              BNE      |L18.270|
0000bc  e024              B        |L18.264|
                  |L18.190|
;;;2875                   return false;
;;;2876               }
;;;2877   
;;;2878               return true;
;;;2879           }
;;;2880   
;;;2881           case cJSON_Object:
;;;2882           {
;;;2883               cJSON *a_element = NULL;
;;;2884               cJSON *b_element = NULL;
;;;2885               cJSON_ArrayForEach(a_element, a)
0000be  68af              LDR      r7,[r5,#8]
0000c0  e00d              B        |L18.222|
                  |L18.194|
;;;2886               {
;;;2887                   /* TODO This has O(n^2) runtime, which is horrible! */
;;;2888                   b_element = get_object_item(b, a_element->string, case_sensitive);
0000c2  4632              MOV      r2,r6
0000c4  4620              MOV      r0,r4
0000c6  6a39              LDR      r1,[r7,#0x20]
0000c8  f7fffffe          BL       get_object_item
0000cc  0001              MOVS     r1,r0
;;;2889                   if (b_element == NULL)
0000ce  d01e              BEQ      |L18.270|
;;;2890                   {
;;;2891                       return false;
;;;2892                   }
;;;2893   
;;;2894                   if (!cJSON_Compare(a_element, b_element, case_sensitive))
0000d0  4632              MOV      r2,r6
0000d2  4638              MOV      r0,r7
0000d4  f7fffffe          BL       cJSON_Compare
0000d8  2800              CMP      r0,#0
0000da  d016              BEQ      |L18.266|
0000dc  683f              LDR      r7,[r7,#0]            ;2885
                  |L18.222|
0000de  2f00              CMP      r7,#0                 ;2885
0000e0  d1ef              BNE      |L18.194|
;;;2895                   {
;;;2896                       return false;
;;;2897                   }
;;;2898               }
;;;2899   
;;;2900               /* doing this twice, once on a and b to prevent true comparison if a subset of b
;;;2901                * TODO: Do this the proper way, this is just a fix for now */
;;;2902               cJSON_ArrayForEach(b_element, b)
0000e2  b17c              CBZ      r4,|L18.260|
0000e4  68a4              LDR      r4,[r4,#8]
0000e6  e00d              B        |L18.260|
                  |L18.232|
;;;2903               {
;;;2904                   a_element = get_object_item(a, b_element->string, case_sensitive);
0000e8  4632              MOV      r2,r6
0000ea  4628              MOV      r0,r5
0000ec  6a21              LDR      r1,[r4,#0x20]
0000ee  f7fffffe          BL       get_object_item
0000f2  0001              MOVS     r1,r0
;;;2905                   if (a_element == NULL)
0000f4  d00b              BEQ      |L18.270|
;;;2906                   {
;;;2907                       return false;
;;;2908                   }
;;;2909   
;;;2910                   if (!cJSON_Compare(b_element, a_element, case_sensitive))
0000f6  4632              MOV      r2,r6
0000f8  4620              MOV      r0,r4
0000fa  f7fffffe          BL       cJSON_Compare
0000fe  2800              CMP      r0,#0
000100  d003              BEQ      |L18.266|
000102  6824              LDR      r4,[r4,#0]            ;2902
                  |L18.260|
000104  2c00              CMP      r4,#0                 ;2902
000106  d1ef              BNE      |L18.232|
                  |L18.264|
;;;2911                   {
;;;2912                       return false;
;;;2913                   }
;;;2914               }
;;;2915   
;;;2916               return true;
000108  2001              MOVS     r0,#1
                  |L18.266|
;;;2917           }
;;;2918   
;;;2919           default:
;;;2920               return false;
;;;2921       }
;;;2922   }
00010a  e8bd81f0          POP      {r4-r8,pc}
                  |L18.270|
00010e  2000              MOVS     r0,#0                 ;2920
000110  e7fb              B        |L18.266|
;;;2923   
                          ENDP


                          AREA ||i.cJSON_CreateArray||, CODE, READONLY, ALIGN=2

                  cJSON_CreateArray PROC
;;;2382   
;;;2383   CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void)
000000  b510              PUSH     {r4,lr}
;;;2384   {
;;;2385       cJSON *item = cJSON_New_Item(&global_hooks);
000002  4804              LDR      r0,|L19.20|
000004  f7fffffe          BL       cJSON_New_Item
;;;2386       if(item)
000008  2800              CMP      r0,#0
00000a  d001              BEQ      |L19.16|
;;;2387       {
;;;2388           item->type=cJSON_Array;
00000c  2120              MOVS     r1,#0x20
00000e  60c1              STR      r1,[r0,#0xc]
                  |L19.16|
;;;2389       }
;;;2390   
;;;2391       return item;
;;;2392   }
000010  bd10              POP      {r4,pc}
;;;2393   
                          ENDP

000012  0000              DCW      0x0000
                  |L19.20|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_CreateArrayReference||, CODE, READONLY, ALIGN=2

                  cJSON_CreateArrayReference PROC
;;;2355   
;;;2356   CJSON_PUBLIC(cJSON *) cJSON_CreateArrayReference(const cJSON *child) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;2357       cJSON *item = cJSON_New_Item(&global_hooks);
000004  4804              LDR      r0,|L20.24|
000006  f7fffffe          BL       cJSON_New_Item
;;;2358       if (item != NULL) {
00000a  2800              CMP      r0,#0
00000c  d003              BEQ      |L20.22|
;;;2359           item->type = cJSON_Array | cJSON_IsReference;
00000e  f44f7190          MOV      r1,#0x120
000012  e9c04102          STRD     r4,r1,[r0,#8]
                  |L20.22|
;;;2360           item->child = (cJSON*)cast_away_const(child);
;;;2361       }
;;;2362   
;;;2363       return item;
;;;2364   }
000016  bd10              POP      {r4,pc}
;;;2365   
                          ENDP

                  |L20.24|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_CreateBool||, CODE, READONLY, ALIGN=2

                  cJSON_CreateBool PROC
;;;2278   
;;;2279   CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool b)
000000  b510              PUSH     {r4,lr}
;;;2280   {
000002  4604              MOV      r4,r0
;;;2281       cJSON *item = cJSON_New_Item(&global_hooks);
000004  4805              LDR      r0,|L21.28|
000006  f7fffffe          BL       cJSON_New_Item
;;;2282       if(item)
00000a  2800              CMP      r0,#0
00000c  d004              BEQ      |L21.24|
;;;2283       {
;;;2284           item->type = b ? cJSON_True : cJSON_False;
00000e  b10c              CBZ      r4,|L21.20|
000010  2102              MOVS     r1,#2
000012  e000              B        |L21.22|
                  |L21.20|
000014  2101              MOVS     r1,#1
                  |L21.22|
000016  60c1              STR      r1,[r0,#0xc]
                  |L21.24|
;;;2285       }
;;;2286   
;;;2287       return item;
;;;2288   }
000018  bd10              POP      {r4,pc}
;;;2289   
                          ENDP

00001a  0000              DCW      0x0000
                  |L21.28|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_CreateDoubleArray||, CODE, READONLY, ALIGN=1

                  cJSON_CreateDoubleArray PROC
;;;2476   
;;;2477   CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2478   {
;;;2479       size_t i = 0;
000004  f04f0400          MOV      r4,#0
000008  000f              MOVS     r7,r1                 ;2478
00000a  4680              MOV      r8,r0                 ;2478
;;;2480       cJSON *n = NULL;
;;;2481       cJSON *p = NULL;
00000c  4625              MOV      r5,r4
00000e  d406              BMI      |L22.30|
;;;2482       cJSON *a = NULL;
;;;2483   
;;;2484       if ((count < 0) || (numbers == NULL))
000010  f1b80f00          CMP      r8,#0
000014  d003              BEQ      |L22.30|
;;;2485       {
;;;2486           return NULL;
;;;2487       }
;;;2488   
;;;2489       a = cJSON_CreateArray();
000016  f7fffffe          BL       cJSON_CreateArray
00001a  4606              MOV      r6,r0
;;;2490   
;;;2491       for(i = 0;a && (i < (size_t)count); i++)
00001c  e00e              B        |L22.60|
                  |L22.30|
00001e  2000              MOVS     r0,#0                 ;2486
                  |L22.32|
;;;2492       {
;;;2493           n = cJSON_CreateNumber(numbers[i]);
;;;2494           if(!n)
;;;2495           {
;;;2496               cJSON_Delete(a);
;;;2497               return NULL;
;;;2498           }
;;;2499           if(!i)
;;;2500           {
;;;2501               a->child = n;
;;;2502           }
;;;2503           else
;;;2504           {
;;;2505               suffix_object(p, n);
;;;2506           }
;;;2507           p = n;
;;;2508       }
;;;2509   
;;;2510       return a;
;;;2511   }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L22.36|
000024  eb0800c4          ADD      r0,r8,r4,LSL #3       ;2493
000028  ed900b00          VLDR     d0,[r0,#0]            ;2493
00002c  f7fffffe          BL       cJSON_CreateNumber
000030  b148              CBZ      r0,|L22.70|
000032  b164              CBZ      r4,|L22.78|
000034  6028              STR      r0,[r5,#0]            ;2499
000036  6045              STR      r5,[r0,#4]            ;2499
                  |L22.56|
000038  4605              MOV      r5,r0                 ;2507
00003a  1c64              ADDS     r4,r4,#1              ;2507
                  |L22.60|
00003c  b10e              CBZ      r6,|L22.66|
00003e  42bc              CMP      r4,r7                 ;2491
000040  d3f0              BCC      |L22.36|
                  |L22.66|
000042  4630              MOV      r0,r6                 ;2510
000044  e7ec              B        |L22.32|
                  |L22.70|
000046  4630              MOV      r0,r6                 ;2496
000048  f7fffffe          BL       cJSON_Delete
00004c  e7e7              B        |L22.30|
                  |L22.78|
00004e  60b0              STR      r0,[r6,#8]            ;2501
000050  e7f2              B        |L22.56|
;;;2512   
                          ENDP


                          AREA ||i.cJSON_CreateFalse||, CODE, READONLY, ALIGN=2

                  cJSON_CreateFalse PROC
;;;2267   
;;;2268   CJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void)
000000  b510              PUSH     {r4,lr}
;;;2269   {
;;;2270       cJSON *item = cJSON_New_Item(&global_hooks);
000002  4804              LDR      r0,|L23.20|
000004  f7fffffe          BL       cJSON_New_Item
;;;2271       if(item)
000008  2800              CMP      r0,#0
00000a  d001              BEQ      |L23.16|
;;;2272       {
;;;2273           item->type = cJSON_False;
00000c  2101              MOVS     r1,#1
00000e  60c1              STR      r1,[r0,#0xc]
                  |L23.16|
;;;2274       }
;;;2275   
;;;2276       return item;
;;;2277   }
000010  bd10              POP      {r4,pc}
;;;2278   
                          ENDP

000012  0000              DCW      0x0000
                  |L23.20|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_CreateFloatArray||, CODE, READONLY, ALIGN=1

                  cJSON_CreateFloatArray PROC
;;;2440   
;;;2441   CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2442   {
;;;2443       size_t i = 0;
000004  f04f0400          MOV      r4,#0
000008  000f              MOVS     r7,r1                 ;2442
00000a  4680              MOV      r8,r0                 ;2442
;;;2444       cJSON *n = NULL;
;;;2445       cJSON *p = NULL;
00000c  4625              MOV      r5,r4
00000e  d406              BMI      |L24.30|
;;;2446       cJSON *a = NULL;
;;;2447   
;;;2448       if ((count < 0) || (numbers == NULL))
000010  f1b80f00          CMP      r8,#0
000014  d003              BEQ      |L24.30|
;;;2449       {
;;;2450           return NULL;
;;;2451       }
;;;2452   
;;;2453       a = cJSON_CreateArray();
000016  f7fffffe          BL       cJSON_CreateArray
00001a  4606              MOV      r6,r0
;;;2454   
;;;2455       for(i = 0; a && (i < (size_t)count); i++)
00001c  e010              B        |L24.64|
                  |L24.30|
00001e  2000              MOVS     r0,#0                 ;2450
                  |L24.32|
;;;2456       {
;;;2457           n = cJSON_CreateNumber((double)numbers[i]);
;;;2458           if(!n)
;;;2459           {
;;;2460               cJSON_Delete(a);
;;;2461               return NULL;
;;;2462           }
;;;2463           if(!i)
;;;2464           {
;;;2465               a->child = n;
;;;2466           }
;;;2467           else
;;;2468           {
;;;2469               suffix_object(p, n);
;;;2470           }
;;;2471           p = n;
;;;2472       }
;;;2473   
;;;2474       return a;
;;;2475   }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L24.36|
000024  f8580024          LDR      r0,[r8,r4,LSL #2]     ;2457
000028  f7fffffe          BL       __aeabi_f2d
00002c  ec410b10          VMOV     d0,r0,r1              ;2457
000030  f7fffffe          BL       cJSON_CreateNumber
000034  b148              CBZ      r0,|L24.74|
000036  b164              CBZ      r4,|L24.82|
000038  6028              STR      r0,[r5,#0]            ;2463
00003a  6045              STR      r5,[r0,#4]            ;2463
                  |L24.60|
00003c  4605              MOV      r5,r0                 ;2471
00003e  1c64              ADDS     r4,r4,#1              ;2471
                  |L24.64|
000040  b10e              CBZ      r6,|L24.70|
000042  42bc              CMP      r4,r7                 ;2455
000044  d3ee              BCC      |L24.36|
                  |L24.70|
000046  4630              MOV      r0,r6                 ;2474
000048  e7ea              B        |L24.32|
                  |L24.74|
00004a  4630              MOV      r0,r6                 ;2460
00004c  f7fffffe          BL       cJSON_Delete
000050  e7e5              B        |L24.30|
                  |L24.82|
000052  60b0              STR      r0,[r6,#8]            ;2465
000054  e7f2              B        |L24.60|
;;;2476   
                          ENDP


                          AREA ||i.cJSON_CreateIntArray||, CODE, READONLY, ALIGN=1

                  cJSON_CreateIntArray PROC
;;;2405   /* Create Arrays: */
;;;2406   CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2407   {
;;;2408       size_t i = 0;
000004  f04f0400          MOV      r4,#0
000008  000f              MOVS     r7,r1                 ;2407
00000a  4680              MOV      r8,r0                 ;2407
;;;2409       cJSON *n = NULL;
;;;2410       cJSON *p = NULL;
00000c  4625              MOV      r5,r4
00000e  d406              BMI      |L25.30|
;;;2411       cJSON *a = NULL;
;;;2412   
;;;2413       if ((count < 0) || (numbers == NULL))
000010  f1b80f00          CMP      r8,#0
000014  d003              BEQ      |L25.30|
;;;2414       {
;;;2415           return NULL;
;;;2416       }
;;;2417   
;;;2418       a = cJSON_CreateArray();
000016  f7fffffe          BL       cJSON_CreateArray
00001a  4606              MOV      r6,r0
;;;2419       for(i = 0; a && (i < (size_t)count); i++)
00001c  e010              B        |L25.64|
                  |L25.30|
00001e  2000              MOVS     r0,#0                 ;2415
                  |L25.32|
;;;2420       {
;;;2421           n = cJSON_CreateNumber(numbers[i]);
;;;2422           if (!n)
;;;2423           {
;;;2424               cJSON_Delete(a);
;;;2425               return NULL;
;;;2426           }
;;;2427           if(!i)
;;;2428           {
;;;2429               a->child = n;
;;;2430           }
;;;2431           else
;;;2432           {
;;;2433               suffix_object(p, n);
;;;2434           }
;;;2435           p = n;
;;;2436       }
;;;2437   
;;;2438       return a;
;;;2439   }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L25.36|
000024  f8580024          LDR      r0,[r8,r4,LSL #2]     ;2421
000028  f7fffffe          BL       __aeabi_i2d
00002c  ec410b10          VMOV     d0,r0,r1              ;2421
000030  f7fffffe          BL       cJSON_CreateNumber
000034  b148              CBZ      r0,|L25.74|
000036  b164              CBZ      r4,|L25.82|
000038  6028              STR      r0,[r5,#0]            ;2427
00003a  6045              STR      r5,[r0,#4]            ;2427
                  |L25.60|
00003c  4605              MOV      r5,r0                 ;2435
00003e  1c64              ADDS     r4,r4,#1              ;2435
                  |L25.64|
000040  b10e              CBZ      r6,|L25.70|
000042  42bc              CMP      r4,r7                 ;2419
000044  d3ee              BCC      |L25.36|
                  |L25.70|
000046  4630              MOV      r0,r6                 ;2438
000048  e7ea              B        |L25.32|
                  |L25.74|
00004a  4630              MOV      r0,r6                 ;2424
00004c  f7fffffe          BL       cJSON_Delete
000050  e7e5              B        |L25.30|
                  |L25.82|
000052  60b0              STR      r0,[r6,#8]            ;2429
000054  e7f2              B        |L25.60|
;;;2440   
                          ENDP


                          AREA ||i.cJSON_CreateNull||, CODE, READONLY, ALIGN=2

                  cJSON_CreateNull PROC
;;;2245   /* Create basic types: */
;;;2246   CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void)
000000  b510              PUSH     {r4,lr}
;;;2247   {
;;;2248       cJSON *item = cJSON_New_Item(&global_hooks);
000002  4804              LDR      r0,|L26.20|
000004  f7fffffe          BL       cJSON_New_Item
;;;2249       if(item)
000008  2800              CMP      r0,#0
00000a  d001              BEQ      |L26.16|
;;;2250       {
;;;2251           item->type = cJSON_NULL;
00000c  2104              MOVS     r1,#4
00000e  60c1              STR      r1,[r0,#0xc]
                  |L26.16|
;;;2252       }
;;;2253   
;;;2254       return item;
;;;2255   }
000010  bd10              POP      {r4,pc}
;;;2256   
                          ENDP

000012  0000              DCW      0x0000
                  |L26.20|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_CreateNumber||, CODE, READONLY, ALIGN=2

                  cJSON_CreateNumber PROC
;;;2289   
;;;2290   CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num)
000000  b510              PUSH     {r4,lr}
;;;2291   {
;;;2292       cJSON *item = cJSON_New_Item(&global_hooks);
000002  4818              LDR      r0,|L27.100|
000004  ed2d8b02          VPUSH    {d8}                  ;2291
000008  eeb08a40          VMOV.F32 s16,s0                ;2291
00000c  eef08a60          VMOV.F32 s17,s1                ;2291
000010  f7fffffe          BL       cJSON_New_Item
000014  0004              MOVS     r4,r0
;;;2293       if(item)
000016  d020              BEQ      |L27.90|
;;;2294       {
;;;2295           item->type = cJSON_Number;
000018  2008              MOVS     r0,#8
;;;2296           item->valuedouble = num;
00001a  60e0              STR      r0,[r4,#0xc]
;;;2297   
;;;2298           /* use saturation in case of overflow */
;;;2299           if (num >= INT_MAX)
00001c  ed9f0b12          VLDR     d0,|L27.104|
000020  ed848b06          VSTR     d8,[r4,#0x18]         ;2296
000024  ec532b10          VMOV     r2,r3,d0
000028  ec510b18          VMOV     r0,r1,d8
00002c  f7fffffe          BL       __aeabi_cdrcmple
000030  d802              BHI      |L27.56|
;;;2300           {
;;;2301               item->valueint = INT_MAX;
000032  f06f4000          MVN      r0,#0x80000000
000036  e00f              B        |L27.88|
                  |L27.56|
;;;2302           }
;;;2303           else if (num <= INT_MIN)
000038  ed9f0b0d          VLDR     d0,|L27.112|
00003c  ec510b18          VMOV     r0,r1,d8
000040  ec532b10          VMOV     r2,r3,d0
000044  f7fffffe          BL       __aeabi_cdcmple
000048  d802              BHI      |L27.80|
;;;2304           {
;;;2305               item->valueint = INT_MIN;
00004a  f04f4000          MOV      r0,#0x80000000
00004e  e003              B        |L27.88|
                  |L27.80|
;;;2306           }
;;;2307           else
;;;2308           {
;;;2309               item->valueint = (int)num;
000050  ec510b18          VMOV     r0,r1,d8
000054  f7fffffe          BL       __aeabi_d2iz
                  |L27.88|
000058  6160              STR      r0,[r4,#0x14]         ;2305
                  |L27.90|
;;;2310           }
;;;2311       }
;;;2312   
;;;2313       return item;
00005a  4620              MOV      r0,r4
;;;2314   }
00005c  ecbd8b02          VPOP     {d8}
000060  bd10              POP      {r4,pc}
;;;2315   
                          ENDP

000062  0000              DCW      0x0000
                  |L27.100|
                          DCD      ||.data||+0x8
                  |L27.104|
000068  ffc00000          DCFD     0x41dfffffffc00000 ; 2147483647
00006c  41dfffff
                  |L27.112|
000070  00000000          DCFD     0xc1e0000000000000 ; -2147483648
000074  c1e00000

                          AREA ||i.cJSON_CreateObject||, CODE, READONLY, ALIGN=2

                  cJSON_CreateObject PROC
;;;2393   
;;;2394   CJSON_PUBLIC(cJSON *) cJSON_CreateObject(void)
000000  b510              PUSH     {r4,lr}
;;;2395   {
;;;2396       cJSON *item = cJSON_New_Item(&global_hooks);
000002  4804              LDR      r0,|L28.20|
000004  f7fffffe          BL       cJSON_New_Item
;;;2397       if (item)
000008  2800              CMP      r0,#0
00000a  d001              BEQ      |L28.16|
;;;2398       {
;;;2399           item->type = cJSON_Object;
00000c  2140              MOVS     r1,#0x40
00000e  60c1              STR      r1,[r0,#0xc]
                  |L28.16|
;;;2400       }
;;;2401   
;;;2402       return item;
;;;2403   }
000010  bd10              POP      {r4,pc}
;;;2404   
                          ENDP

000012  0000              DCW      0x0000
                  |L28.20|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_CreateObjectReference||, CODE, READONLY, ALIGN=2

                  cJSON_CreateObjectReference PROC
;;;2344   
;;;2345   CJSON_PUBLIC(cJSON *) cJSON_CreateObjectReference(const cJSON *child)
000000  b510              PUSH     {r4,lr}
;;;2346   {
000002  4604              MOV      r4,r0
;;;2347       cJSON *item = cJSON_New_Item(&global_hooks);
000004  4804              LDR      r0,|L29.24|
000006  f7fffffe          BL       cJSON_New_Item
;;;2348       if (item != NULL) {
00000a  2800              CMP      r0,#0
00000c  d003              BEQ      |L29.22|
;;;2349           item->type = cJSON_Object | cJSON_IsReference;
00000e  f44f71a0          MOV      r1,#0x140
000012  e9c04102          STRD     r4,r1,[r0,#8]
                  |L29.22|
;;;2350           item->child = (cJSON*)cast_away_const(child);
;;;2351       }
;;;2352   
;;;2353       return item;
;;;2354   }
000016  bd10              POP      {r4,pc}
;;;2355   
                          ENDP

                  |L29.24|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_CreateRaw||, CODE, READONLY, ALIGN=2

                  cJSON_CreateRaw PROC
;;;2365   
;;;2366   CJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char *raw)
000000  b570              PUSH     {r4-r6,lr}
;;;2367   {
000002  4605              MOV      r5,r0
;;;2368       cJSON *item = cJSON_New_Item(&global_hooks);
000004  4809              LDR      r0,|L30.44|
000006  f7fffffe          BL       cJSON_New_Item
00000a  0004              MOVS     r4,r0
;;;2369       if(item)
00000c  d007              BEQ      |L30.30|
;;;2370       {
;;;2371           item->type = cJSON_Raw;
00000e  2080              MOVS     r0,#0x80
;;;2372           item->valuestring = (char*)cJSON_strdup((const unsigned char*)raw, &global_hooks);
000010  60e0              STR      r0,[r4,#0xc]
000012  4906              LDR      r1,|L30.44|
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       cJSON_strdup
;;;2373           if(!item->valuestring)
00001a  6120              STR      r0,[r4,#0x10]
00001c  b108              CBZ      r0,|L30.34|
                  |L30.30|
;;;2374           {
;;;2375               cJSON_Delete(item);
;;;2376               return NULL;
;;;2377           }
;;;2378       }
;;;2379   
;;;2380       return item;
00001e  4620              MOV      r0,r4
;;;2381   }
000020  bd70              POP      {r4-r6,pc}
                  |L30.34|
000022  4620              MOV      r0,r4                 ;2375
000024  f7fffffe          BL       cJSON_Delete
000028  2000              MOVS     r0,#0                 ;2376
00002a  bd70              POP      {r4-r6,pc}
;;;2382   
                          ENDP

                  |L30.44|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_CreateString||, CODE, READONLY, ALIGN=2

                  cJSON_CreateString PROC
;;;2315   
;;;2316   CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string)
000000  b570              PUSH     {r4-r6,lr}
;;;2317   {
000002  4605              MOV      r5,r0
;;;2318       cJSON *item = cJSON_New_Item(&global_hooks);
000004  4809              LDR      r0,|L31.44|
000006  f7fffffe          BL       cJSON_New_Item
00000a  0004              MOVS     r4,r0
;;;2319       if(item)
00000c  d007              BEQ      |L31.30|
;;;2320       {
;;;2321           item->type = cJSON_String;
00000e  2010              MOVS     r0,#0x10
;;;2322           item->valuestring = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
000010  60e0              STR      r0,[r4,#0xc]
000012  4906              LDR      r1,|L31.44|
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       cJSON_strdup
;;;2323           if(!item->valuestring)
00001a  6120              STR      r0,[r4,#0x10]
00001c  b108              CBZ      r0,|L31.34|
                  |L31.30|
;;;2324           {
;;;2325               cJSON_Delete(item);
;;;2326               return NULL;
;;;2327           }
;;;2328       }
;;;2329   
;;;2330       return item;
00001e  4620              MOV      r0,r4
;;;2331   }
000020  bd70              POP      {r4-r6,pc}
                  |L31.34|
000022  4620              MOV      r0,r4                 ;2325
000024  f7fffffe          BL       cJSON_Delete
000028  2000              MOVS     r0,#0                 ;2326
00002a  bd70              POP      {r4-r6,pc}
;;;2332   
                          ENDP

                  |L31.44|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_CreateStringArray||, CODE, READONLY, ALIGN=1

                  cJSON_CreateStringArray PROC
;;;2512   
;;;2513   CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char **strings, int count)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2514   {
;;;2515       size_t i = 0;
000004  f04f0400          MOV      r4,#0
000008  000f              MOVS     r7,r1                 ;2514
00000a  4680              MOV      r8,r0                 ;2514
;;;2516       cJSON *n = NULL;
;;;2517       cJSON *p = NULL;
00000c  4625              MOV      r5,r4
00000e  d406              BMI      |L32.30|
;;;2518       cJSON *a = NULL;
;;;2519   
;;;2520       if ((count < 0) || (strings == NULL))
000010  f1b80f00          CMP      r8,#0
000014  d003              BEQ      |L32.30|
;;;2521       {
;;;2522           return NULL;
;;;2523       }
;;;2524   
;;;2525       a = cJSON_CreateArray();
000016  f7fffffe          BL       cJSON_CreateArray
00001a  4606              MOV      r6,r0
;;;2526   
;;;2527       for (i = 0; a && (i < (size_t)count); i++)
00001c  e00c              B        |L32.56|
                  |L32.30|
00001e  2000              MOVS     r0,#0                 ;2522
                  |L32.32|
;;;2528       {
;;;2529           n = cJSON_CreateString(strings[i]);
;;;2530           if(!n)
;;;2531           {
;;;2532               cJSON_Delete(a);
;;;2533               return NULL;
;;;2534           }
;;;2535           if(!i)
;;;2536           {
;;;2537               a->child = n;
;;;2538           }
;;;2539           else
;;;2540           {
;;;2541               suffix_object(p,n);
;;;2542           }
;;;2543           p = n;
;;;2544       }
;;;2545   
;;;2546       return a;
;;;2547   }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L32.36|
000024  f8580024          LDR      r0,[r8,r4,LSL #2]     ;2529
000028  f7fffffe          BL       cJSON_CreateString
00002c  b148              CBZ      r0,|L32.66|
00002e  b164              CBZ      r4,|L32.74|
000030  6028              STR      r0,[r5,#0]            ;2535
000032  6045              STR      r5,[r0,#4]            ;2535
                  |L32.52|
000034  4605              MOV      r5,r0                 ;2543
000036  1c64              ADDS     r4,r4,#1              ;2543
                  |L32.56|
000038  b10e              CBZ      r6,|L32.62|
00003a  42bc              CMP      r4,r7                 ;2527
00003c  d3f2              BCC      |L32.36|
                  |L32.62|
00003e  4630              MOV      r0,r6                 ;2546
000040  e7ee              B        |L32.32|
                  |L32.66|
000042  4630              MOV      r0,r6                 ;2532
000044  f7fffffe          BL       cJSON_Delete
000048  e7e9              B        |L32.30|
                  |L32.74|
00004a  60b0              STR      r0,[r6,#8]            ;2537
00004c  e7f2              B        |L32.52|
;;;2548   
                          ENDP


                          AREA ||i.cJSON_CreateStringReference||, CODE, READONLY, ALIGN=2

                  cJSON_CreateStringReference PROC
;;;2332   
;;;2333   CJSON_PUBLIC(cJSON *) cJSON_CreateStringReference(const char *string)
000000  b510              PUSH     {r4,lr}
;;;2334   {
000002  4604              MOV      r4,r0
;;;2335       cJSON *item = cJSON_New_Item(&global_hooks);
000004  4804              LDR      r0,|L33.24|
000006  f7fffffe          BL       cJSON_New_Item
;;;2336       if (item != NULL)
00000a  2800              CMP      r0,#0
00000c  d003              BEQ      |L33.22|
;;;2337       {
;;;2338           item->type = cJSON_String | cJSON_IsReference;
00000e  f44f7188          MOV      r1,#0x110
000012  e9c01403          STRD     r1,r4,[r0,#0xc]
                  |L33.22|
;;;2339           item->valuestring = (char*)cast_away_const(string);
;;;2340       }
;;;2341   
;;;2342       return item;
;;;2343   }
000016  bd10              POP      {r4,pc}
;;;2344   
                          ENDP

                  |L33.24|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_CreateTrue||, CODE, READONLY, ALIGN=2

                  cJSON_CreateTrue PROC
;;;2256   
;;;2257   CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void)
000000  b510              PUSH     {r4,lr}
;;;2258   {
;;;2259       cJSON *item = cJSON_New_Item(&global_hooks);
000002  4804              LDR      r0,|L34.20|
000004  f7fffffe          BL       cJSON_New_Item
;;;2260       if(item)
000008  2800              CMP      r0,#0
00000a  d001              BEQ      |L34.16|
;;;2261       {
;;;2262           item->type = cJSON_True;
00000c  2102              MOVS     r1,#2
00000e  60c1              STR      r1,[r0,#0xc]
                  |L34.16|
;;;2263       }
;;;2264   
;;;2265       return item;
;;;2266   }
000010  bd10              POP      {r4,pc}
;;;2267   
                          ENDP

000012  0000              DCW      0x0000
                  |L34.20|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_Delete||, CODE, READONLY, ALIGN=2

                  cJSON_Delete PROC
;;;213    /* Delete a cJSON structure. */
;;;214    CJSON_PUBLIC(void) cJSON_Delete(cJSON *item)
000000  b570              PUSH     {r4-r6,lr}
;;;215    {
000002  4604              MOV      r4,r0
;;;216        cJSON *next = NULL;
;;;217        while (item != NULL)
;;;218        {
;;;219            next = item->next;
;;;220            if (!(item->type & cJSON_IsReference) && (item->child != NULL))
;;;221            {
;;;222                cJSON_Delete(item->child);
;;;223            }
;;;224            if (!(item->type & cJSON_IsReference) && (item->valuestring != NULL))
;;;225            {
;;;226                global_hooks.deallocate(item->valuestring);
000004  4e0f              LDR      r6,|L35.68|
000006  e019              B        |L35.60|
                  |L35.8|
000008  89a0              LDRH     r0,[r4,#0xc]          ;220
00000a  6825              LDR      r5,[r4,#0]            ;220
00000c  05c0              LSLS     r0,r0,#23             ;220
00000e  d40a              BMI      |L35.38|
000010  68a0              LDR      r0,[r4,#8]            ;220
000012  b120              CBZ      r0,|L35.30|
000014  f7fffffe          BL       cJSON_Delete
000018  89a0              LDRH     r0,[r4,#0xc]          ;224
00001a  05c0              LSLS     r0,r0,#23             ;224
00001c  d403              BMI      |L35.38|
                  |L35.30|
00001e  6920              LDR      r0,[r4,#0x10]         ;224
000020  b108              CBZ      r0,|L35.38|
000022  6871              LDR      r1,[r6,#4]  ; global_hooks
000024  4788              BLX      r1
                  |L35.38|
;;;227            }
;;;228            if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
000026  89a0              LDRH     r0,[r4,#0xc]
000028  0580              LSLS     r0,r0,#22
00002a  d403              BMI      |L35.52|
00002c  6a20              LDR      r0,[r4,#0x20]
00002e  b108              CBZ      r0,|L35.52|
;;;229            {
;;;230                global_hooks.deallocate(item->string);
000030  6871              LDR      r1,[r6,#4]  ; global_hooks
000032  4788              BLX      r1
                  |L35.52|
;;;231            }
;;;232            global_hooks.deallocate(item);
000034  6871              LDR      r1,[r6,#4]  ; global_hooks
000036  4620              MOV      r0,r4
000038  4788              BLX      r1
;;;233            item = next;
00003a  462c              MOV      r4,r5
                  |L35.60|
00003c  2c00              CMP      r4,#0                 ;217
00003e  d1e3              BNE      |L35.8|
;;;234        }
;;;235    }
000040  bd70              POP      {r4-r6,pc}
;;;236    
                          ENDP

000042  0000              DCW      0x0000
                  |L35.68|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_DeleteItemFromArray||, CODE, READONLY, ALIGN=1

                  cJSON_DeleteItemFromArray PROC
;;;2110   
;;;2111   CJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which)
000000  b510              PUSH     {r4,lr}
;;;2112   {
;;;2113       cJSON_Delete(cJSON_DetachItemFromArray(array, which));
000002  f7fffffe          BL       cJSON_DetachItemFromArray
000006  e8bd4010          POP      {r4,lr}
00000a  f7ffbffe          B.W      cJSON_Delete
;;;2114   }
;;;2115   
                          ENDP


                          AREA ||i.cJSON_DeleteItemFromObject||, CODE, READONLY, ALIGN=1

                  cJSON_DeleteItemFromObject PROC
;;;2129   
;;;2130   CJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string)
000000  b510              PUSH     {r4,lr}
;;;2131   {
;;;2132       cJSON_Delete(cJSON_DetachItemFromObject(object, string));
000002  f7fffffe          BL       cJSON_DetachItemFromObject
000006  e8bd4010          POP      {r4,lr}
00000a  f7ffbffe          B.W      cJSON_Delete
;;;2133   }
;;;2134   
                          ENDP


                          AREA ||i.cJSON_DeleteItemFromObjectCaseSensitive||, CODE, READONLY, ALIGN=1

                  cJSON_DeleteItemFromObjectCaseSensitive PROC
;;;2134   
;;;2135   CJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string)
000000  b510              PUSH     {r4,lr}
;;;2136   {
;;;2137       cJSON_Delete(cJSON_DetachItemFromObjectCaseSensitive(object, string));
000002  f7fffffe          BL       cJSON_DetachItemFromObjectCaseSensitive
000006  e8bd4010          POP      {r4,lr}
00000a  f7ffbffe          B.W      cJSON_Delete
;;;2138   }
;;;2139   
                          ENDP


                          AREA ||i.cJSON_DetachItemFromArray||, CODE, READONLY, ALIGN=1

                  cJSON_DetachItemFromArray PROC
;;;2100   
;;;2101   CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which)
000000  b510              PUSH     {r4,lr}
;;;2102   {
000002  4604              MOV      r4,r0
;;;2103       if (which < 0)
000004  2900              CMP      r1,#0
000006  da01              BGE      |L39.12|
;;;2104       {
;;;2105           return NULL;
000008  2000              MOVS     r0,#0
;;;2106       }
;;;2107   
;;;2108       return cJSON_DetachItemViaPointer(array, get_array_item(array, (size_t)which));
;;;2109   }
00000a  bd10              POP      {r4,pc}
                  |L39.12|
00000c  f7fffffe          BL       get_array_item
000010  4601              MOV      r1,r0                 ;2108
000012  4620              MOV      r0,r4                 ;2108
000014  e8bd4010          POP      {r4,lr}               ;2108
000018  f7ffbffe          B.W      cJSON_DetachItemViaPointer
;;;2110   
                          ENDP


                          AREA ||i.cJSON_DetachItemFromObject||, CODE, READONLY, ALIGN=1

                  cJSON_DetachItemFromObject PROC
;;;2115   
;;;2116   CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string)
000000  b510              PUSH     {r4,lr}
;;;2117   {
000002  4604              MOV      r4,r0
;;;2118       cJSON *to_detach = cJSON_GetObjectItem(object, string);
000004  f7fffffe          BL       cJSON_GetObjectItem
000008  4601              MOV      r1,r0
;;;2119   
;;;2120       return cJSON_DetachItemViaPointer(object, to_detach);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  f7ffbffe          B.W      cJSON_DetachItemViaPointer
;;;2121   }
;;;2122   
                          ENDP


                          AREA ||i.cJSON_DetachItemFromObjectCaseSensitive||, CODE, READONLY, ALIGN=1

                  cJSON_DetachItemFromObjectCaseSensitive PROC
;;;2122   
;;;2123   CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string)
000000  b510              PUSH     {r4,lr}
;;;2124   {
000002  4604              MOV      r4,r0
;;;2125       cJSON *to_detach = cJSON_GetObjectItemCaseSensitive(object, string);
000004  f7fffffe          BL       cJSON_GetObjectItemCaseSensitive
000008  4601              MOV      r1,r0
;;;2126   
;;;2127       return cJSON_DetachItemViaPointer(object, to_detach);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  f7ffbffe          B.W      cJSON_DetachItemViaPointer
;;;2128   }
;;;2129   
                          ENDP


                          AREA ||i.cJSON_DetachItemViaPointer||, CODE, READONLY, ALIGN=1

                  cJSON_DetachItemViaPointer PROC
;;;2070   
;;;2071   CJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item)
000000  b190              CBZ      r0,|L42.40|
;;;2072   {
;;;2073       if ((parent == NULL) || (item == NULL))
000002  b189              CBZ      r1,|L42.40|
;;;2074       {
;;;2075           return NULL;
;;;2076       }
;;;2077   
;;;2078       if (item->prev != NULL)
000004  684a              LDR      r2,[r1,#4]
000006  b10a              CBZ      r2,|L42.12|
;;;2079       {
;;;2080           /* not the first element */
;;;2081           item->prev->next = item->next;
000008  680b              LDR      r3,[r1,#0]
00000a  6013              STR      r3,[r2,#0]
                  |L42.12|
;;;2082       }
;;;2083       if (item->next != NULL)
00000c  680a              LDR      r2,[r1,#0]
00000e  b10a              CBZ      r2,|L42.20|
;;;2084       {
;;;2085           /* not the last element */
;;;2086           item->next->prev = item->prev;
000010  684b              LDR      r3,[r1,#4]
000012  6053              STR      r3,[r2,#4]
                  |L42.20|
;;;2087       }
;;;2088   
;;;2089       if (item == parent->child)
000014  6882              LDR      r2,[r0,#8]
000016  428a              CMP      r2,r1
000018  d101              BNE      |L42.30|
;;;2090       {
;;;2091           /* first element */
;;;2092           parent->child = item->next;
00001a  680a              LDR      r2,[r1,#0]
00001c  6082              STR      r2,[r0,#8]
                  |L42.30|
;;;2093       }
;;;2094       /* make sure the detached item doesn't point anywhere anymore */
;;;2095       item->prev = NULL;
00001e  2000              MOVS     r0,#0
;;;2096       item->next = NULL;
000020  6048              STR      r0,[r1,#4]
;;;2097   
;;;2098       return item;
000022  6008              STR      r0,[r1,#0]
000024  4608              MOV      r0,r1
;;;2099   }
000026  4770              BX       lr
                  |L42.40|
000028  2000              MOVS     r0,#0                 ;2075
00002a  4770              BX       lr
;;;2100   
                          ENDP


                          AREA ||i.cJSON_Duplicate||, CODE, READONLY, ALIGN=2

                  cJSON_Duplicate PROC
;;;2549   /* Duplication */
;;;2550   CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2551   {
000004  460f              MOV      r7,r1
000006  0006              MOVS     r6,r0
;;;2552       cJSON *newitem = NULL;
;;;2553       cJSON *child = NULL;
;;;2554       cJSON *next = NULL;
000008  f04f0400          MOV      r4,#0
00000c  d037              BEQ      |L43.126|
;;;2555       cJSON *newchild = NULL;
;;;2556   
;;;2557       /* Bail on bad ptr */
;;;2558       if (!item)
;;;2559       {
;;;2560           goto fail;
;;;2561       }
;;;2562       /* Create new item */
;;;2563       newitem = cJSON_New_Item(&global_hooks);
00000e  481d              LDR      r0,|L43.132|
000010  f7fffffe          BL       cJSON_New_Item
000014  0005              MOVS     r5,r0
;;;2564       if (!newitem)
000016  d032              BEQ      |L43.126|
;;;2565       {
;;;2566           goto fail;
;;;2567       }
;;;2568       /* Copy over all vars */
;;;2569       newitem->type = item->type & (~cJSON_IsReference);
000018  68f0              LDR      r0,[r6,#0xc]
00001a  f4207080          BIC      r0,r0,#0x100
;;;2570       newitem->valueint = item->valueint;
00001e  60e8              STR      r0,[r5,#0xc]
000020  6970              LDR      r0,[r6,#0x14]
;;;2571       newitem->valuedouble = item->valuedouble;
000022  6168              STR      r0,[r5,#0x14]
000024  ed960b06          VLDR     d0,[r6,#0x18]
000028  ed850b06          VSTR     d0,[r5,#0x18]
;;;2572       if (item->valuestring)
00002c  6930              LDR      r0,[r6,#0x10]
00002e  b120              CBZ      r0,|L43.58|
;;;2573       {
;;;2574           newitem->valuestring = (char*)cJSON_strdup((unsigned char*)item->valuestring, &global_hooks);
000030  4914              LDR      r1,|L43.132|
000032  f7fffffe          BL       cJSON_strdup
;;;2575           if (!newitem->valuestring)
000036  6128              STR      r0,[r5,#0x10]
000038  b1f0              CBZ      r0,|L43.120|
                  |L43.58|
;;;2576           {
;;;2577               goto fail;
;;;2578           }
;;;2579       }
;;;2580       if (item->string)
00003a  6a30              LDR      r0,[r6,#0x20]
00003c  b138              CBZ      r0,|L43.78|
;;;2581       {
;;;2582           newitem->string = (item->type&cJSON_StringIsConst) ? item->string : (char*)cJSON_strdup((unsigned char*)item->string, &global_hooks);
00003e  89b1              LDRH     r1,[r6,#0xc]
000040  0589              LSLS     r1,r1,#22
000042  d402              BMI      |L43.74|
000044  490f              LDR      r1,|L43.132|
000046  f7fffffe          BL       cJSON_strdup
                  |L43.74|
;;;2583           if (!newitem->string)
00004a  6228              STR      r0,[r5,#0x20]
00004c  b1a0              CBZ      r0,|L43.120|
                  |L43.78|
;;;2584           {
;;;2585               goto fail;
;;;2586           }
;;;2587       }
;;;2588       /* If non-recursive, then we're done! */
;;;2589       if (!recurse)
00004e  b17f              CBZ      r7,|L43.112|
;;;2590       {
;;;2591           return newitem;
;;;2592       }
;;;2593       /* Walk the ->next chain for the child. */
;;;2594       child = item->child;
000050  68b6              LDR      r6,[r6,#8]
;;;2595       while (child != NULL)
000052  e00b              B        |L43.108|
                  |L43.84|
;;;2596       {
;;;2597           newchild = cJSON_Duplicate(child, true); /* Duplicate (with recurse) each item in the ->next chain */
000054  2101              MOVS     r1,#1
000056  4630              MOV      r0,r6
000058  f7fffffe          BL       cJSON_Duplicate
;;;2598           if (!newchild)
00005c  b158              CBZ      r0,|L43.118|
;;;2599           {
;;;2600               goto fail;
;;;2601           }
;;;2602           if (next != NULL)
00005e  b114              CBZ      r4,|L43.102|
;;;2603           {
;;;2604               /* If newitem->child already set, then crosswire ->prev and ->next and move on */
;;;2605               next->next = newchild;
;;;2606               newchild->prev = next;
000060  6020              STR      r0,[r4,#0]
;;;2607               next = newchild;
000062  6044              STR      r4,[r0,#4]
000064  e000              B        |L43.104|
                  |L43.102|
;;;2608           }
;;;2609           else
;;;2610           {
;;;2611               /* Set newitem->child and move to it */
;;;2612               newitem->child = newchild;
000066  60a8              STR      r0,[r5,#8]
                  |L43.104|
;;;2613               next = newchild;
;;;2614           }
;;;2615           child = child->next;
000068  6836              LDR      r6,[r6,#0]
00006a  4604              MOV      r4,r0                 ;2613
                  |L43.108|
00006c  2e00              CMP      r6,#0                 ;2595
00006e  d1f1              BNE      |L43.84|
                  |L43.112|
;;;2616       }
;;;2617   
;;;2618       return newitem;
000070  4628              MOV      r0,r5
                  |L43.114|
;;;2619   
;;;2620   fail:
;;;2621       if (newitem != NULL)
;;;2622       {
;;;2623           cJSON_Delete(newitem);
;;;2624       }
;;;2625   
;;;2626       return NULL;
;;;2627   }
000072  e8bd81f0          POP      {r4-r8,pc}
                  |L43.118|
000076  b115              CBZ      r5,|L43.126|
                  |L43.120|
000078  4628              MOV      r0,r5                 ;2623
00007a  f7fffffe          BL       cJSON_Delete
                  |L43.126|
00007e  2000              MOVS     r0,#0                 ;2626
000080  e7f7              B        |L43.114|
;;;2628   
                          ENDP

000082  0000              DCW      0x0000
                  |L43.132|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_GetArrayItem||, CODE, READONLY, ALIGN=1

                  cJSON_GetArrayItem PROC
;;;1761   
;;;1762   CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index)
000000  2900              CMP      r1,#0
;;;1763   {
000002  da01              BGE      |L44.8|
;;;1764       if (index < 0)
;;;1765       {
;;;1766           return NULL;
000004  2000              MOVS     r0,#0
;;;1767       }
;;;1768   
;;;1769       return get_array_item(array, (size_t)index);
;;;1770   }
000006  4770              BX       lr
                  |L44.8|
000008  f7ffbffe          B.W      get_array_item
;;;1771   
                          ENDP


                          AREA ||i.cJSON_GetArraySize||, CODE, READONLY, ALIGN=1

                  cJSON_GetArraySize PROC
;;;1719   /* Get Array size/item / object item. */
;;;1720   CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array)
000000  0001              MOVS     r1,r0
;;;1721   {
;;;1722       cJSON *child = NULL;
;;;1723       size_t size = 0;
000002  f04f0000          MOV      r0,#0
000006  d001              BEQ      |L45.12|
;;;1724   
;;;1725       if (array == NULL)
;;;1726       {
;;;1727           return 0;
;;;1728       }
;;;1729   
;;;1730       child = array->child;
000008  6889              LDR      r1,[r1,#8]
;;;1731   
;;;1732       while(child != NULL)
00000a  e003              B        |L45.20|
                  |L45.12|
00000c  2000              MOVS     r0,#0                 ;1727
;;;1733       {
;;;1734           size++;
;;;1735           child = child->next;
;;;1736       }
;;;1737   
;;;1738       /* FIXME: Can overflow here. Cannot be fixed without breaking the API */
;;;1739   
;;;1740       return (int)size;
;;;1741   }
00000e  4770              BX       lr
                  |L45.16|
000010  6809              LDR      r1,[r1,#0]            ;1735
000012  1c40              ADDS     r0,r0,#1              ;1735
                  |L45.20|
000014  2900              CMP      r1,#0                 ;1732
000016  d1fb              BNE      |L45.16|
000018  4770              BX       lr
;;;1742   
                          ENDP


                          AREA ||i.cJSON_GetErrorPtr||, CODE, READONLY, ALIGN=2

                  cJSON_GetErrorPtr PROC
;;;69     
;;;70     CJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void)
000000  4802              LDR      r0,|L46.12|
;;;71     {
;;;72         return (const char*) (global_error.json + global_error.position);
000002  e9d01000          LDRD     r1,r0,[r0,#0]
000006  4408              ADD      r0,r0,r1
;;;73     }
000008  4770              BX       lr
;;;74     
                          ENDP

00000a  0000              DCW      0x0000
                  |L46.12|
                          DCD      ||.data||

                          AREA ||i.cJSON_GetObjectItem||, CODE, READONLY, ALIGN=1

                  cJSON_GetObjectItem PROC
;;;1799   
;;;1800   CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string)
000000  2200              MOVS     r2,#0
;;;1801   {
;;;1802       return get_object_item(object, string, false);
000002  f7ffbffe          B.W      get_object_item
;;;1803   }
;;;1804   
                          ENDP


                          AREA ||i.cJSON_GetObjectItemCaseSensitive||, CODE, READONLY, ALIGN=1

                  cJSON_GetObjectItemCaseSensitive PROC
;;;1804   
;;;1805   CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string)
000000  2201              MOVS     r2,#1
;;;1806   {
;;;1807       return get_object_item(object, string, true);
000002  f7ffbffe          B.W      get_object_item
;;;1808   }
;;;1809   
                          ENDP


                          AREA ||i.cJSON_GetStringValue||, CODE, READONLY, ALIGN=1

                  cJSON_GetStringValue PROC
;;;74     
;;;75     CJSON_PUBLIC(char *) cJSON_GetStringValue(cJSON *item) {
000000  b500              PUSH     {lr}
000002  4601              MOV      r1,r0
;;;76         if (!cJSON_IsString(item)) {
000004  f7fffffe          BL       cJSON_IsString
000008  2800              CMP      r0,#0
00000a  d000              BEQ      |L49.14|
;;;77             return NULL;
;;;78         }
;;;79     
;;;80         return item->valuestring;
00000c  6908              LDR      r0,[r1,#0x10]
                  |L49.14|
;;;81     }
00000e  bd00              POP      {pc}
;;;82     
                          ENDP


                          AREA ||i.cJSON_HasObjectItem||, CODE, READONLY, ALIGN=1

                  cJSON_HasObjectItem PROC
;;;1809   
;;;1810   CJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string)
000000  b510              PUSH     {r4,lr}
;;;1811   {
;;;1812       return cJSON_GetObjectItem(object, string) ? 1 : 0;
000002  f7fffffe          BL       cJSON_GetObjectItem
000006  2800              CMP      r0,#0
000008  d000              BEQ      |L50.12|
00000a  2001              MOVS     r0,#1
                  |L50.12|
;;;1813   }
00000c  bd10              POP      {r4,pc}
;;;1814   
                          ENDP


                          AREA ||i.cJSON_InitHooks||, CODE, READONLY, ALIGN=2

                  cJSON_InitHooks PROC
;;;169    
;;;170    CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks)
000000  b530              PUSH     {r4,r5,lr}
;;;171    {
;;;172        if (hooks == NULL)
;;;173        {
;;;174            /* Reset hooks */
;;;175            global_hooks.allocate = malloc;
;;;176            global_hooks.deallocate = free;
;;;177            global_hooks.reallocate = realloc;
000002  4d0d              LDR      r5,|L51.56|
000004  4b0d              LDR      r3,|L51.60|
000006  4c0e              LDR      r4,|L51.64|
000008  4a0e              LDR      r2,|L51.68|
00000a  b188              CBZ      r0,|L51.48|
;;;178            return;
;;;179        }
;;;180    
;;;181        global_hooks.allocate = malloc;
;;;182        if (hooks->malloc_fn != NULL)
00000c  6013              STR      r3,[r2,#0]  ; global_hooks
00000e  6801              LDR      r1,[r0,#0]
000010  b101              CBZ      r1,|L51.20|
;;;183        {
;;;184            global_hooks.allocate = hooks->malloc_fn;
000012  6011              STR      r1,[r2,#0]  ; global_hooks
                  |L51.20|
;;;185        }
;;;186    
;;;187        global_hooks.deallocate = free;
;;;188        if (hooks->free_fn != NULL)
000014  6054              STR      r4,[r2,#4]  ; global_hooks
000016  6840              LDR      r0,[r0,#4]
000018  b100              CBZ      r0,|L51.28|
;;;189        {
;;;190            global_hooks.deallocate = hooks->free_fn;
00001a  6050              STR      r0,[r2,#4]  ; global_hooks
                  |L51.28|
;;;191        }
;;;192    
;;;193        /* use realloc only if both free and malloc are used */
;;;194        global_hooks.reallocate = NULL;
00001c  2000              MOVS     r0,#0
;;;195        if ((global_hooks.allocate == malloc) && (global_hooks.deallocate == free))
00001e  6090              STR      r0,[r2,#8]  ; global_hooks
000020  6810              LDR      r0,[r2,#0]  ; global_hooks
000022  4298              CMP      r0,r3
000024  d103              BNE      |L51.46|
000026  6850              LDR      r0,[r2,#4]  ; global_hooks
000028  42a0              CMP      r0,r4
00002a  d100              BNE      |L51.46|
;;;196        {
;;;197            global_hooks.reallocate = realloc;
00002c  6095              STR      r5,[r2,#8]  ; global_hooks
                  |L51.46|
;;;198        }
;;;199    }
00002e  bd30              POP      {r4,r5,pc}
                  |L51.48|
000030  e8820038          STM      r2,{r3-r5}
000034  bd30              POP      {r4,r5,pc}
;;;200    
                          ENDP

000036  0000              DCW      0x0000
                  |L51.56|
                          DCD      realloc
                  |L51.60|
                          DCD      malloc
                  |L51.64|
                          DCD      free
                  |L51.68|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_InsertItemInArray||, CODE, READONLY, ALIGN=1

                  cJSON_InsertItemInArray PROC
;;;2140   /* Replace array/object items with new ones. */
;;;2141   CJSON_PUBLIC(void) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)
000000  b570              PUSH     {r4-r6,lr}
;;;2142   {
000002  4614              MOV      r4,r2
000004  4605              MOV      r5,r0
;;;2143       cJSON *after_inserted = NULL;
;;;2144   
;;;2145       if (which < 0)
000006  2900              CMP      r1,#0
000008  db0a              BLT      |L52.32|
;;;2146       {
;;;2147           return;
;;;2148       }
;;;2149   
;;;2150       after_inserted = get_array_item(array, (size_t)which);
00000a  f7fffffe          BL       get_array_item
;;;2151       if (after_inserted == NULL)
00000e  b140              CBZ      r0,|L52.34|
;;;2152       {
;;;2153           add_item_to_array(array, newitem);
;;;2154           return;
;;;2155       }
;;;2156   
;;;2157       newitem->next = after_inserted;
;;;2158       newitem->prev = after_inserted->prev;
000010  6020              STR      r0,[r4,#0]
000012  6841              LDR      r1,[r0,#4]
;;;2159       after_inserted->prev = newitem;
000014  6061              STR      r1,[r4,#4]
;;;2160       if (after_inserted == array->child)
000016  6044              STR      r4,[r0,#4]
000018  68a9              LDR      r1,[r5,#8]
00001a  4281              CMP      r1,r0
00001c  d107              BNE      |L52.46|
;;;2161       {
;;;2162           array->child = newitem;
00001e  60ac              STR      r4,[r5,#8]
                  |L52.32|
;;;2163       }
;;;2164       else
;;;2165       {
;;;2166           newitem->prev->next = newitem;
;;;2167       }
;;;2168   }
000020  bd70              POP      {r4-r6,pc}
                  |L52.34|
000022  4621              MOV      r1,r4                 ;2153
000024  4628              MOV      r0,r5                 ;2153
000026  e8bd4070          POP      {r4-r6,lr}            ;2153
00002a  f7ffbffe          B.W      add_item_to_array
                  |L52.46|
00002e  6860              LDR      r0,[r4,#4]            ;2166
000030  6004              STR      r4,[r0,#0]            ;2166
000032  bd70              POP      {r4-r6,pc}
;;;2169   
                          ENDP


                          AREA ||i.cJSON_IsArray||, CODE, READONLY, ALIGN=1

                  cJSON_IsArray PROC
;;;2768   
;;;2769   CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item)
000000  2800              CMP      r0,#0
;;;2770   {
000002  d003              BEQ      |L53.12|
;;;2771       if (item == NULL)
;;;2772       {
;;;2773           return false;
;;;2774       }
;;;2775   
;;;2776       return (item->type & 0xFF) == cJSON_Array;
000004  7b00              LDRB     r0,[r0,#0xc]
000006  2820              CMP      r0,#0x20
000008  d001              BEQ      |L53.14|
00000a  2000              MOVS     r0,#0
                  |L53.12|
;;;2777   }
00000c  4770              BX       lr
                  |L53.14|
00000e  2001              MOVS     r0,#1                 ;2776
000010  4770              BX       lr
;;;2778   
                          ENDP


                          AREA ||i.cJSON_IsBool||, CODE, READONLY, ALIGN=1

                  cJSON_IsBool PROC
;;;2729   
;;;2730   CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item)
000000  2800              CMP      r0,#0
;;;2731   {
000002  d003              BEQ      |L54.12|
;;;2732       if (item == NULL)
;;;2733       {
;;;2734           return false;
;;;2735       }
;;;2736   
;;;2737       return (item->type & (cJSON_True | cJSON_False)) != 0;
000004  7b00              LDRB     r0,[r0,#0xc]
000006  0780              LSLS     r0,r0,#30
000008  d000              BEQ      |L54.12|
00000a  2001              MOVS     r0,#1
                  |L54.12|
;;;2738   }
00000c  4770              BX       lr
;;;2739   CJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item)
                          ENDP


                          AREA ||i.cJSON_IsFalse||, CODE, READONLY, ALIGN=1

                  cJSON_IsFalse PROC
;;;2708   
;;;2709   CJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item)
000000  2800              CMP      r0,#0
;;;2710   {
000002  d003              BEQ      |L55.12|
;;;2711       if (item == NULL)
;;;2712       {
;;;2713           return false;
;;;2714       }
;;;2715   
;;;2716       return (item->type & 0xFF) == cJSON_False;
000004  7b00              LDRB     r0,[r0,#0xc]
000006  2801              CMP      r0,#1
000008  d000              BEQ      |L55.12|
00000a  2000              MOVS     r0,#0
                  |L55.12|
;;;2717   }
00000c  4770              BX       lr
;;;2718   
                          ENDP


                          AREA ||i.cJSON_IsInvalid||, CODE, READONLY, ALIGN=1

                  cJSON_IsInvalid PROC
;;;2698   
;;;2699   CJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item)
000000  2800              CMP      r0,#0
;;;2700   {
000002  d004              BEQ      |L56.14|
;;;2701       if (item == NULL)
;;;2702       {
;;;2703           return false;
;;;2704       }
;;;2705   
;;;2706       return (item->type & 0xFF) == cJSON_Invalid;
000004  7b00              LDRB     r0,[r0,#0xc]
000006  f0100fff          TST      r0,#0xff
00000a  d001              BEQ      |L56.16|
00000c  2000              MOVS     r0,#0
                  |L56.14|
;;;2707   }
00000e  4770              BX       lr
                  |L56.16|
000010  2001              MOVS     r0,#1                 ;2706
000012  4770              BX       lr
;;;2708   
                          ENDP


                          AREA ||i.cJSON_IsNull||, CODE, READONLY, ALIGN=1

                  cJSON_IsNull PROC
;;;2738   }
;;;2739   CJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item)
000000  2800              CMP      r0,#0
;;;2740   {
000002  d003              BEQ      |L57.12|
;;;2741       if (item == NULL)
;;;2742       {
;;;2743           return false;
;;;2744       }
;;;2745   
;;;2746       return (item->type & 0xFF) == cJSON_NULL;
000004  7b00              LDRB     r0,[r0,#0xc]
000006  2804              CMP      r0,#4
000008  d001              BEQ      |L57.14|
00000a  2000              MOVS     r0,#0
                  |L57.12|
;;;2747   }
00000c  4770              BX       lr
                  |L57.14|
00000e  2001              MOVS     r0,#1                 ;2746
000010  4770              BX       lr
;;;2748   
                          ENDP


                          AREA ||i.cJSON_IsNumber||, CODE, READONLY, ALIGN=1

                  cJSON_IsNumber PROC
;;;2748   
;;;2749   CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item)
000000  2800              CMP      r0,#0
;;;2750   {
000002  d003              BEQ      |L58.12|
;;;2751       if (item == NULL)
;;;2752       {
;;;2753           return false;
;;;2754       }
;;;2755   
;;;2756       return (item->type & 0xFF) == cJSON_Number;
000004  7b00              LDRB     r0,[r0,#0xc]
000006  2808              CMP      r0,#8
000008  d001              BEQ      |L58.14|
00000a  2000              MOVS     r0,#0
                  |L58.12|
;;;2757   }
00000c  4770              BX       lr
                  |L58.14|
00000e  2001              MOVS     r0,#1                 ;2756
000010  4770              BX       lr
;;;2758   
                          ENDP


                          AREA ||i.cJSON_IsObject||, CODE, READONLY, ALIGN=1

                  cJSON_IsObject PROC
;;;2778   
;;;2779   CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item)
000000  2800              CMP      r0,#0
;;;2780   {
000002  d003              BEQ      |L59.12|
;;;2781       if (item == NULL)
;;;2782       {
;;;2783           return false;
;;;2784       }
;;;2785   
;;;2786       return (item->type & 0xFF) == cJSON_Object;
000004  7b00              LDRB     r0,[r0,#0xc]
000006  2840              CMP      r0,#0x40
000008  d001              BEQ      |L59.14|
00000a  2000              MOVS     r0,#0
                  |L59.12|
;;;2787   }
00000c  4770              BX       lr
                  |L59.14|
00000e  2001              MOVS     r0,#1                 ;2786
000010  4770              BX       lr
;;;2788   
                          ENDP


                          AREA ||i.cJSON_IsRaw||, CODE, READONLY, ALIGN=1

                  cJSON_IsRaw PROC
;;;2788   
;;;2789   CJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON * const item)
000000  2800              CMP      r0,#0
;;;2790   {
000002  d003              BEQ      |L60.12|
;;;2791       if (item == NULL)
;;;2792       {
;;;2793           return false;
;;;2794       }
;;;2795   
;;;2796       return (item->type & 0xFF) == cJSON_Raw;
000004  7b00              LDRB     r0,[r0,#0xc]
000006  2880              CMP      r0,#0x80
000008  d001              BEQ      |L60.14|
00000a  2000              MOVS     r0,#0
                  |L60.12|
;;;2797   }
00000c  4770              BX       lr
                  |L60.14|
00000e  2001              MOVS     r0,#1                 ;2796
000010  4770              BX       lr
;;;2798   
                          ENDP


                          AREA ||i.cJSON_IsString||, CODE, READONLY, ALIGN=1

                  cJSON_IsString PROC
;;;2758   
;;;2759   CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item)
000000  2800              CMP      r0,#0
;;;2760   {
000002  d003              BEQ      |L61.12|
;;;2761       if (item == NULL)
;;;2762       {
;;;2763           return false;
;;;2764       }
;;;2765   
;;;2766       return (item->type & 0xFF) == cJSON_String;
000004  7b00              LDRB     r0,[r0,#0xc]
000006  2810              CMP      r0,#0x10
000008  d001              BEQ      |L61.14|
00000a  2000              MOVS     r0,#0
                  |L61.12|
;;;2767   }
00000c  4770              BX       lr
                  |L61.14|
00000e  2001              MOVS     r0,#1                 ;2766
000010  4770              BX       lr
;;;2768   
                          ENDP


                          AREA ||i.cJSON_IsTrue||, CODE, READONLY, ALIGN=1

                  cJSON_IsTrue PROC
;;;2718   
;;;2719   CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item)
000000  2800              CMP      r0,#0
;;;2720   {
000002  d003              BEQ      |L62.12|
;;;2721       if (item == NULL)
;;;2722       {
;;;2723           return false;
;;;2724       }
;;;2725   
;;;2726       return (item->type & 0xff) == cJSON_True;
000004  7b00              LDRB     r0,[r0,#0xc]
000006  2802              CMP      r0,#2
000008  d001              BEQ      |L62.14|
00000a  2000              MOVS     r0,#0
                  |L62.12|
;;;2727   }
00000c  4770              BX       lr
                  |L62.14|
00000e  2001              MOVS     r0,#1                 ;2726
000010  4770              BX       lr
;;;2728   
                          ENDP


                          AREA ||i.cJSON_Minify||, CODE, READONLY, ALIGN=1

                  cJSON_Minify PROC
;;;2628   
;;;2629   CJSON_PUBLIC(void) cJSON_Minify(char *json)
000000  1e01              SUBS     r1,r0,#0
;;;2630   {
000002  d020              BEQ      |L63.70|
000004  e01a              B        |L63.60|
                  |L63.6|
;;;2631       unsigned char *into = (unsigned char*)json;
;;;2632   
;;;2633       if (json == NULL)
;;;2634       {
;;;2635           return;
;;;2636       }
;;;2637   
;;;2638       while (*json)
;;;2639       {
;;;2640           if (*json == ' ')
000006  b2d2              UXTB     r2,r2
000008  2a20              CMP      r2,#0x20
00000a  d00b              BEQ      |L63.36|
;;;2641           {
;;;2642               json++;
;;;2643           }
;;;2644           else if (*json == '\t')
00000c  2a09              CMP      r2,#9
00000e  d009              BEQ      |L63.36|
;;;2645           {
;;;2646               /* Whitespace characters. */
;;;2647               json++;
;;;2648           }
;;;2649           else if (*json == '\r')
000010  2a0d              CMP      r2,#0xd
000012  d007              BEQ      |L63.36|
;;;2650           {
;;;2651               json++;
;;;2652           }
;;;2653           else if (*json=='\n')
000014  2a0a              CMP      r2,#0xa
000016  d005              BEQ      |L63.36|
;;;2654           {
;;;2655               json++;
;;;2656           }
;;;2657           else if ((*json == '/') && (json[1] == '/'))
000018  2a2f              CMP      r2,#0x2f
00001a  d005              BEQ      |L63.40|
;;;2658           {
;;;2659               /* double-slash comments, to end of line. */
;;;2660               while (*json && (*json != '\n'))
;;;2661               {
;;;2662                   json++;
;;;2663               }
;;;2664           }
;;;2665           else if ((*json == '/') && (json[1] == '*'))
;;;2666           {
;;;2667               /* multiline comments. */
;;;2668               while (*json && !((*json == '*') && (json[1] == '/')))
;;;2669               {
;;;2670                   json++;
;;;2671               }
;;;2672               json += 2;
;;;2673           }
;;;2674           else if (*json == '\"')
00001c  b2d3              UXTB     r3,r2
00001e  2b22              CMP      r3,#0x22
000020  d023              BEQ      |L63.106|
000022  e007              B        |L63.52|
                  |L63.36|
000024  1c40              ADDS     r0,r0,#1
000026  e009              B        |L63.60|
                  |L63.40|
000028  7842              LDRB     r2,[r0,#1]            ;2657
00002a  2a2f              CMP      r2,#0x2f              ;2657
00002c  d00c              BEQ      |L63.72|
00002e  b2d2              UXTB     r2,r2                 ;2665
000030  2a2a              CMP      r2,#0x2a              ;2665
000032  d010              BEQ      |L63.86|
                  |L63.52|
;;;2675           {
;;;2676               /* string literals, which are \" sensitive. */
;;;2677               *into++ = (unsigned char)*json++;
;;;2678               while (*json && (*json != '\"'))
;;;2679               {
;;;2680                   if (*json == '\\')
;;;2681                   {
;;;2682                       *into++ = (unsigned char)*json++;
;;;2683                   }
;;;2684                   *into++ = (unsigned char)*json++;
;;;2685               }
;;;2686               *into++ = (unsigned char)*json++;
;;;2687           }
;;;2688           else
;;;2689           {
;;;2690               /* All other characters. */
;;;2691               *into++ = (unsigned char)*json++;
000034  f8102b01          LDRB     r2,[r0],#1
000038  f8012b01          STRB     r2,[r1],#1
                  |L63.60|
00003c  7802              LDRB     r2,[r0,#0]            ;2638
00003e  2a00              CMP      r2,#0                 ;2638
000040  d1e1              BNE      |L63.6|
                  |L63.66|
;;;2692           }
;;;2693       }
;;;2694   
;;;2695       /* and null-terminate. */
;;;2696       *into = '\0';
000042  2000              MOVS     r0,#0
000044  7008              STRB     r0,[r1,#0]
                  |L63.70|
;;;2697   }
000046  4770              BX       lr
                  |L63.72|
000048  f8102f01          LDRB     r2,[r0,#1]!           ;2660
00004c  2a00              CMP      r2,#0                 ;2662
00004e  d0f8              BEQ      |L63.66|
000050  2a0a              CMP      r2,#0xa               ;2660
000052  d1f9              BNE      |L63.72|
000054  e7d7              B        |L63.6|
                  |L63.86|
000056  f8102f01          LDRB     r2,[r0,#1]!           ;2668
00005a  b122              CBZ      r2,|L63.102|
00005c  2a2a              CMP      r2,#0x2a              ;2668
00005e  d1fa              BNE      |L63.86|
000060  7842              LDRB     r2,[r0,#1]            ;2668
000062  2a2f              CMP      r2,#0x2f              ;2668
000064  d1f7              BNE      |L63.86|
                  |L63.102|
000066  1c80              ADDS     r0,r0,#2              ;2668
000068  e7e8              B        |L63.60|
                  |L63.106|
00006a  f8012b01          STRB     r2,[r1],#1            ;2677
00006e  1c40              ADDS     r0,r0,#1              ;2677
000070  e008              B        |L63.132|
                  |L63.114|
000072  2a5c              CMP      r2,#0x5c              ;2680
000074  d102              BNE      |L63.124|
000076  f8012b01          STRB     r2,[r1],#1            ;2682
00007a  1c40              ADDS     r0,r0,#1              ;2682
                  |L63.124|
00007c  f8102b01          LDRB     r2,[r0],#1            ;2684
000080  f8012b01          STRB     r2,[r1],#1            ;2684
                  |L63.132|
000084  7802              LDRB     r2,[r0,#0]            ;2678
000086  b10a              CBZ      r2,|L63.140|
000088  2a22              CMP      r2,#0x22              ;2678
00008a  d1f2              BNE      |L63.114|
                  |L63.140|
00008c  f8012b01          STRB     r2,[r1],#1            ;2686
000090  e7c8              B        |L63.36|
;;;2698   
                          ENDP


                          AREA ||i.cJSON_New_Item||, CODE, READONLY, ALIGN=1

                  cJSON_New_Item PROC
;;;201    /* Internal constructor. */
;;;202    static cJSON *cJSON_New_Item(const internal_hooks * const hooks)
000000  b510              PUSH     {r4,lr}
;;;203    {
;;;204        cJSON* node = (cJSON*)hooks->allocate(sizeof(cJSON));
000002  6801              LDR      r1,[r0,#0]
000004  2028              MOVS     r0,#0x28
000006  4788              BLX      r1
000008  0004              MOVS     r4,r0
;;;205        if (node)
00000a  d002              BEQ      |L64.18|
;;;206        {
;;;207            memset(node, '\0', sizeof(cJSON));
00000c  2128              MOVS     r1,#0x28
00000e  f7fffffe          BL       __aeabi_memclr4
                  |L64.18|
;;;208        }
;;;209    
;;;210        return node;
000012  4620              MOV      r0,r4
;;;211    }
000014  bd10              POP      {r4,pc}
;;;212    
                          ENDP


                          AREA ||i.cJSON_Parse||, CODE, READONLY, ALIGN=1

                  cJSON_Parse PROC
;;;1079   /* Default options for cJSON_Parse */
;;;1080   CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value)
000000  2200              MOVS     r2,#0
;;;1081   {
;;;1082       return cJSON_ParseWithOpts(value, 0, 0);
000002  4611              MOV      r1,r2
000004  f7ffbffe          B.W      cJSON_ParseWithOpts
;;;1083   }
;;;1084   
                          ENDP


                          AREA ||i.cJSON_ParseWithOpts||, CODE, READONLY, ALIGN=2

                  cJSON_ParseWithOpts PROC
;;;999    /* Parse an object - create a new root, and populate. */
;;;1000   CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1001   {
000004  b088              SUB      sp,sp,#0x20
000006  460c              MOV      r4,r1
000008  4605              MOV      r5,r0
00000a  4692              MOV      r10,r2
;;;1002       parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };
00000c  211c              MOVS     r1,#0x1c
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       __aeabi_memclr4
;;;1003       cJSON *item = NULL;
;;;1004   
;;;1005       /* reset error position */
;;;1006       global_error.json = NULL;
000014  4831              LDR      r0,|L66.220|
000016  2600              MOVS     r6,#0
;;;1007       global_error.position = 0;
;;;1008   
;;;1009       if (value == NULL)
000018  2d00              CMP      r5,#0
00001a  6006              STR      r6,[r0,#0]            ;1007  ; global_error
00001c  6046              STR      r6,[r0,#4]  ; global_error
00001e  d05a              BEQ      |L66.214|
;;;1010       {
;;;1011           goto fail;
;;;1012       }
;;;1013   
;;;1014       buffer.content = (const unsigned char*)value;
;;;1015       buffer.length = strlen((const char*)value) + sizeof("");
000020  4628              MOV      r0,r5
000022  9500              STR      r5,[sp,#0]
000024  f7fffffe          BL       strlen
;;;1016       buffer.offset = 0;
;;;1017       buffer.hooks = global_hooks;
000028  1c40              ADDS     r0,r0,#1
00002a  f8df90b0          LDR      r9,|L66.220|
00002e  e9cd0601          STRD     r0,r6,[sp,#4]
000032  e9d91202          LDRD     r1,r2,[r9,#8]
000036  f8d90010          LDR      r0,[r9,#0x10]  ; global_hooks
00003a  9104              STR      r1,[sp,#0x10]
00003c  e9cd2005          STRD     r2,r0,[sp,#0x14]
000040  46b0              MOV      r8,r6                 ;1016
;;;1018   
;;;1019       item = cJSON_New_Item(&global_hooks);
000042  f1090008          ADD      r0,r9,#8
000046  f7fffffe          BL       cJSON_New_Item
00004a  0006              MOVS     r6,r0
;;;1020       if (item == NULL) /* memory fail */
00004c  d02b              BEQ      |L66.166|
;;;1021       {
;;;1022           goto fail;
;;;1023       }
;;;1024   
;;;1025       if (!parse_value(item, buffer_skip_whitespace(skip_utf8_bom(&buffer))))
00004e  9800              LDR      r0,[sp,#0]
000050  466f              MOV      r7,sp
000052  b108              CBZ      r0,|L66.88|
000054  9802              LDR      r0,[sp,#8]
000056  b108              CBZ      r0,|L66.92|
                  |L66.88|
000058  2000              MOVS     r0,#0
00005a  e00c              B        |L66.118|
                  |L66.92|
00005c  9801              LDR      r0,[sp,#4]
00005e  2804              CMP      r0,#4
000060  d908              BLS      |L66.116|
000062  2203              MOVS     r2,#3
000064  a11e              ADR      r1,|L66.224|
000066  9800              LDR      r0,[sp,#0]
000068  f7fffffe          BL       strncmp
00006c  b910              CBNZ     r0,|L66.116|
00006e  9802              LDR      r0,[sp,#8]
000070  1cc0              ADDS     r0,r0,#3
000072  9002              STR      r0,[sp,#8]
                  |L66.116|
000074  4638              MOV      r0,r7
                  |L66.118|
000076  f7fffffe          BL       buffer_skip_whitespace
00007a  4601              MOV      r1,r0
00007c  4630              MOV      r0,r6
00007e  f7fffffe          BL       parse_value
000082  b168              CBZ      r0,|L66.160|
;;;1026       {
;;;1027           /* parse failure. ep is set. */
;;;1028           goto fail;
;;;1029       }
;;;1030   
;;;1031       /* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
;;;1032       if (require_null_terminated)
000084  f1ba0f00          CMP      r10,#0
000088  d014              BEQ      |L66.180|
;;;1033       {
;;;1034           buffer_skip_whitespace(&buffer);
00008a  4668              MOV      r0,sp
00008c  f7fffffe          BL       buffer_skip_whitespace
000090  e9dd0101          LDRD     r0,r1,[sp,#4]
;;;1035           if ((buffer.offset >= buffer.length) || buffer_at_offset(&buffer)[0] != '\0')
000094  4281              CMP      r1,r0
000096  d203              BCS      |L66.160|
000098  9902              LDR      r1,[sp,#8]
00009a  9800              LDR      r0,[sp,#0]
00009c  5c40              LDRB     r0,[r0,r1]
00009e  b148              CBZ      r0,|L66.180|
                  |L66.160|
;;;1036           {
;;;1037               goto fail;
;;;1038           }
;;;1039       }
;;;1040       if (return_parse_end)
;;;1041       {
;;;1042           *return_parse_end = (const char*)buffer_at_offset(&buffer);
;;;1043       }
;;;1044   
;;;1045       return item;
;;;1046   
;;;1047   fail:
;;;1048       if (item != NULL)
;;;1049       {
;;;1050           cJSON_Delete(item);
0000a0  4630              MOV      r0,r6
0000a2  f7fffffe          BL       cJSON_Delete
                  |L66.166|
;;;1051       }
;;;1052   
;;;1053       if (value != NULL)
;;;1054       {
;;;1055           error local_error;
;;;1056           local_error.json = (const unsigned char*)value;
;;;1057           local_error.position = 0;
0000a6  e9dd2101          LDRD     r2,r1,[sp,#4]
0000aa  4640              MOV      r0,r8
;;;1058   
;;;1059           if (buffer.offset < buffer.length)
0000ac  4291              CMP      r1,r2
0000ae  d20a              BCS      |L66.198|
;;;1060           {
;;;1061               local_error.position = buffer.offset;
0000b0  4608              MOV      r0,r1
0000b2  e00b              B        |L66.204|
                  |L66.180|
0000b4  b11c              CBZ      r4,|L66.190|
0000b6  9902              LDR      r1,[sp,#8]            ;1042
0000b8  9800              LDR      r0,[sp,#0]            ;1042
0000ba  4408              ADD      r0,r0,r1              ;1042
0000bc  6020              STR      r0,[r4,#0]            ;1042
                  |L66.190|
0000be  4630              MOV      r0,r6                 ;1045
                  |L66.192|
;;;1062           }
;;;1063           else if (buffer.length > 0)
;;;1064           {
;;;1065               local_error.position = buffer.length - 1;
;;;1066           }
;;;1067   
;;;1068           if (return_parse_end != NULL)
;;;1069           {
;;;1070               *return_parse_end = (const char*)local_error.json + local_error.position;
;;;1071           }
;;;1072   
;;;1073           global_error = local_error;
;;;1074       }
;;;1075   
;;;1076       return NULL;
;;;1077   }
0000c0  b008              ADD      sp,sp,#0x20
0000c2  e8bd87f0          POP      {r4-r10,pc}
                  |L66.198|
0000c6  1e11              SUBS     r1,r2,#0              ;1063
0000c8  d000              BEQ      |L66.204|
0000ca  1e48              SUBS     r0,r1,#1              ;1065
                  |L66.204|
0000cc  b10c              CBZ      r4,|L66.210|
0000ce  1829              ADDS     r1,r5,r0              ;1070
0000d0  6021              STR      r1,[r4,#0]            ;1070
                  |L66.210|
0000d2  e9c95000          STRD     r5,r0,[r9,#0]         ;1073
                  |L66.214|
0000d6  2000              MOVS     r0,#0                 ;1076
0000d8  e7f2              B        |L66.192|
;;;1078   
                          ENDP

0000da  0000              DCW      0x0000
                  |L66.220|
                          DCD      ||.data||
                  |L66.224|
0000e0  efbbbf00          DCB      239,187,191,0

                          AREA ||i.cJSON_Print||, CODE, READONLY, ALIGN=2

                  cJSON_Print PROC
;;;1151   /* Render a cJSON item/entity/structure to text. */
;;;1152   CJSON_PUBLIC(char *) cJSON_Print(const cJSON *item)
000000  4a01              LDR      r2,|L67.8|
;;;1153   {
;;;1154       return (char*)print(item, true, &global_hooks);
000002  2101              MOVS     r1,#1
000004  f7ffbffe          B.W      print
;;;1155   }
;;;1156   
                          ENDP

                  |L67.8|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_PrintBuffered||, CODE, READONLY, ALIGN=2

                  cJSON_PrintBuffered PROC
;;;1161   
;;;1162   CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1163   {
000002  b089              SUB      sp,sp,#0x24
000004  460c              MOV      r4,r1
000006  4606              MOV      r6,r0
000008  4617              MOV      r7,r2
;;;1164       printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
00000a  2124              MOVS     r1,#0x24
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memclr4
;;;1165   
;;;1166       if (prebuffer < 0)
000012  2c00              CMP      r4,#0
000014  da02              BGE      |L68.28|
                  |L68.22|
;;;1167       {
;;;1168           return NULL;
000016  2000              MOVS     r0,#0
                  |L68.24|
;;;1169       }
;;;1170   
;;;1171       p.buffer = (unsigned char*)global_hooks.allocate((size_t)prebuffer);
;;;1172       if (!p.buffer)
;;;1173       {
;;;1174           return NULL;
;;;1175       }
;;;1176   
;;;1177       p.length = (size_t)prebuffer;
;;;1178       p.offset = 0;
;;;1179       p.noalloc = false;
;;;1180       p.format = fmt;
;;;1181       p.hooks = global_hooks;
;;;1182   
;;;1183       if (!print_value(item, &p))
;;;1184       {
;;;1185           global_hooks.deallocate(p.buffer);
;;;1186           return NULL;
;;;1187       }
;;;1188   
;;;1189       return (char*)p.buffer;
;;;1190   }
000018  b009              ADD      sp,sp,#0x24
00001a  bdf0              POP      {r4-r7,pc}
                  |L68.28|
00001c  4d0d              LDR      r5,|L68.84|
00001e  4620              MOV      r0,r4                 ;1171
000020  6829              LDR      r1,[r5,#0]            ;1171  ; global_hooks
000022  4788              BLX      r1                    ;1171
000024  9000              STR      r0,[sp,#0]            ;1172
000026  2800              CMP      r0,#0                 ;1172
000028  d0f6              BEQ      |L68.24|
00002a  2000              MOVS     r0,#0                 ;1178
00002c  e9cd4001          STRD     r4,r0,[sp,#4]         ;1178
000030  e9cd0704          STRD     r0,r7,[sp,#0x10]      ;1178
000034  4628              MOV      r0,r5                 ;1181
000036  ab06              ADD      r3,sp,#0x18           ;1181
000038  c807              LDM      r0,{r0-r2}            ;1181
00003a  e8830007          STM      r3,{r0-r2}            ;1181
00003e  4669              MOV      r1,sp                 ;1183
000040  4630              MOV      r0,r6                 ;1183
000042  f7fffffe          BL       print_value
000046  2800              CMP      r0,#0                 ;1183
000048  9800              LDR      r0,[sp,#0]            ;1183
00004a  d1e5              BNE      |L68.24|
00004c  6869              LDR      r1,[r5,#4]            ;1185  ; global_hooks
00004e  4788              BLX      r1                    ;1185
000050  e7e1              B        |L68.22|
;;;1191   
                          ENDP

000052  0000              DCW      0x0000
                  |L68.84|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_PrintPreallocated||, CODE, READONLY, ALIGN=2

                  cJSON_PrintPreallocated PROC
;;;1191   
;;;1192   CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buf, const int len, const cJSON_bool fmt)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1193   {
000002  b089              SUB      sp,sp,#0x24
000004  460d              MOV      r5,r1
000006  4606              MOV      r6,r0
000008  461f              MOV      r7,r3
00000a  4614              MOV      r4,r2
;;;1194       printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
00000c  2124              MOVS     r1,#0x24
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       __aeabi_memclr4
;;;1195   
;;;1196       if ((len < 0) || (buf == NULL))
000014  2c00              CMP      r4,#0
000016  db12              BLT      |L69.62|
000018  b18d              CBZ      r5,|L69.62|
;;;1197       {
;;;1198           return false;
;;;1199       }
;;;1200   
;;;1201       p.buffer = (unsigned char*)buf;
;;;1202       p.length = (size_t)len;
;;;1203       p.offset = 0;
00001a  2000              MOVS     r0,#0
00001c  9500              STR      r5,[sp,#0]
00001e  e9cd4001          STRD     r4,r0,[sp,#4]
;;;1204       p.noalloc = true;
000022  2001              MOVS     r0,#1
;;;1205       p.format = fmt;
;;;1206       p.hooks = global_hooks;
000024  4907              LDR      r1,|L69.68|
000026  e9cd0704          STRD     r0,r7,[sp,#0x10]
00002a  c907              LDM      r1,{r0-r2}
00002c  ab06              ADD      r3,sp,#0x18
00002e  e8830007          STM      r3,{r0-r2}
;;;1207   
;;;1208       return print_value(item, &p);
000032  4669              MOV      r1,sp
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       print_value
                  |L69.58|
;;;1209   }
00003a  b009              ADD      sp,sp,#0x24
00003c  bdf0              POP      {r4-r7,pc}
                  |L69.62|
00003e  2000              MOVS     r0,#0                 ;1198
000040  e7fb              B        |L69.58|
;;;1210   
                          ENDP

000042  0000              DCW      0x0000
                  |L69.68|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_PrintUnformatted||, CODE, READONLY, ALIGN=2

                  cJSON_PrintUnformatted PROC
;;;1156   
;;;1157   CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item)
000000  4a01              LDR      r2,|L70.8|
;;;1158   {
;;;1159       return (char*)print(item, false, &global_hooks);
000002  2100              MOVS     r1,#0
000004  f7ffbffe          B.W      print
;;;1160   }
;;;1161   
                          ENDP

                  |L70.8|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_ReplaceItemInArray||, CODE, READONLY, ALIGN=1

                  cJSON_ReplaceItemInArray PROC
;;;2204   
;;;2205   CJSON_PUBLIC(void) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem)
000000  b570              PUSH     {r4-r6,lr}
;;;2206   {
000002  4614              MOV      r4,r2
000004  4605              MOV      r5,r0
;;;2207       if (which < 0)
000006  2900              CMP      r1,#0
000008  db08              BLT      |L71.28|
;;;2208       {
;;;2209           return;
;;;2210       }
;;;2211   
;;;2212       cJSON_ReplaceItemViaPointer(array, get_array_item(array, (size_t)which), newitem);
00000a  f7fffffe          BL       get_array_item
00000e  4601              MOV      r1,r0
000010  4622              MOV      r2,r4
000012  4628              MOV      r0,r5
000014  e8bd4070          POP      {r4-r6,lr}
000018  f7ffbffe          B.W      cJSON_ReplaceItemViaPointer
                  |L71.28|
;;;2213   }
00001c  bd70              POP      {r4-r6,pc}
;;;2214   
                          ENDP


                          AREA ||i.cJSON_ReplaceItemInObject||, CODE, READONLY, ALIGN=1

                  cJSON_ReplaceItemInObject PROC
;;;2234   
;;;2235   CJSON_PUBLIC(void) cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem)
000000  2300              MOVS     r3,#0
;;;2236   {
;;;2237       replace_item_in_object(object, string, newitem, false);
000002  f7ffbffe          B.W      replace_item_in_object
;;;2238   }
;;;2239   
                          ENDP


                          AREA ||i.cJSON_ReplaceItemInObjectCaseSensitive||, CODE, READONLY, ALIGN=1

                  cJSON_ReplaceItemInObjectCaseSensitive PROC
;;;2239   
;;;2240   CJSON_PUBLIC(void) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object, const char *string, cJSON *newitem)
000000  2301              MOVS     r3,#1
;;;2241   {
;;;2242       replace_item_in_object(object, string, newitem, true);
000002  f7ffbffe          B.W      replace_item_in_object
;;;2243   }
;;;2244   
                          ENDP


                          AREA ||i.cJSON_ReplaceItemViaPointer||, CODE, READONLY, ALIGN=1

                  cJSON_ReplaceItemViaPointer PROC
;;;2169   
;;;2170   CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement)
000000  b510              PUSH     {r4,lr}
;;;2171   {
000002  0003              MOVS     r3,r0
000004  d005              BEQ      |L74.18|
;;;2172       if ((parent == NULL) || (replacement == NULL) || (item == NULL))
000006  b122              CBZ      r2,|L74.18|
000008  b119              CBZ      r1,|L74.18|
;;;2173       {
;;;2174           return false;
;;;2175       }
;;;2176   
;;;2177       if (replacement == item)
00000a  428a              CMP      r2,r1
00000c  d103              BNE      |L74.22|
                  |L74.14|
;;;2178       {
;;;2179           return true;
00000e  2001              MOVS     r0,#1
;;;2180       }
;;;2181   
;;;2182       replacement->next = item->next;
;;;2183       replacement->prev = item->prev;
;;;2184   
;;;2185       if (replacement->next != NULL)
;;;2186       {
;;;2187           replacement->next->prev = replacement;
;;;2188       }
;;;2189       if (replacement->prev != NULL)
;;;2190       {
;;;2191           replacement->prev->next = replacement;
;;;2192       }
;;;2193       if (parent->child == item)
;;;2194       {
;;;2195           parent->child = replacement;
;;;2196       }
;;;2197   
;;;2198       item->next = NULL;
;;;2199       item->prev = NULL;
;;;2200       cJSON_Delete(item);
;;;2201   
;;;2202       return true;
;;;2203   }
000010  bd10              POP      {r4,pc}
                  |L74.18|
000012  2000              MOVS     r0,#0                 ;2174
000014  bd10              POP      {r4,pc}
                  |L74.22|
000016  6808              LDR      r0,[r1,#0]            ;2182
000018  6010              STR      r0,[r2,#0]            ;2183
00001a  684c              LDR      r4,[r1,#4]            ;2183
00001c  6054              STR      r4,[r2,#4]            ;2185
00001e  b100              CBZ      r0,|L74.34|
000020  6042              STR      r2,[r0,#4]            ;2187
                  |L74.34|
000022  6850              LDR      r0,[r2,#4]            ;2189
000024  b100              CBZ      r0,|L74.40|
000026  6002              STR      r2,[r0,#0]            ;2191
                  |L74.40|
000028  6898              LDR      r0,[r3,#8]            ;2193
00002a  4288              CMP      r0,r1                 ;2193
00002c  d100              BNE      |L74.48|
00002e  609a              STR      r2,[r3,#8]            ;2195
                  |L74.48|
000030  2000              MOVS     r0,#0                 ;2198
000032  6008              STR      r0,[r1,#0]            ;2199
000034  6048              STR      r0,[r1,#4]            ;2200
000036  4608              MOV      r0,r1                 ;2200
000038  f7fffffe          BL       cJSON_Delete
00003c  e7e7              B        |L74.14|
;;;2204   
                          ENDP


                          AREA ||i.cJSON_SetNumberHelper||, CODE, READONLY, ALIGN=2

                  cJSON_SetNumberHelper PROC
;;;342    /* don't ask me, but the original cJSON_SetNumberValue returns an integer or double */
;;;343    CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number)
000000  b510              PUSH     {r4,lr}
;;;344    {
000002  4604              MOV      r4,r0
000004  ed2d8b02          VPUSH    {d8}
000008  eeb08a40          VMOV.F32 s16,s0
00000c  eef08a60          VMOV.F32 s17,s1
;;;345        if (number >= INT_MAX)
000010  ed9f0b12          VLDR     d0,|L75.92|
000014  ec510b18          VMOV     r0,r1,d8
000018  ec532b10          VMOV     r2,r3,d0
00001c  f7fffffe          BL       __aeabi_cdrcmple
000020  d802              BHI      |L75.40|
;;;346        {
;;;347            object->valueint = INT_MAX;
000022  f06f4000          MVN      r0,#0x80000000
000026  e00f              B        |L75.72|
                  |L75.40|
;;;348        }
;;;349        else if (number <= INT_MIN)
000028  ed9f0b0e          VLDR     d0,|L75.100|
00002c  ec510b18          VMOV     r0,r1,d8
000030  ec532b10          VMOV     r2,r3,d0
000034  f7fffffe          BL       __aeabi_cdcmple
000038  d802              BHI      |L75.64|
;;;350        {
;;;351            object->valueint = INT_MIN;
00003a  f04f4000          MOV      r0,#0x80000000
00003e  e003              B        |L75.72|
                  |L75.64|
;;;352        }
;;;353        else
;;;354        {
;;;355            object->valueint = (int)number;
000040  ec510b18          VMOV     r0,r1,d8
000044  f7fffffe          BL       __aeabi_d2iz
                  |L75.72|
;;;356        }
;;;357    
;;;358        return object->valuedouble = number;
000048  eeb00a48          VMOV.F32 s0,s16
00004c  eef00a68          VMOV.F32 s1,s17
000050  6160              STR      r0,[r4,#0x14]
000052  ed840b06          VSTR     d0,[r4,#0x18]
;;;359    }
000056  ecbd8b02          VPOP     {d8}
00005a  bd10              POP      {r4,pc}
;;;360    
                          ENDP

                  |L75.92|
00005c  ffc00000          DCFD     0x41dfffffffc00000 ; 2147483647
000060  41dfffff
                  |L75.100|
000064  00000000          DCFD     0xc1e0000000000000 ; -2147483648
000068  c1e00000

                          AREA ||i.cJSON_Version||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_i
                          REQUIRE _printf_int_dec
                  cJSON_Version PROC
;;;87     
;;;88     CJSON_PUBLIC(const char*) cJSON_Version(void)
000000  b508              PUSH     {r3,lr}
;;;89     {
;;;90         static char version[15];
;;;91         sprintf(version, "%i.%i.%i", CJSON_VERSION_MAJOR, CJSON_VERSION_MINOR, CJSON_VERSION_PATCH);
000002  2006              MOVS     r0,#6
000004  9000              STR      r0,[sp,#0]
000006  2307              MOVS     r3,#7
000008  2201              MOVS     r2,#1
00000a  a103              ADR      r1,|L76.24|
00000c  4805              LDR      r0,|L76.36|
00000e  f7fffffe          BL       __2sprintf
;;;92     
;;;93         return version;
000012  4804              LDR      r0,|L76.36|
;;;94     }
000014  bd08              POP      {r3,pc}
;;;95     
                          ENDP

000016  0000              DCW      0x0000
                  |L76.24|
000018  25692e25          DCB      "%i.%i.%i",0
00001c  692e2569
000020  00      
000021  00                DCB      0
000022  00                DCB      0
000023  00                DCB      0
                  |L76.36|
                          DCD      ||.bss||

                          AREA ||i.cJSON_free||, CODE, READONLY, ALIGN=2

                  cJSON_free PROC
;;;2928   
;;;2929   CJSON_PUBLIC(void) cJSON_free(void *object)
000000  4901              LDR      r1,|L77.8|
;;;2930   {
;;;2931       global_hooks.deallocate(object);
000002  6849              LDR      r1,[r1,#4]  ; global_hooks
000004  4708              BX       r1
;;;2932   }
                          ENDP

000006  0000              DCW      0x0000
                  |L77.8|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_malloc||, CODE, READONLY, ALIGN=2

                  cJSON_malloc PROC
;;;2923   
;;;2924   CJSON_PUBLIC(void *) cJSON_malloc(size_t size)
000000  4901              LDR      r1,|L78.8|
;;;2925   {
;;;2926       return global_hooks.allocate(size);
000002  6809              LDR      r1,[r1,#0]  ; global_hooks
000004  4708              BX       r1
;;;2927   }
;;;2928   
                          ENDP

000006  0000              DCW      0x0000
                  |L78.8|
                          DCD      ||.data||+0x8

                          AREA ||i.cJSON_strdup||, CODE, READONLY, ALIGN=1

                  cJSON_strdup PROC
;;;148    
;;;149    static unsigned char* cJSON_strdup(const unsigned char* string, const internal_hooks * const hooks)
000000  b570              PUSH     {r4-r6,lr}
;;;150    {
000002  460c              MOV      r4,r1
000004  0006              MOVS     r6,r0
000006  d00d              BEQ      |L79.36|
;;;151        size_t length = 0;
;;;152        unsigned char *copy = NULL;
;;;153    
;;;154        if (string == NULL)
;;;155        {
;;;156            return NULL;
;;;157        }
;;;158    
;;;159        length = strlen((const char*)string) + sizeof("");
000008  f7fffffe          BL       strlen
00000c  1c40              ADDS     r0,r0,#1
;;;160        copy = (unsigned char*)hooks->allocate(length);
00000e  6823              LDR      r3,[r4,#0]
000010  4605              MOV      r5,r0                 ;159
000012  4798              BLX      r3
000014  0004              MOVS     r4,r0
;;;161        if (copy == NULL)
000016  d005              BEQ      |L79.36|
;;;162        {
;;;163            return NULL;
;;;164        }
;;;165        memcpy(copy, string, length);
000018  462a              MOV      r2,r5
00001a  4631              MOV      r1,r6
00001c  f7fffffe          BL       __aeabi_memcpy
;;;166    
;;;167        return copy;
000020  4620              MOV      r0,r4
;;;168    }
000022  bd70              POP      {r4-r6,pc}
                  |L79.36|
000024  2000              MOVS     r0,#0                 ;163
000026  bd70              POP      {r4-r6,pc}
;;;169    
                          ENDP


                          AREA ||i.create_reference||, CODE, READONLY, ALIGN=1

                  create_reference PROC
;;;1822   /* Utility for handling references. */
;;;1823   static cJSON *create_reference(const cJSON *item, const internal_hooks * const hooks)
000000  b570              PUSH     {r4-r6,lr}
;;;1824   {
000002  0005              MOVS     r5,r0
000004  d012              BEQ      |L80.44|
;;;1825       cJSON *reference = NULL;
;;;1826       if (item == NULL)
;;;1827       {
;;;1828           return NULL;
;;;1829       }
;;;1830   
;;;1831       reference = cJSON_New_Item(hooks);
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       cJSON_New_Item
00000c  0004              MOVS     r4,r0
;;;1832       if (reference == NULL)
00000e  d00d              BEQ      |L80.44|
;;;1833       {
;;;1834           return NULL;
;;;1835       }
;;;1836   
;;;1837       memcpy(reference, item, sizeof(cJSON));
000010  2228              MOVS     r2,#0x28
000012  4629              MOV      r1,r5
000014  f7fffffe          BL       __aeabi_memcpy4
;;;1838       reference->string = NULL;
000018  2000              MOVS     r0,#0
;;;1839       reference->type |= cJSON_IsReference;
00001a  6220              STR      r0,[r4,#0x20]
00001c  68e1              LDR      r1,[r4,#0xc]
;;;1840       reference->next = reference->prev = NULL;
00001e  6060              STR      r0,[r4,#4]
000020  f4417180          ORR      r1,r1,#0x100          ;1839
;;;1841       return reference;
000024  60e1              STR      r1,[r4,#0xc]
000026  6020              STR      r0,[r4,#0]
000028  4620              MOV      r0,r4
;;;1842   }
00002a  bd70              POP      {r4-r6,pc}
                  |L80.44|
00002c  2000              MOVS     r0,#0                 ;1834
00002e  bd70              POP      {r4-r6,pc}
;;;1843   
                          ENDP


                          AREA ||i.ensure||, CODE, READONLY, ALIGN=1

                  ensure PROC
;;;372    /* realloc printbuffer if necessary to have at least "needed" bytes more */
;;;373    static unsigned char* ensure(printbuffer * const p, size_t needed)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;374    {
000004  0004              MOVS     r4,r0
000006  d01c              BEQ      |L81.66|
;;;375        unsigned char *newbuffer = NULL;
;;;376        size_t newsize = 0;
;;;377    
;;;378        if ((p == NULL) || (p->buffer == NULL))
000008  6822              LDR      r2,[r4,#0]
00000a  b1d2              CBZ      r2,|L81.66|
;;;379        {
;;;380            return NULL;
;;;381        }
;;;382    
;;;383        if ((p->length > 0) && (p->offset >= p->length))
00000c  6863              LDR      r3,[r4,#4]
00000e  b113              CBZ      r3,|L81.22|
000010  68a0              LDR      r0,[r4,#8]
000012  4298              CMP      r0,r3
000014  d215              BCS      |L81.66|
                  |L81.22|
;;;384        {
;;;385            /* make sure that offset is valid */
;;;386            return NULL;
;;;387        }
;;;388    
;;;389        if (needed > INT_MAX)
000016  f04f4600          MOV      r6,#0x80000000
00001a  42b1              CMP      r1,r6
00001c  d211              BCS      |L81.66|
;;;390        {
;;;391            /* sizes bigger than INT_MAX are currently not supported */
;;;392            return NULL;
;;;393        }
;;;394    
;;;395        needed += p->offset + 1;
00001e  68a5              LDR      r5,[r4,#8]
000020  1c49              ADDS     r1,r1,#1
000022  1868              ADDS     r0,r5,r1
;;;396        if (needed <= p->length)
000024  4283              CMP      r3,r0
000026  d302              BCC      |L81.46|
;;;397        {
;;;398            return p->buffer + p->offset;
000028  1950              ADDS     r0,r2,r5
                  |L81.42|
;;;399        }
;;;400    
;;;401        if (p->noalloc) {
;;;402            return NULL;
;;;403        }
;;;404    
;;;405        /* calculate new buffer size */
;;;406        if (needed > (INT_MAX / 2))
;;;407        {
;;;408            /* overflow of int, use INT_MAX if possible */
;;;409            if (needed <= INT_MAX)
;;;410            {
;;;411                newsize = INT_MAX;
;;;412            }
;;;413            else
;;;414            {
;;;415                return NULL;
;;;416            }
;;;417        }
;;;418        else
;;;419        {
;;;420            newsize = needed * 2;
;;;421        }
;;;422    
;;;423        if (p->hooks.reallocate != NULL)
;;;424        {
;;;425            /* reallocate with realloc if available */
;;;426            newbuffer = (unsigned char*)p->hooks.reallocate(p->buffer, newsize);
;;;427            if (newbuffer == NULL)
;;;428            {
;;;429                p->hooks.deallocate(p->buffer);
;;;430                p->length = 0;
;;;431                p->buffer = NULL;
;;;432    
;;;433                return NULL;
;;;434            }
;;;435        }
;;;436        else
;;;437        {
;;;438            /* otherwise reallocate manually */
;;;439            newbuffer = (unsigned char*)p->hooks.allocate(newsize);
;;;440            if (!newbuffer)
;;;441            {
;;;442                p->hooks.deallocate(p->buffer);
;;;443                p->length = 0;
;;;444                p->buffer = NULL;
;;;445    
;;;446                return NULL;
;;;447            }
;;;448            if (newbuffer)
;;;449            {
;;;450                memcpy(newbuffer, p->buffer, p->offset + 1);
;;;451            }
;;;452            p->hooks.deallocate(p->buffer);
;;;453        }
;;;454        p->length = newsize;
;;;455        p->buffer = newbuffer;
;;;456    
;;;457        return newbuffer + p->offset;
;;;458    }
00002a  e8bd81f0          POP      {r4-r8,pc}
                  |L81.46|
00002e  6921              LDR      r1,[r4,#0x10]         ;401
000030  b939              CBNZ     r1,|L81.66|
000032  f1b04f80          CMP      r0,#0x40000000        ;406
000036  d306              BCC      |L81.70|
000038  42b0              CMP      r0,r6                 ;409
00003a  d202              BCS      |L81.66|
00003c  f06f4600          MVN      r6,#0x80000000        ;411
000040  e002              B        |L81.72|
                  |L81.66|
000042  2000              MOVS     r0,#0                 ;415
000044  e7f1              B        |L81.42|
                  |L81.70|
000046  0046              LSLS     r6,r0,#1              ;420
                  |L81.72|
000048  6a23              LDR      r3,[r4,#0x20]         ;423
00004a  2700              MOVS     r7,#0                 ;423
00004c  b12b              CBZ      r3,|L81.90|
00004e  4631              MOV      r1,r6                 ;426
000050  4610              MOV      r0,r2                 ;426
000052  4798              BLX      r3                    ;426
000054  0005              MOVS     r5,r0                 ;426
000056  d012              BEQ      |L81.126|
000058  e00c              B        |L81.116|
                  |L81.90|
00005a  69a1              LDR      r1,[r4,#0x18]         ;439
00005c  4630              MOV      r0,r6                 ;439
00005e  4788              BLX      r1                    ;439
000060  0005              MOVS     r5,r0                 ;439
000062  d00c              BEQ      |L81.126|
000064  68a2              LDR      r2,[r4,#8]            ;450
000066  6821              LDR      r1,[r4,#0]            ;450
000068  1c52              ADDS     r2,r2,#1              ;450
00006a  f7fffffe          BL       __aeabi_memcpy
00006e  69e1              LDR      r1,[r4,#0x1c]         ;452
000070  6820              LDR      r0,[r4,#0]            ;452
000072  4788              BLX      r1                    ;452
                  |L81.116|
000074  e9c45600          STRD     r5,r6,[r4,#0]         ;452
000078  68a0              LDR      r0,[r4,#8]            ;457
00007a  4428              ADD      r0,r0,r5              ;457
00007c  e7d5              B        |L81.42|
                  |L81.126|
00007e  69e1              LDR      r1,[r4,#0x1c]         ;442
000080  6820              LDR      r0,[r4,#0]            ;442
000082  4788              BLX      r1                    ;442
000084  6067              STR      r7,[r4,#4]            ;444
000086  6027              STR      r7,[r4,#0]            ;446
000088  e7db              B        |L81.66|
;;;459    
                          ENDP


                          AREA ||i.get_array_item||, CODE, READONLY, ALIGN=1

                  get_array_item PROC
;;;1742   
;;;1743   static cJSON* get_array_item(const cJSON *array, size_t index)
000000  2800              CMP      r0,#0
;;;1744   {
000002  d007              BEQ      |L82.20|
;;;1745       cJSON *current_child = NULL;
;;;1746   
;;;1747       if (array == NULL)
;;;1748       {
;;;1749           return NULL;
;;;1750       }
;;;1751   
;;;1752       current_child = array->child;
000004  6880              LDR      r0,[r0,#8]
;;;1753       while ((current_child != NULL) && (index > 0))
000006  e001              B        |L82.12|
                  |L82.8|
;;;1754       {
;;;1755           index--;
;;;1756           current_child = current_child->next;
000008  6800              LDR      r0,[r0,#0]
00000a  1e49              SUBS     r1,r1,#1
                  |L82.12|
00000c  2800              CMP      r0,#0                 ;1753
00000e  d001              BEQ      |L82.20|
000010  2900              CMP      r1,#0                 ;1753
000012  d1f9              BNE      |L82.8|
                  |L82.20|
;;;1757       }
;;;1758   
;;;1759       return current_child;
;;;1760   }
000014  4770              BX       lr
;;;1761   
                          ENDP


                          AREA ||i.get_object_item||, CODE, READONLY, ALIGN=1

                  get_object_item PROC
;;;1771   
;;;1772   static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1773   {
000004  4688              MOV      r8,r1
000006  b128              CBZ      r0,|L83.20|
;;;1774       cJSON *current_element = NULL;
;;;1775   
;;;1776       if ((object == NULL) || (name == NULL))
000008  f1b80f00          CMP      r8,#0
00000c  d002              BEQ      |L83.20|
;;;1777       {
;;;1778           return NULL;
;;;1779       }
;;;1780   
;;;1781       current_element = object->child;
;;;1782       if (case_sensitive)
00000e  6885              LDR      r5,[r0,#8]
000010  b922              CBNZ     r2,|L83.28|
000012  e00c              B        |L83.46|
                  |L83.20|
000014  2000              MOVS     r0,#0                 ;1778
                  |L83.22|
;;;1783       {
;;;1784           while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))
;;;1785           {
;;;1786               current_element = current_element->next;
;;;1787           }
;;;1788       }
;;;1789       else
;;;1790       {
;;;1791           while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
;;;1792           {
;;;1793               current_element = current_element->next;
;;;1794           }
;;;1795       }
;;;1796   
;;;1797       return current_element;
;;;1798   }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L83.26|
00001a  682d              LDR      r5,[r5,#0]            ;1786
                  |L83.28|
00001c  b335              CBZ      r5,|L83.108|
00001e  4640              MOV      r0,r8                 ;1784
000020  6a29              LDR      r1,[r5,#0x20]         ;1784
000022  f7fffffe          BL       strcmp
000026  2800              CMP      r0,#0                 ;1784
000028  d1f7              BNE      |L83.26|
00002a  e01f              B        |L83.108|
                  |L83.44|
00002c  682d              LDR      r5,[r5,#0]            ;1793
                  |L83.46|
00002e  b1ed              CBZ      r5,|L83.108|
000030  6a2e              LDR      r6,[r5,#0x20]         ;1791
000032  ea5f0408          MOVS     r4,r8                 ;1791
000036  d0f9              BEQ      |L83.44|
000038  2e00              CMP      r6,#0                 ;1791
00003a  d0f7              BEQ      |L83.44|
00003c  42b4              CMP      r4,r6                 ;1791
00003e  d015              BEQ      |L83.108|
000040  e002              B        |L83.72|
                  |L83.66|
000042  b198              CBZ      r0,|L83.108|
000044  1c64              ADDS     r4,r4,#1              ;1791
000046  1c76              ADDS     r6,r6,#1              ;1791
                  |L83.72|
000048  7820              LDRB     r0,[r4,#0]            ;1791
00004a  f7fffffe          BL       tolower
00004e  4607              MOV      r7,r0                 ;1791
000050  7830              LDRB     r0,[r6,#0]            ;1791
000052  f7fffffe          BL       tolower
000056  4287              CMP      r7,r0                 ;1791
000058  7820              LDRB     r0,[r4,#0]            ;1791
00005a  d0f2              BEQ      |L83.66|
00005c  f7fffffe          BL       tolower
000060  4604              MOV      r4,r0                 ;1791
000062  7830              LDRB     r0,[r6,#0]            ;1791
000064  f7fffffe          BL       tolower
000068  4284              CMP      r4,r0                 ;1791
00006a  d1df              BNE      |L83.44|
                  |L83.108|
00006c  4628              MOV      r0,r5                 ;1797
00006e  e7d2              B        |L83.22|
;;;1799   
                          ENDP


                          AREA ||i.parse_array||, CODE, READONLY, ALIGN=1

                  parse_array PROC
;;;1340   /* Build an array from input text. */
;;;1341   static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1342   {
000004  4607              MOV      r7,r0
;;;1343       cJSON *head = NULL; /* head of the linked list */
000006  2600              MOVS     r6,#0
;;;1344       cJSON *current_item = NULL;
;;;1345   
;;;1346       if (input_buffer->depth >= CJSON_NESTING_LIMIT)
000008  68c8              LDR      r0,[r1,#0xc]
00000a  460c              MOV      r4,r1                 ;1342
00000c  4635              MOV      r5,r6                 ;1344
00000e  f5b07f7a          CMP      r0,#0x3e8
000012  d259              BCS      |L84.200|
000014  1c40              ADDS     r0,r0,#1              ;1342
;;;1347       {
;;;1348           return false; /* to deeply nested */
;;;1349       }
;;;1350       input_buffer->depth++;
;;;1351   
;;;1352       if (buffer_at_offset(input_buffer)[0] != '[')
000016  60e0              STR      r0,[r4,#0xc]
000018  6821              LDR      r1,[r4,#0]
00001a  68a0              LDR      r0,[r4,#8]
00001c  5c09              LDRB     r1,[r1,r0]
00001e  295b              CMP      r1,#0x5b
000020  d152              BNE      |L84.200|
000022  1c40              ADDS     r0,r0,#1
;;;1353       {
;;;1354           /* not an array */
;;;1355           goto fail;
;;;1356       }
;;;1357   
;;;1358       input_buffer->offset++;
;;;1359       buffer_skip_whitespace(input_buffer);
000024  60a0              STR      r0,[r4,#8]
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       buffer_skip_whitespace
;;;1360       if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ']'))
00002c  b14c              CBZ      r4,|L84.66|
00002e  e9d41001          LDRD     r1,r0,[r4,#4]
000032  4288              CMP      r0,r1
000034  d203              BCS      |L84.62|
000036  6822              LDR      r2,[r4,#0]
000038  5c12              LDRB     r2,[r2,r0]
00003a  2a5d              CMP      r2,#0x5d
00003c  d033              BEQ      |L84.166|
                  |L84.62|
;;;1361       {
;;;1362           /* empty array */
;;;1363           goto success;
;;;1364       }
;;;1365   
;;;1366       /* check if we skipped to the end of the buffer */
;;;1367       if (cannot_access_at_index(input_buffer, 0))
00003e  4288              CMP      r0,r1
000040  d303              BCC      |L84.74|
                  |L84.66|
;;;1368       {
;;;1369           input_buffer->offset--;
000042  68a0              LDR      r0,[r4,#8]
000044  1e40              SUBS     r0,r0,#1
;;;1370           goto fail;
000046  60a0              STR      r0,[r4,#8]
000048  e03e              B        |L84.200|
                  |L84.74|
00004a  1e40              SUBS     r0,r0,#1
;;;1371       }
;;;1372   
;;;1373       /* step back to character in front of the first element */
;;;1374       input_buffer->offset--;
;;;1375       /* loop through the comma separated array elements */
;;;1376       do
;;;1377       {
;;;1378           /* allocate next item */
;;;1379           cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
00004c  f1040810          ADD      r8,r4,#0x10
000050  60a0              STR      r0,[r4,#8]
                  |L84.82|
000052  4640              MOV      r0,r8
000054  f7fffffe          BL       cJSON_New_Item
;;;1380           if (new_item == NULL)
000058  b388              CBZ      r0,|L84.190|
;;;1381           {
;;;1382               goto fail; /* allocation failure */
;;;1383           }
;;;1384   
;;;1385           /* attach next item to list */
;;;1386           if (head == NULL)
00005a  b30e              CBZ      r6,|L84.160|
;;;1387           {
;;;1388               /* start the linked list */
;;;1389               current_item = head = new_item;
;;;1390           }
;;;1391           else
;;;1392           {
;;;1393               /* add to the end and advance */
;;;1394               current_item->next = new_item;
;;;1395               new_item->prev = current_item;
00005c  6028              STR      r0,[r5,#0]
;;;1396               current_item = new_item;
00005e  6045              STR      r5,[r0,#4]
000060  4605              MOV      r5,r0
                  |L84.98|
;;;1397           }
;;;1398   
;;;1399           /* parse next value */
;;;1400           input_buffer->offset++;
000062  68a0              LDR      r0,[r4,#8]
000064  1c40              ADDS     r0,r0,#1
;;;1401           buffer_skip_whitespace(input_buffer);
000066  60a0              STR      r0,[r4,#8]
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       buffer_skip_whitespace
;;;1402           if (!parse_value(current_item, input_buffer))
00006e  4621              MOV      r1,r4
000070  4628              MOV      r0,r5
000072  f7fffffe          BL       parse_value
000076  b320              CBZ      r0,|L84.194|
;;;1403           {
;;;1404               goto fail; /* failed to parse value */
;;;1405           }
;;;1406           buffer_skip_whitespace(input_buffer);
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       buffer_skip_whitespace
;;;1407       }
;;;1408       while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));
00007e  b304              CBZ      r4,|L84.194|
000080  e9d41001          LDRD     r1,r0,[r4,#4]
000084  4288              CMP      r0,r1
000086  d203              BCS      |L84.144|
000088  6821              LDR      r1,[r4,#0]
00008a  5c09              LDRB     r1,[r1,r0]
00008c  292c              CMP      r1,#0x2c
00008e  d0e0              BEQ      |L84.82|
                  |L84.144|
;;;1409   
;;;1410       if (cannot_access_at_index(input_buffer, 0) || buffer_at_offset(input_buffer)[0] != ']')
000090  6862              LDR      r2,[r4,#4]
000092  4290              CMP      r0,r2
000094  d215              BCS      |L84.194|
000096  6821              LDR      r1,[r4,#0]
000098  5c08              LDRB     r0,[r1,r0]
00009a  285d              CMP      r0,#0x5d
00009c  d111              BNE      |L84.194|
00009e  e002              B        |L84.166|
                  |L84.160|
0000a0  4606              MOV      r6,r0                 ;1389
0000a2  4635              MOV      r5,r6                 ;1389
0000a4  e7dd              B        |L84.98|
                  |L84.166|
;;;1411       {
;;;1412           goto fail; /* expected end of array */
;;;1413       }
;;;1414   
;;;1415   success:
;;;1416       input_buffer->depth--;
0000a6  68e0              LDR      r0,[r4,#0xc]
0000a8  1e40              SUBS     r0,r0,#1
;;;1417   
;;;1418       item->type = cJSON_Array;
0000aa  60e0              STR      r0,[r4,#0xc]
0000ac  2020              MOVS     r0,#0x20
0000ae  e9c76002          STRD     r6,r0,[r7,#8]
;;;1419       item->child = head;
;;;1420   
;;;1421       input_buffer->offset++;
0000b2  68a0              LDR      r0,[r4,#8]
0000b4  1c40              ADDS     r0,r0,#1
;;;1422   
;;;1423       return true;
0000b6  60a0              STR      r0,[r4,#8]
0000b8  2001              MOVS     r0,#1
                  |L84.186|
;;;1424   
;;;1425   fail:
;;;1426       if (head != NULL)
;;;1427       {
;;;1428           cJSON_Delete(head);
;;;1429       }
;;;1430   
;;;1431       return false;
;;;1432   }
0000ba  e8bd81f0          POP      {r4-r8,pc}
                  |L84.190|
0000be  e7ff              B        |L84.192|
                  |L84.192|
0000c0  b116              CBZ      r6,|L84.200|
                  |L84.194|
0000c2  4630              MOV      r0,r6                 ;1428
0000c4  f7fffffe          BL       cJSON_Delete
                  |L84.200|
0000c8  2000              MOVS     r0,#0                 ;1431
0000ca  e7f6              B        |L84.186|
;;;1433   
                          ENDP


                          AREA ||i.parse_hex4||, CODE, READONLY, ALIGN=1

                  parse_hex4 PROC
;;;539    /* parse 4 digit hexadecimal number */
;;;540    static unsigned parse_hex4(const unsigned char * const input)
000000  4603              MOV      r3,r0
;;;541    {
000002  b510              PUSH     {r4,lr}
;;;542        unsigned int h = 0;
000004  2000              MOVS     r0,#0
;;;543        size_t i = 0;
000006  4602              MOV      r2,r0
                  |L85.8|
;;;544    
;;;545        for (i = 0; i < 4; i++)
;;;546        {
;;;547            /* parse digit */
;;;548            if ((input[i] >= '0') && (input[i] <= '9'))
000008  5c99              LDRB     r1,[r3,r2]
00000a  f1a10430          SUB      r4,r1,#0x30
00000e  2c09              CMP      r4,#9
000010  d801              BHI      |L85.22|
000012  3830              SUBS     r0,r0,#0x30
;;;549            {
;;;550                h += (unsigned int) input[i] - '0';
000014  e00a              B        |L85.44|
                  |L85.22|
;;;551            }
;;;552            else if ((input[i] >= 'A') && (input[i] <= 'F'))
000016  f1a10441          SUB      r4,r1,#0x41
00001a  2c05              CMP      r4,#5
00001c  d801              BHI      |L85.34|
00001e  3837              SUBS     r0,r0,#0x37
;;;553            {
;;;554                h += (unsigned int) 10 + input[i] - 'A';
000020  e004              B        |L85.44|
                  |L85.34|
;;;555            }
;;;556            else if ((input[i] >= 'a') && (input[i] <= 'f'))
000022  f1a10461          SUB      r4,r1,#0x61
000026  2c05              CMP      r4,#5
000028  d808              BHI      |L85.60|
00002a  3857              SUBS     r0,r0,#0x57
                  |L85.44|
;;;557            {
;;;558                h += (unsigned int) 10 + input[i] - 'a';
00002c  4408              ADD      r0,r0,r1
;;;559            }
;;;560            else /* invalid */
;;;561            {
;;;562                return 0;
;;;563            }
;;;564    
;;;565            if (i < 3)
00002e  2a03              CMP      r2,#3
000030  d200              BCS      |L85.52|
;;;566            {
;;;567                /* shift left to make place for the next nibble */
;;;568                h = h << 4;
000032  0100              LSLS     r0,r0,#4
                  |L85.52|
000034  1c52              ADDS     r2,r2,#1
000036  2a04              CMP      r2,#4                 ;545
000038  d3e6              BCC      |L85.8|
;;;569            }
;;;570        }
;;;571    
;;;572        return h;
;;;573    }
00003a  bd10              POP      {r4,pc}
                  |L85.60|
00003c  2000              MOVS     r0,#0                 ;562
00003e  bd10              POP      {r4,pc}
;;;574    
                          ENDP


                          AREA ||i.parse_number||, CODE, READONLY, ALIGN=2

                  parse_number PROC
;;;265    /* Parse the input text to generate a number, and populate the result into item. */
;;;266    static cJSON_bool parse_number(cJSON * const item, parse_buffer * const input_buffer)
000000  b5f0              PUSH     {r4-r7,lr}
;;;267    {
;;;268        double number = 0;
;;;269        unsigned char *after_end = NULL;
000002  f04f0300          MOV      r3,#0
000006  ed2d8b02          VPUSH    {d8}                  ;267
00000a  b091              SUB      sp,sp,#0x44           ;267
00000c  4605              MOV      r5,r0                 ;267
00000e  000c              MOVS     r4,r1                 ;267
000010  f04f072e          MOV      r7,#0x2e              ;267
;;;270        unsigned char number_c_string[64];
;;;271        unsigned char decimal_point = get_decimal_point();
;;;272        size_t i = 0;
000014  4618              MOV      r0,r3
000016  9310              STR      r3,[sp,#0x40]         ;267
000018  d03d              BEQ      |L86.150|
;;;273    
;;;274        if ((input_buffer == NULL) || (input_buffer->content == NULL))
00001a  6821              LDR      r1,[r4,#0]
00001c  b3d9              CBZ      r1,|L86.150|
00001e  466e              MOV      r6,sp                 ;270
;;;275        {
;;;276            return false;
;;;277        }
;;;278    
;;;279        /* copy the number into a temporary buffer and replace '.' with the decimal point
;;;280         * of the current locale (for strtod)
;;;281         * This also takes care of '\0' not necessarily being available for marking the end of the input */
;;;282        for (i = 0; (i < (sizeof(number_c_string) - 1)) && can_access_at_index(input_buffer, i); i++)
000020  e027              B        |L86.114|
                  |L86.34|
;;;283        {
;;;284            switch (buffer_at_offset(input_buffer)[i])
000022  6822              LDR      r2,[r4,#0]
000024  4411              ADD      r1,r1,r2
000026  5c42              LDRB     r2,[r0,r1]
000028  2a34              CMP      r2,#0x34
00002a  d01b              BEQ      |L86.100|
00002c  dc0a              BGT      |L86.68|
00002e  f1a2012b          SUB      r1,r2,#0x2b
000032  2909              CMP      r1,#9
000034  d223              BCS      |L86.126|
000036  e8dff001          TBB      [pc,r1]
00003a  1522              DCB      0x15,0x22
00003c  15172215          DCB      0x15,0x17,0x22,0x15
000040  15151500          DCB      0x15,0x15,0x15,0x00
                  |L86.68|
000044  2a38              CMP      r2,#0x38
000046  d00d              BEQ      |L86.100|
000048  dc06              BGT      |L86.88|
00004a  2a35              CMP      r2,#0x35
00004c  d00a              BEQ      |L86.100|
00004e  2a36              CMP      r2,#0x36
000050  d008              BEQ      |L86.100|
000052  2a37              CMP      r2,#0x37
000054  d113              BNE      |L86.126|
000056  e005              B        |L86.100|
                  |L86.88|
000058  2a39              CMP      r2,#0x39
00005a  d003              BEQ      |L86.100|
00005c  2a45              CMP      r2,#0x45
00005e  d001              BEQ      |L86.100|
000060  2a65              CMP      r2,#0x65
000062  d10c              BNE      |L86.126|
                  |L86.100|
;;;285            {
;;;286                case '0':
;;;287                case '1':
;;;288                case '2':
;;;289                case '3':
;;;290                case '4':
;;;291                case '5':
;;;292                case '6':
;;;293                case '7':
;;;294                case '8':
;;;295                case '9':
;;;296                case '+':
;;;297                case '-':
;;;298                case 'e':
;;;299                case 'E':
;;;300                    number_c_string[i] = buffer_at_offset(input_buffer)[i];
000064  5432              STRB     r2,[r6,r0]
;;;301                    break;
000066  e000              B        |L86.106|
;;;302    
;;;303                case '.':
;;;304                    number_c_string[i] = decimal_point;
000068  5437              STRB     r7,[r6,r0]
                  |L86.106|
00006a  1c40              ADDS     r0,r0,#1
00006c  283f              CMP      r0,#0x3f              ;282
00006e  d206              BCS      |L86.126|
000070  b12c              CBZ      r4,|L86.126|
                  |L86.114|
000072  68a1              LDR      r1,[r4,#8]            ;282
000074  f8d4c004          LDR      r12,[r4,#4]           ;282
000078  180a              ADDS     r2,r1,r0              ;282
00007a  4562              CMP      r2,r12                ;282
00007c  d3d1              BCC      |L86.34|
                  |L86.126|
;;;305                    break;
;;;306    
;;;307                default:
;;;308                    goto loop_end;
;;;309            }
;;;310        }
;;;311    loop_end:
;;;312        number_c_string[i] = '\0';
00007e  5433              STRB     r3,[r6,r0]
;;;313    
;;;314        number = strtod((const char*)number_c_string, (char**)&after_end);
000080  a910              ADD      r1,sp,#0x40
000082  4630              MOV      r0,r6
000084  f7fffffe          BL       __hardfp_strtod
;;;315        if (number_c_string == after_end)
000088  9810              LDR      r0,[sp,#0x40]
00008a  eeb08a40          VMOV.F32 s16,s0                ;314
00008e  eef08a60          VMOV.F32 s17,s1                ;314
000092  4286              CMP      r6,r0
000094  d104              BNE      |L86.160|
                  |L86.150|
;;;316        {
;;;317            return false; /* parse_error */
000096  2000              MOVS     r0,#0
                  |L86.152|
;;;318        }
;;;319    
;;;320        item->valuedouble = number;
;;;321    
;;;322        /* use saturation in case of overflow */
;;;323        if (number >= INT_MAX)
;;;324        {
;;;325            item->valueint = INT_MAX;
;;;326        }
;;;327        else if (number <= INT_MIN)
;;;328        {
;;;329            item->valueint = INT_MIN;
;;;330        }
;;;331        else
;;;332        {
;;;333            item->valueint = (int)number;
;;;334        }
;;;335    
;;;336        item->type = cJSON_Number;
;;;337    
;;;338        input_buffer->offset += (size_t)(after_end - number_c_string);
;;;339        return true;
;;;340    }
000098  b011              ADD      sp,sp,#0x44
00009a  ecbd8b02          VPOP     {d8}
00009e  bdf0              POP      {r4-r7,pc}
                  |L86.160|
0000a0  ed9f0b13          VLDR     d0,|L86.240|
0000a4  ed858b06          VSTR     d8,[r5,#0x18]         ;320
0000a8  ec532b10          VMOV     r2,r3,d0              ;323
0000ac  ec510b18          VMOV     r0,r1,d8              ;323
0000b0  f7fffffe          BL       __aeabi_cdrcmple
0000b4  d802              BHI      |L86.188|
0000b6  f06f4000          MVN      r0,#0x80000000        ;325
0000ba  e00f              B        |L86.220|
                  |L86.188|
0000bc  ed9f0b0e          VLDR     d0,|L86.248|
0000c0  ec510b18          VMOV     r0,r1,d8              ;327
0000c4  ec532b10          VMOV     r2,r3,d0              ;327
0000c8  f7fffffe          BL       __aeabi_cdcmple
0000cc  d802              BHI      |L86.212|
0000ce  f04f4000          MOV      r0,#0x80000000        ;329
0000d2  e003              B        |L86.220|
                  |L86.212|
0000d4  ec510b18          VMOV     r0,r1,d8              ;333
0000d8  f7fffffe          BL       __aeabi_d2iz
                  |L86.220|
0000dc  6168              STR      r0,[r5,#0x14]         ;336
0000de  2008              MOVS     r0,#8                 ;336
0000e0  60e8              STR      r0,[r5,#0xc]          ;338
0000e2  9910              LDR      r1,[sp,#0x40]         ;338
0000e4  68a0              LDR      r0,[r4,#8]            ;338
0000e6  1b89              SUBS     r1,r1,r6              ;338
0000e8  4408              ADD      r0,r0,r1              ;338
0000ea  60a0              STR      r0,[r4,#8]            ;339
0000ec  2001              MOVS     r0,#1                 ;339
0000ee  e7d3              B        |L86.152|
;;;341    
                          ENDP

                  |L86.240|
0000f0  ffc00000          DCFD     0x41dfffffffc00000 ; 2147483647
0000f4  41dfffff
                  |L86.248|
0000f8  00000000          DCFD     0xc1e0000000000000 ; -2147483648
0000fc  c1e00000

                          AREA ||i.parse_object||, CODE, READONLY, ALIGN=1

                  parse_object PROC
;;;1496   /* Build an object from the text. */
;;;1497   static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1498   {
000004  4607              MOV      r7,r0
;;;1499       cJSON *head = NULL; /* linked list head */
000006  2600              MOVS     r6,#0
;;;1500       cJSON *current_item = NULL;
;;;1501   
;;;1502       if (input_buffer->depth >= CJSON_NESTING_LIMIT)
000008  68c8              LDR      r0,[r1,#0xc]
00000a  460c              MOV      r4,r1                 ;1498
00000c  4635              MOV      r5,r6                 ;1500
00000e  f5b07f7a          CMP      r0,#0x3e8
000012  d276              BCS      |L87.258|
000014  1c40              ADDS     r0,r0,#1              ;1498
;;;1503       {
;;;1504           return false; /* to deeply nested */
;;;1505       }
;;;1506       input_buffer->depth++;
;;;1507   
;;;1508       if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '{'))
000016  60e0              STR      r0,[r4,#0xc]
000018  2c00              CMP      r4,#0
00001a  d072              BEQ      |L87.258|
00001c  e9d41001          LDRD     r1,r0,[r4,#4]
000020  4288              CMP      r0,r1
000022  d26e              BCS      |L87.258|
000024  6821              LDR      r1,[r4,#0]
000026  5c09              LDRB     r1,[r1,r0]
000028  297b              CMP      r1,#0x7b
00002a  d16a              BNE      |L87.258|
00002c  1c40              ADDS     r0,r0,#1
;;;1509       {
;;;1510           goto fail; /* not an object */
;;;1511       }
;;;1512   
;;;1513       input_buffer->offset++;
;;;1514       buffer_skip_whitespace(input_buffer);
00002e  60a0              STR      r0,[r4,#8]
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       buffer_skip_whitespace
000036  e9d41001          LDRD     r1,r0,[r4,#4]
;;;1515       if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '}'))
00003a  4288              CMP      r0,r1
00003c  d203              BCS      |L87.70|
00003e  6822              LDR      r2,[r4,#0]
000040  5c12              LDRB     r2,[r2,r0]
000042  2a7d              CMP      r2,#0x7d
000044  d04c              BEQ      |L87.224|
                  |L87.70|
;;;1516       {
;;;1517           goto success; /* empty object */
;;;1518       }
;;;1519   
;;;1520       /* check if we skipped to the end of the buffer */
;;;1521       if (cannot_access_at_index(input_buffer, 0))
000046  4288              CMP      r0,r1
000048  f1a00001          SUB      r0,r0,#1
00004c  60a0              STR      r0,[r4,#8]
00004e  d258              BCS      |L87.258|
;;;1522       {
;;;1523           input_buffer->offset--;
;;;1524           goto fail;
;;;1525       }
;;;1526   
;;;1527       /* step back to character in front of the first element */
;;;1528       input_buffer->offset--;
;;;1529       /* loop through the comma separated array elements */
;;;1530       do
;;;1531       {
;;;1532           /* allocate next item */
;;;1533           cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
000050  f1040810          ADD      r8,r4,#0x10
                  |L87.84|
000054  4640              MOV      r0,r8
000056  f7fffffe          BL       cJSON_New_Item
;;;1534           if (new_item == NULL)
00005a  b3e8              CBZ      r0,|L87.216|
;;;1535           {
;;;1536               goto fail; /* allocation failure */
;;;1537           }
;;;1538   
;;;1539           /* attach next item to list */
;;;1540           if (head == NULL)
00005c  b1f6              CBZ      r6,|L87.156|
;;;1541           {
;;;1542               /* start the linked list */
;;;1543               current_item = head = new_item;
;;;1544           }
;;;1545           else
;;;1546           {
;;;1547               /* add to the end and advance */
;;;1548               current_item->next = new_item;
;;;1549               new_item->prev = current_item;
00005e  6028              STR      r0,[r5,#0]
;;;1550               current_item = new_item;
000060  6045              STR      r5,[r0,#4]
000062  4605              MOV      r5,r0
                  |L87.100|
;;;1551           }
;;;1552   
;;;1553           /* parse the name of the child */
;;;1554           input_buffer->offset++;
000064  68a0              LDR      r0,[r4,#8]
000066  1c40              ADDS     r0,r0,#1
;;;1555           buffer_skip_whitespace(input_buffer);
000068  60a0              STR      r0,[r4,#8]
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       buffer_skip_whitespace
;;;1556           if (!parse_string(current_item, input_buffer))
000070  4621              MOV      r1,r4
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       parse_string
000078  b378              CBZ      r0,|L87.218|
;;;1557           {
;;;1558               goto fail; /* faile to parse name */
;;;1559           }
;;;1560           buffer_skip_whitespace(input_buffer);
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       buffer_skip_whitespace
;;;1561   
;;;1562           /* swap valuestring and string, because we parsed the name */
;;;1563           current_item->string = current_item->valuestring;
000080  6928              LDR      r0,[r5,#0x10]
;;;1564           current_item->valuestring = NULL;
000082  6228              STR      r0,[r5,#0x20]
000084  2000              MOVS     r0,#0
;;;1565   
;;;1566           if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != ':'))
000086  6128              STR      r0,[r5,#0x10]
000088  b33c              CBZ      r4,|L87.218|
00008a  e9d41001          LDRD     r1,r0,[r4,#4]
00008e  4288              CMP      r0,r1
000090  d234              BCS      |L87.252|
000092  6821              LDR      r1,[r4,#0]
000094  5c09              LDRB     r1,[r1,r0]
000096  293a              CMP      r1,#0x3a
000098  d130              BNE      |L87.252|
00009a  e002              B        |L87.162|
                  |L87.156|
00009c  4606              MOV      r6,r0                 ;1543
00009e  4635              MOV      r5,r6                 ;1543
0000a0  e7e0              B        |L87.100|
                  |L87.162|
0000a2  1c40              ADDS     r0,r0,#1              ;1543
;;;1567           {
;;;1568               goto fail; /* invalid object */
;;;1569           }
;;;1570   
;;;1571           /* parse the value */
;;;1572           input_buffer->offset++;
;;;1573           buffer_skip_whitespace(input_buffer);
0000a4  60a0              STR      r0,[r4,#8]
0000a6  4620              MOV      r0,r4
0000a8  f7fffffe          BL       buffer_skip_whitespace
;;;1574           if (!parse_value(current_item, input_buffer))
0000ac  4621              MOV      r1,r4
0000ae  4628              MOV      r0,r5
0000b0  f7fffffe          BL       parse_value
0000b4  b188              CBZ      r0,|L87.218|
;;;1575           {
;;;1576               goto fail; /* failed to parse value */
;;;1577           }
;;;1578           buffer_skip_whitespace(input_buffer);
0000b6  4620              MOV      r0,r4
0000b8  f7fffffe          BL       buffer_skip_whitespace
0000bc  e9d41001          LDRD     r1,r0,[r4,#4]
;;;1579       }
;;;1580       while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));
0000c0  4288              CMP      r0,r1
0000c2  d203              BCS      |L87.204|
0000c4  6821              LDR      r1,[r4,#0]
0000c6  5c09              LDRB     r1,[r1,r0]
0000c8  292c              CMP      r1,#0x2c
0000ca  d0c3              BEQ      |L87.84|
                  |L87.204|
;;;1581   
;;;1582       if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '}'))
0000cc  6862              LDR      r2,[r4,#4]
0000ce  4290              CMP      r0,r2
0000d0  d214              BCS      |L87.252|
0000d2  6821              LDR      r1,[r4,#0]
0000d4  5c08              LDRB     r0,[r1,r0]
0000d6  e001              B        |L87.220|
                  |L87.216|
0000d8  e00f              B        |L87.250|
                  |L87.218|
0000da  e00f              B        |L87.252|
                  |L87.220|
0000dc  287d              CMP      r0,#0x7d
0000de  d10d              BNE      |L87.252|
                  |L87.224|
;;;1583       {
;;;1584           goto fail; /* expected end of object */
;;;1585       }
;;;1586   
;;;1587   success:
;;;1588       input_buffer->depth--;
0000e0  68e0              LDR      r0,[r4,#0xc]
0000e2  1e40              SUBS     r0,r0,#1
;;;1589   
;;;1590       item->type = cJSON_Object;
0000e4  60e0              STR      r0,[r4,#0xc]
0000e6  2040              MOVS     r0,#0x40
0000e8  e9c76002          STRD     r6,r0,[r7,#8]
;;;1591       item->child = head;
;;;1592   
;;;1593       input_buffer->offset++;
0000ec  68a0              LDR      r0,[r4,#8]
0000ee  1c40              ADDS     r0,r0,#1
;;;1594       return true;
0000f0  60a0              STR      r0,[r4,#8]
0000f2  2001              MOVS     r0,#1
                  |L87.244|
;;;1595   
;;;1596   fail:
;;;1597       if (head != NULL)
;;;1598       {
;;;1599           cJSON_Delete(head);
;;;1600       }
;;;1601   
;;;1602       return false;
;;;1603   }
0000f4  e8bd81f0          POP      {r4-r8,pc}
0000f8  e003              B        |L87.258|
                  |L87.250|
0000fa  b116              CBZ      r6,|L87.258|
                  |L87.252|
0000fc  4630              MOV      r0,r6                 ;1599
0000fe  f7fffffe          BL       cJSON_Delete
                  |L87.258|
000102  2000              MOVS     r0,#0                 ;1602
000104  e7f6              B        |L87.244|
;;;1604   
                          ENDP


                          AREA ||i.parse_string||, CODE, READONLY, ALIGN=1

                  parse_string PROC
;;;697    /* Parse the input text into an unescaped cinput, and populate item. */
;;;698    static cJSON_bool parse_string(cJSON * const item, parse_buffer * const input_buffer)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;699    {
000004  4681              MOV      r9,r0
;;;700        const unsigned char *input_pointer = buffer_at_offset(input_buffer) + 1;
000006  f8d18008          LDR      r8,[r1,#8]
00000a  6808              LDR      r0,[r1,#0]
;;;701        const unsigned char *input_end = buffer_at_offset(input_buffer) + 1;
;;;702        unsigned char *output_pointer = NULL;
00000c  f04f0a00          MOV      r10,#0
;;;703        unsigned char *output = NULL;
;;;704    
;;;705        /* not a string */
;;;706        if (buffer_at_offset(input_buffer)[0] != '\"')
000010  f8cda000          STR      r10,[sp,#0]
000014  f8d1c000          LDR      r12,[r1,#0]
000018  eb000408          ADD      r4,r0,r8              ;700
00001c  1c65              ADDS     r5,r4,#1              ;700
00001e  f81c0008          LDRB     r0,[r12,r8]
000022  1c64              ADDS     r4,r4,#1
000024  460e              MOV      r6,r1                 ;699
000026  4657              MOV      r7,r10                ;703
000028  2822              CMP      r0,#0x22
00002a  d176              BNE      |L88.282|
;;;707        {
;;;708            goto fail;
;;;709        }
;;;710    
;;;711        {
;;;712            /* calculate approximate size of the output (overestimate) */
;;;713            size_t allocation_length = 0;
;;;714            size_t skipped_bytes = 0;
00002c  2100              MOVS     r1,#0
;;;715            while (((size_t)(input_end - input_buffer->content) < input_buffer->length) && (*input_end != '\"'))
00002e  6870              LDR      r0,[r6,#4]
000030  e007              B        |L88.66|
                  |L88.50|
;;;716            {
;;;717                /* is escape sequence */
;;;718                if (input_end[0] == '\\')
000032  2b5c              CMP      r3,#0x5c
000034  d104              BNE      |L88.64|
000036  1c52              ADDS     r2,r2,#1
;;;719                {
;;;720                    if ((size_t)(input_end + 1 - input_buffer->content) >= input_buffer->length)
000038  4282              CMP      r2,r0
00003a  d26a              BCS      |L88.274|
00003c  1c49              ADDS     r1,r1,#1
00003e  1c64              ADDS     r4,r4,#1
                  |L88.64|
000040  1c64              ADDS     r4,r4,#1
                  |L88.66|
000042  eba4020c          SUB      r2,r4,r12             ;715
000046  4282              CMP      r2,r0                 ;715
000048  d202              BCS      |L88.80|
00004a  7823              LDRB     r3,[r4,#0]            ;715
00004c  2b22              CMP      r3,#0x22              ;715
00004e  d1f0              BNE      |L88.50|
                  |L88.80|
;;;721                    {
;;;722                        /* prevent buffer overflow when last input character is a backslash */
;;;723                        goto fail;
;;;724                    }
;;;725                    skipped_bytes++;
;;;726                    input_end++;
;;;727                }
;;;728                input_end++;
;;;729            }
;;;730            if (((size_t)(input_end - input_buffer->content) >= input_buffer->length) || (*input_end != '\"'))
000050  eba4020c          SUB      r2,r4,r12
000054  4282              CMP      r2,r0
000056  d25c              BCS      |L88.274|
000058  7820              LDRB     r0,[r4,#0]
00005a  2822              CMP      r0,#0x22
00005c  d159              BNE      |L88.274|
;;;731            {
;;;732                goto fail; /* string ended unexpectedly */
;;;733            }
;;;734    
;;;735            /* This is at most how much we need for the output */
;;;736            allocation_length = (size_t) (input_end - buffer_at_offset(input_buffer)) - skipped_bytes;
00005e  eb0c0008          ADD      r0,r12,r8
000062  1a20              SUBS     r0,r4,r0
000064  1a40              SUBS     r0,r0,r1
;;;737            output = (unsigned char*)input_buffer->hooks.allocate(allocation_length + sizeof(""));
000066  6931              LDR      r1,[r6,#0x10]
000068  1c40              ADDS     r0,r0,#1
00006a  4788              BLX      r1
00006c  0007              MOVS     r7,r0
;;;738            if (output == NULL)
00006e  d054              BEQ      |L88.282|
;;;739            {
;;;740                goto fail; /* allocation failure */
;;;741            }
;;;742        }
;;;743    
;;;744        output_pointer = output;
;;;745        /* loop through the string literal */
;;;746        while (input_pointer < input_end)
000070  9700              STR      r7,[sp,#0]
000072  e03d              B        |L88.240|
                  |L88.116|
;;;747        {
;;;748            if (*input_pointer != '\\')
000074  7829              LDRB     r1,[r5,#0]
000076  295c              CMP      r1,#0x5c
000078  d005              BEQ      |L88.134|
;;;749            {
;;;750                *output_pointer++ = *input_pointer++;
00007a  9800              LDR      r0,[sp,#0]
00007c  1c6d              ADDS     r5,r5,#1
00007e  f8001b01          STRB     r1,[r0],#1
000082  9000              STR      r0,[sp,#0]
000084  e034              B        |L88.240|
                  |L88.134|
;;;751            }
;;;752            /* escape sequence */
;;;753            else
;;;754            {
;;;755                unsigned char sequence_length = 2;
000086  2102              MOVS     r1,#2
;;;756                if ((input_end - input_pointer) < 1)
000088  1b60              SUBS     r0,r4,r5
00008a  2801              CMP      r0,#1
00008c  db41              BLT      |L88.274|
;;;757                {
;;;758                    goto fail;
;;;759                }
;;;760    
;;;761                switch (input_pointer[1])
00008e  7868              LDRB     r0,[r5,#1]
000090  2866              CMP      r0,#0x66
000092  d014              BEQ      |L88.190|
000094  dc08              BGT      |L88.168|
000096  2822              CMP      r0,#0x22
000098  d01d              BEQ      |L88.214|
00009a  282f              CMP      r0,#0x2f
00009c  d01b              BEQ      |L88.214|
00009e  285c              CMP      r0,#0x5c
0000a0  d019              BEQ      |L88.214|
0000a2  2862              CMP      r0,#0x62
0000a4  d135              BNE      |L88.274|
0000a6  e008              B        |L88.186|
                  |L88.168|
0000a8  286e              CMP      r0,#0x6e
0000aa  d00e              BEQ      |L88.202|
0000ac  2872              CMP      r0,#0x72
0000ae  d00e              BEQ      |L88.206|
0000b0  2874              CMP      r0,#0x74
0000b2  d00e              BEQ      |L88.210|
0000b4  2875              CMP      r0,#0x75
0000b6  d12c              BNE      |L88.274|
0000b8  e012              B        |L88.224|
                  |L88.186|
;;;762                {
;;;763                    case 'b':
;;;764                        *output_pointer++ = '\b';
0000ba  2208              MOVS     r2,#8
;;;765                        break;
0000bc  e000              B        |L88.192|
                  |L88.190|
;;;766                    case 'f':
;;;767                        *output_pointer++ = '\f';
0000be  220c              MOVS     r2,#0xc
                  |L88.192|
0000c0  9800              LDR      r0,[sp,#0]            ;764
0000c2  f8002b01          STRB     r2,[r0],#1            ;764
0000c6  9000              STR      r0,[sp,#0]            ;764
0000c8  e011              B        |L88.238|
                  |L88.202|
;;;768                        break;
;;;769                    case 'n':
;;;770                        *output_pointer++ = '\n';
0000ca  220a              MOVS     r2,#0xa
;;;771                        break;
0000cc  e7f8              B        |L88.192|
                  |L88.206|
;;;772                    case 'r':
;;;773                        *output_pointer++ = '\r';
0000ce  220d              MOVS     r2,#0xd
;;;774                        break;
0000d0  e7f6              B        |L88.192|
                  |L88.210|
;;;775                    case 't':
;;;776                        *output_pointer++ = '\t';
0000d2  2209              MOVS     r2,#9
;;;777                        break;
0000d4  e7f4              B        |L88.192|
                  |L88.214|
;;;778                    case '\"':
;;;779                    case '\\':
;;;780                    case '/':
;;;781                        *output_pointer++ = input_pointer[1];
0000d6  9a00              LDR      r2,[sp,#0]
0000d8  f8020b01          STRB     r0,[r2],#1
;;;782                        break;
0000dc  9200              STR      r2,[sp,#0]
0000de  e006              B        |L88.238|
                  |L88.224|
;;;783    
;;;784                    /* UTF-16 literal */
;;;785                    case 'u':
;;;786                        sequence_length = utf16_literal_to_utf8(input_pointer, input_end, &output_pointer);
0000e0  466a              MOV      r2,sp
0000e2  4621              MOV      r1,r4
0000e4  4628              MOV      r0,r5
0000e6  f7fffffe          BL       utf16_literal_to_utf8
0000ea  0001              MOVS     r1,r0
;;;787                        if (sequence_length == 0)
0000ec  d011              BEQ      |L88.274|
                  |L88.238|
;;;788                        {
;;;789                            /* failed to convert UTF16-literal to UTF-8 */
;;;790                            goto fail;
;;;791                        }
;;;792                        break;
;;;793    
;;;794                    default:
;;;795                        goto fail;
;;;796                }
;;;797                input_pointer += sequence_length;
0000ee  440d              ADD      r5,r5,r1
                  |L88.240|
0000f0  42a5              CMP      r5,r4                 ;746
0000f2  d3bf              BCC      |L88.116|
;;;798            }
;;;799        }
;;;800    
;;;801        /* zero terminate the output */
;;;802        *output_pointer = '\0';
0000f4  9900              LDR      r1,[sp,#0]
0000f6  f881a000          STRB     r10,[r1,#0]
;;;803    
;;;804        item->type = cJSON_String;
0000fa  2110              MOVS     r1,#0x10
0000fc  e9c91703          STRD     r1,r7,[r9,#0xc]
;;;805        item->valuestring = (char*)output;
;;;806    
;;;807        input_buffer->offset = (size_t) (input_end - input_buffer->content);
000100  6830              LDR      r0,[r6,#0]
000102  1a20              SUBS     r0,r4,r0
000104  1c40              ADDS     r0,r0,#1
;;;808        input_buffer->offset++;
;;;809    
;;;810        return true;
000106  60b0              STR      r0,[r6,#8]
000108  2001              MOVS     r0,#1
                  |L88.266|
;;;811    
;;;812    fail:
;;;813        if (output != NULL)
;;;814        {
;;;815            input_buffer->hooks.deallocate(output);
;;;816        }
;;;817    
;;;818        if (input_pointer != NULL)
;;;819        {
;;;820            input_buffer->offset = (size_t)(input_pointer - input_buffer->content);
;;;821        }
;;;822    
;;;823        return false;
;;;824    }
00010a  e8bd8ff8          POP      {r3-r11,pc}
00010e  e004              B        |L88.282|
000110  e7ff              B        |L88.274|
                  |L88.274|
000112  b117              CBZ      r7,|L88.282|
000114  6971              LDR      r1,[r6,#0x14]         ;815
000116  4638              MOV      r0,r7                 ;815
000118  4788              BLX      r1                    ;815
                  |L88.282|
00011a  b115              CBZ      r5,|L88.290|
00011c  6830              LDR      r0,[r6,#0]            ;820
00011e  1a28              SUBS     r0,r5,r0              ;820
000120  60b0              STR      r0,[r6,#8]            ;820
                  |L88.290|
000122  2000              MOVS     r0,#0                 ;823
000124  e7f1              B        |L88.266|
;;;825    
                          ENDP


                          AREA ||i.parse_value||, CODE, READONLY, ALIGN=2

                  parse_value PROC
;;;1211   /* Parser core - when encountering text, process appropriately. */
;;;1212   static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer)
000000  b570              PUSH     {r4-r6,lr}
;;;1213   {
000002  000c              MOVS     r4,r1
000004  4605              MOV      r5,r0
000006  d05e              BEQ      |L89.198|
;;;1214       if ((input_buffer == NULL) || (input_buffer->content == NULL))
000008  6821              LDR      r1,[r4,#0]
00000a  2900              CMP      r1,#0
00000c  d05b              BEQ      |L89.198|
;;;1215       {
;;;1216           return false; /* no input */
;;;1217       }
;;;1218   
;;;1219       /* parse the different types of values */
;;;1220       /* null */
;;;1221       if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "null", 4) == 0))
00000e  68a0              LDR      r0,[r4,#8]
000010  6863              LDR      r3,[r4,#4]
000012  1d02              ADDS     r2,r0,#4
000014  429a              CMP      r2,r3
000016  d805              BHI      |L89.36|
000018  4408              ADD      r0,r0,r1
00001a  2204              MOVS     r2,#4
00001c  a131              ADR      r1,|L89.228|
00001e  f7fffffe          BL       strncmp
000022  b378              CBZ      r0,|L89.132|
                  |L89.36|
;;;1222       {
;;;1223           item->type = cJSON_NULL;
;;;1224           input_buffer->offset += 4;
;;;1225           return true;
;;;1226       }
;;;1227       /* false */
;;;1228       if (can_read(input_buffer, 5) && (strncmp((const char*)buffer_at_offset(input_buffer), "false", 5) == 0))
000024  68a0              LDR      r0,[r4,#8]
000026  6862              LDR      r2,[r4,#4]
000028  1d41              ADDS     r1,r0,#5
00002a  2601              MOVS     r6,#1                 ;1225
00002c  4291              CMP      r1,r2
00002e  d806              BHI      |L89.62|
000030  6821              LDR      r1,[r4,#0]
000032  2205              MOVS     r2,#5
000034  4408              ADD      r0,r0,r1
000036  a12d              ADR      r1,|L89.236|
000038  f7fffffe          BL       strncmp
00003c  b328              CBZ      r0,|L89.138|
                  |L89.62|
;;;1229       {
;;;1230           item->type = cJSON_False;
;;;1231           input_buffer->offset += 5;
;;;1232           return true;
;;;1233       }
;;;1234       /* true */
;;;1235       if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "true", 4) == 0))
00003e  68a0              LDR      r0,[r4,#8]
000040  6862              LDR      r2,[r4,#4]
000042  1d01              ADDS     r1,r0,#4
000044  4291              CMP      r1,r2
000046  d806              BHI      |L89.86|
000048  6821              LDR      r1,[r4,#0]
00004a  2204              MOVS     r2,#4
00004c  4408              ADD      r0,r0,r1
00004e  a129              ADR      r1,|L89.244|
000050  f7fffffe          BL       strncmp
000054  b1e8              CBZ      r0,|L89.146|
                  |L89.86|
000056  e9d40101          LDRD     r0,r1,[r4,#4]
;;;1236       {
;;;1237           item->type = cJSON_True;
;;;1238           item->valueint = 1;
;;;1239           input_buffer->offset += 4;
;;;1240           return true;
;;;1241       }
;;;1242       /* string */
;;;1243       if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '\"'))
00005a  4281              CMP      r1,r0
00005c  d203              BCS      |L89.102|
00005e  6822              LDR      r2,[r4,#0]
000060  5c52              LDRB     r2,[r2,r1]
000062  2a22              CMP      r2,#0x22
000064  d01d              BEQ      |L89.162|
                  |L89.102|
;;;1244       {
;;;1245           return parse_string(item, input_buffer);
;;;1246       }
;;;1247       /* number */
;;;1248       if (can_access_at_index(input_buffer, 0) && ((buffer_at_offset(input_buffer)[0] == '-') || ((buffer_at_offset(input_buffer)[0] >= '0') && (buffer_at_offset(input_buffer)[0] <= '9'))))
000066  4281              CMP      r1,r0
000068  d221              BCS      |L89.174|
00006a  6822              LDR      r2,[r4,#0]
00006c  5c52              LDRB     r2,[r2,r1]
00006e  2a2d              CMP      r2,#0x2d
000070  d002              BEQ      |L89.120|
000072  3a30              SUBS     r2,r2,#0x30
000074  2a09              CMP      r2,#9
000076  d81a              BHI      |L89.174|
                  |L89.120|
;;;1249       {
;;;1250           return parse_number(item, input_buffer);
000078  4621              MOV      r1,r4
00007a  4628              MOV      r0,r5
00007c  e8bd4070          POP      {r4-r6,lr}
000080  f7ffbffe          B.W      parse_number
                  |L89.132|
000084  2004              MOVS     r0,#4                 ;1223
000086  60e8              STR      r0,[r5,#0xc]          ;1225
000088  e006              B        |L89.152|
                  |L89.138|
00008a  60ee              STR      r6,[r5,#0xc]          ;1231
00008c  68a0              LDR      r0,[r4,#8]            ;1231
00008e  1d40              ADDS     r0,r0,#5              ;1231
000090  e004              B        |L89.156|
                  |L89.146|
000092  2002              MOVS     r0,#2                 ;1237
000094  616e              STR      r6,[r5,#0x14]         ;1238
000096  60e8              STR      r0,[r5,#0xc]          ;1238
                  |L89.152|
000098  68a0              LDR      r0,[r4,#8]            ;1224
00009a  1d00              ADDS     r0,r0,#4              ;1224
                  |L89.156|
00009c  60a0              STR      r0,[r4,#8]            ;1240
00009e  2001              MOVS     r0,#1                 ;1240
;;;1251       }
;;;1252       /* array */
;;;1253       if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '['))
;;;1254       {
;;;1255           return parse_array(item, input_buffer);
;;;1256       }
;;;1257       /* object */
;;;1258       if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '{'))
;;;1259       {
;;;1260           return parse_object(item, input_buffer);
;;;1261       }
;;;1262   
;;;1263       return false;
;;;1264   }
0000a0  bd70              POP      {r4-r6,pc}
                  |L89.162|
0000a2  4621              MOV      r1,r4                 ;1245
0000a4  4628              MOV      r0,r5                 ;1245
0000a6  e8bd4070          POP      {r4-r6,lr}            ;1245
0000aa  f7ffbffe          B.W      parse_string
                  |L89.174|
0000ae  4281              CMP      r1,r0                 ;1253
0000b0  d203              BCS      |L89.186|
0000b2  6822              LDR      r2,[r4,#0]            ;1253
0000b4  5c52              LDRB     r2,[r2,r1]            ;1253
0000b6  2a5b              CMP      r2,#0x5b              ;1253
0000b8  d007              BEQ      |L89.202|
                  |L89.186|
0000ba  4281              CMP      r1,r0                 ;1258
0000bc  d203              BCS      |L89.198|
0000be  6820              LDR      r0,[r4,#0]            ;1258
0000c0  5c40              LDRB     r0,[r0,r1]            ;1258
0000c2  287b              CMP      r0,#0x7b              ;1258
0000c4  d007              BEQ      |L89.214|
                  |L89.198|
0000c6  2000              MOVS     r0,#0                 ;1263
0000c8  bd70              POP      {r4-r6,pc}
                  |L89.202|
0000ca  4621              MOV      r1,r4                 ;1255
0000cc  4628              MOV      r0,r5                 ;1255
0000ce  e8bd4070          POP      {r4-r6,lr}            ;1255
0000d2  f7ffbffe          B.W      parse_array
                  |L89.214|
0000d6  4621              MOV      r1,r4                 ;1260
0000d8  4628              MOV      r0,r5                 ;1260
0000da  e8bd4070          POP      {r4-r6,lr}            ;1260
0000de  f7ffbffe          B.W      parse_object
;;;1265   
                          ENDP

0000e2  0000              DCW      0x0000
                  |L89.228|
0000e4  6e756c6c          DCB      "null",0
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L89.236|
0000ec  66616c73          DCB      "false",0
0000f0  6500    
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L89.244|
0000f4  74727565          DCB      "true",0
0000f8  00      
0000f9  00                DCB      0
0000fa  00                DCB      0
0000fb  00                DCB      0

                          AREA ||i.print||, CODE, READONLY, ALIGN=1

                  print PROC
;;;1086   
;;;1087   static unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1088   {
000002  b089              SUB      sp,sp,#0x24
000004  460f              MOV      r7,r1
000006  4606              MOV      r6,r0
000008  4614              MOV      r4,r2
;;;1089       static const size_t default_buffer_size = 256;
;;;1090       printbuffer buffer[1];
;;;1091       unsigned char *printed = NULL;
;;;1092   
;;;1093       memset(buffer, 0, sizeof(buffer));
00000a  2124              MOVS     r1,#0x24
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memclr4
;;;1094   
;;;1095       /* create buffer */
;;;1096       buffer->buffer = (unsigned char*) hooks->allocate(default_buffer_size);
000012  f44f7580          MOV      r5,#0x100
000016  6821              LDR      r1,[r4,#0]
000018  4628              MOV      r0,r5
00001a  4788              BLX      r1
;;;1097       buffer->length = default_buffer_size;
;;;1098       buffer->format = format;
00001c  9705              STR      r7,[sp,#0x14]
00001e  e9cd0500          STRD     r0,r5,[sp,#0]
000022  e8940007          LDM      r4,{r0-r2}
000026  ab06              ADD      r3,sp,#0x18
000028  e8830007          STM      r3,{r0-r2}
;;;1099       buffer->hooks = *hooks;
;;;1100       if (buffer->buffer == NULL)
00002c  9800              LDR      r0,[sp,#0]
00002e  b388              CBZ      r0,|L90.148|
;;;1101       {
;;;1102           goto fail;
;;;1103       }
;;;1104   
;;;1105       /* print the value */
;;;1106       if (!print_value(item, buffer))
000030  4669              MOV      r1,sp
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       print_value
000038  b340              CBZ      r0,|L90.140|
;;;1107       {
;;;1108           goto fail;
;;;1109       }
;;;1110       update_offset(buffer);
00003a  4668              MOV      r0,sp
00003c  f7fffffe          BL       update_offset
;;;1111   
;;;1112       /* check if reallocate is available */
;;;1113       if (hooks->reallocate != NULL)
000040  68a2              LDR      r2,[r4,#8]
000042  2600              MOVS     r6,#0
000044  b13a              CBZ      r2,|L90.86|
;;;1114       {
;;;1115           printed = (unsigned char*) hooks->reallocate(buffer->buffer, buffer->offset + 1);
000046  9902              LDR      r1,[sp,#8]
000048  9800              LDR      r0,[sp,#0]
00004a  1c49              ADDS     r1,r1,#1
00004c  4790              BLX      r2
00004e  0005              MOVS     r5,r0
;;;1116           buffer->buffer = NULL;
;;;1117           if (printed == NULL) {
000050  9600              STR      r6,[sp,#0]
000052  d01f              BEQ      |L90.148|
000054  e017              B        |L90.134|
                  |L90.86|
;;;1118               goto fail;
;;;1119           }
;;;1120       }
;;;1121       else /* otherwise copy the JSON over to a new buffer */
;;;1122       {
;;;1123           printed = (unsigned char*) hooks->allocate(buffer->offset + 1);
000056  9802              LDR      r0,[sp,#8]
000058  6821              LDR      r1,[r4,#0]
00005a  1c40              ADDS     r0,r0,#1
00005c  4788              BLX      r1
00005e  0005              MOVS     r5,r0
;;;1124           if (printed == NULL)
000060  d014              BEQ      |L90.140|
000062  e9dd1001          LDRD     r1,r0,[sp,#4]
000066  1c40              ADDS     r0,r0,#1
;;;1125           {
;;;1126               goto fail;
;;;1127           }
;;;1128           memcpy(printed, buffer->buffer, cjson_min(buffer->length, buffer->offset + 1));
000068  4281              CMP      r1,r0
00006a  d201              BCS      |L90.112|
00006c  460a              MOV      r2,r1
00006e  e001              B        |L90.116|
                  |L90.112|
000070  9a02              LDR      r2,[sp,#8]
000072  1c52              ADDS     r2,r2,#1
                  |L90.116|
000074  4628              MOV      r0,r5
000076  9900              LDR      r1,[sp,#0]
000078  f7fffffe          BL       __aeabi_memcpy
;;;1129           printed[buffer->offset] = '\0'; /* just to be sure */
00007c  9802              LDR      r0,[sp,#8]
00007e  542e              STRB     r6,[r5,r0]
;;;1130   
;;;1131           /* free the buffer */
;;;1132           hooks->deallocate(buffer->buffer);
000080  6861              LDR      r1,[r4,#4]
000082  9800              LDR      r0,[sp,#0]
000084  4788              BLX      r1
                  |L90.134|
;;;1133       }
;;;1134   
;;;1135       return printed;
000086  4628              MOV      r0,r5
                  |L90.136|
;;;1136   
;;;1137   fail:
;;;1138       if (buffer->buffer != NULL)
;;;1139       {
;;;1140           hooks->deallocate(buffer->buffer);
;;;1141       }
;;;1142   
;;;1143       if (printed != NULL)
;;;1144       {
;;;1145           hooks->deallocate(printed);
;;;1146       }
;;;1147   
;;;1148       return NULL;
;;;1149   }
000088  b009              ADD      sp,sp,#0x24
00008a  bdf0              POP      {r4-r7,pc}
                  |L90.140|
00008c  9800              LDR      r0,[sp,#0]            ;1138
00008e  b108              CBZ      r0,|L90.148|
000090  6861              LDR      r1,[r4,#4]            ;1140
000092  4788              BLX      r1                    ;1140
                  |L90.148|
000094  2000              MOVS     r0,#0                 ;1148
000096  e7f7              B        |L90.136|
;;;1150   
                          ENDP


                          AREA ||i.print_array||, CODE, READONLY, ALIGN=1

                  print_array PROC
;;;1434   /* Render an array to text */
;;;1435   static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1436   {
000004  6885              LDR      r5,[r0,#8]
000006  000c              MOVS     r4,r1
000008  d00f              BEQ      |L91.42|
;;;1437       unsigned char *output_pointer = NULL;
;;;1438       size_t length = 0;
;;;1439       cJSON *current_element = item->child;
;;;1440   
;;;1441       if (output_buffer == NULL)
;;;1442       {
;;;1443           return false;
;;;1444       }
;;;1445   
;;;1446       /* Compose the output array. */
;;;1447       /* opening square bracket */
;;;1448       output_pointer = ensure(output_buffer, 1);
00000a  2101              MOVS     r1,#1
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       ensure
;;;1449       if (output_pointer == NULL)
000012  2800              CMP      r0,#0
000014  d00a              BEQ      |L91.44|
;;;1450       {
;;;1451           return false;
;;;1452       }
;;;1453   
;;;1454       *output_pointer = '[';
000016  215b              MOVS     r1,#0x5b
000018  7001              STRB     r1,[r0,#0]
;;;1455       output_buffer->offset++;
00001a  68a0              LDR      r0,[r4,#8]
00001c  1c40              ADDS     r0,r0,#1
;;;1456       output_buffer->depth++;
00001e  60a0              STR      r0,[r4,#8]
000020  68e0              LDR      r0,[r4,#0xc]
000022  1c40              ADDS     r0,r0,#1
000024  2700              MOVS     r7,#0
;;;1457   
;;;1458       while (current_element != NULL)
000026  60e0              STR      r0,[r4,#0xc]
000028  e025              B        |L91.118|
                  |L91.42|
00002a  2000              MOVS     r0,#0                 ;1443
                  |L91.44|
;;;1459       {
;;;1460           if (!print_value(current_element, output_buffer))
;;;1461           {
;;;1462               return false;
;;;1463           }
;;;1464           update_offset(output_buffer);
;;;1465           if (current_element->next)
;;;1466           {
;;;1467               length = (size_t) (output_buffer->format ? 2 : 1);
;;;1468               output_pointer = ensure(output_buffer, length + 1);
;;;1469               if (output_pointer == NULL)
;;;1470               {
;;;1471                   return false;
;;;1472               }
;;;1473               *output_pointer++ = ',';
;;;1474               if(output_buffer->format)
;;;1475               {
;;;1476                   *output_pointer++ = ' ';
;;;1477               }
;;;1478               *output_pointer = '\0';
;;;1479               output_buffer->offset += length;
;;;1480           }
;;;1481           current_element = current_element->next;
;;;1482       }
;;;1483   
;;;1484       output_pointer = ensure(output_buffer, 2);
;;;1485       if (output_pointer == NULL)
;;;1486       {
;;;1487           return false;
;;;1488       }
;;;1489       *output_pointer++ = ']';
;;;1490       *output_pointer = '\0';
;;;1491       output_buffer->depth--;
;;;1492   
;;;1493       return true;
;;;1494   }
00002c  e8bd81f0          POP      {r4-r8,pc}
                  |L91.48|
000030  4621              MOV      r1,r4                 ;1460
000032  4628              MOV      r0,r5                 ;1460
000034  f7fffffe          BL       print_value
000038  2800              CMP      r0,#0                 ;1460
00003a  d0f7              BEQ      |L91.44|
00003c  4620              MOV      r0,r4                 ;1464
00003e  f7fffffe          BL       update_offset
000042  6828              LDR      r0,[r5,#0]            ;1465
000044  b1b0              CBZ      r0,|L91.116|
000046  6960              LDR      r0,[r4,#0x14]         ;1467
000048  b108              CBZ      r0,|L91.78|
00004a  2602              MOVS     r6,#2                 ;1467
00004c  e000              B        |L91.80|
                  |L91.78|
00004e  2601              MOVS     r6,#1                 ;1467
                  |L91.80|
000050  1c71              ADDS     r1,r6,#1              ;1468
000052  4620              MOV      r0,r4                 ;1468
000054  f7fffffe          BL       ensure
000058  2800              CMP      r0,#0                 ;1469
00005a  d0e7              BEQ      |L91.44|
00005c  212c              MOVS     r1,#0x2c              ;1473
00005e  f8001b01          STRB     r1,[r0],#1            ;1473
000062  6961              LDR      r1,[r4,#0x14]         ;1474
000064  b111              CBZ      r1,|L91.108|
000066  2120              MOVS     r1,#0x20              ;1476
000068  f8001b01          STRB     r1,[r0],#1            ;1476
                  |L91.108|
00006c  7007              STRB     r7,[r0,#0]            ;1478
00006e  68a0              LDR      r0,[r4,#8]            ;1479
000070  4430              ADD      r0,r0,r6              ;1479
000072  60a0              STR      r0,[r4,#8]            ;1479
                  |L91.116|
000074  682d              LDR      r5,[r5,#0]            ;1481
                  |L91.118|
000076  2d00              CMP      r5,#0                 ;1458
000078  d1da              BNE      |L91.48|
00007a  2102              MOVS     r1,#2                 ;1484
00007c  4620              MOV      r0,r4                 ;1484
00007e  f7fffffe          BL       ensure
000082  2800              CMP      r0,#0                 ;1485
000084  d0d2              BEQ      |L91.44|
000086  215d              MOVS     r1,#0x5d              ;1489
000088  7001              STRB     r1,[r0,#0]            ;1489
00008a  7047              STRB     r7,[r0,#1]            ;1490
00008c  68e0              LDR      r0,[r4,#0xc]          ;1491
00008e  1e40              SUBS     r0,r0,#1              ;1491
000090  60e0              STR      r0,[r4,#0xc]          ;1493
000092  2001              MOVS     r0,#1                 ;1493
000094  e7ca              B        |L91.44|
;;;1495   
                          ENDP


                          AREA ||i.print_number||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_return_value
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_g
                          REQUIRE _printf_fp_dec
                          REQUIRE _scanf_real
                  print_number PROC
;;;473    /* Render the number nicely from the given item into a string. */
;;;474    static cJSON_bool print_number(const cJSON * const item, printbuffer * const output_buffer)
000000  b5f0              PUSH     {r4-r7,lr}
;;;475    {
000002  ed2d8b02          VPUSH    {d8}
000006  b08b              SUB      sp,sp,#0x2c
;;;476        unsigned char *output_pointer = NULL;
;;;477        double d = item->valuedouble;
000008  ed908b06          VLDR     d8,[r0,#0x18]
00000c  000e              MOVS     r6,r1                 ;475
;;;478        int length = 0;
;;;479        size_t i = 0;
00000e  f04f0400          MOV      r4,#0
000012  f04f072e          MOV      r7,#0x2e
000016  d01f              BEQ      |L92.88|
;;;480        unsigned char number_buffer[26]; /* temporary buffer to print the number into */
;;;481        unsigned char decimal_point = get_decimal_point();
;;;482        double test;
;;;483    
;;;484        if (output_buffer == NULL)
;;;485        {
;;;486            return false;
;;;487        }
;;;488    
;;;489        /* This checks for NaN and Infinity */
;;;490        if ((d * 0) != 0)
;;;491        {
;;;492            length = sprintf((char*)number_buffer, "null");
;;;493        }
;;;494        else
;;;495        {
;;;496            /* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */
;;;497            length = sprintf((char*)number_buffer, "%1.15g", d);
000018  ec532b18          VMOV     r2,r3,d8
00001c  a11d              ADR      r1,|L92.148|
00001e  4668              MOV      r0,sp
000020  f7fffffe          BL       __2sprintf
000024  4605              MOV      r5,r0
;;;498    
;;;499            /* Check whether the original double can be recovered */
;;;500            if ((sscanf((char*)number_buffer, "%lg", &test) != 1) || ((double)test != d))
000026  aa08              ADD      r2,sp,#0x20
000028  a11c              ADR      r1,|L92.156|
00002a  4668              MOV      r0,sp
00002c  f7fffffe          BL       __0sscanf
000030  2801              CMP      r0,#1
000032  d108              BNE      |L92.70|
000034  ed9d0b08          VLDR     d0,[sp,#0x20]
000038  ec532b18          VMOV     r2,r3,d8
00003c  ec510b10          VMOV     r0,r1,d0
000040  f7fffffe          BL       __aeabi_cdcmpeq
000044  d006              BEQ      |L92.84|
                  |L92.70|
;;;501            {
;;;502                /* If not, print with 17 decimal places of precision */
;;;503                length = sprintf((char*)number_buffer, "%1.17g", d);
000046  ec532b18          VMOV     r2,r3,d8
00004a  a115              ADR      r1,|L92.160|
00004c  4668              MOV      r0,sp
00004e  f7fffffe          BL       __2sprintf
000052  4605              MOV      r5,r0
                  |L92.84|
;;;504            }
;;;505        }
;;;506    
;;;507        /* sprintf failed or buffer overrun occured */
;;;508        if ((length < 0) || (length > (int)(sizeof(number_buffer) - 1)))
000054  2d1a              CMP      r5,#0x1a
000056  d304              BCC      |L92.98|
                  |L92.88|
;;;509        {
;;;510            return false;
000058  2000              MOVS     r0,#0
                  |L92.90|
;;;511        }
;;;512    
;;;513        /* reserve appropriate space in the output */
;;;514        output_pointer = ensure(output_buffer, (size_t)length + sizeof(""));
;;;515        if (output_pointer == NULL)
;;;516        {
;;;517            return false;
;;;518        }
;;;519    
;;;520        /* copy the printed number to the output and replace locale
;;;521         * dependent decimal point with '.' */
;;;522        for (i = 0; i < ((size_t)length); i++)
;;;523        {
;;;524            if (number_buffer[i] == decimal_point)
;;;525            {
;;;526                output_pointer[i] = '.';
;;;527                continue;
;;;528            }
;;;529    
;;;530            output_pointer[i] = number_buffer[i];
;;;531        }
;;;532        output_pointer[i] = '\0';
;;;533    
;;;534        output_buffer->offset += (size_t)length;
;;;535    
;;;536        return true;
;;;537    }
00005a  b00b              ADD      sp,sp,#0x2c
00005c  ecbd8b02          VPOP     {d8}
000060  bdf0              POP      {r4-r7,pc}
                  |L92.98|
000062  1c69              ADDS     r1,r5,#1              ;514
000064  4630              MOV      r0,r6                 ;514
000066  f7fffffe          BL       ensure
00006a  2800              CMP      r0,#0                 ;515
00006c  d0f5              BEQ      |L92.90|
00006e  466a              MOV      r2,sp                 ;480
000070  232e              MOVS     r3,#0x2e              ;480
000072  e006              B        |L92.130|
                  |L92.116|
000074  5d11              LDRB     r1,[r2,r4]            ;524
000076  42b9              CMP      r1,r7                 ;524
000078  d101              BNE      |L92.126|
00007a  5503              STRB     r3,[r0,r4]            ;526
00007c  e000              B        |L92.128|
                  |L92.126|
00007e  5501              STRB     r1,[r0,r4]            ;530
                  |L92.128|
000080  1c64              ADDS     r4,r4,#1              ;530
                  |L92.130|
000082  42ac              CMP      r4,r5                 ;522
000084  d3f6              BCC      |L92.116|
000086  2100              MOVS     r1,#0                 ;532
000088  5501              STRB     r1,[r0,r4]            ;532
00008a  68b0              LDR      r0,[r6,#8]            ;534
00008c  4428              ADD      r0,r0,r5              ;534
00008e  60b0              STR      r0,[r6,#8]            ;536
000090  2001              MOVS     r0,#1                 ;536
000092  e7e2              B        |L92.90|
;;;538    
                          ENDP

                  |L92.148|
000094  25312e31          DCB      "%1.15g",0
000098  356700  
00009b  00                DCB      0
                  |L92.156|
00009c  256c6700          DCB      "%lg",0
                  |L92.160|
0000a0  25312e31          DCB      "%1.17g",0
0000a4  376700  
0000a7  00                DCB      0

                          AREA ||i.print_object||, CODE, READONLY, ALIGN=1

                  print_object PROC
;;;1605   /* Render an object to text. */
;;;1606   static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1607   {
000004  6885              LDR      r5,[r0,#8]
000006  000c              MOVS     r4,r1
000008  d003              BEQ      |L93.18|
;;;1608       unsigned char *output_pointer = NULL;
;;;1609       size_t length = 0;
;;;1610       cJSON *current_item = item->child;
;;;1611   
;;;1612       if (output_buffer == NULL)
;;;1613       {
;;;1614           return false;
;;;1615       }
;;;1616   
;;;1617       /* Compose the output: */
;;;1618       length = (size_t) (output_buffer->format ? 2 : 1); /* fmt: {\n */
00000a  6960              LDR      r0,[r4,#0x14]
00000c  b120              CBZ      r0,|L93.24|
00000e  2602              MOVS     r6,#2
000010  e003              B        |L93.26|
                  |L93.18|
000012  2000              MOVS     r0,#0                 ;1614
                  |L93.20|
;;;1619       output_pointer = ensure(output_buffer, length + 1);
;;;1620       if (output_pointer == NULL)
;;;1621       {
;;;1622           return false;
;;;1623       }
;;;1624   
;;;1625       *output_pointer++ = '{';
;;;1626       output_buffer->depth++;
;;;1627       if (output_buffer->format)
;;;1628       {
;;;1629           *output_pointer++ = '\n';
;;;1630       }
;;;1631       output_buffer->offset += length;
;;;1632   
;;;1633       while (current_item)
;;;1634       {
;;;1635           if (output_buffer->format)
;;;1636           {
;;;1637               size_t i;
;;;1638               output_pointer = ensure(output_buffer, output_buffer->depth);
;;;1639               if (output_pointer == NULL)
;;;1640               {
;;;1641                   return false;
;;;1642               }
;;;1643               for (i = 0; i < output_buffer->depth; i++)
;;;1644               {
;;;1645                   *output_pointer++ = '\t';
;;;1646               }
;;;1647               output_buffer->offset += output_buffer->depth;
;;;1648           }
;;;1649   
;;;1650           /* print key */
;;;1651           if (!print_string_ptr((unsigned char*)current_item->string, output_buffer))
;;;1652           {
;;;1653               return false;
;;;1654           }
;;;1655           update_offset(output_buffer);
;;;1656   
;;;1657           length = (size_t) (output_buffer->format ? 2 : 1);
;;;1658           output_pointer = ensure(output_buffer, length);
;;;1659           if (output_pointer == NULL)
;;;1660           {
;;;1661               return false;
;;;1662           }
;;;1663           *output_pointer++ = ':';
;;;1664           if (output_buffer->format)
;;;1665           {
;;;1666               *output_pointer++ = '\t';
;;;1667           }
;;;1668           output_buffer->offset += length;
;;;1669   
;;;1670           /* print value */
;;;1671           if (!print_value(current_item, output_buffer))
;;;1672           {
;;;1673               return false;
;;;1674           }
;;;1675           update_offset(output_buffer);
;;;1676   
;;;1677           /* print comma if not last */
;;;1678           length = (size_t) ((output_buffer->format ? 1 : 0) + (current_item->next ? 1 : 0));
;;;1679           output_pointer = ensure(output_buffer, length + 1);
;;;1680           if (output_pointer == NULL)
;;;1681           {
;;;1682               return false;
;;;1683           }
;;;1684           if (current_item->next)
;;;1685           {
;;;1686               *output_pointer++ = ',';
;;;1687           }
;;;1688   
;;;1689           if (output_buffer->format)
;;;1690           {
;;;1691               *output_pointer++ = '\n';
;;;1692           }
;;;1693           *output_pointer = '\0';
;;;1694           output_buffer->offset += length;
;;;1695   
;;;1696           current_item = current_item->next;
;;;1697       }
;;;1698   
;;;1699       output_pointer = ensure(output_buffer, output_buffer->format ? (output_buffer->depth + 1) : 2);
;;;1700       if (output_pointer == NULL)
;;;1701       {
;;;1702           return false;
;;;1703       }
;;;1704       if (output_buffer->format)
;;;1705       {
;;;1706           size_t i;
;;;1707           for (i = 0; i < (output_buffer->depth - 1); i++)
;;;1708           {
;;;1709               *output_pointer++ = '\t';
;;;1710           }
;;;1711       }
;;;1712       *output_pointer++ = '}';
;;;1713       *output_pointer = '\0';
;;;1714       output_buffer->depth--;
;;;1715   
;;;1716       return true;
;;;1717   }
000014  e8bd87f0          POP      {r4-r10,pc}
                  |L93.24|
000018  2601              MOVS     r6,#1                 ;1618
                  |L93.26|
00001a  1c71              ADDS     r1,r6,#1              ;1619
00001c  4620              MOV      r0,r4                 ;1619
00001e  f7fffffe          BL       ensure
000022  2800              CMP      r0,#0                 ;1620
000024  d0f6              BEQ      |L93.20|
000026  217b              MOVS     r1,#0x7b              ;1625
000028  f8001b01          STRB     r1,[r0],#1            ;1625
00002c  68e1              LDR      r1,[r4,#0xc]          ;1626
00002e  f04f080a          MOV      r8,#0xa               ;1629
000032  1c49              ADDS     r1,r1,#1              ;1626
000034  60e1              STR      r1,[r4,#0xc]          ;1627
000036  6961              LDR      r1,[r4,#0x14]         ;1627
000038  b109              CBZ      r1,|L93.62|
00003a  f8808000          STRB     r8,[r0,#0]            ;1629
                  |L93.62|
00003e  68a0              LDR      r0,[r4,#8]            ;1631
000040  f04f0900          MOV      r9,#0                 ;1631
000044  4430              ADD      r0,r0,r6              ;1631
000046  2709              MOVS     r7,#9                 ;1645
000048  60a0              STR      r0,[r4,#8]            ;1633
00004a  e053              B        |L93.244|
                  |L93.76|
00004c  b180              CBZ      r0,|L93.112|
00004e  4620              MOV      r0,r4                 ;1638
000050  68e1              LDR      r1,[r4,#0xc]          ;1638
000052  f7fffffe          BL       ensure
000056  2800              CMP      r0,#0                 ;1639
000058  d0dc              BEQ      |L93.20|
00005a  2100              MOVS     r1,#0                 ;1643
00005c  e002              B        |L93.100|
                  |L93.94|
00005e  f8007b01          STRB     r7,[r0],#1            ;1645
000062  1c49              ADDS     r1,r1,#1              ;1645
                  |L93.100|
000064  68e2              LDR      r2,[r4,#0xc]          ;1643
000066  428a              CMP      r2,r1                 ;1643
000068  d8f9              BHI      |L93.94|
00006a  68a0              LDR      r0,[r4,#8]            ;1647
00006c  4410              ADD      r0,r0,r2              ;1647
00006e  60a0              STR      r0,[r4,#8]            ;1647
                  |L93.112|
000070  4621              MOV      r1,r4                 ;1651
000072  6a28              LDR      r0,[r5,#0x20]         ;1651
000074  f7fffffe          BL       print_string_ptr
000078  2800              CMP      r0,#0                 ;1651
00007a  d0cb              BEQ      |L93.20|
00007c  4620              MOV      r0,r4                 ;1655
00007e  f7fffffe          BL       update_offset
000082  6960              LDR      r0,[r4,#0x14]         ;1657
000084  b108              CBZ      r0,|L93.138|
000086  2602              MOVS     r6,#2                 ;1657
000088  e000              B        |L93.140|
                  |L93.138|
00008a  2601              MOVS     r6,#1                 ;1657
                  |L93.140|
00008c  4631              MOV      r1,r6                 ;1658
00008e  4620              MOV      r0,r4                 ;1658
000090  f7fffffe          BL       ensure
000094  2800              CMP      r0,#0                 ;1659
000096  d0bd              BEQ      |L93.20|
000098  213a              MOVS     r1,#0x3a              ;1663
00009a  f8001b01          STRB     r1,[r0],#1            ;1663
00009e  6961              LDR      r1,[r4,#0x14]         ;1664
0000a0  b101              CBZ      r1,|L93.164|
0000a2  7007              STRB     r7,[r0,#0]            ;1666
                  |L93.164|
0000a4  68a0              LDR      r0,[r4,#8]            ;1668
0000a6  4621              MOV      r1,r4                 ;1671
0000a8  4430              ADD      r0,r0,r6              ;1668
0000aa  60a0              STR      r0,[r4,#8]            ;1671
0000ac  4628              MOV      r0,r5                 ;1671
0000ae  f7fffffe          BL       print_value
0000b2  2800              CMP      r0,#0                 ;1671
0000b4  d0ae              BEQ      |L93.20|
0000b6  4620              MOV      r0,r4                 ;1675
0000b8  f7fffffe          BL       update_offset
0000bc  6960              LDR      r0,[r4,#0x14]         ;1678
0000be  b100              CBZ      r0,|L93.194|
0000c0  2001              MOVS     r0,#1                 ;1678
                  |L93.194|
0000c2  6829              LDR      r1,[r5,#0]            ;1678
0000c4  b101              CBZ      r1,|L93.200|
0000c6  2101              MOVS     r1,#1                 ;1678
                  |L93.200|
0000c8  1846              ADDS     r6,r0,r1              ;1678
0000ca  1c71              ADDS     r1,r6,#1              ;1679
0000cc  4620              MOV      r0,r4                 ;1679
0000ce  f7fffffe          BL       ensure
0000d2  2800              CMP      r0,#0                 ;1680
0000d4  d09e              BEQ      |L93.20|
0000d6  6829              LDR      r1,[r5,#0]            ;1684
0000d8  b111              CBZ      r1,|L93.224|
0000da  212c              MOVS     r1,#0x2c              ;1686
0000dc  f8001b01          STRB     r1,[r0],#1            ;1686
                  |L93.224|
0000e0  6961              LDR      r1,[r4,#0x14]         ;1689
0000e2  b109              CBZ      r1,|L93.232|
0000e4  f8008b01          STRB     r8,[r0],#1            ;1691
                  |L93.232|
0000e8  f8809000          STRB     r9,[r0,#0]            ;1693
0000ec  68a0              LDR      r0,[r4,#8]            ;1694
0000ee  4430              ADD      r0,r0,r6              ;1694
0000f0  60a0              STR      r0,[r4,#8]            ;1696
0000f2  682d              LDR      r5,[r5,#0]            ;1696
                  |L93.244|
0000f4  6960              LDR      r0,[r4,#0x14]         ;1633
0000f6  2d00              CMP      r5,#0                 ;1633
0000f8  d1a8              BNE      |L93.76|
0000fa  b110              CBZ      r0,|L93.258|
0000fc  68e1              LDR      r1,[r4,#0xc]          ;1699
0000fe  1c49              ADDS     r1,r1,#1              ;1699
000100  e000              B        |L93.260|
                  |L93.258|
000102  2102              MOVS     r1,#2                 ;1699
                  |L93.260|
000104  4620              MOV      r0,r4                 ;1699
000106  f7fffffe          BL       ensure
00010a  2800              CMP      r0,#0                 ;1700
00010c  d082              BEQ      |L93.20|
00010e  6961              LDR      r1,[r4,#0x14]         ;1704
000110  b141              CBZ      r1,|L93.292|
000112  2100              MOVS     r1,#0                 ;1707
000114  e002              B        |L93.284|
                  |L93.278|
000116  f8007b01          STRB     r7,[r0],#1            ;1709
00011a  1c49              ADDS     r1,r1,#1              ;1709
                  |L93.284|
00011c  68e2              LDR      r2,[r4,#0xc]          ;1707
00011e  1e52              SUBS     r2,r2,#1              ;1707
000120  428a              CMP      r2,r1                 ;1707
000122  d8f8              BHI      |L93.278|
                  |L93.292|
000124  217d              MOVS     r1,#0x7d              ;1712
000126  7001              STRB     r1,[r0,#0]            ;1712
000128  f8809001          STRB     r9,[r0,#1]            ;1713
00012c  68e0              LDR      r0,[r4,#0xc]          ;1714
00012e  1e40              SUBS     r0,r0,#1              ;1714
000130  60e0              STR      r0,[r4,#0xc]          ;1716
000132  2001              MOVS     r0,#1                 ;1716
000134  e76e              B        |L93.20|
;;;1718   
                          ENDP


                          AREA ||i.print_string_ptr||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  print_string_ptr PROC
;;;826    /* Render the cstring provided to an escaped version that can be printed. */
;;;827    static cJSON_bool print_string_ptr(const unsigned char * const input, printbuffer * const output_buffer)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;828    {
000004  000a              MOVS     r2,r1
000006  4606              MOV      r6,r0
;;;829        const unsigned char *input_pointer = NULL;
;;;830        unsigned char *output = NULL;
;;;831        unsigned char *output_pointer = NULL;
;;;832        size_t output_length = 0;
;;;833        /* numbers of additional characters needed for escaping */
;;;834        size_t escape_characters = 0;
000008  f04f0400          MOV      r4,#0
00000c  d002              BEQ      |L94.20|
;;;835    
;;;836        if (output_buffer == NULL)
;;;837        {
;;;838            return false;
;;;839        }
;;;840    
;;;841        /* empty string */
;;;842        if (input == NULL)
00000e  b126              CBZ      r6,|L94.26|
;;;843        {
;;;844            output = ensure(output_buffer, sizeof("\"\""));
;;;845            if (output == NULL)
;;;846            {
;;;847                return false;
;;;848            }
;;;849            strcpy((char*)output, "\"\"");
;;;850    
;;;851            return true;
;;;852        }
;;;853    
;;;854        /* set "flag" to 1 if something needs to be escaped */
;;;855        for (input_pointer = input; *input_pointer; input_pointer++)
000010  4601              MOV      r1,r0
000012  e020              B        |L94.86|
                  |L94.20|
000014  2000              MOVS     r0,#0                 ;838
                  |L94.22|
;;;856        {
;;;857            switch (*input_pointer)
;;;858            {
;;;859                case '\"':
;;;860                case '\\':
;;;861                case '\b':
;;;862                case '\f':
;;;863                case '\n':
;;;864                case '\r':
;;;865                case '\t':
;;;866                    /* one character escape sequence */
;;;867                    escape_characters++;
;;;868                    break;
;;;869                default:
;;;870                    if (*input_pointer < 32)
;;;871                    {
;;;872                        /* UTF-16 escape sequence uXXXX */
;;;873                        escape_characters += 5;
;;;874                    }
;;;875                    break;
;;;876            }
;;;877        }
;;;878        output_length = (size_t)(input_pointer - input) + escape_characters;
;;;879    
;;;880        output = ensure(output_buffer, output_length + sizeof("\"\""));
;;;881        if (output == NULL)
;;;882        {
;;;883            return false;
;;;884        }
;;;885    
;;;886        /* no characters have to be escaped */
;;;887        if (escape_characters == 0)
;;;888        {
;;;889            output[0] = '\"';
;;;890            memcpy(output + 1, input, output_length);
;;;891            output[output_length + 1] = '\"';
;;;892            output[output_length + 2] = '\0';
;;;893    
;;;894            return true;
;;;895        }
;;;896    
;;;897        output[0] = '\"';
;;;898        output_pointer = output + 1;
;;;899        /* copy the string */
;;;900        for (input_pointer = input; *input_pointer != '\0'; (void)input_pointer++, output_pointer++)
;;;901        {
;;;902            if ((*input_pointer > 31) && (*input_pointer != '\"') && (*input_pointer != '\\'))
;;;903            {
;;;904                /* normal character, copy */
;;;905                *output_pointer = *input_pointer;
;;;906            }
;;;907            else
;;;908            {
;;;909                /* character needs to be escaped */
;;;910                *output_pointer++ = '\\';
;;;911                switch (*input_pointer)
;;;912                {
;;;913                    case '\\':
;;;914                        *output_pointer = '\\';
;;;915                        break;
;;;916                    case '\"':
;;;917                        *output_pointer = '\"';
;;;918                        break;
;;;919                    case '\b':
;;;920                        *output_pointer = 'b';
;;;921                        break;
;;;922                    case '\f':
;;;923                        *output_pointer = 'f';
;;;924                        break;
;;;925                    case '\n':
;;;926                        *output_pointer = 'n';
;;;927                        break;
;;;928                    case '\r':
;;;929                        *output_pointer = 'r';
;;;930                        break;
;;;931                    case '\t':
;;;932                        *output_pointer = 't';
;;;933                        break;
;;;934                    default:
;;;935                        /* escape and print as unicode codepoint */
;;;936                        sprintf((char*)output_pointer, "u%04x", *input_pointer);
;;;937                        output_pointer += 4;
;;;938                        break;
;;;939                }
;;;940            }
;;;941        }
;;;942        output[output_length + 1] = '\"';
;;;943        output[output_length + 2] = '\0';
;;;944    
;;;945        return true;
;;;946    }
000016  e8bd87f0          POP      {r4-r10,pc}
                  |L94.26|
00001a  2103              MOVS     r1,#3                 ;844
00001c  4610              MOV      r0,r2                 ;844
00001e  f7fffffe          BL       ensure
000022  2800              CMP      r0,#0                 ;845
000024  d0f7              BEQ      |L94.22|
000026  a137              ADR      r1,|L94.260|
000028  f7fffffe          BL       strcpy
00002c  e05a              B        |L94.228|
                  |L94.46|
00002e  280c              CMP      r0,#0xc               ;857
000030  d027              BEQ      |L94.130|
000032  dc06              BGT      |L94.66|
000034  2808              CMP      r0,#8                 ;857
000036  d024              BEQ      |L94.130|
000038  2809              CMP      r0,#9                 ;857
00003a  d022              BEQ      |L94.130|
00003c  280a              CMP      r0,#0xa               ;857
00003e  d106              BNE      |L94.78|
000040  e01f              B        |L94.130|
                  |L94.66|
000042  280d              CMP      r0,#0xd               ;857
000044  d01d              BEQ      |L94.130|
000046  2822              CMP      r0,#0x22              ;857
000048  d01b              BEQ      |L94.130|
00004a  285c              CMP      r0,#0x5c              ;857
00004c  d019              BEQ      |L94.130|
                  |L94.78|
00004e  2820              CMP      r0,#0x20              ;870
000050  d200              BCS      |L94.84|
000052  1d64              ADDS     r4,r4,#5              ;870
                  |L94.84|
000054  1c49              ADDS     r1,r1,#1              ;870
                  |L94.86|
000056  7808              LDRB     r0,[r1,#0]            ;855
000058  2800              CMP      r0,#0                 ;855
00005a  d1e8              BNE      |L94.46|
00005c  1b88              SUBS     r0,r1,r6              ;878
00005e  1907              ADDS     r7,r0,r4              ;878
000060  1cf9              ADDS     r1,r7,#3              ;880
000062  4610              MOV      r0,r2                 ;880
000064  f7fffffe          BL       ensure
000068  1e05              SUBS     r5,r0,#0              ;880
00006a  d0d4              BEQ      |L94.22|
00006c  f04f0822          MOV      r8,#0x22              ;889
000070  f04f0900          MOV      r9,#0                 ;881
000074  f8858000          STRB     r8,[r5,#0]            ;897
000078  b12c              CBZ      r4,|L94.134|
00007a  1c6c              ADDS     r4,r5,#1              ;898
00007c  f04f0a5c          MOV      r10,#0x5c             ;857
000080  e028              B        |L94.212|
                  |L94.130|
000082  1c64              ADDS     r4,r4,#1              ;900
000084  e7e6              B        |L94.84|
                  |L94.134|
000086  463a              MOV      r2,r7                 ;890
000088  4631              MOV      r1,r6                 ;890
00008a  1c68              ADDS     r0,r5,#1              ;890
00008c  f7fffffe          BL       __aeabi_memcpy
000090  e023              B        |L94.218|
                  |L94.146|
000092  281f              CMP      r0,#0x1f              ;902
000094  d903              BLS      |L94.158|
000096  2822              CMP      r0,#0x22              ;902
000098  d001              BEQ      |L94.158|
00009a  285c              CMP      r0,#0x5c              ;902
00009c  d130              BNE      |L94.256|
                  |L94.158|
00009e  f804ab01          STRB     r10,[r4],#1           ;910
0000a2  7832              LDRB     r2,[r6,#0]            ;911
0000a4  4650              MOV      r0,r10                ;910
0000a6  2a0c              CMP      r2,#0xc               ;911
0000a8  d023              BEQ      |L94.242|
0000aa  dc06              BGT      |L94.186|
0000ac  2a08              CMP      r2,#8                 ;911
0000ae  d01e              BEQ      |L94.238|
0000b0  2a09              CMP      r2,#9                 ;911
0000b2  d024              BEQ      |L94.254|
0000b4  2a0a              CMP      r2,#0xa               ;911
0000b6  d106              BNE      |L94.198|
0000b8  e01d              B        |L94.246|
                  |L94.186|
0000ba  2a0d              CMP      r2,#0xd               ;911
0000bc  d01d              BEQ      |L94.250|
0000be  2a22              CMP      r2,#0x22              ;911
0000c0  d012              BEQ      |L94.232|
0000c2  2a5c              CMP      r2,#0x5c              ;911
0000c4  d01c              BEQ      |L94.256|
                  |L94.198|
0000c6  a110              ADR      r1,|L94.264|
0000c8  4620              MOV      r0,r4                 ;936
0000ca  f7fffffe          BL       __2sprintf
0000ce  1d24              ADDS     r4,r4,#4              ;936
                  |L94.208|
0000d0  1c64              ADDS     r4,r4,#1              ;936
0000d2  1c76              ADDS     r6,r6,#1              ;936
                  |L94.212|
0000d4  7830              LDRB     r0,[r6,#0]            ;900
0000d6  2800              CMP      r0,#0                 ;900
0000d8  d1db              BNE      |L94.146|
                  |L94.218|
0000da  19e8              ADDS     r0,r5,r7              ;942
0000dc  f8808001          STRB     r8,[r0,#1]            ;942
0000e0  f8809002          STRB     r9,[r0,#2]            ;943
                  |L94.228|
0000e4  2001              MOVS     r0,#1                 ;945
0000e6  e796              B        |L94.22|
                  |L94.232|
0000e8  f8848000          STRB     r8,[r4,#0]            ;917
0000ec  e7f0              B        |L94.208|
                  |L94.238|
0000ee  2062              MOVS     r0,#0x62              ;920
0000f0  e006              B        |L94.256|
                  |L94.242|
0000f2  2066              MOVS     r0,#0x66              ;923
0000f4  e004              B        |L94.256|
                  |L94.246|
0000f6  206e              MOVS     r0,#0x6e              ;926
0000f8  e002              B        |L94.256|
                  |L94.250|
0000fa  2072              MOVS     r0,#0x72              ;929
0000fc  e000              B        |L94.256|
                  |L94.254|
0000fe  2074              MOVS     r0,#0x74              ;932
                  |L94.256|
000100  7020              STRB     r0,[r4,#0]            ;932
000102  e7e5              B        |L94.208|
;;;947    
                          ENDP

                  |L94.260|
000104  222200            DCB      """""",0
000107  00                DCB      0
                  |L94.264|
000108  75253034          DCB      "u%04x",0
00010c  7800    
00010e  00                DCB      0
00010f  00                DCB      0

                          AREA ||i.print_value||, CODE, READONLY, ALIGN=2

                  print_value PROC
;;;1266   /* Render a value to text. */
;;;1267   static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer)
000000  b570              PUSH     {r4-r6,lr}
;;;1268   {
000002  0004              MOVS     r4,r0
000004  460d              MOV      r5,r1
000006  d013              BEQ      |L95.48|
;;;1269       unsigned char *output = NULL;
;;;1270   
;;;1271       if ((item == NULL) || (output_buffer == NULL))
000008  b195              CBZ      r5,|L95.48|
;;;1272       {
;;;1273           return false;
;;;1274       }
;;;1275   
;;;1276       switch ((item->type) & 0xFF)
00000a  7b20              LDRB     r0,[r4,#0xc]
00000c  2810              CMP      r0,#0x10
00000e  d043              BEQ      |L95.152|
000010  dc08              BGT      |L95.36|
000012  2801              CMP      r0,#1
000014  d016              BEQ      |L95.68|
000016  2802              CMP      r0,#2
000018  d01e              BEQ      |L95.88|
00001a  2804              CMP      r0,#4
00001c  d00a              BEQ      |L95.52|
00001e  2808              CMP      r0,#8
000020  d106              BNE      |L95.48|
000022  e021              B        |L95.104|
                  |L95.36|
000024  2820              CMP      r0,#0x20
000026  d03c              BEQ      |L95.162|
000028  2840              CMP      r0,#0x40
00002a  d03f              BEQ      |L95.172|
00002c  2880              CMP      r0,#0x80
00002e  d020              BEQ      |L95.114|
                  |L95.48|
;;;1277       {
;;;1278           case cJSON_NULL:
;;;1279               output = ensure(output_buffer, 5);
;;;1280               if (output == NULL)
;;;1281               {
;;;1282                   return false;
;;;1283               }
;;;1284               strcpy((char*)output, "null");
;;;1285               return true;
;;;1286   
;;;1287           case cJSON_False:
;;;1288               output = ensure(output_buffer, 6);
;;;1289               if (output == NULL)
;;;1290               {
;;;1291                   return false;
;;;1292               }
;;;1293               strcpy((char*)output, "false");
;;;1294               return true;
;;;1295   
;;;1296           case cJSON_True:
;;;1297               output = ensure(output_buffer, 5);
;;;1298               if (output == NULL)
;;;1299               {
;;;1300                   return false;
;;;1301               }
;;;1302               strcpy((char*)output, "true");
;;;1303               return true;
;;;1304   
;;;1305           case cJSON_Number:
;;;1306               return print_number(item, output_buffer);
;;;1307   
;;;1308           case cJSON_Raw:
;;;1309           {
;;;1310               size_t raw_length = 0;
;;;1311               if (item->valuestring == NULL)
;;;1312               {
;;;1313                   return false;
;;;1314               }
;;;1315   
;;;1316               raw_length = strlen(item->valuestring) + sizeof("");
;;;1317               output = ensure(output_buffer, raw_length);
;;;1318               if (output == NULL)
;;;1319               {
;;;1320                   return false;
;;;1321               }
;;;1322               memcpy(output, item->valuestring, raw_length);
;;;1323               return true;
;;;1324           }
;;;1325   
;;;1326           case cJSON_String:
;;;1327               return print_string(item, output_buffer);
;;;1328   
;;;1329           case cJSON_Array:
;;;1330               return print_array(item, output_buffer);
;;;1331   
;;;1332           case cJSON_Object:
;;;1333               return print_object(item, output_buffer);
;;;1334   
;;;1335           default:
;;;1336               return false;
000030  2000              MOVS     r0,#0
                  |L95.50|
;;;1337       }
;;;1338   }
000032  bd70              POP      {r4-r6,pc}
                  |L95.52|
000034  2105              MOVS     r1,#5                 ;1279
000036  4628              MOV      r0,r5                 ;1279
000038  f7fffffe          BL       ensure
00003c  2800              CMP      r0,#0                 ;1280
00003e  d0f8              BEQ      |L95.50|
000040  a11d              ADR      r1,|L95.184|
000042  e006              B        |L95.82|
                  |L95.68|
000044  2106              MOVS     r1,#6                 ;1288
000046  4628              MOV      r0,r5                 ;1288
000048  f7fffffe          BL       ensure
00004c  2800              CMP      r0,#0                 ;1289
00004e  d0f0              BEQ      |L95.50|
000050  a11b              ADR      r1,|L95.192|
                  |L95.82|
000052  f7fffffe          BL       strcpy
000056  e01d              B        |L95.148|
                  |L95.88|
000058  2105              MOVS     r1,#5                 ;1297
00005a  4628              MOV      r0,r5                 ;1297
00005c  f7fffffe          BL       ensure
000060  2800              CMP      r0,#0                 ;1298
000062  d0e6              BEQ      |L95.50|
000064  a118              ADR      r1,|L95.200|
000066  e7f4              B        |L95.82|
                  |L95.104|
000068  4620              MOV      r0,r4                 ;1306
00006a  e8bd4070          POP      {r4-r6,lr}            ;1306
00006e  f7ffbffe          B.W      print_number
                  |L95.114|
000072  6920              LDR      r0,[r4,#0x10]         ;1311
000074  2800              CMP      r0,#0                 ;1311
000076  d0dc              BEQ      |L95.50|
000078  f7fffffe          BL       strlen
00007c  1c40              ADDS     r0,r0,#1              ;1316
00007e  4606              MOV      r6,r0                 ;1316
000080  4601              MOV      r1,r0                 ;1317
000082  4628              MOV      r0,r5                 ;1317
000084  f7fffffe          BL       ensure
000088  2800              CMP      r0,#0                 ;1318
00008a  d0d2              BEQ      |L95.50|
00008c  4632              MOV      r2,r6                 ;1322
00008e  6921              LDR      r1,[r4,#0x10]         ;1322
000090  f7fffffe          BL       __aeabi_memcpy
                  |L95.148|
000094  2001              MOVS     r0,#1                 ;1323
000096  bd70              POP      {r4-r6,pc}
                  |L95.152|
000098  6920              LDR      r0,[r4,#0x10]
00009a  e8bd4070          POP      {r4-r6,lr}
00009e  f7ffbffe          B.W      print_string_ptr
                  |L95.162|
0000a2  4620              MOV      r0,r4                 ;1330
0000a4  e8bd4070          POP      {r4-r6,lr}            ;1330
0000a8  f7ffbffe          B.W      print_array
                  |L95.172|
0000ac  4620              MOV      r0,r4                 ;1333
0000ae  e8bd4070          POP      {r4-r6,lr}            ;1333
0000b2  f7ffbffe          B.W      print_object
;;;1339   
                          ENDP

0000b6  0000              DCW      0x0000
                  |L95.184|
0000b8  6e756c6c          DCB      "null",0
0000bc  00      
0000bd  00                DCB      0
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L95.192|
0000c0  66616c73          DCB      "false",0
0000c4  6500    
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L95.200|
0000c8  74727565          DCB      "true",0
0000cc  00      
0000cd  00                DCB      0
0000ce  00                DCB      0
0000cf  00                DCB      0

                          AREA ||i.replace_item_in_object||, CODE, READONLY, ALIGN=2

                  replace_item_in_object PROC
;;;2214   
;;;2215   static cJSON_bool replace_item_in_object(cJSON *object, const char *string, cJSON *replacement, cJSON_bool case_sensitive)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2216   {
000004  461e              MOV      r6,r3
000006  0014              MOVS     r4,r2
000008  460d              MOV      r5,r1
00000a  4607              MOV      r7,r0
00000c  d01d              BEQ      |L96.74|
;;;2217       if ((replacement == NULL) || (string == NULL))
00000e  b1e5              CBZ      r5,|L96.74|
;;;2218       {
;;;2219           return false;
;;;2220       }
;;;2221   
;;;2222       /* replace the name in the replacement */
;;;2223       if (!(replacement->type & cJSON_StringIsConst) && (replacement->string != NULL))
000010  89a0              LDRH     r0,[r4,#0xc]
000012  0580              LSLS     r0,r0,#22
000014  d403              BMI      |L96.30|
000016  6a20              LDR      r0,[r4,#0x20]
000018  b108              CBZ      r0,|L96.30|
;;;2224       {
;;;2225           cJSON_free(replacement->string);
00001a  f7fffffe          BL       cJSON_free
                  |L96.30|
;;;2226       }
;;;2227       replacement->string = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
00001e  490c              LDR      r1,|L96.80|
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       cJSON_strdup
;;;2228       replacement->type &= ~cJSON_StringIsConst;
000026  6220              STR      r0,[r4,#0x20]
000028  68e0              LDR      r0,[r4,#0xc]
;;;2229   
;;;2230       cJSON_ReplaceItemViaPointer(object, get_object_item(object, string, case_sensitive), replacement);
00002a  4632              MOV      r2,r6
00002c  f4207000          BIC      r0,r0,#0x200          ;2228
000030  60e0              STR      r0,[r4,#0xc]
000032  4629              MOV      r1,r5
000034  4638              MOV      r0,r7
000036  f7fffffe          BL       get_object_item
00003a  4601              MOV      r1,r0
00003c  4622              MOV      r2,r4
00003e  4638              MOV      r0,r7
000040  f7fffffe          BL       cJSON_ReplaceItemViaPointer
;;;2231   
;;;2232       return true;
000044  2001              MOVS     r0,#1
                  |L96.70|
;;;2233   }
000046  e8bd81f0          POP      {r4-r8,pc}
                  |L96.74|
00004a  2000              MOVS     r0,#0                 ;2219
00004c  e7fb              B        |L96.70|
;;;2234   
                          ENDP

00004e  0000              DCW      0x0000
                  |L96.80|
                          DCD      ||.data||+0x8

                          AREA ||i.update_offset||, CODE, READONLY, ALIGN=1

                  update_offset PROC
;;;460    /* calculate the new length of the string in a printbuffer and update the offset */
;;;461    static void update_offset(printbuffer * const buffer)
000000  b510              PUSH     {r4,lr}
;;;462    {
000002  0004              MOVS     r4,r0
000004  d009              BEQ      |L97.26|
;;;463        const unsigned char *buffer_pointer = NULL;
;;;464        if ((buffer == NULL) || (buffer->buffer == NULL))
000006  6820              LDR      r0,[r4,#0]
000008  2800              CMP      r0,#0
00000a  d006              BEQ      |L97.26|
;;;465        {
;;;466            return;
;;;467        }
;;;468        buffer_pointer = buffer->buffer + buffer->offset;
00000c  68a1              LDR      r1,[r4,#8]
00000e  4408              ADD      r0,r0,r1
;;;469    
;;;470        buffer->offset += strlen((const char*)buffer_pointer);
000010  f7fffffe          BL       strlen
000014  68a1              LDR      r1,[r4,#8]
000016  4408              ADD      r0,r0,r1
000018  60a0              STR      r0,[r4,#8]
                  |L97.26|
;;;471    }
00001a  bd10              POP      {r4,pc}
;;;472    
                          ENDP


                          AREA ||i.utf16_literal_to_utf8||, CODE, READONLY, ALIGN=1

                  utf16_literal_to_utf8 PROC
;;;576     * A literal can be one or two sequences of the form \uXXXX */
;;;577    static unsigned char utf16_literal_to_utf8(const unsigned char * const input_pointer, const unsigned char * const input_end, unsigned char **output_pointer)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;578    {
000004  4607              MOV      r7,r0
;;;579        long unsigned int codepoint = 0;
;;;580        unsigned int first_code = 0;
;;;581        const unsigned char *first_sequence = input_pointer;
;;;582        unsigned char utf8_length = 0;
;;;583        unsigned char utf8_position = 0;
;;;584        unsigned char sequence_length = 0;
;;;585        unsigned char first_byte_mark = 0;
000006  2600              MOVS     r6,#0
;;;586    
;;;587        if ((input_end - first_sequence) < 6)
000008  1bc8              SUBS     r0,r1,r7
00000a  4614              MOV      r4,r2                 ;578
00000c  4689              MOV      r9,r1                 ;578
00000e  2806              CMP      r0,#6
000010  db5c              BLT      |L98.204|
;;;588        {
;;;589            /* input ends unexpectedly */
;;;590            goto fail;
;;;591        }
;;;592    
;;;593        /* get the first utf16 sequence */
;;;594        first_code = parse_hex4(first_sequence + 2);
000012  1cb8              ADDS     r0,r7,#2
000014  f7fffffe          BL       parse_hex4
000018  4605              MOV      r5,r0
;;;595    
;;;596        /* check that the code is valid */
;;;597        if (((first_code >= 0xDC00) && (first_code <= 0xDFFF)))
00001a  f5a0405c          SUB      r0,r0,#0xdc00
00001e  f44f6180          MOV      r1,#0x400
000022  4288              CMP      r0,r1
000024  d352              BCC      |L98.204|
;;;598        {
;;;599            goto fail;
;;;600        }
;;;601    
;;;602        /* UTF16 surrogate pair */
;;;603        if ((first_code >= 0xD800) && (first_code <= 0xDBFF))
000026  f5a54058          SUB      r0,r5,#0xd800
00002a  468a              MOV      r10,r1
00002c  4550              CMP      r0,r10
00002e  d21a              BCS      |L98.102|
;;;604        {
;;;605            const unsigned char *second_sequence = first_sequence + 6;
000030  1db8              ADDS     r0,r7,#6
;;;606            unsigned int second_code = 0;
;;;607            sequence_length = 12; /* \uXXXX\uXXXX */
;;;608    
;;;609            if ((input_end - second_sequence) < 6)
000032  eba90100          SUB      r1,r9,r0
000036  f04f080c          MOV      r8,#0xc               ;607
00003a  2906              CMP      r1,#6
00003c  db46              BLT      |L98.204|
;;;610            {
;;;611                /* input ends unexpectedly */
;;;612                goto fail;
;;;613            }
;;;614    
;;;615            if ((second_sequence[0] != '\\') || (second_sequence[1] != 'u'))
00003e  7801              LDRB     r1,[r0,#0]
000040  295c              CMP      r1,#0x5c
000042  d143              BNE      |L98.204|
000044  7841              LDRB     r1,[r0,#1]
000046  2975              CMP      r1,#0x75
000048  d140              BNE      |L98.204|
00004a  1c80              ADDS     r0,r0,#2
;;;616            {
;;;617                /* missing second half of the surrogate pair */
;;;618                goto fail;
;;;619            }
;;;620    
;;;621            /* get the second utf16 sequence */
;;;622            second_code = parse_hex4(second_sequence + 2);
00004c  f7fffffe          BL       parse_hex4
;;;623            /* check that the code is valid */
;;;624            if ((second_code < 0xDC00) || (second_code > 0xDFFF))
000050  f5a0415c          SUB      r1,r0,#0xdc00
000054  4551              CMP      r1,r10
000056  d239              BCS      |L98.204|
;;;625            {
;;;626                /* invalid second half of the surrogate pair */
;;;627                goto fail;
;;;628            }
;;;629    
;;;630    
;;;631            /* calculate the unicode codepoint from the surrogate pair */
;;;632            codepoint = 0x10000 + (((first_code & 0x3FF) << 10) | (second_code & 0x3FF));
000058  f3c50109          UBFX     r1,r5,#0,#10
00005c  f361209f          BFI      r0,r1,#10,#22
000060  f5003080          ADD      r0,r0,#0x10000
;;;633        }
000064  e002              B        |L98.108|
                  |L98.102|
;;;634        else
;;;635        {
;;;636            sequence_length = 6; /* \uXXXX */
000066  f04f0806          MOV      r8,#6
;;;637            codepoint = first_code;
00006a  4628              MOV      r0,r5
                  |L98.108|
;;;638        }
;;;639    
;;;640        /* encode as UTF-8
;;;641         * takes at maximum 4 bytes to encode:
;;;642         * 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */
;;;643        if (codepoint < 0x80)
00006c  2880              CMP      r0,#0x80
00006e  d201              BCS      |L98.116|
;;;644        {
;;;645            /* normal ascii, encoding 0xxxxxxx */
;;;646            utf8_length = 1;
000070  2201              MOVS     r2,#1
000072  e010              B        |L98.150|
                  |L98.116|
;;;647        }
;;;648        else if (codepoint < 0x800)
000074  f5b06f00          CMP      r0,#0x800
000078  d202              BCS      |L98.128|
;;;649        {
;;;650            /* two bytes, encoding 110xxxxx 10xxxxxx */
;;;651            utf8_length = 2;
00007a  2202              MOVS     r2,#2
;;;652            first_byte_mark = 0xC0; /* 11000000 */
00007c  26c0              MOVS     r6,#0xc0
00007e  e00a              B        |L98.150|
                  |L98.128|
;;;653        }
;;;654        else if (codepoint < 0x10000)
000080  f5b03f80          CMP      r0,#0x10000
000084  d202              BCS      |L98.140|
;;;655        {
;;;656            /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */
;;;657            utf8_length = 3;
000086  2203              MOVS     r2,#3
;;;658            first_byte_mark = 0xE0; /* 11100000 */
000088  26e0              MOVS     r6,#0xe0
00008a  e004              B        |L98.150|
                  |L98.140|
;;;659        }
;;;660        else if (codepoint <= 0x10FFFF)
00008c  f5b01f88          CMP      r0,#0x110000
000090  d21c              BCS      |L98.204|
;;;661        {
;;;662            /* four bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx */
;;;663            utf8_length = 4;
000092  2204              MOVS     r2,#4
;;;664            first_byte_mark = 0xF0; /* 11110000 */
000094  26f0              MOVS     r6,#0xf0
                  |L98.150|
;;;665        }
;;;666        else
;;;667        {
;;;668            /* invalid unicode codepoint */
;;;669            goto fail;
;;;670        }
;;;671    
;;;672        /* encode as utf8 */
;;;673        for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)
000096  1e51              SUBS     r1,r2,#1
000098  e007              B        |L98.170|
                  |L98.154|
;;;674        {
;;;675            /* 10xxxxxx */
;;;676            (*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) & 0xBF);
00009a  f00003bf          AND      r3,r0,#0xbf
00009e  6825              LDR      r5,[r4,#0]
0000a0  f0430380          ORR      r3,r3,#0x80
;;;677            codepoint >>= 6;
0000a4  0980              LSRS     r0,r0,#6
0000a6  546b              STRB     r3,[r5,r1]            ;676
0000a8  1e49              SUBS     r1,r1,#1
                  |L98.170|
0000aa  f01101ff          ANDS     r1,r1,#0xff           ;673
0000ae  d1f4              BNE      |L98.154|
;;;678        }
;;;679        /* encode first byte */
;;;680        if (utf8_length > 1)
0000b0  2a01              CMP      r2,#1
0000b2  d901              BLS      |L98.184|
;;;681        {
;;;682            (*output_pointer)[0] = (unsigned char)((codepoint | first_byte_mark) & 0xFF);
0000b4  4330              ORRS     r0,r0,r6
0000b6  e001              B        |L98.188|
                  |L98.184|
;;;683        }
;;;684        else
;;;685        {
;;;686            (*output_pointer)[0] = (unsigned char)(codepoint & 0x7F);
0000b8  f000007f          AND      r0,r0,#0x7f
                  |L98.188|
0000bc  6821              LDR      r1,[r4,#0]
0000be  7008              STRB     r0,[r1,#0]
;;;687        }
;;;688    
;;;689        *output_pointer += utf8_length;
0000c0  6820              LDR      r0,[r4,#0]
0000c2  4410              ADD      r0,r0,r2
;;;690    
;;;691        return sequence_length;
0000c4  6020              STR      r0,[r4,#0]
0000c6  4640              MOV      r0,r8
                  |L98.200|
;;;692    
;;;693    fail:
;;;694        return 0;
;;;695    }
0000c8  e8bd87f0          POP      {r4-r10,pc}
                  |L98.204|
0000cc  2000              MOVS     r0,#0                 ;694
0000ce  e7fb              B        |L98.200|
;;;696    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  version
                          %        15

                          AREA ||.data||, DATA, ALIGN=2

                  global_error
                          DCD      0x00000000
                          DCD      0x00000000
                  global_hooks
                          DCD      malloc
                          DCD      free
                          DCD      realloc

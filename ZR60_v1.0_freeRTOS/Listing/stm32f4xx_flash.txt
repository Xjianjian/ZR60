; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\stm32f4xx_flash.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\stm32f4xx_flash.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\ZR60_v1.0_freeRTOS -I..\..\Lwip\App -I..\..\Lwip\Bsp -I..\..\Lwip\Bsp\LAN8742A -I..\..\Lwip\lwip-1.4.1 -I..\..\Lwip\lwip-1.4.1\port -I..\..\Lwip\lwip-1.4.1\port\arch -I..\..\Lwip\lwip-1.4.1\port\Standalone -I..\..\Lwip\lwip-1.4.1\src\include -I..\..\Lwip\lwip-1.4.1\src\include\ipv4 -I..\..\Lwip\lwip-1.4.1\src\include\lwip -I..\..\Lwip\lwip-1.4.1\src\include\netif -I..\..\Ecal\BtnFltr -I..\..\Ecal\UartComn -I..\..\Ecal\MemIf -I..\..\APP -I..\..\APP\BlackListMng -I..\..\APP\SeverNewsPush -I..\..\APP\NewsPull -I..\..\Ecal -I..\..\Ecal\JsonIf -I..\..\Ecal\Mcu_Init -I..\..\Service -I..\..\Complex -I..\..\Complex\FATFS -I..\..\FreeRTOS\Source\include -I..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\FreeRTOS -I.\RTE\_ZR60 -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=..\..\output\stm32f4xx_flash.crf ..\..\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_flash.c]
                          THUMB

                          AREA ||i.FLASH_ClearFlag||, CODE, READONLY, ALIGN=2

                  FLASH_ClearFlag PROC
;;;1519     */
;;;1520   void FLASH_ClearFlag(uint32_t FLASH_FLAG)
000000  4901              LDR      r1,|L1.8|
;;;1521   {
;;;1522     /* Check the parameters */
;;;1523     assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
;;;1524     
;;;1525     /* Clear the flags */
;;;1526     FLASH->SR = FLASH_FLAG;
000002  6008              STR      r0,[r1,#0]
;;;1527   }
000004  4770              BX       lr
;;;1528   
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x40023c0c

                          AREA ||i.FLASH_DataCacheCmd||, CODE, READONLY, ALIGN=2

                  FLASH_DataCacheCmd PROC
;;;334      */
;;;335    void FLASH_DataCacheCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L2.24|
;;;336    {
;;;337      /* Check the parameters */
;;;338      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;339      
;;;340      if(NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;341      {
;;;342        FLASH->ACR |= FLASH_ACR_DCEN;
;;;343      }
;;;344      else
;;;345      {
;;;346        FLASH->ACR &= (~FLASH_ACR_DCEN);
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L2.14|
000008  f4406080          ORR      r0,r0,#0x400          ;342
00000c  e001              B        |L2.18|
                  |L2.14|
00000e  f4206080          BIC      r0,r0,#0x400
                  |L2.18|
000012  6008              STR      r0,[r1,#0]            ;342
;;;347      }
;;;348    }
000014  4770              BX       lr
;;;349    
                          ENDP

000016  0000              DCW      0x0000
                  |L2.24|
                          DCD      0x40023c00

                          AREA ||i.FLASH_DataCacheReset||, CODE, READONLY, ALIGN=2

                  FLASH_DataCacheReset PROC
;;;366      */
;;;367    void FLASH_DataCacheReset(void)
000000  4802              LDR      r0,|L3.12|
;;;368    {
;;;369      FLASH->ACR |= FLASH_ACR_DCRST;
000002  6801              LDR      r1,[r0,#0]
000004  f4415180          ORR      r1,r1,#0x1000
000008  6001              STR      r1,[r0,#0]
;;;370    }
00000a  4770              BX       lr
;;;371    
                          ENDP

                  |L3.12|
                          DCD      0x40023c00

                          AREA ||i.FLASH_EraseAllBank1Sectors||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllBank1Sectors PROC
;;;623      */
;;;624    FLASH_Status FLASH_EraseAllBank1Sectors(uint8_t VoltageRange)
000000  b530              PUSH     {r4,r5,lr}
;;;625    {
000002  4604              MOV      r4,r0
;;;626      uint32_t tmp_psize = 0x0;
000004  2500              MOVS     r5,#0
;;;627      FLASH_Status status = FLASH_COMPLETE;
;;;628      
;;;629      /* Wait for last operation to be completed */
;;;630      status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
;;;631      assert_param(IS_VOLTAGERANGE(VoltageRange));
;;;632      
;;;633      if(VoltageRange == VoltageRange_1)
00000a  b12c              CBZ      r4,|L4.24|
;;;634      {
;;;635         tmp_psize = FLASH_PSIZE_BYTE;
;;;636      }
;;;637      else if(VoltageRange == VoltageRange_2)
00000c  2c01              CMP      r4,#1
00000e  d01c              BEQ      |L4.74|
;;;638      {
;;;639        tmp_psize = FLASH_PSIZE_HALF_WORD;
;;;640      }
;;;641      else if(VoltageRange == VoltageRange_3)
000010  2c02              CMP      r4,#2
000012  d01d              BEQ      |L4.80|
;;;642      {
;;;643        tmp_psize = FLASH_PSIZE_WORD;
;;;644      }
;;;645      else
;;;646      {
;;;647        tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
000014  f44f7540          MOV      r5,#0x300
                  |L4.24|
;;;648      }  
;;;649      if(status == FLASH_COMPLETE)
000018  2809              CMP      r0,#9
00001a  d115              BNE      |L4.72|
;;;650      {
;;;651        /* if the previous operation is completed, proceed to erase all sectors */
;;;652         FLASH->CR &= CR_PSIZE_MASK;
00001c  4c0e              LDR      r4,|L4.88|
00001e  6820              LDR      r0,[r4,#0]
000020  f4207040          BIC      r0,r0,#0x300
000024  6020              STR      r0,[r4,#0]
;;;653         FLASH->CR |= tmp_psize;
000026  6820              LDR      r0,[r4,#0]
000028  4328              ORRS     r0,r0,r5
00002a  6020              STR      r0,[r4,#0]
;;;654         FLASH->CR |= FLASH_CR_MER1;
00002c  6820              LDR      r0,[r4,#0]
00002e  f0400004          ORR      r0,r0,#4
000032  6020              STR      r0,[r4,#0]
;;;655         FLASH->CR |= FLASH_CR_STRT;
000034  6820              LDR      r0,[r4,#0]
000036  f4403080          ORR      r0,r0,#0x10000
00003a  6020              STR      r0,[r4,#0]
;;;656        
;;;657        /* Wait for last operation to be completed */
;;;658        status = FLASH_WaitForLastOperation();
00003c  f7fffffe          BL       FLASH_WaitForLastOperation
;;;659    
;;;660        /* if the erase operation is completed, disable the MER Bit */
;;;661        FLASH->CR &= (~FLASH_CR_MER1);
000040  6821              LDR      r1,[r4,#0]
000042  f0210104          BIC      r1,r1,#4
000046  6021              STR      r1,[r4,#0]
                  |L4.72|
;;;662    
;;;663      }   
;;;664      /* Return the Erase Status */
;;;665      return status;
;;;666    }
000048  bd30              POP      {r4,r5,pc}
                  |L4.74|
00004a  f44f7580          MOV      r5,#0x100             ;639
00004e  e7e3              B        |L4.24|
                  |L4.80|
000050  f44f7500          MOV      r5,#0x200             ;643
000054  e7e0              B        |L4.24|
;;;667    
                          ENDP

000056  0000              DCW      0x0000
                  |L4.88|
                          DCD      0x40023c10

                          AREA ||i.FLASH_EraseAllBank2Sectors||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllBank2Sectors PROC
;;;690      */
;;;691    FLASH_Status FLASH_EraseAllBank2Sectors(uint8_t VoltageRange)
000000  b530              PUSH     {r4,r5,lr}
;;;692    {
000002  4604              MOV      r4,r0
;;;693      uint32_t tmp_psize = 0x0;
000004  2500              MOVS     r5,#0
;;;694      FLASH_Status status = FLASH_COMPLETE;
;;;695      
;;;696      /* Wait for last operation to be completed */
;;;697      status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
;;;698      assert_param(IS_VOLTAGERANGE(VoltageRange));
;;;699      
;;;700      if(VoltageRange == VoltageRange_1)
00000a  b12c              CBZ      r4,|L5.24|
;;;701      {
;;;702         tmp_psize = FLASH_PSIZE_BYTE;
;;;703      }
;;;704      else if(VoltageRange == VoltageRange_2)
00000c  2c01              CMP      r4,#1
00000e  d01c              BEQ      |L5.74|
;;;705      {
;;;706        tmp_psize = FLASH_PSIZE_HALF_WORD;
;;;707      }
;;;708      else if(VoltageRange == VoltageRange_3)
000010  2c02              CMP      r4,#2
000012  d01d              BEQ      |L5.80|
;;;709      {
;;;710        tmp_psize = FLASH_PSIZE_WORD;
;;;711      }
;;;712      else
;;;713      {
;;;714        tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
000014  f44f7540          MOV      r5,#0x300
                  |L5.24|
;;;715      }  
;;;716      if(status == FLASH_COMPLETE)
000018  2809              CMP      r0,#9
00001a  d115              BNE      |L5.72|
;;;717      {
;;;718        /* if the previous operation is completed, proceed to erase all sectors */
;;;719         FLASH->CR &= CR_PSIZE_MASK;
00001c  4c0e              LDR      r4,|L5.88|
00001e  6820              LDR      r0,[r4,#0]
000020  f4207040          BIC      r0,r0,#0x300
000024  6020              STR      r0,[r4,#0]
;;;720         FLASH->CR |= tmp_psize;
000026  6820              LDR      r0,[r4,#0]
000028  4328              ORRS     r0,r0,r5
00002a  6020              STR      r0,[r4,#0]
;;;721         FLASH->CR |= FLASH_CR_MER2;
00002c  6820              LDR      r0,[r4,#0]
00002e  f4404000          ORR      r0,r0,#0x8000
000032  6020              STR      r0,[r4,#0]
;;;722         FLASH->CR |= FLASH_CR_STRT;
000034  6820              LDR      r0,[r4,#0]
000036  f4403080          ORR      r0,r0,#0x10000
00003a  6020              STR      r0,[r4,#0]
;;;723        
;;;724        /* Wait for last operation to be completed */
;;;725        status = FLASH_WaitForLastOperation();
00003c  f7fffffe          BL       FLASH_WaitForLastOperation
;;;726    
;;;727        /* if the erase operation is completed, disable the MER Bit */
;;;728        FLASH->CR &= (~FLASH_CR_MER2);
000040  6821              LDR      r1,[r4,#0]
000042  f4214100          BIC      r1,r1,#0x8000
000046  6021              STR      r1,[r4,#0]
                  |L5.72|
;;;729    
;;;730      }   
;;;731      /* Return the Erase Status */
;;;732      return status;
;;;733    }
000048  bd30              POP      {r4,r5,pc}
                  |L5.74|
00004a  f44f7580          MOV      r5,#0x100             ;706
00004e  e7e3              B        |L5.24|
                  |L5.80|
000050  f44f7500          MOV      r5,#0x200             ;710
000054  e7e0              B        |L5.24|
;;;734    
                          ENDP

000056  0000              DCW      0x0000
                  |L5.88|
                          DCD      0x40023c10

                          AREA ||i.FLASH_EraseAllSectors||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllSectors PROC
;;;542      */
;;;543    FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange)
000000  b530              PUSH     {r4,r5,lr}
;;;544    {
000002  4604              MOV      r4,r0
;;;545      uint32_t tmp_psize = 0x0;
000004  2500              MOVS     r5,#0
;;;546      FLASH_Status status = FLASH_COMPLETE;
;;;547      
;;;548      /* Wait for last operation to be completed */
;;;549      status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
;;;550      assert_param(IS_VOLTAGERANGE(VoltageRange));
;;;551      
;;;552      if(VoltageRange == VoltageRange_1)
00000a  b12c              CBZ      r4,|L6.24|
;;;553      {
;;;554         tmp_psize = FLASH_PSIZE_BYTE;
;;;555      }
;;;556      else if(VoltageRange == VoltageRange_2)
00000c  2c01              CMP      r4,#1
00000e  d01c              BEQ      |L6.74|
;;;557      {
;;;558        tmp_psize = FLASH_PSIZE_HALF_WORD;
;;;559      }
;;;560      else if(VoltageRange == VoltageRange_3)
000010  2c02              CMP      r4,#2
000012  d01d              BEQ      |L6.80|
;;;561      {
;;;562        tmp_psize = FLASH_PSIZE_WORD;
;;;563      }
;;;564      else
;;;565      {
;;;566        tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
000014  f44f7540          MOV      r5,#0x300
                  |L6.24|
;;;567      }  
;;;568      if(status == FLASH_COMPLETE)
000018  2809              CMP      r0,#9
00001a  d115              BNE      |L6.72|
;;;569      {
;;;570        /* if the previous operation is completed, proceed to erase all sectors */
;;;571    #if defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F469_479xx)
;;;572        FLASH->CR &= CR_PSIZE_MASK;
;;;573        FLASH->CR |= tmp_psize;
;;;574        FLASH->CR |= (FLASH_CR_MER1 | FLASH_CR_MER2);
;;;575        FLASH->CR |= FLASH_CR_STRT;
;;;576        
;;;577        /* Wait for last operation to be completed */
;;;578        status = FLASH_WaitForLastOperation();
;;;579    
;;;580        /* if the erase operation is completed, disable the MER Bit */
;;;581        FLASH->CR &= ~(FLASH_CR_MER1 | FLASH_CR_MER2);
;;;582    #endif /* STM32F427_437xx ||  STM32F429_439xx ||  STM32F469_479xx */
;;;583    
;;;584    #if defined(STM32F40_41xxx) || defined(STM32F401xx) || defined(STM32F410xx) || defined(STM32F411xE) || defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
;;;585        FLASH->CR &= CR_PSIZE_MASK;
00001c  4c0e              LDR      r4,|L6.88|
00001e  6820              LDR      r0,[r4,#0]
000020  f4207040          BIC      r0,r0,#0x300
000024  6020              STR      r0,[r4,#0]
;;;586        FLASH->CR |= tmp_psize;
000026  6820              LDR      r0,[r4,#0]
000028  4328              ORRS     r0,r0,r5
00002a  6020              STR      r0,[r4,#0]
;;;587        FLASH->CR |= FLASH_CR_MER;
00002c  6820              LDR      r0,[r4,#0]
00002e  f0400004          ORR      r0,r0,#4
000032  6020              STR      r0,[r4,#0]
;;;588        FLASH->CR |= FLASH_CR_STRT;
000034  6820              LDR      r0,[r4,#0]
000036  f4403080          ORR      r0,r0,#0x10000
00003a  6020              STR      r0,[r4,#0]
;;;589        
;;;590        /* Wait for last operation to be completed */
;;;591        status = FLASH_WaitForLastOperation();
00003c  f7fffffe          BL       FLASH_WaitForLastOperation
;;;592    
;;;593        /* if the erase operation is completed, disable the MER Bit */
;;;594        FLASH->CR &= (~FLASH_CR_MER);
000040  6821              LDR      r1,[r4,#0]
000042  f0210104          BIC      r1,r1,#4
000046  6021              STR      r1,[r4,#0]
                  |L6.72|
;;;595    #endif /* STM32F40_41xxx || STM32F401xx || STM32F410xx || STM32F411xE || STM32F412xG || STM32F413_423xx || STM32F446xx */
;;;596    
;;;597      }   
;;;598      /* Return the Erase Status */
;;;599      return status;
;;;600    }
000048  bd30              POP      {r4,r5,pc}
                  |L6.74|
00004a  f44f7580          MOV      r5,#0x100             ;558
00004e  e7e3              B        |L6.24|
                  |L6.80|
000050  f44f7500          MOV      r5,#0x200             ;562
000054  e7e0              B        |L6.24|
;;;601    
                          ENDP

000056  0000              DCW      0x0000
                  |L6.88|
                          DCD      0x40023c10

                          AREA ||i.FLASH_EraseSector||, CODE, READONLY, ALIGN=2

                  FLASH_EraseSector PROC
;;;474      */
;;;475    FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
000000  b570              PUSH     {r4-r6,lr}
;;;476    {
000002  4606              MOV      r6,r0
;;;477      uint32_t tmp_psize = 0x0;
000004  2500              MOVS     r5,#0
000006  b129              CBZ      r1,|L7.20|
;;;478      FLASH_Status status = FLASH_COMPLETE;
;;;479    
;;;480      /* Check the parameters */
;;;481      assert_param(IS_FLASH_SECTOR(FLASH_Sector));
;;;482      assert_param(IS_VOLTAGERANGE(VoltageRange));
;;;483      
;;;484      if(VoltageRange == VoltageRange_1)
;;;485      {
;;;486         tmp_psize = FLASH_PSIZE_BYTE;
;;;487      }
;;;488      else if(VoltageRange == VoltageRange_2)
000008  2901              CMP      r1,#1
00000a  d027              BEQ      |L7.92|
;;;489      {
;;;490        tmp_psize = FLASH_PSIZE_HALF_WORD;
;;;491      }
;;;492      else if(VoltageRange == VoltageRange_3)
00000c  2902              CMP      r1,#2
00000e  d028              BEQ      |L7.98|
;;;493      {
;;;494        tmp_psize = FLASH_PSIZE_WORD;
;;;495      }
;;;496      else
;;;497      {
;;;498        tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
000010  f44f7540          MOV      r5,#0x300
                  |L7.20|
;;;499      }
;;;500      /* Wait for last operation to be completed */
;;;501      status = FLASH_WaitForLastOperation();
000014  f7fffffe          BL       FLASH_WaitForLastOperation
;;;502      
;;;503      if(status == FLASH_COMPLETE)
000018  2809              CMP      r0,#9
00001a  d11e              BNE      |L7.90|
;;;504      { 
;;;505        /* if the previous operation is completed, proceed to erase the sector */
;;;506        FLASH->CR &= CR_PSIZE_MASK;
00001c  4c12              LDR      r4,|L7.104|
00001e  6820              LDR      r0,[r4,#0]
000020  f4207040          BIC      r0,r0,#0x300
000024  6020              STR      r0,[r4,#0]
;;;507        FLASH->CR |= tmp_psize;
000026  6820              LDR      r0,[r4,#0]
000028  4328              ORRS     r0,r0,r5
00002a  6020              STR      r0,[r4,#0]
;;;508        FLASH->CR &= SECTOR_MASK;
00002c  6820              LDR      r0,[r4,#0]
00002e  f02000f8          BIC      r0,r0,#0xf8
000032  6020              STR      r0,[r4,#0]
;;;509        FLASH->CR |= FLASH_CR_SER | FLASH_Sector;
000034  6820              LDR      r0,[r4,#0]
000036  f0460102          ORR      r1,r6,#2
00003a  4308              ORRS     r0,r0,r1
00003c  6020              STR      r0,[r4,#0]
;;;510        FLASH->CR |= FLASH_CR_STRT;
00003e  6820              LDR      r0,[r4,#0]
000040  f4403080          ORR      r0,r0,#0x10000
000044  6020              STR      r0,[r4,#0]
;;;511        
;;;512        /* Wait for last operation to be completed */
;;;513        status = FLASH_WaitForLastOperation();
000046  f7fffffe          BL       FLASH_WaitForLastOperation
;;;514        
;;;515        /* if the erase operation is completed, disable the SER Bit */
;;;516        FLASH->CR &= (~FLASH_CR_SER);
00004a  6821              LDR      r1,[r4,#0]
00004c  f0210102          BIC      r1,r1,#2
000050  6021              STR      r1,[r4,#0]
;;;517        FLASH->CR &= SECTOR_MASK; 
000052  6821              LDR      r1,[r4,#0]
000054  f02101f8          BIC      r1,r1,#0xf8
000058  6021              STR      r1,[r4,#0]
                  |L7.90|
;;;518      }
;;;519      /* Return the Erase Status */
;;;520      return status;
;;;521    }
00005a  bd70              POP      {r4-r6,pc}
                  |L7.92|
00005c  f44f7580          MOV      r5,#0x100             ;490
000060  e7d8              B        |L7.20|
                  |L7.98|
000062  f44f7500          MOV      r5,#0x200             ;494
000066  e7d5              B        |L7.20|
;;;522    
                          ENDP

                  |L7.104|
                          DCD      0x40023c10

                          AREA ||i.FLASH_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetFlagStatus PROC
;;;1488     */
;;;1489   FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
000000  4a03              LDR      r2,|L8.16|
;;;1490   {
000002  4601              MOV      r1,r0
;;;1491     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1492     /* Check the parameters */
;;;1493     assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG));
;;;1494   
;;;1495     if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
000006  6812              LDR      r2,[r2,#0]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L8.14|
;;;1496     {
;;;1497       bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L8.14|
;;;1498     }
;;;1499     else
;;;1500     {
;;;1501       bitstatus = RESET;
;;;1502     }
;;;1503     /* Return the new state of FLASH_FLAG (SET or RESET) */
;;;1504     return bitstatus; 
;;;1505   }
00000e  4770              BX       lr
;;;1506   
                          ENDP

                  |L8.16|
                          DCD      0x40023c0c

                          AREA ||i.FLASH_GetStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetStatus PROC
;;;1534     */
;;;1535   FLASH_Status FLASH_GetStatus(void)
000000  490d              LDR      r1,|L9.56|
;;;1536   {
;;;1537     FLASH_Status flashstatus = FLASH_COMPLETE;
000002  2009              MOVS     r0,#9
;;;1538     
;;;1539     if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
000004  680a              LDR      r2,[r1,#0]
000006  03d2              LSLS     r2,r2,#15
000008  d501              BPL      |L9.14|
;;;1540     {
;;;1541       flashstatus = FLASH_BUSY;
00000a  2001              MOVS     r0,#1
;;;1542     }
;;;1543     else 
;;;1544     {  
;;;1545       if((FLASH->SR & FLASH_FLAG_WRPERR) != (uint32_t)0x00)
;;;1546       { 
;;;1547         flashstatus = FLASH_ERROR_WRP;
;;;1548       }
;;;1549       else
;;;1550       {
;;;1551         if((FLASH->SR & FLASH_FLAG_RDERR) != (uint32_t)0x00)
;;;1552         { 
;;;1553           flashstatus = FLASH_ERROR_RD;
;;;1554         } 
;;;1555         else 
;;;1556         {
;;;1557           if((FLASH->SR & (uint32_t)0xE0) != (uint32_t)0x00)
;;;1558           {
;;;1559             flashstatus = FLASH_ERROR_PROGRAM; 
;;;1560           }
;;;1561           else
;;;1562           {
;;;1563             if((FLASH->SR & FLASH_FLAG_OPERR) != (uint32_t)0x00)
;;;1564             {
;;;1565               flashstatus = FLASH_ERROR_OPERATION;
;;;1566             }
;;;1567             else
;;;1568             {
;;;1569               flashstatus = FLASH_COMPLETE;
;;;1570             }
;;;1571           }
;;;1572         }
;;;1573       }
;;;1574     }
;;;1575     /* Return the FLASH Status */
;;;1576     return flashstatus;
;;;1577   }
00000c  4770              BX       lr
                  |L9.14|
00000e  680a              LDR      r2,[r1,#0]            ;1545
000010  06d2              LSLS     r2,r2,#27             ;1545
000012  d501              BPL      |L9.24|
000014  2006              MOVS     r0,#6                 ;1547
000016  4770              BX       lr
                  |L9.24|
000018  680a              LDR      r2,[r1,#0]            ;1551
00001a  05d2              LSLS     r2,r2,#23             ;1551
00001c  d501              BPL      |L9.34|
00001e  2002              MOVS     r0,#2                 ;1553
000020  4770              BX       lr
                  |L9.34|
000022  680a              LDR      r2,[r1,#0]            ;1557
000024  f0120fe0          TST      r2,#0xe0              ;1557
000028  d001              BEQ      |L9.46|
00002a  2007              MOVS     r0,#7                 ;1559
                  |L9.44|
00002c  4770              BX       lr
                  |L9.46|
00002e  6809              LDR      r1,[r1,#0]            ;1563
000030  0789              LSLS     r1,r1,#30             ;1563
000032  d5fb              BPL      |L9.44|
000034  2008              MOVS     r0,#8                 ;1565
000036  4770              BX       lr
;;;1578   
                          ENDP

                  |L9.56|
                          DCD      0x40023c0c

                          AREA ||i.FLASH_ITConfig||, CODE, READONLY, ALIGN=2

                  FLASH_ITConfig PROC
;;;1456     */
;;;1457   void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L10.20|
;;;1458   {
;;;1459     /* Check the parameters */
;;;1460     assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;1461     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1462   
;;;1463     if(NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1464     {
;;;1465       /* Enable the interrupt sources */
;;;1466       FLASH->CR |= FLASH_IT;
;;;1467     }
;;;1468     else
;;;1469     {
;;;1470       /* Disable the interrupt sources */
;;;1471       FLASH->CR &= ~(uint32_t)FLASH_IT;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L10.12|
000008  4301              ORRS     r1,r1,r0              ;1466
00000a  e000              B        |L10.14|
                  |L10.12|
00000c  4381              BICS     r1,r1,r0
                  |L10.14|
00000e  6011              STR      r1,[r2,#0]            ;1466
;;;1472     }
;;;1473   }
000010  4770              BX       lr
;;;1474   
                          ENDP

000012  0000              DCW      0x0000
                  |L10.20|
                          DCD      0x40023c10

                          AREA ||i.FLASH_InstructionCacheCmd||, CODE, READONLY, ALIGN=2

                  FLASH_InstructionCacheCmd PROC
;;;313      */
;;;314    void FLASH_InstructionCacheCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L11.24|
;;;315    {
;;;316      /* Check the parameters */
;;;317      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;318      
;;;319      if(NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;320      {
;;;321        FLASH->ACR |= FLASH_ACR_ICEN;
;;;322      }
;;;323      else
;;;324      {
;;;325        FLASH->ACR &= (~FLASH_ACR_ICEN);
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L11.14|
000008  f4407000          ORR      r0,r0,#0x200          ;321
00000c  e001              B        |L11.18|
                  |L11.14|
00000e  f4207000          BIC      r0,r0,#0x200
                  |L11.18|
000012  6008              STR      r0,[r1,#0]            ;321
;;;326      }
;;;327    }
000014  4770              BX       lr
;;;328    
                          ENDP

000016  0000              DCW      0x0000
                  |L11.24|
                          DCD      0x40023c00

                          AREA ||i.FLASH_InstructionCacheReset||, CODE, READONLY, ALIGN=2

                  FLASH_InstructionCacheReset PROC
;;;355      */
;;;356    void FLASH_InstructionCacheReset(void)
000000  4802              LDR      r0,|L12.12|
;;;357    {
;;;358      FLASH->ACR |= FLASH_ACR_ICRST;
000002  6801              LDR      r1,[r0,#0]
000004  f4416100          ORR      r1,r1,#0x800
000008  6001              STR      r1,[r0,#0]
;;;359    }
00000a  4770              BX       lr
;;;360    
                          ENDP

                  |L12.12|
                          DCD      0x40023c00

                          AREA ||i.FLASH_Lock||, CODE, READONLY, ALIGN=2

                  FLASH_Lock PROC
;;;428      */
;;;429    void FLASH_Lock(void)
000000  4802              LDR      r0,|L13.12|
;;;430    {
;;;431      /* Set the LOCK Bit to lock the FLASH Registers access */
;;;432      FLASH->CR |= FLASH_CR_LOCK;
000002  6801              LDR      r1,[r0,#0]
000004  f0414100          ORR      r1,r1,#0x80000000
000008  6001              STR      r1,[r0,#0]
;;;433    }
00000a  4770              BX       lr
;;;434    
                          ENDP

                  |L13.12|
                          DCD      0x40023c10

                          AREA ||i.FLASH_OB_BORConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_BORConfig PROC
;;;1301     */
;;;1302   void FLASH_OB_BORConfig(uint8_t OB_BOR)
000000  4904              LDR      r1,|L14.20|
;;;1303   {
;;;1304     /* Check the parameters */
;;;1305     assert_param(IS_OB_BOR(OB_BOR));
;;;1306   
;;;1307     /* Set the BOR Level */
;;;1308     *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BOR_LEV);
000002  780a              LDRB     r2,[r1,#0]
000004  f022020c          BIC      r2,r2,#0xc
000008  700a              STRB     r2,[r1,#0]
;;;1309     *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOR;
00000a  780a              LDRB     r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  700a              STRB     r2,[r1,#0]
;;;1310   
;;;1311   }
000010  4770              BX       lr
;;;1312   
                          ENDP

000012  0000              DCW      0x0000
                  |L14.20|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_BootConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_BootConfig PROC
;;;1280     */
;;;1281   void FLASH_OB_BootConfig(uint8_t OB_BOOT)
000000  4904              LDR      r1,|L15.20|
;;;1282   {
;;;1283     /* Check the parameters */
;;;1284     assert_param(IS_OB_BOOT(OB_BOOT));
;;;1285   
;;;1286     /* Set Dual Bank Boot */
;;;1287     *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BFB2);
000002  780a              LDRB     r2,[r1,#0]
000004  f0220210          BIC      r2,r2,#0x10
000008  700a              STRB     r2,[r1,#0]
;;;1288     *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOOT;
00000a  780a              LDRB     r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  700a              STRB     r2,[r1,#0]
;;;1289   
;;;1290   }
000010  4770              BX       lr
;;;1291   
                          ENDP

000012  0000              DCW      0x0000
                  |L15.20|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_GetBOR||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetBOR PROC
;;;1427     */
;;;1428   uint8_t FLASH_OB_GetBOR(void)
000000  4802              LDR      r0,|L16.12|
;;;1429   {
;;;1430     /* Return the FLASH BOR level */
;;;1431     return (uint8_t)(*(__IO uint8_t *)(OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0C);
000002  7800              LDRB     r0,[r0,#0]
000004  f000000c          AND      r0,r0,#0xc
;;;1432   }
000008  4770              BX       lr
;;;1433   
                          ENDP

00000a  0000              DCW      0x0000
                  |L16.12|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_GetPCROP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetPCROP PROC
;;;1376     */
;;;1377   uint16_t FLASH_OB_GetPCROP(void)
000000  4801              LDR      r0,|L17.8|
;;;1378   {
;;;1379     /* Return the FLASH PC Read/write protection Register value */
;;;1380     return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
000002  8800              LDRH     r0,[r0,#0]
;;;1381   }
000004  4770              BX       lr
;;;1382   
                          ENDP

000006  0000              DCW      0x0000
                  |L17.8|
                          DCD      0x40023c16

                          AREA ||i.FLASH_OB_GetPCROP1||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetPCROP1 PROC
;;;1390     */
;;;1391   uint16_t FLASH_OB_GetPCROP1(void)
000000  4801              LDR      r0,|L18.8|
;;;1392   {
;;;1393     /* Return the FLASH write protection Register value */
;;;1394     return (*(__IO uint16_t *)(OPTCR1_BYTE2_ADDRESS));
000002  8800              LDRH     r0,[r0,#0]
;;;1395   }
000004  4770              BX       lr
;;;1396   
                          ENDP

000006  0000              DCW      0x0000
                  |L18.8|
                          DCD      0x40023c1a

                          AREA ||i.FLASH_OB_GetRDP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetRDP PROC
;;;1403     */
;;;1404   FlagStatus FLASH_OB_GetRDP(void)
000000  4903              LDR      r1,|L19.16|
;;;1405   {
;;;1406     FlagStatus readstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1407   
;;;1408     if ((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS) != (uint8_t)OB_RDP_Level_0))
000004  7809              LDRB     r1,[r1,#0]
000006  29aa              CMP      r1,#0xaa
000008  d000              BEQ      |L19.12|
;;;1409     {
;;;1410       readstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L19.12|
;;;1411     }
;;;1412     else
;;;1413     {
;;;1414       readstatus = RESET;
;;;1415     }
;;;1416     return readstatus;
;;;1417   }
00000c  4770              BX       lr
;;;1418   
                          ENDP

00000e  0000              DCW      0x0000
                  |L19.16|
                          DCD      0x40023c15

                          AREA ||i.FLASH_OB_GetUser||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetUser PROC
;;;1337     */
;;;1338   uint8_t FLASH_OB_GetUser(void)
000000  4802              LDR      r0,|L20.12|
;;;1339   {
;;;1340     /* Return the User Option Byte */
;;;1341     return (uint8_t)(FLASH->OPTCR >> 5);
000002  6800              LDR      r0,[r0,#0]
000004  f3c01047          UBFX     r0,r0,#5,#8
;;;1342   }
000008  4770              BX       lr
;;;1343   
                          ENDP

00000a  0000              DCW      0x0000
                  |L20.12|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_GetWRP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetWRP PROC
;;;1348     */
;;;1349   uint16_t FLASH_OB_GetWRP(void)
000000  4801              LDR      r0,|L21.8|
;;;1350   {
;;;1351     /* Return the FLASH write protection Register value */
;;;1352     return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
000002  8800              LDRH     r0,[r0,#0]
;;;1353   }
000004  4770              BX       lr
;;;1354   
                          ENDP

000006  0000              DCW      0x0000
                  |L21.8|
                          DCD      0x40023c16

                          AREA ||i.FLASH_OB_GetWRP1||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetWRP1 PROC
;;;1362     */
;;;1363   uint16_t FLASH_OB_GetWRP1(void)
000000  4801              LDR      r0,|L22.8|
;;;1364   {
;;;1365     /* Return the FLASH write protection Register value */
;;;1366     return (*(__IO uint16_t *)(OPTCR1_BYTE2_ADDRESS));
000002  8800              LDRH     r0,[r0,#0]
;;;1367   }
000004  4770              BX       lr
;;;1368   
                          ENDP

000006  0000              DCW      0x0000
                  |L22.8|
                          DCD      0x40023c1a

                          AREA ||i.FLASH_OB_Launch||, CODE, READONLY, ALIGN=2

                  FLASH_OB_Launch PROC
;;;1318     */
;;;1319   FLASH_Status FLASH_OB_Launch(void)
000000  4803              LDR      r0,|L23.16|
;;;1320   {
;;;1321     FLASH_Status status = FLASH_COMPLETE;
;;;1322   
;;;1323     /* Set the OPTSTRT bit in OPTCR register */
;;;1324     *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= FLASH_OPTCR_OPTSTRT;
000002  7801              LDRB     r1,[r0,#0]
000004  f0410102          ORR      r1,r1,#2
000008  7001              STRB     r1,[r0,#0]
;;;1325   
;;;1326     /* Wait for last operation to be completed */
;;;1327     status = FLASH_WaitForLastOperation();
00000a  f7ffbffe          B.W      FLASH_WaitForLastOperation
;;;1328   
;;;1329     return status;
;;;1330   }
;;;1331   
                          ENDP

00000e  0000              DCW      0x0000
                  |L23.16|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_Lock||, CODE, READONLY, ALIGN=2

                  FLASH_OB_Lock PROC
;;;988      */
;;;989    void FLASH_OB_Lock(void)
000000  4802              LDR      r0,|L24.12|
;;;990    {
;;;991      /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
;;;992      FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
000002  6801              LDR      r1,[r0,#0]
000004  f0410101          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;993    }
00000a  4770              BX       lr
;;;994    
                          ENDP

                  |L24.12|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_PCROP1Config||, CODE, READONLY, ALIGN=2

                  FLASH_OB_PCROP1Config PROC
;;;1171     */
;;;1172   void FLASH_OB_PCROP1Config(uint32_t OB_PCROP, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;1173   { 
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;1174     FLASH_Status status = FLASH_COMPLETE;
;;;1175     
;;;1176     /* Check the parameters */
;;;1177     assert_param(IS_OB_PCROP(OB_PCROP));
;;;1178     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1179       
;;;1180     status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1181   
;;;1182     if(status == FLASH_COMPLETE)
00000a  2809              CMP      r0,#9
00000c  d106              BNE      |L25.28|
;;;1183     { 
;;;1184       if(NewState != DISABLE)
;;;1185       {
;;;1186         *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS |= (uint16_t)OB_PCROP;
00000e  4804              LDR      r0,|L25.32|
;;;1187       }
;;;1188       else
;;;1189       {
;;;1190         *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS &= (~OB_PCROP);
000010  8801              LDRH     r1,[r0,#0]
000012  b10d              CBZ      r5,|L25.24|
000014  4321              ORRS     r1,r1,r4              ;1186
000016  e000              B        |L25.26|
                  |L25.24|
000018  43a1              BICS     r1,r1,r4
                  |L25.26|
00001a  8001              STRH     r1,[r0,#0]
                  |L25.28|
;;;1191       }
;;;1192     }
;;;1193   }
00001c  bd30              POP      {r4,r5,pc}
;;;1194   
                          ENDP

00001e  0000              DCW      0x0000
                  |L25.32|
                          DCD      0x40023c1a

                          AREA ||i.FLASH_OB_PCROPConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_PCROPConfig PROC
;;;1134     */
;;;1135   void FLASH_OB_PCROPConfig(uint32_t OB_PCROP, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;1136   { 
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;1137     FLASH_Status status = FLASH_COMPLETE;
;;;1138     
;;;1139     /* Check the parameters */
;;;1140     assert_param(IS_OB_PCROP(OB_PCROP));
;;;1141     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1142       
;;;1143     status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1144   
;;;1145     if(status == FLASH_COMPLETE)
00000a  2809              CMP      r0,#9
00000c  d106              BNE      |L26.28|
;;;1146     { 
;;;1147       if(NewState != DISABLE)
;;;1148       {
;;;1149         *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_PCROP;    
00000e  4804              LDR      r0,|L26.32|
;;;1150       }
;;;1151       else
;;;1152       {
;;;1153         *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_PCROP);
000010  8801              LDRH     r1,[r0,#0]
000012  b10d              CBZ      r5,|L26.24|
000014  4321              ORRS     r1,r1,r4              ;1149
000016  e000              B        |L26.26|
                  |L26.24|
000018  43a1              BICS     r1,r1,r4
                  |L26.26|
00001a  8001              STRH     r1,[r0,#0]
                  |L26.28|
;;;1154       }
;;;1155     }
;;;1156   }
00001c  bd30              POP      {r4,r5,pc}
;;;1157   
                          ENDP

00001e  0000              DCW      0x0000
                  |L26.32|
                          DCD      0x40023c16

                          AREA ||i.FLASH_OB_PCROPSelectionConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_PCROPSelectionConfig PROC
;;;1103     */
;;;1104   void FLASH_OB_PCROPSelectionConfig(uint8_t OB_PcROP)
000000  4a03              LDR      r2,|L27.16|
;;;1105   {  
;;;1106     uint8_t optiontmp = 0xFF;
;;;1107         
;;;1108     /* Check the parameters */
;;;1109     assert_param(IS_OB_PCROP_SELECT(OB_PcROP));
;;;1110     
;;;1111     /* Mask SPRMOD bit */
;;;1112     optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE3_ADDRESS) & (uint8_t)0x7F); 
000002  7811              LDRB     r1,[r2,#0]
000004  f001017f          AND      r1,r1,#0x7f
;;;1113     /* Update Option Byte */
;;;1114     *(__IO uint8_t *)OPTCR_BYTE3_ADDRESS = (uint8_t)(OB_PcROP | optiontmp); 
000008  4308              ORRS     r0,r0,r1
00000a  7010              STRB     r0,[r2,#0]
;;;1115       
;;;1116   }
00000c  4770              BX       lr
;;;1117   
                          ENDP

00000e  0000              DCW      0x0000
                  |L27.16|
                          DCD      0x40023c17

                          AREA ||i.FLASH_OB_RDPConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_RDPConfig PROC
;;;1207     */
;;;1208   void FLASH_OB_RDPConfig(uint8_t OB_RDP)
000000  b510              PUSH     {r4,lr}
;;;1209   {
000002  4604              MOV      r4,r0
;;;1210     FLASH_Status status = FLASH_COMPLETE;
;;;1211   
;;;1212     /* Check the parameters */
;;;1213     assert_param(IS_OB_RDP(OB_RDP));
;;;1214   
;;;1215     status = FLASH_WaitForLastOperation();
000004  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1216   
;;;1217     if(status == FLASH_COMPLETE)
000008  2809              CMP      r0,#9
00000a  d101              BNE      |L28.16|
;;;1218     {
;;;1219       *(__IO uint8_t*)OPTCR_BYTE1_ADDRESS = OB_RDP;
00000c  4801              LDR      r0,|L28.20|
00000e  7004              STRB     r4,[r0,#0]
                  |L28.16|
;;;1220   
;;;1221     }
;;;1222   }
000010  bd10              POP      {r4,pc}
;;;1223   
                          ENDP

000012  0000              DCW      0x0000
                  |L28.20|
                          DCD      0x40023c15

                          AREA ||i.FLASH_OB_Unlock||, CODE, READONLY, ALIGN=2

                  FLASH_OB_Unlock PROC
;;;973      */
;;;974    void FLASH_OB_Unlock(void)
000000  4805              LDR      r0,|L29.24|
;;;975    {
;;;976      if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
000002  6800              LDR      r0,[r0,#0]
000004  07c0              LSLS     r0,r0,#31
000006  d005              BEQ      |L29.20|
;;;977      {
;;;978        /* Authorizes the Option Byte register programming */
;;;979        FLASH->OPTKEYR = FLASH_OPT_KEY1;
000008  4803              LDR      r0,|L29.24|
00000a  4904              LDR      r1,|L29.28|
00000c  380c              SUBS     r0,r0,#0xc
00000e  6001              STR      r1,[r0,#0]
;;;980        FLASH->OPTKEYR = FLASH_OPT_KEY2;
000010  4903              LDR      r1,|L29.32|
000012  6001              STR      r1,[r0,#0]
                  |L29.20|
;;;981      }  
;;;982    }
000014  4770              BX       lr
;;;983    
                          ENDP

000016  0000              DCW      0x0000
                  |L29.24|
                          DCD      0x40023c14
                  |L29.28|
                          DCD      0x08192a3b
                  |L29.32|
                          DCD      0x4c5d6e7f

                          AREA ||i.FLASH_OB_UserConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_UserConfig PROC
;;;1239     */
;;;1240   void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
000000  b570              PUSH     {r4-r6,lr}
;;;1241   {
000002  4615              MOV      r5,r2
000004  460c              MOV      r4,r1
000006  4606              MOV      r6,r0
;;;1242     uint8_t optiontmp = 0xFF;
;;;1243     FLASH_Status status = FLASH_COMPLETE; 
;;;1244   
;;;1245     /* Check the parameters */
;;;1246     assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
;;;1247     assert_param(IS_OB_STOP_SOURCE(OB_STOP));
;;;1248     assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
;;;1249   
;;;1250     /* Wait for last operation to be completed */
;;;1251     status = FLASH_WaitForLastOperation();
000008  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1252     
;;;1253     if(status == FLASH_COMPLETE)
00000c  2809              CMP      r0,#9
00000e  d107              BNE      |L30.32|
;;;1254     { 
;;;1255   #if defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F469_479xx)
;;;1256       /* Mask OPTLOCK, OPTSTRT, BOR_LEV and BFB2 bits */
;;;1257       optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x1F);
;;;1258   #endif /* STM32F427_437xx ||  STM32F429_439xx ||  STM32F469_479xx */
;;;1259   
;;;1260   #if defined(STM32F40_41xxx) || defined(STM32F401xx) || defined(STM32F410xx) || defined(STM32F411xE) || defined(STM32F446xx)
;;;1261       /* Mask OPTLOCK, OPTSTRT and BOR_LEV bits */
;;;1262       optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0F); 
000010  4904              LDR      r1,|L30.36|
000012  7808              LDRB     r0,[r1,#0]
000014  f000000f          AND      r0,r0,#0xf
;;;1263   #endif /* STM32F40_41xxx || STM32F401xx || STM32F410xx || STM32F411xE || STM32F446xx */ 
;;;1264   
;;;1265       /* Update User Option Byte */
;;;1266       *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS = OB_IWDG | (uint8_t)(OB_STDBY | (uint8_t)(OB_STOP | ((uint8_t)optiontmp))); 
000018  4304              ORRS     r4,r4,r0
00001a  432c              ORRS     r4,r4,r5
00001c  4334              ORRS     r4,r4,r6
00001e  700c              STRB     r4,[r1,#0]
                  |L30.32|
;;;1267     }  
;;;1268   }
000020  bd70              POP      {r4-r6,pc}
;;;1269   
                          ENDP

000022  0000              DCW      0x0000
                  |L30.36|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_WRP1Config||, CODE, READONLY, ALIGN=2

                  FLASH_OB_WRP1Config PROC
;;;1053     */
;;;1054   void FLASH_OB_WRP1Config(uint32_t OB_WRP, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;1055   { 
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;1056     FLASH_Status status = FLASH_COMPLETE;
;;;1057     
;;;1058     /* Check the parameters */
;;;1059     assert_param(IS_OB_WRP(OB_WRP));
;;;1060     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1061       
;;;1062     status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1063   
;;;1064     if(status == FLASH_COMPLETE)
00000a  2809              CMP      r0,#9
00000c  d106              BNE      |L31.28|
;;;1065     { 
;;;1066       if(NewState != DISABLE)
;;;1067       {
;;;1068         *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS &= (~OB_WRP);
00000e  4804              LDR      r0,|L31.32|
;;;1069       }
;;;1070       else
;;;1071       {
;;;1072         *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
000010  8801              LDRH     r1,[r0,#0]
000012  b10d              CBZ      r5,|L31.24|
000014  43a1              BICS     r1,r1,r4              ;1068
000016  e000              B        |L31.26|
                  |L31.24|
000018  4321              ORRS     r1,r1,r4
                  |L31.26|
00001a  8001              STRH     r1,[r0,#0]
                  |L31.28|
;;;1073       }
;;;1074     }
;;;1075   }
00001c  bd30              POP      {r4,r5,pc}
;;;1076   
                          ENDP

00001e  0000              DCW      0x0000
                  |L31.32|
                          DCD      0x40023c1a

                          AREA ||i.FLASH_OB_WRPConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_WRPConfig PROC
;;;1011     */
;;;1012   void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;1013   { 
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;1014     FLASH_Status status = FLASH_COMPLETE;
;;;1015     
;;;1016     /* Check the parameters */
;;;1017     assert_param(IS_OB_WRP(OB_WRP));
;;;1018     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1019       
;;;1020     status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1021   
;;;1022     if(status == FLASH_COMPLETE)
00000a  2809              CMP      r0,#9
00000c  d106              BNE      |L32.28|
;;;1023     { 
;;;1024       if(NewState != DISABLE)
;;;1025       {
;;;1026         *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_WRP);
00000e  4804              LDR      r0,|L32.32|
;;;1027       }
;;;1028       else
;;;1029       {
;;;1030         *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
000010  8801              LDRH     r1,[r0,#0]
000012  b10d              CBZ      r5,|L32.24|
000014  43a1              BICS     r1,r1,r4              ;1026
000016  e000              B        |L32.26|
                  |L32.24|
000018  4321              ORRS     r1,r1,r4
                  |L32.26|
00001a  8001              STRH     r1,[r0,#0]
                  |L32.28|
;;;1031       }
;;;1032     }
;;;1033   }
00001c  bd30              POP      {r4,r5,pc}
;;;1034   
                          ENDP

00001e  0000              DCW      0x0000
                  |L32.32|
                          DCD      0x40023c16

                          AREA ||i.FLASH_PrefetchBufferCmd||, CODE, READONLY, ALIGN=2

                  FLASH_PrefetchBufferCmd PROC
;;;291      */
;;;292    void FLASH_PrefetchBufferCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L33.24|
;;;293    {
;;;294      /* Check the parameters */
;;;295      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;296      
;;;297      /* Enable or disable the Prefetch Buffer */
;;;298      if(NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;299      {
;;;300        FLASH->ACR |= FLASH_ACR_PRFTEN;
;;;301      }
;;;302      else
;;;303      {
;;;304        FLASH->ACR &= (~FLASH_ACR_PRFTEN);
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L33.14|
000008  f4407080          ORR      r0,r0,#0x100          ;300
00000c  e001              B        |L33.18|
                  |L33.14|
00000e  f4207080          BIC      r0,r0,#0x100
                  |L33.18|
000012  6008              STR      r0,[r1,#0]            ;300
;;;305      }
;;;306    }
000014  4770              BX       lr
;;;307    
                          ENDP

000016  0000              DCW      0x0000
                  |L33.24|
                          DCD      0x40023c00

                          AREA ||i.FLASH_ProgramByte||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramByte PROC
;;;874      */
;;;875    FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;876    {
000002  460d              MOV      r5,r1
000004  4606              MOV      r6,r0
;;;877      FLASH_Status status = FLASH_COMPLETE;
;;;878    
;;;879      /* Check the parameters */
;;;880      assert_param(IS_FLASH_ADDRESS(Address));
;;;881    
;;;882      /* Wait for last operation to be completed */
;;;883      status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
;;;884      
;;;885      if(status == FLASH_COMPLETE)
00000a  2809              CMP      r0,#9
00000c  d111              BNE      |L34.50|
;;;886      {
;;;887        /* if the previous operation is completed, proceed to program the new data */
;;;888        FLASH->CR &= CR_PSIZE_MASK;
00000e  4c09              LDR      r4,|L34.52|
000010  6820              LDR      r0,[r4,#0]
000012  f4207040          BIC      r0,r0,#0x300
000016  6020              STR      r0,[r4,#0]
;;;889        FLASH->CR |= FLASH_PSIZE_BYTE;
000018  6820              LDR      r0,[r4,#0]
00001a  6020              STR      r0,[r4,#0]
;;;890        FLASH->CR |= FLASH_CR_PG;
00001c  6820              LDR      r0,[r4,#0]
00001e  f0400001          ORR      r0,r0,#1
000022  6020              STR      r0,[r4,#0]
;;;891      
;;;892        *(__IO uint8_t*)Address = Data;
000024  7035              STRB     r5,[r6,#0]
;;;893            
;;;894        /* Wait for last operation to be completed */
;;;895        status = FLASH_WaitForLastOperation();
000026  f7fffffe          BL       FLASH_WaitForLastOperation
;;;896    
;;;897        /* if the program operation is completed, disable the PG Bit */
;;;898        FLASH->CR &= (~FLASH_CR_PG);
00002a  6821              LDR      r1,[r4,#0]
00002c  f0210101          BIC      r1,r1,#1
000030  6021              STR      r1,[r4,#0]
                  |L34.50|
;;;899      } 
;;;900    
;;;901      /* Return the Program Status */
;;;902      return status;
;;;903    }
000032  bd70              POP      {r4-r6,pc}
;;;904    
                          ENDP

                  |L34.52|
                          DCD      0x40023c10

                          AREA ||i.FLASH_ProgramDoubleWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramDoubleWord PROC
;;;747      */
;;;748    FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;749    {
000002  4615              MOV      r5,r2
000004  461e              MOV      r6,r3
000006  4607              MOV      r7,r0
;;;750      FLASH_Status status = FLASH_COMPLETE;
;;;751    
;;;752      /* Check the parameters */
;;;753      assert_param(IS_FLASH_ADDRESS(Address));
;;;754    
;;;755      /* Wait for last operation to be completed */
;;;756      status = FLASH_WaitForLastOperation();
000008  f7fffffe          BL       FLASH_WaitForLastOperation
;;;757      
;;;758      if(status == FLASH_COMPLETE)
00000c  2809              CMP      r0,#9
00000e  d114              BNE      |L35.58|
;;;759      {
;;;760        /* if the previous operation is completed, proceed to program the new data */
;;;761        FLASH->CR &= CR_PSIZE_MASK;
000010  4c0a              LDR      r4,|L35.60|
000012  6820              LDR      r0,[r4,#0]
000014  f4207040          BIC      r0,r0,#0x300
000018  6020              STR      r0,[r4,#0]
;;;762        FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
00001a  6820              LDR      r0,[r4,#0]
00001c  f4407040          ORR      r0,r0,#0x300
000020  6020              STR      r0,[r4,#0]
;;;763        FLASH->CR |= FLASH_CR_PG;
000022  6820              LDR      r0,[r4,#0]
000024  f0400001          ORR      r0,r0,#1
000028  6020              STR      r0,[r4,#0]
;;;764      
;;;765        *(__IO uint64_t*)Address = Data;
00002a  603d              STR      r5,[r7,#0]
00002c  607e              STR      r6,[r7,#4]
;;;766            
;;;767        /* Wait for last operation to be completed */
;;;768        status = FLASH_WaitForLastOperation();
00002e  f7fffffe          BL       FLASH_WaitForLastOperation
;;;769    
;;;770        /* if the program operation is completed, disable the PG Bit */
;;;771        FLASH->CR &= (~FLASH_CR_PG);
000032  6821              LDR      r1,[r4,#0]
000034  f0210101          BIC      r1,r1,#1
000038  6021              STR      r1,[r4,#0]
                  |L35.58|
;;;772      } 
;;;773      /* Return the Program Status */
;;;774      return status;
;;;775    }
00003a  bdf0              POP      {r4-r7,pc}
;;;776    
                          ENDP

                  |L35.60|
                          DCD      0x40023c10

                          AREA ||i.FLASH_ProgramHalfWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramHalfWord PROC
;;;832      */
;;;833    FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;834    {
000002  460d              MOV      r5,r1
000004  4606              MOV      r6,r0
;;;835      FLASH_Status status = FLASH_COMPLETE;
;;;836    
;;;837      /* Check the parameters */
;;;838      assert_param(IS_FLASH_ADDRESS(Address));
;;;839    
;;;840      /* Wait for last operation to be completed */
;;;841      status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
;;;842      
;;;843      if(status == FLASH_COMPLETE)
00000a  2809              CMP      r0,#9
00000c  d113              BNE      |L36.54|
;;;844      {
;;;845        /* if the previous operation is completed, proceed to program the new data */
;;;846        FLASH->CR &= CR_PSIZE_MASK;
00000e  4c0a              LDR      r4,|L36.56|
000010  6820              LDR      r0,[r4,#0]
000012  f4207040          BIC      r0,r0,#0x300
000016  6020              STR      r0,[r4,#0]
;;;847        FLASH->CR |= FLASH_PSIZE_HALF_WORD;
000018  6820              LDR      r0,[r4,#0]
00001a  f4407080          ORR      r0,r0,#0x100
00001e  6020              STR      r0,[r4,#0]
;;;848        FLASH->CR |= FLASH_CR_PG;
000020  6820              LDR      r0,[r4,#0]
000022  f0400001          ORR      r0,r0,#1
000026  6020              STR      r0,[r4,#0]
;;;849      
;;;850        *(__IO uint16_t*)Address = Data;
000028  8035              STRH     r5,[r6,#0]
;;;851            
;;;852        /* Wait for last operation to be completed */
;;;853        status = FLASH_WaitForLastOperation();
00002a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;854    
;;;855        /* if the program operation is completed, disable the PG Bit */
;;;856        FLASH->CR &= (~FLASH_CR_PG);
00002e  6821              LDR      r1,[r4,#0]
000030  f0210101          BIC      r1,r1,#1
000034  6021              STR      r1,[r4,#0]
                  |L36.54|
;;;857      } 
;;;858      /* Return the Program Status */
;;;859      return status;
;;;860    }
000036  bd70              POP      {r4-r6,pc}
;;;861    
                          ENDP

                  |L36.56|
                          DCD      0x40023c10

                          AREA ||i.FLASH_ProgramWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramWord PROC
;;;790      */
;;;791    FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;792    {
000002  460d              MOV      r5,r1
000004  4606              MOV      r6,r0
;;;793      FLASH_Status status = FLASH_COMPLETE;
;;;794    
;;;795      /* Check the parameters */
;;;796      assert_param(IS_FLASH_ADDRESS(Address));
;;;797    
;;;798      /* Wait for last operation to be completed */
;;;799      status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
;;;800      
;;;801      if(status == FLASH_COMPLETE)
00000a  2809              CMP      r0,#9
00000c  d113              BNE      |L37.54|
;;;802      {
;;;803        /* if the previous operation is completed, proceed to program the new data */
;;;804        FLASH->CR &= CR_PSIZE_MASK;
00000e  4c0a              LDR      r4,|L37.56|
000010  6820              LDR      r0,[r4,#0]
000012  f4207040          BIC      r0,r0,#0x300
000016  6020              STR      r0,[r4,#0]
;;;805        FLASH->CR |= FLASH_PSIZE_WORD;
000018  6820              LDR      r0,[r4,#0]
00001a  f4407000          ORR      r0,r0,#0x200
00001e  6020              STR      r0,[r4,#0]
;;;806        FLASH->CR |= FLASH_CR_PG;
000020  6820              LDR      r0,[r4,#0]
000022  f0400001          ORR      r0,r0,#1
000026  6020              STR      r0,[r4,#0]
;;;807      
;;;808        *(__IO uint32_t*)Address = Data;
000028  6035              STR      r5,[r6,#0]
;;;809            
;;;810        /* Wait for last operation to be completed */
;;;811        status = FLASH_WaitForLastOperation();
00002a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;812    
;;;813        /* if the program operation is completed, disable the PG Bit */
;;;814        FLASH->CR &= (~FLASH_CR_PG);
00002e  6821              LDR      r1,[r4,#0]
000030  f0210101          BIC      r1,r1,#1
000034  6021              STR      r1,[r4,#0]
                  |L37.54|
;;;815      } 
;;;816      /* Return the Program Status */
;;;817      return status;
;;;818    }
000036  bd70              POP      {r4-r6,pc}
;;;819    
                          ENDP

                  |L37.56|
                          DCD      0x40023c10

                          AREA ||i.FLASH_SetLatency||, CODE, READONLY, ALIGN=2

                  FLASH_SetLatency PROC
;;;276      */
;;;277    void FLASH_SetLatency(uint32_t FLASH_Latency)
000000  4901              LDR      r1,|L38.8|
;;;278    {
;;;279      /* Check the parameters */
;;;280      assert_param(IS_FLASH_LATENCY(FLASH_Latency));
;;;281      
;;;282      /* Perform Byte access to FLASH_ACR[8:0] to set the Latency value */
;;;283      *(__IO uint8_t *)ACR_BYTE0_ADDRESS = (uint8_t)FLASH_Latency;
000002  7008              STRB     r0,[r1,#0]
;;;284    }
000004  4770              BX       lr
;;;285    
                          ENDP

000006  0000              DCW      0x0000
                  |L38.8|
                          DCD      0x40023c00

                          AREA ||i.FLASH_Unlock||, CODE, READONLY, ALIGN=2

                  FLASH_Unlock PROC
;;;413      */
;;;414    void FLASH_Unlock(void)
000000  4805              LDR      r0,|L39.24|
;;;415    {
;;;416      if((FLASH->CR & FLASH_CR_LOCK) != RESET)
000002  6800              LDR      r0,[r0,#0]
000004  2800              CMP      r0,#0
000006  da05              BGE      |L39.20|
;;;417      {
;;;418        /* Authorize the FLASH Registers access */
;;;419        FLASH->KEYR = FLASH_KEY1;
000008  4803              LDR      r0,|L39.24|
00000a  4904              LDR      r1,|L39.28|
00000c  380c              SUBS     r0,r0,#0xc
00000e  6001              STR      r1,[r0,#0]
;;;420        FLASH->KEYR = FLASH_KEY2;
000010  4903              LDR      r1,|L39.32|
000012  6001              STR      r1,[r0,#0]
                  |L39.20|
;;;421      }  
;;;422    }
000014  4770              BX       lr
;;;423    
                          ENDP

000016  0000              DCW      0x0000
                  |L39.24|
                          DCD      0x40023c10
                  |L39.28|
                          DCD      0x45670123
                  |L39.32|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_WaitForLastOperation||, CODE, READONLY, ALIGN=1

                  FLASH_WaitForLastOperation PROC
;;;1584     */
;;;1585   FLASH_Status FLASH_WaitForLastOperation(void)
000000  b508              PUSH     {r3,lr}
;;;1586   { 
;;;1587     __IO FLASH_Status status = FLASH_COMPLETE;
000002  2009              MOVS     r0,#9
000004  f88d0000          STRB     r0,[sp,#0]
                  |L40.8|
;;;1588      
;;;1589     /* Check for the FLASH Status */
;;;1590     status = FLASH_GetStatus();
;;;1591   
;;;1592     /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
;;;1593        Even if the FLASH operation fails, the BUSY flag will be reset and an error
;;;1594        flag will be set */
;;;1595     while(status == FLASH_BUSY)
;;;1596     {
;;;1597       status = FLASH_GetStatus();
000008  f7fffffe          BL       FLASH_GetStatus
00000c  f88d0000          STRB     r0,[sp,#0]
000010  f89d0000          LDRB     r0,[sp,#0]            ;1595
000014  2801              CMP      r0,#1                 ;1595
000016  d0f7              BEQ      |L40.8|
;;;1598     }
;;;1599     /* Return the operation status */
;;;1600     return status;
000018  f89d0000          LDRB     r0,[sp,#0]
;;;1601   }
00001c  bd08              POP      {r3,pc}
;;;1602   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_flash.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f4xx_flash_c_a2a150d6____REV16|
#line 138 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_stm32f4xx_flash_c_a2a150d6____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f4xx_flash_c_a2a150d6____REVSH|
#line 153
|__asm___17_stm32f4xx_flash_c_a2a150d6____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f4xx_flash_c_a2a150d6____RRX|
#line 328
|__asm___17_stm32f4xx_flash_c_a2a150d6____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

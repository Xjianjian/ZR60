L 1 "..\..\Lwip\App\dnsAnalysis.c"
N/******************************************************
N文件名：	dnsAnalysis
N
N描述：	
NData			Vasion			author
N2018/04/12		V1.0			liujian
N*******************************************************/
N
N/*******************************************************
Ndescription： include the header file
N*******************************************************/
N#include "dnsAnalysis.h"
L 1 "..\..\Lwip\App\dnsAnalysis.h" 1
N/******************************************************
N文件名：	dnsAnalysis
N
N描述：		
N
NData			  Vasion			author
N2018/04/12		  V1.0			    liujian
N*******************************************************/
N#ifndef		_DNS_ANALYSIS_H
N#define		_DNS_ANALYSIS_H
N/*******************************************************
Ndescription： include the header file
N*******************************************************/
N#include "Include.h"
L 1 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 1
N/******************************************************
N浠跺锛	
N
N杩帮
N
NData			  Vasion			author
N2018/1/4		  V1.0			    liujian
N*******************************************************/
N#ifndef		INCLUDE_H
N#define		INCLUDE_H
N/*******************************************************
Ndescription锛include the header file
N*******************************************************/
N
N#define NETWORK_ON     //定义时，开启网络功能
N#define UART_DEBUG
N//#define WM8978_DEBUG
N//#define NET_DEBUG
N//#define TIME_DEBUG
N//#define freeRTOS_RUN_DEBUG
N
N
N
N/*C标准库文件*/
N#include <string.h>
L 1 "d:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060019
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 26 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include <stdlib.h>
L 1 "d:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060019
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 27 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include <stdio.h>
L 1 "d:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060019
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 28 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N/*bsp文件*/
N#include "./usart/bsp_debug_usart.h"
L 1 "..\..\Complex\./usart/bsp_debug_usart.h" 1
N#ifndef __DEBUG_USART_H
N#define	__DEBUG_USART_H
N
N#include "stm32f4xx.h"
L 1 "..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include\stm32f4xx.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    09-November-2016
N  * @brief   CMSIS Cortex-M4 Device Peripheral Access Layer Header File. 
N  *          This file contains all the peripheral register's definitions, bits 
N  *          definitions and memory mapping for STM32F4xx devices.            
N  *            
N  *          The file is the unique include file that the application programmer
N  *          is using in the C source code, usually in main.c. This file contains:
N  *           - Configuration section that allows to select:
N  *              - The device used in the target application
N  *              - To use or not the peripherals drivers in application code(i.e. 
N  *                code will be based on direct access to peripherals registers 
N  *                rather than drivers API), this option is controlled by 
N  *                "#define USE_STDPERIPH_DRIVER"
N  *              - To change few application-specific parameters such as the HSE 
N  *                crystal frequency
N  *           - Data structures and the address mapping for all peripherals
N  *           - Peripherals registers declarations and bits definition
N  *           - Macros to access peripherals registers hardware
N  *  
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************  
N  */ 
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup stm32f4xx
N  * @{
N  */
N    
N#ifndef __STM32F4xx_H
N#define __STM32F4xx_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif /* __cplusplus */
N  
N/** @addtogroup Library_configuration_section
N  * @{
N  */
N  
N/* Uncomment the line below according to the target STM32 device used in your
N   application 
N  */
N
N#if !defined(STM32F40_41xxx) && !defined(STM32F427_437xx) && !defined(STM32F429_439xx) && !defined(STM32F401xx) && !defined(STM32F410xx) && \
N    !defined(STM32F411xE) && !defined(STM32F412xG) && !defined(STM32F413_423xx) && !defined(STM32F446xx) && !defined(STM32F469_479xx)
X#if !1L && !0L && !0L && !0L && !0L &&     !0L && !0L && !0L && !0L && !0L
S  #define STM32F40_41xxx    /*!< STM32F405RG, STM32F405VG, STM32F405ZG, STM32F415RG, STM32F415VG, STM32F415ZG,
S                                      STM32F407VG, STM32F407VE, STM32F407ZG, STM32F407ZE, STM32F407IG, STM32F407IE, 
S                                      STM32F417VG, STM32F417VE, STM32F417ZG, STM32F417ZE, STM32F417IG and STM32F417IE Devices */
S
S  /* #define STM32F427_437xx */  /*!< STM32F427VG, STM32F427VI, STM32F427ZG, STM32F427ZI, STM32F427IG, STM32F427II,
S                                      STM32F437VG, STM32F437VI, STM32F437ZG, STM32F437ZI, STM32F437IG, STM32F437II Devices */
S
S  /* #define STM32F429_439xx */  /*!< STM32F429VG, STM32F429VI, STM32F429ZG, STM32F429ZI, STM32F429BG, STM32F429BI,
S                                      STM32F429NG, STM32F439NI, STM32F429IG, STM32F429II, STM32F439VG, STM32F439VI,
S                                      STM32F439ZG, STM32F439ZI, STM32F439BG, STM32F439BI, STM32F439NG, STM32F439NI,
S                                      STM32F439IG and STM32F439II Devices */
S
S  /* #define STM32F401xx */      /*!< STM32F401CB, STM32F401CC,  STM32F401RB, STM32F401RC, STM32F401VB, STM32F401VC,
S                                      STM32F401CD, STM32F401RD, STM32F401VD, STM32F401CExx, STM32F401RE and STM32F401VE Devices */
S
S  /* #define STM32F410xx */      /*!< STM32F410Tx, STM32F410Cx and STM32F410Rx */
S
S  /* #define STM32F411xE */      /*!< STM32F411CC, STM32F411RC, STM32F411VC, STM32F411CE, STM32F411RE and STM32F411VE Devices */
S
S  /* #define STM32F412xG */      /*!< STM32F412CEU, STM32F412CGU, STM32F412ZET, STM32F412ZGT, STM32F412ZEJ, STM32F412ZGJ,
S                                      STM32F412VET, STM32F412VGT, STM32F412VEH, STM32F412VGH, STM32F412RET, STM32F412RGT,
S                                      STM32F412REY and STM32F412RGY Devices */
S                                      
S  /* #define STM32F413_423xx */  /*!< STM32F413CGU, STM32F413CHU, STM32F413MGY, STM32F413MHY, STM32F413RGT, STM32F413VGT,
S                                      STM32F413ZGT, STM32F413RHT, STM32F413VHT, STM32F413ZHT, STM32F413VGH, STM32F413ZGJ,
S                                      STM32F413VHH, STM32F413ZHJ, STM32F423CHU, STM32F423RHT, STM32F423VHT, STM32F423ZHT,
S                                      STM32F423VHH and STM32F423ZHJ devices */
S
S  /* #define STM32F446xx */      /*!< STM32F446MC, STM32F446ME, STM32F446RC, STM32F446RE, STM32F446VC, STM32F446VE, STM32F446ZC 
S                                      and STM32F446ZE Devices */
S
S  /* #define STM32F469_479xx */  /*!< STM32F479AI, STM32F479II, STM32F479BI, STM32F479NI, STM32F479AG, STM32F479IG, STM32F479BG,
S                                      STM32F479NG, STM32F479AE, STM32F479IE, STM32F479BE, STM32F479NE Devices */
S
N#endif /* STM32F40_41xxx && STM32F427_437xx && STM32F429_439xx && STM32F401xx && STM32F410xx && STM32F411xE && STM32F412xG && STM32F413_423xx && STM32F446xx && STM32F469_479xx */
N
N/* Old STM32F40XX definition, maintained for legacy purpose */
N#ifdef STM32F40XX
S  #define STM32F40_41xxx
N#endif /* STM32F40XX */
N
N/* Old STM32F427X definition, maintained for legacy purpose */
N#ifdef STM32F427X
S  #define STM32F427_437xx
N#endif /* STM32F427X */
N
N/*  Tip: To avoid modifying this file each time you need to switch between these
N        devices, you can define the device in your toolchain compiler preprocessor.
N  */
N
N#if !defined(STM32F40_41xxx) && !defined(STM32F427_437xx) && !defined(STM32F429_439xx) && !defined(STM32F401xx) && !defined(STM32F410xx) && \
N    !defined(STM32F411xE) && !defined(STM32F412xG) && !defined(STM32F413_423xx) && !defined(STM32F446xx) && !defined(STM32F469_479xx)
X#if !1L && !0L && !0L && !0L && !0L &&     !0L && !0L && !0L && !0L && !0L
S #error "Please select first the target STM32F4xx device used in your application (in stm32f4xx.h file)"
N#endif /* STM32F40_41xxx && STM32F427_437xx && STM32F429_439xx && STM32F401xx && STM32F410xx && STM32F411xE && STM32F412xG && STM32F413_23xx && STM32F446xx && STM32F469_479xx */
N
N#if !defined  (USE_STDPERIPH_DRIVER)
X#if !1L
S/**
S * @brief Comment the line below if you will not use the peripherals drivers.
S   In this case, these drivers will not be included and the application code will 
S   be based on direct access to peripherals registers 
S   */
S  /*#define USE_STDPERIPH_DRIVER */
N#endif /* USE_STDPERIPH_DRIVER */
N
N/**
N * @brief In the following line adjust the value of External High Speed oscillator (HSE)
N   used in your application 
N   
N   Tip: To avoid modifying this file each time you need to use different HSE, you
N        can define the HSE value in your toolchain compiler preprocessor.
N  */           
N#if defined(STM32F40_41xxx) || defined(STM32F427_437xx)  || defined(STM32F429_439xx) || defined(STM32F401xx) || \
N    defined(STM32F410xx) || defined(STM32F411xE) || defined(STM32F469_479xx)
X#if 1L || 0L  || 0L || 0L ||     0L || 0L || 0L
N #if !defined  (HSE_VALUE) 
X #if !0L 
N  #define HSE_VALUE    ((uint32_t)25000000) /*!< Value of the External oscillator in Hz */
N #endif /* HSE_VALUE */
N#elif defined (STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
S #if !defined  (HSE_VALUE) 
S  #define HSE_VALUE    ((uint32_t)8000000) /*!< Value of the External oscillator in Hz */
S #endif /* HSE_VALUE */
N#endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F401xx || STM32F411xE || STM32F469_479xx */
N/**
N * @brief In the following line adjust the External High Speed oscillator (HSE) Startup 
N   Timeout value 
N   */
N#if !defined  (HSE_STARTUP_TIMEOUT) 
X#if !0L 
N  #define HSE_STARTUP_TIMEOUT    ((uint16_t)0x05000)   /*!< Time out for HSE start up */
N#endif /* HSE_STARTUP_TIMEOUT */   
N
N#if !defined  (HSI_VALUE)   
X#if !0L   
N  #define HSI_VALUE    ((uint32_t)16000000) /*!< Value of the Internal oscillator in Hz*/
N#endif /* HSI_VALUE */   
N
N/**
N * @brief STM32F4XX Standard Peripherals Library version number V1.8.0
N   */
N#define __STM32F4XX_STDPERIPH_VERSION_MAIN   (0x01) /*!< [31:24] main version */
N#define __STM32F4XX_STDPERIPH_VERSION_SUB1   (0x08) /*!< [23:16] sub1 version */
N#define __STM32F4XX_STDPERIPH_VERSION_SUB2   (0x00) /*!< [15:8]  sub2 version */
N#define __STM32F4XX_STDPERIPH_VERSION_RC     (0x00) /*!< [7:0]  release candidate */ 
N#define __STM32F4XX_STDPERIPH_VERSION        ((__STM32F4XX_STDPERIPH_VERSION_MAIN << 24)\
N                                             |(__STM32F4XX_STDPERIPH_VERSION_SUB1 << 16)\
N                                             |(__STM32F4XX_STDPERIPH_VERSION_SUB2 << 8)\
N                                             |(__STM32F4XX_STDPERIPH_VERSION_RC))
X#define __STM32F4XX_STDPERIPH_VERSION        ((__STM32F4XX_STDPERIPH_VERSION_MAIN << 24)                                             |(__STM32F4XX_STDPERIPH_VERSION_SUB1 << 16)                                             |(__STM32F4XX_STDPERIPH_VERSION_SUB2 << 8)                                             |(__STM32F4XX_STDPERIPH_VERSION_RC))
N
N/**
N  * @}
N  */
N
N/** @addtogroup Configuration_section_for_CMSIS
N  * @{
N  */
N
N/**
N * @brief Configuration of the Cortex-M4 Processor and Core Peripherals 
N */
N#define __CM4_REV                 0x0001  /*!< Core revision r0p1                            */
N#define __MPU_PRESENT             1       /*!< STM32F4XX provides an MPU                     */
N#define __NVIC_PRIO_BITS          4       /*!< STM32F4XX uses 4 Bits for the Priority Levels */
N#define __Vendor_SysTickConfig    0       /*!< Set to 1 if different SysTick Config is used  */
N#define __FPU_PRESENT             1       /*!< FPU present                                   */
N
N/**
N * @brief STM32F4XX Interrupt Number Definition, according to the selected device 
N *        in @ref Library_configuration_section 
N */
Ntypedef enum IRQn
N{
N/******  Cortex-M4 Processor Exceptions Numbers ****************************************************************/
N  NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                                          */
N  MemoryManagement_IRQn       = -12,    /*!< 4 Cortex-M4 Memory Management Interrupt                           */
N  BusFault_IRQn               = -11,    /*!< 5 Cortex-M4 Bus Fault Interrupt                                   */
N  UsageFault_IRQn             = -10,    /*!< 6 Cortex-M4 Usage Fault Interrupt                                 */
N  SVCall_IRQn                 = -5,     /*!< 11 Cortex-M4 SV Call Interrupt                                    */
N  DebugMonitor_IRQn           = -4,     /*!< 12 Cortex-M4 Debug Monitor Interrupt                              */
N  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M4 Pend SV Interrupt                                    */
N  SysTick_IRQn                = -1,     /*!< 15 Cortex-M4 System Tick Interrupt                                */
N/******  STM32 specific Interrupt Numbers **********************************************************************/
N  WWDG_IRQn                   = 0,      /*!< Window WatchDog Interrupt                                         */
N  PVD_IRQn                    = 1,      /*!< PVD through EXTI Line detection Interrupt                         */
N  TAMP_STAMP_IRQn             = 2,      /*!< Tamper and TimeStamp interrupts through the EXTI line             */
N  RTC_WKUP_IRQn               = 3,      /*!< RTC Wakeup interrupt through the EXTI line                        */
N  FLASH_IRQn                  = 4,      /*!< FLASH global Interrupt                                            */
N  RCC_IRQn                    = 5,      /*!< RCC global Interrupt                                              */
N  EXTI0_IRQn                  = 6,      /*!< EXTI Line0 Interrupt                                              */
N  EXTI1_IRQn                  = 7,      /*!< EXTI Line1 Interrupt                                              */
N  EXTI2_IRQn                  = 8,      /*!< EXTI Line2 Interrupt                                              */
N  EXTI3_IRQn                  = 9,      /*!< EXTI Line3 Interrupt                                              */
N  EXTI4_IRQn                  = 10,     /*!< EXTI Line4 Interrupt                                              */
N  DMA1_Stream0_IRQn           = 11,     /*!< DMA1 Stream 0 global Interrupt                                    */
N  DMA1_Stream1_IRQn           = 12,     /*!< DMA1 Stream 1 global Interrupt                                    */
N  DMA1_Stream2_IRQn           = 13,     /*!< DMA1 Stream 2 global Interrupt                                    */
N  DMA1_Stream3_IRQn           = 14,     /*!< DMA1 Stream 3 global Interrupt                                    */
N  DMA1_Stream4_IRQn           = 15,     /*!< DMA1 Stream 4 global Interrupt                                    */
N  DMA1_Stream5_IRQn           = 16,     /*!< DMA1 Stream 5 global Interrupt                                    */
N  DMA1_Stream6_IRQn           = 17,     /*!< DMA1 Stream 6 global Interrupt                                    */
N  ADC_IRQn                    = 18,     /*!< ADC1, ADC2 and ADC3 global Interrupts                             */
N
N#if defined(STM32F40_41xxx)
X#if 1L
N  CAN1_TX_IRQn                = 19,     /*!< CAN1 TX Interrupt                                                 */
N  CAN1_RX0_IRQn               = 20,     /*!< CAN1 RX0 Interrupt                                                */
N  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                                */
N  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                                */
N  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
N  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break interrupt and TIM9 global interrupt                    */
N  TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global interrupt                  */
N  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
N  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                                    */
N  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                             */
N  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                             */
N  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                             */
N  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
N  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
N  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
N  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */
N  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
N  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
N  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
N  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
N  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                                           */
N  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
N  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
N  OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS Wakeup through EXTI line interrupt                     */
N  TIM8_BRK_TIM12_IRQn         = 43,     /*!< TIM8 Break Interrupt and TIM12 global interrupt                   */
N  TIM8_UP_TIM13_IRQn          = 44,     /*!< TIM8 Update Interrupt and TIM13 global interrupt                  */
N  TIM8_TRG_COM_TIM14_IRQn     = 45,     /*!< TIM8 Trigger and Commutation Interrupt and TIM14 global interrupt */
N  TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare Interrupt                                    */
N  DMA1_Stream7_IRQn           = 47,     /*!< DMA1 Stream7 Interrupt                                            */
N  FSMC_IRQn                   = 48,     /*!< FSMC global Interrupt                                             */
N  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                             */
N  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                             */
N  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                             */
N  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                                            */
N  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                                            */
N  TIM6_DAC_IRQn               = 54,     /*!< TIM6 global and DAC1&2 underrun error  interrupts                 */
N  TIM7_IRQn                   = 55,     /*!< TIM7 global interrupt                                             */
N  DMA2_Stream0_IRQn           = 56,     /*!< DMA2 Stream 0 global Interrupt                                    */
N  DMA2_Stream1_IRQn           = 57,     /*!< DMA2 Stream 1 global Interrupt                                    */
N  DMA2_Stream2_IRQn           = 58,     /*!< DMA2 Stream 2 global Interrupt                                    */
N  DMA2_Stream3_IRQn           = 59,     /*!< DMA2 Stream 3 global Interrupt                                    */
N  DMA2_Stream4_IRQn           = 60,     /*!< DMA2 Stream 4 global Interrupt                                    */
N  ETH_IRQn                    = 61,     /*!< Ethernet global Interrupt                                         */
N  ETH_WKUP_IRQn               = 62,     /*!< Ethernet Wakeup through EXTI line Interrupt                       */
N  CAN2_TX_IRQn                = 63,     /*!< CAN2 TX Interrupt                                                 */
N  CAN2_RX0_IRQn               = 64,     /*!< CAN2 RX0 Interrupt                                                */
N  CAN2_RX1_IRQn               = 65,     /*!< CAN2 RX1 Interrupt                                                */
N  CAN2_SCE_IRQn               = 66,     /*!< CAN2 SCE Interrupt                                                */
N  OTG_FS_IRQn                 = 67,     /*!< USB OTG FS global Interrupt                                       */
N  DMA2_Stream5_IRQn           = 68,     /*!< DMA2 Stream 5 global interrupt                                    */
N  DMA2_Stream6_IRQn           = 69,     /*!< DMA2 Stream 6 global interrupt                                    */
N  DMA2_Stream7_IRQn           = 70,     /*!< DMA2 Stream 7 global interrupt                                    */
N  USART6_IRQn                 = 71,     /*!< USART6 global interrupt                                           */
N  I2C3_EV_IRQn                = 72,     /*!< I2C3 event interrupt                                              */
N  I2C3_ER_IRQn                = 73,     /*!< I2C3 error interrupt                                              */
N  OTG_HS_EP1_OUT_IRQn         = 74,     /*!< USB OTG HS End Point 1 Out global interrupt                       */
N  OTG_HS_EP1_IN_IRQn          = 75,     /*!< USB OTG HS End Point 1 In global interrupt                        */
N  OTG_HS_WKUP_IRQn            = 76,     /*!< USB OTG HS Wakeup through EXTI interrupt                          */
N  OTG_HS_IRQn                 = 77,     /*!< USB OTG HS global interrupt                                       */
N  DCMI_IRQn                   = 78,     /*!< DCMI global interrupt                                             */
N  CRYP_IRQn                   = 79,     /*!< CRYP crypto global interrupt                                      */
N  HASH_RNG_IRQn               = 80,     /*!< Hash and Rng global interrupt                                     */
N  FPU_IRQn                    = 81      /*!< FPU global interrupt                                              */
N#endif /* STM32F40_41xxx */
N
N#if defined(STM32F427_437xx)
X#if 0L
S  CAN1_TX_IRQn                = 19,     /*!< CAN1 TX Interrupt                                                 */
S  CAN1_RX0_IRQn               = 20,     /*!< CAN1 RX0 Interrupt                                                */
S  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                                */
S  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                                */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
S  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break interrupt and TIM9 global interrupt                    */
S  TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global interrupt                  */
S  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                                    */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                             */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                             */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                             */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
S  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                                           */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
S  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
S  OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS Wakeup through EXTI line interrupt                     */
S  TIM8_BRK_TIM12_IRQn         = 43,     /*!< TIM8 Break Interrupt and TIM12 global interrupt                   */
S  TIM8_UP_TIM13_IRQn          = 44,     /*!< TIM8 Update Interrupt and TIM13 global interrupt                  */
S  TIM8_TRG_COM_TIM14_IRQn     = 45,     /*!< TIM8 Trigger and Commutation Interrupt and TIM14 global interrupt */
S  TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare Interrupt                                    */
S  DMA1_Stream7_IRQn           = 47,     /*!< DMA1 Stream7 Interrupt                                            */
S  FMC_IRQn                    = 48,     /*!< FMC global Interrupt                                              */
S  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                             */
S  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                             */
S  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                             */
S  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                                            */
S  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                                            */
S  TIM6_DAC_IRQn               = 54,     /*!< TIM6 global and DAC1&2 underrun error  interrupts                 */
S  TIM7_IRQn                   = 55,     /*!< TIM7 global interrupt                                             */
S  DMA2_Stream0_IRQn           = 56,     /*!< DMA2 Stream 0 global Interrupt                                    */
S  DMA2_Stream1_IRQn           = 57,     /*!< DMA2 Stream 1 global Interrupt                                    */
S  DMA2_Stream2_IRQn           = 58,     /*!< DMA2 Stream 2 global Interrupt                                    */
S  DMA2_Stream3_IRQn           = 59,     /*!< DMA2 Stream 3 global Interrupt                                    */
S  DMA2_Stream4_IRQn           = 60,     /*!< DMA2 Stream 4 global Interrupt                                    */
S  ETH_IRQn                    = 61,     /*!< Ethernet global Interrupt                                         */
S  ETH_WKUP_IRQn               = 62,     /*!< Ethernet Wakeup through EXTI line Interrupt                       */
S  CAN2_TX_IRQn                = 63,     /*!< CAN2 TX Interrupt                                                 */
S  CAN2_RX0_IRQn               = 64,     /*!< CAN2 RX0 Interrupt                                                */
S  CAN2_RX1_IRQn               = 65,     /*!< CAN2 RX1 Interrupt                                                */
S  CAN2_SCE_IRQn               = 66,     /*!< CAN2 SCE Interrupt                                                */
S  OTG_FS_IRQn                 = 67,     /*!< USB OTG FS global Interrupt                                       */
S  DMA2_Stream5_IRQn           = 68,     /*!< DMA2 Stream 5 global interrupt                                    */
S  DMA2_Stream6_IRQn           = 69,     /*!< DMA2 Stream 6 global interrupt                                    */
S  DMA2_Stream7_IRQn           = 70,     /*!< DMA2 Stream 7 global interrupt                                    */
S  USART6_IRQn                 = 71,     /*!< USART6 global interrupt                                           */
S  I2C3_EV_IRQn                = 72,     /*!< I2C3 event interrupt                                              */
S  I2C3_ER_IRQn                = 73,     /*!< I2C3 error interrupt                                              */
S  OTG_HS_EP1_OUT_IRQn         = 74,     /*!< USB OTG HS End Point 1 Out global interrupt                       */
S  OTG_HS_EP1_IN_IRQn          = 75,     /*!< USB OTG HS End Point 1 In global interrupt                        */
S  OTG_HS_WKUP_IRQn            = 76,     /*!< USB OTG HS Wakeup through EXTI interrupt                          */
S  OTG_HS_IRQn                 = 77,     /*!< USB OTG HS global interrupt                                       */
S  DCMI_IRQn                   = 78,     /*!< DCMI global interrupt                                             */
S  CRYP_IRQn                   = 79,     /*!< CRYP crypto global interrupt                                      */
S  HASH_RNG_IRQn               = 80,     /*!< Hash and Rng global interrupt                                     */
S  FPU_IRQn                    = 81,     /*!< FPU global interrupt                                              */
S  UART7_IRQn                  = 82,     /*!< UART7 global interrupt                                            */
S  UART8_IRQn                  = 83,     /*!< UART8 global interrupt                                            */
S  SPI4_IRQn                   = 84,     /*!< SPI4 global Interrupt                                             */
S  SPI5_IRQn                   = 85,     /*!< SPI5 global Interrupt                                             */
S  SPI6_IRQn                   = 86,     /*!< SPI6 global Interrupt                                             */
S  SAI1_IRQn                   = 87,     /*!< SAI1 global Interrupt                                             */
S  DMA2D_IRQn                  = 90      /*!< DMA2D global Interrupt                                            */
N#endif /* STM32F427_437xx */
N    
N#if defined(STM32F429_439xx)
X#if 0L
S  CAN1_TX_IRQn                = 19,     /*!< CAN1 TX Interrupt                                                 */
S  CAN1_RX0_IRQn               = 20,     /*!< CAN1 RX0 Interrupt                                                */
S  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                                */
S  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                                */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
S  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break interrupt and TIM9 global interrupt                    */
S  TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global interrupt                  */
S  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                                    */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                             */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                             */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                             */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */  
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
S  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                                           */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
S  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
S  OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS Wakeup through EXTI line interrupt                     */    
S  TIM8_BRK_TIM12_IRQn         = 43,     /*!< TIM8 Break Interrupt and TIM12 global interrupt                   */
S  TIM8_UP_TIM13_IRQn          = 44,     /*!< TIM8 Update Interrupt and TIM13 global interrupt                  */
S  TIM8_TRG_COM_TIM14_IRQn     = 45,     /*!< TIM8 Trigger and Commutation Interrupt and TIM14 global interrupt */
S  TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare Interrupt                                    */
S  DMA1_Stream7_IRQn           = 47,     /*!< DMA1 Stream7 Interrupt                                            */
S  FMC_IRQn                    = 48,     /*!< FMC global Interrupt                                              */
S  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                             */
S  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                             */
S  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                             */
S  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                                            */
S  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                                            */
S  TIM6_DAC_IRQn               = 54,     /*!< TIM6 global and DAC1&2 underrun error  interrupts                 */
S  TIM7_IRQn                   = 55,     /*!< TIM7 global interrupt                                             */
S  DMA2_Stream0_IRQn           = 56,     /*!< DMA2 Stream 0 global Interrupt                                    */
S  DMA2_Stream1_IRQn           = 57,     /*!< DMA2 Stream 1 global Interrupt                                    */
S  DMA2_Stream2_IRQn           = 58,     /*!< DMA2 Stream 2 global Interrupt                                    */
S  DMA2_Stream3_IRQn           = 59,     /*!< DMA2 Stream 3 global Interrupt                                    */
S  DMA2_Stream4_IRQn           = 60,     /*!< DMA2 Stream 4 global Interrupt                                    */
S  ETH_IRQn                    = 61,     /*!< Ethernet global Interrupt                                         */
S  ETH_WKUP_IRQn               = 62,     /*!< Ethernet Wakeup through EXTI line Interrupt                       */
S  CAN2_TX_IRQn                = 63,     /*!< CAN2 TX Interrupt                                                 */
S  CAN2_RX0_IRQn               = 64,     /*!< CAN2 RX0 Interrupt                                                */
S  CAN2_RX1_IRQn               = 65,     /*!< CAN2 RX1 Interrupt                                                */
S  CAN2_SCE_IRQn               = 66,     /*!< CAN2 SCE Interrupt                                                */
S  OTG_FS_IRQn                 = 67,     /*!< USB OTG FS global Interrupt                                       */
S  DMA2_Stream5_IRQn           = 68,     /*!< DMA2 Stream 5 global interrupt                                    */
S  DMA2_Stream6_IRQn           = 69,     /*!< DMA2 Stream 6 global interrupt                                    */
S  DMA2_Stream7_IRQn           = 70,     /*!< DMA2 Stream 7 global interrupt                                    */
S  USART6_IRQn                 = 71,     /*!< USART6 global interrupt                                           */
S  I2C3_EV_IRQn                = 72,     /*!< I2C3 event interrupt                                              */
S  I2C3_ER_IRQn                = 73,     /*!< I2C3 error interrupt                                              */
S  OTG_HS_EP1_OUT_IRQn         = 74,     /*!< USB OTG HS End Point 1 Out global interrupt                       */
S  OTG_HS_EP1_IN_IRQn          = 75,     /*!< USB OTG HS End Point 1 In global interrupt                        */
S  OTG_HS_WKUP_IRQn            = 76,     /*!< USB OTG HS Wakeup through EXTI interrupt                          */
S  OTG_HS_IRQn                 = 77,     /*!< USB OTG HS global interrupt                                       */
S  DCMI_IRQn                   = 78,     /*!< DCMI global interrupt                                             */
S  CRYP_IRQn                   = 79,     /*!< CRYP crypto global interrupt                                      */
S  HASH_RNG_IRQn               = 80,     /*!< Hash and Rng global interrupt                                     */
S  FPU_IRQn                    = 81,     /*!< FPU global interrupt                                              */
S  UART7_IRQn                  = 82,     /*!< UART7 global interrupt                                            */
S  UART8_IRQn                  = 83,     /*!< UART8 global interrupt                                            */
S  SPI4_IRQn                   = 84,     /*!< SPI4 global Interrupt                                             */
S  SPI5_IRQn                   = 85,     /*!< SPI5 global Interrupt                                             */
S  SPI6_IRQn                   = 86,     /*!< SPI6 global Interrupt                                             */
S  SAI1_IRQn                   = 87,     /*!< SAI1 global Interrupt                                             */
S  LTDC_IRQn                   = 88,     /*!< LTDC global Interrupt                                             */
S  LTDC_ER_IRQn                = 89,     /*!< LTDC Error global Interrupt                                       */
S  DMA2D_IRQn                  = 90      /*!< DMA2D global Interrupt                                            */
N#endif /* STM32F429_439xx */
N
N#if defined(STM32F410xx)
X#if 0L
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
S  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break interrupt and TIM9 global interrupt                    */
S  TIM1_UP_IRQn                = 25,     /*!< TIM1 Update Interrupt                                             */
S  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                                    */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
S  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
S  DMA1_Stream7_IRQn           = 47,     /*!< DMA1 Stream7 Interrupt                                            */
S  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                             */
S  TIM6_DAC_IRQn               = 54,     /*!< TIM6 global Interrupt and DAC Global Interrupt                    */
S  DMA2_Stream0_IRQn           = 56,     /*!< DMA2 Stream 0 global Interrupt                                    */
S  DMA2_Stream1_IRQn           = 57,     /*!< DMA2 Stream 1 global Interrupt                                    */
S  DMA2_Stream2_IRQn           = 58,     /*!< DMA2 Stream 2 global Interrupt                                    */
S  DMA2_Stream3_IRQn           = 59,     /*!< DMA2 Stream 3 global Interrupt                                    */
S  DMA2_Stream4_IRQn           = 60,     /*!< DMA2 Stream 4 global Interrupt                                    */
S  DMA2_Stream5_IRQn           = 68,     /*!< DMA2 Stream 5 global interrupt                                    */
S  DMA2_Stream6_IRQn           = 69,     /*!< DMA2 Stream 6 global interrupt                                    */
S  DMA2_Stream7_IRQn           = 70,     /*!< DMA2 Stream 7 global interrupt                                    */
S  USART6_IRQn                 = 71,     /*!< USART6 global interrupt                                           */
S  RNG_IRQn                    = 80,     /*!< RNG global Interrupt                                              */
S  FPU_IRQn                    = 81,     /*!< FPU global interrupt                                              */
S  SPI5_IRQn                   = 85,     /*!< SPI5 global Interrupt                                             */
S  FMPI2C1_EV_IRQn             = 95,     /*!< FMPI2C1 Event Interrupt                                           */
S  FMPI2C1_ER_IRQn             = 96,     /*!< FMPI2C1 Error Interrupt                                           */
S  LPTIM1_IRQn                 = 97      /*!< LPTIM1 interrupt                                                  */
N#endif /* STM32F410xx */
N   
N#if defined(STM32F401xx) || defined(STM32F411xE)
X#if 0L || 0L
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
S  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break interrupt and TIM9 global interrupt                    */
S  TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global interrupt                  */
S  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                                    */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                             */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                             */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                             */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
S  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
S  OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS Wakeup through EXTI line interrupt                     */
S  DMA1_Stream7_IRQn           = 47,     /*!< DMA1 Stream7 Interrupt                                            */
S  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                             */
S  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                             */
S  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                             */
S  DMA2_Stream0_IRQn           = 56,     /*!< DMA2 Stream 0 global Interrupt                                    */
S  DMA2_Stream1_IRQn           = 57,     /*!< DMA2 Stream 1 global Interrupt                                    */
S  DMA2_Stream2_IRQn           = 58,     /*!< DMA2 Stream 2 global Interrupt                                    */
S  DMA2_Stream3_IRQn           = 59,     /*!< DMA2 Stream 3 global Interrupt                                    */
S  DMA2_Stream4_IRQn           = 60,     /*!< DMA2 Stream 4 global Interrupt                                    */
S  OTG_FS_IRQn                 = 67,     /*!< USB OTG FS global Interrupt                                       */
S  DMA2_Stream5_IRQn           = 68,     /*!< DMA2 Stream 5 global interrupt                                    */
S  DMA2_Stream6_IRQn           = 69,     /*!< DMA2 Stream 6 global interrupt                                    */
S  DMA2_Stream7_IRQn           = 70,     /*!< DMA2 Stream 7 global interrupt                                    */
S  USART6_IRQn                 = 71,     /*!< USART6 global interrupt                                           */
S  I2C3_EV_IRQn                = 72,     /*!< I2C3 event interrupt                                              */
S  I2C3_ER_IRQn                = 73,     /*!< I2C3 error interrupt                                              */
S  FPU_IRQn                    = 81,      /*!< FPU global interrupt                                             */
S#if defined(STM32F401xx)
S  SPI4_IRQn                   = 84       /*!< SPI4 global Interrupt                                            */
S#endif /* STM32F411xE */
S#if defined(STM32F411xE)
S  SPI4_IRQn                   = 84,     /*!< SPI4 global Interrupt                                             */
S  SPI5_IRQn                   = 85      /*!< SPI5 global Interrupt                                             */
S#endif /* STM32F411xE */
N#endif /* STM32F401xx || STM32F411xE */
N
N#if defined(STM32F469_479xx)
X#if 0L
S  CAN1_TX_IRQn                = 19,     /*!< CAN1 TX Interrupt                                                 */
S  CAN1_RX0_IRQn               = 20,     /*!< CAN1 RX0 Interrupt                                                */
S  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                                */
S  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                                */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
S  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break interrupt and TIM9 global interrupt                    */
S  TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global interrupt                  */
S  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                                    */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                             */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                             */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                             */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
S  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                                           */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
S  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
S  OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS Wakeup through EXTI line interrupt                     */
S  TIM8_BRK_TIM12_IRQn         = 43,     /*!< TIM8 Break Interrupt and TIM12 global interrupt                   */
S  TIM8_UP_TIM13_IRQn          = 44,     /*!< TIM8 Update Interrupt and TIM13 global interrupt                  */
S  TIM8_TRG_COM_TIM14_IRQn     = 45,     /*!< TIM8 Trigger and Commutation Interrupt and TIM14 global interrupt */
S  TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare Interrupt                                    */
S  DMA1_Stream7_IRQn           = 47,     /*!< DMA1 Stream7 Interrupt                                            */
S  FMC_IRQn                    = 48,     /*!< FMC global Interrupt                                              */
S  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                             */
S  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                             */
S  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                             */
S  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                                            */
S  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                                            */
S  TIM6_DAC_IRQn               = 54,     /*!< TIM6 global and DAC1&2 underrun error  interrupts                 */
S  TIM7_IRQn                   = 55,     /*!< TIM7 global interrupt                                             */
S  DMA2_Stream0_IRQn           = 56,     /*!< DMA2 Stream 0 global Interrupt                                    */
S  DMA2_Stream1_IRQn           = 57,     /*!< DMA2 Stream 1 global Interrupt                                    */
S  DMA2_Stream2_IRQn           = 58,     /*!< DMA2 Stream 2 global Interrupt                                    */
S  DMA2_Stream3_IRQn           = 59,     /*!< DMA2 Stream 3 global Interrupt                                    */
S  DMA2_Stream4_IRQn           = 60,     /*!< DMA2 Stream 4 global Interrupt                                    */
S  ETH_IRQn                    = 61,     /*!< Ethernet global Interrupt                                         */
S  ETH_WKUP_IRQn               = 62,     /*!< Ethernet Wakeup through EXTI line Interrupt                       */
S  CAN2_TX_IRQn                = 63,     /*!< CAN2 TX Interrupt                                                 */
S  CAN2_RX0_IRQn               = 64,     /*!< CAN2 RX0 Interrupt                                                */
S  CAN2_RX1_IRQn               = 65,     /*!< CAN2 RX1 Interrupt                                                */
S  CAN2_SCE_IRQn               = 66,     /*!< CAN2 SCE Interrupt                                                */
S  OTG_FS_IRQn                 = 67,     /*!< USB OTG FS global Interrupt                                       */
S  DMA2_Stream5_IRQn           = 68,     /*!< DMA2 Stream 5 global interrupt                                    */
S  DMA2_Stream6_IRQn           = 69,     /*!< DMA2 Stream 6 global interrupt                                    */
S  DMA2_Stream7_IRQn           = 70,     /*!< DMA2 Stream 7 global interrupt                                    */
S  USART6_IRQn                 = 71,     /*!< USART6 global interrupt                                           */
S  I2C3_EV_IRQn                = 72,     /*!< I2C3 event interrupt                                              */
S  I2C3_ER_IRQn                = 73,     /*!< I2C3 error interrupt                                              */
S  OTG_HS_EP1_OUT_IRQn         = 74,     /*!< USB OTG HS End Point 1 Out global interrupt                       */
S  OTG_HS_EP1_IN_IRQn          = 75,     /*!< USB OTG HS End Point 1 In global interrupt                        */
S  OTG_HS_WKUP_IRQn            = 76,     /*!< USB OTG HS Wakeup through EXTI interrupt                          */
S  OTG_HS_IRQn                 = 77,     /*!< USB OTG HS global interrupt                                       */
S  DCMI_IRQn                   = 78,     /*!< DCMI global interrupt                                             */
S  CRYP_IRQn                   = 79,     /*!< CRYP crypto global interrupt                                      */
S  HASH_RNG_IRQn               = 80,     /*!< Hash and Rng global interrupt                                     */
S  FPU_IRQn                    = 81,     /*!< FPU global interrupt                                              */
S  UART7_IRQn                  = 82,     /*!< UART7 global interrupt                                            */
S  UART8_IRQn                  = 83,     /*!< UART8 global interrupt                                            */
S  SPI4_IRQn                   = 84,     /*!< SPI4 global Interrupt                                             */
S  SPI5_IRQn                   = 85,     /*!< SPI5 global Interrupt                                             */
S  SPI6_IRQn                   = 86,     /*!< SPI6 global Interrupt                                             */
S  SAI1_IRQn                   = 87,     /*!< SAI1 global Interrupt                                             */
S  LTDC_IRQn                   = 88,     /*!< LTDC global Interrupt                                             */
S  LTDC_ER_IRQn                = 89,     /*!< LTDC Error global Interrupt                                       */
S  DMA2D_IRQn                  = 90,     /*!< DMA2D global Interrupt                                            */
S  QUADSPI_IRQn                = 91,     /*!< QUADSPI global Interrupt                                          */
S  DSI_IRQn                    = 92      /*!< DSI global Interrupt                                              */
N#endif /* STM32F469_479xx */
N
N#if defined(STM32F446xx)
X#if 0L
S  CAN1_TX_IRQn                = 19,     /*!< CAN1 TX Interrupt                                                 */
S  CAN1_RX0_IRQn               = 20,     /*!< CAN1 RX0 Interrupt                                                */
S  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                                */
S  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                                */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
S  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break interrupt and TIM9 global interrupt                    */
S  TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global interrupt                  */
S  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                                    */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                             */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                             */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                             */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */  
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
S  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                                           */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
S  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
S  OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS Wakeup through EXTI line interrupt                     */    
S  TIM8_BRK_IRQn               = 43,     /*!< TIM8 Break Interrupt                                              */
S  TIM8_BRK_TIM12_IRQn         = 43,     /*!< TIM8 Break Interrupt and TIM12 global interrupt                   */
S  TIM8_UP_TIM13_IRQn          = 44,     /*!< TIM8 Update Interrupt and TIM13 global interrupt                  */
S  TIM8_TRG_COM_TIM14_IRQn     = 45,     /*!< TIM8 Trigger and Commutation Interrupt and TIM14 global interrupt */
S  DMA1_Stream7_IRQn           = 47,     /*!< DMA1 Stream7 Interrupt                                            */
S  FMC_IRQn                    = 48,     /*!< FMC global Interrupt                                              */
S  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                             */
S  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                             */
S  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                             */
S  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                                            */
S  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                                            */
S  TIM6_DAC_IRQn               = 54,     /*!< TIM6 global and DAC1&2 underrun error  interrupts                 */
S  TIM7_IRQn                   = 55,     /*!< TIM7 global interrupt                                             */
S  DMA2_Stream0_IRQn           = 56,     /*!< DMA2 Stream 0 global Interrupt                                    */
S  DMA2_Stream1_IRQn           = 57,     /*!< DMA2 Stream 1 global Interrupt                                    */
S  DMA2_Stream2_IRQn           = 58,     /*!< DMA2 Stream 2 global Interrupt                                    */
S  DMA2_Stream3_IRQn           = 59,     /*!< DMA2 Stream 3 global Interrupt                                    */
S  DMA2_Stream4_IRQn           = 60,     /*!< DMA2 Stream 4 global Interrupt                                    */
S  CAN2_TX_IRQn                = 63,     /*!< CAN2 TX Interrupt                                                 */
S  CAN2_RX0_IRQn               = 64,     /*!< CAN2 RX0 Interrupt                                                */
S  CAN2_RX1_IRQn               = 65,     /*!< CAN2 RX1 Interrupt                                                */
S  CAN2_SCE_IRQn               = 66,     /*!< CAN2 SCE Interrupt                                                */
S  OTG_FS_IRQn                 = 67,     /*!< USB OTG FS global Interrupt                                       */
S  DMA2_Stream5_IRQn           = 68,     /*!< DMA2 Stream 5 global interrupt                                    */
S  DMA2_Stream6_IRQn           = 69,     /*!< DMA2 Stream 6 global interrupt                                    */
S  DMA2_Stream7_IRQn           = 70,     /*!< DMA2 Stream 7 global interrupt                                    */
S  USART6_IRQn                 = 71,     /*!< USART6 global interrupt                                           */
S  I2C3_EV_IRQn                = 72,     /*!< I2C3 event interrupt                                              */
S  I2C3_ER_IRQn                = 73,     /*!< I2C3 error interrupt                                              */
S  OTG_HS_EP1_OUT_IRQn         = 74,     /*!< USB OTG HS End Point 1 Out global interrupt                       */
S  OTG_HS_EP1_IN_IRQn          = 75,     /*!< USB OTG HS End Point 1 In global interrupt                        */
S  OTG_HS_WKUP_IRQn            = 76,     /*!< USB OTG HS Wakeup through EXTI interrupt                          */
S  OTG_HS_IRQn                 = 77,     /*!< USB OTG HS global interrupt                                       */
S  DCMI_IRQn                   = 78,     /*!< DCMI global interrupt                                             */
S  FPU_IRQn                    = 81,     /*!< FPU global interrupt                                              */
S  SPI4_IRQn                   = 84,     /*!< SPI4 global Interrupt                                             */
S  SAI1_IRQn                   = 87,     /*!< SAI1 global Interrupt                                             */
S  SAI2_IRQn                   = 91,     /*!< SAI2 global Interrupt                                             */
S  QUADSPI_IRQn                = 92,     /*!< QuadSPI global Interrupt                                          */
S  CEC_IRQn                    = 93,     /*!< QuadSPI global Interrupt                                          */
S  SPDIF_RX_IRQn               = 94,     /*!< QuadSPI global Interrupt                                          */
S  FMPI2C1_EV_IRQn             = 95,     /*!< FMPI2C Event Interrupt                                            */
S  FMPI2C1_ER_IRQn             = 96      /*!< FMPCI2C Error Interrupt                                           */
N#endif /* STM32F446xx */
N
N#if defined(STM32F412xG)
X#if 0L
S  CAN1_TX_IRQn                = 19,     /*!< CAN1 TX Interrupt                                                 */
S  CAN1_RX0_IRQn               = 20,     /*!< CAN1 RX0 Interrupt                                                */
S  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                                */
S  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                                */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
S  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break interrupt and TIM9 global interrupt                    */
S  TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global interrupt                  */
S  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                                    */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                             */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                             */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                             */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */  
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
S  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                                           */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
S  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
S  OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS Wakeup through EXTI line interrupt                     */
S  TIM8_BRK_TIM12_IRQn         = 43,     /*!< TIM8 Break Interrupt and TIM12 global interrupt                   */
S  TIM8_UP_TIM13_IRQn          = 44,     /*!< TIM8 Update Interrupt and TIM13 global interrupt                  */
S  TIM8_TRG_COM_TIM14_IRQn     = 45,     /*!< TIM8 Trigger and Commutation Interrupt and TIM14 global interrupt */
S  TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare Interrupt                                    */
S  DMA1_Stream7_IRQn           = 47,     /*!< DMA1 Stream7 Interrupt                                            */
S  FSMC_IRQn                   = 48,     /*!< FSMC global Interrupt                                              */
S  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                             */
S  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                             */
S  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                             */
S  TIM6_IRQn                   = 54,     /*!< TIM6 global interrupt                                             */
S  TIM7_IRQn                   = 55,     /*!< TIM7 global interrupt                                             */
S  DMA2_Stream0_IRQn           = 56,     /*!< DMA2 Stream 0 global Interrupt                                    */
S  DMA2_Stream1_IRQn           = 57,     /*!< DMA2 Stream 1 global Interrupt                                    */
S  DMA2_Stream2_IRQn           = 58,     /*!< DMA2 Stream 2 global Interrupt                                    */
S  DMA2_Stream3_IRQn           = 59,     /*!< DMA2 Stream 3 global Interrupt                                    */
S  DMA2_Stream4_IRQn           = 60,     /*!< DMA2 Stream 4 global Interrupt                                    */
S  DFSDM1_FLT0_IRQn            = 61,     /*!< DFSDM1 Filter 0 global Interrupt                                  */
S  DFSDM1_FLT1_IRQn            = 62,     /*!< DFSDM1 Filter 1 global Interrupt                                  */
S  CAN2_TX_IRQn                = 63,     /*!< CAN2 TX Interrupt                                                 */
S  CAN2_RX0_IRQn               = 64,     /*!< CAN2 RX0 Interrupt                                                */
S  CAN2_RX1_IRQn               = 65,     /*!< CAN2 RX1 Interrupt                                                */
S  CAN2_SCE_IRQn               = 66,     /*!< CAN2 SCE Interrupt                                                */
S  OTG_FS_IRQn                 = 67,     /*!< USB OTG FS global Interrupt                                       */
S  DMA2_Stream5_IRQn           = 68,     /*!< DMA2 Stream 5 global interrupt                                    */
S  DMA2_Stream6_IRQn           = 69,     /*!< DMA2 Stream 6 global interrupt                                    */
S  DMA2_Stream7_IRQn           = 70,     /*!< DMA2 Stream 7 global interrupt                                    */
S  USART6_IRQn                 = 71,     /*!< USART6 global interrupt                                           */
S  I2C3_EV_IRQn                = 72,     /*!< I2C3 event interrupt                                              */
S  I2C3_ER_IRQn                = 73,     /*!< I2C3 error interrupt                                              */
S  RNG_IRQn                    = 80,     /*!< RNG global Interrupt                                              */
S  FPU_IRQn                    = 81,     /*!< FPU global interrupt                                              */
S  SPI4_IRQn                   = 84,     /*!< SPI4 global Interrupt                                             */
S  SPI5_IRQn                   = 85,      /*!< SPI5 global Interrupt                                            */
S  QUADSPI_IRQn                = 92,     /*!< QuadSPI global Interrupt                                          */
S  FMPI2C1_EV_IRQn             = 95,     /*!< FMPI2C1 Event Interrupt                                           */
S  FMPI2C1_ER_IRQn             = 96      /*!< FMPI2C1 Error Interrupt                                           */
N#endif /* STM32F412xG */
N
N#if defined(STM32F413_423xx)
X#if 0L
S  CAN1_TX_IRQn                = 19,     /*!< CAN1 TX Interrupt                                                 */
S  CAN1_RX0_IRQn               = 20,     /*!< CAN1 RX0 Interrupt                                                */
S  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                                */
S  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                                */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
S  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break interrupt and TIM9 global interrupt                    */
S  TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global interrupt                  */
S  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                                    */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                             */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                             */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                             */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */  
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
S  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                                           */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
S  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
S  OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS Wakeup through EXTI line interrupt                     */
S  TIM8_BRK_TIM12_IRQn         = 43,     /*!< TIM8 Break Interrupt and TIM12 global interrupt                   */
S  TIM8_UP_TIM13_IRQn          = 44,     /*!< TIM8 Update Interrupt and TIM13 global interrupt                  */
S  TIM8_TRG_COM_TIM14_IRQn     = 45,     /*!< TIM8 Trigger and Commutation Interrupt and TIM14 global interrupt */
S  TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare Interrupt                                    */
S  DMA1_Stream7_IRQn           = 47,     /*!< DMA1 Stream7 Interrupt                                            */
S  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                             */
S  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                             */
S  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                             */
S  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                                            */
S  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                                            */
S  TIM6_DAC_IRQn               = 54,     /*!< TIM6 and DAC1&2 global Interrupt                                  */
S  TIM7_IRQn                   = 55,     /*!< TIM7 global interrupt                                             */
S  DMA2_Stream0_IRQn           = 56,     /*!< DMA2 Stream 0 global Interrupt                                    */
S  DMA2_Stream1_IRQn           = 57,     /*!< DMA2 Stream 1 global Interrupt                                    */
S  DMA2_Stream2_IRQn           = 58,     /*!< DMA2 Stream 2 global Interrupt                                    */
S  DMA2_Stream3_IRQn           = 59,     /*!< DMA2 Stream 3 global Interrupt                                    */
S  DMA2_Stream4_IRQn           = 60,     /*!< DMA2 Stream 4 global Interrupt                                    */
S  DFSDM1_FLT0_IRQn            = 61,     /*!< DFSDM1 Filter 0 global Interrupt                                  */
S  DFSDM1_FLT1_IRQn            = 62,     /*!< DFSDM1 Filter 1 global Interrupt                                  */
S  CAN2_TX_IRQn                = 63,     /*!< CAN2 TX Interrupt                                                 */
S  CAN2_RX0_IRQn               = 64,     /*!< CAN2 RX0 Interrupt                                                */
S  CAN2_RX1_IRQn               = 65,     /*!< CAN2 RX1 Interrupt                                                */
S  CAN2_SCE_IRQn               = 66,     /*!< CAN2 SCE Interrupt                                                */
S  OTG_FS_IRQn                 = 67,     /*!< USB OTG FS global Interrupt                                       */
S  DMA2_Stream5_IRQn           = 68,     /*!< DMA2 Stream 5 global interrupt                                    */
S  DMA2_Stream6_IRQn           = 69,     /*!< DMA2 Stream 6 global interrupt                                    */
S  DMA2_Stream7_IRQn           = 70,     /*!< DMA2 Stream 7 global interrupt                                    */
S  USART6_IRQn                 = 71,     /*!< USART6 global interrupt                                           */
S  I2C3_EV_IRQn                = 72,     /*!< I2C3 event interrupt                                              */
S  I2C3_ER_IRQn                = 73,     /*!< I2C3 error interrupt                                              */
S  CAN3_TX_IRQn                = 74,     /*!< CAN3 TX Interrupt                                                 */
S  CAN3_RX0_IRQn               = 75,     /*!< CAN3 RX0 Interrupt                                                */
S  CAN3_RX1_IRQn               = 76,     /*!< CAN3 RX1 Interrupt                                                */
S  CAN3_SCE_IRQn               = 77,     /*!< CAN3 SCE Interrupt                                                */
S  RNG_IRQn                    = 80,     /*!< RNG global Interrupt                                              */
S  FPU_IRQn                    = 81,     /*!< FPU global interrupt                                              */
S  UART7_IRQn                  = 82,     /*!< UART7 global interrupt                                            */  
S  UART8_IRQn                  = 83,     /*!< UART8 global interrupt                                            */   
S  SPI4_IRQn                   = 84,     /*!< SPI4 global Interrupt                                             */
S  SPI5_IRQn                   = 85,     /*!< SPI5 global Interrupt                                             */
S  SAI1_IRQn                   = 87,     /*!< Serial Audio Interface 1 global interrupt                         */
S  UART9_IRQn                  = 88,     /*!< UART9 global Interrupt                                            */
S  UART10_IRQn                 = 89,     /*!< UART10 global Interrupt                                           */  
S  QUADSPI_IRQn                = 92,     /*!< QuadSPI global Interrupt                                          */
S  FMPI2C1_EV_IRQn             = 95,     /*!< FMPI2C1 Event Interrupt                                           */
S  FMPI2C1_ER_IRQn             = 96,     /*!< FMPI2C1 Error Interrupt                                           */
S  LPTIM1_IRQn                 = 97,     /*!< LP TIM1 interrupt                                                 */
S  DFSDM2_FLT0_IRQn            = 98,     /*!< DFSDM2 Filter 0 global Interrupt                                  */
S  DFSDM2_FLT1_IRQn            = 99,     /*!< DFSDM2 Filter 1 global Interrupt                                  */
S  DFSDM2_FLT2_IRQn            = 100,    /*!< DFSDM2 Filter 2 global Interrupt                                  */
S  DFSDM2_FLT3_IRQn            = 101     /*!< DFSDM2 Filter 3 global Interrupt                                  */
N#endif /* STM32F413_423xx */
N} IRQn_Type;
N
N/**
N  * @}
N  */
N
N#include "core_cm4.h"             /* Cortex-M4 processor and core peripherals */
L 1 "..\..\Libraries\CMSIS\Include\core_cm4.h" 1
N/**************************************************************************//**
N * @file     core_cm4.h
N * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
N * @version  V4.10
N * @date     18. March 2015
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifndef __CORE_CM4_H_GENERIC
N#define __CORE_CM4_H_GENERIC
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \ingroup Cortex_M4
N  @{
N */
N
N/*  CMSIS CM4 definitions */
N#define __CM4_CMSIS_VERSION_MAIN  (0x04)                                   /*!< [31:16] CMSIS HAL main version   */
N#define __CM4_CMSIS_VERSION_SUB   (0x00)                                   /*!< [15:0]  CMSIS HAL sub version    */
N#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16) | \
N                                    __CM4_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16) |                                     __CM4_CMSIS_VERSION_SUB          )      
N
N#define __CORTEX_M                (0x04)                                   /*!< Cortex-M Core                    */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )
S  #define __packed
S  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler      */
S  #define __INLINE         inline                                    /*use -pc99 on compile line !< inline keyword for COSMIC Compiler   */
S  #define __STATIC_INLINE  static inline
S
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and functions.
N*/
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 1L
N    #if (__FPU_PRESENT == 1)
X    #if (1 == 1)
N      #define __FPU_USED       1
N    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
N    #endif
N  #else
S    #define __FPU_USED         0
N  #endif
N
N#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI_VFP_SUPPORT__
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
S
S#elif defined ( __CSMC__ )		/* Cosmic */
S  #if ( __CSMC__ & 0x400)		// FPU present for parser
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
N#endif
N
N#include <stdint.h>                      /* standard types definitions                      */
L 1 "d:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 188 "..\..\Libraries\CMSIS\Include\core_cm4.h" 2
N#include <core_cmInstr.h>                /* Core Instruction Access                         */
L 1 "..\..\Libraries\CMSIS\Include\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V4.10
N * @date     18. March 2015
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2014 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060422 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor,
N    so that all instructions following the ISB are fetched from cache or
N    memory, after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0)
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier.
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0)
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0)
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/** \brief  Rotate Right in unsigned value (32 bit)
N
N    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N
N    \param [in]    value  Value to rotate
N    \param [in]    value  Number of Bits to rotate
N    \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/** \brief  Breakpoint
N
N    This function causes the processor to enter Debug state.
N    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N
N    \param [in]    value  is ignored by the processor.
N                   If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/** \brief  Reverse bit order of value
N
N    This function reverses the bit order of the given value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
X#if       ((0x04) >= 0x03) || (__CORTEX_SC >= 300)
N  #define __RBIT                          __rbit
N#else
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S  int32_t s = 4 /*sizeof(v)*/ * 8 - 1; // extra shift needed at end
S
S  result = value;                      // r will be reversed bits of v; first get LSB of v
S  for (value >>= 1; value; value >>= 1)
S  {
S    result <<= 1;
S    result |= value & 1;
S    s--;
S  }
S  result <<= s;                       // shift when v's highest bits are zero
S  return(result);
S}
N#endif
N
N
N/** \brief  Count leading zeros
N
N    This function counts the number of leading zeros of a data value.
N
N    \param [in]  value  Value to count the leading zeros
N    \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
X#if       ((0x04) >= 0x03) || (__CORTEX_SC >= 300)
N
N/** \brief  LDR Exclusive (8 bit)
N
N    This function executes a exclusive LDR instruction for 8 bit value.
N
N    \param [in]    ptr  Pointer to data
N    \return             value of type uint8_t at (*ptr)
N */
N#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
N
N
N/** \brief  LDR Exclusive (16 bit)
N
N    This function executes a exclusive LDR instruction for 16 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint16_t at (*ptr)
N */
N#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
N
N
N/** \brief  LDR Exclusive (32 bit)
N
N    This function executes a exclusive LDR instruction for 32 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint32_t at (*ptr)
N */
N#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
N
N
N/** \brief  STR Exclusive (8 bit)
N
N    This function executes a exclusive STR instruction for 8 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXB(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  STR Exclusive (16 bit)
N
N    This function executes a exclusive STR instruction for 16 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXH(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  STR Exclusive (32 bit)
N
N    This function executes a exclusive STR instruction for 32 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXW(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  Remove the exclusive lock
N
N    This function removes the exclusive lock which is created by LDREX.
N
N */
N#define __CLREX                           __clrex
N
N
N/** \brief  Signed Saturate
N
N    This function saturates a signed value.
N
N    \param [in]  value  Value to be saturated
N    \param [in]    sat  Bit position to saturate to (1..32)
N    \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/** \brief  Unsigned Saturate
N
N    This function saturates an unsigned value.
N
N    \param [in]  value  Value to be saturated
N    \param [in]    sat  Bit position to saturate to (0..31)
N    \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/** \brief  Rotate Right with Extend (32 bit)
N
N    This function moves each bit of a bitstring right by one bit.
N    The carry input is shifted in at the left end of the bitstring.
N
N    \param [in]    value  Value to rotate
N    \return               Rotated value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
X__attribute__((section(".rrx_text"))) static __inline __asm uint32_t __RRX(uint32_t value)
N{
N  rrx r0, r0
N  bx lr
N}
N#endif
N
N
N/** \brief  LDRT Unprivileged (8 bit)
N
N    This function executes a Unprivileged LDRT instruction for 8 bit value.
N
N    \param [in]    ptr  Pointer to data
N    \return             value of type uint8_t at (*ptr)
N */
N#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
N
N
N/** \brief  LDRT Unprivileged (16 bit)
N
N    This function executes a Unprivileged LDRT instruction for 16 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint16_t at (*ptr)
N */
N#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
N
N
N/** \brief  LDRT Unprivileged (32 bit)
N
N    This function executes a Unprivileged LDRT instruction for 32 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint32_t at (*ptr)
N */
N#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
N
N
N/** \brief  STRT Unprivileged (8 bit)
N
N    This function executes a Unprivileged STRT instruction for 8 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N */
N#define __STRBT(value, ptr)               __strt(value, ptr)
N
N
N/** \brief  STRT Unprivileged (16 bit)
N
N    This function executes a Unprivileged STRT instruction for 16 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N */
N#define __STRHT(value, ptr)               __strt(value, ptr)
N
N
N/** \brief  STRT Unprivileged (32 bit)
N
N    This function executes a Unprivileged STRT instruction for 32 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N */
N#define __STRT(value, ptr)                __strt(value, ptr)
N
N#endif /* (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300) */
N
N
N#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/* Define macros for porting to both thumb1 and thumb2.
S * For thumb1, use low register (r0-r7), specified by constrant "l"
S * Otherwise, use general registers, specified by constrant "r" */
S#if defined (__thumb__) && !defined (__thumb2__)
S#define __CMSIS_GCC_OUT_REG(r) "=l" (r)
S#define __CMSIS_GCC_USE_REG(r) "l" (r)
S#else
S#define __CMSIS_GCC_OUT_REG(r) "=r" (r)
S#define __CMSIS_GCC_USE_REG(r) "r" (r)
S#endif
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor,
S    so that all instructions following the ISB are fetched from cache or
S    memory, after the instruction has been completed.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
S{
S  __ASM volatile ("isb 0xF":::"memory");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier.
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb 0xF":::"memory");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before
S    and after the instruction, without ensuring their completion.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb 0xF":::"memory");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __REV(uint32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
S  return __builtin_bswap32(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__((always_inline)) __STATIC_INLINE int32_t __REVSH(int32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S  return (short)__builtin_bswap16(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Rotate Right in unsigned value (32 bit)
S
S    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
S
S    \param [in]    value  Value to rotate
S    \param [in]    value  Number of Bits to rotate
S    \return               Rotated value
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
S{
S  return (op1 >> op2) | (op1 << (32 - op2));
S}
S
S
S/** \brief  Breakpoint
S
S    This function causes the processor to enter Debug state.
S    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
S
S    \param [in]    value  is ignored by the processor.
S                   If required, a debugger can use it to store additional information about the breakpoint.
S */
S#define __BKPT(value)                       __ASM volatile ("bkpt "#value)
S
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S
S#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S#else
S  int32_t s = 4 /*sizeof(v)*/ * 8 - 1; // extra shift needed at end
S
S  result = value;                      // r will be reversed bits of v; first get LSB of v
S  for (value >>= 1; value; value >>= 1)
S  {
S    result <<= 1;
S    result |= value & 1;
S    s--;
S  }
S  result <<= s;                       // shift when v's highest bits are zero
S#endif
S  return(result);
S}
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S#define __CLZ             __builtin_clz
S
S
S#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function executes a exclusive LDR instruction for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__((always_inline)) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint8_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function executes a exclusive LDR instruction for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__((always_inline)) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint16_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function executes a exclusive LDR instruction for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function executes a exclusive STR instruction for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function executes a exclusive STR instruction for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function executes a exclusive STR instruction for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__((always_inline)) __STATIC_INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex" ::: "memory");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Rotate Right with Extend (32 bit)
S
S    This function moves each bit of a bitstring right by one bit.
S    The carry input is shifted in at the left end of the bitstring.
S
S    \param [in]    value  Value to rotate
S    \return               Rotated value
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RRX(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rrx %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S}
S
S
S/** \brief  LDRT Unprivileged (8 bit)
S
S    This function executes a Unprivileged LDRT instruction for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__((always_inline)) __STATIC_INLINE uint8_t __LDRBT(volatile uint8_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrbt %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrbt %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint8_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDRT Unprivileged (16 bit)
S
S    This function executes a Unprivileged LDRT instruction for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__((always_inline)) __STATIC_INLINE uint16_t __LDRHT(volatile uint16_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrht %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrht %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint16_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDRT Unprivileged (32 bit)
S
S    This function executes a Unprivileged LDRT instruction for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __LDRT(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrt %0, %1" : "=r" (result) : "Q" (*addr) );
S   return(result);
S}
S
S
S/** \brief  STRT Unprivileged (8 bit)
S
S    This function executes a Unprivileged STRT instruction for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S */
S__attribute__((always_inline)) __STATIC_INLINE void __STRBT(uint8_t value, volatile uint8_t *addr)
S{
S   __ASM volatile ("strbt %1, %0" : "=Q" (*addr) : "r" ((uint32_t)value) );
S}
S
S
S/** \brief  STRT Unprivileged (16 bit)
S
S    This function executes a Unprivileged STRT instruction for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S */
S__attribute__((always_inline)) __STATIC_INLINE void __STRHT(uint16_t value, volatile uint16_t *addr)
S{
S   __ASM volatile ("strht %1, %0" : "=Q" (*addr) : "r" ((uint32_t)value) );
S}
S
S
S/** \brief  STRT Unprivileged (32 bit)
S
S    This function executes a Unprivileged STRT instruction for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S */
S__attribute__((always_inline)) __STATIC_INLINE void __STRT(uint32_t value, volatile uint32_t *addr)
S{
S   __ASM volatile ("strt %1, %0" : "=Q" (*addr) : "r" (value) );
S}
S
S#endif /* (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300) */
S
S
S#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
S
S#elif defined ( __CSMC__ ) /*------------------ COSMIC Compiler -------------------*/
S/* Cosmic specific functions */
S#include <cmsis_csm.h>
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 189 "..\..\Libraries\CMSIS\Include\core_cm4.h" 2
N#include <core_cmFunc.h>                 /* Core Function Access                            */
L 1 "..\..\Libraries\CMSIS\Include\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V4.10
N * @date     18. March 2015
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060422 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/** \brief  Get IPSR Register
N
N    This function returns the content of the IPSR Register.
N
N    \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
X#if       ((0x04) >= 0x03) || (__CORTEX_SC >= 300)
N
N/** \brief  Enable FIQ
N
N    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
N    Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/** \brief  Disable FIQ
N
N    This function disables FIQ interrupts by setting the F-bit in the CPSR.
N    Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/** \brief  Get Base Priority
N
N    This function returns the current value of the Base Priority register.
N
N    \return               Base Priority register value
N */
N__STATIC_INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/** \brief  Set Base Priority
N
N    This function assigns the given value to the Base Priority register.
N
N    \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xff);
N}
N
N
N/** \brief  Set Base Priority with condition
N
N    This function assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
N    or the new value increases the BASEPRI priority level.
N
N    \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
Xstatic __inline void __set_BASEPRI_MAX(uint32_t basePri)
N{
N  register uint32_t __regBasePriMax      __ASM("basepri_max");
X  register uint32_t __regBasePriMax      __asm("basepri_max");
N  __regBasePriMax = (basePri & 0xff);
N}
N
N
N/** \brief  Get Fault Mask
N
N    This function returns the current value of the Fault Mask register.
N
N    \return               Fault Mask register value
N */
N__STATIC_INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/** \brief  Set Fault Mask
N
N    This function assigns the given value to the Fault Mask register.
N
N    \param [in]    faultMask  Fault Mask value to set
N */
N__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1);
N}
N
N#endif /* (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300) */
N
N
N#if       (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07)
X#if       ((0x04) == 0x04) || ((0x04) == 0x07)
N
N/** \brief  Get FPSCR
N
N    This function returns the current value of the Floating Point Status/Control register.
N
N    \return               Floating Point Status/Control register value
N */
N__STATIC_INLINE uint32_t __get_FPSCR(void)
Xstatic __inline uint32_t __get_FPSCR(void)
N{
N#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
X#if (1 == 1) && (1 == 1)
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  return(__regfpscr);
N#else
S   return(0);
N#endif
N}
N
N
N/** \brief  Set FPSCR
N
N    This function assigns the given value to the Floating Point Status/Control register.
N
N    \param [in]    fpscr  Floating Point Status/Control value to set
N */
N__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
Xstatic __inline void __set_FPSCR(uint32_t fpscr)
N{
N#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
X#if (1 == 1) && (1 == 1)
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  __regfpscr = (fpscr);
N#endif
N}
N
N#endif /* (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07) */
N
N
N#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i" : : : "memory");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i" : : : "memory");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
S}
S
S
S/** \brief  Get IPSR Register
S
S    This function returns the content of the IPSR Register.
S
S    \return               IPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f" : : : "memory");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f" : : : "memory");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
S}
S
S
S/** \brief  Set Base Priority with condition
S
S    This function assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
S	or the new value increases the BASEPRI priority level.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI_MAX(uint32_t value)
S{
S  __ASM volatile ("MSR basepri_max, %0" : : "r" (value) : "memory");
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  uint32_t result;
S
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
S  __ASM volatile ("");
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
S  __ASM volatile ("");
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07) */
S
S
S#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
S
S#elif defined ( __CSMC__ ) /*------------------ COSMIC Compiler -------------------*/
S/* Cosmic specific functions */
S#include <cmsis_csm.h>
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N#endif /* __CORE_CMFUNC_H */
L 190 "..\..\Libraries\CMSIS\Include\core_cm4.h" 2
N#include <core_cmSimd.h>                 /* Compiler specific SIMD Intrinsics               */
L 1 "..\..\Libraries\CMSIS\Include\core_cmSimd.h" 1
N/**************************************************************************//**
N * @file     core_cmSimd.h
N * @brief    CMSIS Cortex-M SIMD Header File
N * @version  V4.10
N * @date     18. March 2015
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2014 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifndef __CORE_CMSIMD_H
N#define __CORE_CMSIMD_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N ******************************************************************************/
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N#define __SADD8                           __sadd8
N#define __QADD8                           __qadd8
N#define __SHADD8                          __shadd8
N#define __UADD8                           __uadd8
N#define __UQADD8                          __uqadd8
N#define __UHADD8                          __uhadd8
N#define __SSUB8                           __ssub8
N#define __QSUB8                           __qsub8
N#define __SHSUB8                          __shsub8
N#define __USUB8                           __usub8
N#define __UQSUB8                          __uqsub8
N#define __UHSUB8                          __uhsub8
N#define __SADD16                          __sadd16
N#define __QADD16                          __qadd16
N#define __SHADD16                         __shadd16
N#define __UADD16                          __uadd16
N#define __UQADD16                         __uqadd16
N#define __UHADD16                         __uhadd16
N#define __SSUB16                          __ssub16
N#define __QSUB16                          __qsub16
N#define __SHSUB16                         __shsub16
N#define __USUB16                          __usub16
N#define __UQSUB16                         __uqsub16
N#define __UHSUB16                         __uhsub16
N#define __SASX                            __sasx
N#define __QASX                            __qasx
N#define __SHASX                           __shasx
N#define __UASX                            __uasx
N#define __UQASX                           __uqasx
N#define __UHASX                           __uhasx
N#define __SSAX                            __ssax
N#define __QSAX                            __qsax
N#define __SHSAX                           __shsax
N#define __USAX                            __usax
N#define __UQSAX                           __uqsax
N#define __UHSAX                           __uhsax
N#define __USAD8                           __usad8
N#define __USADA8                          __usada8
N#define __SSAT16                          __ssat16
N#define __USAT16                          __usat16
N#define __UXTB16                          __uxtb16
N#define __UXTAB16                         __uxtab16
N#define __SXTB16                          __sxtb16
N#define __SXTAB16                         __sxtab16
N#define __SMUAD                           __smuad
N#define __SMUADX                          __smuadx
N#define __SMLAD                           __smlad
N#define __SMLADX                          __smladx
N#define __SMLALD                          __smlald
N#define __SMLALDX                         __smlaldx
N#define __SMUSD                           __smusd
N#define __SMUSDX                          __smusdx
N#define __SMLSD                           __smlsd
N#define __SMLSDX                          __smlsdx
N#define __SMLSLD                          __smlsld
N#define __SMLSLDX                         __smlsldx
N#define __SEL                             __sel
N#define __QADD                            __qadd
N#define __QSUB                            __qsub
N
N#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
N                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
N
N#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
N                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
N
N#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
N                                                      ((int64_t)(ARG3) << 32)      ) >> 32))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32)      ) >> 32))
N
N
N#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("sadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("ssub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("usub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("sadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("ssub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("usub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("sasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("ssax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("usax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USAD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("usad8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USADA8(uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S
S  __ASM volatile ("usada8 %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S#define __SSAT16(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT16(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S#define __USAT16(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT16(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UXTB16(uint32_t op1)
S{
S  uint32_t result;
S
S  __ASM volatile ("uxtb16 %0, %1" : "=r" (result) : "r" (op1));
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UXTAB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uxtab16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SXTB16(uint32_t op1)
S{
S  uint32_t result;
S
S  __ASM volatile ("sxtb16 %0, %1" : "=r" (result) : "r" (op1));
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SXTAB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("sxtab16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUAD  (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("smuad %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUADX (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("smuadx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLAD (uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S
S  __ASM volatile ("smlad %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLADX (uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S
S  __ASM volatile ("smladx %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint64_t __SMLALD (uint32_t op1, uint32_t op2, uint64_t acc)
S{
S  union llreg_u{
S    uint32_t w32[2];
S    uint64_t w64;
S  } llr;
S  llr.w64 = acc;
S
S#ifndef __ARMEB__   // Little endian
S  __ASM volatile ("smlald %0, %1, %2, %3" : "=r" (llr.w32[0]), "=r" (llr.w32[1]): "r" (op1), "r" (op2) , "0" (llr.w32[0]), "1" (llr.w32[1]) );
S#else               // Big endian
S  __ASM volatile ("smlald %0, %1, %2, %3" : "=r" (llr.w32[1]), "=r" (llr.w32[0]): "r" (op1), "r" (op2) , "0" (llr.w32[1]), "1" (llr.w32[0]) );
S#endif
S
S  return(llr.w64);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint64_t __SMLALDX (uint32_t op1, uint32_t op2, uint64_t acc)
S{
S  union llreg_u{
S    uint32_t w32[2];
S    uint64_t w64;
S  } llr;
S  llr.w64 = acc;
S
S#ifndef __ARMEB__   // Little endian
S  __ASM volatile ("smlaldx %0, %1, %2, %3" : "=r" (llr.w32[0]), "=r" (llr.w32[1]): "r" (op1), "r" (op2) , "0" (llr.w32[0]), "1" (llr.w32[1]) );
S#else               // Big endian
S  __ASM volatile ("smlaldx %0, %1, %2, %3" : "=r" (llr.w32[1]), "=r" (llr.w32[0]): "r" (op1), "r" (op2) , "0" (llr.w32[1]), "1" (llr.w32[0]) );
S#endif
S
S  return(llr.w64);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUSD  (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("smusd %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUSDX (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("smusdx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLSD (uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S
S  __ASM volatile ("smlsd %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLSDX (uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S
S  __ASM volatile ("smlsdx %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint64_t __SMLSLD (uint32_t op1, uint32_t op2, uint64_t acc)
S{
S  union llreg_u{
S    uint32_t w32[2];
S    uint64_t w64;
S  } llr;
S  llr.w64 = acc;
S
S#ifndef __ARMEB__   // Little endian
S  __ASM volatile ("smlsld %0, %1, %2, %3" : "=r" (llr.w32[0]), "=r" (llr.w32[1]): "r" (op1), "r" (op2) , "0" (llr.w32[0]), "1" (llr.w32[1]) );
S#else               // Big endian
S  __ASM volatile ("smlsld %0, %1, %2, %3" : "=r" (llr.w32[1]), "=r" (llr.w32[0]): "r" (op1), "r" (op2) , "0" (llr.w32[1]), "1" (llr.w32[0]) );
S#endif
S
S  return(llr.w64);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint64_t __SMLSLDX (uint32_t op1, uint32_t op2, uint64_t acc)
S{
S  union llreg_u{
S    uint32_t w32[2];
S    uint64_t w64;
S  } llr;
S  llr.w64 = acc;
S
S#ifndef __ARMEB__   // Little endian
S  __ASM volatile ("smlsldx %0, %1, %2, %3" : "=r" (llr.w32[0]), "=r" (llr.w32[1]): "r" (op1), "r" (op2) , "0" (llr.w32[0]), "1" (llr.w32[1]) );
S#else               // Big endian
S  __ASM volatile ("smlsldx %0, %1, %2, %3" : "=r" (llr.w32[1]), "=r" (llr.w32[0]): "r" (op1), "r" (op2) , "0" (llr.w32[1]), "1" (llr.w32[0]) );
S#endif
S
S  return(llr.w64);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SEL  (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("sel %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QADD(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qadd %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSUB(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qsub %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S#define __PKHBT(ARG1,ARG2,ARG3) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2); \
S  __ASM ("pkhbt %0, %1, %2, lsl %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  ); \
S  __RES; \
S })
X#define __PKHBT(ARG1,ARG2,ARG3) ({                            uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2);   __ASM ("pkhbt %0, %1, %2, lsl %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  );   __RES;  })
S
S#define __PKHTB(ARG1,ARG2,ARG3) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2); \
S  if (ARG3 == 0) \
S    __ASM ("pkhtb %0, %1, %2" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2)  ); \
S  else \
S    __ASM ("pkhtb %0, %1, %2, asr %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  ); \
S  __RES; \
S })
X#define __PKHTB(ARG1,ARG2,ARG3) ({                            uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2);   if (ARG3 == 0)     __ASM ("pkhtb %0, %1, %2" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2)  );   else     __ASM ("pkhtb %0, %1, %2, asr %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  );   __RES;  })
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMMLA (int32_t op1, int32_t op2, int32_t op3)
S{
S int32_t result;
S
S __ASM volatile ("smmla %0, %1, %2, %3" : "=r" (result): "r"  (op1), "r" (op2), "r" (op3) );
S return(result);
S}
S
S
S#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S/* not yet supported */
S
S
S#elif defined ( __CSMC__ ) /*------------------ COSMIC Compiler -------------------*/
S/* Cosmic specific functions */
S#include <cmsis_csm.h>
S
N#endif
N
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CMSIMD_H */
L 191 "..\..\Libraries\CMSIS\Include\core_cm4.h" 2
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM4_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM4_H_DEPENDANT
N#define __CORE_CM4_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM4_REV
S    #define __CM4_REV               0x0000
S    #warning "__CM4_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __FPU_PRESENT
S    #define __FPU_PRESENT             0
S    #warning "__FPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          4
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions                */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
N
N/*@} end of group Cortex_M4 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N  - Core FPU Register
N ******************************************************************************/
N/** \defgroup CMSIS_core_register Defines and Type Definitions
N    \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_CORE  Status and Control Registers
N    \brief  Core Register type definitions.
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
N    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31                                             /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30                                             /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29                                             /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28                                             /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N#define APSR_Q_Pos                         27                                             /*!< APSR: Q Position */
N#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
N
N#define APSR_GE_Pos                        16                                             /*!< APSR: GE Position */
N#define APSR_GE_Msk                        (0xFUL << APSR_GE_Pos)                         /*!< APSR: GE Mask */
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0                                             /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
N    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31                                             /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30                                             /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29                                             /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28                                             /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_Q_Pos                         27                                             /*!< xPSR: Q Position */
N#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
N
N#define xPSR_IT_Pos                        25                                             /*!< xPSR: IT Position */
N#define xPSR_IT_Msk                        (3UL << xPSR_IT_Pos)                           /*!< xPSR: IT Mask */
N
N#define xPSR_T_Pos                         24                                             /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_GE_Pos                        16                                             /*!< xPSR: GE Position */
N#define xPSR_GE_Msk                        (0xFUL << xPSR_GE_Pos)                         /*!< xPSR: GE Mask */
N
N#define xPSR_ISR_Pos                        0                                             /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_FPCA_Pos                    2                                             /*!< CONTROL: FPCA Position */
N#define CONTROL_FPCA_Msk                   (1UL << CONTROL_FPCA_Pos)                      /*!< CONTROL: FPCA Mask */
N
N#define CONTROL_SPSEL_Pos                   1                                             /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N#define CONTROL_nPRIV_Pos                   0                                             /*!< CONTROL: nPRIV Position */
N#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N    \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[8];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[8];                  
N       uint32_t RESERVED0[24];
N  __IO uint32_t ICER[8];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register         */
X  volatile uint32_t ICER[8];                  
N       uint32_t RSERVED1[24];
N  __IO uint32_t ISPR[8];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register          */
X  volatile uint32_t ISPR[8];                  
N       uint32_t RESERVED2[24];
N  __IO uint32_t ICPR[8];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register        */
X  volatile uint32_t ICPR[8];                  
N       uint32_t RESERVED3[24];
N  __IO uint32_t IABR[8];                 /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register           */
X  volatile uint32_t IABR[8];                  
N       uint32_t RESERVED4[56];
N  __IO uint8_t  IP[240];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240];                  
N       uint32_t RESERVED5[644];
N  __O  uint32_t STIR;                    /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register     */
X  volatile  uint32_t STIR;                     
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0                                          /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCB     System Control Block (SCB)
N    \brief      Type definitions for the System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
X  volatile uint32_t ICSR;                     
N  __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register                          */
X  volatile uint32_t VTOR;                     
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N  __IO uint8_t  SHP[12];                 /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12];                  
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N  __IO uint32_t CFSR;                    /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register                    */
X  volatile uint32_t CFSR;                     
N  __IO uint32_t HFSR;                    /*!< Offset: 0x02C (R/W)  HardFault Status Register                             */
X  volatile uint32_t HFSR;                     
N  __IO uint32_t DFSR;                    /*!< Offset: 0x030 (R/W)  Debug Fault Status Register                           */
X  volatile uint32_t DFSR;                     
N  __IO uint32_t MMFAR;                   /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register                      */
X  volatile uint32_t MMFAR;                    
N  __IO uint32_t BFAR;                    /*!< Offset: 0x038 (R/W)  BusFault Address Register                             */
X  volatile uint32_t BFAR;                     
N  __IO uint32_t AFSR;                    /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register                       */
X  volatile uint32_t AFSR;                     
N  __I  uint32_t PFR[2];                  /*!< Offset: 0x040 (R/ )  Processor Feature Register                            */
X  volatile const  uint32_t PFR[2];                   
N  __I  uint32_t DFR;                     /*!< Offset: 0x048 (R/ )  Debug Feature Register                                */
X  volatile const  uint32_t DFR;                      
N  __I  uint32_t ADR;                     /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register                            */
X  volatile const  uint32_t ADR;                      
N  __I  uint32_t MMFR[4];                 /*!< Offset: 0x050 (R/ )  Memory Model Feature Register                         */
X  volatile const  uint32_t MMFR[4];                  
N  __I  uint32_t ISAR[5];                 /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register                   */
X  volatile const  uint32_t ISAR[5];                  
N       uint32_t RESERVED0[5];
N  __IO uint32_t CPACR;                   /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register                   */
X  volatile uint32_t CPACR;                    
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Registers Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* SCB Hard Fault Status Registers Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
N    \brief      Type definitions for the System Control and ID Register not in the SCB
N  @{
N */
N
N/** \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N       uint32_t RESERVED0[1];
N  __I  uint32_t ICTR;                    /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register      */
X  volatile const  uint32_t ICTR;                     
N  __IO uint32_t ACTLR;                   /*!< Offset: 0x008 (R/W)  Auxiliary Control Register              */
X  volatile uint32_t ACTLR;                    
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0                                          /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N#define SCnSCB_ACTLR_DISOOFP_Pos            9                                          /*!< ACTLR: DISOOFP Position */
N#define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: DISOOFP Mask */
N
N#define SCnSCB_ACTLR_DISFPCA_Pos            8                                          /*!< ACTLR: DISFPCA Position */
N#define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: DISFPCA Mask */
N
N#define SCnSCB_ACTLR_DISFOLD_Pos            2                                          /*!< ACTLR: DISFOLD Position */
N#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
N
N#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1                                          /*!< ACTLR: DISDEFWBUF Position */
N#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
N
N#define SCnSCB_ACTLR_DISMCYCINT_Pos         0                                          /*!< ACTLR: DISMCYCINT Position */
N#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N    \brief      Type definitions for the System Timer Registers.
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
N    \brief      Type definitions for the Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/** \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __O  union
X  volatile  union
N  {
N    __O  uint8_t    u8;                  /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit                   */
X    volatile  uint8_t    u8;                   
N    __O  uint16_t   u16;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit                  */
X    volatile  uint16_t   u16;                  
N    __O  uint32_t   u32;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit                  */
X    volatile  uint32_t   u32;                  
N  }  PORT [32];                          /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers               */
N       uint32_t RESERVED0[864];
N  __IO uint32_t TER;                     /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register                 */
X  volatile uint32_t TER;                      
N       uint32_t RESERVED1[15];
N  __IO uint32_t TPR;                     /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register              */
X  volatile uint32_t TPR;                      
N       uint32_t RESERVED2[15];
N  __IO uint32_t TCR;                     /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register                */
X  volatile uint32_t TCR;                      
N       uint32_t RESERVED3[29];
N  __O  uint32_t IWR;                     /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register            */
X  volatile  uint32_t IWR;                      
N  __I  uint32_t IRR;                     /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register             */
X  volatile const  uint32_t IRR;                      
N  __IO uint32_t IMCR;                    /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register     */
X  volatile uint32_t IMCR;                     
N       uint32_t RESERVED4[43];
N  __O  uint32_t LAR;                     /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register                  */
X  volatile  uint32_t LAR;                      
N  __I  uint32_t LSR;                     /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register                  */
X  volatile const  uint32_t LSR;                      
N       uint32_t RESERVED5[6];
N  __I  uint32_t PID4;                    /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                     
N  __I  uint32_t PID5;                    /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                     
N  __I  uint32_t PID6;                    /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                     
N  __I  uint32_t PID7;                    /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                     
N  __I  uint32_t PID0;                    /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                     
N  __I  uint32_t PID1;                    /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                     
N  __I  uint32_t PID2;                    /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                     
N  __I  uint32_t PID3;                    /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                     
N  __I  uint32_t CID0;                    /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                     
N  __I  uint32_t CID1;                    /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                     
N  __I  uint32_t CID2;                    /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                     
N  __I  uint32_t CID3;                    /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                     
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFUL /*<< ITM_TPR_PRIVMASK_Pos*/)            /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16                                             /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10                                             /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1UL /*<< ITM_IWR_ATVALIDM_Pos*/)              /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1UL /*<< ITM_IRR_ATREADYM_Pos*/)              /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1UL /*<< ITM_IMCR_INTEGRATION_Pos*/)          /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1                                             /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0                                             /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
N    \brief      Type definitions for the Data Watchpoint and Trace (DWT)
N  @{
N */
N
N/** \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  Control Register                          */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t CYCCNT;                  /*!< Offset: 0x004 (R/W)  Cycle Count Register                      */
X  volatile uint32_t CYCCNT;                   
N  __IO uint32_t CPICNT;                  /*!< Offset: 0x008 (R/W)  CPI Count Register                        */
X  volatile uint32_t CPICNT;                   
N  __IO uint32_t EXCCNT;                  /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register         */
X  volatile uint32_t EXCCNT;                   
N  __IO uint32_t SLEEPCNT;                /*!< Offset: 0x010 (R/W)  Sleep Count Register                      */
X  volatile uint32_t SLEEPCNT;                 
N  __IO uint32_t LSUCNT;                  /*!< Offset: 0x014 (R/W)  LSU Count Register                        */
X  volatile uint32_t LSUCNT;                   
N  __IO uint32_t FOLDCNT;                 /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register         */
X  volatile uint32_t FOLDCNT;                  
N  __I  uint32_t PCSR;                    /*!< Offset: 0x01C (R/ )  Program Counter Sample Register           */
X  volatile const  uint32_t PCSR;                     
N  __IO uint32_t COMP0;                   /*!< Offset: 0x020 (R/W)  Comparator Register 0                     */
X  volatile uint32_t COMP0;                    
N  __IO uint32_t MASK0;                   /*!< Offset: 0x024 (R/W)  Mask Register 0                           */
X  volatile uint32_t MASK0;                    
N  __IO uint32_t FUNCTION0;               /*!< Offset: 0x028 (R/W)  Function Register 0                       */
X  volatile uint32_t FUNCTION0;                
N       uint32_t RESERVED0[1];
N  __IO uint32_t COMP1;                   /*!< Offset: 0x030 (R/W)  Comparator Register 1                     */
X  volatile uint32_t COMP1;                    
N  __IO uint32_t MASK1;                   /*!< Offset: 0x034 (R/W)  Mask Register 1                           */
X  volatile uint32_t MASK1;                    
N  __IO uint32_t FUNCTION1;               /*!< Offset: 0x038 (R/W)  Function Register 1                       */
X  volatile uint32_t FUNCTION1;                
N       uint32_t RESERVED1[1];
N  __IO uint32_t COMP2;                   /*!< Offset: 0x040 (R/W)  Comparator Register 2                     */
X  volatile uint32_t COMP2;                    
N  __IO uint32_t MASK2;                   /*!< Offset: 0x044 (R/W)  Mask Register 2                           */
X  volatile uint32_t MASK2;                    
N  __IO uint32_t FUNCTION2;               /*!< Offset: 0x048 (R/W)  Function Register 2                       */
X  volatile uint32_t FUNCTION2;                
N       uint32_t RESERVED2[1];
N  __IO uint32_t COMP3;                   /*!< Offset: 0x050 (R/W)  Comparator Register 3                     */
X  volatile uint32_t COMP3;                    
N  __IO uint32_t MASK3;                   /*!< Offset: 0x054 (R/W)  Mask Register 3                           */
X  volatile uint32_t MASK3;                    
N  __IO uint32_t FUNCTION3;               /*!< Offset: 0x058 (R/W)  Function Register 3                       */
X  volatile uint32_t FUNCTION3;                
N} DWT_Type;
N
N/* DWT Control Register Definitions */
N#define DWT_CTRL_NUMCOMP_Pos               28                                          /*!< DWT CTRL: NUMCOMP Position */
N#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
N
N#define DWT_CTRL_NOTRCPKT_Pos              27                                          /*!< DWT CTRL: NOTRCPKT Position */
N#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
N
N#define DWT_CTRL_NOEXTTRIG_Pos             26                                          /*!< DWT CTRL: NOEXTTRIG Position */
N#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
N
N#define DWT_CTRL_NOCYCCNT_Pos              25                                          /*!< DWT CTRL: NOCYCCNT Position */
N#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
N
N#define DWT_CTRL_NOPRFCNT_Pos              24                                          /*!< DWT CTRL: NOPRFCNT Position */
N#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
N
N#define DWT_CTRL_CYCEVTENA_Pos             22                                          /*!< DWT CTRL: CYCEVTENA Position */
N#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
N
N#define DWT_CTRL_FOLDEVTENA_Pos            21                                          /*!< DWT CTRL: FOLDEVTENA Position */
N#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
N
N#define DWT_CTRL_LSUEVTENA_Pos             20                                          /*!< DWT CTRL: LSUEVTENA Position */
N#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
N
N#define DWT_CTRL_SLEEPEVTENA_Pos           19                                          /*!< DWT CTRL: SLEEPEVTENA Position */
N#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
N
N#define DWT_CTRL_EXCEVTENA_Pos             18                                          /*!< DWT CTRL: EXCEVTENA Position */
N#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
N
N#define DWT_CTRL_CPIEVTENA_Pos             17                                          /*!< DWT CTRL: CPIEVTENA Position */
N#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
N
N#define DWT_CTRL_EXCTRCENA_Pos             16                                          /*!< DWT CTRL: EXCTRCENA Position */
N#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
N
N#define DWT_CTRL_PCSAMPLENA_Pos            12                                          /*!< DWT CTRL: PCSAMPLENA Position */
N#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
N
N#define DWT_CTRL_SYNCTAP_Pos               10                                          /*!< DWT CTRL: SYNCTAP Position */
N#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
N
N#define DWT_CTRL_CYCTAP_Pos                 9                                          /*!< DWT CTRL: CYCTAP Position */
N#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
N
N#define DWT_CTRL_POSTINIT_Pos               5                                          /*!< DWT CTRL: POSTINIT Position */
N#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
N
N#define DWT_CTRL_POSTPRESET_Pos             1                                          /*!< DWT CTRL: POSTPRESET Position */
N#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
N
N#define DWT_CTRL_CYCCNTENA_Pos              0                                          /*!< DWT CTRL: CYCCNTENA Position */
N#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
N
N/* DWT CPI Count Register Definitions */
N#define DWT_CPICNT_CPICNT_Pos               0                                          /*!< DWT CPICNT: CPICNT Position */
N#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
N
N/* DWT Exception Overhead Count Register Definitions */
N#define DWT_EXCCNT_EXCCNT_Pos               0                                          /*!< DWT EXCCNT: EXCCNT Position */
N#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
N
N/* DWT Sleep Count Register Definitions */
N#define DWT_SLEEPCNT_SLEEPCNT_Pos           0                                          /*!< DWT SLEEPCNT: SLEEPCNT Position */
N#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
N
N/* DWT LSU Count Register Definitions */
N#define DWT_LSUCNT_LSUCNT_Pos               0                                          /*!< DWT LSUCNT: LSUCNT Position */
N#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
N
N/* DWT Folded-instruction Count Register Definitions */
N#define DWT_FOLDCNT_FOLDCNT_Pos             0                                          /*!< DWT FOLDCNT: FOLDCNT Position */
N#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
N
N/* DWT Comparator Mask Register Definitions */
N#define DWT_MASK_MASK_Pos                   0                                          /*!< DWT MASK: MASK Position */
N#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
N
N/* DWT Comparator Function Register Definitions */
N#define DWT_FUNCTION_MATCHED_Pos           24                                          /*!< DWT FUNCTION: MATCHED Position */
N#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
N
N#define DWT_FUNCTION_DATAVADDR1_Pos        16                                          /*!< DWT FUNCTION: DATAVADDR1 Position */
N#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
N
N#define DWT_FUNCTION_DATAVADDR0_Pos        12                                          /*!< DWT FUNCTION: DATAVADDR0 Position */
N#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
N
N#define DWT_FUNCTION_DATAVSIZE_Pos         10                                          /*!< DWT FUNCTION: DATAVSIZE Position */
N#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
N
N#define DWT_FUNCTION_LNK1ENA_Pos            9                                          /*!< DWT FUNCTION: LNK1ENA Position */
N#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
N
N#define DWT_FUNCTION_DATAVMATCH_Pos         8                                          /*!< DWT FUNCTION: DATAVMATCH Position */
N#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
N
N#define DWT_FUNCTION_CYCMATCH_Pos           7                                          /*!< DWT FUNCTION: CYCMATCH Position */
N#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
N
N#define DWT_FUNCTION_EMITRANGE_Pos          5                                          /*!< DWT FUNCTION: EMITRANGE Position */
N#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
N
N#define DWT_FUNCTION_FUNCTION_Pos           0                                          /*!< DWT FUNCTION: FUNCTION Position */
N#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
N
N/*@}*/ /* end of group CMSIS_DWT */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_TPI     Trace Port Interface (TPI)
N    \brief      Type definitions for the Trace Port Interface (TPI)
N  @{
N */
N
N/** \brief  Structure type to access the Trace Port Interface Register (TPI).
N */
Ntypedef struct
N{
N  __IO uint32_t SSPSR;                   /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register     */
X  volatile uint32_t SSPSR;                    
N  __IO uint32_t CSPSR;                   /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
X  volatile uint32_t CSPSR;                    
N       uint32_t RESERVED0[2];
N  __IO uint32_t ACPR;                    /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
X  volatile uint32_t ACPR;                     
N       uint32_t RESERVED1[55];
N  __IO uint32_t SPPR;                    /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
X  volatile uint32_t SPPR;                     
N       uint32_t RESERVED2[131];
N  __I  uint32_t FFSR;                    /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
X  volatile const  uint32_t FFSR;                     
N  __IO uint32_t FFCR;                    /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
X  volatile uint32_t FFCR;                     
N  __I  uint32_t FSCR;                    /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
X  volatile const  uint32_t FSCR;                     
N       uint32_t RESERVED3[759];
N  __I  uint32_t TRIGGER;                 /*!< Offset: 0xEE8 (R/ )  TRIGGER */
X  volatile const  uint32_t TRIGGER;                  
N  __I  uint32_t FIFO0;                   /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
X  volatile const  uint32_t FIFO0;                    
N  __I  uint32_t ITATBCTR2;               /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
X  volatile const  uint32_t ITATBCTR2;                
N       uint32_t RESERVED4[1];
N  __I  uint32_t ITATBCTR0;               /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
X  volatile const  uint32_t ITATBCTR0;                
N  __I  uint32_t FIFO1;                   /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
X  volatile const  uint32_t FIFO1;                    
N  __IO uint32_t ITCTRL;                  /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
X  volatile uint32_t ITCTRL;                   
N       uint32_t RESERVED5[39];
N  __IO uint32_t CLAIMSET;                /*!< Offset: 0xFA0 (R/W)  Claim tag set */
X  volatile uint32_t CLAIMSET;                 
N  __IO uint32_t CLAIMCLR;                /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
X  volatile uint32_t CLAIMCLR;                 
N       uint32_t RESERVED7[8];
N  __I  uint32_t DEVID;                   /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
X  volatile const  uint32_t DEVID;                    
N  __I  uint32_t DEVTYPE;                 /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
X  volatile const  uint32_t DEVTYPE;                  
N} TPI_Type;
N
N/* TPI Asynchronous Clock Prescaler Register Definitions */
N#define TPI_ACPR_PRESCALER_Pos              0                                          /*!< TPI ACPR: PRESCALER Position */
N#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
N
N/* TPI Selected Pin Protocol Register Definitions */
N#define TPI_SPPR_TXMODE_Pos                 0                                          /*!< TPI SPPR: TXMODE Position */
N#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
N
N/* TPI Formatter and Flush Status Register Definitions */
N#define TPI_FFSR_FtNonStop_Pos              3                                          /*!< TPI FFSR: FtNonStop Position */
N#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
N
N#define TPI_FFSR_TCPresent_Pos              2                                          /*!< TPI FFSR: TCPresent Position */
N#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
N
N#define TPI_FFSR_FtStopped_Pos              1                                          /*!< TPI FFSR: FtStopped Position */
N#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
N
N#define TPI_FFSR_FlInProg_Pos               0                                          /*!< TPI FFSR: FlInProg Position */
N#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
N
N/* TPI Formatter and Flush Control Register Definitions */
N#define TPI_FFCR_TrigIn_Pos                 8                                          /*!< TPI FFCR: TrigIn Position */
N#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
N
N#define TPI_FFCR_EnFCont_Pos                1                                          /*!< TPI FFCR: EnFCont Position */
N#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
N
N/* TPI TRIGGER Register Definitions */
N#define TPI_TRIGGER_TRIGGER_Pos             0                                          /*!< TPI TRIGGER: TRIGGER Position */
N#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
N
N/* TPI Integration ETM Data Register Definitions (FIFO0) */
N#define TPI_FIFO0_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO0: ITM_ATVALID Position */
N#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
N
N#define TPI_FIFO0_ITM_bytecount_Pos        27                                          /*!< TPI FIFO0: ITM_bytecount Position */
N#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
N
N#define TPI_FIFO0_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO0: ETM_ATVALID Position */
N#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
N
N#define TPI_FIFO0_ETM_bytecount_Pos        24                                          /*!< TPI FIFO0: ETM_bytecount Position */
N#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
N
N#define TPI_FIFO0_ETM2_Pos                 16                                          /*!< TPI FIFO0: ETM2 Position */
N#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
N
N#define TPI_FIFO0_ETM1_Pos                  8                                          /*!< TPI FIFO0: ETM1 Position */
N#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
N
N#define TPI_FIFO0_ETM0_Pos                  0                                          /*!< TPI FIFO0: ETM0 Position */
N#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
N
N/* TPI ITATBCTR2 Register Definitions */
N#define TPI_ITATBCTR2_ATREADY_Pos           0                                          /*!< TPI ITATBCTR2: ATREADY Position */
N#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR2_ATREADY_Pos*/)    /*!< TPI ITATBCTR2: ATREADY Mask */
N
N/* TPI Integration ITM Data Register Definitions (FIFO1) */
N#define TPI_FIFO1_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO1: ITM_ATVALID Position */
N#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
N
N#define TPI_FIFO1_ITM_bytecount_Pos        27                                          /*!< TPI FIFO1: ITM_bytecount Position */
N#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
N
N#define TPI_FIFO1_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO1: ETM_ATVALID Position */
N#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
N
N#define TPI_FIFO1_ETM_bytecount_Pos        24                                          /*!< TPI FIFO1: ETM_bytecount Position */
N#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
N
N#define TPI_FIFO1_ITM2_Pos                 16                                          /*!< TPI FIFO1: ITM2 Position */
N#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
N
N#define TPI_FIFO1_ITM1_Pos                  8                                          /*!< TPI FIFO1: ITM1 Position */
N#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
N
N#define TPI_FIFO1_ITM0_Pos                  0                                          /*!< TPI FIFO1: ITM0 Position */
N#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
N
N/* TPI ITATBCTR0 Register Definitions */
N#define TPI_ITATBCTR0_ATREADY_Pos           0                                          /*!< TPI ITATBCTR0: ATREADY Position */
N#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR0_ATREADY_Pos*/)    /*!< TPI ITATBCTR0: ATREADY Mask */
N
N/* TPI Integration Mode Control Register Definitions */
N#define TPI_ITCTRL_Mode_Pos                 0                                          /*!< TPI ITCTRL: Mode Position */
N#define TPI_ITCTRL_Mode_Msk                (0x1UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
N
N/* TPI DEVID Register Definitions */
N#define TPI_DEVID_NRZVALID_Pos             11                                          /*!< TPI DEVID: NRZVALID Position */
N#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
N
N#define TPI_DEVID_MANCVALID_Pos            10                                          /*!< TPI DEVID: MANCVALID Position */
N#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
N
N#define TPI_DEVID_PTINVALID_Pos             9                                          /*!< TPI DEVID: PTINVALID Position */
N#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
N
N#define TPI_DEVID_MinBufSz_Pos              6                                          /*!< TPI DEVID: MinBufSz Position */
N#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
N
N#define TPI_DEVID_AsynClkIn_Pos             5                                          /*!< TPI DEVID: AsynClkIn Position */
N#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
N
N#define TPI_DEVID_NrTraceInput_Pos          0                                          /*!< TPI DEVID: NrTraceInput Position */
N#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
N
N/* TPI DEVTYPE Register Definitions */
N#define TPI_DEVTYPE_MajorType_Pos           4                                          /*!< TPI DEVTYPE: MajorType Position */
N#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
N
N#define TPI_DEVTYPE_SubType_Pos             0                                          /*!< TPI DEVTYPE: SubType Position */
N#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
N
N/*@}*/ /* end of group CMSIS_TPI */
N
N
N#if (__MPU_PRESENT == 1)
X#if (1 == 1)
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
N    \brief      Type definitions for the Memory Protection Unit (MPU)
N  @{
N */
N
N/** \brief  Structure type to access the Memory Protection Unit (MPU).
N */
Ntypedef struct
N{
N  __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register                              */
X  volatile const  uint32_t TYPE;                     
N  __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register                           */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register                     */
X  volatile uint32_t RNR;                      
N  __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register               */
X  volatile uint32_t RBAR;                     
N  __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register         */
X  volatile uint32_t RASR;                     
N  __IO uint32_t RBAR_A1;                 /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register       */
X  volatile uint32_t RBAR_A1;                  
N  __IO uint32_t RASR_A1;                 /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
X  volatile uint32_t RASR_A1;                  
N  __IO uint32_t RBAR_A2;                 /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register       */
X  volatile uint32_t RBAR_A2;                  
N  __IO uint32_t RASR_A2;                 /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
X  volatile uint32_t RASR_A2;                  
N  __IO uint32_t RBAR_A3;                 /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register       */
X  volatile uint32_t RBAR_A3;                  
N  __IO uint32_t RASR_A3;                 /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
X  volatile uint32_t RASR_A3;                  
N} MPU_Type;
N
N/* MPU Type Register */
N#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register */
N#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register */
N#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register */
N#define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register */
N#define MPU_RASR_ATTRS_Pos                 16                                             /*!< MPU RASR: MPU Region Attribute field Position */
N#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
N
N#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: ATTRS.XN Position */
N#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
N
N#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: ATTRS.AP Position */
N#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: ATTRS.TEX Position */
N#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
N
N#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: ATTRS.S Position */
N#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
N
N#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: ATTRS.C Position */
N#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
N
N#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: ATTRS.B Position */
N#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
N
N#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENABLE_Pos                 0                                             /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@} end of group CMSIS_MPU */
N#endif
N
N
N#if (__FPU_PRESENT == 1)
X#if (1 == 1)
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_FPU     Floating Point Unit (FPU)
N    \brief      Type definitions for the Floating Point Unit (FPU)
N  @{
N */
N
N/** \brief  Structure type to access the Floating Point Unit (FPU).
N */
Ntypedef struct
N{
N       uint32_t RESERVED0[1];
N  __IO uint32_t FPCCR;                   /*!< Offset: 0x004 (R/W)  Floating-Point Context Control Register               */
X  volatile uint32_t FPCCR;                    
N  __IO uint32_t FPCAR;                   /*!< Offset: 0x008 (R/W)  Floating-Point Context Address Register               */
X  volatile uint32_t FPCAR;                    
N  __IO uint32_t FPDSCR;                  /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Control Register        */
X  volatile uint32_t FPDSCR;                   
N  __I  uint32_t MVFR0;                   /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0                       */
X  volatile const  uint32_t MVFR0;                    
N  __I  uint32_t MVFR1;                   /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1                       */
X  volatile const  uint32_t MVFR1;                    
N} FPU_Type;
N
N/* Floating-Point Context Control Register */
N#define FPU_FPCCR_ASPEN_Pos                31                                             /*!< FPCCR: ASPEN bit Position */
N#define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCCR: ASPEN bit Mask */
N
N#define FPU_FPCCR_LSPEN_Pos                30                                             /*!< FPCCR: LSPEN Position */
N#define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCCR: LSPEN bit Mask */
N
N#define FPU_FPCCR_MONRDY_Pos                8                                             /*!< FPCCR: MONRDY Position */
N#define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCCR: MONRDY bit Mask */
N
N#define FPU_FPCCR_BFRDY_Pos                 6                                             /*!< FPCCR: BFRDY Position */
N#define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCCR: BFRDY bit Mask */
N
N#define FPU_FPCCR_MMRDY_Pos                 5                                             /*!< FPCCR: MMRDY Position */
N#define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCCR: MMRDY bit Mask */
N
N#define FPU_FPCCR_HFRDY_Pos                 4                                             /*!< FPCCR: HFRDY Position */
N#define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCCR: HFRDY bit Mask */
N
N#define FPU_FPCCR_THREAD_Pos                3                                             /*!< FPCCR: processor mode bit Position */
N#define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCCR: processor mode active bit Mask */
N
N#define FPU_FPCCR_USER_Pos                  1                                             /*!< FPCCR: privilege level bit Position */
N#define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCCR: privilege level bit Mask */
N
N#define FPU_FPCCR_LSPACT_Pos                0                                             /*!< FPCCR: Lazy state preservation active bit Position */
N#define FPU_FPCCR_LSPACT_Msk               (1UL /*<< FPU_FPCCR_LSPACT_Pos*/)              /*!< FPCCR: Lazy state preservation active bit Mask */
N
N/* Floating-Point Context Address Register */
N#define FPU_FPCAR_ADDRESS_Pos               3                                             /*!< FPCAR: ADDRESS bit Position */
N#define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCAR: ADDRESS bit Mask */
N
N/* Floating-Point Default Status Control Register */
N#define FPU_FPDSCR_AHP_Pos                 26                                             /*!< FPDSCR: AHP bit Position */
N#define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDSCR: AHP bit Mask */
N
N#define FPU_FPDSCR_DN_Pos                  25                                             /*!< FPDSCR: DN bit Position */
N#define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDSCR: DN bit Mask */
N
N#define FPU_FPDSCR_FZ_Pos                  24                                             /*!< FPDSCR: FZ bit Position */
N#define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDSCR: FZ bit Mask */
N
N#define FPU_FPDSCR_RMode_Pos               22                                             /*!< FPDSCR: RMode bit Position */
N#define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDSCR: RMode bit Mask */
N
N/* Media and FP Feature Register 0 */
N#define FPU_MVFR0_FP_rounding_modes_Pos    28                                             /*!< MVFR0: FP rounding modes bits Position */
N#define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR0: FP rounding modes bits Mask */
N
N#define FPU_MVFR0_Short_vectors_Pos        24                                             /*!< MVFR0: Short vectors bits Position */
N#define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR0: Short vectors bits Mask */
N
N#define FPU_MVFR0_Square_root_Pos          20                                             /*!< MVFR0: Square root bits Position */
N#define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR0: Square root bits Mask */
N
N#define FPU_MVFR0_Divide_Pos               16                                             /*!< MVFR0: Divide bits Position */
N#define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR0: Divide bits Mask */
N
N#define FPU_MVFR0_FP_excep_trapping_Pos    12                                             /*!< MVFR0: FP exception trapping bits Position */
N#define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR0: FP exception trapping bits Mask */
N
N#define FPU_MVFR0_Double_precision_Pos      8                                             /*!< MVFR0: Double-precision bits Position */
N#define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR0: Double-precision bits Mask */
N
N#define FPU_MVFR0_Single_precision_Pos      4                                             /*!< MVFR0: Single-precision bits Position */
N#define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR0: Single-precision bits Mask */
N
N#define FPU_MVFR0_A_SIMD_registers_Pos      0                                             /*!< MVFR0: A_SIMD registers bits Position */
N#define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL /*<< FPU_MVFR0_A_SIMD_registers_Pos*/)  /*!< MVFR0: A_SIMD registers bits Mask */
N
N/* Media and FP Feature Register 1 */
N#define FPU_MVFR1_FP_fused_MAC_Pos         28                                             /*!< MVFR1: FP fused MAC bits Position */
N#define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR1: FP fused MAC bits Mask */
N
N#define FPU_MVFR1_FP_HPFP_Pos              24                                             /*!< MVFR1: FP HPFP bits Position */
N#define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR1: FP HPFP bits Mask */
N
N#define FPU_MVFR1_D_NaN_mode_Pos            4                                             /*!< MVFR1: D_NaN mode bits Position */
N#define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR1: D_NaN mode bits Mask */
N
N#define FPU_MVFR1_FtZ_mode_Pos              0                                             /*!< MVFR1: FtZ mode bits Position */
N#define FPU_MVFR1_FtZ_mode_Msk             (0xFUL /*<< FPU_MVFR1_FtZ_mode_Pos*/)          /*!< MVFR1: FtZ mode bits Mask */
N
N/*@} end of group CMSIS_FPU */
N#endif
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N    \brief      Type definitions for the Core Debug Registers
N  @{
N */
N
N/** \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IO uint32_t DHCSR;                   /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register    */
X  volatile uint32_t DHCSR;                    
N  __O  uint32_t DCRSR;                   /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register        */
X  volatile  uint32_t DCRSR;                    
N  __IO uint32_t DCRDR;                   /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register            */
X  volatile uint32_t DCRDR;                    
N  __IO uint32_t DEMCR;                   /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                    
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register */
N#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register */
N#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_core_base     Core Definitions
N    \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M4 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address  */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address                   */
N#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address                   */
N#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address                   */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address            */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address               */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                  */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address  */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct           */
N#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct           */
N#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct           */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct    */
N
N#if (__MPU_PRESENT == 1)
X#if (1 == 1)
N  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit             */
N  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit             */
N#endif
N
N#if (__FPU_PRESENT == 1)
X#if (1 == 1)
N  #define FPU_BASE          (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit                */
N  #define FPU               ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit                */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N    \brief      Functions that manage interrupts and exceptions via the NVIC.
N    @{
N */
N
N/** \brief  Set Priority Grouping
N
N  The function sets the priority grouping field using the required unlock sequence.
N  The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N  Only values from 0..7 are used.
N  In case of a conflict between priority grouping and available
N  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N
N    \param [in]      PriorityGroup  Priority grouping field.
N */
N__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
X  reg_value &= ~((uint32_t)((0xFFFFUL << 16) | (7UL << 8)));              
N  reg_value  =  (reg_value                                   |
N                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FAUL << 16) |
N                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/** \brief  Get Priority Grouping
N
N  The function reads the priority grouping field from the NVIC Interrupt Controller.
N
N    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
N */
N__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
X  return ((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) >> 8));
N}
N
N
N/** \brief  Enable External Interrupt
N
N    The function enables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/** \brief  Disable External Interrupt
N
N    The function disables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    The function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not pending.
N    \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    The function sets the pending bit of an external interrupt.
N
N    \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    The function clears the pending bit of an external interrupt.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/** \brief  Get Active Interrupt
N
N    The function reads the active register in NVIC and returns the active bit.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not active.
N    \return             1  Interrupt status is active.
N */
N__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    The function sets the priority of an interrupt.
N
N    \note The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N    \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if((int32_t)IRQn < 0) {
N    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - 4)) & (uint32_t)0xFFUL);
N  }
N  else {
N    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - 4)) & (uint32_t)0xFFUL);
N  }
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    The function reads the priority of an interrupt. The interrupt
N    number can be positive to specify an external (device specific)
N    interrupt, or negative to specify an internal (core) interrupt.
N
N
N    \param [in]   IRQn  Interrupt number.
N    \return             Interrupt Priority. Value is aligned automatically to the implemented
N                        priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if((int32_t)IRQn < 0) {
N    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8 - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8 - 4)));
N  }
N  else {
N    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8 - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               >> (8 - 4)));
N  }
N}
N
N
N/** \brief  Encode Priority
N
N    The function encodes the priority for an interrupt with the given priority group,
N    preemptive priority value, and subpriority value.
N    In case of a conflict between priority grouping and available
N    priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N
N    \param [in]     PriorityGroup  Used priority group.
N    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N    \param [in]       SubPriority  Subpriority value (starting from 0).
N    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(4)) ? (uint32_t)(4) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(4)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(4));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/** \brief  Decode Priority
N
N    The function decodes an interrupt priority value with a given priority group to
N    preemptive priority value and subpriority value.
N    In case of a conflict between priority grouping and available
N    priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N
N    \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N    \param [in]     PriorityGroup  Used priority group.
N    \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N    \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(4)) ? (uint32_t)(4) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(4)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(4));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N/** \brief  System Reset
N
N    The function initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = (uint32_t)((0x5FAUL << 16)    |
N                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                           (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) |
N                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
X                            (1UL << 2)    );          
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0);                                                           
N  while(1) { __NOP(); }                                             /* wait until reset */
X  while(1) { __nop(); }                                              
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N    \brief      Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
N    Counter is in free running mode to generate periodic interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts.
N
N    \return          0  Function succeeded.
N    \return          1  Function failed.
N
N    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N    must contain a vendor-specific implementation of this function.
N
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */
X  if ((ticks - 1UL) > (0xFFFFFFUL )) { return (1UL); }     
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1UL << 4) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_core_DebugFunctions ITM Functions
N    \brief   Functions that access the ITM debug interface.
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters.                         */
N#define                 ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
N
N
N/** \brief  ITM Send Character
N
N    The function transmits a character via the ITM channel 0, and
N    \li Just returns when no debugger is connected that has booked the output.
N    \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
N
N    \param [in]     ch  Character to transmit.
N
N    \returns            Character to transmit.
N */
N__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
X  if (((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL )) != 0UL) &&       
N      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
X      ((((ITM_Type *) (0xE0000000UL) )->TER & 1UL               ) != 0UL)   )      
N  {
N    while (ITM->PORT[0].u32 == 0UL) { __NOP(); }
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0].u32 == 0UL) { __nop(); }
N    ITM->PORT[0].u8 = (uint8_t)ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0].u8 = (uint8_t)ch;
N  }
N  return (ch);
N}
N
N
N/** \brief  ITM Receive Character
N
N    The function inputs a character via the external variable \ref ITM_RxBuffer.
N
N    \return             Received character.
N    \return         -1  No character pending.
N */
N__STATIC_INLINE int32_t ITM_ReceiveChar (void) {
Xstatic __inline int32_t ITM_ReceiveChar (void) {
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer != 0x5AA55AA5) {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = 0x5AA55AA5;        
N  }
N
N  return (ch);
N}
N
N
N/** \brief  ITM Check Character
N
N    The function checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
N
N    \return          0  No character available.
N    \return          1  Character available.
N */
N__STATIC_INLINE int32_t ITM_CheckChar (void) {
Xstatic __inline int32_t ITM_CheckChar (void) {
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer == 0x5AA55AA5) {
N    return (0);                                 /* no character available */
N  } else {
N    return (1);                                 /*    character available */
N  }
N}
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM4_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 818 "..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include\stm32f4xx.h" 2
N#include "system_stm32f4xx.h"
L 1 "..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include\system_stm32f4xx.h" 1
N/**
N  ******************************************************************************
N  * @file    system_stm32f4xx.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    09-November-2016
N  * @brief   CMSIS Cortex-M4 Device System Source File for STM32F4xx devices.       
N  ******************************************************************************  
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************  
N  */ 
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup stm32f4xx_system
N  * @{
N  */  
N  
N/**
N  * @brief Define to prevent recursive inclusion
N  */
N#ifndef __SYSTEM_STM32F4XX_H
N#define __SYSTEM_STM32F4XX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N/** @addtogroup STM32F4xx_System_Includes
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N
N/** @addtogroup STM32F4xx_System_Exported_types
N  * @{
N  */
N
Nextern uint32_t SystemCoreClock;          /*!< System Clock Frequency (Core Clock) */
N
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32F4xx_System_Exported_Constants
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32F4xx_System_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32F4xx_System_Exported_Functions
N  * @{
N  */
N  
Nextern void SystemInit(void);
Nextern void SystemCoreClockUpdate(void);
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__SYSTEM_STM32F4XX_H */
N
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */  
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 819 "..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include\stm32f4xx.h" 2
N#include <stdint.h>
N
N/** @addtogroup Exported_types
N  * @{
N  */  
N/*!< STM32F10x Standard Peripheral Library old types (maintained for legacy purpose) */
Ntypedef int32_t  s32;
Ntypedef int16_t s16;
Ntypedef int8_t  s8;
N
Ntypedef const int32_t sc32;  /*!< Read Only */
Ntypedef const int16_t sc16;  /*!< Read Only */
Ntypedef const int8_t sc8;   /*!< Read Only */
N
Ntypedef __IO int32_t  vs32;
Xtypedef volatile int32_t  vs32;
Ntypedef __IO int16_t  vs16;
Xtypedef volatile int16_t  vs16;
Ntypedef __IO int8_t   vs8;
Xtypedef volatile int8_t   vs8;
N
Ntypedef __I int32_t vsc32;  /*!< Read Only */
Xtypedef volatile const int32_t vsc32;   
Ntypedef __I int16_t vsc16;  /*!< Read Only */
Xtypedef volatile const int16_t vsc16;   
Ntypedef __I int8_t vsc8;   /*!< Read Only */
Xtypedef volatile const int8_t vsc8;    
N
Ntypedef uint32_t  u32;
Ntypedef uint16_t u16;
Ntypedef uint8_t  u8;
N
Ntypedef const uint32_t uc32;  /*!< Read Only */
Ntypedef const uint16_t uc16;  /*!< Read Only */
Ntypedef const uint8_t uc8;   /*!< Read Only */
N
Ntypedef __IO uint32_t  vu32;
Xtypedef volatile uint32_t  vu32;
Ntypedef __IO uint16_t vu16;
Xtypedef volatile uint16_t vu16;
Ntypedef __IO uint8_t  vu8;
Xtypedef volatile uint8_t  vu8;
N
Ntypedef __I uint32_t vuc32;  /*!< Read Only */
Xtypedef volatile const uint32_t vuc32;   
Ntypedef __I uint16_t vuc16;  /*!< Read Only */
Xtypedef volatile const uint16_t vuc16;   
Ntypedef __I uint8_t vuc8;   /*!< Read Only */
Xtypedef volatile const uint8_t vuc8;    
N
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;
N
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
N
N/**
N  * @}
N  */
N
N/** @addtogroup Peripheral_registers_structures
N  * @{
N  */   
N
N/** 
N  * @brief Analog to Digital Converter  
N  */
N
Ntypedef struct
N{
N  __IO uint32_t SR;     /*!< ADC status register,                         Address offset: 0x00 */
X  volatile uint32_t SR;      
N  __IO uint32_t CR1;    /*!< ADC control register 1,                      Address offset: 0x04 */      
X  volatile uint32_t CR1;           
N  __IO uint32_t CR2;    /*!< ADC control register 2,                      Address offset: 0x08 */
X  volatile uint32_t CR2;     
N  __IO uint32_t SMPR1;  /*!< ADC sample time register 1,                  Address offset: 0x0C */
X  volatile uint32_t SMPR1;   
N  __IO uint32_t SMPR2;  /*!< ADC sample time register 2,                  Address offset: 0x10 */
X  volatile uint32_t SMPR2;   
N  __IO uint32_t JOFR1;  /*!< ADC injected channel data offset register 1, Address offset: 0x14 */
X  volatile uint32_t JOFR1;   
N  __IO uint32_t JOFR2;  /*!< ADC injected channel data offset register 2, Address offset: 0x18 */
X  volatile uint32_t JOFR2;   
N  __IO uint32_t JOFR3;  /*!< ADC injected channel data offset register 3, Address offset: 0x1C */
X  volatile uint32_t JOFR3;   
N  __IO uint32_t JOFR4;  /*!< ADC injected channel data offset register 4, Address offset: 0x20 */
X  volatile uint32_t JOFR4;   
N  __IO uint32_t HTR;    /*!< ADC watchdog higher threshold register,      Address offset: 0x24 */
X  volatile uint32_t HTR;     
N  __IO uint32_t LTR;    /*!< ADC watchdog lower threshold register,       Address offset: 0x28 */
X  volatile uint32_t LTR;     
N  __IO uint32_t SQR1;   /*!< ADC regular sequence register 1,             Address offset: 0x2C */
X  volatile uint32_t SQR1;    
N  __IO uint32_t SQR2;   /*!< ADC regular sequence register 2,             Address offset: 0x30 */
X  volatile uint32_t SQR2;    
N  __IO uint32_t SQR3;   /*!< ADC regular sequence register 3,             Address offset: 0x34 */
X  volatile uint32_t SQR3;    
N  __IO uint32_t JSQR;   /*!< ADC injected sequence register,              Address offset: 0x38 */
X  volatile uint32_t JSQR;    
N  __IO uint32_t JDR1;   /*!< ADC injected data register 1,                Address offset: 0x3C */
X  volatile uint32_t JDR1;    
N  __IO uint32_t JDR2;   /*!< ADC injected data register 2,                Address offset: 0x40 */
X  volatile uint32_t JDR2;    
N  __IO uint32_t JDR3;   /*!< ADC injected data register 3,                Address offset: 0x44 */
X  volatile uint32_t JDR3;    
N  __IO uint32_t JDR4;   /*!< ADC injected data register 4,                Address offset: 0x48 */
X  volatile uint32_t JDR4;    
N  __IO uint32_t DR;     /*!< ADC regular data register,                   Address offset: 0x4C */
X  volatile uint32_t DR;      
N} ADC_TypeDef;
N
Ntypedef struct
N{
N  __IO uint32_t CSR;    /*!< ADC Common status register,                  Address offset: ADC1 base address + 0x300 */
X  volatile uint32_t CSR;     
N  __IO uint32_t CCR;    /*!< ADC common control register,                 Address offset: ADC1 base address + 0x304 */
X  volatile uint32_t CCR;     
N  __IO uint32_t CDR;    /*!< ADC common regular data register for dual
X  volatile uint32_t CDR;    
N                             AND triple modes,                            Address offset: ADC1 base address + 0x308 */
N} ADC_Common_TypeDef;
N
N
N/** 
N  * @brief Controller Area Network TxMailBox 
N  */
N
Ntypedef struct
N{
N  __IO uint32_t TIR;  /*!< CAN TX mailbox identifier register */
X  volatile uint32_t TIR;   
N  __IO uint32_t TDTR; /*!< CAN mailbox data length control and time stamp register */
X  volatile uint32_t TDTR;  
N  __IO uint32_t TDLR; /*!< CAN mailbox data low register */
X  volatile uint32_t TDLR;  
N  __IO uint32_t TDHR; /*!< CAN mailbox data high register */
X  volatile uint32_t TDHR;  
N} CAN_TxMailBox_TypeDef;
N
N/** 
N  * @brief Controller Area Network FIFOMailBox 
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t RIR;  /*!< CAN receive FIFO mailbox identifier register */
X  volatile uint32_t RIR;   
N  __IO uint32_t RDTR; /*!< CAN receive FIFO mailbox data length control and time stamp register */
X  volatile uint32_t RDTR;  
N  __IO uint32_t RDLR; /*!< CAN receive FIFO mailbox data low register */
X  volatile uint32_t RDLR;  
N  __IO uint32_t RDHR; /*!< CAN receive FIFO mailbox data high register */
X  volatile uint32_t RDHR;  
N} CAN_FIFOMailBox_TypeDef;
N
N/** 
N  * @brief Controller Area Network FilterRegister 
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t FR1; /*!< CAN Filter bank register 1 */
X  volatile uint32_t FR1;  
N  __IO uint32_t FR2; /*!< CAN Filter bank register 1 */
X  volatile uint32_t FR2;  
N} CAN_FilterRegister_TypeDef;
N
N/** 
N  * @brief Controller Area Network 
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t              MCR;                 /*!< CAN master control register,         Address offset: 0x00          */
X  volatile uint32_t              MCR;                  
N  __IO uint32_t              MSR;                 /*!< CAN master status register,          Address offset: 0x04          */
X  volatile uint32_t              MSR;                  
N  __IO uint32_t              TSR;                 /*!< CAN transmit status register,        Address offset: 0x08          */
X  volatile uint32_t              TSR;                  
N  __IO uint32_t              RF0R;                /*!< CAN receive FIFO 0 register,         Address offset: 0x0C          */
X  volatile uint32_t              RF0R;                 
N  __IO uint32_t              RF1R;                /*!< CAN receive FIFO 1 register,         Address offset: 0x10          */
X  volatile uint32_t              RF1R;                 
N  __IO uint32_t              IER;                 /*!< CAN interrupt enable register,       Address offset: 0x14          */
X  volatile uint32_t              IER;                  
N  __IO uint32_t              ESR;                 /*!< CAN error status register,           Address offset: 0x18          */
X  volatile uint32_t              ESR;                  
N  __IO uint32_t              BTR;                 /*!< CAN bit timing register,             Address offset: 0x1C          */
X  volatile uint32_t              BTR;                  
N  uint32_t                   RESERVED0[88];       /*!< Reserved, 0x020 - 0x17F                                            */
N  CAN_TxMailBox_TypeDef      sTxMailBox[3];       /*!< CAN Tx MailBox,                      Address offset: 0x180 - 0x1AC */
N  CAN_FIFOMailBox_TypeDef    sFIFOMailBox[2];     /*!< CAN FIFO MailBox,                    Address offset: 0x1B0 - 0x1CC */
N  uint32_t                   RESERVED1[12];       /*!< Reserved, 0x1D0 - 0x1FF                                            */
N  __IO uint32_t              FMR;                 /*!< CAN filter master register,          Address offset: 0x200         */
X  volatile uint32_t              FMR;                  
N  __IO uint32_t              FM1R;                /*!< CAN filter mode register,            Address offset: 0x204         */
X  volatile uint32_t              FM1R;                 
N  uint32_t                   RESERVED2;           /*!< Reserved, 0x208                                                    */
N  __IO uint32_t              FS1R;                /*!< CAN filter scale register,           Address offset: 0x20C         */
X  volatile uint32_t              FS1R;                 
N  uint32_t                   RESERVED3;           /*!< Reserved, 0x210                                                    */
N  __IO uint32_t              FFA1R;               /*!< CAN filter FIFO assignment register, Address offset: 0x214         */
X  volatile uint32_t              FFA1R;                
N  uint32_t                   RESERVED4;           /*!< Reserved, 0x218                                                    */
N  __IO uint32_t              FA1R;                /*!< CAN filter activation register,      Address offset: 0x21C         */
X  volatile uint32_t              FA1R;                 
N  uint32_t                   RESERVED5[8];        /*!< Reserved, 0x220-0x23F                                              */ 
N  CAN_FilterRegister_TypeDef sFilterRegister[28]; /*!< CAN Filter Register,                 Address offset: 0x240-0x31C   */
N} CAN_TypeDef;
N
N#if defined(STM32F446xx)
X#if 0L
S/**
S  * @brief Consumer Electronics Control
S  */
Stypedef struct
S{
S  __IO uint32_t CR;           /*!< CEC control register,              Address offset:0x00 */
S  __IO uint32_t CFGR;         /*!< CEC configuration register,        Address offset:0x04 */
S  __IO uint32_t TXDR;         /*!< CEC Tx data register ,             Address offset:0x08 */
S  __IO uint32_t RXDR;         /*!< CEC Rx Data Register,              Address offset:0x0C */
S  __IO uint32_t ISR;          /*!< CEC Interrupt and Status Register, Address offset:0x10 */
S  __IO uint32_t IER;          /*!< CEC interrupt enable register,     Address offset:0x14 */
S}CEC_TypeDef;
N#endif /* STM32F446xx */
N
N/** 
N  * @brief CRC calculation unit 
N  */
N
Ntypedef struct
N{
N  __IO uint32_t DR;         /*!< CRC Data register,             Address offset: 0x00 */
X  volatile uint32_t DR;          
N  __IO uint8_t  IDR;        /*!< CRC Independent data register, Address offset: 0x04 */
X  volatile uint8_t  IDR;         
N  uint8_t       RESERVED0;  /*!< Reserved, 0x05                                      */
N  uint16_t      RESERVED1;  /*!< Reserved, 0x06                                      */
N  __IO uint32_t CR;         /*!< CRC Control register,          Address offset: 0x08 */
X  volatile uint32_t CR;          
N} CRC_TypeDef;
N
N/** 
N  * @brief Digital to Analog Converter
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;       /*!< DAC control register,                                    Address offset: 0x00 */
X  volatile uint32_t CR;        
N  __IO uint32_t SWTRIGR;  /*!< DAC software trigger register,                           Address offset: 0x04 */
X  volatile uint32_t SWTRIGR;   
N  __IO uint32_t DHR12R1;  /*!< DAC channel1 12-bit right-aligned data holding register, Address offset: 0x08 */
X  volatile uint32_t DHR12R1;   
N  __IO uint32_t DHR12L1;  /*!< DAC channel1 12-bit left aligned data holding register,  Address offset: 0x0C */
X  volatile uint32_t DHR12L1;   
N  __IO uint32_t DHR8R1;   /*!< DAC channel1 8-bit right aligned data holding register,  Address offset: 0x10 */
X  volatile uint32_t DHR8R1;    
N  __IO uint32_t DHR12R2;  /*!< DAC channel2 12-bit right aligned data holding register, Address offset: 0x14 */
X  volatile uint32_t DHR12R2;   
N  __IO uint32_t DHR12L2;  /*!< DAC channel2 12-bit left aligned data holding register,  Address offset: 0x18 */
X  volatile uint32_t DHR12L2;   
N  __IO uint32_t DHR8R2;   /*!< DAC channel2 8-bit right-aligned data holding register,  Address offset: 0x1C */
X  volatile uint32_t DHR8R2;    
N  __IO uint32_t DHR12RD;  /*!< Dual DAC 12-bit right-aligned data holding register,     Address offset: 0x20 */
X  volatile uint32_t DHR12RD;   
N  __IO uint32_t DHR12LD;  /*!< DUAL DAC 12-bit left aligned data holding register,      Address offset: 0x24 */
X  volatile uint32_t DHR12LD;   
N  __IO uint32_t DHR8RD;   /*!< DUAL DAC 8-bit right aligned data holding register,      Address offset: 0x28 */
X  volatile uint32_t DHR8RD;    
N  __IO uint32_t DOR1;     /*!< DAC channel1 data output register,                       Address offset: 0x2C */
X  volatile uint32_t DOR1;      
N  __IO uint32_t DOR2;     /*!< DAC channel2 data output register,                       Address offset: 0x30 */
X  volatile uint32_t DOR2;      
N  __IO uint32_t SR;       /*!< DAC status register,                                     Address offset: 0x34 */
X  volatile uint32_t SR;        
N} DAC_TypeDef;
N
N#if defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 0L || 0L
S/**
S  * @brief DFSDM module registers
S  */
Stypedef struct
S{
S  __IO uint32_t FLTCR1;         /*!< DFSDM control register1,                          Address offset: 0x100 */
S  __IO uint32_t FLTCR2;         /*!< DFSDM control register2,                          Address offset: 0x104 */
S  __IO uint32_t FLTISR;         /*!< DFSDM interrupt and status register,              Address offset: 0x108 */
S  __IO uint32_t FLTICR;         /*!< DFSDM interrupt flag clear register,              Address offset: 0x10C */
S  __IO uint32_t FLTJCHGR;       /*!< DFSDM injected channel group selection register,  Address offset: 0x110 */
S  __IO uint32_t FLTFCR;         /*!< DFSDM filter control register,                    Address offset: 0x114 */
S  __IO uint32_t FLTJDATAR;      /*!< DFSDM data register for injected group,           Address offset: 0x118 */
S  __IO uint32_t FLTRDATAR;      /*!< DFSDM data register for regular group,            Address offset: 0x11C */
S  __IO uint32_t FLTAWHTR;       /*!< DFSDM analog watchdog high threshold register,    Address offset: 0x120 */
S  __IO uint32_t FLTAWLTR;       /*!< DFSDM analog watchdog low threshold register,     Address offset: 0x124 */
S  __IO uint32_t FLTAWSR;        /*!< DFSDM analog watchdog status register             Address offset: 0x128 */
S  __IO uint32_t FLTAWCFR;       /*!< DFSDM analog watchdog clear flag register         Address offset: 0x12C */
S  __IO uint32_t FLTEXMAX;       /*!< DFSDM extreme detector maximum register,          Address offset: 0x130 */
S  __IO uint32_t FLTEXMIN;       /*!< DFSDM extreme detector minimum register           Address offset: 0x134 */
S  __IO uint32_t FLTCNVTIMR;     /*!< DFSDM conversion timer,                           Address offset: 0x138 */
S} DFSDM_Filter_TypeDef;
S
S/**
S  * @brief DFSDM channel configuration registers
S  */
Stypedef struct
S{
S  __IO uint32_t CHCFGR1;     /*!< DFSDM channel configuration register1,            Address offset: 0x00 */
S  __IO uint32_t CHCFGR2;     /*!< DFSDM channel configuration register2,            Address offset: 0x04 */
S  __IO uint32_t CHAWSCDR;    /*!< DFSDM channel analog watchdog and
S                                  short circuit detector register,                  Address offset: 0x08 */
S  __IO uint32_t CHWDATAR;    /*!< DFSDM channel watchdog filter data register,      Address offset: 0x0C */
S  __IO uint32_t CHDATINR;    /*!< DFSDM channel data input register,                Address offset: 0x10 */
S} DFSDM_Channel_TypeDef;
S
S/* Legacy Defines */
S#define DFSDM_TypeDef        DFSDM_Filter_TypeDef
N#endif /* STM32F412xG || STM32F413_423xx */
N/** 
N  * @brief Debug MCU
N  */
N
Ntypedef struct
N{
N  __IO uint32_t IDCODE;  /*!< MCU device ID code,               Address offset: 0x00 */
X  volatile uint32_t IDCODE;   
N  __IO uint32_t CR;      /*!< Debug MCU configuration register, Address offset: 0x04 */
X  volatile uint32_t CR;       
N  __IO uint32_t APB1FZ;  /*!< Debug MCU APB1 freeze register,   Address offset: 0x08 */
X  volatile uint32_t APB1FZ;   
N  __IO uint32_t APB2FZ;  /*!< Debug MCU APB2 freeze register,   Address offset: 0x0C */
X  volatile uint32_t APB2FZ;   
N}DBGMCU_TypeDef;
N
N/** 
N  * @brief DCMI
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;       /*!< DCMI control register 1,                       Address offset: 0x00 */
X  volatile uint32_t CR;        
N  __IO uint32_t SR;       /*!< DCMI status register,                          Address offset: 0x04 */
X  volatile uint32_t SR;        
N  __IO uint32_t RISR;     /*!< DCMI raw interrupt status register,            Address offset: 0x08 */
X  volatile uint32_t RISR;      
N  __IO uint32_t IER;      /*!< DCMI interrupt enable register,                Address offset: 0x0C */
X  volatile uint32_t IER;       
N  __IO uint32_t MISR;     /*!< DCMI masked interrupt status register,         Address offset: 0x10 */
X  volatile uint32_t MISR;      
N  __IO uint32_t ICR;      /*!< DCMI interrupt clear register,                 Address offset: 0x14 */
X  volatile uint32_t ICR;       
N  __IO uint32_t ESCR;     /*!< DCMI embedded synchronization code register,   Address offset: 0x18 */
X  volatile uint32_t ESCR;      
N  __IO uint32_t ESUR;     /*!< DCMI embedded synchronization unmask register, Address offset: 0x1C */
X  volatile uint32_t ESUR;      
N  __IO uint32_t CWSTRTR;  /*!< DCMI crop window start,                        Address offset: 0x20 */
X  volatile uint32_t CWSTRTR;   
N  __IO uint32_t CWSIZER;  /*!< DCMI crop window size,                         Address offset: 0x24 */
X  volatile uint32_t CWSIZER;   
N  __IO uint32_t DR;       /*!< DCMI data register,                            Address offset: 0x28 */
X  volatile uint32_t DR;        
N} DCMI_TypeDef;
N
N/** 
N  * @brief DMA Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;     /*!< DMA stream x configuration register      */
X  volatile uint32_t CR;      
N  __IO uint32_t NDTR;   /*!< DMA stream x number of data register     */
X  volatile uint32_t NDTR;    
N  __IO uint32_t PAR;    /*!< DMA stream x peripheral address register */
X  volatile uint32_t PAR;     
N  __IO uint32_t M0AR;   /*!< DMA stream x memory 0 address register   */
X  volatile uint32_t M0AR;    
N  __IO uint32_t M1AR;   /*!< DMA stream x memory 1 address register   */
X  volatile uint32_t M1AR;    
N  __IO uint32_t FCR;    /*!< DMA stream x FIFO control register       */
X  volatile uint32_t FCR;     
N} DMA_Stream_TypeDef;
N
Ntypedef struct
N{
N  __IO uint32_t LISR;   /*!< DMA low interrupt status register,      Address offset: 0x00 */
X  volatile uint32_t LISR;    
N  __IO uint32_t HISR;   /*!< DMA high interrupt status register,     Address offset: 0x04 */
X  volatile uint32_t HISR;    
N  __IO uint32_t LIFCR;  /*!< DMA low interrupt flag clear register,  Address offset: 0x08 */
X  volatile uint32_t LIFCR;   
N  __IO uint32_t HIFCR;  /*!< DMA high interrupt flag clear register, Address offset: 0x0C */
X  volatile uint32_t HIFCR;   
N} DMA_TypeDef;
N 
N/** 
N  * @brief DMA2D Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;            /*!< DMA2D Control Register,                         Address offset: 0x00 */
X  volatile uint32_t CR;             
N  __IO uint32_t ISR;           /*!< DMA2D Interrupt Status Register,                Address offset: 0x04 */
X  volatile uint32_t ISR;            
N  __IO uint32_t IFCR;          /*!< DMA2D Interrupt Flag Clear Register,            Address offset: 0x08 */
X  volatile uint32_t IFCR;           
N  __IO uint32_t FGMAR;         /*!< DMA2D Foreground Memory Address Register,       Address offset: 0x0C */
X  volatile uint32_t FGMAR;          
N  __IO uint32_t FGOR;          /*!< DMA2D Foreground Offset Register,               Address offset: 0x10 */
X  volatile uint32_t FGOR;           
N  __IO uint32_t BGMAR;         /*!< DMA2D Background Memory Address Register,       Address offset: 0x14 */
X  volatile uint32_t BGMAR;          
N  __IO uint32_t BGOR;          /*!< DMA2D Background Offset Register,               Address offset: 0x18 */
X  volatile uint32_t BGOR;           
N  __IO uint32_t FGPFCCR;       /*!< DMA2D Foreground PFC Control Register,          Address offset: 0x1C */
X  volatile uint32_t FGPFCCR;        
N  __IO uint32_t FGCOLR;        /*!< DMA2D Foreground Color Register,                Address offset: 0x20 */
X  volatile uint32_t FGCOLR;         
N  __IO uint32_t BGPFCCR;       /*!< DMA2D Background PFC Control Register,          Address offset: 0x24 */
X  volatile uint32_t BGPFCCR;        
N  __IO uint32_t BGCOLR;        /*!< DMA2D Background Color Register,                Address offset: 0x28 */
X  volatile uint32_t BGCOLR;         
N  __IO uint32_t FGCMAR;        /*!< DMA2D Foreground CLUT Memory Address Register,  Address offset: 0x2C */
X  volatile uint32_t FGCMAR;         
N  __IO uint32_t BGCMAR;        /*!< DMA2D Background CLUT Memory Address Register,  Address offset: 0x30 */
X  volatile uint32_t BGCMAR;         
N  __IO uint32_t OPFCCR;        /*!< DMA2D Output PFC Control Register,              Address offset: 0x34 */
X  volatile uint32_t OPFCCR;         
N  __IO uint32_t OCOLR;         /*!< DMA2D Output Color Register,                    Address offset: 0x38 */
X  volatile uint32_t OCOLR;          
N  __IO uint32_t OMAR;          /*!< DMA2D Output Memory Address Register,           Address offset: 0x3C */
X  volatile uint32_t OMAR;           
N  __IO uint32_t OOR;           /*!< DMA2D Output Offset Register,                   Address offset: 0x40 */
X  volatile uint32_t OOR;            
N  __IO uint32_t NLR;           /*!< DMA2D Number of Line Register,                  Address offset: 0x44 */
X  volatile uint32_t NLR;            
N  __IO uint32_t LWR;           /*!< DMA2D Line Watermark Register,                  Address offset: 0x48 */
X  volatile uint32_t LWR;            
N  __IO uint32_t AMTCR;         /*!< DMA2D AHB Master Timer Configuration Register,  Address offset: 0x4C */
X  volatile uint32_t AMTCR;          
N  uint32_t      RESERVED[236]; /*!< Reserved, 0x50-0x3FF */
N  __IO uint32_t FGCLUT[256];   /*!< DMA2D Foreground CLUT,                          Address offset:400-7FF */
X  volatile uint32_t FGCLUT[256];    
N  __IO uint32_t BGCLUT[256];   /*!< DMA2D Background CLUT,                          Address offset:800-BFF */
X  volatile uint32_t BGCLUT[256];    
N} DMA2D_TypeDef;
N
N#if defined(STM32F469_479xx)
X#if 0L
S/** 
S  * @brief DSI Controller
S  */
S
Stypedef struct
S{
S  __IO uint32_t VR;             /*!< DSI Host Version Register,                                 Address offset: 0x00       */
S  __IO uint32_t CR;             /*!< DSI Host Control Register,                                 Address offset: 0x04       */
S  __IO uint32_t CCR;            /*!< DSI HOST Clock Control Register,                           Address offset: 0x08       */
S  __IO uint32_t LVCIDR;         /*!< DSI Host LTDC VCID Register,                               Address offset: 0x0C       */
S  __IO uint32_t LCOLCR;         /*!< DSI Host LTDC Color Coding Register,                       Address offset: 0x10       */ 
S  __IO uint32_t LPCR;           /*!< DSI Host LTDC Polarity Configuration Register,             Address offset: 0x14       */
S  __IO uint32_t LPMCR;          /*!< DSI Host Low-Power Mode Configuration Register,            Address offset: 0x18       */
S  uint32_t      RESERVED0[4];   /*!< Reserved, 0x1C - 0x2B                                                                 */
S  __IO uint32_t PCR;            /*!< DSI Host Protocol Configuration Register,                  Address offset: 0x2C       */ 
S  __IO uint32_t GVCIDR;         /*!< DSI Host Generic VCID Register,                            Address offset: 0x30       */
S  __IO uint32_t MCR;            /*!< DSI Host Mode Configuration Register,                      Address offset: 0x34       */
S  __IO uint32_t VMCR;           /*!< DSI Host Video Mode Configuration Register,                Address offset: 0x38       */
S  __IO uint32_t VPCR;           /*!< DSI Host Video Packet Configuration Register,              Address offset: 0x3C       */
S  __IO uint32_t VCCR;           /*!< DSI Host Video Chunks Configuration Register,              Address offset: 0x40       */
S  __IO uint32_t VNPCR;          /*!< DSI Host Video Null Packet Configuration Register,         Address offset: 0x44       */
S  __IO uint32_t VHSACR;         /*!< DSI Host Video HSA Configuration Register,                 Address offset: 0x48       */
S  __IO uint32_t VHBPCR;         /*!< DSI Host Video HBP Configuration Register,                 Address offset: 0x4C       */
S  __IO uint32_t VLCR;           /*!< DSI Host Video Line Configuration Register,                Address offset: 0x50       */
S  __IO uint32_t VVSACR;         /*!< DSI Host Video VSA Configuration Register,                 Address offset: 0x54       */
S  __IO uint32_t VVBPCR;         /*!< DSI Host Video VBP Configuration Register,                 Address offset: 0x58       */
S  __IO uint32_t VVFPCR;         /*!< DSI Host Video VFP Configuration Register,                 Address offset: 0x5C       */
S  __IO uint32_t VVACR;          /*!< DSI Host Video VA Configuration Register,                  Address offset: 0x60       */
S  __IO uint32_t LCCR;           /*!< DSI Host LTDC Command Configuration Register,              Address offset: 0x64       */ 
S  __IO uint32_t CMCR;           /*!< DSI Host Command Mode Configuration Register,              Address offset: 0x68       */
S  __IO uint32_t GHCR;           /*!< DSI Host Generic Header Configuration Register,            Address offset: 0x6C       */
S  __IO uint32_t GPDR;           /*!< DSI Host Generic Payload Data Register,                    Address offset: 0x70       */
S  __IO uint32_t GPSR;           /*!< DSI Host Generic Packet Status Register,                   Address offset: 0x74       */
S  __IO uint32_t TCCR[6];        /*!< DSI Host Timeout Counter Configuration Register,           Address offset: 0x78-0x8F  */
S  __IO uint32_t TDCR;           /*!< DSI Host 3D Configuration Register,                        Address offset: 0x90       */ 
S  __IO uint32_t CLCR;           /*!< DSI Host Clock Lane Configuration Register,                Address offset: 0x94       */
S  __IO uint32_t CLTCR;          /*!< DSI Host Clock Lane Timer Configuration Register,          Address offset: 0x98       */
S  __IO uint32_t DLTCR;          /*!< DSI Host Data Lane Timer Configuration Register,           Address offset: 0x9C       */
S  __IO uint32_t PCTLR;          /*!< DSI Host PHY Control Register,                             Address offset: 0xA0       */ 
S  __IO uint32_t PCONFR;         /*!< DSI Host PHY Configuration Register,                       Address offset: 0xA4       */ 
S  __IO uint32_t PUCR;           /*!< DSI Host PHY ULPS Control Register,                        Address offset: 0xA8       */
S  __IO uint32_t PTTCR;          /*!< DSI Host PHY TX Triggers Configuration Register,           Address offset: 0xAC       */
S  __IO uint32_t PSR;            /*!< DSI Host PHY Status Register,                              Address offset: 0xB0       */
S  uint32_t      RESERVED1[2];   /*!< Reserved, 0xB4 - 0xBB                                                                 */
S  __IO uint32_t ISR[2];         /*!< DSI Host Interrupt & Status Register,                      Address offset: 0xBC-0xC3  */
S  __IO uint32_t IER[2];         /*!< DSI Host Interrupt Enable Register,                        Address offset: 0xC4-0xCB  */
S  uint32_t      RESERVED2[3];   /*!< Reserved, 0xD0 - 0xD7                                                                 */
S  __IO uint32_t FIR[2];         /*!< DSI Host Force Interrupt Register,                         Address offset: 0xD8-0xDF  */
S  uint32_t      RESERVED3[8];   /*!< Reserved, 0xE0 - 0xFF                                                                 */
S  __IO uint32_t VSCR;           /*!< DSI Host Video Shadow Control Register,                    Address offset: 0x100      */
S  uint32_t      RESERVED4[2];   /*!< Reserved, 0x104 - 0x10B                                                               */
S  __IO uint32_t LCVCIDR;        /*!< DSI Host LTDC Current VCID Register,                       Address offset: 0x10C      */
S  __IO uint32_t LCCCR;          /*!< DSI Host LTDC Current Color Coding Register,               Address offset: 0x110      */
S  uint32_t      RESERVED5;      /*!< Reserved, 0x114                                                                       */
S  __IO uint32_t LPMCCR;         /*!< DSI Host Low-power Mode Current Configuration Register,    Address offset: 0x118      */
S  uint32_t      RESERVED6[7];   /*!< Reserved, 0x11C - 0x137                                                               */
S  __IO uint32_t VMCCR;          /*!< DSI Host Video Mode Current Configuration Register,        Address offset: 0x138      */
S  __IO uint32_t VPCCR;          /*!< DSI Host Video Packet Current Configuration Register,      Address offset: 0x13C      */
S  __IO uint32_t VCCCR;          /*!< DSI Host Video Chuncks Current Configuration Register,     Address offset: 0x140      */
S  __IO uint32_t VNPCCR;         /*!< DSI Host Video Null Packet Current Configuration Register, Address offset: 0x144      */
S  __IO uint32_t VHSACCR;        /*!< DSI Host Video HSA Current Configuration Register,         Address offset: 0x148      */
S  __IO uint32_t VHBPCCR;        /*!< DSI Host Video HBP Current Configuration Register,         Address offset: 0x14C      */
S  __IO uint32_t VLCCR;          /*!< DSI Host Video Line Current Configuration Register,        Address offset: 0x150      */
S  __IO uint32_t VVSACCR;        /*!< DSI Host Video VSA Current Configuration Register,         Address offset: 0x154      */ 
S  __IO uint32_t VVBPCCR;        /*!< DSI Host Video VBP Current Configuration Register,         Address offset: 0x158      */
S  __IO uint32_t VVFPCCR;        /*!< DSI Host Video VFP Current Configuration Register,         Address offset: 0x15C      */
S  __IO uint32_t VVACCR;         /*!< DSI Host Video VA Current Configuration Register,          Address offset: 0x160      */
S  uint32_t      RESERVED7[11];  /*!< Reserved, 0x164 - 0x18F                                                               */
S  __IO uint32_t TDCCR;          /*!< DSI Host 3D Current Configuration Register,                Address offset: 0x190      */
S  uint32_t      RESERVED8[155]; /*!< Reserved, 0x194 - 0x3FF                                                               */
S  __IO uint32_t WCFGR;          /*!< DSI Wrapper Configuration Register,                       Address offset: 0x400       */
S  __IO uint32_t WCR;            /*!< DSI Wrapper Control Register,                             Address offset: 0x404       */
S  __IO uint32_t WIER;           /*!< DSI Wrapper Interrupt Enable Register,                    Address offset: 0x408       */
S  __IO uint32_t WISR;           /*!< DSI Wrapper Interrupt and Status Register,                Address offset: 0x40C       */
S  __IO uint32_t WIFCR;          /*!< DSI Wrapper Interrupt Flag Clear Register,                Address offset: 0x410       */
S  uint32_t      RESERVED9;      /*!< Reserved, 0x414                                                                       */
S  __IO uint32_t WPCR[5];        /*!< DSI Wrapper PHY Configuration Register,                   Address offset: 0x418-0x42B */
S  uint32_t      RESERVED10;     /*!< Reserved, 0x42C                                                                       */
S  __IO uint32_t WRPCR;          /*!< DSI Wrapper Regulator and PLL Control Register, Address offset: 0x430                 */
S} DSI_TypeDef;
N#endif /* STM32F469_479xx */
N
N/** 
N  * @brief Ethernet MAC
N  */
N
Ntypedef struct
N{
N  __IO uint32_t MACCR;
X  volatile uint32_t MACCR;
N  __IO uint32_t MACFFR;
X  volatile uint32_t MACFFR;
N  __IO uint32_t MACHTHR;
X  volatile uint32_t MACHTHR;
N  __IO uint32_t MACHTLR;
X  volatile uint32_t MACHTLR;
N  __IO uint32_t MACMIIAR;
X  volatile uint32_t MACMIIAR;
N  __IO uint32_t MACMIIDR;
X  volatile uint32_t MACMIIDR;
N  __IO uint32_t MACFCR;
X  volatile uint32_t MACFCR;
N  __IO uint32_t MACVLANTR;             /*    8 */
X  volatile uint32_t MACVLANTR;              
N  uint32_t      RESERVED0[2];
N  __IO uint32_t MACRWUFFR;             /*   11 */
X  volatile uint32_t MACRWUFFR;              
N  __IO uint32_t MACPMTCSR;
X  volatile uint32_t MACPMTCSR;
N  uint32_t      RESERVED1[2];
N  __IO uint32_t MACSR;                 /*   15 */
X  volatile uint32_t MACSR;                  
N  __IO uint32_t MACIMR;
X  volatile uint32_t MACIMR;
N  __IO uint32_t MACA0HR;
X  volatile uint32_t MACA0HR;
N  __IO uint32_t MACA0LR;
X  volatile uint32_t MACA0LR;
N  __IO uint32_t MACA1HR;
X  volatile uint32_t MACA1HR;
N  __IO uint32_t MACA1LR;
X  volatile uint32_t MACA1LR;
N  __IO uint32_t MACA2HR;
X  volatile uint32_t MACA2HR;
N  __IO uint32_t MACA2LR;
X  volatile uint32_t MACA2LR;
N  __IO uint32_t MACA3HR;
X  volatile uint32_t MACA3HR;
N  __IO uint32_t MACA3LR;               /*   24 */
X  volatile uint32_t MACA3LR;                
N  uint32_t      RESERVED2[40];
N  __IO uint32_t MMCCR;                 /*   65 */
X  volatile uint32_t MMCCR;                  
N  __IO uint32_t MMCRIR;
X  volatile uint32_t MMCRIR;
N  __IO uint32_t MMCTIR;
X  volatile uint32_t MMCTIR;
N  __IO uint32_t MMCRIMR;
X  volatile uint32_t MMCRIMR;
N  __IO uint32_t MMCTIMR;               /*   69 */
X  volatile uint32_t MMCTIMR;                
N  uint32_t      RESERVED3[14];
N  __IO uint32_t MMCTGFSCCR;            /*   84 */
X  volatile uint32_t MMCTGFSCCR;             
N  __IO uint32_t MMCTGFMSCCR;
X  volatile uint32_t MMCTGFMSCCR;
N  uint32_t      RESERVED4[5];
N  __IO uint32_t MMCTGFCR;
X  volatile uint32_t MMCTGFCR;
N  uint32_t      RESERVED5[10];
N  __IO uint32_t MMCRFCECR;
X  volatile uint32_t MMCRFCECR;
N  __IO uint32_t MMCRFAECR;
X  volatile uint32_t MMCRFAECR;
N  uint32_t      RESERVED6[10];
N  __IO uint32_t MMCRGUFCR;
X  volatile uint32_t MMCRGUFCR;
N  uint32_t      RESERVED7[334];
N  __IO uint32_t PTPTSCR;
X  volatile uint32_t PTPTSCR;
N  __IO uint32_t PTPSSIR;
X  volatile uint32_t PTPSSIR;
N  __IO uint32_t PTPTSHR;
X  volatile uint32_t PTPTSHR;
N  __IO uint32_t PTPTSLR;
X  volatile uint32_t PTPTSLR;
N  __IO uint32_t PTPTSHUR;
X  volatile uint32_t PTPTSHUR;
N  __IO uint32_t PTPTSLUR;
X  volatile uint32_t PTPTSLUR;
N  __IO uint32_t PTPTSAR;
X  volatile uint32_t PTPTSAR;
N  __IO uint32_t PTPTTHR;
X  volatile uint32_t PTPTTHR;
N  __IO uint32_t PTPTTLR;
X  volatile uint32_t PTPTTLR;
N  __IO uint32_t RESERVED8;
X  volatile uint32_t RESERVED8;
N  __IO uint32_t PTPTSSR;
X  volatile uint32_t PTPTSSR;
N  uint32_t      RESERVED9[565];
N  __IO uint32_t DMABMR;
X  volatile uint32_t DMABMR;
N  __IO uint32_t DMATPDR;
X  volatile uint32_t DMATPDR;
N  __IO uint32_t DMARPDR;
X  volatile uint32_t DMARPDR;
N  __IO uint32_t DMARDLAR;
X  volatile uint32_t DMARDLAR;
N  __IO uint32_t DMATDLAR;
X  volatile uint32_t DMATDLAR;
N  __IO uint32_t DMASR;
X  volatile uint32_t DMASR;
N  __IO uint32_t DMAOMR;
X  volatile uint32_t DMAOMR;
N  __IO uint32_t DMAIER;
X  volatile uint32_t DMAIER;
N  __IO uint32_t DMAMFBOCR;
X  volatile uint32_t DMAMFBOCR;
N  __IO uint32_t DMARSWTR;
X  volatile uint32_t DMARSWTR;
N  uint32_t      RESERVED10[8];
N  __IO uint32_t DMACHTDR;
X  volatile uint32_t DMACHTDR;
N  __IO uint32_t DMACHRDR;
X  volatile uint32_t DMACHRDR;
N  __IO uint32_t DMACHTBAR;
X  volatile uint32_t DMACHTBAR;
N  __IO uint32_t DMACHRBAR;
X  volatile uint32_t DMACHRBAR;
N} ETH_TypeDef;
N
N/** 
N  * @brief External Interrupt/Event Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t IMR;    /*!< EXTI Interrupt mask register,            Address offset: 0x00 */
X  volatile uint32_t IMR;     
N  __IO uint32_t EMR;    /*!< EXTI Event mask register,                Address offset: 0x04 */
X  volatile uint32_t EMR;     
N  __IO uint32_t RTSR;   /*!< EXTI Rising trigger selection register,  Address offset: 0x08 */
X  volatile uint32_t RTSR;    
N  __IO uint32_t FTSR;   /*!< EXTI Falling trigger selection register, Address offset: 0x0C */
X  volatile uint32_t FTSR;    
N  __IO uint32_t SWIER;  /*!< EXTI Software interrupt event register,  Address offset: 0x10 */
X  volatile uint32_t SWIER;   
N  __IO uint32_t PR;     /*!< EXTI Pending register,                   Address offset: 0x14 */
X  volatile uint32_t PR;      
N} EXTI_TypeDef;
N
N/** 
N  * @brief FLASH Registers
N  */
N
Ntypedef struct
N{
N  __IO uint32_t ACR;      /*!< FLASH access control register,   Address offset: 0x00 */
X  volatile uint32_t ACR;       
N  __IO uint32_t KEYR;     /*!< FLASH key register,              Address offset: 0x04 */
X  volatile uint32_t KEYR;      
N  __IO uint32_t OPTKEYR;  /*!< FLASH option key register,       Address offset: 0x08 */
X  volatile uint32_t OPTKEYR;   
N  __IO uint32_t SR;       /*!< FLASH status register,           Address offset: 0x0C */
X  volatile uint32_t SR;        
N  __IO uint32_t CR;       /*!< FLASH control register,          Address offset: 0x10 */
X  volatile uint32_t CR;        
N  __IO uint32_t OPTCR;    /*!< FLASH option control register ,  Address offset: 0x14 */
X  volatile uint32_t OPTCR;     
N  __IO uint32_t OPTCR1;   /*!< FLASH option control register 1, Address offset: 0x18 */
X  volatile uint32_t OPTCR1;    
N} FLASH_TypeDef;
N
N#if defined(STM32F40_41xxx) || defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 1L || 0L || 0L
N/** 
N  * @brief Flexible Static Memory Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t BTCR[8];    /*!< NOR/PSRAM chip-select control register(BCR) and chip-select timing register(BTR), Address offset: 0x00-1C */   
X  volatile uint32_t BTCR[8];        
N} FSMC_Bank1_TypeDef; 
N
N/** 
N  * @brief Flexible Static Memory Controller Bank1E
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t BWTR[7];    /*!< NOR/PSRAM write timing registers, Address offset: 0x104-0x11C */
X  volatile uint32_t BWTR[7];     
N} FSMC_Bank1E_TypeDef;
N
N/** 
N  * @brief Flexible Static Memory Controller Bank2
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t PCR2;       /*!< NAND Flash control register 2,                       Address offset: 0x60 */
X  volatile uint32_t PCR2;        
N  __IO uint32_t SR2;        /*!< NAND Flash FIFO status and interrupt register 2,     Address offset: 0x64 */
X  volatile uint32_t SR2;         
N  __IO uint32_t PMEM2;      /*!< NAND Flash Common memory space timing register 2,    Address offset: 0x68 */
X  volatile uint32_t PMEM2;       
N  __IO uint32_t PATT2;      /*!< NAND Flash Attribute memory space timing register 2, Address offset: 0x6C */
X  volatile uint32_t PATT2;       
N  uint32_t      RESERVED0;  /*!< Reserved, 0x70                                                            */
N  __IO uint32_t ECCR2;      /*!< NAND Flash ECC result registers 2,                   Address offset: 0x74 */
X  volatile uint32_t ECCR2;       
N} FSMC_Bank2_TypeDef;
N
N/** 
N  * @brief Flexible Static Memory Controller Bank3
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t PCR3;       /*!< NAND Flash control register 3,                       Address offset: 0x80 */
X  volatile uint32_t PCR3;        
N  __IO uint32_t SR3;        /*!< NAND Flash FIFO status and interrupt register 3,     Address offset: 0x84 */
X  volatile uint32_t SR3;         
N  __IO uint32_t PMEM3;      /*!< NAND Flash Common memory space timing register 3,    Address offset: 0x88 */
X  volatile uint32_t PMEM3;       
N  __IO uint32_t PATT3;      /*!< NAND Flash Attribute memory space timing register 3, Address offset: 0x8C */
X  volatile uint32_t PATT3;       
N  uint32_t      RESERVED0;  /*!< Reserved, 0x90                                                            */
N  __IO uint32_t ECCR3;      /*!< NAND Flash ECC result registers 3,                   Address offset: 0x94 */
X  volatile uint32_t ECCR3;       
N} FSMC_Bank3_TypeDef;
N
N/** 
N  * @brief Flexible Static Memory Controller Bank4
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t PCR4;       /*!< PC Card  control register 4,                       Address offset: 0xA0 */
X  volatile uint32_t PCR4;        
N  __IO uint32_t SR4;        /*!< PC Card  FIFO status and interrupt register 4,     Address offset: 0xA4 */
X  volatile uint32_t SR4;         
N  __IO uint32_t PMEM4;      /*!< PC Card  Common memory space timing register 4,    Address offset: 0xA8 */
X  volatile uint32_t PMEM4;       
N  __IO uint32_t PATT4;      /*!< PC Card  Attribute memory space timing register 4, Address offset: 0xAC */
X  volatile uint32_t PATT4;       
N  __IO uint32_t PIO4;       /*!< PC Card  I/O space timing register 4,              Address offset: 0xB0 */
X  volatile uint32_t PIO4;        
N} FSMC_Bank4_TypeDef; 
N#endif /* STM32F40_41xxx || STM32F412xG || STM32F413_423xx */
N
N#if defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
X#if 0L || 0L || 0L || 0L
S/** 
S  * @brief Flexible Memory Controller
S  */
S
Stypedef struct
S{
S  __IO uint32_t BTCR[8];    /*!< NOR/PSRAM chip-select control register(BCR) and chip-select timing register(BTR), Address offset: 0x00-1C */   
S} FMC_Bank1_TypeDef; 
S
S/** 
S  * @brief Flexible Memory Controller Bank1E
S  */
S  
Stypedef struct
S{
S  __IO uint32_t BWTR[7];    /*!< NOR/PSRAM write timing registers, Address offset: 0x104-0x11C */
S} FMC_Bank1E_TypeDef;
S
S/** 
S  * @brief Flexible Memory Controller Bank2
S  */
S  
Stypedef struct
S{
S  __IO uint32_t PCR2;       /*!< NAND Flash control register 2,                       Address offset: 0x60 */
S  __IO uint32_t SR2;        /*!< NAND Flash FIFO status and interrupt register 2,     Address offset: 0x64 */
S  __IO uint32_t PMEM2;      /*!< NAND Flash Common memory space timing register 2,    Address offset: 0x68 */
S  __IO uint32_t PATT2;      /*!< NAND Flash Attribute memory space timing register 2, Address offset: 0x6C */
S  uint32_t      RESERVED0;  /*!< Reserved, 0x70                                                            */
S  __IO uint32_t ECCR2;      /*!< NAND Flash ECC result registers 2,                   Address offset: 0x74 */
S} FMC_Bank2_TypeDef;
S
S/** 
S  * @brief Flexible Memory Controller Bank3
S  */
S  
Stypedef struct
S{
S  __IO uint32_t PCR3;       /*!< NAND Flash control register 3,                       Address offset: 0x80 */
S  __IO uint32_t SR3;        /*!< NAND Flash FIFO status and interrupt register 3,     Address offset: 0x84 */
S  __IO uint32_t PMEM3;      /*!< NAND Flash Common memory space timing register 3,    Address offset: 0x88 */
S  __IO uint32_t PATT3;      /*!< NAND Flash Attribute memory space timing register 3, Address offset: 0x8C */
S  uint32_t      RESERVED0;  /*!< Reserved, 0x90                                                            */
S  __IO uint32_t ECCR3;      /*!< NAND Flash ECC result registers 3,                   Address offset: 0x94 */
S} FMC_Bank3_TypeDef;
S
S/** 
S  * @brief Flexible Memory Controller Bank4
S  */
S  
Stypedef struct
S{
S  __IO uint32_t PCR4;       /*!< PC Card  control register 4,                       Address offset: 0xA0 */
S  __IO uint32_t SR4;        /*!< PC Card  FIFO status and interrupt register 4,     Address offset: 0xA4 */
S  __IO uint32_t PMEM4;      /*!< PC Card  Common memory space timing register 4,    Address offset: 0xA8 */
S  __IO uint32_t PATT4;      /*!< PC Card  Attribute memory space timing register 4, Address offset: 0xAC */
S  __IO uint32_t PIO4;       /*!< PC Card  I/O space timing register 4,              Address offset: 0xB0 */
S} FMC_Bank4_TypeDef; 
S
S/** 
S  * @brief Flexible Memory Controller Bank5_6
S  */
S  
Stypedef struct
S{
S  __IO uint32_t SDCR[2];        /*!< SDRAM Control registers ,      Address offset: 0x140-0x144  */
S  __IO uint32_t SDTR[2];        /*!< SDRAM Timing registers ,       Address offset: 0x148-0x14C  */
S  __IO uint32_t SDCMR;       /*!< SDRAM Command Mode register,    Address offset: 0x150  */
S  __IO uint32_t SDRTR;       /*!< SDRAM Refresh Timer register,   Address offset: 0x154  */
S  __IO uint32_t SDSR;        /*!< SDRAM Status register,          Address offset: 0x158  */
S} FMC_Bank5_6_TypeDef; 
N#endif /* STM32F427_437xx ||  STM32F429_439xx || STM32F446xx || STM32F469_479xx */
N
N/** 
N  * @brief General Purpose I/O
N  */
N
Ntypedef struct
N{
N  __IO uint32_t MODER;    /*!< GPIO port mode register,               Address offset: 0x00      */
X  volatile uint32_t MODER;     
N  __IO uint32_t OTYPER;   /*!< GPIO port output type register,        Address offset: 0x04      */
X  volatile uint32_t OTYPER;    
N  __IO uint32_t OSPEEDR;  /*!< GPIO port output speed register,       Address offset: 0x08      */
X  volatile uint32_t OSPEEDR;   
N  __IO uint32_t PUPDR;    /*!< GPIO port pull-up/pull-down register,  Address offset: 0x0C      */
X  volatile uint32_t PUPDR;     
N  __IO uint32_t IDR;      /*!< GPIO port input data register,         Address offset: 0x10      */
X  volatile uint32_t IDR;       
N  __IO uint32_t ODR;      /*!< GPIO port output data register,        Address offset: 0x14      */
X  volatile uint32_t ODR;       
N  __IO uint16_t BSRRL;    /*!< GPIO port bit set/reset low register,  Address offset: 0x18      */
X  volatile uint16_t BSRRL;     
N  __IO uint16_t BSRRH;    /*!< GPIO port bit set/reset high register, Address offset: 0x1A      */
X  volatile uint16_t BSRRH;     
N  __IO uint32_t LCKR;     /*!< GPIO port configuration lock register, Address offset: 0x1C      */
X  volatile uint32_t LCKR;      
N  __IO uint32_t AFR[2];   /*!< GPIO alternate function registers,     Address offset: 0x20-0x24 */
X  volatile uint32_t AFR[2];    
N} GPIO_TypeDef;
N
N/** 
N  * @brief System configuration controller
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t MEMRMP;       /*!< SYSCFG memory remap register,                      Address offset: 0x00      */
X  volatile uint32_t MEMRMP;        
N  __IO uint32_t PMC;          /*!< SYSCFG peripheral mode configuration register,     Address offset: 0x04      */
X  volatile uint32_t PMC;           
N  __IO uint32_t EXTICR[4];    /*!< SYSCFG external interrupt configuration registers, Address offset: 0x08-0x14 */
X  volatile uint32_t EXTICR[4];     
N#if defined (STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 0L || 0L || 0L
S  uint32_t      RESERVED;     /*!< Reserved, 0x18                                                               */
S  __IO uint32_t CFGR2;        /*!< Reserved, 0x1C                                                               */
S  __IO uint32_t CMPCR;        /*!< SYSCFG Compensation cell control register,         Address offset: 0x20      */
S  uint32_t      RESERVED1[2]; /*!< Reserved, 0x24-0x28                                                          */
S  __IO uint32_t CFGR;         /*!< SYSCFG Configuration register,                     Address offset: 0x2C      */
N#else  /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F401xx || STM32F411xE || STM32F446xx || STM32F469_479xx */
N  uint32_t      RESERVED[2];  /*!< Reserved, 0x18-0x1C                                                          */ 
N  __IO uint32_t CMPCR;        /*!< SYSCFG Compensation cell control register,         Address offset: 0x20      */
X  volatile uint32_t CMPCR;         
N#endif /* STM32F410xx || defined(STM32F412xG) || defined(STM32F413_423xx) */
N#if defined(STM32F413_423xx)
X#if 0L
S  __IO uint32_t MCHDLYCR;     /*!< SYSCFG multi-channel delay register,               Address offset: 0x30      */
N#endif /* STM32F413_423xx */
N} SYSCFG_TypeDef;
N
N/** 
N  * @brief Inter-integrated Circuit Interface
N  */
N
Ntypedef struct
N{
N  __IO uint16_t CR1;        /*!< I2C Control register 1,     Address offset: 0x00 */
X  volatile uint16_t CR1;         
N  uint16_t      RESERVED0;  /*!< Reserved, 0x02                                   */
N  __IO uint16_t CR2;        /*!< I2C Control register 2,     Address offset: 0x04 */
X  volatile uint16_t CR2;         
N  uint16_t      RESERVED1;  /*!< Reserved, 0x06                                   */
N  __IO uint16_t OAR1;       /*!< I2C Own address register 1, Address offset: 0x08 */
X  volatile uint16_t OAR1;        
N  uint16_t      RESERVED2;  /*!< Reserved, 0x0A                                   */
N  __IO uint16_t OAR2;       /*!< I2C Own address register 2, Address offset: 0x0C */
X  volatile uint16_t OAR2;        
N  uint16_t      RESERVED3;  /*!< Reserved, 0x0E                                   */
N  __IO uint16_t DR;         /*!< I2C Data register,          Address offset: 0x10 */
X  volatile uint16_t DR;          
N  uint16_t      RESERVED4;  /*!< Reserved, 0x12                                   */
N  __IO uint16_t SR1;        /*!< I2C Status register 1,      Address offset: 0x14 */
X  volatile uint16_t SR1;         
N  uint16_t      RESERVED5;  /*!< Reserved, 0x16                                   */
N  __IO uint16_t SR2;        /*!< I2C Status register 2,      Address offset: 0x18 */
X  volatile uint16_t SR2;         
N  uint16_t      RESERVED6;  /*!< Reserved, 0x1A                                   */
N  __IO uint16_t CCR;        /*!< I2C Clock control register, Address offset: 0x1C */
X  volatile uint16_t CCR;         
N  uint16_t      RESERVED7;  /*!< Reserved, 0x1E                                   */
N  __IO uint16_t TRISE;      /*!< I2C TRISE register,         Address offset: 0x20 */
X  volatile uint16_t TRISE;       
N  uint16_t      RESERVED8;  /*!< Reserved, 0x22                                   */
N  __IO uint16_t FLTR;       /*!< I2C FLTR register,          Address offset: 0x24 */
X  volatile uint16_t FLTR;        
N  uint16_t      RESERVED9;  /*!< Reserved, 0x26                                   */
N} I2C_TypeDef;
N
N#if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) 
X#if 0L || 0L || 0L || 0L 
S/**
S  * @brief Inter-integrated Circuit Interface
S  */
S
Stypedef struct
S{
S  __IO uint32_t CR1;      /*!< FMPI2C Control register 1,            Address offset: 0x00 */
S  __IO uint32_t CR2;      /*!< FMPI2C Control register 2,            Address offset: 0x04 */
S  __IO uint32_t OAR1;     /*!< FMPI2C Own address 1 register,        Address offset: 0x08 */
S  __IO uint32_t OAR2;     /*!< FMPI2C Own address 2 register,        Address offset: 0x0C */
S  __IO uint32_t TIMINGR;  /*!< FMPI2C Timing register,               Address offset: 0x10 */
S  __IO uint32_t TIMEOUTR; /*!< FMPI2C Timeout register,              Address offset: 0x14 */
S  __IO uint32_t ISR;      /*!< FMPI2C Interrupt and status register, Address offset: 0x18 */
S  __IO uint32_t ICR;      /*!< FMPI2C Interrupt clear register,      Address offset: 0x1C */
S  __IO uint32_t PECR;     /*!< FMPI2C PEC register,                  Address offset: 0x20 */
S  __IO uint32_t RXDR;     /*!< FMPI2C Receive data register,         Address offset: 0x24 */
S  __IO uint32_t TXDR;     /*!< FMPI2C Transmit data register,        Address offset: 0x28 */
S}FMPI2C_TypeDef;
N#endif /* STM32F410xx || STM32F412xG || STM32F413_423xx || STM32F446xx */
N
N/** 
N  * @brief Independent WATCHDOG
N  */
N
Ntypedef struct
N{
N  __IO uint32_t KR;   /*!< IWDG Key register,       Address offset: 0x00 */
X  volatile uint32_t KR;    
N  __IO uint32_t PR;   /*!< IWDG Prescaler register, Address offset: 0x04 */
X  volatile uint32_t PR;    
N  __IO uint32_t RLR;  /*!< IWDG Reload register,    Address offset: 0x08 */
X  volatile uint32_t RLR;   
N  __IO uint32_t SR;   /*!< IWDG Status register,    Address offset: 0x0C */
X  volatile uint32_t SR;    
N} IWDG_TypeDef;
N
N/** 
N  * @brief LCD-TFT Display Controller
N  */
N  
Ntypedef struct
N{
N  uint32_t      RESERVED0[2];  /*!< Reserved, 0x00-0x04 */
N  __IO uint32_t SSCR;          /*!< LTDC Synchronization Size Configuration Register,    Address offset: 0x08 */
X  volatile uint32_t SSCR;           
N  __IO uint32_t BPCR;          /*!< LTDC Back Porch Configuration Register,              Address offset: 0x0C */
X  volatile uint32_t BPCR;           
N  __IO uint32_t AWCR;          /*!< LTDC Active Width Configuration Register,            Address offset: 0x10 */
X  volatile uint32_t AWCR;           
N  __IO uint32_t TWCR;          /*!< LTDC Total Width Configuration Register,             Address offset: 0x14 */
X  volatile uint32_t TWCR;           
N  __IO uint32_t GCR;           /*!< LTDC Global Control Register,                        Address offset: 0x18 */
X  volatile uint32_t GCR;            
N  uint32_t      RESERVED1[2];  /*!< Reserved, 0x1C-0x20 */
N  __IO uint32_t SRCR;          /*!< LTDC Shadow Reload Configuration Register,           Address offset: 0x24 */
X  volatile uint32_t SRCR;           
N  uint32_t      RESERVED2[1];  /*!< Reserved, 0x28 */
N  __IO uint32_t BCCR;          /*!< LTDC Background Color Configuration Register,        Address offset: 0x2C */
X  volatile uint32_t BCCR;           
N  uint32_t      RESERVED3[1];  /*!< Reserved, 0x30 */
N  __IO uint32_t IER;           /*!< LTDC Interrupt Enable Register,                      Address offset: 0x34 */
X  volatile uint32_t IER;            
N  __IO uint32_t ISR;           /*!< LTDC Interrupt Status Register,                      Address offset: 0x38 */
X  volatile uint32_t ISR;            
N  __IO uint32_t ICR;           /*!< LTDC Interrupt Clear Register,                       Address offset: 0x3C */
X  volatile uint32_t ICR;            
N  __IO uint32_t LIPCR;         /*!< LTDC Line Interrupt Position Configuration Register, Address offset: 0x40 */
X  volatile uint32_t LIPCR;          
N  __IO uint32_t CPSR;          /*!< LTDC Current Position Status Register,               Address offset: 0x44 */
X  volatile uint32_t CPSR;           
N  __IO uint32_t CDSR;         /*!< LTDC Current Display Status Register,                       Address offset: 0x48 */
X  volatile uint32_t CDSR;          
N} LTDC_TypeDef;  
N
N/** 
N  * @brief LCD-TFT Display layer x Controller
N  */
N  
Ntypedef struct
N{  
N  __IO uint32_t CR;            /*!< LTDC Layerx Control Register                                  Address offset: 0x84 */
X  volatile uint32_t CR;             
N  __IO uint32_t WHPCR;         /*!< LTDC Layerx Window Horizontal Position Configuration Register Address offset: 0x88 */
X  volatile uint32_t WHPCR;          
N  __IO uint32_t WVPCR;         /*!< LTDC Layerx Window Vertical Position Configuration Register   Address offset: 0x8C */
X  volatile uint32_t WVPCR;          
N  __IO uint32_t CKCR;          /*!< LTDC Layerx Color Keying Configuration Register               Address offset: 0x90 */
X  volatile uint32_t CKCR;           
N  __IO uint32_t PFCR;          /*!< LTDC Layerx Pixel Format Configuration Register               Address offset: 0x94 */
X  volatile uint32_t PFCR;           
N  __IO uint32_t CACR;          /*!< LTDC Layerx Constant Alpha Configuration Register             Address offset: 0x98 */
X  volatile uint32_t CACR;           
N  __IO uint32_t DCCR;          /*!< LTDC Layerx Default Color Configuration Register              Address offset: 0x9C */
X  volatile uint32_t DCCR;           
N  __IO uint32_t BFCR;          /*!< LTDC Layerx Blending Factors Configuration Register           Address offset: 0xA0 */
X  volatile uint32_t BFCR;           
N  uint32_t      RESERVED0[2];  /*!< Reserved */
N  __IO uint32_t CFBAR;         /*!< LTDC Layerx Color Frame Buffer Address Register               Address offset: 0xAC */
X  volatile uint32_t CFBAR;          
N  __IO uint32_t CFBLR;         /*!< LTDC Layerx Color Frame Buffer Length Register                Address offset: 0xB0 */
X  volatile uint32_t CFBLR;          
N  __IO uint32_t CFBLNR;        /*!< LTDC Layerx ColorFrame Buffer Line Number Register            Address offset: 0xB4 */
X  volatile uint32_t CFBLNR;         
N  uint32_t      RESERVED1[3];  /*!< Reserved */
N  __IO uint32_t CLUTWR;         /*!< LTDC Layerx CLUT Write Register                               Address offset: 0x144 */
X  volatile uint32_t CLUTWR;          
N
N} LTDC_Layer_TypeDef;
N
N/** 
N  * @brief Power Control
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;   /*!< PWR power control register,        Address offset: 0x00 */
X  volatile uint32_t CR;    
N  __IO uint32_t CSR;  /*!< PWR power control/status register, Address offset: 0x04 */
X  volatile uint32_t CSR;   
N} PWR_TypeDef;
N
N/** 
N  * @brief Reset and Clock Control
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;            /*!< RCC clock control register,                                  Address offset: 0x00 */
X  volatile uint32_t CR;             
N  __IO uint32_t PLLCFGR;       /*!< RCC PLL configuration register,                              Address offset: 0x04 */
X  volatile uint32_t PLLCFGR;        
N  __IO uint32_t CFGR;          /*!< RCC clock configuration register,                            Address offset: 0x08 */
X  volatile uint32_t CFGR;           
N  __IO uint32_t CIR;           /*!< RCC clock interrupt register,                                Address offset: 0x0C */
X  volatile uint32_t CIR;            
N  __IO uint32_t AHB1RSTR;      /*!< RCC AHB1 peripheral reset register,                          Address offset: 0x10 */
X  volatile uint32_t AHB1RSTR;       
N  __IO uint32_t AHB2RSTR;      /*!< RCC AHB2 peripheral reset register,                          Address offset: 0x14 */
X  volatile uint32_t AHB2RSTR;       
N  __IO uint32_t AHB3RSTR;      /*!< RCC AHB3 peripheral reset register,                          Address offset: 0x18 */
X  volatile uint32_t AHB3RSTR;       
N  uint32_t      RESERVED0;     /*!< Reserved, 0x1C                                                                    */
N  __IO uint32_t APB1RSTR;      /*!< RCC APB1 peripheral reset register,                          Address offset: 0x20 */
X  volatile uint32_t APB1RSTR;       
N  __IO uint32_t APB2RSTR;      /*!< RCC APB2 peripheral reset register,                          Address offset: 0x24 */
X  volatile uint32_t APB2RSTR;       
N  uint32_t      RESERVED1[2];  /*!< Reserved, 0x28-0x2C                                                               */
N  __IO uint32_t AHB1ENR;       /*!< RCC AHB1 peripheral clock register,                          Address offset: 0x30 */
X  volatile uint32_t AHB1ENR;        
N  __IO uint32_t AHB2ENR;       /*!< RCC AHB2 peripheral clock register,                          Address offset: 0x34 */
X  volatile uint32_t AHB2ENR;        
N  __IO uint32_t AHB3ENR;       /*!< RCC AHB3 peripheral clock register,                          Address offset: 0x38 */
X  volatile uint32_t AHB3ENR;        
N  uint32_t      RESERVED2;     /*!< Reserved, 0x3C                                                                    */
N  __IO uint32_t APB1ENR;       /*!< RCC APB1 peripheral clock enable register,                   Address offset: 0x40 */
X  volatile uint32_t APB1ENR;        
N  __IO uint32_t APB2ENR;       /*!< RCC APB2 peripheral clock enable register,                   Address offset: 0x44 */
X  volatile uint32_t APB2ENR;        
N  uint32_t      RESERVED3[2];  /*!< Reserved, 0x48-0x4C                                                               */
N  __IO uint32_t AHB1LPENR;     /*!< RCC AHB1 peripheral clock enable in low power mode register, Address offset: 0x50 */
X  volatile uint32_t AHB1LPENR;      
N  __IO uint32_t AHB2LPENR;     /*!< RCC AHB2 peripheral clock enable in low power mode register, Address offset: 0x54 */
X  volatile uint32_t AHB2LPENR;      
N  __IO uint32_t AHB3LPENR;     /*!< RCC AHB3 peripheral clock enable in low power mode register, Address offset: 0x58 */
X  volatile uint32_t AHB3LPENR;      
N  uint32_t      RESERVED4;     /*!< Reserved, 0x5C                                                                    */
N  __IO uint32_t APB1LPENR;     /*!< RCC APB1 peripheral clock enable in low power mode register, Address offset: 0x60 */
X  volatile uint32_t APB1LPENR;      
N  __IO uint32_t APB2LPENR;     /*!< RCC APB2 peripheral clock enable in low power mode register, Address offset: 0x64 */
X  volatile uint32_t APB2LPENR;      
N  uint32_t      RESERVED5[2];  /*!< Reserved, 0x68-0x6C                                                               */
N  __IO uint32_t BDCR;          /*!< RCC Backup domain control register,                          Address offset: 0x70 */
X  volatile uint32_t BDCR;           
N  __IO uint32_t CSR;           /*!< RCC clock control & status register,                         Address offset: 0x74 */
X  volatile uint32_t CSR;            
N  uint32_t      RESERVED6[2];  /*!< Reserved, 0x78-0x7C                                                               */
N  __IO uint32_t SSCGR;         /*!< RCC spread spectrum clock generation register,               Address offset: 0x80 */
X  volatile uint32_t SSCGR;          
N  __IO uint32_t PLLI2SCFGR;    /*!< RCC PLLI2S configuration register,                           Address offset: 0x84 */
X  volatile uint32_t PLLI2SCFGR;     
N  __IO uint32_t PLLSAICFGR;    /*!< RCC PLLSAI configuration register,                           Address offset: 0x88 */
X  volatile uint32_t PLLSAICFGR;     
N  __IO uint32_t DCKCFGR;       /*!< RCC Dedicated Clocks configuration register,                 Address offset: 0x8C */
X  volatile uint32_t DCKCFGR;        
N  __IO uint32_t CKGATENR;      /*!< RCC Clocks Gated Enable Register,                            Address offset: 0x90 */ /* Only for STM32F412xG, STM32413_423xx and STM32F446xx devices */
X  volatile uint32_t CKGATENR;         
N  __IO uint32_t DCKCFGR2;      /*!< RCC Dedicated Clocks configuration register 2,               Address offset: 0x94 */ /* Only for STM32F410xx, STM32F412xG, STM32413_423xx and STM32F446xx devices */
X  volatile uint32_t DCKCFGR2;         
N
N} RCC_TypeDef;
N
N/** 
N  * @brief Real-Time Clock
N  */
N
Ntypedef struct
N{
N  __IO uint32_t TR;      /*!< RTC time register,                                        Address offset: 0x00 */
X  volatile uint32_t TR;       
N  __IO uint32_t DR;      /*!< RTC date register,                                        Address offset: 0x04 */
X  volatile uint32_t DR;       
N  __IO uint32_t CR;      /*!< RTC control register,                                     Address offset: 0x08 */
X  volatile uint32_t CR;       
N  __IO uint32_t ISR;     /*!< RTC initialization and status register,                   Address offset: 0x0C */
X  volatile uint32_t ISR;      
N  __IO uint32_t PRER;    /*!< RTC prescaler register,                                   Address offset: 0x10 */
X  volatile uint32_t PRER;     
N  __IO uint32_t WUTR;    /*!< RTC wakeup timer register,                                Address offset: 0x14 */
X  volatile uint32_t WUTR;     
N  __IO uint32_t CALIBR;  /*!< RTC calibration register,                                 Address offset: 0x18 */
X  volatile uint32_t CALIBR;   
N  __IO uint32_t ALRMAR;  /*!< RTC alarm A register,                                     Address offset: 0x1C */
X  volatile uint32_t ALRMAR;   
N  __IO uint32_t ALRMBR;  /*!< RTC alarm B register,                                     Address offset: 0x20 */
X  volatile uint32_t ALRMBR;   
N  __IO uint32_t WPR;     /*!< RTC write protection register,                            Address offset: 0x24 */
X  volatile uint32_t WPR;      
N  __IO uint32_t SSR;     /*!< RTC sub second register,                                  Address offset: 0x28 */
X  volatile uint32_t SSR;      
N  __IO uint32_t SHIFTR;  /*!< RTC shift control register,                               Address offset: 0x2C */
X  volatile uint32_t SHIFTR;   
N  __IO uint32_t TSTR;    /*!< RTC time stamp time register,                             Address offset: 0x30 */
X  volatile uint32_t TSTR;     
N  __IO uint32_t TSDR;    /*!< RTC time stamp date register,                             Address offset: 0x34 */
X  volatile uint32_t TSDR;     
N  __IO uint32_t TSSSR;   /*!< RTC time-stamp sub second register,                       Address offset: 0x38 */
X  volatile uint32_t TSSSR;    
N  __IO uint32_t CALR;    /*!< RTC calibration register,                                 Address offset: 0x3C */
X  volatile uint32_t CALR;     
N  __IO uint32_t TAFCR;   /*!< RTC tamper and alternate function configuration register, Address offset: 0x40 */
X  volatile uint32_t TAFCR;    
N  __IO uint32_t ALRMASSR;/*!< RTC alarm A sub second register,                          Address offset: 0x44 */
X  volatile uint32_t ALRMASSR; 
N  __IO uint32_t ALRMBSSR;/*!< RTC alarm B sub second register,                          Address offset: 0x48 */
X  volatile uint32_t ALRMBSSR; 
N  uint32_t RESERVED7;    /*!< Reserved, 0x4C                                                                 */
N  __IO uint32_t BKP0R;   /*!< RTC backup register 1,                                    Address offset: 0x50 */
X  volatile uint32_t BKP0R;    
N  __IO uint32_t BKP1R;   /*!< RTC backup register 1,                                    Address offset: 0x54 */
X  volatile uint32_t BKP1R;    
N  __IO uint32_t BKP2R;   /*!< RTC backup register 2,                                    Address offset: 0x58 */
X  volatile uint32_t BKP2R;    
N  __IO uint32_t BKP3R;   /*!< RTC backup register 3,                                    Address offset: 0x5C */
X  volatile uint32_t BKP3R;    
N  __IO uint32_t BKP4R;   /*!< RTC backup register 4,                                    Address offset: 0x60 */
X  volatile uint32_t BKP4R;    
N  __IO uint32_t BKP5R;   /*!< RTC backup register 5,                                    Address offset: 0x64 */
X  volatile uint32_t BKP5R;    
N  __IO uint32_t BKP6R;   /*!< RTC backup register 6,                                    Address offset: 0x68 */
X  volatile uint32_t BKP6R;    
N  __IO uint32_t BKP7R;   /*!< RTC backup register 7,                                    Address offset: 0x6C */
X  volatile uint32_t BKP7R;    
N  __IO uint32_t BKP8R;   /*!< RTC backup register 8,                                    Address offset: 0x70 */
X  volatile uint32_t BKP8R;    
N  __IO uint32_t BKP9R;   /*!< RTC backup register 9,                                    Address offset: 0x74 */
X  volatile uint32_t BKP9R;    
N  __IO uint32_t BKP10R;  /*!< RTC backup register 10,                                   Address offset: 0x78 */
X  volatile uint32_t BKP10R;   
N  __IO uint32_t BKP11R;  /*!< RTC backup register 11,                                   Address offset: 0x7C */
X  volatile uint32_t BKP11R;   
N  __IO uint32_t BKP12R;  /*!< RTC backup register 12,                                   Address offset: 0x80 */
X  volatile uint32_t BKP12R;   
N  __IO uint32_t BKP13R;  /*!< RTC backup register 13,                                   Address offset: 0x84 */
X  volatile uint32_t BKP13R;   
N  __IO uint32_t BKP14R;  /*!< RTC backup register 14,                                   Address offset: 0x88 */
X  volatile uint32_t BKP14R;   
N  __IO uint32_t BKP15R;  /*!< RTC backup register 15,                                   Address offset: 0x8C */
X  volatile uint32_t BKP15R;   
N  __IO uint32_t BKP16R;  /*!< RTC backup register 16,                                   Address offset: 0x90 */
X  volatile uint32_t BKP16R;   
N  __IO uint32_t BKP17R;  /*!< RTC backup register 17,                                   Address offset: 0x94 */
X  volatile uint32_t BKP17R;   
N  __IO uint32_t BKP18R;  /*!< RTC backup register 18,                                   Address offset: 0x98 */
X  volatile uint32_t BKP18R;   
N  __IO uint32_t BKP19R;  /*!< RTC backup register 19,                                   Address offset: 0x9C */
X  volatile uint32_t BKP19R;   
N} RTC_TypeDef;
N
N
N/** 
N  * @brief Serial Audio Interface
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t GCR;      /*!< SAI global configuration register,        Address offset: 0x00 */
X  volatile uint32_t GCR;       
N} SAI_TypeDef;
N
Ntypedef struct
N{
N  __IO uint32_t CR1;      /*!< SAI block x configuration register 1,     Address offset: 0x04 */
X  volatile uint32_t CR1;       
N  __IO uint32_t CR2;      /*!< SAI block x configuration register 2,     Address offset: 0x08 */
X  volatile uint32_t CR2;       
N  __IO uint32_t FRCR;     /*!< SAI block x frame configuration register, Address offset: 0x0C */
X  volatile uint32_t FRCR;      
N  __IO uint32_t SLOTR;    /*!< SAI block x slot register,                Address offset: 0x10 */
X  volatile uint32_t SLOTR;     
N  __IO uint32_t IMR;      /*!< SAI block x interrupt mask register,      Address offset: 0x14 */
X  volatile uint32_t IMR;       
N  __IO uint32_t SR;       /*!< SAI block x status register,              Address offset: 0x18 */
X  volatile uint32_t SR;        
N  __IO uint32_t CLRFR;    /*!< SAI block x clear flag register,          Address offset: 0x1C */
X  volatile uint32_t CLRFR;     
N  __IO uint32_t DR;       /*!< SAI block x data register,                Address offset: 0x20 */
X  volatile uint32_t DR;        
N} SAI_Block_TypeDef;
N
N/** 
N  * @brief SD host Interface
N  */
N
Ntypedef struct
N{
N  __IO uint32_t POWER;          /*!< SDIO power control register,    Address offset: 0x00 */
X  volatile uint32_t POWER;           
N  __IO uint32_t CLKCR;          /*!< SDI clock control register,     Address offset: 0x04 */
X  volatile uint32_t CLKCR;           
N  __IO uint32_t ARG;            /*!< SDIO argument register,         Address offset: 0x08 */
X  volatile uint32_t ARG;             
N  __IO uint32_t CMD;            /*!< SDIO command register,          Address offset: 0x0C */
X  volatile uint32_t CMD;             
N  __I uint32_t  RESPCMD;        /*!< SDIO command response register, Address offset: 0x10 */
X  volatile const uint32_t  RESPCMD;         
N  __I uint32_t  RESP1;          /*!< SDIO response 1 register,       Address offset: 0x14 */
X  volatile const uint32_t  RESP1;           
N  __I uint32_t  RESP2;          /*!< SDIO response 2 register,       Address offset: 0x18 */
X  volatile const uint32_t  RESP2;           
N  __I uint32_t  RESP3;          /*!< SDIO response 3 register,       Address offset: 0x1C */
X  volatile const uint32_t  RESP3;           
N  __I uint32_t  RESP4;          /*!< SDIO response 4 register,       Address offset: 0x20 */
X  volatile const uint32_t  RESP4;           
N  __IO uint32_t DTIMER;         /*!< SDIO data timer register,       Address offset: 0x24 */
X  volatile uint32_t DTIMER;          
N  __IO uint32_t DLEN;           /*!< SDIO data length register,      Address offset: 0x28 */
X  volatile uint32_t DLEN;            
N  __IO uint32_t DCTRL;          /*!< SDIO data control register,     Address offset: 0x2C */
X  volatile uint32_t DCTRL;           
N  __I uint32_t  DCOUNT;         /*!< SDIO data counter register,     Address offset: 0x30 */
X  volatile const uint32_t  DCOUNT;          
N  __I uint32_t  STA;            /*!< SDIO status register,           Address offset: 0x34 */
X  volatile const uint32_t  STA;             
N  __IO uint32_t ICR;            /*!< SDIO interrupt clear register,  Address offset: 0x38 */
X  volatile uint32_t ICR;             
N  __IO uint32_t MASK;           /*!< SDIO mask register,             Address offset: 0x3C */
X  volatile uint32_t MASK;            
N  uint32_t      RESERVED0[2];   /*!< Reserved, 0x40-0x44                                  */
N  __I uint32_t  FIFOCNT;        /*!< SDIO FIFO counter register,     Address offset: 0x48 */
X  volatile const uint32_t  FIFOCNT;         
N  uint32_t      RESERVED1[13];  /*!< Reserved, 0x4C-0x7C                                  */
N  __IO uint32_t FIFO;           /*!< SDIO data FIFO register,        Address offset: 0x80 */
X  volatile uint32_t FIFO;            
N} SDIO_TypeDef;
N
N/** 
N  * @brief Serial Peripheral Interface
N  */
N
Ntypedef struct
N{
N  __IO uint16_t CR1;        /*!< SPI control register 1 (not used in I2S mode),      Address offset: 0x00 */
X  volatile uint16_t CR1;         
N  uint16_t      RESERVED0;  /*!< Reserved, 0x02                                                           */
N  __IO uint16_t CR2;        /*!< SPI control register 2,                             Address offset: 0x04 */
X  volatile uint16_t CR2;         
N  uint16_t      RESERVED1;  /*!< Reserved, 0x06                                                           */
N  __IO uint16_t SR;         /*!< SPI status register,                                Address offset: 0x08 */
X  volatile uint16_t SR;          
N  uint16_t      RESERVED2;  /*!< Reserved, 0x0A                                                           */
N  __IO uint16_t DR;         /*!< SPI data register,                                  Address offset: 0x0C */
X  volatile uint16_t DR;          
N  uint16_t      RESERVED3;  /*!< Reserved, 0x0E                                                           */
N  __IO uint16_t CRCPR;      /*!< SPI CRC polynomial register (not used in I2S mode), Address offset: 0x10 */
X  volatile uint16_t CRCPR;       
N  uint16_t      RESERVED4;  /*!< Reserved, 0x12                                                           */
N  __IO uint16_t RXCRCR;     /*!< SPI RX CRC register (not used in I2S mode),         Address offset: 0x14 */
X  volatile uint16_t RXCRCR;      
N  uint16_t      RESERVED5;  /*!< Reserved, 0x16                                                           */
N  __IO uint16_t TXCRCR;     /*!< SPI TX CRC register (not used in I2S mode),         Address offset: 0x18 */
X  volatile uint16_t TXCRCR;      
N  uint16_t      RESERVED6;  /*!< Reserved, 0x1A                                                           */
N  __IO uint16_t I2SCFGR;    /*!< SPI_I2S configuration register,                     Address offset: 0x1C */
X  volatile uint16_t I2SCFGR;     
N  uint16_t      RESERVED7;  /*!< Reserved, 0x1E                                                           */
N  __IO uint16_t I2SPR;      /*!< SPI_I2S prescaler register,                         Address offset: 0x20 */
X  volatile uint16_t I2SPR;       
N  uint16_t      RESERVED8;  /*!< Reserved, 0x22                                                           */
N} SPI_TypeDef;
N
N#if defined(STM32F446xx)
X#if 0L
S/** 
S  * @brief SPDIFRX Interface
S  */
Stypedef struct
S{
S  __IO uint32_t   CR;           /*!< Control register,                   Address offset: 0x00 */
S  __IO uint16_t   IMR;          /*!< Interrupt mask register,            Address offset: 0x04 */
S  uint16_t        RESERVED0;    /*!< Reserved,  0x06                                          */  
S  __IO uint32_t   SR;           /*!< Status register,                    Address offset: 0x08 */
S  __IO uint16_t   IFCR;         /*!< Interrupt Flag Clear register,      Address offset: 0x0C */
S  uint16_t        RESERVED1;    /*!< Reserved,  0x0E                                          */   
S  __IO uint32_t   DR;           /*!< Data input register,                Address offset: 0x10 */
S  __IO uint32_t   CSR;          /*!< Channel Status register,            Address offset: 0x14 */
S   __IO uint32_t  DIR;          /*!< Debug Information register,         Address offset: 0x18 */
S  uint16_t        RESERVED2;    /*!< Reserved,  0x1A                                          */   
S} SPDIFRX_TypeDef;
N#endif /* STM32F446xx */
N
N#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
X#if 0L || 0L || 0L || 0L
S/** 
S  * @brief QUAD Serial Peripheral Interface
S  */
Stypedef struct
S{
S  __IO uint32_t CR;       /*!< QUADSPI Control register,                           Address offset: 0x00 */
S  __IO uint32_t DCR;      /*!< QUADSPI Device Configuration register,              Address offset: 0x04 */
S  __IO uint32_t SR;       /*!< QUADSPI Status register,                            Address offset: 0x08 */
S  __IO uint32_t FCR;      /*!< QUADSPI Flag Clear register,                        Address offset: 0x0C */
S  __IO uint32_t DLR;      /*!< QUADSPI Data Length register,                       Address offset: 0x10 */
S  __IO uint32_t CCR;      /*!< QUADSPI Communication Configuration register,       Address offset: 0x14 */
S  __IO uint32_t AR;       /*!< QUADSPI Address register,                           Address offset: 0x18 */
S  __IO uint32_t ABR;      /*!< QUADSPI Alternate Bytes register,                   Address offset: 0x1C */
S  __IO uint32_t DR;       /*!< QUADSPI Data register,                              Address offset: 0x20 */
S  __IO uint32_t PSMKR;    /*!< QUADSPI Polling Status Mask register,               Address offset: 0x24 */
S  __IO uint32_t PSMAR;    /*!< QUADSPI Polling Status Match register,              Address offset: 0x28 */
S  __IO uint32_t PIR;      /*!< QUADSPI Polling Interval register,                  Address offset: 0x2C */
S  __IO uint32_t LPTR;     /*!< QUADSPI Low Power Timeout register,                 Address offset: 0x30 */
S} QUADSPI_TypeDef;
N#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx || STM32F469_479xx */
N
N#if defined(STM32F446xx)
X#if 0L
S/** 
S  * @brief SPDIF-RX Interface
S  */
Stypedef struct
S{
S  __IO uint32_t   CR;           /*!< Control register,                   Address offset: 0x00 */
S  __IO uint16_t   IMR;          /*!< Interrupt mask register,            Address offset: 0x04 */
S  uint16_t        RESERVED0;    /*!< Reserved,  0x06                                          */  
S  __IO uint32_t   SR;           /*!< Status register,                    Address offset: 0x08 */
S  __IO uint16_t   IFCR;         /*!< Interrupt Flag Clear register,      Address offset: 0x0C */
S  uint16_t        RESERVED1;    /*!< Reserved,  0x0E                                          */   
S  __IO uint32_t   DR;           /*!< Data input register,                Address offset: 0x10 */
S  __IO uint32_t   CSR;          /*!< Channel Status register,            Address offset: 0x14 */
S   __IO uint32_t  DIR;          /*!< Debug Information register,         Address offset: 0x18 */
S  uint16_t        RESERVED2;    /*!< Reserved,  0x1A                                          */   
S} SPDIF_TypeDef;
N#endif /* STM32F446xx */
N
N/** 
N  * @brief TIM
N  */
N
Ntypedef struct
N{
N  __IO uint16_t CR1;         /*!< TIM control register 1,              Address offset: 0x00 */
X  volatile uint16_t CR1;          
N  uint16_t      RESERVED0;   /*!< Reserved, 0x02                                            */
N  __IO uint16_t CR2;         /*!< TIM control register 2,              Address offset: 0x04 */
X  volatile uint16_t CR2;          
N  uint16_t      RESERVED1;   /*!< Reserved, 0x06                                            */
N  __IO uint16_t SMCR;        /*!< TIM slave mode control register,     Address offset: 0x08 */
X  volatile uint16_t SMCR;         
N  uint16_t      RESERVED2;   /*!< Reserved, 0x0A                                            */
N  __IO uint16_t DIER;        /*!< TIM DMA/interrupt enable register,   Address offset: 0x0C */
X  volatile uint16_t DIER;         
N  uint16_t      RESERVED3;   /*!< Reserved, 0x0E                                            */
N  __IO uint16_t SR;          /*!< TIM status register,                 Address offset: 0x10 */
X  volatile uint16_t SR;           
N  uint16_t      RESERVED4;   /*!< Reserved, 0x12                                            */
N  __IO uint16_t EGR;         /*!< TIM event generation register,       Address offset: 0x14 */
X  volatile uint16_t EGR;          
N  uint16_t      RESERVED5;   /*!< Reserved, 0x16                                            */
N  __IO uint16_t CCMR1;       /*!< TIM capture/compare mode register 1, Address offset: 0x18 */
X  volatile uint16_t CCMR1;        
N  uint16_t      RESERVED6;   /*!< Reserved, 0x1A                                            */
N  __IO uint16_t CCMR2;       /*!< TIM capture/compare mode register 2, Address offset: 0x1C */
X  volatile uint16_t CCMR2;        
N  uint16_t      RESERVED7;   /*!< Reserved, 0x1E                                            */
N  __IO uint16_t CCER;        /*!< TIM capture/compare enable register, Address offset: 0x20 */
X  volatile uint16_t CCER;         
N  uint16_t      RESERVED8;   /*!< Reserved, 0x22                                            */
N  __IO uint32_t CNT;         /*!< TIM counter register,                Address offset: 0x24 */
X  volatile uint32_t CNT;          
N  __IO uint16_t PSC;         /*!< TIM prescaler,                       Address offset: 0x28 */
X  volatile uint16_t PSC;          
N  uint16_t      RESERVED9;   /*!< Reserved, 0x2A                                            */
N  __IO uint32_t ARR;         /*!< TIM auto-reload register,            Address offset: 0x2C */
X  volatile uint32_t ARR;          
N  __IO uint16_t RCR;         /*!< TIM repetition counter register,     Address offset: 0x30 */
X  volatile uint16_t RCR;          
N  uint16_t      RESERVED10;  /*!< Reserved, 0x32                                            */
N  __IO uint32_t CCR1;        /*!< TIM capture/compare register 1,      Address offset: 0x34 */
X  volatile uint32_t CCR1;         
N  __IO uint32_t CCR2;        /*!< TIM capture/compare register 2,      Address offset: 0x38 */
X  volatile uint32_t CCR2;         
N  __IO uint32_t CCR3;        /*!< TIM capture/compare register 3,      Address offset: 0x3C */
X  volatile uint32_t CCR3;         
N  __IO uint32_t CCR4;        /*!< TIM capture/compare register 4,      Address offset: 0x40 */
X  volatile uint32_t CCR4;         
N  __IO uint16_t BDTR;        /*!< TIM break and dead-time register,    Address offset: 0x44 */
X  volatile uint16_t BDTR;         
N  uint16_t      RESERVED11;  /*!< Reserved, 0x46                                            */
N  __IO uint16_t DCR;         /*!< TIM DMA control register,            Address offset: 0x48 */
X  volatile uint16_t DCR;          
N  uint16_t      RESERVED12;  /*!< Reserved, 0x4A                                            */
N  __IO uint16_t DMAR;        /*!< TIM DMA address for full transfer,   Address offset: 0x4C */
X  volatile uint16_t DMAR;         
N  uint16_t      RESERVED13;  /*!< Reserved, 0x4E                                            */
N  __IO uint16_t OR;          /*!< TIM option register,                 Address offset: 0x50 */
X  volatile uint16_t OR;           
N  uint16_t      RESERVED14;  /*!< Reserved, 0x52                                            */
N} TIM_TypeDef;
N
N/** 
N  * @brief Universal Synchronous Asynchronous Receiver Transmitter
N  */
N 
Ntypedef struct
N{
N  __IO uint16_t SR;         /*!< USART Status register,                   Address offset: 0x00 */
X  volatile uint16_t SR;          
N  uint16_t      RESERVED0;  /*!< Reserved, 0x02                                                */
N  __IO uint16_t DR;         /*!< USART Data register,                     Address offset: 0x04 */
X  volatile uint16_t DR;          
N  uint16_t      RESERVED1;  /*!< Reserved, 0x06                                                */
N  __IO uint16_t BRR;        /*!< USART Baud rate register,                Address offset: 0x08 */
X  volatile uint16_t BRR;         
N  uint16_t      RESERVED2;  /*!< Reserved, 0x0A                                                */
N  __IO uint16_t CR1;        /*!< USART Control register 1,                Address offset: 0x0C */
X  volatile uint16_t CR1;         
N  uint16_t      RESERVED3;  /*!< Reserved, 0x0E                                                */
N  __IO uint16_t CR2;        /*!< USART Control register 2,                Address offset: 0x10 */
X  volatile uint16_t CR2;         
N  uint16_t      RESERVED4;  /*!< Reserved, 0x12                                                */
N  __IO uint16_t CR3;        /*!< USART Control register 3,                Address offset: 0x14 */
X  volatile uint16_t CR3;         
N  uint16_t      RESERVED5;  /*!< Reserved, 0x16                                                */
N  __IO uint16_t GTPR;       /*!< USART Guard time and prescaler register, Address offset: 0x18 */
X  volatile uint16_t GTPR;        
N  uint16_t      RESERVED6;  /*!< Reserved, 0x1A                                                */
N} USART_TypeDef;
N
N/** 
N  * @brief Window WATCHDOG
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;   /*!< WWDG Control register,       Address offset: 0x00 */
X  volatile uint32_t CR;    
N  __IO uint32_t CFR;  /*!< WWDG Configuration register, Address offset: 0x04 */
X  volatile uint32_t CFR;   
N  __IO uint32_t SR;   /*!< WWDG Status register,        Address offset: 0x08 */
X  volatile uint32_t SR;    
N} WWDG_TypeDef;
N
N/** 
N  * @brief Crypto Processor
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;         /*!< CRYP control register,                                    Address offset: 0x00 */
X  volatile uint32_t CR;          
N  __IO uint32_t SR;         /*!< CRYP status register,                                     Address offset: 0x04 */
X  volatile uint32_t SR;          
N  __IO uint32_t DR;         /*!< CRYP data input register,                                 Address offset: 0x08 */
X  volatile uint32_t DR;          
N  __IO uint32_t DOUT;       /*!< CRYP data output register,                                Address offset: 0x0C */
X  volatile uint32_t DOUT;        
N  __IO uint32_t DMACR;      /*!< CRYP DMA control register,                                Address offset: 0x10 */
X  volatile uint32_t DMACR;       
N  __IO uint32_t IMSCR;      /*!< CRYP interrupt mask set/clear register,                   Address offset: 0x14 */
X  volatile uint32_t IMSCR;       
N  __IO uint32_t RISR;       /*!< CRYP raw interrupt status register,                       Address offset: 0x18 */
X  volatile uint32_t RISR;        
N  __IO uint32_t MISR;       /*!< CRYP masked interrupt status register,                    Address offset: 0x1C */
X  volatile uint32_t MISR;        
N  __IO uint32_t K0LR;       /*!< CRYP key left  register 0,                                Address offset: 0x20 */
X  volatile uint32_t K0LR;        
N  __IO uint32_t K0RR;       /*!< CRYP key right register 0,                                Address offset: 0x24 */
X  volatile uint32_t K0RR;        
N  __IO uint32_t K1LR;       /*!< CRYP key left  register 1,                                Address offset: 0x28 */
X  volatile uint32_t K1LR;        
N  __IO uint32_t K1RR;       /*!< CRYP key right register 1,                                Address offset: 0x2C */
X  volatile uint32_t K1RR;        
N  __IO uint32_t K2LR;       /*!< CRYP key left  register 2,                                Address offset: 0x30 */
X  volatile uint32_t K2LR;        
N  __IO uint32_t K2RR;       /*!< CRYP key right register 2,                                Address offset: 0x34 */
X  volatile uint32_t K2RR;        
N  __IO uint32_t K3LR;       /*!< CRYP key left  register 3,                                Address offset: 0x38 */
X  volatile uint32_t K3LR;        
N  __IO uint32_t K3RR;       /*!< CRYP key right register 3,                                Address offset: 0x3C */
X  volatile uint32_t K3RR;        
N  __IO uint32_t IV0LR;      /*!< CRYP initialization vector left-word  register 0,         Address offset: 0x40 */
X  volatile uint32_t IV0LR;       
N  __IO uint32_t IV0RR;      /*!< CRYP initialization vector right-word register 0,         Address offset: 0x44 */
X  volatile uint32_t IV0RR;       
N  __IO uint32_t IV1LR;      /*!< CRYP initialization vector left-word  register 1,         Address offset: 0x48 */
X  volatile uint32_t IV1LR;       
N  __IO uint32_t IV1RR;      /*!< CRYP initialization vector right-word register 1,         Address offset: 0x4C */
X  volatile uint32_t IV1RR;       
N  __IO uint32_t CSGCMCCM0R; /*!< CRYP GCM/GMAC or CCM/CMAC context swap register 0,        Address offset: 0x50 */
X  volatile uint32_t CSGCMCCM0R;  
N  __IO uint32_t CSGCMCCM1R; /*!< CRYP GCM/GMAC or CCM/CMAC context swap register 1,        Address offset: 0x54 */
X  volatile uint32_t CSGCMCCM1R;  
N  __IO uint32_t CSGCMCCM2R; /*!< CRYP GCM/GMAC or CCM/CMAC context swap register 2,        Address offset: 0x58 */
X  volatile uint32_t CSGCMCCM2R;  
N  __IO uint32_t CSGCMCCM3R; /*!< CRYP GCM/GMAC or CCM/CMAC context swap register 3,        Address offset: 0x5C */
X  volatile uint32_t CSGCMCCM3R;  
N  __IO uint32_t CSGCMCCM4R; /*!< CRYP GCM/GMAC or CCM/CMAC context swap register 4,        Address offset: 0x60 */
X  volatile uint32_t CSGCMCCM4R;  
N  __IO uint32_t CSGCMCCM5R; /*!< CRYP GCM/GMAC or CCM/CMAC context swap register 5,        Address offset: 0x64 */
X  volatile uint32_t CSGCMCCM5R;  
N  __IO uint32_t CSGCMCCM6R; /*!< CRYP GCM/GMAC or CCM/CMAC context swap register 6,        Address offset: 0x68 */
X  volatile uint32_t CSGCMCCM6R;  
N  __IO uint32_t CSGCMCCM7R; /*!< CRYP GCM/GMAC or CCM/CMAC context swap register 7,        Address offset: 0x6C */
X  volatile uint32_t CSGCMCCM7R;  
N  __IO uint32_t CSGCM0R;    /*!< CRYP GCM/GMAC context swap register 0,                    Address offset: 0x70 */
X  volatile uint32_t CSGCM0R;     
N  __IO uint32_t CSGCM1R;    /*!< CRYP GCM/GMAC context swap register 1,                    Address offset: 0x74 */
X  volatile uint32_t CSGCM1R;     
N  __IO uint32_t CSGCM2R;    /*!< CRYP GCM/GMAC context swap register 2,                    Address offset: 0x78 */
X  volatile uint32_t CSGCM2R;     
N  __IO uint32_t CSGCM3R;    /*!< CRYP GCM/GMAC context swap register 3,                    Address offset: 0x7C */
X  volatile uint32_t CSGCM3R;     
N  __IO uint32_t CSGCM4R;    /*!< CRYP GCM/GMAC context swap register 4,                    Address offset: 0x80 */
X  volatile uint32_t CSGCM4R;     
N  __IO uint32_t CSGCM5R;    /*!< CRYP GCM/GMAC context swap register 5,                    Address offset: 0x84 */
X  volatile uint32_t CSGCM5R;     
N  __IO uint32_t CSGCM6R;    /*!< CRYP GCM/GMAC context swap register 6,                    Address offset: 0x88 */
X  volatile uint32_t CSGCM6R;     
N  __IO uint32_t CSGCM7R;    /*!< CRYP GCM/GMAC context swap register 7,                    Address offset: 0x8C */
X  volatile uint32_t CSGCM7R;     
N} CRYP_TypeDef;
N
N/** 
N  * @brief HASH
N  */
N  
Ntypedef struct 
N{
N  __IO uint32_t CR;               /*!< HASH control register,          Address offset: 0x00        */
X  volatile uint32_t CR;                
N  __IO uint32_t DIN;              /*!< HASH data input register,       Address offset: 0x04        */
X  volatile uint32_t DIN;               
N  __IO uint32_t STR;              /*!< HASH start register,            Address offset: 0x08        */
X  volatile uint32_t STR;               
N  __IO uint32_t HR[5];            /*!< HASH digest registers,          Address offset: 0x0C-0x1C   */
X  volatile uint32_t HR[5];             
N  __IO uint32_t IMR;              /*!< HASH interrupt enable register, Address offset: 0x20        */
X  volatile uint32_t IMR;               
N  __IO uint32_t SR;               /*!< HASH status register,           Address offset: 0x24        */
X  volatile uint32_t SR;                
N       uint32_t RESERVED[52];     /*!< Reserved, 0x28-0xF4                                         */
N  __IO uint32_t CSR[54];          /*!< HASH context swap registers,    Address offset: 0x0F8-0x1CC */
X  volatile uint32_t CSR[54];           
N} HASH_TypeDef;
N
N/** 
N  * @brief HASH_DIGEST
N  */
N  
Ntypedef struct 
N{
N  __IO uint32_t HR[8];     /*!< HASH digest registers,          Address offset: 0x310-0x32C */ 
X  volatile uint32_t HR[8];       
N} HASH_DIGEST_TypeDef;
N
N/** 
N  * @brief RNG
N  */
N  
Ntypedef struct 
N{
N  __IO uint32_t CR;  /*!< RNG control register, Address offset: 0x00 */
X  volatile uint32_t CR;   
N  __IO uint32_t SR;  /*!< RNG status register,  Address offset: 0x04 */
X  volatile uint32_t SR;   
N  __IO uint32_t DR;  /*!< RNG data register,    Address offset: 0x08 */
X  volatile uint32_t DR;   
N} RNG_TypeDef;
N
N#if defined(STM32F410xx) || defined(STM32F413_423xx)
X#if 0L || 0L
S/**
S  * @brief LPTIMER
S  */
Stypedef struct
S{
S  __IO uint32_t ISR;         /*!< LPTIM Interrupt and Status register,                Address offset: 0x00 */
S  __IO uint32_t ICR;         /*!< LPTIM Interrupt Clear register,                     Address offset: 0x04 */
S  __IO uint32_t IER;         /*!< LPTIM Interrupt Enable register,                    Address offset: 0x08 */
S  __IO uint32_t CFGR;        /*!< LPTIM Configuration register,                       Address offset: 0x0C */
S  __IO uint32_t CR;          /*!< LPTIM Control register,                             Address offset: 0x10 */
S  __IO uint32_t CMP;         /*!< LPTIM Compare register,                             Address offset: 0x14 */
S  __IO uint32_t ARR;         /*!< LPTIM Autoreload register,                          Address offset: 0x18 */
S  __IO uint32_t CNT;         /*!< LPTIM Counter register,                             Address offset: 0x1C */
S  __IO uint32_t OR;          /*!< LPTIM Option register,                              Address offset: 0x20 */
S} LPTIM_TypeDef;
N#endif /* STM32F410xx || STM32F413_423xx */
N/**
N  * @}
N  */
N  
N/** @addtogroup Peripheral_memory_map
N  * @{
N  */
N
N#define FLASH_BASE            ((uint32_t)0x08000000) /*!< FLASH(up to 1 MB) base address in the alias region                         */
N#define CCMDATARAM_BASE       ((uint32_t)0x10000000) /*!< CCM(core coupled memory) data RAM(64 KB) base address in the alias region  */
N#define SRAM1_BASE            ((uint32_t)0x20000000) /*!< SRAM1(112 KB) base address in the alias region                             */
N#if defined(STM32F40_41xxx) || defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F446xx) 
X#if 1L || 0L || 0L || 0L 
N#define SRAM2_BASE            ((uint32_t)0x2001C000) /*!< SRAM2(16 KB) base address in the alias region                              */
N#define SRAM3_BASE            ((uint32_t)0x20020000) /*!< SRAM3(64 KB) base address in the alias region                              */
N#elif defined(STM32F469_479xx)
S#define SRAM2_BASE            ((uint32_t)0x20028000) /*!< SRAM2(16 KB) base address in the alias region                              */
S#define SRAM3_BASE            ((uint32_t)0x20030000) /*!< SRAM3(64 KB) base address in the alias region                              */
S#elif defined(STM32F413_423xx)
S#define SRAM2_BASE            ((uint32_t)0x20040000) /*!< SRAM2(16 KB) base address in the alias region                              */
S#else /* STM32F411xE || STM32F410xx || STM32F412xG */
N#endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx ||  STM32F446xx */
N#define PERIPH_BASE           ((uint32_t)0x40000000) /*!< Peripheral base address in the alias region                                */
N#define BKPSRAM_BASE          ((uint32_t)0x40024000) /*!< Backup SRAM(4 KB) base address in the alias region                         */
N      
N#if defined(STM32F40_41xxx) || defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 1L || 0L || 0L
N#define FSMC_R_BASE           ((uint32_t)0xA0000000) /*!< FSMC registers base address                                                */
N#endif /* STM32F40_41xxx || STM32F412xG || STM32F413_423xx */
N
N#if defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
X#if 0L || 0L || 0L || 0L
S#define FMC_R_BASE            ((uint32_t)0xA0000000) /*!< FMC registers base address                                                 */
N#endif /* STM32F427_437xx ||  STM32F429_439xx || STM32F446xx || STM32F469_479xx */
N
N#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
X#if 0L || 0L || 0L || 0L
S#define QSPI_R_BASE           ((uint32_t)0xA0001000) /*!< QuadSPI registers base address                                            */
N#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx || STM32F469_479xx */
N
N#define CCMDATARAM_BB_BASE    ((uint32_t)0x12000000) /*!< CCM(core coupled memory) data RAM(64 KB) base address in the bit-band region  */
N#define SRAM1_BB_BASE         ((uint32_t)0x22000000) /*!< SRAM1(112 KB) base address in the bit-band region                             */
N#if defined(STM32F40_41xxx) || defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F446xx)
X#if 1L || 0L || 0L || 0L
N#define SRAM2_BB_BASE         ((uint32_t)0x22380000) /*!< SRAM2(16 KB) base address in the bit-band region                              */
N#define SRAM3_BB_BASE         ((uint32_t)0x22400000) /*!< SRAM3(64 KB) base address in the bit-band region                              */
N#elif defined(STM32F469_479xx)
S#define SRAM2_BB_BASE         ((uint32_t)0x22500000) /*!< SRAM2(16 KB) base address in the bit-band region                              */
S#define SRAM3_BB_BASE         ((uint32_t)0x22600000) /*!< SRAM3(64 KB) base address in the bit-band region                              */
S#elif defined(STM32F413_423xx)
S#define SRAM2_BB_BASE         ((uint32_t)0x22800000) /*!< SRAM2(64 KB) base address in the bit-band region                              */   
S#else /* STM32F411xE || STM32F410xx || STM32F412xG */
N#endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx ||  STM32F446xx */
N#define PERIPH_BB_BASE        ((uint32_t)0x42000000) /*!< Peripheral base address in the bit-band region                                */
N#define BKPSRAM_BB_BASE       ((uint32_t)0x42480000) /*!< Backup SRAM(4 KB) base address in the bit-band region                         */
N
N/* Legacy defines */
N#define SRAM_BASE             SRAM1_BASE
N#define SRAM_BB_BASE          SRAM1_BB_BASE
N
N
N/*!< Peripheral memory map */
N#define APB1PERIPH_BASE       PERIPH_BASE
N#define APB2PERIPH_BASE       (PERIPH_BASE + 0x00010000)
N#define AHB1PERIPH_BASE       (PERIPH_BASE + 0x00020000)
N#define AHB2PERIPH_BASE       (PERIPH_BASE + 0x10000000)
N
N/*!< APB1 peripherals */
N#define TIM2_BASE             (APB1PERIPH_BASE + 0x0000)
N#define TIM3_BASE             (APB1PERIPH_BASE + 0x0400)
N#define TIM4_BASE             (APB1PERIPH_BASE + 0x0800)
N#define TIM5_BASE             (APB1PERIPH_BASE + 0x0C00)
N#define TIM6_BASE             (APB1PERIPH_BASE + 0x1000)
N#define TIM7_BASE             (APB1PERIPH_BASE + 0x1400)
N#if defined(STM32F410xx) || defined(STM32F413_423xx)
X#if 0L || 0L
S#define LPTIM1_BASE           (APB1PERIPH_BASE + 0x2400)
N#endif /* STM32F410xx || STM32F413_423xx */
N#define TIM12_BASE            (APB1PERIPH_BASE + 0x1800)
N#define TIM13_BASE            (APB1PERIPH_BASE + 0x1C00)
N#define TIM14_BASE            (APB1PERIPH_BASE + 0x2000)
N#define RTC_BASE              (APB1PERIPH_BASE + 0x2800)
N#define WWDG_BASE             (APB1PERIPH_BASE + 0x2C00)
N#define IWDG_BASE             (APB1PERIPH_BASE + 0x3000)
N#define I2S2ext_BASE          (APB1PERIPH_BASE + 0x3400)
N#define SPI2_BASE             (APB1PERIPH_BASE + 0x3800)
N#define SPI3_BASE             (APB1PERIPH_BASE + 0x3C00)
N#if defined(STM32F446xx)                              
X#if 0L                              
S#define SPDIFRX_BASE          (APB1PERIPH_BASE + 0x4000)
N#endif /* STM32F446xx */
N#define I2S3ext_BASE          (APB1PERIPH_BASE + 0x4000)
N#define USART2_BASE           (APB1PERIPH_BASE + 0x4400)
N#define USART3_BASE           (APB1PERIPH_BASE + 0x4800)
N#define UART4_BASE            (APB1PERIPH_BASE + 0x4C00)
N#define UART5_BASE            (APB1PERIPH_BASE + 0x5000)
N#define I2C1_BASE             (APB1PERIPH_BASE + 0x5400)
N#define I2C2_BASE             (APB1PERIPH_BASE + 0x5800)
N#define I2C3_BASE             (APB1PERIPH_BASE + 0x5C00)
N#if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
X#if 0L || 0L || 0L || 0L
S#define FMPI2C1_BASE          (APB1PERIPH_BASE + 0x6000)
N#endif /* STM32F410xx || STM32F412xG || STM32F413_423xx || STM32F446xx */
N#define CAN1_BASE             (APB1PERIPH_BASE + 0x6400)
N#define CAN2_BASE             (APB1PERIPH_BASE + 0x6800)
N#if defined(STM32F413_423xx)
X#if 0L
S#define CAN3_BASE             (APB1PERIPH_BASE + 0x6C00)
N#endif /* STM32F413_423xx */
N#if defined(STM32F446xx)
X#if 0L
S#define CEC_BASE              (APB1PERIPH_BASE + 0x6C00)
N#endif /* STM32F446xx */
N#define PWR_BASE              (APB1PERIPH_BASE + 0x7000)
N#define DAC_BASE              (APB1PERIPH_BASE + 0x7400)
N#define UART7_BASE            (APB1PERIPH_BASE + 0x7800)
N#define UART8_BASE            (APB1PERIPH_BASE + 0x7C00)
N
N/*!< APB2 peripherals */
N#define TIM1_BASE             (APB2PERIPH_BASE + 0x0000)
N#define TIM8_BASE             (APB2PERIPH_BASE + 0x0400)
N#define USART1_BASE           (APB2PERIPH_BASE + 0x1000)
N#define USART6_BASE           (APB2PERIPH_BASE + 0x1400)
N#define UART9_BASE            (APB2PERIPH_BASE + 0x1800U)
N#define UART10_BASE           (APB2PERIPH_BASE + 0x1C00U)
N#define ADC1_BASE             (APB2PERIPH_BASE + 0x2000)
N#define ADC2_BASE             (APB2PERIPH_BASE + 0x2100)
N#define ADC3_BASE             (APB2PERIPH_BASE + 0x2200)
N#define ADC_BASE              (APB2PERIPH_BASE + 0x2300)
N#define SDIO_BASE             (APB2PERIPH_BASE + 0x2C00)
N#define SPI1_BASE             (APB2PERIPH_BASE + 0x3000)
N#define SPI4_BASE             (APB2PERIPH_BASE + 0x3400)
N#define SYSCFG_BASE           (APB2PERIPH_BASE + 0x3800)
N#define EXTI_BASE             (APB2PERIPH_BASE + 0x3C00)
N#define TIM9_BASE             (APB2PERIPH_BASE + 0x4000)
N#define TIM10_BASE            (APB2PERIPH_BASE + 0x4400)
N#define TIM11_BASE            (APB2PERIPH_BASE + 0x4800)
N#define SPI5_BASE             (APB2PERIPH_BASE + 0x5000)
N#define SPI6_BASE             (APB2PERIPH_BASE + 0x5400)
N#define SAI1_BASE             (APB2PERIPH_BASE + 0x5800)
N#define SAI1_Block_A_BASE     (SAI1_BASE + 0x004)
N#define SAI1_Block_B_BASE     (SAI1_BASE + 0x024)
N#if defined(STM32F446xx)
X#if 0L
S#define SAI2_BASE             (APB2PERIPH_BASE + 0x5C00)
S#define SAI2_Block_A_BASE     (SAI2_BASE + 0x004)
S#define SAI2_Block_B_BASE     (SAI2_BASE + 0x024)
N#endif /* STM32F446xx */
N#define LTDC_BASE             (APB2PERIPH_BASE + 0x6800)
N#define LTDC_Layer1_BASE      (LTDC_BASE + 0x84)
N#define LTDC_Layer2_BASE      (LTDC_BASE + 0x104)
N#if defined(STM32F469_479xx)
X#if 0L
S#define DSI_BASE              (APB2PERIPH_BASE + 0x6C00)
N#endif /* STM32F469_479xx */
N#if defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 0L || 0L
S#define DFSDM1_BASE           (APB2PERIPH_BASE + 0x6000)
S#define DFSDM1_Channel0_BASE  (DFSDM1_BASE + 0x00)
S#define DFSDM1_Channel1_BASE  (DFSDM1_BASE + 0x20)
S#define DFSDM1_Channel2_BASE  (DFSDM1_BASE + 0x40)
S#define DFSDM1_Channel3_BASE  (DFSDM1_BASE + 0x60)
S#define DFSDM1_Filter0_BASE   (DFSDM1_BASE + 0x100)
S#define DFSDM1_Filter1_BASE   (DFSDM1_BASE + 0x180)
S#define DFSDM1_0              ((DFSDM_TypeDef *) DFSDM1_Filter0_BASE)
S#define DFSDM1_1              ((DFSDM_TypeDef *) DFSDM1_Filter1_BASE)
S/* Legacy Defines */
S#define DFSDM0                DFSDM1_0              
S#define DFSDM1                DFSDM1_1              
S#if defined(STM32F413_423xx)
S#define DFSDM2_BASE           (APB2PERIPH_BASE + 0x6400U)
S#define DFSDM2_Channel0_BASE  (DFSDM2_BASE + 0x00U)
S#define DFSDM2_Channel1_BASE  (DFSDM2_BASE + 0x20U)
S#define DFSDM2_Channel2_BASE  (DFSDM2_BASE + 0x40U)
S#define DFSDM2_Channel3_BASE  (DFSDM2_BASE + 0x60U)
S#define DFSDM2_Channel4_BASE  (DFSDM2_BASE + 0x80U)
S#define DFSDM2_Channel5_BASE  (DFSDM2_BASE + 0xA0U)
S#define DFSDM2_Channel6_BASE  (DFSDM2_BASE + 0xC0U)
S#define DFSDM2_Channel7_BASE  (DFSDM2_BASE + 0xE0U)
S#define DFSDM2_Filter0_BASE   (DFSDM2_BASE + 0x100U)
S#define DFSDM2_Filter1_BASE   (DFSDM2_BASE + 0x180U)
S#define DFSDM2_Filter2_BASE   (DFSDM2_BASE + 0x200U)
S#define DFSDM2_Filter3_BASE   (DFSDM2_BASE + 0x280U)
S#define DFSDM2_0              ((DFSDM_TypeDef *) DFSDM2_Filter0_BASE)
S#define DFSDM2_1              ((DFSDM_TypeDef *) DFSDM2_Filter1_BASE)
S#define DFSDM2_2              ((DFSDM_TypeDef *) DFSDM2_Filter2_BASE)
S#define DFSDM2_3              ((DFSDM_TypeDef *) DFSDM2_Filter3_BASE)
S#endif /* STM32F413_423xx */
N#endif /* STM32F412xG ||  STM32F413_423xx */
N
N/*!< AHB1 peripherals */
N#define GPIOA_BASE            (AHB1PERIPH_BASE + 0x0000)
N#define GPIOB_BASE            (AHB1PERIPH_BASE + 0x0400)
N#define GPIOC_BASE            (AHB1PERIPH_BASE + 0x0800)
N#define GPIOD_BASE            (AHB1PERIPH_BASE + 0x0C00)
N#define GPIOE_BASE            (AHB1PERIPH_BASE + 0x1000)
N#define GPIOF_BASE            (AHB1PERIPH_BASE + 0x1400)
N#define GPIOG_BASE            (AHB1PERIPH_BASE + 0x1800)
N#define GPIOH_BASE            (AHB1PERIPH_BASE + 0x1C00)
N#define GPIOI_BASE            (AHB1PERIPH_BASE + 0x2000)
N#define GPIOJ_BASE            (AHB1PERIPH_BASE + 0x2400)
N#define GPIOK_BASE            (AHB1PERIPH_BASE + 0x2800)
N#define CRC_BASE              (AHB1PERIPH_BASE + 0x3000)
N#define RCC_BASE              (AHB1PERIPH_BASE + 0x3800)
N#define FLASH_R_BASE          (AHB1PERIPH_BASE + 0x3C00)
N#define DMA1_BASE             (AHB1PERIPH_BASE + 0x6000)
N#define DMA1_Stream0_BASE     (DMA1_BASE + 0x010)
N#define DMA1_Stream1_BASE     (DMA1_BASE + 0x028)
N#define DMA1_Stream2_BASE     (DMA1_BASE + 0x040)
N#define DMA1_Stream3_BASE     (DMA1_BASE + 0x058)
N#define DMA1_Stream4_BASE     (DMA1_BASE + 0x070)
N#define DMA1_Stream5_BASE     (DMA1_BASE + 0x088)
N#define DMA1_Stream6_BASE     (DMA1_BASE + 0x0A0)
N#define DMA1_Stream7_BASE     (DMA1_BASE + 0x0B8)
N#define DMA2_BASE             (AHB1PERIPH_BASE + 0x6400)
N#define DMA2_Stream0_BASE     (DMA2_BASE + 0x010)
N#define DMA2_Stream1_BASE     (DMA2_BASE + 0x028)
N#define DMA2_Stream2_BASE     (DMA2_BASE + 0x040)
N#define DMA2_Stream3_BASE     (DMA2_BASE + 0x058)
N#define DMA2_Stream4_BASE     (DMA2_BASE + 0x070)
N#define DMA2_Stream5_BASE     (DMA2_BASE + 0x088)
N#define DMA2_Stream6_BASE     (DMA2_BASE + 0x0A0)
N#define DMA2_Stream7_BASE     (DMA2_BASE + 0x0B8)
N#define ETH_BASE              (AHB1PERIPH_BASE + 0x8000)
N#define ETH_MAC_BASE          (ETH_BASE)
N#define ETH_MMC_BASE          (ETH_BASE + 0x0100)
N#define ETH_PTP_BASE          (ETH_BASE + 0x0700)
N#define ETH_DMA_BASE          (ETH_BASE + 0x1000)
N#define DMA2D_BASE            (AHB1PERIPH_BASE + 0xB000)
N
N/*!< AHB2 peripherals */
N#define DCMI_BASE             (AHB2PERIPH_BASE + 0x50000)
N#define CRYP_BASE             (AHB2PERIPH_BASE + 0x60000)
N#define HASH_BASE             (AHB2PERIPH_BASE + 0x60400)
N#define HASH_DIGEST_BASE      (AHB2PERIPH_BASE + 0x60710)
N#define RNG_BASE              (AHB2PERIPH_BASE + 0x60800)
N
N#if defined(STM32F40_41xxx) || defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 1L || 0L || 0L
N/*!< FSMC Bankx registers base address */
N#define FSMC_Bank1_R_BASE     (FSMC_R_BASE + 0x0000)
N#define FSMC_Bank1E_R_BASE    (FSMC_R_BASE + 0x0104)
N#define FSMC_Bank2_R_BASE     (FSMC_R_BASE + 0x0060)
N#define FSMC_Bank3_R_BASE     (FSMC_R_BASE + 0x0080)
N#define FSMC_Bank4_R_BASE     (FSMC_R_BASE + 0x00A0)
N#endif /* STM32F40_41xxx || STM32F412xG || STM32F413_423xx */
N
N#if defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
X#if 0L || 0L || 0L || 0L
S/*!< FMC Bankx registers base address */
S#define FMC_Bank1_R_BASE      (FMC_R_BASE + 0x0000)
S#define FMC_Bank1E_R_BASE     (FMC_R_BASE + 0x0104)
S#define FMC_Bank2_R_BASE      (FMC_R_BASE + 0x0060)
S#define FMC_Bank3_R_BASE      (FMC_R_BASE + 0x0080)
S#define FMC_Bank4_R_BASE      (FMC_R_BASE + 0x00A0)
S#define FMC_Bank5_6_R_BASE    (FMC_R_BASE + 0x0140)
N#endif /* STM32F427_437xx ||  STM32F429_439xx || STM32F446xx || STM32F469_479xx */
N
N/* Debug MCU registers base address */
N#define DBGMCU_BASE           ((uint32_t )0xE0042000)
N
N/**
N  * @}
N  */
N  
N/** @addtogroup Peripheral_declaration
N  * @{
N  */
N#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
X#if 0L || 0L || 0L || 0L
S#define QUADSPI             ((QUADSPI_TypeDef *) QSPI_R_BASE)
N#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx || STM32F469_479xx */
N#define TIM2                ((TIM_TypeDef *) TIM2_BASE)
N#define TIM3                ((TIM_TypeDef *) TIM3_BASE)
N#define TIM4                ((TIM_TypeDef *) TIM4_BASE)
N#define TIM5                ((TIM_TypeDef *) TIM5_BASE)
N#define TIM6                ((TIM_TypeDef *) TIM6_BASE)
N#define TIM7                ((TIM_TypeDef *) TIM7_BASE)
N#define TIM12               ((TIM_TypeDef *) TIM12_BASE)
N#define TIM13               ((TIM_TypeDef *) TIM13_BASE)
N#define TIM14               ((TIM_TypeDef *) TIM14_BASE)
N#define RTC                 ((RTC_TypeDef *) RTC_BASE)
N#define WWDG                ((WWDG_TypeDef *) WWDG_BASE)
N#define IWDG                ((IWDG_TypeDef *) IWDG_BASE)
N#define I2S2ext             ((SPI_TypeDef *) I2S2ext_BASE)
N#define SPI2                ((SPI_TypeDef *) SPI2_BASE)
N#define SPI3                ((SPI_TypeDef *) SPI3_BASE)
N#if defined(STM32F446xx)
X#if 0L
S#define SPDIFRX             ((SPDIFRX_TypeDef *) SPDIFRX_BASE)
N#endif /* STM32F446xx */
N#define I2S3ext             ((SPI_TypeDef *) I2S3ext_BASE)
N#define USART2              ((USART_TypeDef *) USART2_BASE)
N#define USART3              ((USART_TypeDef *) USART3_BASE)
N#define UART4               ((USART_TypeDef *) UART4_BASE)
N#define UART5               ((USART_TypeDef *) UART5_BASE)
N#define I2C1                ((I2C_TypeDef *) I2C1_BASE)
N#define I2C2                ((I2C_TypeDef *) I2C2_BASE)
N#define I2C3                ((I2C_TypeDef *) I2C3_BASE)
N#if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
X#if 0L || 0L || 0L || 0L
S#define FMPI2C1             ((FMPI2C_TypeDef *) FMPI2C1_BASE)
N#endif /* STM32F410xx || STM32F412xG || STM32F413_423xx || STM32F446xx */
N#if defined(STM32F410xx) || defined(STM32F413_423xx)
X#if 0L || 0L
S#define LPTIM1              ((LPTIM_TypeDef *) LPTIM1_BASE)
N#endif /* STM32F410xx || STM32F413_423xx */
N#define CAN1                ((CAN_TypeDef *) CAN1_BASE)
N#define CAN2                ((CAN_TypeDef *) CAN2_BASE)
N#if defined(STM32F413_423xx)
X#if 0L
S#define CAN3                ((CAN_TypeDef *) CAN3_BASE)
N#endif /* STM32F413_423xx */
N#if defined(STM32F446xx)
X#if 0L
S#define CEC                 ((CEC_TypeDef *) CEC_BASE)
N#endif /* STM32F446xx */
N#define PWR                 ((PWR_TypeDef *) PWR_BASE)
N#define DAC                 ((DAC_TypeDef *) DAC_BASE)
N#define UART7               ((USART_TypeDef *) UART7_BASE)
N#define UART8               ((USART_TypeDef *) UART8_BASE)
N#define UART9               ((USART_TypeDef *) UART9_BASE)
N#define UART10              ((USART_TypeDef *) UART10_BASE)
N#define TIM1                ((TIM_TypeDef *) TIM1_BASE)
N#define TIM8                ((TIM_TypeDef *) TIM8_BASE)
N#define USART1              ((USART_TypeDef *) USART1_BASE)
N#define USART6              ((USART_TypeDef *) USART6_BASE)
N#define ADC                 ((ADC_Common_TypeDef *) ADC_BASE)
N#define ADC1                ((ADC_TypeDef *) ADC1_BASE)
N#define ADC2                ((ADC_TypeDef *) ADC2_BASE)
N#define ADC3                ((ADC_TypeDef *) ADC3_BASE)
N#define SDIO                ((SDIO_TypeDef *) SDIO_BASE)
N#define SPI1                ((SPI_TypeDef *) SPI1_BASE) 
N#define SPI4                ((SPI_TypeDef *) SPI4_BASE)
N#define SYSCFG              ((SYSCFG_TypeDef *) SYSCFG_BASE)
N#define EXTI                ((EXTI_TypeDef *) EXTI_BASE)
N#define TIM9                ((TIM_TypeDef *) TIM9_BASE)
N#define TIM10               ((TIM_TypeDef *) TIM10_BASE)
N#define TIM11               ((TIM_TypeDef *) TIM11_BASE)
N#define SPI5                ((SPI_TypeDef *) SPI5_BASE)
N#define SPI6                ((SPI_TypeDef *) SPI6_BASE)
N#define SAI1                ((SAI_TypeDef *) SAI1_BASE)
N#define SAI1_Block_A        ((SAI_Block_TypeDef *)SAI1_Block_A_BASE)
N#define SAI1_Block_B        ((SAI_Block_TypeDef *)SAI1_Block_B_BASE)
N#if defined(STM32F446xx)
X#if 0L
S#define SAI2                ((SAI_TypeDef *) SAI2_BASE)
S#define SAI2_Block_A        ((SAI_Block_TypeDef *)SAI2_Block_A_BASE)
S#define SAI2_Block_B        ((SAI_Block_TypeDef *)SAI2_Block_B_BASE)
N#endif /* STM32F446xx */
N#define LTDC                ((LTDC_TypeDef *)LTDC_BASE)
N#define LTDC_Layer1         ((LTDC_Layer_TypeDef *)LTDC_Layer1_BASE)
N#define LTDC_Layer2         ((LTDC_Layer_TypeDef *)LTDC_Layer2_BASE)
N#if defined(STM32F469_479xx)
X#if 0L
S#define DSI                 ((DSI_TypeDef *)DSI_BASE)
N#endif /* STM32F469_479xx */
N#if defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 0L || 0L
S#define DFSDM1_Channel0     ((DFSDM_Channel_TypeDef *) DFSDM1_Channel0_BASE)
S#define DFSDM1_Channel1     ((DFSDM_Channel_TypeDef *) DFSDM1_Channel1_BASE)
S#define DFSDM1_Channel2     ((DFSDM_Channel_TypeDef *) DFSDM1_Channel2_BASE)
S#define DFSDM1_Channel3     ((DFSDM_Channel_TypeDef *) DFSDM1_Channel3_BASE)
S#define DFSDM1_Filter0      ((DFSDM_TypeDef *) DFSDM_Filter0_BASE)
S#define DFSDM1_Filter1      ((DFSDM_TypeDef *) DFSDM_Filter1_BASE)
S#if defined(STM32F413_423xx)
S#define DFSDM2_Channel0     ((DFSDM_Channel_TypeDef *) DFSDM2_Channel0_BASE)
S#define DFSDM2_Channel1     ((DFSDM_Channel_TypeDef *) DFSDM2_Channel1_BASE)
S#define DFSDM2_Channel2     ((DFSDM_Channel_TypeDef *) DFSDM2_Channel2_BASE)
S#define DFSDM2_Channel3     ((DFSDM_Channel_TypeDef *) DFSDM2_Channel3_BASE)
S#define DFSDM2_Channel4     ((DFSDM_Channel_TypeDef *) DFSDM2_Channel4_BASE)
S#define DFSDM2_Channel5     ((DFSDM_Channel_TypeDef *) DFSDM2_Channel5_BASE)
S#define DFSDM2_Channel6     ((DFSDM_Channel_TypeDef *) DFSDM2_Channel6_BASE)
S#define DFSDM2_Channel7     ((DFSDM_Channel_TypeDef *) DFSDM2_Channel7_BASE)
S#define DFSDM2_Filter0      ((DFSDM_Filter_TypeDef *) DFSDM2_Filter0_BASE)
S#define DFSDM2_Filter1      ((DFSDM_Filter_TypeDef *) DFSDM2_Filter1_BASE)
S#define DFSDM2_Filter2      ((DFSDM_Filter_TypeDef *) DFSDM2_Filter2_BASE)
S#define DFSDM2_Filter3      ((DFSDM_Filter_TypeDef *) DFSDM2_Filter3_BASE)
S#endif /* STM32F413_423xx */
N#endif /* STM32F412xG || STM32F413_423xx */
N#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
N#define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
N#define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
N#define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)
N#define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)
N#define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)
N#define GPIOG               ((GPIO_TypeDef *) GPIOG_BASE)
N#define GPIOH               ((GPIO_TypeDef *) GPIOH_BASE)
N#define GPIOI               ((GPIO_TypeDef *) GPIOI_BASE)
N#define GPIOJ               ((GPIO_TypeDef *) GPIOJ_BASE)
N#define GPIOK               ((GPIO_TypeDef *) GPIOK_BASE)
N#define CRC                 ((CRC_TypeDef *) CRC_BASE)
N#define RCC                 ((RCC_TypeDef *) RCC_BASE)
N#define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)
N#define DMA1                ((DMA_TypeDef *) DMA1_BASE)
N#define DMA1_Stream0        ((DMA_Stream_TypeDef *) DMA1_Stream0_BASE)
N#define DMA1_Stream1        ((DMA_Stream_TypeDef *) DMA1_Stream1_BASE)
N#define DMA1_Stream2        ((DMA_Stream_TypeDef *) DMA1_Stream2_BASE)
N#define DMA1_Stream3        ((DMA_Stream_TypeDef *) DMA1_Stream3_BASE)
N#define DMA1_Stream4        ((DMA_Stream_TypeDef *) DMA1_Stream4_BASE)
N#define DMA1_Stream5        ((DMA_Stream_TypeDef *) DMA1_Stream5_BASE)
N#define DMA1_Stream6        ((DMA_Stream_TypeDef *) DMA1_Stream6_BASE)
N#define DMA1_Stream7        ((DMA_Stream_TypeDef *) DMA1_Stream7_BASE)
N#define DMA2                ((DMA_TypeDef *) DMA2_BASE)
N#define DMA2_Stream0        ((DMA_Stream_TypeDef *) DMA2_Stream0_BASE)
N#define DMA2_Stream1        ((DMA_Stream_TypeDef *) DMA2_Stream1_BASE)
N#define DMA2_Stream2        ((DMA_Stream_TypeDef *) DMA2_Stream2_BASE)
N#define DMA2_Stream3        ((DMA_Stream_TypeDef *) DMA2_Stream3_BASE)
N#define DMA2_Stream4        ((DMA_Stream_TypeDef *) DMA2_Stream4_BASE)
N#define DMA2_Stream5        ((DMA_Stream_TypeDef *) DMA2_Stream5_BASE)
N#define DMA2_Stream6        ((DMA_Stream_TypeDef *) DMA2_Stream6_BASE)
N#define DMA2_Stream7        ((DMA_Stream_TypeDef *) DMA2_Stream7_BASE)
N#define ETH                 ((ETH_TypeDef *) ETH_BASE)  
N#define DMA2D               ((DMA2D_TypeDef *)DMA2D_BASE)
N#define DCMI                ((DCMI_TypeDef *) DCMI_BASE)
N#define CRYP                ((CRYP_TypeDef *) CRYP_BASE)
N#define HASH                ((HASH_TypeDef *) HASH_BASE)
N#define HASH_DIGEST         ((HASH_DIGEST_TypeDef *) HASH_DIGEST_BASE)
N#define RNG                 ((RNG_TypeDef *) RNG_BASE)
N
N#if defined(STM32F40_41xxx) || defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 1L || 0L || 0L
N#define FSMC_Bank1          ((FSMC_Bank1_TypeDef *) FSMC_Bank1_R_BASE)
N#define FSMC_Bank1E         ((FSMC_Bank1E_TypeDef *) FSMC_Bank1E_R_BASE)
N#define FSMC_Bank2          ((FSMC_Bank2_TypeDef *) FSMC_Bank2_R_BASE)
N#define FSMC_Bank3          ((FSMC_Bank3_TypeDef *) FSMC_Bank3_R_BASE)
N#define FSMC_Bank4          ((FSMC_Bank4_TypeDef *) FSMC_Bank4_R_BASE)
N#endif /* STM32F40_41xxx || STM32F412xG || STM32F413_423xx */
N
N#if defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
X#if 0L || 0L || 0L || 0L
S#define FMC_Bank1           ((FMC_Bank1_TypeDef *) FMC_Bank1_R_BASE)
S#define FMC_Bank1E          ((FMC_Bank1E_TypeDef *) FMC_Bank1E_R_BASE)
S#define FMC_Bank2           ((FMC_Bank2_TypeDef *) FMC_Bank2_R_BASE)
S#define FMC_Bank3           ((FMC_Bank3_TypeDef *) FMC_Bank3_R_BASE)
S#define FMC_Bank4           ((FMC_Bank4_TypeDef *) FMC_Bank4_R_BASE)
S#define FMC_Bank5_6         ((FMC_Bank5_6_TypeDef *) FMC_Bank5_6_R_BASE)
N#endif /* STM32F427_437xx ||  STM32F429_439xx || STM32F446xx || STM32F469_479xx */
N
N#define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)
N
N/**
N  * @}
N  */
N
N/** @addtogroup Exported_constants
N  * @{
N  */
N  
N  /** @addtogroup Peripheral_Registers_Bits_Definition
N  * @{
N  */
N    
N/******************************************************************************/
N/*                         Peripheral Registers_Bits_Definition               */
N/******************************************************************************/
N
N/******************************************************************************/
N/*                                                                            */
N/*                        Analog to Digital Converter                         */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for ADC_SR register  ********************/
N#define  ADC_SR_AWD                          ((uint8_t)0x01)               /*!<Analog watchdog flag               */
N#define  ADC_SR_EOC                          ((uint8_t)0x02)               /*!<End of conversion                  */
N#define  ADC_SR_JEOC                         ((uint8_t)0x04)               /*!<Injected channel end of conversion */
N#define  ADC_SR_JSTRT                        ((uint8_t)0x08)               /*!<Injected channel Start flag        */
N#define  ADC_SR_STRT                         ((uint8_t)0x10)               /*!<Regular channel Start flag         */
N#define  ADC_SR_OVR                          ((uint8_t)0x20)               /*!<Overrun flag                       */
N
N/*******************  Bit definition for ADC_CR1 register  ********************/
N#define  ADC_CR1_AWDCH                       ((uint32_t)0x0000001F)        /*!<AWDCH[4:0] bits (Analog watchdog channel select bits) */
N#define  ADC_CR1_AWDCH_0                     ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  ADC_CR1_AWDCH_1                     ((uint32_t)0x00000002)        /*!<Bit 1 */
N#define  ADC_CR1_AWDCH_2                     ((uint32_t)0x00000004)        /*!<Bit 2 */
N#define  ADC_CR1_AWDCH_3                     ((uint32_t)0x00000008)        /*!<Bit 3 */
N#define  ADC_CR1_AWDCH_4                     ((uint32_t)0x00000010)        /*!<Bit 4 */
N#define  ADC_CR1_EOCIE                       ((uint32_t)0x00000020)        /*!<Interrupt enable for EOC                              */
N#define  ADC_CR1_AWDIE                       ((uint32_t)0x00000040)        /*!<AAnalog Watchdog interrupt enable                     */
N#define  ADC_CR1_JEOCIE                      ((uint32_t)0x00000080)        /*!<Interrupt enable for injected channels                */
N#define  ADC_CR1_SCAN                        ((uint32_t)0x00000100)        /*!<Scan mode                                             */
N#define  ADC_CR1_AWDSGL                      ((uint32_t)0x00000200)        /*!<Enable the watchdog on a single channel in scan mode  */
N#define  ADC_CR1_JAUTO                       ((uint32_t)0x00000400)        /*!<Automatic injected group conversion                   */
N#define  ADC_CR1_DISCEN                      ((uint32_t)0x00000800)        /*!<Discontinuous mode on regular channels                */
N#define  ADC_CR1_JDISCEN                     ((uint32_t)0x00001000)        /*!<Discontinuous mode on injected channels               */
N#define  ADC_CR1_DISCNUM                     ((uint32_t)0x0000E000)        /*!<DISCNUM[2:0] bits (Discontinuous mode channel count)  */
N#define  ADC_CR1_DISCNUM_0                   ((uint32_t)0x00002000)        /*!<Bit 0 */
N#define  ADC_CR1_DISCNUM_1                   ((uint32_t)0x00004000)        /*!<Bit 1 */
N#define  ADC_CR1_DISCNUM_2                   ((uint32_t)0x00008000)        /*!<Bit 2 */
N#define  ADC_CR1_JAWDEN                      ((uint32_t)0x00400000)        /*!<Analog watchdog enable on injected channels           */
N#define  ADC_CR1_AWDEN                       ((uint32_t)0x00800000)        /*!<Analog watchdog enable on regular channels            */
N#define  ADC_CR1_RES                         ((uint32_t)0x03000000)        /*!<RES[2:0] bits (Resolution)                            */
N#define  ADC_CR1_RES_0                       ((uint32_t)0x01000000)        /*!<Bit 0 */
N#define  ADC_CR1_RES_1                       ((uint32_t)0x02000000)        /*!<Bit 1 */
N#define  ADC_CR1_OVRIE                       ((uint32_t)0x04000000)         /*!<overrun interrupt enable                              */
N  
N/*******************  Bit definition for ADC_CR2 register  ********************/
N#define  ADC_CR2_ADON                        ((uint32_t)0x00000001)        /*!<A/D Converter ON / OFF             */
N#define  ADC_CR2_CONT                        ((uint32_t)0x00000002)        /*!<Continuous Conversion              */
N#define  ADC_CR2_DMA                         ((uint32_t)0x00000100)        /*!<Direct Memory access mode          */
N#define  ADC_CR2_DDS                         ((uint32_t)0x00000200)        /*!<DMA disable selection (Single ADC) */
N#define  ADC_CR2_EOCS                        ((uint32_t)0x00000400)        /*!<End of conversion selection        */
N#define  ADC_CR2_ALIGN                       ((uint32_t)0x00000800)        /*!<Data Alignment                     */
N#define  ADC_CR2_JEXTSEL                     ((uint32_t)0x000F0000)        /*!<JEXTSEL[3:0] bits (External event select for injected group) */
N#define  ADC_CR2_JEXTSEL_0                   ((uint32_t)0x00010000)        /*!<Bit 0 */
N#define  ADC_CR2_JEXTSEL_1                   ((uint32_t)0x00020000)        /*!<Bit 1 */
N#define  ADC_CR2_JEXTSEL_2                   ((uint32_t)0x00040000)        /*!<Bit 2 */
N#define  ADC_CR2_JEXTSEL_3                   ((uint32_t)0x00080000)        /*!<Bit 3 */
N#define  ADC_CR2_JEXTEN                      ((uint32_t)0x00300000)        /*!<JEXTEN[1:0] bits (External Trigger Conversion mode for injected channelsp) */
N#define  ADC_CR2_JEXTEN_0                    ((uint32_t)0x00100000)        /*!<Bit 0 */
N#define  ADC_CR2_JEXTEN_1                    ((uint32_t)0x00200000)        /*!<Bit 1 */
N#define  ADC_CR2_JSWSTART                    ((uint32_t)0x00400000)        /*!<Start Conversion of injected channels */
N#define  ADC_CR2_EXTSEL                      ((uint32_t)0x0F000000)        /*!<EXTSEL[3:0] bits (External Event Select for regular group) */
N#define  ADC_CR2_EXTSEL_0                    ((uint32_t)0x01000000)        /*!<Bit 0 */
N#define  ADC_CR2_EXTSEL_1                    ((uint32_t)0x02000000)        /*!<Bit 1 */
N#define  ADC_CR2_EXTSEL_2                    ((uint32_t)0x04000000)        /*!<Bit 2 */
N#define  ADC_CR2_EXTSEL_3                    ((uint32_t)0x08000000)        /*!<Bit 3 */
N#define  ADC_CR2_EXTEN                       ((uint32_t)0x30000000)        /*!<EXTEN[1:0] bits (External Trigger Conversion mode for regular channelsp) */
N#define  ADC_CR2_EXTEN_0                     ((uint32_t)0x10000000)        /*!<Bit 0 */
N#define  ADC_CR2_EXTEN_1                     ((uint32_t)0x20000000)        /*!<Bit 1 */
N#define  ADC_CR2_SWSTART                     ((uint32_t)0x40000000)        /*!<Start Conversion of regular channels */
N
N/******************  Bit definition for ADC_SMPR1 register  *******************/
N#define  ADC_SMPR1_SMP10                     ((uint32_t)0x00000007)        /*!<SMP10[2:0] bits (Channel 10 Sample time selection) */
N#define  ADC_SMPR1_SMP10_0                   ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  ADC_SMPR1_SMP10_1                   ((uint32_t)0x00000002)        /*!<Bit 1 */
N#define  ADC_SMPR1_SMP10_2                   ((uint32_t)0x00000004)        /*!<Bit 2 */
N#define  ADC_SMPR1_SMP11                     ((uint32_t)0x00000038)        /*!<SMP11[2:0] bits (Channel 11 Sample time selection) */
N#define  ADC_SMPR1_SMP11_0                   ((uint32_t)0x00000008)        /*!<Bit 0 */
N#define  ADC_SMPR1_SMP11_1                   ((uint32_t)0x00000010)        /*!<Bit 1 */
N#define  ADC_SMPR1_SMP11_2                   ((uint32_t)0x00000020)        /*!<Bit 2 */
N#define  ADC_SMPR1_SMP12                     ((uint32_t)0x000001C0)        /*!<SMP12[2:0] bits (Channel 12 Sample time selection) */
N#define  ADC_SMPR1_SMP12_0                   ((uint32_t)0x00000040)        /*!<Bit 0 */
N#define  ADC_SMPR1_SMP12_1                   ((uint32_t)0x00000080)        /*!<Bit 1 */
N#define  ADC_SMPR1_SMP12_2                   ((uint32_t)0x00000100)        /*!<Bit 2 */
N#define  ADC_SMPR1_SMP13                     ((uint32_t)0x00000E00)        /*!<SMP13[2:0] bits (Channel 13 Sample time selection) */
N#define  ADC_SMPR1_SMP13_0                   ((uint32_t)0x00000200)        /*!<Bit 0 */
N#define  ADC_SMPR1_SMP13_1                   ((uint32_t)0x00000400)        /*!<Bit 1 */
N#define  ADC_SMPR1_SMP13_2                   ((uint32_t)0x00000800)        /*!<Bit 2 */
N#define  ADC_SMPR1_SMP14                     ((uint32_t)0x00007000)        /*!<SMP14[2:0] bits (Channel 14 Sample time selection) */
N#define  ADC_SMPR1_SMP14_0                   ((uint32_t)0x00001000)        /*!<Bit 0 */
N#define  ADC_SMPR1_SMP14_1                   ((uint32_t)0x00002000)        /*!<Bit 1 */
N#define  ADC_SMPR1_SMP14_2                   ((uint32_t)0x00004000)        /*!<Bit 2 */
N#define  ADC_SMPR1_SMP15                     ((uint32_t)0x00038000)        /*!<SMP15[2:0] bits (Channel 15 Sample time selection) */
N#define  ADC_SMPR1_SMP15_0                   ((uint32_t)0x00008000)        /*!<Bit 0 */
N#define  ADC_SMPR1_SMP15_1                   ((uint32_t)0x00010000)        /*!<Bit 1 */
N#define  ADC_SMPR1_SMP15_2                   ((uint32_t)0x00020000)        /*!<Bit 2 */
N#define  ADC_SMPR1_SMP16                     ((uint32_t)0x001C0000)        /*!<SMP16[2:0] bits (Channel 16 Sample time selection) */
N#define  ADC_SMPR1_SMP16_0                   ((uint32_t)0x00040000)        /*!<Bit 0 */
N#define  ADC_SMPR1_SMP16_1                   ((uint32_t)0x00080000)        /*!<Bit 1 */
N#define  ADC_SMPR1_SMP16_2                   ((uint32_t)0x00100000)        /*!<Bit 2 */
N#define  ADC_SMPR1_SMP17                     ((uint32_t)0x00E00000)        /*!<SMP17[2:0] bits (Channel 17 Sample time selection) */
N#define  ADC_SMPR1_SMP17_0                   ((uint32_t)0x00200000)        /*!<Bit 0 */
N#define  ADC_SMPR1_SMP17_1                   ((uint32_t)0x00400000)        /*!<Bit 1 */
N#define  ADC_SMPR1_SMP17_2                   ((uint32_t)0x00800000)        /*!<Bit 2 */
N#define  ADC_SMPR1_SMP18                     ((uint32_t)0x07000000)        /*!<SMP18[2:0] bits (Channel 18 Sample time selection) */
N#define  ADC_SMPR1_SMP18_0                   ((uint32_t)0x01000000)        /*!<Bit 0 */
N#define  ADC_SMPR1_SMP18_1                   ((uint32_t)0x02000000)        /*!<Bit 1 */
N#define  ADC_SMPR1_SMP18_2                   ((uint32_t)0x04000000)        /*!<Bit 2 */
N
N/******************  Bit definition for ADC_SMPR2 register  *******************/
N#define  ADC_SMPR2_SMP0                      ((uint32_t)0x00000007)        /*!<SMP0[2:0] bits (Channel 0 Sample time selection) */
N#define  ADC_SMPR2_SMP0_0                    ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  ADC_SMPR2_SMP0_1                    ((uint32_t)0x00000002)        /*!<Bit 1 */
N#define  ADC_SMPR2_SMP0_2                    ((uint32_t)0x00000004)        /*!<Bit 2 */
N#define  ADC_SMPR2_SMP1                      ((uint32_t)0x00000038)        /*!<SMP1[2:0] bits (Channel 1 Sample time selection) */
N#define  ADC_SMPR2_SMP1_0                    ((uint32_t)0x00000008)        /*!<Bit 0 */
N#define  ADC_SMPR2_SMP1_1                    ((uint32_t)0x00000010)        /*!<Bit 1 */
N#define  ADC_SMPR2_SMP1_2                    ((uint32_t)0x00000020)        /*!<Bit 2 */
N#define  ADC_SMPR2_SMP2                      ((uint32_t)0x000001C0)        /*!<SMP2[2:0] bits (Channel 2 Sample time selection) */
N#define  ADC_SMPR2_SMP2_0                    ((uint32_t)0x00000040)        /*!<Bit 0 */
N#define  ADC_SMPR2_SMP2_1                    ((uint32_t)0x00000080)        /*!<Bit 1 */
N#define  ADC_SMPR2_SMP2_2                    ((uint32_t)0x00000100)        /*!<Bit 2 */
N#define  ADC_SMPR2_SMP3                      ((uint32_t)0x00000E00)        /*!<SMP3[2:0] bits (Channel 3 Sample time selection) */
N#define  ADC_SMPR2_SMP3_0                    ((uint32_t)0x00000200)        /*!<Bit 0 */
N#define  ADC_SMPR2_SMP3_1                    ((uint32_t)0x00000400)        /*!<Bit 1 */
N#define  ADC_SMPR2_SMP3_2                    ((uint32_t)0x00000800)        /*!<Bit 2 */
N#define  ADC_SMPR2_SMP4                      ((uint32_t)0x00007000)        /*!<SMP4[2:0] bits (Channel 4 Sample time selection) */
N#define  ADC_SMPR2_SMP4_0                    ((uint32_t)0x00001000)        /*!<Bit 0 */
N#define  ADC_SMPR2_SMP4_1                    ((uint32_t)0x00002000)        /*!<Bit 1 */
N#define  ADC_SMPR2_SMP4_2                    ((uint32_t)0x00004000)        /*!<Bit 2 */
N#define  ADC_SMPR2_SMP5                      ((uint32_t)0x00038000)        /*!<SMP5[2:0] bits (Channel 5 Sample time selection) */
N#define  ADC_SMPR2_SMP5_0                    ((uint32_t)0x00008000)        /*!<Bit 0 */
N#define  ADC_SMPR2_SMP5_1                    ((uint32_t)0x00010000)        /*!<Bit 1 */
N#define  ADC_SMPR2_SMP5_2                    ((uint32_t)0x00020000)        /*!<Bit 2 */
N#define  ADC_SMPR2_SMP6                      ((uint32_t)0x001C0000)        /*!<SMP6[2:0] bits (Channel 6 Sample time selection) */
N#define  ADC_SMPR2_SMP6_0                    ((uint32_t)0x00040000)        /*!<Bit 0 */
N#define  ADC_SMPR2_SMP6_1                    ((uint32_t)0x00080000)        /*!<Bit 1 */
N#define  ADC_SMPR2_SMP6_2                    ((uint32_t)0x00100000)        /*!<Bit 2 */
N#define  ADC_SMPR2_SMP7                      ((uint32_t)0x00E00000)        /*!<SMP7[2:0] bits (Channel 7 Sample time selection) */
N#define  ADC_SMPR2_SMP7_0                    ((uint32_t)0x00200000)        /*!<Bit 0 */
N#define  ADC_SMPR2_SMP7_1                    ((uint32_t)0x00400000)        /*!<Bit 1 */
N#define  ADC_SMPR2_SMP7_2                    ((uint32_t)0x00800000)        /*!<Bit 2 */
N#define  ADC_SMPR2_SMP8                      ((uint32_t)0x07000000)        /*!<SMP8[2:0] bits (Channel 8 Sample time selection) */
N#define  ADC_SMPR2_SMP8_0                    ((uint32_t)0x01000000)        /*!<Bit 0 */
N#define  ADC_SMPR2_SMP8_1                    ((uint32_t)0x02000000)        /*!<Bit 1 */
N#define  ADC_SMPR2_SMP8_2                    ((uint32_t)0x04000000)        /*!<Bit 2 */
N#define  ADC_SMPR2_SMP9                      ((uint32_t)0x38000000)        /*!<SMP9[2:0] bits (Channel 9 Sample time selection) */
N#define  ADC_SMPR2_SMP9_0                    ((uint32_t)0x08000000)        /*!<Bit 0 */
N#define  ADC_SMPR2_SMP9_1                    ((uint32_t)0x10000000)        /*!<Bit 1 */
N#define  ADC_SMPR2_SMP9_2                    ((uint32_t)0x20000000)        /*!<Bit 2 */
N
N/******************  Bit definition for ADC_JOFR1 register  *******************/
N#define  ADC_JOFR1_JOFFSET1                  ((uint16_t)0x0FFF)            /*!<Data offset for injected channel 1 */
N
N/******************  Bit definition for ADC_JOFR2 register  *******************/
N#define  ADC_JOFR2_JOFFSET2                  ((uint16_t)0x0FFF)            /*!<Data offset for injected channel 2 */
N
N/******************  Bit definition for ADC_JOFR3 register  *******************/
N#define  ADC_JOFR3_JOFFSET3                  ((uint16_t)0x0FFF)            /*!<Data offset for injected channel 3 */
N
N/******************  Bit definition for ADC_JOFR4 register  *******************/
N#define  ADC_JOFR4_JOFFSET4                  ((uint16_t)0x0FFF)            /*!<Data offset for injected channel 4 */
N
N/*******************  Bit definition for ADC_HTR register  ********************/
N#define  ADC_HTR_HT                          ((uint16_t)0x0FFF)            /*!<Analog watchdog high threshold */
N
N/*******************  Bit definition for ADC_LTR register  ********************/
N#define  ADC_LTR_LT                          ((uint16_t)0x0FFF)            /*!<Analog watchdog low threshold */
N
N/*******************  Bit definition for ADC_SQR1 register  *******************/
N#define  ADC_SQR1_SQ13                       ((uint32_t)0x0000001F)        /*!<SQ13[4:0] bits (13th conversion in regular sequence) */
N#define  ADC_SQR1_SQ13_0                     ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  ADC_SQR1_SQ13_1                     ((uint32_t)0x00000002)        /*!<Bit 1 */
N#define  ADC_SQR1_SQ13_2                     ((uint32_t)0x00000004)        /*!<Bit 2 */
N#define  ADC_SQR1_SQ13_3                     ((uint32_t)0x00000008)        /*!<Bit 3 */
N#define  ADC_SQR1_SQ13_4                     ((uint32_t)0x00000010)        /*!<Bit 4 */
N#define  ADC_SQR1_SQ14                       ((uint32_t)0x000003E0)        /*!<SQ14[4:0] bits (14th conversion in regular sequence) */
N#define  ADC_SQR1_SQ14_0                     ((uint32_t)0x00000020)        /*!<Bit 0 */
N#define  ADC_SQR1_SQ14_1                     ((uint32_t)0x00000040)        /*!<Bit 1 */
N#define  ADC_SQR1_SQ14_2                     ((uint32_t)0x00000080)        /*!<Bit 2 */
N#define  ADC_SQR1_SQ14_3                     ((uint32_t)0x00000100)        /*!<Bit 3 */
N#define  ADC_SQR1_SQ14_4                     ((uint32_t)0x00000200)        /*!<Bit 4 */
N#define  ADC_SQR1_SQ15                       ((uint32_t)0x00007C00)        /*!<SQ15[4:0] bits (15th conversion in regular sequence) */
N#define  ADC_SQR1_SQ15_0                     ((uint32_t)0x00000400)        /*!<Bit 0 */
N#define  ADC_SQR1_SQ15_1                     ((uint32_t)0x00000800)        /*!<Bit 1 */
N#define  ADC_SQR1_SQ15_2                     ((uint32_t)0x00001000)        /*!<Bit 2 */
N#define  ADC_SQR1_SQ15_3                     ((uint32_t)0x00002000)        /*!<Bit 3 */
N#define  ADC_SQR1_SQ15_4                     ((uint32_t)0x00004000)        /*!<Bit 4 */
N#define  ADC_SQR1_SQ16                       ((uint32_t)0x000F8000)        /*!<SQ16[4:0] bits (16th conversion in regular sequence) */
N#define  ADC_SQR1_SQ16_0                     ((uint32_t)0x00008000)        /*!<Bit 0 */
N#define  ADC_SQR1_SQ16_1                     ((uint32_t)0x00010000)        /*!<Bit 1 */
N#define  ADC_SQR1_SQ16_2                     ((uint32_t)0x00020000)        /*!<Bit 2 */
N#define  ADC_SQR1_SQ16_3                     ((uint32_t)0x00040000)        /*!<Bit 3 */
N#define  ADC_SQR1_SQ16_4                     ((uint32_t)0x00080000)        /*!<Bit 4 */
N#define  ADC_SQR1_L                          ((uint32_t)0x00F00000)        /*!<L[3:0] bits (Regular channel sequence length) */
N#define  ADC_SQR1_L_0                        ((uint32_t)0x00100000)        /*!<Bit 0 */
N#define  ADC_SQR1_L_1                        ((uint32_t)0x00200000)        /*!<Bit 1 */
N#define  ADC_SQR1_L_2                        ((uint32_t)0x00400000)        /*!<Bit 2 */
N#define  ADC_SQR1_L_3                        ((uint32_t)0x00800000)        /*!<Bit 3 */
N
N/*******************  Bit definition for ADC_SQR2 register  *******************/
N#define  ADC_SQR2_SQ7                        ((uint32_t)0x0000001F)        /*!<SQ7[4:0] bits (7th conversion in regular sequence) */
N#define  ADC_SQR2_SQ7_0                      ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  ADC_SQR2_SQ7_1                      ((uint32_t)0x00000002)        /*!<Bit 1 */
N#define  ADC_SQR2_SQ7_2                      ((uint32_t)0x00000004)        /*!<Bit 2 */
N#define  ADC_SQR2_SQ7_3                      ((uint32_t)0x00000008)        /*!<Bit 3 */
N#define  ADC_SQR2_SQ7_4                      ((uint32_t)0x00000010)        /*!<Bit 4 */
N#define  ADC_SQR2_SQ8                        ((uint32_t)0x000003E0)        /*!<SQ8[4:0] bits (8th conversion in regular sequence) */
N#define  ADC_SQR2_SQ8_0                      ((uint32_t)0x00000020)        /*!<Bit 0 */
N#define  ADC_SQR2_SQ8_1                      ((uint32_t)0x00000040)        /*!<Bit 1 */
N#define  ADC_SQR2_SQ8_2                      ((uint32_t)0x00000080)        /*!<Bit 2 */
N#define  ADC_SQR2_SQ8_3                      ((uint32_t)0x00000100)        /*!<Bit 3 */
N#define  ADC_SQR2_SQ8_4                      ((uint32_t)0x00000200)        /*!<Bit 4 */
N#define  ADC_SQR2_SQ9                        ((uint32_t)0x00007C00)        /*!<SQ9[4:0] bits (9th conversion in regular sequence) */
N#define  ADC_SQR2_SQ9_0                      ((uint32_t)0x00000400)        /*!<Bit 0 */
N#define  ADC_SQR2_SQ9_1                      ((uint32_t)0x00000800)        /*!<Bit 1 */
N#define  ADC_SQR2_SQ9_2                      ((uint32_t)0x00001000)        /*!<Bit 2 */
N#define  ADC_SQR2_SQ9_3                      ((uint32_t)0x00002000)        /*!<Bit 3 */
N#define  ADC_SQR2_SQ9_4                      ((uint32_t)0x00004000)        /*!<Bit 4 */
N#define  ADC_SQR2_SQ10                       ((uint32_t)0x000F8000)        /*!<SQ10[4:0] bits (10th conversion in regular sequence) */
N#define  ADC_SQR2_SQ10_0                     ((uint32_t)0x00008000)        /*!<Bit 0 */
N#define  ADC_SQR2_SQ10_1                     ((uint32_t)0x00010000)        /*!<Bit 1 */
N#define  ADC_SQR2_SQ10_2                     ((uint32_t)0x00020000)        /*!<Bit 2 */
N#define  ADC_SQR2_SQ10_3                     ((uint32_t)0x00040000)        /*!<Bit 3 */
N#define  ADC_SQR2_SQ10_4                     ((uint32_t)0x00080000)        /*!<Bit 4 */
N#define  ADC_SQR2_SQ11                       ((uint32_t)0x01F00000)        /*!<SQ11[4:0] bits (11th conversion in regular sequence) */
N#define  ADC_SQR2_SQ11_0                     ((uint32_t)0x00100000)        /*!<Bit 0 */
N#define  ADC_SQR2_SQ11_1                     ((uint32_t)0x00200000)        /*!<Bit 1 */
N#define  ADC_SQR2_SQ11_2                     ((uint32_t)0x00400000)        /*!<Bit 2 */
N#define  ADC_SQR2_SQ11_3                     ((uint32_t)0x00800000)        /*!<Bit 3 */
N#define  ADC_SQR2_SQ11_4                     ((uint32_t)0x01000000)        /*!<Bit 4 */
N#define  ADC_SQR2_SQ12                       ((uint32_t)0x3E000000)        /*!<SQ12[4:0] bits (12th conversion in regular sequence) */
N#define  ADC_SQR2_SQ12_0                     ((uint32_t)0x02000000)        /*!<Bit 0 */
N#define  ADC_SQR2_SQ12_1                     ((uint32_t)0x04000000)        /*!<Bit 1 */
N#define  ADC_SQR2_SQ12_2                     ((uint32_t)0x08000000)        /*!<Bit 2 */
N#define  ADC_SQR2_SQ12_3                     ((uint32_t)0x10000000)        /*!<Bit 3 */
N#define  ADC_SQR2_SQ12_4                     ((uint32_t)0x20000000)        /*!<Bit 4 */
N
N/*******************  Bit definition for ADC_SQR3 register  *******************/
N#define  ADC_SQR3_SQ1                        ((uint32_t)0x0000001F)        /*!<SQ1[4:0] bits (1st conversion in regular sequence) */
N#define  ADC_SQR3_SQ1_0                      ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  ADC_SQR3_SQ1_1                      ((uint32_t)0x00000002)        /*!<Bit 1 */
N#define  ADC_SQR3_SQ1_2                      ((uint32_t)0x00000004)        /*!<Bit 2 */
N#define  ADC_SQR3_SQ1_3                      ((uint32_t)0x00000008)        /*!<Bit 3 */
N#define  ADC_SQR3_SQ1_4                      ((uint32_t)0x00000010)        /*!<Bit 4 */
N#define  ADC_SQR3_SQ2                        ((uint32_t)0x000003E0)        /*!<SQ2[4:0] bits (2nd conversion in regular sequence) */
N#define  ADC_SQR3_SQ2_0                      ((uint32_t)0x00000020)        /*!<Bit 0 */
N#define  ADC_SQR3_SQ2_1                      ((uint32_t)0x00000040)        /*!<Bit 1 */
N#define  ADC_SQR3_SQ2_2                      ((uint32_t)0x00000080)        /*!<Bit 2 */
N#define  ADC_SQR3_SQ2_3                      ((uint32_t)0x00000100)        /*!<Bit 3 */
N#define  ADC_SQR3_SQ2_4                      ((uint32_t)0x00000200)        /*!<Bit 4 */
N#define  ADC_SQR3_SQ3                        ((uint32_t)0x00007C00)        /*!<SQ3[4:0] bits (3rd conversion in regular sequence) */
N#define  ADC_SQR3_SQ3_0                      ((uint32_t)0x00000400)        /*!<Bit 0 */
N#define  ADC_SQR3_SQ3_1                      ((uint32_t)0x00000800)        /*!<Bit 1 */
N#define  ADC_SQR3_SQ3_2                      ((uint32_t)0x00001000)        /*!<Bit 2 */
N#define  ADC_SQR3_SQ3_3                      ((uint32_t)0x00002000)        /*!<Bit 3 */
N#define  ADC_SQR3_SQ3_4                      ((uint32_t)0x00004000)        /*!<Bit 4 */
N#define  ADC_SQR3_SQ4                        ((uint32_t)0x000F8000)        /*!<SQ4[4:0] bits (4th conversion in regular sequence) */
N#define  ADC_SQR3_SQ4_0                      ((uint32_t)0x00008000)        /*!<Bit 0 */
N#define  ADC_SQR3_SQ4_1                      ((uint32_t)0x00010000)        /*!<Bit 1 */
N#define  ADC_SQR3_SQ4_2                      ((uint32_t)0x00020000)        /*!<Bit 2 */
N#define  ADC_SQR3_SQ4_3                      ((uint32_t)0x00040000)        /*!<Bit 3 */
N#define  ADC_SQR3_SQ4_4                      ((uint32_t)0x00080000)        /*!<Bit 4 */
N#define  ADC_SQR3_SQ5                        ((uint32_t)0x01F00000)        /*!<SQ5[4:0] bits (5th conversion in regular sequence) */
N#define  ADC_SQR3_SQ5_0                      ((uint32_t)0x00100000)        /*!<Bit 0 */
N#define  ADC_SQR3_SQ5_1                      ((uint32_t)0x00200000)        /*!<Bit 1 */
N#define  ADC_SQR3_SQ5_2                      ((uint32_t)0x00400000)        /*!<Bit 2 */
N#define  ADC_SQR3_SQ5_3                      ((uint32_t)0x00800000)        /*!<Bit 3 */
N#define  ADC_SQR3_SQ5_4                      ((uint32_t)0x01000000)        /*!<Bit 4 */
N#define  ADC_SQR3_SQ6                        ((uint32_t)0x3E000000)        /*!<SQ6[4:0] bits (6th conversion in regular sequence) */
N#define  ADC_SQR3_SQ6_0                      ((uint32_t)0x02000000)        /*!<Bit 0 */
N#define  ADC_SQR3_SQ6_1                      ((uint32_t)0x04000000)        /*!<Bit 1 */
N#define  ADC_SQR3_SQ6_2                      ((uint32_t)0x08000000)        /*!<Bit 2 */
N#define  ADC_SQR3_SQ6_3                      ((uint32_t)0x10000000)        /*!<Bit 3 */
N#define  ADC_SQR3_SQ6_4                      ((uint32_t)0x20000000)        /*!<Bit 4 */
N
N/*******************  Bit definition for ADC_JSQR register  *******************/
N#define  ADC_JSQR_JSQ1                       ((uint32_t)0x0000001F)        /*!<JSQ1[4:0] bits (1st conversion in injected sequence) */  
N#define  ADC_JSQR_JSQ1_0                     ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  ADC_JSQR_JSQ1_1                     ((uint32_t)0x00000002)        /*!<Bit 1 */
N#define  ADC_JSQR_JSQ1_2                     ((uint32_t)0x00000004)        /*!<Bit 2 */
N#define  ADC_JSQR_JSQ1_3                     ((uint32_t)0x00000008)        /*!<Bit 3 */
N#define  ADC_JSQR_JSQ1_4                     ((uint32_t)0x00000010)        /*!<Bit 4 */
N#define  ADC_JSQR_JSQ2                       ((uint32_t)0x000003E0)        /*!<JSQ2[4:0] bits (2nd conversion in injected sequence) */
N#define  ADC_JSQR_JSQ2_0                     ((uint32_t)0x00000020)        /*!<Bit 0 */
N#define  ADC_JSQR_JSQ2_1                     ((uint32_t)0x00000040)        /*!<Bit 1 */
N#define  ADC_JSQR_JSQ2_2                     ((uint32_t)0x00000080)        /*!<Bit 2 */
N#define  ADC_JSQR_JSQ2_3                     ((uint32_t)0x00000100)        /*!<Bit 3 */
N#define  ADC_JSQR_JSQ2_4                     ((uint32_t)0x00000200)        /*!<Bit 4 */
N#define  ADC_JSQR_JSQ3                       ((uint32_t)0x00007C00)        /*!<JSQ3[4:0] bits (3rd conversion in injected sequence) */
N#define  ADC_JSQR_JSQ3_0                     ((uint32_t)0x00000400)        /*!<Bit 0 */
N#define  ADC_JSQR_JSQ3_1                     ((uint32_t)0x00000800)        /*!<Bit 1 */
N#define  ADC_JSQR_JSQ3_2                     ((uint32_t)0x00001000)        /*!<Bit 2 */
N#define  ADC_JSQR_JSQ3_3                     ((uint32_t)0x00002000)        /*!<Bit 3 */
N#define  ADC_JSQR_JSQ3_4                     ((uint32_t)0x00004000)        /*!<Bit 4 */
N#define  ADC_JSQR_JSQ4                       ((uint32_t)0x000F8000)        /*!<JSQ4[4:0] bits (4th conversion in injected sequence) */
N#define  ADC_JSQR_JSQ4_0                     ((uint32_t)0x00008000)        /*!<Bit 0 */
N#define  ADC_JSQR_JSQ4_1                     ((uint32_t)0x00010000)        /*!<Bit 1 */
N#define  ADC_JSQR_JSQ4_2                     ((uint32_t)0x00020000)        /*!<Bit 2 */
N#define  ADC_JSQR_JSQ4_3                     ((uint32_t)0x00040000)        /*!<Bit 3 */
N#define  ADC_JSQR_JSQ4_4                     ((uint32_t)0x00080000)        /*!<Bit 4 */
N#define  ADC_JSQR_JL                         ((uint32_t)0x00300000)        /*!<JL[1:0] bits (Injected Sequence length) */
N#define  ADC_JSQR_JL_0                       ((uint32_t)0x00100000)        /*!<Bit 0 */
N#define  ADC_JSQR_JL_1                       ((uint32_t)0x00200000)        /*!<Bit 1 */
N
N/*******************  Bit definition for ADC_JDR1 register  *******************/
N#define  ADC_JDR1_JDATA                      ((uint16_t)0xFFFF)            /*!<Injected data */
N
N/*******************  Bit definition for ADC_JDR2 register  *******************/
N#define  ADC_JDR2_JDATA                      ((uint16_t)0xFFFF)            /*!<Injected data */
N
N/*******************  Bit definition for ADC_JDR3 register  *******************/
N#define  ADC_JDR3_JDATA                      ((uint16_t)0xFFFF)            /*!<Injected data */
N
N/*******************  Bit definition for ADC_JDR4 register  *******************/
N#define  ADC_JDR4_JDATA                      ((uint16_t)0xFFFF)            /*!<Injected data */
N
N/********************  Bit definition for ADC_DR register  ********************/
N#define  ADC_DR_DATA                         ((uint32_t)0x0000FFFF)        /*!<Regular data */
N#define  ADC_DR_ADC2DATA                     ((uint32_t)0xFFFF0000)        /*!<ADC2 data */
N
N/*******************  Bit definition for ADC_CSR register  ********************/
N#define  ADC_CSR_AWD1                        ((uint32_t)0x00000001)        /*!<ADC1 Analog watchdog flag */
N#define  ADC_CSR_EOC1                        ((uint32_t)0x00000002)        /*!<ADC1 End of conversion */
N#define  ADC_CSR_JEOC1                       ((uint32_t)0x00000004)        /*!<ADC1 Injected channel end of conversion */
N#define  ADC_CSR_JSTRT1                      ((uint32_t)0x00000008)        /*!<ADC1 Injected channel Start flag */
N#define  ADC_CSR_STRT1                       ((uint32_t)0x00000010)        /*!<ADC1 Regular channel Start flag */
N#define  ADC_CSR_OVR1                        ((uint32_t)0x00000020)        /*!<ADC1 DMA overrun  flag */
N#define  ADC_CSR_AWD2                        ((uint32_t)0x00000100)        /*!<ADC2 Analog watchdog flag */
N#define  ADC_CSR_EOC2                        ((uint32_t)0x00000200)        /*!<ADC2 End of conversion */
N#define  ADC_CSR_JEOC2                       ((uint32_t)0x00000400)        /*!<ADC2 Injected channel end of conversion */
N#define  ADC_CSR_JSTRT2                      ((uint32_t)0x00000800)        /*!<ADC2 Injected channel Start flag */
N#define  ADC_CSR_STRT2                       ((uint32_t)0x00001000)        /*!<ADC2 Regular channel Start flag */
N#define  ADC_CSR_OVR2                        ((uint32_t)0x00002000)        /*!<ADC2 DMA overrun  flag */
N#define  ADC_CSR_AWD3                        ((uint32_t)0x00010000)        /*!<ADC3 Analog watchdog flag */
N#define  ADC_CSR_EOC3                        ((uint32_t)0x00020000)        /*!<ADC3 End of conversion */
N#define  ADC_CSR_JEOC3                       ((uint32_t)0x00040000)        /*!<ADC3 Injected channel end of conversion */
N#define  ADC_CSR_JSTRT3                      ((uint32_t)0x00080000)        /*!<ADC3 Injected channel Start flag */
N#define  ADC_CSR_STRT3                       ((uint32_t)0x00100000)        /*!<ADC3 Regular channel Start flag */
N#define  ADC_CSR_OVR3                        ((uint32_t)0x00200000)        /*!<ADC3 DMA overrun  flag */
N
N/* Legacy defines */
N#define  ADC_CSR_DOVR1                        ADC_CSR_OVR1
N#define  ADC_CSR_DOVR2                        ADC_CSR_OVR2
N#define  ADC_CSR_DOVR3                        ADC_CSR_OVR3
N
N/*******************  Bit definition for ADC_CCR register  ********************/
N#define  ADC_CCR_MULTI                       ((uint32_t)0x0000001F)        /*!<MULTI[4:0] bits (Multi-ADC mode selection) */  
N#define  ADC_CCR_MULTI_0                     ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  ADC_CCR_MULTI_1                     ((uint32_t)0x00000002)        /*!<Bit 1 */
N#define  ADC_CCR_MULTI_2                     ((uint32_t)0x00000004)        /*!<Bit 2 */
N#define  ADC_CCR_MULTI_3                     ((uint32_t)0x00000008)        /*!<Bit 3 */
N#define  ADC_CCR_MULTI_4                     ((uint32_t)0x00000010)        /*!<Bit 4 */
N#define  ADC_CCR_DELAY                       ((uint32_t)0x00000F00)        /*!<DELAY[3:0] bits (Delay between 2 sampling phases) */  
N#define  ADC_CCR_DELAY_0                     ((uint32_t)0x00000100)        /*!<Bit 0 */
N#define  ADC_CCR_DELAY_1                     ((uint32_t)0x00000200)        /*!<Bit 1 */
N#define  ADC_CCR_DELAY_2                     ((uint32_t)0x00000400)        /*!<Bit 2 */
N#define  ADC_CCR_DELAY_3                     ((uint32_t)0x00000800)        /*!<Bit 3 */
N#define  ADC_CCR_DDS                         ((uint32_t)0x00002000)        /*!<DMA disable selection (Multi-ADC mode) */
N#define  ADC_CCR_DMA                         ((uint32_t)0x0000C000)        /*!<DMA[1:0] bits (Direct Memory Access mode for multimode) */  
N#define  ADC_CCR_DMA_0                       ((uint32_t)0x00004000)        /*!<Bit 0 */
N#define  ADC_CCR_DMA_1                       ((uint32_t)0x00008000)        /*!<Bit 1 */
N#define  ADC_CCR_ADCPRE                      ((uint32_t)0x00030000)        /*!<ADCPRE[1:0] bits (ADC prescaler) */  
N#define  ADC_CCR_ADCPRE_0                    ((uint32_t)0x00010000)        /*!<Bit 0 */
N#define  ADC_CCR_ADCPRE_1                    ((uint32_t)0x00020000)        /*!<Bit 1 */
N#define  ADC_CCR_VBATE                       ((uint32_t)0x00400000)        /*!<VBAT Enable */
N#define  ADC_CCR_TSVREFE                     ((uint32_t)0x00800000)        /*!<Temperature Sensor and VREFINT Enable */
N
N/*******************  Bit definition for ADC_CDR register  ********************/
N#define  ADC_CDR_DATA1                      ((uint32_t)0x0000FFFF)         /*!<1st data of a pair of regular conversions */
N#define  ADC_CDR_DATA2                      ((uint32_t)0xFFFF0000)         /*!<2nd data of a pair of regular conversions */
N
N/******************************************************************************/
N/*                                                                            */
N/*                         Controller Area Network                            */
N/*                                                                            */
N/******************************************************************************/
N/*!<CAN control and status registers */
N/*******************  Bit definition for CAN_MCR register  ********************/
N#define  CAN_MCR_INRQ                        ((uint16_t)0x0001)            /*!<Initialization Request */
N#define  CAN_MCR_SLEEP                       ((uint16_t)0x0002)            /*!<Sleep Mode Request */
N#define  CAN_MCR_TXFP                        ((uint16_t)0x0004)            /*!<Transmit FIFO Priority */
N#define  CAN_MCR_RFLM                        ((uint16_t)0x0008)            /*!<Receive FIFO Locked Mode */
N#define  CAN_MCR_NART                        ((uint16_t)0x0010)            /*!<No Automatic Retransmission */
N#define  CAN_MCR_AWUM                        ((uint16_t)0x0020)            /*!<Automatic Wakeup Mode */
N#define  CAN_MCR_ABOM                        ((uint16_t)0x0040)            /*!<Automatic Bus-Off Management */
N#define  CAN_MCR_TTCM                        ((uint16_t)0x0080)            /*!<Time Triggered Communication Mode */
N#define  CAN_MCR_RESET                       ((uint16_t)0x8000)            /*!<bxCAN software master reset */
N
N/*******************  Bit definition for CAN_MSR register  ********************/
N#define  CAN_MSR_INAK                        ((uint16_t)0x0001)            /*!<Initialization Acknowledge */
N#define  CAN_MSR_SLAK                        ((uint16_t)0x0002)            /*!<Sleep Acknowledge */
N#define  CAN_MSR_ERRI                        ((uint16_t)0x0004)            /*!<Error Interrupt */
N#define  CAN_MSR_WKUI                        ((uint16_t)0x0008)            /*!<Wakeup Interrupt */
N#define  CAN_MSR_SLAKI                       ((uint16_t)0x0010)            /*!<Sleep Acknowledge Interrupt */
N#define  CAN_MSR_TXM                         ((uint16_t)0x0100)            /*!<Transmit Mode */
N#define  CAN_MSR_RXM                         ((uint16_t)0x0200)            /*!<Receive Mode */
N#define  CAN_MSR_SAMP                        ((uint16_t)0x0400)            /*!<Last Sample Point */
N#define  CAN_MSR_RX                          ((uint16_t)0x0800)            /*!<CAN Rx Signal */
N
N/*******************  Bit definition for CAN_TSR register  ********************/
N#define  CAN_TSR_RQCP0                       ((uint32_t)0x00000001)        /*!<Request Completed Mailbox0 */
N#define  CAN_TSR_TXOK0                       ((uint32_t)0x00000002)        /*!<Transmission OK of Mailbox0 */
N#define  CAN_TSR_ALST0                       ((uint32_t)0x00000004)        /*!<Arbitration Lost for Mailbox0 */
N#define  CAN_TSR_TERR0                       ((uint32_t)0x00000008)        /*!<Transmission Error of Mailbox0 */
N#define  CAN_TSR_ABRQ0                       ((uint32_t)0x00000080)        /*!<Abort Request for Mailbox0 */
N#define  CAN_TSR_RQCP1                       ((uint32_t)0x00000100)        /*!<Request Completed Mailbox1 */
N#define  CAN_TSR_TXOK1                       ((uint32_t)0x00000200)        /*!<Transmission OK of Mailbox1 */
N#define  CAN_TSR_ALST1                       ((uint32_t)0x00000400)        /*!<Arbitration Lost for Mailbox1 */
N#define  CAN_TSR_TERR1                       ((uint32_t)0x00000800)        /*!<Transmission Error of Mailbox1 */
N#define  CAN_TSR_ABRQ1                       ((uint32_t)0x00008000)        /*!<Abort Request for Mailbox 1 */
N#define  CAN_TSR_RQCP2                       ((uint32_t)0x00010000)        /*!<Request Completed Mailbox2 */
N#define  CAN_TSR_TXOK2                       ((uint32_t)0x00020000)        /*!<Transmission OK of Mailbox 2 */
N#define  CAN_TSR_ALST2                       ((uint32_t)0x00040000)        /*!<Arbitration Lost for mailbox 2 */
N#define  CAN_TSR_TERR2                       ((uint32_t)0x00080000)        /*!<Transmission Error of Mailbox 2 */
N#define  CAN_TSR_ABRQ2                       ((uint32_t)0x00800000)        /*!<Abort Request for Mailbox 2 */
N#define  CAN_TSR_CODE                        ((uint32_t)0x03000000)        /*!<Mailbox Code */
N
N#define  CAN_TSR_TME                         ((uint32_t)0x1C000000)        /*!<TME[2:0] bits */
N#define  CAN_TSR_TME0                        ((uint32_t)0x04000000)        /*!<Transmit Mailbox 0 Empty */
N#define  CAN_TSR_TME1                        ((uint32_t)0x08000000)        /*!<Transmit Mailbox 1 Empty */
N#define  CAN_TSR_TME2                        ((uint32_t)0x10000000)        /*!<Transmit Mailbox 2 Empty */
N
N#define  CAN_TSR_LOW                         ((uint32_t)0xE0000000)        /*!<LOW[2:0] bits */
N#define  CAN_TSR_LOW0                        ((uint32_t)0x20000000)        /*!<Lowest Priority Flag for Mailbox 0 */
N#define  CAN_TSR_LOW1                        ((uint32_t)0x40000000)        /*!<Lowest Priority Flag for Mailbox 1 */
N#define  CAN_TSR_LOW2                        ((uint32_t)0x80000000)        /*!<Lowest Priority Flag for Mailbox 2 */
N
N/*******************  Bit definition for CAN_RF0R register  *******************/
N#define  CAN_RF0R_FMP0                       ((uint8_t)0x03)               /*!<FIFO 0 Message Pending */
N#define  CAN_RF0R_FULL0                      ((uint8_t)0x08)               /*!<FIFO 0 Full */
N#define  CAN_RF0R_FOVR0                      ((uint8_t)0x10)               /*!<FIFO 0 Overrun */
N#define  CAN_RF0R_RFOM0                      ((uint8_t)0x20)               /*!<Release FIFO 0 Output Mailbox */
N
N/*******************  Bit definition for CAN_RF1R register  *******************/
N#define  CAN_RF1R_FMP1                       ((uint8_t)0x03)               /*!<FIFO 1 Message Pending */
N#define  CAN_RF1R_FULL1                      ((uint8_t)0x08)               /*!<FIFO 1 Full */
N#define  CAN_RF1R_FOVR1                      ((uint8_t)0x10)               /*!<FIFO 1 Overrun */
N#define  CAN_RF1R_RFOM1                      ((uint8_t)0x20)               /*!<Release FIFO 1 Output Mailbox */
N
N/********************  Bit definition for CAN_IER register  *******************/
N#define  CAN_IER_TMEIE                       ((uint32_t)0x00000001)        /*!<Transmit Mailbox Empty Interrupt Enable */
N#define  CAN_IER_FMPIE0                      ((uint32_t)0x00000002)        /*!<FIFO Message Pending Interrupt Enable */
N#define  CAN_IER_FFIE0                       ((uint32_t)0x00000004)        /*!<FIFO Full Interrupt Enable */
N#define  CAN_IER_FOVIE0                      ((uint32_t)0x00000008)        /*!<FIFO Overrun Interrupt Enable */
N#define  CAN_IER_FMPIE1                      ((uint32_t)0x00000010)        /*!<FIFO Message Pending Interrupt Enable */
N#define  CAN_IER_FFIE1                       ((uint32_t)0x00000020)        /*!<FIFO Full Interrupt Enable */
N#define  CAN_IER_FOVIE1                      ((uint32_t)0x00000040)        /*!<FIFO Overrun Interrupt Enable */
N#define  CAN_IER_EWGIE                       ((uint32_t)0x00000100)        /*!<Error Warning Interrupt Enable */
N#define  CAN_IER_EPVIE                       ((uint32_t)0x00000200)        /*!<Error Passive Interrupt Enable */
N#define  CAN_IER_BOFIE                       ((uint32_t)0x00000400)        /*!<Bus-Off Interrupt Enable */
N#define  CAN_IER_LECIE                       ((uint32_t)0x00000800)        /*!<Last Error Code Interrupt Enable */
N#define  CAN_IER_ERRIE                       ((uint32_t)0x00008000)        /*!<Error Interrupt Enable */
N#define  CAN_IER_WKUIE                       ((uint32_t)0x00010000)        /*!<Wakeup Interrupt Enable */
N#define  CAN_IER_SLKIE                       ((uint32_t)0x00020000)        /*!<Sleep Interrupt Enable */
N
N/********************  Bit definition for CAN_ESR register  *******************/
N#define  CAN_ESR_EWGF                        ((uint32_t)0x00000001)        /*!<Error Warning Flag */
N#define  CAN_ESR_EPVF                        ((uint32_t)0x00000002)        /*!<Error Passive Flag */
N#define  CAN_ESR_BOFF                        ((uint32_t)0x00000004)        /*!<Bus-Off Flag */
N
N#define  CAN_ESR_LEC                         ((uint32_t)0x00000070)        /*!<LEC[2:0] bits (Last Error Code) */
N#define  CAN_ESR_LEC_0                       ((uint32_t)0x00000010)        /*!<Bit 0 */
N#define  CAN_ESR_LEC_1                       ((uint32_t)0x00000020)        /*!<Bit 1 */
N#define  CAN_ESR_LEC_2                       ((uint32_t)0x00000040)        /*!<Bit 2 */
N
N#define  CAN_ESR_TEC                         ((uint32_t)0x00FF0000)        /*!<Least significant byte of the 9-bit Transmit Error Counter */
N#define  CAN_ESR_REC                         ((uint32_t)0xFF000000)        /*!<Receive Error Counter */
N
N/*******************  Bit definition for CAN_BTR register  ********************/
N#define  CAN_BTR_BRP                         ((uint32_t)0x000003FF)        /*!<Baud Rate Prescaler */
N#define  CAN_BTR_TS1                         ((uint32_t)0x000F0000)        /*!<Time Segment 1 */
N#define  CAN_BTR_TS2                         ((uint32_t)0x00700000)        /*!<Time Segment 2 */
N#define  CAN_BTR_SJW                         ((uint32_t)0x03000000)        /*!<Resynchronization Jump Width */
N#define  CAN_BTR_LBKM                        ((uint32_t)0x40000000)        /*!<Loop Back Mode (Debug) */
N#define  CAN_BTR_SILM                        ((uint32_t)0x80000000)        /*!<Silent Mode */
N
N/*!<Mailbox registers */
N/******************  Bit definition for CAN_TI0R register  ********************/
N#define  CAN_TI0R_TXRQ                       ((uint32_t)0x00000001)        /*!<Transmit Mailbox Request */
N#define  CAN_TI0R_RTR                        ((uint32_t)0x00000002)        /*!<Remote Transmission Request */
N#define  CAN_TI0R_IDE                        ((uint32_t)0x00000004)        /*!<Identifier Extension */
N#define  CAN_TI0R_EXID                       ((uint32_t)0x001FFFF8)        /*!<Extended Identifier */
N#define  CAN_TI0R_STID                       ((uint32_t)0xFFE00000)        /*!<Standard Identifier or Extended Identifier */
N
N/******************  Bit definition for CAN_TDT0R register  *******************/
N#define  CAN_TDT0R_DLC                       ((uint32_t)0x0000000F)        /*!<Data Length Code */
N#define  CAN_TDT0R_TGT                       ((uint32_t)0x00000100)        /*!<Transmit Global Time */
N#define  CAN_TDT0R_TIME                      ((uint32_t)0xFFFF0000)        /*!<Message Time Stamp */
N
N/******************  Bit definition for CAN_TDL0R register  *******************/
N#define  CAN_TDL0R_DATA0                     ((uint32_t)0x000000FF)        /*!<Data byte 0 */
N#define  CAN_TDL0R_DATA1                     ((uint32_t)0x0000FF00)        /*!<Data byte 1 */
N#define  CAN_TDL0R_DATA2                     ((uint32_t)0x00FF0000)        /*!<Data byte 2 */
N#define  CAN_TDL0R_DATA3                     ((uint32_t)0xFF000000)        /*!<Data byte 3 */
N
N/******************  Bit definition for CAN_TDH0R register  *******************/
N#define  CAN_TDH0R_DATA4                     ((uint32_t)0x000000FF)        /*!<Data byte 4 */
N#define  CAN_TDH0R_DATA5                     ((uint32_t)0x0000FF00)        /*!<Data byte 5 */
N#define  CAN_TDH0R_DATA6                     ((uint32_t)0x00FF0000)        /*!<Data byte 6 */
N#define  CAN_TDH0R_DATA7                     ((uint32_t)0xFF000000)        /*!<Data byte 7 */
N
N/*******************  Bit definition for CAN_TI1R register  *******************/
N#define  CAN_TI1R_TXRQ                       ((uint32_t)0x00000001)        /*!<Transmit Mailbox Request */
N#define  CAN_TI1R_RTR                        ((uint32_t)0x00000002)        /*!<Remote Transmission Request */
N#define  CAN_TI1R_IDE                        ((uint32_t)0x00000004)        /*!<Identifier Extension */
N#define  CAN_TI1R_EXID                       ((uint32_t)0x001FFFF8)        /*!<Extended Identifier */
N#define  CAN_TI1R_STID                       ((uint32_t)0xFFE00000)        /*!<Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_TDT1R register  ******************/
N#define  CAN_TDT1R_DLC                       ((uint32_t)0x0000000F)        /*!<Data Length Code */
N#define  CAN_TDT1R_TGT                       ((uint32_t)0x00000100)        /*!<Transmit Global Time */
N#define  CAN_TDT1R_TIME                      ((uint32_t)0xFFFF0000)        /*!<Message Time Stamp */
N
N/*******************  Bit definition for CAN_TDL1R register  ******************/
N#define  CAN_TDL1R_DATA0                     ((uint32_t)0x000000FF)        /*!<Data byte 0 */
N#define  CAN_TDL1R_DATA1                     ((uint32_t)0x0000FF00)        /*!<Data byte 1 */
N#define  CAN_TDL1R_DATA2                     ((uint32_t)0x00FF0000)        /*!<Data byte 2 */
N#define  CAN_TDL1R_DATA3                     ((uint32_t)0xFF000000)        /*!<Data byte 3 */
N
N/*******************  Bit definition for CAN_TDH1R register  ******************/
N#define  CAN_TDH1R_DATA4                     ((uint32_t)0x000000FF)        /*!<Data byte 4 */
N#define  CAN_TDH1R_DATA5                     ((uint32_t)0x0000FF00)        /*!<Data byte 5 */
N#define  CAN_TDH1R_DATA6                     ((uint32_t)0x00FF0000)        /*!<Data byte 6 */
N#define  CAN_TDH1R_DATA7                     ((uint32_t)0xFF000000)        /*!<Data byte 7 */
N
N/*******************  Bit definition for CAN_TI2R register  *******************/
N#define  CAN_TI2R_TXRQ                       ((uint32_t)0x00000001)        /*!<Transmit Mailbox Request */
N#define  CAN_TI2R_RTR                        ((uint32_t)0x00000002)        /*!<Remote Transmission Request */
N#define  CAN_TI2R_IDE                        ((uint32_t)0x00000004)        /*!<Identifier Extension */
N#define  CAN_TI2R_EXID                       ((uint32_t)0x001FFFF8)        /*!<Extended identifier */
N#define  CAN_TI2R_STID                       ((uint32_t)0xFFE00000)        /*!<Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_TDT2R register  ******************/  
N#define  CAN_TDT2R_DLC                       ((uint32_t)0x0000000F)        /*!<Data Length Code */
N#define  CAN_TDT2R_TGT                       ((uint32_t)0x00000100)        /*!<Transmit Global Time */
N#define  CAN_TDT2R_TIME                      ((uint32_t)0xFFFF0000)        /*!<Message Time Stamp */
N
N/*******************  Bit definition for CAN_TDL2R register  ******************/
N#define  CAN_TDL2R_DATA0                     ((uint32_t)0x000000FF)        /*!<Data byte 0 */
N#define  CAN_TDL2R_DATA1                     ((uint32_t)0x0000FF00)        /*!<Data byte 1 */
N#define  CAN_TDL2R_DATA2                     ((uint32_t)0x00FF0000)        /*!<Data byte 2 */
N#define  CAN_TDL2R_DATA3                     ((uint32_t)0xFF000000)        /*!<Data byte 3 */
N
N/*******************  Bit definition for CAN_TDH2R register  ******************/
N#define  CAN_TDH2R_DATA4                     ((uint32_t)0x000000FF)        /*!<Data byte 4 */
N#define  CAN_TDH2R_DATA5                     ((uint32_t)0x0000FF00)        /*!<Data byte 5 */
N#define  CAN_TDH2R_DATA6                     ((uint32_t)0x00FF0000)        /*!<Data byte 6 */
N#define  CAN_TDH2R_DATA7                     ((uint32_t)0xFF000000)        /*!<Data byte 7 */
N
N/*******************  Bit definition for CAN_RI0R register  *******************/
N#define  CAN_RI0R_RTR                        ((uint32_t)0x00000002)        /*!<Remote Transmission Request */
N#define  CAN_RI0R_IDE                        ((uint32_t)0x00000004)        /*!<Identifier Extension */
N#define  CAN_RI0R_EXID                       ((uint32_t)0x001FFFF8)        /*!<Extended Identifier */
N#define  CAN_RI0R_STID                       ((uint32_t)0xFFE00000)        /*!<Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_RDT0R register  ******************/
N#define  CAN_RDT0R_DLC                       ((uint32_t)0x0000000F)        /*!<Data Length Code */
N#define  CAN_RDT0R_FMI                       ((uint32_t)0x0000FF00)        /*!<Filter Match Index */
N#define  CAN_RDT0R_TIME                      ((uint32_t)0xFFFF0000)        /*!<Message Time Stamp */
N
N/*******************  Bit definition for CAN_RDL0R register  ******************/
N#define  CAN_RDL0R_DATA0                     ((uint32_t)0x000000FF)        /*!<Data byte 0 */
N#define  CAN_RDL0R_DATA1                     ((uint32_t)0x0000FF00)        /*!<Data byte 1 */
N#define  CAN_RDL0R_DATA2                     ((uint32_t)0x00FF0000)        /*!<Data byte 2 */
N#define  CAN_RDL0R_DATA3                     ((uint32_t)0xFF000000)        /*!<Data byte 3 */
N
N/*******************  Bit definition for CAN_RDH0R register  ******************/
N#define  CAN_RDH0R_DATA4                     ((uint32_t)0x000000FF)        /*!<Data byte 4 */
N#define  CAN_RDH0R_DATA5                     ((uint32_t)0x0000FF00)        /*!<Data byte 5 */
N#define  CAN_RDH0R_DATA6                     ((uint32_t)0x00FF0000)        /*!<Data byte 6 */
N#define  CAN_RDH0R_DATA7                     ((uint32_t)0xFF000000)        /*!<Data byte 7 */
N
N/*******************  Bit definition for CAN_RI1R register  *******************/
N#define  CAN_RI1R_RTR                        ((uint32_t)0x00000002)        /*!<Remote Transmission Request */
N#define  CAN_RI1R_IDE                        ((uint32_t)0x00000004)        /*!<Identifier Extension */
N#define  CAN_RI1R_EXID                       ((uint32_t)0x001FFFF8)        /*!<Extended identifier */
N#define  CAN_RI1R_STID                       ((uint32_t)0xFFE00000)        /*!<Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_RDT1R register  ******************/
N#define  CAN_RDT1R_DLC                       ((uint32_t)0x0000000F)        /*!<Data Length Code */
N#define  CAN_RDT1R_FMI                       ((uint32_t)0x0000FF00)        /*!<Filter Match Index */
N#define  CAN_RDT1R_TIME                      ((uint32_t)0xFFFF0000)        /*!<Message Time Stamp */
N
N/*******************  Bit definition for CAN_RDL1R register  ******************/
N#define  CAN_RDL1R_DATA0                     ((uint32_t)0x000000FF)        /*!<Data byte 0 */
N#define  CAN_RDL1R_DATA1                     ((uint32_t)0x0000FF00)        /*!<Data byte 1 */
N#define  CAN_RDL1R_DATA2                     ((uint32_t)0x00FF0000)        /*!<Data byte 2 */
N#define  CAN_RDL1R_DATA3                     ((uint32_t)0xFF000000)        /*!<Data byte 3 */
N
N/*******************  Bit definition for CAN_RDH1R register  ******************/
N#define  CAN_RDH1R_DATA4                     ((uint32_t)0x000000FF)        /*!<Data byte 4 */
N#define  CAN_RDH1R_DATA5                     ((uint32_t)0x0000FF00)        /*!<Data byte 5 */
N#define  CAN_RDH1R_DATA6                     ((uint32_t)0x00FF0000)        /*!<Data byte 6 */
N#define  CAN_RDH1R_DATA7                     ((uint32_t)0xFF000000)        /*!<Data byte 7 */
N
N/*!<CAN filter registers */
N/*******************  Bit definition for CAN_FMR register  ********************/
N#define  CAN_FMR_FINIT                       ((uint8_t)0x01)               /*!<Filter Init Mode */
N
N/*******************  Bit definition for CAN_FM1R register  *******************/
N#define  CAN_FM1R_FBM                        ((uint16_t)0x3FFF)            /*!<Filter Mode */
N#define  CAN_FM1R_FBM0                       ((uint16_t)0x0001)            /*!<Filter Init Mode bit 0 */
N#define  CAN_FM1R_FBM1                       ((uint16_t)0x0002)            /*!<Filter Init Mode bit 1 */
N#define  CAN_FM1R_FBM2                       ((uint16_t)0x0004)            /*!<Filter Init Mode bit 2 */
N#define  CAN_FM1R_FBM3                       ((uint16_t)0x0008)            /*!<Filter Init Mode bit 3 */
N#define  CAN_FM1R_FBM4                       ((uint16_t)0x0010)            /*!<Filter Init Mode bit 4 */
N#define  CAN_FM1R_FBM5                       ((uint16_t)0x0020)            /*!<Filter Init Mode bit 5 */
N#define  CAN_FM1R_FBM6                       ((uint16_t)0x0040)            /*!<Filter Init Mode bit 6 */
N#define  CAN_FM1R_FBM7                       ((uint16_t)0x0080)            /*!<Filter Init Mode bit 7 */
N#define  CAN_FM1R_FBM8                       ((uint16_t)0x0100)            /*!<Filter Init Mode bit 8 */
N#define  CAN_FM1R_FBM9                       ((uint16_t)0x0200)            /*!<Filter Init Mode bit 9 */
N#define  CAN_FM1R_FBM10                      ((uint16_t)0x0400)            /*!<Filter Init Mode bit 10 */
N#define  CAN_FM1R_FBM11                      ((uint16_t)0x0800)            /*!<Filter Init Mode bit 11 */
N#define  CAN_FM1R_FBM12                      ((uint16_t)0x1000)            /*!<Filter Init Mode bit 12 */
N#define  CAN_FM1R_FBM13                      ((uint16_t)0x2000)            /*!<Filter Init Mode bit 13 */
N
N/*******************  Bit definition for CAN_FS1R register  *******************/
N#define  CAN_FS1R_FSC                        ((uint16_t)0x3FFF)            /*!<Filter Scale Configuration */
N#define  CAN_FS1R_FSC0                       ((uint16_t)0x0001)            /*!<Filter Scale Configuration bit 0 */
N#define  CAN_FS1R_FSC1                       ((uint16_t)0x0002)            /*!<Filter Scale Configuration bit 1 */
N#define  CAN_FS1R_FSC2                       ((uint16_t)0x0004)            /*!<Filter Scale Configuration bit 2 */
N#define  CAN_FS1R_FSC3                       ((uint16_t)0x0008)            /*!<Filter Scale Configuration bit 3 */
N#define  CAN_FS1R_FSC4                       ((uint16_t)0x0010)            /*!<Filter Scale Configuration bit 4 */
N#define  CAN_FS1R_FSC5                       ((uint16_t)0x0020)            /*!<Filter Scale Configuration bit 5 */
N#define  CAN_FS1R_FSC6                       ((uint16_t)0x0040)            /*!<Filter Scale Configuration bit 6 */
N#define  CAN_FS1R_FSC7                       ((uint16_t)0x0080)            /*!<Filter Scale Configuration bit 7 */
N#define  CAN_FS1R_FSC8                       ((uint16_t)0x0100)            /*!<Filter Scale Configuration bit 8 */
N#define  CAN_FS1R_FSC9                       ((uint16_t)0x0200)            /*!<Filter Scale Configuration bit 9 */
N#define  CAN_FS1R_FSC10                      ((uint16_t)0x0400)            /*!<Filter Scale Configuration bit 10 */
N#define  CAN_FS1R_FSC11                      ((uint16_t)0x0800)            /*!<Filter Scale Configuration bit 11 */
N#define  CAN_FS1R_FSC12                      ((uint16_t)0x1000)            /*!<Filter Scale Configuration bit 12 */
N#define  CAN_FS1R_FSC13                      ((uint16_t)0x2000)            /*!<Filter Scale Configuration bit 13 */
N
N/******************  Bit definition for CAN_FFA1R register  *******************/
N#define  CAN_FFA1R_FFA                       ((uint16_t)0x3FFF)            /*!<Filter FIFO Assignment */
N#define  CAN_FFA1R_FFA0                      ((uint16_t)0x0001)            /*!<Filter FIFO Assignment for Filter 0 */
N#define  CAN_FFA1R_FFA1                      ((uint16_t)0x0002)            /*!<Filter FIFO Assignment for Filter 1 */
N#define  CAN_FFA1R_FFA2                      ((uint16_t)0x0004)            /*!<Filter FIFO Assignment for Filter 2 */
N#define  CAN_FFA1R_FFA3                      ((uint16_t)0x0008)            /*!<Filter FIFO Assignment for Filter 3 */
N#define  CAN_FFA1R_FFA4                      ((uint16_t)0x0010)            /*!<Filter FIFO Assignment for Filter 4 */
N#define  CAN_FFA1R_FFA5                      ((uint16_t)0x0020)            /*!<Filter FIFO Assignment for Filter 5 */
N#define  CAN_FFA1R_FFA6                      ((uint16_t)0x0040)            /*!<Filter FIFO Assignment for Filter 6 */
N#define  CAN_FFA1R_FFA7                      ((uint16_t)0x0080)            /*!<Filter FIFO Assignment for Filter 7 */
N#define  CAN_FFA1R_FFA8                      ((uint16_t)0x0100)            /*!<Filter FIFO Assignment for Filter 8 */
N#define  CAN_FFA1R_FFA9                      ((uint16_t)0x0200)            /*!<Filter FIFO Assignment for Filter 9 */
N#define  CAN_FFA1R_FFA10                     ((uint16_t)0x0400)            /*!<Filter FIFO Assignment for Filter 10 */
N#define  CAN_FFA1R_FFA11                     ((uint16_t)0x0800)            /*!<Filter FIFO Assignment for Filter 11 */
N#define  CAN_FFA1R_FFA12                     ((uint16_t)0x1000)            /*!<Filter FIFO Assignment for Filter 12 */
N#define  CAN_FFA1R_FFA13                     ((uint16_t)0x2000)            /*!<Filter FIFO Assignment for Filter 13 */
N
N/*******************  Bit definition for CAN_FA1R register  *******************/
N#define  CAN_FA1R_FACT                       ((uint16_t)0x3FFF)            /*!<Filter Active */
N#define  CAN_FA1R_FACT0                      ((uint16_t)0x0001)            /*!<Filter 0 Active */
N#define  CAN_FA1R_FACT1                      ((uint16_t)0x0002)            /*!<Filter 1 Active */
N#define  CAN_FA1R_FACT2                      ((uint16_t)0x0004)            /*!<Filter 2 Active */
N#define  CAN_FA1R_FACT3                      ((uint16_t)0x0008)            /*!<Filter 3 Active */
N#define  CAN_FA1R_FACT4                      ((uint16_t)0x0010)            /*!<Filter 4 Active */
N#define  CAN_FA1R_FACT5                      ((uint16_t)0x0020)            /*!<Filter 5 Active */
N#define  CAN_FA1R_FACT6                      ((uint16_t)0x0040)            /*!<Filter 6 Active */
N#define  CAN_FA1R_FACT7                      ((uint16_t)0x0080)            /*!<Filter 7 Active */
N#define  CAN_FA1R_FACT8                      ((uint16_t)0x0100)            /*!<Filter 8 Active */
N#define  CAN_FA1R_FACT9                      ((uint16_t)0x0200)            /*!<Filter 9 Active */
N#define  CAN_FA1R_FACT10                     ((uint16_t)0x0400)            /*!<Filter 10 Active */
N#define  CAN_FA1R_FACT11                     ((uint16_t)0x0800)            /*!<Filter 11 Active */
N#define  CAN_FA1R_FACT12                     ((uint16_t)0x1000)            /*!<Filter 12 Active */
N#define  CAN_FA1R_FACT13                     ((uint16_t)0x2000)            /*!<Filter 13 Active */
N
N/*******************  Bit definition for CAN_F0R1 register  *******************/
N#define  CAN_F0R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F0R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F0R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F0R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F0R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F0R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F0R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F0R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F0R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F0R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F0R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F0R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F0R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F0R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F0R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F0R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F0R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F0R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F0R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F0R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F0R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F0R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F0R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F0R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F0R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F0R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F0R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F0R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F0R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F0R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F0R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F0R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F1R1 register  *******************/
N#define  CAN_F1R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F1R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F1R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F1R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F1R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F1R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F1R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F1R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F1R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F1R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F1R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F1R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F1R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F1R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F1R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F1R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F1R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F1R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F1R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F1R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F1R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F1R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F1R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F1R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F1R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F1R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F1R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F1R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F1R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F1R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F1R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F1R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F2R1 register  *******************/
N#define  CAN_F2R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F2R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F2R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F2R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F2R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F2R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F2R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F2R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F2R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F2R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F2R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F2R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F2R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F2R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F2R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F2R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F2R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F2R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F2R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F2R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F2R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F2R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F2R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F2R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F2R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F2R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F2R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F2R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F2R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F2R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F2R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F2R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F3R1 register  *******************/
N#define  CAN_F3R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F3R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F3R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F3R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F3R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F3R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F3R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F3R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F3R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F3R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F3R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F3R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F3R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F3R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F3R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F3R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F3R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F3R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F3R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F3R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F3R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F3R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F3R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F3R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F3R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F3R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F3R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F3R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F3R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F3R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F3R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F3R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F4R1 register  *******************/
N#define  CAN_F4R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F4R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F4R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F4R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F4R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F4R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F4R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F4R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F4R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F4R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F4R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F4R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F4R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F4R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F4R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F4R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F4R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F4R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F4R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F4R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F4R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F4R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F4R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F4R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F4R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F4R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F4R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F4R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F4R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F4R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F4R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F4R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F5R1 register  *******************/
N#define  CAN_F5R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F5R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F5R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F5R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F5R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F5R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F5R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F5R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F5R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F5R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F5R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F5R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F5R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F5R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F5R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F5R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F5R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F5R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F5R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F5R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F5R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F5R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F5R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F5R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F5R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F5R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F5R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F5R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F5R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F5R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F5R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F5R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F6R1 register  *******************/
N#define  CAN_F6R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F6R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F6R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F6R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F6R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F6R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F6R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F6R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F6R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F6R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F6R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F6R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F6R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F6R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F6R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F6R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F6R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F6R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F6R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F6R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F6R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F6R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F6R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F6R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F6R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F6R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F6R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F6R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F6R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F6R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F6R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F6R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F7R1 register  *******************/
N#define  CAN_F7R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F7R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F7R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F7R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F7R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F7R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F7R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F7R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F7R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F7R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F7R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F7R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F7R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F7R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F7R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F7R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F7R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F7R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F7R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F7R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F7R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F7R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F7R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F7R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F7R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F7R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F7R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F7R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F7R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F7R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F7R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F7R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F8R1 register  *******************/
N#define  CAN_F8R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F8R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F8R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F8R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F8R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F8R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F8R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F8R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F8R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F8R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F8R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F8R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F8R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F8R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F8R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F8R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F8R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F8R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F8R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F8R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F8R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F8R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F8R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F8R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F8R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F8R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F8R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F8R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F8R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F8R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F8R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F8R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F9R1 register  *******************/
N#define  CAN_F9R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F9R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F9R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F9R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F9R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F9R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F9R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F9R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F9R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F9R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F9R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F9R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F9R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F9R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F9R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F9R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F9R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F9R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F9R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F9R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F9R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F9R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F9R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F9R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F9R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F9R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F9R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F9R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F9R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F9R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F9R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F9R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F10R1 register  ******************/
N#define  CAN_F10R1_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F10R1_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F10R1_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F10R1_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F10R1_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F10R1_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F10R1_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F10R1_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F10R1_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F10R1_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F10R1_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F10R1_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F10R1_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F10R1_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F10R1_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F10R1_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F10R1_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F10R1_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F10R1_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F10R1_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F10R1_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F10R1_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F10R1_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F10R1_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F10R1_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F10R1_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F10R1_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F10R1_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F10R1_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F10R1_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F10R1_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F10R1_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F11R1 register  ******************/
N#define  CAN_F11R1_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F11R1_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F11R1_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F11R1_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F11R1_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F11R1_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F11R1_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F11R1_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F11R1_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F11R1_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F11R1_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F11R1_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F11R1_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F11R1_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F11R1_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F11R1_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F11R1_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F11R1_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F11R1_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F11R1_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F11R1_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F11R1_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F11R1_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F11R1_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F11R1_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F11R1_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F11R1_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F11R1_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F11R1_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F11R1_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F11R1_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F11R1_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F12R1 register  ******************/
N#define  CAN_F12R1_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F12R1_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F12R1_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F12R1_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F12R1_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F12R1_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F12R1_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F12R1_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F12R1_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F12R1_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F12R1_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F12R1_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F12R1_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F12R1_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F12R1_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F12R1_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F12R1_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F12R1_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F12R1_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F12R1_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F12R1_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F12R1_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F12R1_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F12R1_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F12R1_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F12R1_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F12R1_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F12R1_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F12R1_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F12R1_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F12R1_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F12R1_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F13R1 register  ******************/
N#define  CAN_F13R1_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F13R1_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F13R1_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F13R1_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F13R1_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F13R1_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F13R1_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F13R1_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F13R1_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F13R1_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F13R1_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F13R1_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F13R1_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F13R1_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F13R1_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F13R1_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F13R1_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F13R1_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F13R1_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F13R1_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F13R1_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F13R1_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F13R1_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F13R1_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F13R1_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F13R1_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F13R1_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F13R1_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F13R1_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F13R1_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F13R1_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F13R1_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F0R2 register  *******************/
N#define  CAN_F0R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F0R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F0R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F0R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F0R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F0R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F0R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F0R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F0R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F0R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F0R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F0R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F0R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F0R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F0R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F0R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F0R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F0R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F0R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F0R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F0R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F0R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F0R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F0R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F0R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F0R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F0R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F0R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F0R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F0R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F0R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F0R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F1R2 register  *******************/
N#define  CAN_F1R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F1R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F1R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F1R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F1R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F1R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F1R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F1R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F1R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F1R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F1R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F1R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F1R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F1R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F1R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F1R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F1R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F1R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F1R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F1R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F1R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F1R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F1R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F1R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F1R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F1R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F1R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F1R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F1R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F1R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F1R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F1R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F2R2 register  *******************/
N#define  CAN_F2R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F2R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F2R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F2R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F2R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F2R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F2R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F2R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F2R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F2R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F2R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F2R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F2R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F2R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F2R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F2R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F2R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F2R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F2R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F2R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F2R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F2R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F2R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F2R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F2R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F2R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F2R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F2R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F2R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F2R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F2R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F2R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F3R2 register  *******************/
N#define  CAN_F3R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F3R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F3R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F3R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F3R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F3R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F3R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F3R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F3R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F3R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F3R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F3R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F3R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F3R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F3R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F3R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F3R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F3R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F3R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F3R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F3R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F3R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F3R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F3R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F3R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F3R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F3R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F3R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F3R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F3R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F3R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F3R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F4R2 register  *******************/
N#define  CAN_F4R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F4R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F4R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F4R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F4R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F4R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F4R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F4R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F4R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F4R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F4R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F4R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F4R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F4R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F4R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F4R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F4R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F4R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F4R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F4R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F4R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F4R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F4R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F4R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F4R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F4R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F4R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F4R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F4R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F4R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F4R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F4R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F5R2 register  *******************/
N#define  CAN_F5R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F5R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F5R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F5R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F5R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F5R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F5R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F5R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F5R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F5R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F5R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F5R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F5R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F5R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F5R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F5R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F5R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F5R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F5R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F5R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F5R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F5R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F5R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F5R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F5R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F5R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F5R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F5R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F5R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F5R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F5R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F5R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F6R2 register  *******************/
N#define  CAN_F6R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F6R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F6R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F6R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F6R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F6R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F6R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F6R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F6R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F6R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F6R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F6R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F6R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F6R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F6R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F6R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F6R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F6R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F6R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F6R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F6R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F6R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F6R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F6R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F6R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F6R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F6R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F6R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F6R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F6R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F6R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F6R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F7R2 register  *******************/
N#define  CAN_F7R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F7R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F7R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F7R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F7R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F7R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F7R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F7R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F7R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F7R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F7R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F7R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F7R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F7R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F7R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F7R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F7R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F7R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F7R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F7R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F7R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F7R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F7R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F7R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F7R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F7R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F7R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F7R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F7R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F7R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F7R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F7R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F8R2 register  *******************/
N#define  CAN_F8R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F8R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F8R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F8R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F8R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F8R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F8R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F8R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F8R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F8R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F8R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F8R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F8R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F8R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F8R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F8R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F8R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F8R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F8R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F8R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F8R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F8R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F8R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F8R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F8R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F8R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F8R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F8R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F8R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F8R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F8R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F8R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F9R2 register  *******************/
N#define  CAN_F9R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F9R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F9R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F9R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F9R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F9R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F9R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F9R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F9R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F9R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F9R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F9R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F9R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F9R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F9R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F9R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F9R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F9R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F9R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F9R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F9R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F9R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F9R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F9R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F9R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F9R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F9R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F9R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F9R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F9R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F9R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F9R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F10R2 register  ******************/
N#define  CAN_F10R2_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F10R2_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F10R2_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F10R2_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F10R2_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F10R2_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F10R2_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F10R2_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F10R2_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F10R2_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F10R2_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F10R2_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F10R2_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F10R2_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F10R2_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F10R2_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F10R2_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F10R2_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F10R2_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F10R2_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F10R2_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F10R2_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F10R2_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F10R2_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F10R2_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F10R2_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F10R2_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F10R2_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F10R2_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F10R2_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F10R2_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F10R2_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F11R2 register  ******************/
N#define  CAN_F11R2_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F11R2_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F11R2_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F11R2_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F11R2_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F11R2_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F11R2_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F11R2_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F11R2_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F11R2_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F11R2_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F11R2_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F11R2_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F11R2_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F11R2_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F11R2_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F11R2_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F11R2_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F11R2_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F11R2_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F11R2_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F11R2_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F11R2_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F11R2_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F11R2_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F11R2_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F11R2_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F11R2_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F11R2_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F11R2_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F11R2_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F11R2_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F12R2 register  ******************/
N#define  CAN_F12R2_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F12R2_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F12R2_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F12R2_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F12R2_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F12R2_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F12R2_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F12R2_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F12R2_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F12R2_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F12R2_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F12R2_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F12R2_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F12R2_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F12R2_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F12R2_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F12R2_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F12R2_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F12R2_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F12R2_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F12R2_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F12R2_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F12R2_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F12R2_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F12R2_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F12R2_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F12R2_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F12R2_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F12R2_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F12R2_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F12R2_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F12R2_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F13R2 register  ******************/
N#define  CAN_F13R2_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F13R2_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F13R2_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F13R2_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F13R2_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F13R2_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F13R2_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F13R2_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F13R2_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F13R2_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F13R2_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F13R2_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F13R2_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F13R2_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F13R2_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F13R2_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F13R2_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F13R2_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F13R2_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F13R2_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F13R2_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F13R2_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F13R2_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F13R2_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F13R2_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F13R2_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F13R2_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F13R2_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F13R2_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F13R2_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F13R2_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F13R2_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N#if defined(STM32F446xx)
X#if 0L
S/******************************************************************************/
S/*                                                                            */
S/*                          HDMI-CEC (CEC)                                    */
S/*                                                                            */
S/******************************************************************************/
S
S/*******************  Bit definition for CEC_CR register  *********************/
S#define  CEC_CR_CECEN                        ((uint32_t)0x00000001)       /*!< CEC Enable                              */
S#define  CEC_CR_TXSOM                        ((uint32_t)0x00000002)       /*!< CEC Tx Start Of Message                 */
S#define  CEC_CR_TXEOM                        ((uint32_t)0x00000004)       /*!< CEC Tx End Of Message                   */
S
S/*******************  Bit definition for CEC_CFGR register  *******************/
S#define  CEC_CFGR_SFT                        ((uint32_t)0x00000007)       /*!< CEC Signal Free Time                    */
S#define  CEC_CFGR_RXTOL                      ((uint32_t)0x00000008)       /*!< CEC Tolerance                           */
S#define  CEC_CFGR_BRESTP                     ((uint32_t)0x00000010)       /*!< CEC Rx Stop                             */
S#define  CEC_CFGR_BREGEN                     ((uint32_t)0x00000020)       /*!< CEC Bit Rising Error generation         */
S#define  CEC_CFGR_LREGEN                     ((uint32_t)0x00000040)       /*!< CEC Long Period Error generation        */
S#define  CEC_CFGR_SFTOPT                     ((uint32_t)0x00000100)       /*!< CEC Signal Free Time optional           */
S#define  CEC_CFGR_BRDNOGEN                   ((uint32_t)0x00000080)       /*!< CEC Broadcast No error generation       */
S#define  CEC_CFGR_OAR                        ((uint32_t)0x7FFF0000)       /*!< CEC Own Address                         */
S#define  CEC_CFGR_LSTN                       ((uint32_t)0x80000000)       /*!< CEC Listen mode                         */
S
S/*******************  Bit definition for CEC_TXDR register  *******************/
S#define  CEC_TXDR_TXD                        ((uint32_t)0x000000FF)       /*!< CEC Tx Data                              */
S
S/*******************  Bit definition for CEC_RXDR register  *******************/
S#define  CEC_TXDR_RXD                        ((uint32_t)0x000000FF)       /*!< CEC Rx Data                              */
S
S/*******************  Bit definition for CEC_ISR register  ********************/
S#define  CEC_ISR_RXBR                        ((uint32_t)0x00000001)       /*!< CEC Rx-Byte Received                      */
S#define  CEC_ISR_RXEND                       ((uint32_t)0x00000002)       /*!< CEC End Of Reception                      */
S#define  CEC_ISR_RXOVR                       ((uint32_t)0x00000004)       /*!< CEC Rx-Overrun                            */
S#define  CEC_ISR_BRE                         ((uint32_t)0x00000008)       /*!< CEC Rx Bit Rising Error                   */
S#define  CEC_ISR_SBPE                        ((uint32_t)0x00000010)       /*!< CEC Rx Short Bit period Error             */
S#define  CEC_ISR_LBPE                        ((uint32_t)0x00000020)       /*!< CEC Rx Long Bit period Error              */
S#define  CEC_ISR_RXACKE                      ((uint32_t)0x00000040)       /*!< CEC Rx Missing Acknowledge                */
S#define  CEC_ISR_ARBLST                      ((uint32_t)0x00000080)       /*!< CEC Arbitration Lost                      */
S#define  CEC_ISR_TXBR                        ((uint32_t)0x00000100)       /*!< CEC Tx Byte Request                       */
S#define  CEC_ISR_TXEND                       ((uint32_t)0x00000200)       /*!< CEC End of Transmission                   */
S#define  CEC_ISR_TXUDR                       ((uint32_t)0x00000400)       /*!< CEC Tx-Buffer Underrun                    */
S#define  CEC_ISR_TXERR                       ((uint32_t)0x00000800)       /*!< CEC Tx-Error                              */
S#define  CEC_ISR_TXACKE                      ((uint32_t)0x00001000)       /*!< CEC Tx Missing Acknowledge                */
S
S/*******************  Bit definition for CEC_IER register  ********************/
S#define  CEC_IER_RXBRIE                      ((uint32_t)0x00000001)       /*!< CEC Rx-Byte Received IT Enable            */
S#define  CEC_IER_RXENDIE                     ((uint32_t)0x00000002)       /*!< CEC End Of Reception IT Enable            */
S#define  CEC_IER_RXOVRIE                     ((uint32_t)0x00000004)       /*!< CEC Rx-Overrun IT Enable                  */
S#define  CEC_IER_BREIEIE                     ((uint32_t)0x00000008)       /*!< CEC Rx Bit Rising Error IT Enable         */
S#define  CEC_IER_SBPEIE                      ((uint32_t)0x00000010)       /*!< CEC Rx Short Bit period Error IT Enable   */
S#define  CEC_IER_LBPEIE                      ((uint32_t)0x00000020)       /*!< CEC Rx Long Bit period Error IT Enable    */
S#define  CEC_IER_RXACKEIE                    ((uint32_t)0x00000040)       /*!< CEC Rx Missing Acknowledge IT Enable      */
S#define  CEC_IER_ARBLSTIE                    ((uint32_t)0x00000080)       /*!< CEC Arbitration Lost IT Enable            */
S#define  CEC_IER_TXBRIE                      ((uint32_t)0x00000100)       /*!< CEC Tx Byte Request  IT Enable            */
S#define  CEC_IER_TXENDIE                     ((uint32_t)0x00000200)       /*!< CEC End of Transmission IT Enable         */
S#define  CEC_IER_TXUDRIE                     ((uint32_t)0x00000400)       /*!< CEC Tx-Buffer Underrun IT Enable          */
S#define  CEC_IER_TXERRIE                     ((uint32_t)0x00000800)       /*!< CEC Tx-Error IT Enable                    */
S#define  CEC_IER_TXACKEIE                    ((uint32_t)0x00001000)       /*!< CEC Tx Missing Acknowledge IT Enable      */
N#endif /* STM32F446xx */
N
N/******************************************************************************/
N/*                                                                            */
N/*                          CRC calculation unit                              */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for CRC_DR register  *********************/
N#define  CRC_DR_DR                           ((uint32_t)0xFFFFFFFF) /*!< Data register bits */
N
N
N/*******************  Bit definition for CRC_IDR register  ********************/
N#define  CRC_IDR_IDR                         ((uint8_t)0xFF)        /*!< General-purpose 8-bit data register bits */
N
N
N/********************  Bit definition for CRC_CR register  ********************/
N#define  CRC_CR_RESET                        ((uint8_t)0x01)        /*!< RESET bit */
N
N/******************************************************************************/
N/*                                                                            */
N/*                            Crypto Processor                                */
N/*                                                                            */
N/******************************************************************************/
N/******************* Bits definition for CRYP_CR register  ********************/
N#define CRYP_CR_ALGODIR                      ((uint32_t)0x00000004)
N
N#define CRYP_CR_ALGOMODE                     ((uint32_t)0x00080038)
N#define CRYP_CR_ALGOMODE_0                   ((uint32_t)0x00000008)
N#define CRYP_CR_ALGOMODE_1                   ((uint32_t)0x00000010)
N#define CRYP_CR_ALGOMODE_2                   ((uint32_t)0x00000020)
N#define CRYP_CR_ALGOMODE_TDES_ECB            ((uint32_t)0x00000000)
N#define CRYP_CR_ALGOMODE_TDES_CBC            ((uint32_t)0x00000008)
N#define CRYP_CR_ALGOMODE_DES_ECB             ((uint32_t)0x00000010)
N#define CRYP_CR_ALGOMODE_DES_CBC             ((uint32_t)0x00000018)
N#define CRYP_CR_ALGOMODE_AES_ECB             ((uint32_t)0x00000020)
N#define CRYP_CR_ALGOMODE_AES_CBC             ((uint32_t)0x00000028)
N#define CRYP_CR_ALGOMODE_AES_CTR             ((uint32_t)0x00000030)
N#define CRYP_CR_ALGOMODE_AES_KEY             ((uint32_t)0x00000038)
N
N#define CRYP_CR_DATATYPE                     ((uint32_t)0x000000C0)
N#define CRYP_CR_DATATYPE_0                   ((uint32_t)0x00000040)
N#define CRYP_CR_DATATYPE_1                   ((uint32_t)0x00000080)
N#define CRYP_CR_KEYSIZE                      ((uint32_t)0x00000300)
N#define CRYP_CR_KEYSIZE_0                    ((uint32_t)0x00000100)
N#define CRYP_CR_KEYSIZE_1                    ((uint32_t)0x00000200)
N#define CRYP_CR_FFLUSH                       ((uint32_t)0x00004000)
N#define CRYP_CR_CRYPEN                       ((uint32_t)0x00008000)
N
N#define CRYP_CR_GCM_CCMPH                    ((uint32_t)0x00030000)
N#define CRYP_CR_GCM_CCMPH_0                  ((uint32_t)0x00010000)
N#define CRYP_CR_GCM_CCMPH_1                  ((uint32_t)0x00020000)
N#define CRYP_CR_ALGOMODE_3                   ((uint32_t)0x00080000) 
N
N/****************** Bits definition for CRYP_SR register  *********************/
N#define CRYP_SR_IFEM                         ((uint32_t)0x00000001)
N#define CRYP_SR_IFNF                         ((uint32_t)0x00000002)
N#define CRYP_SR_OFNE                         ((uint32_t)0x00000004)
N#define CRYP_SR_OFFU                         ((uint32_t)0x00000008)
N#define CRYP_SR_BUSY                         ((uint32_t)0x00000010)
N/****************** Bits definition for CRYP_DMACR register  ******************/
N#define CRYP_DMACR_DIEN                      ((uint32_t)0x00000001)
N#define CRYP_DMACR_DOEN                      ((uint32_t)0x00000002)
N/*****************  Bits definition for CRYP_IMSCR register  ******************/
N#define CRYP_IMSCR_INIM                      ((uint32_t)0x00000001)
N#define CRYP_IMSCR_OUTIM                     ((uint32_t)0x00000002)
N/****************** Bits definition for CRYP_RISR register  *******************/
N#define CRYP_RISR_OUTRIS                     ((uint32_t)0x00000001)
N#define CRYP_RISR_INRIS                      ((uint32_t)0x00000002)
N/****************** Bits definition for CRYP_MISR register  *******************/
N#define CRYP_MISR_INMIS                      ((uint32_t)0x00000001)
N#define CRYP_MISR_OUTMIS                     ((uint32_t)0x00000002)
N
N/******************************************************************************/
N/*                                                                            */
N/*                      Digital to Analog Converter                           */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for DAC_CR register  ********************/
N#define  DAC_CR_EN1                          ((uint32_t)0x00000001)        /*!<DAC channel1 enable */
N#define  DAC_CR_BOFF1                        ((uint32_t)0x00000002)        /*!<DAC channel1 output buffer disable */
N#define  DAC_CR_TEN1                         ((uint32_t)0x00000004)        /*!<DAC channel1 Trigger enable */
N
N#define  DAC_CR_TSEL1                        ((uint32_t)0x00000038)        /*!<TSEL1[2:0] (DAC channel1 Trigger selection) */
N#define  DAC_CR_TSEL1_0                      ((uint32_t)0x00000008)        /*!<Bit 0 */
N#define  DAC_CR_TSEL1_1                      ((uint32_t)0x00000010)        /*!<Bit 1 */
N#define  DAC_CR_TSEL1_2                      ((uint32_t)0x00000020)        /*!<Bit 2 */
N
N#define  DAC_CR_WAVE1                        ((uint32_t)0x000000C0)        /*!<WAVE1[1:0] (DAC channel1 noise/triangle wave generation enable) */
N#define  DAC_CR_WAVE1_0                      ((uint32_t)0x00000040)        /*!<Bit 0 */
N#define  DAC_CR_WAVE1_1                      ((uint32_t)0x00000080)        /*!<Bit 1 */
N
N#define  DAC_CR_MAMP1                        ((uint32_t)0x00000F00)        /*!<MAMP1[3:0] (DAC channel1 Mask/Amplitude selector) */
N#define  DAC_CR_MAMP1_0                      ((uint32_t)0x00000100)        /*!<Bit 0 */
N#define  DAC_CR_MAMP1_1                      ((uint32_t)0x00000200)        /*!<Bit 1 */
N#define  DAC_CR_MAMP1_2                      ((uint32_t)0x00000400)        /*!<Bit 2 */
N#define  DAC_CR_MAMP1_3                      ((uint32_t)0x00000800)        /*!<Bit 3 */
N
N#define  DAC_CR_DMAEN1                       ((uint32_t)0x00001000)        /*!<DAC channel1 DMA enable */
N#define  DAC_CR_DMAUDRIE1                    ((uint32_t)0x00002000)        /*!<DAC channel1 DMA underrun interrupt enable*/
N#define  DAC_CR_EN2                          ((uint32_t)0x00010000)        /*!<DAC channel2 enable */
N#define  DAC_CR_BOFF2                        ((uint32_t)0x00020000)        /*!<DAC channel2 output buffer disable */
N#define  DAC_CR_TEN2                         ((uint32_t)0x00040000)        /*!<DAC channel2 Trigger enable */
N
N#define  DAC_CR_TSEL2                        ((uint32_t)0x00380000)        /*!<TSEL2[2:0] (DAC channel2 Trigger selection) */
N#define  DAC_CR_TSEL2_0                      ((uint32_t)0x00080000)        /*!<Bit 0 */
N#define  DAC_CR_TSEL2_1                      ((uint32_t)0x00100000)        /*!<Bit 1 */
N#define  DAC_CR_TSEL2_2                      ((uint32_t)0x00200000)        /*!<Bit 2 */
N
N#define  DAC_CR_WAVE2                        ((uint32_t)0x00C00000)        /*!<WAVE2[1:0] (DAC channel2 noise/triangle wave generation enable) */
N#define  DAC_CR_WAVE2_0                      ((uint32_t)0x00400000)        /*!<Bit 0 */
N#define  DAC_CR_WAVE2_1                      ((uint32_t)0x00800000)        /*!<Bit 1 */
N
N#define  DAC_CR_MAMP2                        ((uint32_t)0x0F000000)        /*!<MAMP2[3:0] (DAC channel2 Mask/Amplitude selector) */
N#define  DAC_CR_MAMP2_0                      ((uint32_t)0x01000000)        /*!<Bit 0 */
N#define  DAC_CR_MAMP2_1                      ((uint32_t)0x02000000)        /*!<Bit 1 */
N#define  DAC_CR_MAMP2_2                      ((uint32_t)0x04000000)        /*!<Bit 2 */
N#define  DAC_CR_MAMP2_3                      ((uint32_t)0x08000000)        /*!<Bit 3 */
N
N#define  DAC_CR_DMAEN2                       ((uint32_t)0x10000000)        /*!<DAC channel2 DMA enabled */
N#define  DAC_CR_DMAUDRIE2                    ((uint32_t)0x20000000U)        /*!<DAC channel2 DMA underrun interrupt enable*/
N
N/*****************  Bit definition for DAC_SWTRIGR register  ******************/
N#define  DAC_SWTRIGR_SWTRIG1                 ((uint8_t)0x01)               /*!<DAC channel1 software trigger */
N#define  DAC_SWTRIGR_SWTRIG2                 ((uint8_t)0x02)               /*!<DAC channel2 software trigger */
N
N/*****************  Bit definition for DAC_DHR12R1 register  ******************/
N#define  DAC_DHR12R1_DACC1DHR                ((uint16_t)0x0FFF)            /*!<DAC channel1 12-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12L1 register  ******************/
N#define  DAC_DHR12L1_DACC1DHR                ((uint16_t)0xFFF0)            /*!<DAC channel1 12-bit Left aligned data */
N
N/******************  Bit definition for DAC_DHR8R1 register  ******************/
N#define  DAC_DHR8R1_DACC1DHR                 ((uint8_t)0xFF)               /*!<DAC channel1 8-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12R2 register  ******************/
N#define  DAC_DHR12R2_DACC2DHR                ((uint16_t)0x0FFF)            /*!<DAC channel2 12-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12L2 register  ******************/
N#define  DAC_DHR12L2_DACC2DHR                ((uint16_t)0xFFF0)            /*!<DAC channel2 12-bit Left aligned data */
N
N/******************  Bit definition for DAC_DHR8R2 register  ******************/
N#define  DAC_DHR8R2_DACC2DHR                 ((uint8_t)0xFF)               /*!<DAC channel2 8-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12RD register  ******************/
N#define  DAC_DHR12RD_DACC1DHR                ((uint32_t)0x00000FFF)        /*!<DAC channel1 12-bit Right aligned data */
N#define  DAC_DHR12RD_DACC2DHR                ((uint32_t)0x0FFF0000)        /*!<DAC channel2 12-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12LD register  ******************/
N#define  DAC_DHR12LD_DACC1DHR                ((uint32_t)0x0000FFF0)        /*!<DAC channel1 12-bit Left aligned data */
N#define  DAC_DHR12LD_DACC2DHR                ((uint32_t)0xFFF00000)        /*!<DAC channel2 12-bit Left aligned data */
N
N/******************  Bit definition for DAC_DHR8RD register  ******************/
N#define  DAC_DHR8RD_DACC1DHR                 ((uint16_t)0x00FF)            /*!<DAC channel1 8-bit Right aligned data */
N#define  DAC_DHR8RD_DACC2DHR                 ((uint16_t)0xFF00)            /*!<DAC channel2 8-bit Right aligned data */
N
N/*******************  Bit definition for DAC_DOR1 register  *******************/
N#define  DAC_DOR1_DACC1DOR                   ((uint16_t)0x0FFF)            /*!<DAC channel1 data output */
N
N/*******************  Bit definition for DAC_DOR2 register  *******************/
N#define  DAC_DOR2_DACC2DOR                   ((uint16_t)0x0FFF)            /*!<DAC channel2 data output */
N
N/********************  Bit definition for DAC_SR register  ********************/
N#define  DAC_SR_DMAUDR1                      ((uint32_t)0x00002000)        /*!<DAC channel1 DMA underrun flag */
N#define  DAC_SR_DMAUDR2                      ((uint32_t)0x20000000)        /*!<DAC channel2 DMA underrun flag */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                 Debug MCU                                  */
N/*                                                                            */
N/******************************************************************************/
N
N/******************************************************************************/
N/*                                                                            */
N/*                                    DCMI                                    */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bits definition for DCMI_CR register  ******************/
N#define DCMI_CR_CAPTURE                      ((uint32_t)0x00000001)
N#define DCMI_CR_CM                           ((uint32_t)0x00000002)
N#define DCMI_CR_CROP                         ((uint32_t)0x00000004)
N#define DCMI_CR_JPEG                         ((uint32_t)0x00000008)
N#define DCMI_CR_ESS                          ((uint32_t)0x00000010)
N#define DCMI_CR_PCKPOL                       ((uint32_t)0x00000020)
N#define DCMI_CR_HSPOL                        ((uint32_t)0x00000040)
N#define DCMI_CR_VSPOL                        ((uint32_t)0x00000080)
N#define DCMI_CR_FCRC_0                       ((uint32_t)0x00000100)
N#define DCMI_CR_FCRC_1                       ((uint32_t)0x00000200)
N#define DCMI_CR_EDM_0                        ((uint32_t)0x00000400)
N#define DCMI_CR_EDM_1                        ((uint32_t)0x00000800)
N#define DCMI_CR_CRE                          ((uint32_t)0x00001000)
N#define DCMI_CR_ENABLE                       ((uint32_t)0x00004000)
N
N/********************  Bits definition for DCMI_SR register  ******************/
N#define DCMI_SR_HSYNC                        ((uint32_t)0x00000001)
N#define DCMI_SR_VSYNC                        ((uint32_t)0x00000002)
N#define DCMI_SR_FNE                          ((uint32_t)0x00000004)
N
N/********************  Bits definition for DCMI_RIS register  *****************/
N#define DCMI_RIS_FRAME_RIS                   ((uint32_t)0x00000001)
N#define DCMI_RIS_OVR_RIS                     ((uint32_t)0x00000002)
N#define DCMI_RIS_ERR_RIS                     ((uint32_t)0x00000004)
N#define DCMI_RIS_VSYNC_RIS                   ((uint32_t)0x00000008)
N#define DCMI_RIS_LINE_RIS                     ((uint32_t)0x00000010)
N/* Legacy defines */
N#define DCMI_RISR_FRAME_RIS                  DCMI_RIS_FRAME_RIS
N#define DCMI_RISR_OVR_RIS                    DCMI_RIS_OVR_RIS
N#define DCMI_RISR_ERR_RIS                    DCMI_RIS_ERR_RIS
N#define DCMI_RISR_VSYNC_RIS                  DCMI_RIS_VSYNC_RIS
N#define DCMI_RISR_LINE_RIS                   DCMI_RIS_LINE_RIS
N#define DCMI_RISR_OVF_RIS                    DCMI_RIS_OVR_RIS
N
N/********************  Bits definition for DCMI_IER register  *****************/
N#define DCMI_IER_FRAME_IE                    ((uint32_t)0x00000001)
N#define DCMI_IER_OVR_IE                      ((uint32_t)0x00000002)
N#define DCMI_IER_ERR_IE                      ((uint32_t)0x00000004)
N#define DCMI_IER_VSYNC_IE                    ((uint32_t)0x00000008)
N#define DCMI_IER_LINE_IE                     ((uint32_t)0x00000010)
N
N/* Legacy defines */
N#define DCMI_IER_OVF_IE                      DCMI_IER_OVR_IE
N
N/********************  Bits definition for DCMI_MIS register  ****************/
N#define DCMI_MIS_FRAME_MIS                   ((uint32_t)0x00000001)
N#define DCMI_MIS_OVR_MIS                     ((uint32_t)0x00000002)
N#define DCMI_MIS_ERR_MIS                     ((uint32_t)0x00000004)
N#define DCMI_MIS_VSYNC_MIS                   ((uint32_t)0x00000008)
N#define DCMI_MIS_LINE_MIS                    ((uint32_t)0x00000010)
N
N/* Legacy defines */
N#define DCMI_MISR_FRAME_MIS                  DCMI_MIS_FRAME_MIS
N#define DCMI_MISR_OVF_MIS                    DCMI_MIS_OVR_MIS
N#define DCMI_MISR_ERR_MIS                    DCMI_MIS_ERR_MIS
N#define DCMI_MISR_VSYNC_MIS                  DCMI_MIS_VSYNC_MIS
N#define DCMI_MISR_LINE_MIS                   DCMI_MIS_LINE_MIS
N
N/********************  Bits definition for DCMI_ICR register  *****************/
N#define DCMI_ICR_FRAME_ISC                   ((uint32_t)0x00000001)
N#define DCMI_ICR_OVR_ISC                     ((uint32_t)0x00000002)
N#define DCMI_ICR_ERR_ISC                     ((uint32_t)0x00000004)
N#define DCMI_ICR_VSYNC_ISC                   ((uint32_t)0x00000008)
N#define DCMI_ICR_LINE_ISC                    ((uint32_t)0x00000010)
N
N/* Legacy defines */
N#define DCMI_ICR_OVF_ISC                     DCMI_ICR_OVR_ISC
N
N/********************  Bits definition for DCMI_ESCR register  ******************/
N#define DCMI_ESCR_FSC                        ((uint32_t)0x000000FF)
N#define DCMI_ESCR_LSC                        ((uint32_t)0x0000FF00)
N#define DCMI_ESCR_LEC                        ((uint32_t)0x00FF0000)
N#define DCMI_ESCR_FEC                        ((uint32_t)0xFF000000)
N
N/********************  Bits definition for DCMI_ESUR register  ******************/
N#define DCMI_ESUR_FSU                        ((uint32_t)0x000000FF)
N#define DCMI_ESUR_LSU                        ((uint32_t)0x0000FF00)
N#define DCMI_ESUR_LEU                        ((uint32_t)0x00FF0000)
N#define DCMI_ESUR_FEU                        ((uint32_t)0xFF000000)
N
N/********************  Bits definition for DCMI_CWSTRT register  ******************/
N#define DCMI_CWSTRT_HOFFCNT                  ((uint32_t)0x00003FFF)
N#define DCMI_CWSTRT_VST                      ((uint32_t)0x1FFF0000)
N
N/********************  Bits definition for DCMI_CWSIZE register  ******************/
N#define DCMI_CWSIZE_CAPCNT                   ((uint32_t)0x00003FFF)
N#define DCMI_CWSIZE_VLINE                    ((uint32_t)0x3FFF0000)
N
N/********************  Bits definition for DCMI_DR register  ******************/
N#define DCMI_DR_BYTE0                        ((uint32_t)0x000000FF)
N#define DCMI_DR_BYTE1                        ((uint32_t)0x0000FF00)
N#define DCMI_DR_BYTE2                        ((uint32_t)0x00FF0000)
N#define DCMI_DR_BYTE3                        ((uint32_t)0xFF000000)
N
N/******************************************************************************/
N/*                                                                            */
N/*                 Digital Filter for Sigma Delta Modulators                  */
N/*                                                                            */
N/******************************************************************************/
N
N/****************   DFSDM channel configuration registers  ********************/
N
N/***************  Bit definition for DFSDM_CHCFGR1 register  ******************/
N#define  DFSDM_CHCFGR1_DFSDMEN                ((uint32_t)0x80000000)            /*!< Global enable for DFSDM interface */
N#define  DFSDM_CHCFGR1_CKOUTSRC               ((uint32_t)0x40000000)            /*!< Output serial clock source selection */
N#define  DFSDM_CHCFGR1_CKOUTDIV               ((uint32_t)0x00FF0000)            /*!< CKOUTDIV[7:0] output serial clock divider */
N#define  DFSDM_CHCFGR1_DATPACK                ((uint32_t)0x0000C000)            /*!< DATPACK[1:0] Data packing mode */
N#define  DFSDM_CHCFGR1_DATPACK_1              ((uint32_t)0x00008000)            /*!< Data packing mode, Bit 1 */
N#define  DFSDM_CHCFGR1_DATPACK_0              ((uint32_t)0x00004000)            /*!< Data packing mode, Bit 0 */
N#define  DFSDM_CHCFGR1_DATMPX                 ((uint32_t)0x00003000)            /*!< DATMPX[1:0] Input data multiplexer for channel y */
N#define  DFSDM_CHCFGR1_DATMPX_1               ((uint32_t)0x00002000)            /*!< Input data multiplexer for channel y, Bit 1 */
N#define  DFSDM_CHCFGR1_DATMPX_0               ((uint32_t)0x00001000)            /*!< Input data multiplexer for channel y, Bit 0 */
N#define  DFSDM_CHCFGR1_CHINSEL                ((uint32_t)0x00000100)            /*!< Serial inputs selection for channel y */
N#define  DFSDM_CHCFGR1_CHEN                   ((uint32_t)0x00000080)            /*!< Channel y enable */
N#define  DFSDM_CHCFGR1_CKABEN                 ((uint32_t)0x00000040)            /*!< Clock absence detector enable on channel y */
N#define  DFSDM_CHCFGR1_SCDEN                  ((uint32_t)0x00000020)            /*!< Short circuit detector enable on channel y */
N#define  DFSDM_CHCFGR1_SPICKSEL               ((uint32_t)0x0000000C)            /*!< SPICKSEL[1:0] SPI clock select for channel y */
N#define  DFSDM_CHCFGR1_SPICKSEL_1             ((uint32_t)0x00000008)            /*!< SPI clock select for channel y, Bit 1 */
N#define  DFSDM_CHCFGR1_SPICKSEL_0             ((uint32_t)0x00000004)            /*!< SPI clock select for channel y, Bit 0 */
N#define  DFSDM_CHCFGR1_SITP                   ((uint32_t)0x00000003)            /*!< SITP[1:0] Serial interface type for channel y */
N#define  DFSDM_CHCFGR1_SITP_1                 ((uint32_t)0x00000002)            /*!< Serial interface type for channel y, Bit 1 */
N#define  DFSDM_CHCFGR1_SITP_0                 ((uint32_t)0x00000001)            /*!< Serial interface type for channel y, Bit 0 */
N
N/***************  Bit definition for DFSDM_CHCFGR2 register  ******************/
N#define  DFSDM_CHCFGR2_OFFSET                 ((uint32_t)0xFFFFFF00)            /*!< OFFSET[23:0] 24-bit calibration offset for channel y */
N#define  DFSDM_CHCFGR2_DTRBS                  ((uint32_t)0x000000F8)            /*!< DTRBS[4:0] Data right bit-shift for channel y */
N
N/******************  Bit definition for DFSDM_CHAWSCDR register ***************/
N#define  DFSDM_CHAWSCDR_AWFORD                ((uint32_t)0x00C00000)            /*!< AWFORD[1:0] Analog watchdog Sinc filter order on channel y */
N#define  DFSDM_CHAWSCDR_AWFORD_1              ((uint32_t)0x00800000)            /*!< Analog watchdog Sinc filter order on channel y, Bit 1 */
N#define  DFSDM_CHAWSCDR_AWFORD_0              ((uint32_t)0x00400000)            /*!< Analog watchdog Sinc filter order on channel y, Bit 0 */
N#define  DFSDM_CHAWSCDR_AWFOSR                ((uint32_t)0x001F0000)            /*!< AWFOSR[4:0] Analog watchdog filter oversampling ratio on channel y */
N#define  DFSDM_CHAWSCDR_BKSCD                 ((uint32_t)0x0000F000)            /*!< BKSCD[3:0] Break signal assignment for short circuit detector on channel y */
N#define  DFSDM_CHAWSCDR_SCDT                  ((uint32_t)0x000000FF)            /*!< SCDT[7:0] Short circuit detector threshold for channel y */
N
N/****************  Bit definition for DFSDM_CHWDATR register *******************/
N#define  DFSDM_CHWDATR_WDATA                  ((uint32_t)0x0000FFFF)            /*!< WDATA[15:0] Input channel y watchdog data */
N
N/****************  Bit definition for DFSDM_CHDATINR register *****************/
N#define  DFSDM_CHDATINR_INDAT0                ((uint32_t)0x0000FFFF)            /*!< INDAT0[31:16] Input data for channel y or channel (y+1) */
N#define  DFSDM_CHDATINR_INDAT1                ((uint32_t)0xFFFF0000)            /*!< INDAT0[15:0] Input data for channel y */
N
N/************************   DFSDM module registers  ****************************/
N
N/*****************  Bit definition for DFSDM_FLTCR1 register *******************/
N#define  DFSDM_FLTCR1_AWFSEL                  ((uint32_t)0x40000000)            /*!< Analog watchdog fast mode select */
N#define  DFSDM_FLTCR1_FAST                    ((uint32_t)0x20000000)            /*!< Fast conversion mode selection */
N#define  DFSDM_FLTCR1_RCH                     ((uint32_t)0x07000000)            /*!< RCH[2:0] Regular channel selection */
N#define  DFSDM_FLTCR1_RDMAEN                  ((uint32_t)0x00200000)            /*!< DMA channel enabled to read data for the regular conversion */
N#define  DFSDM_FLTCR1_RSYNC                   ((uint32_t)0x00080000)            /*!< Launch regular conversion synchronously with DFSDMx */
N#define  DFSDM_FLTCR1_RCONT                   ((uint32_t)0x00040000)            /*!< Continuous mode selection for regular conversions */
N#define  DFSDM_FLTCR1_RSWSTART                ((uint32_t)0x00020000)            /*!< Software start of a conversion on the regular channel */
N#define  DFSDM_FLTCR1_JEXTEN                  ((uint32_t)0x00006000)            /*!< JEXTEN[1:0] Trigger enable and trigger edge selection for injected conversions */
N#define  DFSDM_FLTCR1_JEXTEN_1                ((uint32_t)0x00004000)            /*!< Trigger enable and trigger edge selection for injected conversions, Bit 1 */
N#define  DFSDM_FLTCR1_JEXTEN_0                ((uint32_t)0x00002000)            /*!< Trigger enable and trigger edge selection for injected conversions, Bit 0 */
N#define  DFSDM_FLTCR1_JEXTSEL                 ((uint32_t)0x00000700)            /*!< JEXTSEL[2:0]Trigger signal selection for launching injected conversions */
N#define  DFSDM_FLTCR1_JEXTSEL_2               ((uint32_t)0x00000400)            /*!< Trigger signal selection for launching injected conversions, Bit 2 */
N#define  DFSDM_FLTCR1_JEXTSEL_1               ((uint32_t)0x00000200)            /*!< Trigger signal selection for launching injected conversions, Bit 1 */
N#define  DFSDM_FLTCR1_JEXTSEL_0               ((uint32_t)0x00000100)            /*!< Trigger signal selection for launching injected conversions, Bit 0 */
N#define  DFSDM_FLTCR1_JDMAEN                  ((uint32_t)0x00000020)            /*!< DMA channel enabled to read data for the injected channel group */
N#define  DFSDM_FLTCR1_JSCAN                   ((uint32_t)0x00000010)            /*!< Scanning conversion in continuous mode selection for injected conversions */
N#define  DFSDM_FLTCR1_JSYNC                   ((uint32_t)0x00000008)            /*!< Launch an injected conversion synchronously with DFSDMx JSWSTART trigger  */
N#define  DFSDM_FLTCR1_JSWSTART                ((uint32_t)0x00000002)            /*!< Start the conversion of the injected group of channels */
N#define  DFSDM_FLTCR1_DFEN                    ((uint32_t)0x00000001)            /*!< DFSDM enable */
N
N/********************  Bit definition for DFSDM_FLTCR2 register ***************/
N#define  DFSDM_FLTCR2_AWDCH                   ((uint32_t)0x000F0000)            /*!< AWDCH[7:0] Analog watchdog channel selection */
N#define  DFSDM_FLTCR2_EXCH                    ((uint32_t)0x00000F00)            /*!< EXCH[7:0] Extreme detector channel selection */
N#define  DFSDM_FLTCR2_CKABIE                  ((uint32_t)0x00000040)            /*!< Clock absence interrupt enable */
N#define  DFSDM_FLTCR2_SCDIE                   ((uint32_t)0x00000020)            /*!< Short circuit detector interrupt enable */
N#define  DFSDM_FLTCR2_AWDIE                   ((uint32_t)0x00000010)            /*!< Analog watchdog interrupt enable */
N#define  DFSDM_FLTCR2_ROVRIE                  ((uint32_t)0x00000008)            /*!< Regular data overrun interrupt enable */
N#define  DFSDM_FLTCR2_JOVRIE                  ((uint32_t)0x00000004)            /*!< Injected data overrun interrupt enable */
N#define  DFSDM_FLTCR2_REOCIE                  ((uint32_t)0x00000002)            /*!< Regular end of conversion interrupt enable */
N#define  DFSDM_FLTCR2_JEOCIE                  ((uint32_t)0x00000001)            /*!< Injected end of conversion interrupt enable */
N
N/*****************  Bit definition for DFSDM_FLTISR register *******************/
N#define  DFSDM_FLTISR_SCDF                    ((uint32_t)0x0F000000)            /*!< SCDF[7:0] Short circuit detector flag */
N#define  DFSDM_FLTISR_CKABF                   ((uint32_t)0x000F0000)            /*!< CKABF[7:0] Clock absence flag */
N#define  DFSDM_FLTISR_RCIP                    ((uint32_t)0x00004000)            /*!< Regular conversion in progress status */
N#define  DFSDM_FLTISR_JCIP                    ((uint32_t)0x00002000)            /*!< Injected conversion in progress status */
N#define  DFSDM_FLTISR_AWDF                    ((uint32_t)0x00000010)            /*!< Analog watchdog */
N#define  DFSDM_FLTISR_ROVRF                   ((uint32_t)0x00000008)            /*!< Regular conversion overrun flag */
N#define  DFSDM_FLTISR_JOVRF                   ((uint32_t)0x00000004)            /*!< Injected conversion overrun flag */
N#define  DFSDM_FLTISR_REOCF                   ((uint32_t)0x00000002)            /*!< End of regular conversion flag */
N#define  DFSDM_FLTISR_JEOCF                   ((uint32_t)0x00000001)            /*!< End of injected conversion flag */
N
N/*****************  Bit definition for DFSDM_FLTICR register *******************/
N#define  DFSDM_FLTICR_CLRSCSDF                ((uint32_t)0x0F000000)            /*!< CLRSCSDF[7:0] Clear the short circuit detector flag */
N#define  DFSDM_FLTICR_CLRCKABF                ((uint32_t)0x000F0000)            /*!< CLRCKABF[7:0] Clear the clock absence flag */
N#define  DFSDM_FLTICR_CLRROVRF                ((uint32_t)0x00000008)            /*!< Clear the regular conversion overrun flag */
N#define  DFSDM_FLTICR_CLRJOVRF                ((uint32_t)0x00000004)            /*!< Clear the injected conversion overrun flag */
N
N/****************  Bit definition for DFSDM_FLTJCHGR register ******************/
N#define  DFSDM_FLTJCHGR_JCHG                  ((uint32_t)0x000000FF)            /*!< JCHG[7:0] Injected channel group selection */
N
N/*****************  Bit definition for DFSDM_FLTFCR register *******************/
N#define  DFSDM_FLTFCR_FORD                    ((uint32_t)0xE0000000)            /*!< FORD[2:0] Sinc filter order */
N#define  DFSDM_FLTFCR_FORD_2                  ((uint32_t)0x80000000)            /*!< Sinc filter order, Bit 2 */
N#define  DFSDM_FLTFCR_FORD_1                  ((uint32_t)0x40000000)            /*!< Sinc filter order, Bit 1 */
N#define  DFSDM_FLTFCR_FORD_0                  ((uint32_t)0x20000000)            /*!< Sinc filter order, Bit 0 */
N#define  DFSDM_FLTFCR_FOSR                    ((uint32_t)0x03FF0000)            /*!< FOSR[9:0] Sinc filter oversampling ratio (decimation rate) */
N#define  DFSDM_FLTFCR_IOSR                    ((uint32_t)0x000000FF)            /*!< IOSR[7:0] Integrator oversampling ratio (averaging length) */
N
N/***************  Bit definition for DFSDM_FLTJDATAR register *****************/
N#define  DFSDM_FLTJDATAR_JDATA                ((uint32_t)0xFFFFFF00)            /*!< JDATA[23:0] Injected group conversion data */
N#define  DFSDM_FLTJDATAR_JDATACH              ((uint32_t)0x00000007)            /*!< JDATACH[2:0] Injected channel most recently converted */
N
N/***************  Bit definition for DFSDM_FLTRDATAR register *****************/
N#define  DFSDM_FLTRDATAR_RDATA                ((uint32_t)0xFFFFFF00)            /*!< RDATA[23:0] Regular channel conversion data */
N#define  DFSDM_FLTRDATAR_RPEND                ((uint32_t)0x00000010)            /*!< RPEND Regular channel pending data */
N#define  DFSDM_FLTRDATAR_RDATACH              ((uint32_t)0x00000007)            /*!< RDATACH[2:0] Regular channel most recently converted */
N
N/***************  Bit definition for DFSDM_FLTAWHTR register ******************/
N#define  DFSDM_FLTAWHTR_AWHT                 ((uint32_t)0xFFFFFF00)             /*!< AWHT[23:0] Analog watchdog high threshold */
N#define  DFSDM_FLTAWHTR_BKAWH                ((uint32_t)0x0000000F)             /*!< BKAWH[3:0] Break signal assignment to analog watchdog high threshold event */
N
N/***************  Bit definition for DFSDM_FLTAWLTR register ******************/
N#define  DFSDM_FLTAWLTR_AWLT                 ((uint32_t)0xFFFFFF00)             /*!< AWLT[23:0] Analog watchdog low threshold */
N#define  DFSDM_FLTAWLTR_BKAWL                ((uint32_t)0x0000000F)             /*!< BKAWL[3:0] Break signal assignment to analog watchdog low threshold event */
N
N/***************  Bit definition for DFSDM_FLTAWSR register *******************/
N#define  DFSDM_FLTAWSR_AWHTF                 ((uint32_t)0x00000F00)             /*!< AWHTF[15:8] Analog watchdog high threshold error on given channels */
N#define  DFSDM_FLTAWSR_AWLTF                 ((uint32_t)0x0000000F)             /*!< AWLTF[7:0] Analog watchdog low threshold error on given channels */
N
N/***************  Bit definition for DFSDM_FLTAWCFR register ******************/
N#define  DFSDM_FLTAWCFR_CLRAWHTF             ((uint32_t)0x00000F00)             /*!< CLRAWHTF[15:8] Clear the Analog watchdog high threshold flag */
N#define  DFSDM_FLTAWCFR_CLRAWLTF             ((uint32_t)0x0000000F)             /*!< CLRAWLTF[7:0] Clear the Analog watchdog low threshold flag */
N
N/***************  Bit definition for DFSDM_FLTEXMAX register ******************/
N#define  DFSDM_FLTEXMAX_EXMAX                ((uint32_t)0xFFFFFF00)             /*!< EXMAX[23:0] Extreme detector maximum value */
N#define  DFSDM_FLTEXMAX_EXMAXCH              ((uint32_t)0x00000007)             /*!< EXMAXCH[2:0] Extreme detector maximum data channel */
N
N/***************  Bit definition for DFSDM_FLTEXMIN register ******************/
N#define  DFSDM_FLTEXMIN_EXMIN                ((uint32_t)0xFFFFFF00)             /*!< EXMIN[23:0] Extreme detector minimum value */
N#define  DFSDM_FLTEXMIN_EXMINCH              ((uint32_t)0x00000007)             /*!< EXMINCH[2:0] Extreme detector minimum data channel */
N
N/***************  Bit definition for DFSDM_FLTCNVTIMR register ****************/
N#define  DFSDM_FLTCNVTIMR_CNVCNT             ((uint32_t)0xFFFFFFF0)             /*!< CNVCNT[27:0]: 28-bit timer counting conversion time */
N
N/******************************************************************************/
N/*                                                                            */
N/*                             DMA Controller                                 */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bits definition for DMA_SxCR register  *****************/ 
N#define DMA_SxCR_CHSEL                       ((uint32_t)0x0E000000)
N#define DMA_SxCR_CHSEL_0                     ((uint32_t)0x02000000)
N#define DMA_SxCR_CHSEL_1                     ((uint32_t)0x04000000)
N#define DMA_SxCR_CHSEL_2                     ((uint32_t)0x08000000) 
N#define DMA_SxCR_MBURST                      ((uint32_t)0x01800000)
N#define DMA_SxCR_MBURST_0                    ((uint32_t)0x00800000)
N#define DMA_SxCR_MBURST_1                    ((uint32_t)0x01000000)
N#define DMA_SxCR_PBURST                      ((uint32_t)0x00600000)
N#define DMA_SxCR_PBURST_0                    ((uint32_t)0x00200000)
N#define DMA_SxCR_PBURST_1                    ((uint32_t)0x00400000)
N#define DMA_SxCR_ACK                         ((uint32_t)0x00100000)
N#define DMA_SxCR_CT                          ((uint32_t)0x00080000)  
N#define DMA_SxCR_DBM                         ((uint32_t)0x00040000)
N#define DMA_SxCR_PL                          ((uint32_t)0x00030000)
N#define DMA_SxCR_PL_0                        ((uint32_t)0x00010000)
N#define DMA_SxCR_PL_1                        ((uint32_t)0x00020000)
N#define DMA_SxCR_PINCOS                      ((uint32_t)0x00008000)
N#define DMA_SxCR_MSIZE                       ((uint32_t)0x00006000)
N#define DMA_SxCR_MSIZE_0                     ((uint32_t)0x00002000)
N#define DMA_SxCR_MSIZE_1                     ((uint32_t)0x00004000)
N#define DMA_SxCR_PSIZE                       ((uint32_t)0x00001800)
N#define DMA_SxCR_PSIZE_0                     ((uint32_t)0x00000800)
N#define DMA_SxCR_PSIZE_1                     ((uint32_t)0x00001000)
N#define DMA_SxCR_MINC                        ((uint32_t)0x00000400)
N#define DMA_SxCR_PINC                        ((uint32_t)0x00000200)
N#define DMA_SxCR_CIRC                        ((uint32_t)0x00000100)
N#define DMA_SxCR_DIR                         ((uint32_t)0x000000C0)
N#define DMA_SxCR_DIR_0                       ((uint32_t)0x00000040)
N#define DMA_SxCR_DIR_1                       ((uint32_t)0x00000080)
N#define DMA_SxCR_PFCTRL                      ((uint32_t)0x00000020)
N#define DMA_SxCR_TCIE                        ((uint32_t)0x00000010)
N#define DMA_SxCR_HTIE                        ((uint32_t)0x00000008)
N#define DMA_SxCR_TEIE                        ((uint32_t)0x00000004)
N#define DMA_SxCR_DMEIE                       ((uint32_t)0x00000002)
N#define DMA_SxCR_EN                          ((uint32_t)0x00000001)
N
N/********************  Bits definition for DMA_SxCNDTR register  **************/
N#define DMA_SxNDT                            ((uint32_t)0x0000FFFF)
N#define DMA_SxNDT_0                          ((uint32_t)0x00000001)
N#define DMA_SxNDT_1                          ((uint32_t)0x00000002)
N#define DMA_SxNDT_2                          ((uint32_t)0x00000004)
N#define DMA_SxNDT_3                          ((uint32_t)0x00000008)
N#define DMA_SxNDT_4                          ((uint32_t)0x00000010)
N#define DMA_SxNDT_5                          ((uint32_t)0x00000020)
N#define DMA_SxNDT_6                          ((uint32_t)0x00000040)
N#define DMA_SxNDT_7                          ((uint32_t)0x00000080)
N#define DMA_SxNDT_8                          ((uint32_t)0x00000100)
N#define DMA_SxNDT_9                          ((uint32_t)0x00000200)
N#define DMA_SxNDT_10                         ((uint32_t)0x00000400)
N#define DMA_SxNDT_11                         ((uint32_t)0x00000800)
N#define DMA_SxNDT_12                         ((uint32_t)0x00001000)
N#define DMA_SxNDT_13                         ((uint32_t)0x00002000)
N#define DMA_SxNDT_14                         ((uint32_t)0x00004000)
N#define DMA_SxNDT_15                         ((uint32_t)0x00008000)
N
N/********************  Bits definition for DMA_SxFCR register  ****************/ 
N#define DMA_SxFCR_FEIE                       ((uint32_t)0x00000080)
N#define DMA_SxFCR_FS                         ((uint32_t)0x00000038)
N#define DMA_SxFCR_FS_0                       ((uint32_t)0x00000008)
N#define DMA_SxFCR_FS_1                       ((uint32_t)0x00000010)
N#define DMA_SxFCR_FS_2                       ((uint32_t)0x00000020)
N#define DMA_SxFCR_DMDIS                      ((uint32_t)0x00000004)
N#define DMA_SxFCR_FTH                        ((uint32_t)0x00000003)
N#define DMA_SxFCR_FTH_0                      ((uint32_t)0x00000001)
N#define DMA_SxFCR_FTH_1                      ((uint32_t)0x00000002)
N
N/********************  Bits definition for DMA_LISR register  *****************/ 
N#define DMA_LISR_TCIF3                       ((uint32_t)0x08000000)
N#define DMA_LISR_HTIF3                       ((uint32_t)0x04000000)
N#define DMA_LISR_TEIF3                       ((uint32_t)0x02000000)
N#define DMA_LISR_DMEIF3                      ((uint32_t)0x01000000)
N#define DMA_LISR_FEIF3                       ((uint32_t)0x00400000)
N#define DMA_LISR_TCIF2                       ((uint32_t)0x00200000)
N#define DMA_LISR_HTIF2                       ((uint32_t)0x00100000)
N#define DMA_LISR_TEIF2                       ((uint32_t)0x00080000)
N#define DMA_LISR_DMEIF2                      ((uint32_t)0x00040000)
N#define DMA_LISR_FEIF2                       ((uint32_t)0x00010000)
N#define DMA_LISR_TCIF1                       ((uint32_t)0x00000800)
N#define DMA_LISR_HTIF1                       ((uint32_t)0x00000400)
N#define DMA_LISR_TEIF1                       ((uint32_t)0x00000200)
N#define DMA_LISR_DMEIF1                      ((uint32_t)0x00000100)
N#define DMA_LISR_FEIF1                       ((uint32_t)0x00000040)
N#define DMA_LISR_TCIF0                       ((uint32_t)0x00000020)
N#define DMA_LISR_HTIF0                       ((uint32_t)0x00000010)
N#define DMA_LISR_TEIF0                       ((uint32_t)0x00000008)
N#define DMA_LISR_DMEIF0                      ((uint32_t)0x00000004)
N#define DMA_LISR_FEIF0                       ((uint32_t)0x00000001)
N
N/********************  Bits definition for DMA_HISR register  *****************/ 
N#define DMA_HISR_TCIF7                       ((uint32_t)0x08000000)
N#define DMA_HISR_HTIF7                       ((uint32_t)0x04000000)
N#define DMA_HISR_TEIF7                       ((uint32_t)0x02000000)
N#define DMA_HISR_DMEIF7                      ((uint32_t)0x01000000)
N#define DMA_HISR_FEIF7                       ((uint32_t)0x00400000)
N#define DMA_HISR_TCIF6                       ((uint32_t)0x00200000)
N#define DMA_HISR_HTIF6                       ((uint32_t)0x00100000)
N#define DMA_HISR_TEIF6                       ((uint32_t)0x00080000)
N#define DMA_HISR_DMEIF6                      ((uint32_t)0x00040000)
N#define DMA_HISR_FEIF6                       ((uint32_t)0x00010000)
N#define DMA_HISR_TCIF5                       ((uint32_t)0x00000800)
N#define DMA_HISR_HTIF5                       ((uint32_t)0x00000400)
N#define DMA_HISR_TEIF5                       ((uint32_t)0x00000200)
N#define DMA_HISR_DMEIF5                      ((uint32_t)0x00000100)
N#define DMA_HISR_FEIF5                       ((uint32_t)0x00000040)
N#define DMA_HISR_TCIF4                       ((uint32_t)0x00000020)
N#define DMA_HISR_HTIF4                       ((uint32_t)0x00000010)
N#define DMA_HISR_TEIF4                       ((uint32_t)0x00000008)
N#define DMA_HISR_DMEIF4                      ((uint32_t)0x00000004)
N#define DMA_HISR_FEIF4                       ((uint32_t)0x00000001)
N
N/********************  Bits definition for DMA_LIFCR register  ****************/ 
N#define DMA_LIFCR_CTCIF3                     ((uint32_t)0x08000000)
N#define DMA_LIFCR_CHTIF3                     ((uint32_t)0x04000000)
N#define DMA_LIFCR_CTEIF3                     ((uint32_t)0x02000000)
N#define DMA_LIFCR_CDMEIF3                    ((uint32_t)0x01000000)
N#define DMA_LIFCR_CFEIF3                     ((uint32_t)0x00400000)
N#define DMA_LIFCR_CTCIF2                     ((uint32_t)0x00200000)
N#define DMA_LIFCR_CHTIF2                     ((uint32_t)0x00100000)
N#define DMA_LIFCR_CTEIF2                     ((uint32_t)0x00080000)
N#define DMA_LIFCR_CDMEIF2                    ((uint32_t)0x00040000)
N#define DMA_LIFCR_CFEIF2                     ((uint32_t)0x00010000)
N#define DMA_LIFCR_CTCIF1                     ((uint32_t)0x00000800)
N#define DMA_LIFCR_CHTIF1                     ((uint32_t)0x00000400)
N#define DMA_LIFCR_CTEIF1                     ((uint32_t)0x00000200)
N#define DMA_LIFCR_CDMEIF1                    ((uint32_t)0x00000100)
N#define DMA_LIFCR_CFEIF1                     ((uint32_t)0x00000040)
N#define DMA_LIFCR_CTCIF0                     ((uint32_t)0x00000020)
N#define DMA_LIFCR_CHTIF0                     ((uint32_t)0x00000010)
N#define DMA_LIFCR_CTEIF0                     ((uint32_t)0x00000008)
N#define DMA_LIFCR_CDMEIF0                    ((uint32_t)0x00000004)
N#define DMA_LIFCR_CFEIF0                     ((uint32_t)0x00000001)
N
N/********************  Bits definition for DMA_HIFCR  register  ****************/ 
N#define DMA_HIFCR_CTCIF7                     ((uint32_t)0x08000000)
N#define DMA_HIFCR_CHTIF7                     ((uint32_t)0x04000000)
N#define DMA_HIFCR_CTEIF7                     ((uint32_t)0x02000000)
N#define DMA_HIFCR_CDMEIF7                    ((uint32_t)0x01000000)
N#define DMA_HIFCR_CFEIF7                     ((uint32_t)0x00400000)
N#define DMA_HIFCR_CTCIF6                     ((uint32_t)0x00200000)
N#define DMA_HIFCR_CHTIF6                     ((uint32_t)0x00100000)
N#define DMA_HIFCR_CTEIF6                     ((uint32_t)0x00080000)
N#define DMA_HIFCR_CDMEIF6                    ((uint32_t)0x00040000)
N#define DMA_HIFCR_CFEIF6                     ((uint32_t)0x00010000)
N#define DMA_HIFCR_CTCIF5                     ((uint32_t)0x00000800)
N#define DMA_HIFCR_CHTIF5                     ((uint32_t)0x00000400)
N#define DMA_HIFCR_CTEIF5                     ((uint32_t)0x00000200)
N#define DMA_HIFCR_CDMEIF5                    ((uint32_t)0x00000100)
N#define DMA_HIFCR_CFEIF5                     ((uint32_t)0x00000040)
N#define DMA_HIFCR_CTCIF4                     ((uint32_t)0x00000020)
N#define DMA_HIFCR_CHTIF4                     ((uint32_t)0x00000010)
N#define DMA_HIFCR_CTEIF4                     ((uint32_t)0x00000008)
N#define DMA_HIFCR_CDMEIF4                    ((uint32_t)0x00000004)
N#define DMA_HIFCR_CFEIF4                     ((uint32_t)0x00000001)
N
N/******************************************************************************/
N/*                                                                            */
N/*                         AHB Master DMA2D Controller (DMA2D)                */
N/*                                                                            */
N/******************************************************************************/
N
N/********************  Bit definition for DMA2D_CR register  ******************/
N
N#define DMA2D_CR_START                     ((uint32_t)0x00000001)               /*!< Start transfer */
N#define DMA2D_CR_SUSP                      ((uint32_t)0x00000002)               /*!< Suspend transfer */
N#define DMA2D_CR_ABORT                     ((uint32_t)0x00000004)               /*!< Abort transfer */
N#define DMA2D_CR_TEIE                      ((uint32_t)0x00000100)               /*!< Transfer Error Interrupt Enable */
N#define DMA2D_CR_TCIE                      ((uint32_t)0x00000200)               /*!< Transfer Complete Interrupt Enable */
N#define DMA2D_CR_TWIE                      ((uint32_t)0x00000400)               /*!< Transfer Watermark Interrupt Enable */
N#define DMA2D_CR_CAEIE                     ((uint32_t)0x00000800)               /*!< CLUT Access Error Interrupt Enable */
N#define DMA2D_CR_CTCIE                     ((uint32_t)0x00001000)               /*!< CLUT Transfer Complete Interrupt Enable */
N#define DMA2D_CR_CEIE                      ((uint32_t)0x00002000)               /*!< Configuration Error Interrupt Enable */
N#define DMA2D_CR_MODE                      ((uint32_t)0x00030000)               /*!< DMA2D Mode */
N
N/********************  Bit definition for DMA2D_ISR register  *****************/
N
N#define DMA2D_ISR_TEIF                     ((uint32_t)0x00000001)               /*!< Transfer Error Interrupt Flag */
N#define DMA2D_ISR_TCIF                     ((uint32_t)0x00000002)               /*!< Transfer Complete Interrupt Flag */
N#define DMA2D_ISR_TWIF                     ((uint32_t)0x00000004)               /*!< Transfer Watermark Interrupt Flag */
N#define DMA2D_ISR_CAEIF                    ((uint32_t)0x00000008)               /*!< CLUT Access Error Interrupt Flag */
N#define DMA2D_ISR_CTCIF                    ((uint32_t)0x00000010)               /*!< CLUT Transfer Complete Interrupt Flag */
N#define DMA2D_ISR_CEIF                     ((uint32_t)0x00000020)               /*!< Configuration Error Interrupt Flag */
N
N/********************  Bit definition for DMA2D_IFCR register  ****************/
N
N#define DMA2D_IFCR_CTEIF                   ((uint32_t)0x00000001)               /*!< Clears Transfer Error Interrupt Flag         */
N#define DMA2D_IFCR_CTCIF                   ((uint32_t)0x00000002)               /*!< Clears Transfer Complete Interrupt Flag      */
N#define DMA2D_IFCR_CTWIF                   ((uint32_t)0x00000004)               /*!< Clears Transfer Watermark Interrupt Flag     */
N#define DMA2D_IFCR_CAECIF                  ((uint32_t)0x00000008)               /*!< Clears CLUT Access Error Interrupt Flag      */
N#define DMA2D_IFCR_CCTCIF                  ((uint32_t)0x00000010)               /*!< Clears CLUT Transfer Complete Interrupt Flag */
N#define DMA2D_IFCR_CCEIF                   ((uint32_t)0x00000020)               /*!< Clears Configuration Error Interrupt Flag    */
N
N/* Legacy defines */
N#define DMA2D_IFSR_CTEIF                   DMA2D_IFCR_CTEIF                     /*!< Clears Transfer Error Interrupt Flag         */
N#define DMA2D_IFSR_CTCIF                   DMA2D_IFCR_CTCIF                     /*!< Clears Transfer Complete Interrupt Flag      */
N#define DMA2D_IFSR_CTWIF                   DMA2D_IFCR_CTWIF                     /*!< Clears Transfer Watermark Interrupt Flag     */
N#define DMA2D_IFSR_CCAEIF                  DMA2D_IFCR_CAECIF                    /*!< Clears CLUT Access Error Interrupt Flag      */
N#define DMA2D_IFSR_CCTCIF                  DMA2D_IFCR_CCTCIF                    /*!< Clears CLUT Transfer Complete Interrupt Flag */
N#define DMA2D_IFSR_CCEIF                   DMA2D_IFCR_CCEIF                     /*!< Clears Configuration Error Interrupt Flag    */
N
N/********************  Bit definition for DMA2D_FGMAR register  ***************/
N
N#define DMA2D_FGMAR_MA                     ((uint32_t)0xFFFFFFFF)               /*!< Memory Address */
N
N/********************  Bit definition for DMA2D_FGOR register  ****************/
N
N#define DMA2D_FGOR_LO                      ((uint32_t)0x00003FFF)               /*!< Line Offset */
N
N/********************  Bit definition for DMA2D_BGMAR register  ***************/
N
N#define DMA2D_BGMAR_MA                     ((uint32_t)0xFFFFFFFF)               /*!< Memory Address */
N
N/********************  Bit definition for DMA2D_BGOR register  ****************/
N
N#define DMA2D_BGOR_LO                      ((uint32_t)0x00003FFF)               /*!< Line Offset */
N
N/********************  Bit definition for DMA2D_FGPFCCR register  *************/
N
N#define DMA2D_FGPFCCR_CM                   ((uint32_t)0x0000000F)               /*!< Input color mode CM[3:0] */
N#define DMA2D_FGPFCCR_CM_0                 ((uint32_t)0x00000001)               /*!< Input color mode CM bit 0 */
N#define DMA2D_FGPFCCR_CM_1                 ((uint32_t)0x00000002)               /*!< Input color mode CM bit 1 */
N#define DMA2D_FGPFCCR_CM_2                 ((uint32_t)0x00000004)               /*!< Input color mode CM bit 2 */
N#define DMA2D_FGPFCCR_CM_3                 ((uint32_t)0x00000008)               /*!< Input color mode CM bit 3 */
N#define DMA2D_FGPFCCR_CCM                  ((uint32_t)0x00000010)               /*!< CLUT Color mode */
N#define DMA2D_FGPFCCR_START                ((uint32_t)0x00000020)               /*!< Start */
N#define DMA2D_FGPFCCR_CS                   ((uint32_t)0x0000FF00)               /*!< CLUT size */
N#define DMA2D_FGPFCCR_AM                   ((uint32_t)0x00030000)               /*!< Alpha mode AM[1:0] */
N#define DMA2D_FGPFCCR_AM_0                 ((uint32_t)0x00010000)               /*!< Alpha mode AM bit 0 */
N#define DMA2D_FGPFCCR_AM_1                 ((uint32_t)0x00020000)               /*!< Alpha mode AM bit 1 */
N#define DMA2D_FGPFCCR_ALPHA                ((uint32_t)0xFF000000)               /*!< Alpha value */
N
N/********************  Bit definition for DMA2D_FGCOLR register  **************/
N
N#define DMA2D_FGCOLR_BLUE                  ((uint32_t)0x000000FF)               /*!< Blue Value */
N#define DMA2D_FGCOLR_GREEN                 ((uint32_t)0x0000FF00)               /*!< Green Value */
N#define DMA2D_FGCOLR_RED                   ((uint32_t)0x00FF0000)               /*!< Red Value */   
N
N/********************  Bit definition for DMA2D_BGPFCCR register  *************/
N
N#define DMA2D_BGPFCCR_CM                   ((uint32_t)0x0000000F)               /*!< Input color mode CM[3:0] */
N#define DMA2D_BGPFCCR_CM_0                 ((uint32_t)0x00000001)               /*!< Input color mode CM bit 0 */
N#define DMA2D_BGPFCCR_CM_1                 ((uint32_t)0x00000002)               /*!< Input color mode CM bit 1 */
N#define DMA2D_BGPFCCR_CM_2                 ((uint32_t)0x00000004)               /*!< Input color mode CM bit 2 */
N#define DMA2D_FGPFCCR_CM_3                 ((uint32_t)0x00000008)               /*!< Input color mode CM bit 3 */
N#define DMA2D_BGPFCCR_CCM                  ((uint32_t)0x00000010)               /*!< CLUT Color mode */
N#define DMA2D_BGPFCCR_START                ((uint32_t)0x00000020)               /*!< Start */
N#define DMA2D_BGPFCCR_CS                   ((uint32_t)0x0000FF00)               /*!< CLUT size */
N#define DMA2D_BGPFCCR_AM                   ((uint32_t)0x00030000)               /*!< Alpha mode AM[1:0] */
N#define DMA2D_BGPFCCR_AM_0                 ((uint32_t)0x00010000)               /*!< Alpha mode AM bit 0 */
N#define DMA2D_BGPFCCR_AM_1                 ((uint32_t)0x00020000)               /*!< Alpha mode AM bit 1 */
N#define DMA2D_BGPFCCR_ALPHA                ((uint32_t)0xFF000000)               /*!< Alpha value */
N
N/********************  Bit definition for DMA2D_BGCOLR register  **************/
N
N#define DMA2D_BGCOLR_BLUE                  ((uint32_t)0x000000FF)               /*!< Blue Value */
N#define DMA2D_BGCOLR_GREEN                 ((uint32_t)0x0000FF00)               /*!< Green Value */
N#define DMA2D_BGCOLR_RED                   ((uint32_t)0x00FF0000)               /*!< Red Value */
N
N/********************  Bit definition for DMA2D_FGCMAR register  **************/
N
N#define DMA2D_FGCMAR_MA                    ((uint32_t)0xFFFFFFFF)               /*!< Memory Address */
N
N/********************  Bit definition for DMA2D_BGCMAR register  **************/
N
N#define DMA2D_BGCMAR_MA                    ((uint32_t)0xFFFFFFFF)               /*!< Memory Address */
N
N/********************  Bit definition for DMA2D_OPFCCR register  **************/
N
N#define DMA2D_OPFCCR_CM                    ((uint32_t)0x00000007)               /*!< Color mode CM[2:0] */
N#define DMA2D_OPFCCR_CM_0                  ((uint32_t)0x00000001)               /*!< Color mode CM bit 0 */
N#define DMA2D_OPFCCR_CM_1                  ((uint32_t)0x00000002)               /*!< Color mode CM bit 1 */
N#define DMA2D_OPFCCR_CM_2                  ((uint32_t)0x00000004)               /*!< Color mode CM bit 2 */
N
N/********************  Bit definition for DMA2D_OCOLR register  ***************/
N
N/*!<Mode_ARGB8888/RGB888 */
N
N#define DMA2D_OCOLR_BLUE_1                 ((uint32_t)0x000000FF)               /*!< BLUE Value */
N#define DMA2D_OCOLR_GREEN_1                ((uint32_t)0x0000FF00)               /*!< GREEN Value  */
N#define DMA2D_OCOLR_RED_1                  ((uint32_t)0x00FF0000)               /*!< Red Value */
N#define DMA2D_OCOLR_ALPHA_1                ((uint32_t)0xFF000000)               /*!< Alpha Channel Value */
N
N/*!<Mode_RGB565 */
N#define DMA2D_OCOLR_BLUE_2                 ((uint32_t)0x0000001F)               /*!< BLUE Value */
N#define DMA2D_OCOLR_GREEN_2                ((uint32_t)0x000007E0)               /*!< GREEN Value  */
N#define DMA2D_OCOLR_RED_2                  ((uint32_t)0x0000F800)               /*!< Red Value */
N
N/*!<Mode_ARGB1555 */
N#define DMA2D_OCOLR_BLUE_3                 ((uint32_t)0x0000001F)               /*!< BLUE Value */
N#define DMA2D_OCOLR_GREEN_3                ((uint32_t)0x000003E0)               /*!< GREEN Value  */
N#define DMA2D_OCOLR_RED_3                  ((uint32_t)0x00007C00)               /*!< Red Value */
N#define DMA2D_OCOLR_ALPHA_3                ((uint32_t)0x00008000)               /*!< Alpha Channel Value */
N
N/*!<Mode_ARGB4444 */
N#define DMA2D_OCOLR_BLUE_4                 ((uint32_t)0x0000000F)               /*!< BLUE Value */
N#define DMA2D_OCOLR_GREEN_4                ((uint32_t)0x000000F0)               /*!< GREEN Value  */
N#define DMA2D_OCOLR_RED_4                  ((uint32_t)0x00000F00)               /*!< Red Value */
N#define DMA2D_OCOLR_ALPHA_4                ((uint32_t)0x0000F000)               /*!< Alpha Channel Value */
N
N/********************  Bit definition for DMA2D_OMAR register  ****************/
N
N#define DMA2D_OMAR_MA                      ((uint32_t)0xFFFFFFFF)               /*!< Memory Address */
N
N/********************  Bit definition for DMA2D_OOR register  *****************/
N
N#define DMA2D_OOR_LO                       ((uint32_t)0x00003FFF)               /*!< Line Offset */
N
N/********************  Bit definition for DMA2D_NLR register  *****************/
N
N#define DMA2D_NLR_NL                       ((uint32_t)0x0000FFFF)               /*!< Number of Lines */
N#define DMA2D_NLR_PL                       ((uint32_t)0x3FFF0000)               /*!< Pixel per Lines */
N
N/********************  Bit definition for DMA2D_LWR register  *****************/
N
N#define DMA2D_LWR_LW                       ((uint32_t)0x0000FFFF)               /*!< Line Watermark */
N
N/********************  Bit definition for DMA2D_AMTCR register  ***************/
N
N#define DMA2D_AMTCR_EN                     ((uint32_t)0x00000001)               /*!< Enable */
N#define DMA2D_AMTCR_DT                     ((uint32_t)0x0000FF00)               /*!< Dead Time */
N
N
N
N/********************  Bit definition for DMA2D_FGCLUT register  **************/
N                                                                     
N/********************  Bit definition for DMA2D_BGCLUT register  **************/
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                    External Interrupt/Event Controller                     */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for EXTI_IMR register  *******************/
N#define  EXTI_IMR_MR0                        ((uint32_t)0x00000001)        /*!< Interrupt Mask on line 0 */
N#define  EXTI_IMR_MR1                        ((uint32_t)0x00000002)        /*!< Interrupt Mask on line 1 */
N#define  EXTI_IMR_MR2                        ((uint32_t)0x00000004)        /*!< Interrupt Mask on line 2 */
N#define  EXTI_IMR_MR3                        ((uint32_t)0x00000008)        /*!< Interrupt Mask on line 3 */
N#define  EXTI_IMR_MR4                        ((uint32_t)0x00000010)        /*!< Interrupt Mask on line 4 */
N#define  EXTI_IMR_MR5                        ((uint32_t)0x00000020)        /*!< Interrupt Mask on line 5 */
N#define  EXTI_IMR_MR6                        ((uint32_t)0x00000040)        /*!< Interrupt Mask on line 6 */
N#define  EXTI_IMR_MR7                        ((uint32_t)0x00000080)        /*!< Interrupt Mask on line 7 */
N#define  EXTI_IMR_MR8                        ((uint32_t)0x00000100)        /*!< Interrupt Mask on line 8 */
N#define  EXTI_IMR_MR9                        ((uint32_t)0x00000200)        /*!< Interrupt Mask on line 9 */
N#define  EXTI_IMR_MR10                       ((uint32_t)0x00000400)        /*!< Interrupt Mask on line 10 */
N#define  EXTI_IMR_MR11                       ((uint32_t)0x00000800)        /*!< Interrupt Mask on line 11 */
N#define  EXTI_IMR_MR12                       ((uint32_t)0x00001000)        /*!< Interrupt Mask on line 12 */
N#define  EXTI_IMR_MR13                       ((uint32_t)0x00002000)        /*!< Interrupt Mask on line 13 */
N#define  EXTI_IMR_MR14                       ((uint32_t)0x00004000)        /*!< Interrupt Mask on line 14 */
N#define  EXTI_IMR_MR15                       ((uint32_t)0x00008000)        /*!< Interrupt Mask on line 15 */
N#define  EXTI_IMR_MR16                       ((uint32_t)0x00010000)        /*!< Interrupt Mask on line 16 */
N#define  EXTI_IMR_MR17                       ((uint32_t)0x00020000)        /*!< Interrupt Mask on line 17 */
N#define  EXTI_IMR_MR18                       ((uint32_t)0x00040000)        /*!< Interrupt Mask on line 18 */
N#define  EXTI_IMR_MR19                       ((uint32_t)0x00080000)        /*!< Interrupt Mask on line 19 */
N#define  EXTI_IMR_MR23                       ((uint32_t)0x00800000)        /*!< Interrupt Mask on line 23 */
N
N/*******************  Bit definition for EXTI_EMR register  *******************/
N#define  EXTI_EMR_MR0                        ((uint32_t)0x00000001)        /*!< Event Mask on line 0 */
N#define  EXTI_EMR_MR1                        ((uint32_t)0x00000002)        /*!< Event Mask on line 1 */
N#define  EXTI_EMR_MR2                        ((uint32_t)0x00000004)        /*!< Event Mask on line 2 */
N#define  EXTI_EMR_MR3                        ((uint32_t)0x00000008)        /*!< Event Mask on line 3 */
N#define  EXTI_EMR_MR4                        ((uint32_t)0x00000010)        /*!< Event Mask on line 4 */
N#define  EXTI_EMR_MR5                        ((uint32_t)0x00000020)        /*!< Event Mask on line 5 */
N#define  EXTI_EMR_MR6                        ((uint32_t)0x00000040)        /*!< Event Mask on line 6 */
N#define  EXTI_EMR_MR7                        ((uint32_t)0x00000080)        /*!< Event Mask on line 7 */
N#define  EXTI_EMR_MR8                        ((uint32_t)0x00000100)        /*!< Event Mask on line 8 */
N#define  EXTI_EMR_MR9                        ((uint32_t)0x00000200)        /*!< Event Mask on line 9 */
N#define  EXTI_EMR_MR10                       ((uint32_t)0x00000400)        /*!< Event Mask on line 10 */
N#define  EXTI_EMR_MR11                       ((uint32_t)0x00000800)        /*!< Event Mask on line 11 */
N#define  EXTI_EMR_MR12                       ((uint32_t)0x00001000)        /*!< Event Mask on line 12 */
N#define  EXTI_EMR_MR13                       ((uint32_t)0x00002000)        /*!< Event Mask on line 13 */
N#define  EXTI_EMR_MR14                       ((uint32_t)0x00004000)        /*!< Event Mask on line 14 */
N#define  EXTI_EMR_MR15                       ((uint32_t)0x00008000)        /*!< Event Mask on line 15 */
N#define  EXTI_EMR_MR16                       ((uint32_t)0x00010000)        /*!< Event Mask on line 16 */
N#define  EXTI_EMR_MR17                       ((uint32_t)0x00020000)        /*!< Event Mask on line 17 */
N#define  EXTI_EMR_MR18                       ((uint32_t)0x00040000)        /*!< Event Mask on line 18 */
N#define  EXTI_EMR_MR19                       ((uint32_t)0x00080000)        /*!< Event Mask on line 19 */
N#define  EXTI_EMR_MR23                       ((uint32_t)0x00800000)        /*!< Event Mask on line 19 */
N
N/******************  Bit definition for EXTI_RTSR register  *******************/
N#define  EXTI_RTSR_TR0                       ((uint32_t)0x00000001)        /*!< Rising trigger event configuration bit of line 0 */
N#define  EXTI_RTSR_TR1                       ((uint32_t)0x00000002)        /*!< Rising trigger event configuration bit of line 1 */
N#define  EXTI_RTSR_TR2                       ((uint32_t)0x00000004)        /*!< Rising trigger event configuration bit of line 2 */
N#define  EXTI_RTSR_TR3                       ((uint32_t)0x00000008)        /*!< Rising trigger event configuration bit of line 3 */
N#define  EXTI_RTSR_TR4                       ((uint32_t)0x00000010)        /*!< Rising trigger event configuration bit of line 4 */
N#define  EXTI_RTSR_TR5                       ((uint32_t)0x00000020)        /*!< Rising trigger event configuration bit of line 5 */
N#define  EXTI_RTSR_TR6                       ((uint32_t)0x00000040)        /*!< Rising trigger event configuration bit of line 6 */
N#define  EXTI_RTSR_TR7                       ((uint32_t)0x00000080)        /*!< Rising trigger event configuration bit of line 7 */
N#define  EXTI_RTSR_TR8                       ((uint32_t)0x00000100)        /*!< Rising trigger event configuration bit of line 8 */
N#define  EXTI_RTSR_TR9                       ((uint32_t)0x00000200)        /*!< Rising trigger event configuration bit of line 9 */
N#define  EXTI_RTSR_TR10                      ((uint32_t)0x00000400)        /*!< Rising trigger event configuration bit of line 10 */
N#define  EXTI_RTSR_TR11                      ((uint32_t)0x00000800)        /*!< Rising trigger event configuration bit of line 11 */
N#define  EXTI_RTSR_TR12                      ((uint32_t)0x00001000)        /*!< Rising trigger event configuration bit of line 12 */
N#define  EXTI_RTSR_TR13                      ((uint32_t)0x00002000)        /*!< Rising trigger event configuration bit of line 13 */
N#define  EXTI_RTSR_TR14                      ((uint32_t)0x00004000)        /*!< Rising trigger event configuration bit of line 14 */
N#define  EXTI_RTSR_TR15                      ((uint32_t)0x00008000)        /*!< Rising trigger event configuration bit of line 15 */
N#define  EXTI_RTSR_TR16                      ((uint32_t)0x00010000)        /*!< Rising trigger event configuration bit of line 16 */
N#define  EXTI_RTSR_TR17                      ((uint32_t)0x00020000)        /*!< Rising trigger event configuration bit of line 17 */
N#define  EXTI_RTSR_TR18                      ((uint32_t)0x00040000)        /*!< Rising trigger event configuration bit of line 18 */
N#define  EXTI_RTSR_TR19                      ((uint32_t)0x00080000)        /*!< Rising trigger event configuration bit of line 19 */
N#define  EXTI_RTSR_TR23                      ((uint32_t)0x00800000)        /*!< Rising trigger event configuration bit of line 23 */
N
N/******************  Bit definition for EXTI_FTSR register  *******************/
N#define  EXTI_FTSR_TR0                       ((uint32_t)0x00000001)        /*!< Falling trigger event configuration bit of line 0 */
N#define  EXTI_FTSR_TR1                       ((uint32_t)0x00000002)        /*!< Falling trigger event configuration bit of line 1 */
N#define  EXTI_FTSR_TR2                       ((uint32_t)0x00000004)        /*!< Falling trigger event configuration bit of line 2 */
N#define  EXTI_FTSR_TR3                       ((uint32_t)0x00000008)        /*!< Falling trigger event configuration bit of line 3 */
N#define  EXTI_FTSR_TR4                       ((uint32_t)0x00000010)        /*!< Falling trigger event configuration bit of line 4 */
N#define  EXTI_FTSR_TR5                       ((uint32_t)0x00000020)        /*!< Falling trigger event configuration bit of line 5 */
N#define  EXTI_FTSR_TR6                       ((uint32_t)0x00000040)        /*!< Falling trigger event configuration bit of line 6 */
N#define  EXTI_FTSR_TR7                       ((uint32_t)0x00000080)        /*!< Falling trigger event configuration bit of line 7 */
N#define  EXTI_FTSR_TR8                       ((uint32_t)0x00000100)        /*!< Falling trigger event configuration bit of line 8 */
N#define  EXTI_FTSR_TR9                       ((uint32_t)0x00000200)        /*!< Falling trigger event configuration bit of line 9 */
N#define  EXTI_FTSR_TR10                      ((uint32_t)0x00000400)        /*!< Falling trigger event configuration bit of line 10 */
N#define  EXTI_FTSR_TR11                      ((uint32_t)0x00000800)        /*!< Falling trigger event configuration bit of line 11 */
N#define  EXTI_FTSR_TR12                      ((uint32_t)0x00001000)        /*!< Falling trigger event configuration bit of line 12 */
N#define  EXTI_FTSR_TR13                      ((uint32_t)0x00002000)        /*!< Falling trigger event configuration bit of line 13 */
N#define  EXTI_FTSR_TR14                      ((uint32_t)0x00004000)        /*!< Falling trigger event configuration bit of line 14 */
N#define  EXTI_FTSR_TR15                      ((uint32_t)0x00008000)        /*!< Falling trigger event configuration bit of line 15 */
N#define  EXTI_FTSR_TR16                      ((uint32_t)0x00010000)        /*!< Falling trigger event configuration bit of line 16 */
N#define  EXTI_FTSR_TR17                      ((uint32_t)0x00020000)        /*!< Falling trigger event configuration bit of line 17 */
N#define  EXTI_FTSR_TR18                      ((uint32_t)0x00040000)        /*!< Falling trigger event configuration bit of line 18 */
N#define  EXTI_FTSR_TR19                      ((uint32_t)0x00080000)        /*!< Falling trigger event configuration bit of line 19 */
N#define  EXTI_FTSR_TR23                      ((uint32_t)0x00800000)        /*!< Falling trigger event configuration bit of line 23 */
N
N/******************  Bit definition for EXTI_SWIER register  ******************/
N#define  EXTI_SWIER_SWIER0                   ((uint32_t)0x00000001)        /*!< Software Interrupt on line 0 */
N#define  EXTI_SWIER_SWIER1                   ((uint32_t)0x00000002)        /*!< Software Interrupt on line 1 */
N#define  EXTI_SWIER_SWIER2                   ((uint32_t)0x00000004)        /*!< Software Interrupt on line 2 */
N#define  EXTI_SWIER_SWIER3                   ((uint32_t)0x00000008)        /*!< Software Interrupt on line 3 */
N#define  EXTI_SWIER_SWIER4                   ((uint32_t)0x00000010)        /*!< Software Interrupt on line 4 */
N#define  EXTI_SWIER_SWIER5                   ((uint32_t)0x00000020)        /*!< Software Interrupt on line 5 */
N#define  EXTI_SWIER_SWIER6                   ((uint32_t)0x00000040)        /*!< Software Interrupt on line 6 */
N#define  EXTI_SWIER_SWIER7                   ((uint32_t)0x00000080)        /*!< Software Interrupt on line 7 */
N#define  EXTI_SWIER_SWIER8                   ((uint32_t)0x00000100)        /*!< Software Interrupt on line 8 */
N#define  EXTI_SWIER_SWIER9                   ((uint32_t)0x00000200)        /*!< Software Interrupt on line 9 */
N#define  EXTI_SWIER_SWIER10                  ((uint32_t)0x00000400)        /*!< Software Interrupt on line 10 */
N#define  EXTI_SWIER_SWIER11                  ((uint32_t)0x00000800)        /*!< Software Interrupt on line 11 */
N#define  EXTI_SWIER_SWIER12                  ((uint32_t)0x00001000)        /*!< Software Interrupt on line 12 */
N#define  EXTI_SWIER_SWIER13                  ((uint32_t)0x00002000)        /*!< Software Interrupt on line 13 */
N#define  EXTI_SWIER_SWIER14                  ((uint32_t)0x00004000)        /*!< Software Interrupt on line 14 */
N#define  EXTI_SWIER_SWIER15                  ((uint32_t)0x00008000)        /*!< Software Interrupt on line 15 */
N#define  EXTI_SWIER_SWIER16                  ((uint32_t)0x00010000)        /*!< Software Interrupt on line 16 */
N#define  EXTI_SWIER_SWIER17                  ((uint32_t)0x00020000)        /*!< Software Interrupt on line 17 */
N#define  EXTI_SWIER_SWIER18                  ((uint32_t)0x00040000)        /*!< Software Interrupt on line 18 */
N#define  EXTI_SWIER_SWIER19                  ((uint32_t)0x00080000)        /*!< Software Interrupt on line 19 */
N#define  EXTI_SWIER_SWIER23                  ((uint32_t)0x00800000)        /*!< Software Interrupt on line 23 */
N
N/*******************  Bit definition for EXTI_PR register  ********************/
N#define  EXTI_PR_PR0                         ((uint32_t)0x00000001)        /*!< Pending bit for line 0 */
N#define  EXTI_PR_PR1                         ((uint32_t)0x00000002)        /*!< Pending bit for line 1 */
N#define  EXTI_PR_PR2                         ((uint32_t)0x00000004)        /*!< Pending bit for line 2 */
N#define  EXTI_PR_PR3                         ((uint32_t)0x00000008)        /*!< Pending bit for line 3 */
N#define  EXTI_PR_PR4                         ((uint32_t)0x00000010)        /*!< Pending bit for line 4 */
N#define  EXTI_PR_PR5                         ((uint32_t)0x00000020)        /*!< Pending bit for line 5 */
N#define  EXTI_PR_PR6                         ((uint32_t)0x00000040)        /*!< Pending bit for line 6 */
N#define  EXTI_PR_PR7                         ((uint32_t)0x00000080)        /*!< Pending bit for line 7 */
N#define  EXTI_PR_PR8                         ((uint32_t)0x00000100)        /*!< Pending bit for line 8 */
N#define  EXTI_PR_PR9                         ((uint32_t)0x00000200)        /*!< Pending bit for line 9 */
N#define  EXTI_PR_PR10                        ((uint32_t)0x00000400)        /*!< Pending bit for line 10 */
N#define  EXTI_PR_PR11                        ((uint32_t)0x00000800)        /*!< Pending bit for line 11 */
N#define  EXTI_PR_PR12                        ((uint32_t)0x00001000)        /*!< Pending bit for line 12 */
N#define  EXTI_PR_PR13                        ((uint32_t)0x00002000)        /*!< Pending bit for line 13 */
N#define  EXTI_PR_PR14                        ((uint32_t)0x00004000)        /*!< Pending bit for line 14 */
N#define  EXTI_PR_PR15                        ((uint32_t)0x00008000)        /*!< Pending bit for line 15 */
N#define  EXTI_PR_PR16                        ((uint32_t)0x00010000)        /*!< Pending bit for line 16 */
N#define  EXTI_PR_PR17                        ((uint32_t)0x00020000)        /*!< Pending bit for line 17 */
N#define  EXTI_PR_PR18                        ((uint32_t)0x00040000)        /*!< Pending bit for line 18 */
N#define  EXTI_PR_PR19                        ((uint32_t)0x00080000)        /*!< Pending bit for line 19 */
N#define  EXTI_PR_PR23                        ((uint32_t)0x00800000)        /*!< Pending bit for line 23 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                    FLASH                                   */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bits definition for FLASH_ACR register  *****************/
N#define FLASH_ACR_LATENCY                    ((uint32_t)0x0000000F)
N#define FLASH_ACR_LATENCY_0WS                ((uint32_t)0x00000000)
N#define FLASH_ACR_LATENCY_1WS                ((uint32_t)0x00000001)
N#define FLASH_ACR_LATENCY_2WS                ((uint32_t)0x00000002)
N#define FLASH_ACR_LATENCY_3WS                ((uint32_t)0x00000003)
N#define FLASH_ACR_LATENCY_4WS                ((uint32_t)0x00000004)
N#define FLASH_ACR_LATENCY_5WS                ((uint32_t)0x00000005)
N#define FLASH_ACR_LATENCY_6WS                ((uint32_t)0x00000006)
N#define FLASH_ACR_LATENCY_7WS                ((uint32_t)0x00000007)
N#define FLASH_ACR_LATENCY_8WS                ((uint32_t)0x00000008)
N#define FLASH_ACR_LATENCY_9WS                ((uint32_t)0x00000009)
N#define FLASH_ACR_LATENCY_10WS               ((uint32_t)0x0000000A)
N#define FLASH_ACR_LATENCY_11WS               ((uint32_t)0x0000000B)
N#define FLASH_ACR_LATENCY_12WS               ((uint32_t)0x0000000C)
N#define FLASH_ACR_LATENCY_13WS               ((uint32_t)0x0000000D)
N#define FLASH_ACR_LATENCY_14WS               ((uint32_t)0x0000000E)
N#define FLASH_ACR_LATENCY_15WS               ((uint32_t)0x0000000F)
N
N#define FLASH_ACR_PRFTEN                     ((uint32_t)0x00000100)
N#define FLASH_ACR_ICEN                       ((uint32_t)0x00000200)
N#define FLASH_ACR_DCEN                       ((uint32_t)0x00000400)
N#define FLASH_ACR_ICRST                      ((uint32_t)0x00000800)
N#define FLASH_ACR_DCRST                      ((uint32_t)0x00001000)
N#define FLASH_ACR_BYTE0_ADDRESS              ((uint32_t)0x40023C00)
N#define FLASH_ACR_BYTE2_ADDRESS              ((uint32_t)0x40023C03)
N
N/*******************  Bits definition for FLASH_SR register  ******************/
N#define FLASH_SR_EOP                         ((uint32_t)0x00000001)
N#define FLASH_SR_SOP                         ((uint32_t)0x00000002)
N#define FLASH_SR_WRPERR                      ((uint32_t)0x00000010)
N#define FLASH_SR_PGAERR                      ((uint32_t)0x00000020)
N#define FLASH_SR_PGPERR                      ((uint32_t)0x00000040)
N#define FLASH_SR_PGSERR                      ((uint32_t)0x00000080)
N#define FLASH_SR_BSY                         ((uint32_t)0x00010000)
N
N/*******************  Bits definition for FLASH_CR register  ******************/
N#define FLASH_CR_PG                          ((uint32_t)0x00000001)
N#define FLASH_CR_SER                         ((uint32_t)0x00000002)
N#define FLASH_CR_MER                         ((uint32_t)0x00000004)
N#define FLASH_CR_MER1                        FLASH_CR_MER
N#define FLASH_CR_SNB                         ((uint32_t)0x000000F8)
N#define FLASH_CR_SNB_0                       ((uint32_t)0x00000008)
N#define FLASH_CR_SNB_1                       ((uint32_t)0x00000010)
N#define FLASH_CR_SNB_2                       ((uint32_t)0x00000020)
N#define FLASH_CR_SNB_3                       ((uint32_t)0x00000040)
N#define FLASH_CR_SNB_4                       ((uint32_t)0x00000040)
N#define FLASH_CR_PSIZE                       ((uint32_t)0x00000300)
N#define FLASH_CR_PSIZE_0                     ((uint32_t)0x00000100)
N#define FLASH_CR_PSIZE_1                     ((uint32_t)0x00000200)
N#define FLASH_CR_MER2                        ((uint32_t)0x00008000)
N#define FLASH_CR_STRT                        ((uint32_t)0x00010000)
N#define FLASH_CR_EOPIE                       ((uint32_t)0x01000000)
N#define FLASH_CR_LOCK                        ((uint32_t)0x80000000)
N
N/*******************  Bits definition for FLASH_OPTCR register  ***************/
N#define FLASH_OPTCR_OPTLOCK                 ((uint32_t)0x00000001)
N#define FLASH_OPTCR_OPTSTRT                 ((uint32_t)0x00000002)
N#define FLASH_OPTCR_BOR_LEV_0               ((uint32_t)0x00000004)
N#define FLASH_OPTCR_BOR_LEV_1               ((uint32_t)0x00000008)
N#define FLASH_OPTCR_BOR_LEV                 ((uint32_t)0x0000000C)
N#define FLASH_OPTCR_BFB2                    ((uint32_t)0x00000010)
N
N#define FLASH_OPTCR_WDG_SW                  ((uint32_t)0x00000020)
N#define FLASH_OPTCR_nRST_STOP               ((uint32_t)0x00000040)
N#define FLASH_OPTCR_nRST_STDBY              ((uint32_t)0x00000080)
N#define FLASH_OPTCR_RDP                     ((uint32_t)0x0000FF00)
N#define FLASH_OPTCR_RDP_0                   ((uint32_t)0x00000100)
N#define FLASH_OPTCR_RDP_1                   ((uint32_t)0x00000200)
N#define FLASH_OPTCR_RDP_2                   ((uint32_t)0x00000400)
N#define FLASH_OPTCR_RDP_3                   ((uint32_t)0x00000800)
N#define FLASH_OPTCR_RDP_4                   ((uint32_t)0x00001000)
N#define FLASH_OPTCR_RDP_5                   ((uint32_t)0x00002000)
N#define FLASH_OPTCR_RDP_6                   ((uint32_t)0x00004000)
N#define FLASH_OPTCR_RDP_7                   ((uint32_t)0x00008000)
N#define FLASH_OPTCR_nWRP                    ((uint32_t)0x0FFF0000)
N#define FLASH_OPTCR_nWRP_0                  ((uint32_t)0x00010000)
N#define FLASH_OPTCR_nWRP_1                  ((uint32_t)0x00020000)
N#define FLASH_OPTCR_nWRP_2                  ((uint32_t)0x00040000)
N#define FLASH_OPTCR_nWRP_3                  ((uint32_t)0x00080000)
N#define FLASH_OPTCR_nWRP_4                  ((uint32_t)0x00100000)
N#define FLASH_OPTCR_nWRP_5                  ((uint32_t)0x00200000)
N#define FLASH_OPTCR_nWRP_6                  ((uint32_t)0x00400000)
N#define FLASH_OPTCR_nWRP_7                  ((uint32_t)0x00800000)
N#define FLASH_OPTCR_nWRP_8                  ((uint32_t)0x01000000)
N#define FLASH_OPTCR_nWRP_9                  ((uint32_t)0x02000000)
N#define FLASH_OPTCR_nWRP_10                 ((uint32_t)0x04000000)
N#define FLASH_OPTCR_nWRP_11                 ((uint32_t)0x08000000)
N
N#define FLASH_OPTCR_DB1M                    ((uint32_t)0x40000000) 
N#define FLASH_OPTCR_SPRMOD                  ((uint32_t)0x80000000) 
N                                             
N/******************  Bits definition for FLASH_OPTCR1 register  ***************/
N#define FLASH_OPTCR1_nWRP                    ((uint32_t)0x0FFF0000)
N#define FLASH_OPTCR1_nWRP_0                  ((uint32_t)0x00010000)
N#define FLASH_OPTCR1_nWRP_1                  ((uint32_t)0x00020000)
N#define FLASH_OPTCR1_nWRP_2                  ((uint32_t)0x00040000)
N#define FLASH_OPTCR1_nWRP_3                  ((uint32_t)0x00080000)
N#define FLASH_OPTCR1_nWRP_4                  ((uint32_t)0x00100000)
N#define FLASH_OPTCR1_nWRP_5                  ((uint32_t)0x00200000)
N#define FLASH_OPTCR1_nWRP_6                  ((uint32_t)0x00400000)
N#define FLASH_OPTCR1_nWRP_7                  ((uint32_t)0x00800000)
N#define FLASH_OPTCR1_nWRP_8                  ((uint32_t)0x01000000)
N#define FLASH_OPTCR1_nWRP_9                  ((uint32_t)0x02000000)
N#define FLASH_OPTCR1_nWRP_10                 ((uint32_t)0x04000000)
N#define FLASH_OPTCR1_nWRP_11                 ((uint32_t)0x08000000)
N
N#if defined(STM32F40_41xxx) || defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 1L || 0L || 0L
N/******************************************************************************/
N/*                                                                            */
N/*                       Flexible Static Memory Controller                    */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bit definition for FSMC_BCR1 register  *******************/
N#define  FSMC_BCR1_MBKEN                     ((uint32_t)0x00000001)        /*!<Memory bank enable bit                 */
N#define  FSMC_BCR1_MUXEN                     ((uint32_t)0x00000002)        /*!<Address/data multiplexing enable bit   */
N
N#define  FSMC_BCR1_MTYP                      ((uint32_t)0x0000000C)        /*!<MTYP[1:0] bits (Memory type)           */
N#define  FSMC_BCR1_MTYP_0                    ((uint32_t)0x00000004)        /*!<Bit 0 */
N#define  FSMC_BCR1_MTYP_1                    ((uint32_t)0x00000008)        /*!<Bit 1 */
N
N#define  FSMC_BCR1_MWID                      ((uint32_t)0x00000030)        /*!<MWID[1:0] bits (Memory data bus width) */
N#define  FSMC_BCR1_MWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
N#define  FSMC_BCR1_MWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
N
N#define  FSMC_BCR1_FACCEN                    ((uint32_t)0x00000040)        /*!<Flash access enable                    */
N#define  FSMC_BCR1_BURSTEN                   ((uint32_t)0x00000100)        /*!<Burst enable bit                       */
N#define  FSMC_BCR1_WAITPOL                   ((uint32_t)0x00000200)        /*!<Wait signal polarity bit               */
N#define  FSMC_BCR1_WRAPMOD                   ((uint32_t)0x00000400)        /*!<Wrapped burst mode support             */
N#define  FSMC_BCR1_WAITCFG                   ((uint32_t)0x00000800)        /*!<Wait timing configuration              */
N#define  FSMC_BCR1_WREN                      ((uint32_t)0x00001000)        /*!<Write enable bit                       */
N#define  FSMC_BCR1_WAITEN                    ((uint32_t)0x00002000)        /*!<Wait enable bit                        */
N#define  FSMC_BCR1_EXTMOD                    ((uint32_t)0x00004000)        /*!<Extended mode enable                   */
N#define  FSMC_BCR1_ASYNCWAIT                 ((uint32_t)0x00008000)        /*!<Asynchronous wait                      */
N#define  FSMC_BCR1_CBURSTRW                  ((uint32_t)0x00080000)        /*!<Write burst enable                     */
N
N/******************  Bit definition for FSMC_BCR2 register  *******************/
N#define  FSMC_BCR2_MBKEN                     ((uint32_t)0x00000001)        /*!<Memory bank enable bit                */
N#define  FSMC_BCR2_MUXEN                     ((uint32_t)0x00000002)        /*!<Address/data multiplexing enable bit   */
N
N#define  FSMC_BCR2_MTYP                      ((uint32_t)0x0000000C)        /*!<MTYP[1:0] bits (Memory type)           */
N#define  FSMC_BCR2_MTYP_0                    ((uint32_t)0x00000004)        /*!<Bit 0 */
N#define  FSMC_BCR2_MTYP_1                    ((uint32_t)0x00000008)        /*!<Bit 1 */
N
N#define  FSMC_BCR2_MWID                      ((uint32_t)0x00000030)        /*!<MWID[1:0] bits (Memory data bus width) */
N#define  FSMC_BCR2_MWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
N#define  FSMC_BCR2_MWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
N
N#define  FSMC_BCR2_FACCEN                    ((uint32_t)0x00000040)        /*!<Flash access enable                    */
N#define  FSMC_BCR2_BURSTEN                   ((uint32_t)0x00000100)        /*!<Burst enable bit                       */
N#define  FSMC_BCR2_WAITPOL                   ((uint32_t)0x00000200)        /*!<Wait signal polarity bit               */
N#define  FSMC_BCR2_WRAPMOD                   ((uint32_t)0x00000400)        /*!<Wrapped burst mode support             */
N#define  FSMC_BCR2_WAITCFG                   ((uint32_t)0x00000800)        /*!<Wait timing configuration              */
N#define  FSMC_BCR2_WREN                      ((uint32_t)0x00001000)        /*!<Write enable bit                       */
N#define  FSMC_BCR2_WAITEN                    ((uint32_t)0x00002000)        /*!<Wait enable bit                        */
N#define  FSMC_BCR2_EXTMOD                    ((uint32_t)0x00004000)        /*!<Extended mode enable                   */
N#define  FSMC_BCR2_ASYNCWAIT                 ((uint32_t)0x00008000)        /*!<Asynchronous wait                      */
N#define  FSMC_BCR2_CBURSTRW                  ((uint32_t)0x00080000)        /*!<Write burst enable                     */
N
N/******************  Bit definition for FSMC_BCR3 register  *******************/
N#define  FSMC_BCR3_MBKEN                     ((uint32_t)0x00000001)        /*!<Memory bank enable bit                 */
N#define  FSMC_BCR3_MUXEN                     ((uint32_t)0x00000002)        /*!<Address/data multiplexing enable bit   */
N
N#define  FSMC_BCR3_MTYP                      ((uint32_t)0x0000000C)        /*!<MTYP[1:0] bits (Memory type)           */
N#define  FSMC_BCR3_MTYP_0                    ((uint32_t)0x00000004)        /*!<Bit 0 */
N#define  FSMC_BCR3_MTYP_1                    ((uint32_t)0x00000008)        /*!<Bit 1 */
N
N#define  FSMC_BCR3_MWID                      ((uint32_t)0x00000030)        /*!<MWID[1:0] bits (Memory data bus width) */
N#define  FSMC_BCR3_MWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
N#define  FSMC_BCR3_MWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
N
N#define  FSMC_BCR3_FACCEN                    ((uint32_t)0x00000040)        /*!<Flash access enable                    */
N#define  FSMC_BCR3_BURSTEN                   ((uint32_t)0x00000100)        /*!<Burst enable bit                       */
N#define  FSMC_BCR3_WAITPOL                   ((uint32_t)0x00000200)        /*!<Wait signal polarity bit               */
N#define  FSMC_BCR3_WRAPMOD                   ((uint32_t)0x00000400)        /*!<Wrapped burst mode support             */
N#define  FSMC_BCR3_WAITCFG                   ((uint32_t)0x00000800)        /*!<Wait timing configuration              */
N#define  FSMC_BCR3_WREN                      ((uint32_t)0x00001000)        /*!<Write enable bit                       */
N#define  FSMC_BCR3_WAITEN                    ((uint32_t)0x00002000)        /*!<Wait enable bit                        */
N#define  FSMC_BCR3_EXTMOD                    ((uint32_t)0x00004000)        /*!<Extended mode enable                   */
N#define  FSMC_BCR3_ASYNCWAIT                 ((uint32_t)0x00008000)        /*!<Asynchronous wait                      */
N#define  FSMC_BCR3_CBURSTRW                  ((uint32_t)0x00080000)        /*!<Write burst enable                     */
N
N/******************  Bit definition for FSMC_BCR4 register  *******************/
N#define  FSMC_BCR4_MBKEN                     ((uint32_t)0x00000001)        /*!<Memory bank enable bit */
N#define  FSMC_BCR4_MUXEN                     ((uint32_t)0x00000002)        /*!<Address/data multiplexing enable bit   */
N
N#define  FSMC_BCR4_MTYP                      ((uint32_t)0x0000000C)        /*!<MTYP[1:0] bits (Memory type)           */
N#define  FSMC_BCR4_MTYP_0                    ((uint32_t)0x00000004)        /*!<Bit 0 */
N#define  FSMC_BCR4_MTYP_1                    ((uint32_t)0x00000008)        /*!<Bit 1 */
N
N#define  FSMC_BCR4_MWID                      ((uint32_t)0x00000030)        /*!<MWID[1:0] bits (Memory data bus width) */
N#define  FSMC_BCR4_MWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
N#define  FSMC_BCR4_MWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
N
N#define  FSMC_BCR4_FACCEN                    ((uint32_t)0x00000040)        /*!<Flash access enable                    */
N#define  FSMC_BCR4_BURSTEN                   ((uint32_t)0x00000100)        /*!<Burst enable bit                       */
N#define  FSMC_BCR4_WAITPOL                   ((uint32_t)0x00000200)        /*!<Wait signal polarity bit               */
N#define  FSMC_BCR4_WRAPMOD                   ((uint32_t)0x00000400)        /*!<Wrapped burst mode support             */
N#define  FSMC_BCR4_WAITCFG                   ((uint32_t)0x00000800)        /*!<Wait timing configuration              */
N#define  FSMC_BCR4_WREN                      ((uint32_t)0x00001000)        /*!<Write enable bit                       */
N#define  FSMC_BCR4_WAITEN                    ((uint32_t)0x00002000)        /*!<Wait enable bit                        */
N#define  FSMC_BCR4_EXTMOD                    ((uint32_t)0x00004000)        /*!<Extended mode enable                   */
N#define  FSMC_BCR4_ASYNCWAIT                 ((uint32_t)0x00008000)        /*!<Asynchronous wait                      */
N#define  FSMC_BCR4_CBURSTRW                  ((uint32_t)0x00080000)        /*!<Write burst enable                     */
N
N/******************  Bit definition for FSMC_BTR1 register  ******************/
N#define  FSMC_BTR1_ADDSET                    ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
N#define  FSMC_BTR1_ADDSET_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  FSMC_BTR1_ADDSET_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
N#define  FSMC_BTR1_ADDSET_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
N#define  FSMC_BTR1_ADDSET_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
N
N#define  FSMC_BTR1_ADDHLD                    ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FSMC_BTR1_ADDHLD_0                  ((uint32_t)0x00000010)        /*!<Bit 0 */
N#define  FSMC_BTR1_ADDHLD_1                  ((uint32_t)0x00000020)        /*!<Bit 1 */
N#define  FSMC_BTR1_ADDHLD_2                  ((uint32_t)0x00000040)        /*!<Bit 2 */
N#define  FSMC_BTR1_ADDHLD_3                  ((uint32_t)0x00000080)        /*!<Bit 3 */
N
N#define  FSMC_BTR1_DATAST                    ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
N#define  FSMC_BTR1_DATAST_0                  ((uint32_t)0x00000100)        /*!<Bit 0 */
N#define  FSMC_BTR1_DATAST_1                  ((uint32_t)0x00000200)        /*!<Bit 1 */
N#define  FSMC_BTR1_DATAST_2                  ((uint32_t)0x00000400)        /*!<Bit 2 */
N#define  FSMC_BTR1_DATAST_3                  ((uint32_t)0x00000800)        /*!<Bit 3 */
N
N#define  FSMC_BTR1_BUSTURN                   ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
N#define  FSMC_BTR1_BUSTURN_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
N#define  FSMC_BTR1_BUSTURN_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
N#define  FSMC_BTR1_BUSTURN_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
N#define  FSMC_BTR1_BUSTURN_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
N
N#define  FSMC_BTR1_CLKDIV                    ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
N#define  FSMC_BTR1_CLKDIV_0                  ((uint32_t)0x00100000)        /*!<Bit 0 */
N#define  FSMC_BTR1_CLKDIV_1                  ((uint32_t)0x00200000)        /*!<Bit 1 */
N#define  FSMC_BTR1_CLKDIV_2                  ((uint32_t)0x00400000)        /*!<Bit 2 */
N#define  FSMC_BTR1_CLKDIV_3                  ((uint32_t)0x00800000)        /*!<Bit 3 */
N
N#define  FSMC_BTR1_DATLAT                    ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
N#define  FSMC_BTR1_DATLAT_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
N#define  FSMC_BTR1_DATLAT_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
N#define  FSMC_BTR1_DATLAT_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
N#define  FSMC_BTR1_DATLAT_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
N
N#define  FSMC_BTR1_ACCMOD                    ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
N#define  FSMC_BTR1_ACCMOD_0                  ((uint32_t)0x10000000)        /*!<Bit 0 */
N#define  FSMC_BTR1_ACCMOD_1                  ((uint32_t)0x20000000)        /*!<Bit 1 */
N
N/******************  Bit definition for FSMC_BTR2 register  *******************/
N#define  FSMC_BTR2_ADDSET                    ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
N#define  FSMC_BTR2_ADDSET_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  FSMC_BTR2_ADDSET_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
N#define  FSMC_BTR2_ADDSET_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
N#define  FSMC_BTR2_ADDSET_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
N
N#define  FSMC_BTR2_ADDHLD                    ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FSMC_BTR2_ADDHLD_0                  ((uint32_t)0x00000010)        /*!<Bit 0 */
N#define  FSMC_BTR2_ADDHLD_1                  ((uint32_t)0x00000020)        /*!<Bit 1 */
N#define  FSMC_BTR2_ADDHLD_2                  ((uint32_t)0x00000040)        /*!<Bit 2 */
N#define  FSMC_BTR2_ADDHLD_3                  ((uint32_t)0x00000080)        /*!<Bit 3 */
N
N#define  FSMC_BTR2_DATAST                    ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
N#define  FSMC_BTR2_DATAST_0                  ((uint32_t)0x00000100)        /*!<Bit 0 */
N#define  FSMC_BTR2_DATAST_1                  ((uint32_t)0x00000200)        /*!<Bit 1 */
N#define  FSMC_BTR2_DATAST_2                  ((uint32_t)0x00000400)        /*!<Bit 2 */
N#define  FSMC_BTR2_DATAST_3                  ((uint32_t)0x00000800)        /*!<Bit 3 */
N
N#define  FSMC_BTR2_BUSTURN                   ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
N#define  FSMC_BTR2_BUSTURN_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
N#define  FSMC_BTR2_BUSTURN_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
N#define  FSMC_BTR2_BUSTURN_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
N#define  FSMC_BTR2_BUSTURN_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
N
N#define  FSMC_BTR2_CLKDIV                    ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
N#define  FSMC_BTR2_CLKDIV_0                  ((uint32_t)0x00100000)        /*!<Bit 0 */
N#define  FSMC_BTR2_CLKDIV_1                  ((uint32_t)0x00200000)        /*!<Bit 1 */
N#define  FSMC_BTR2_CLKDIV_2                  ((uint32_t)0x00400000)        /*!<Bit 2 */
N#define  FSMC_BTR2_CLKDIV_3                  ((uint32_t)0x00800000)        /*!<Bit 3 */
N
N#define  FSMC_BTR2_DATLAT                    ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
N#define  FSMC_BTR2_DATLAT_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
N#define  FSMC_BTR2_DATLAT_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
N#define  FSMC_BTR2_DATLAT_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
N#define  FSMC_BTR2_DATLAT_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
N
N#define  FSMC_BTR2_ACCMOD                    ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
N#define  FSMC_BTR2_ACCMOD_0                  ((uint32_t)0x10000000)        /*!<Bit 0 */
N#define  FSMC_BTR2_ACCMOD_1                  ((uint32_t)0x20000000)        /*!<Bit 1 */
N
N/*******************  Bit definition for FSMC_BTR3 register  *******************/
N#define  FSMC_BTR3_ADDSET                    ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
N#define  FSMC_BTR3_ADDSET_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  FSMC_BTR3_ADDSET_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
N#define  FSMC_BTR3_ADDSET_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
N#define  FSMC_BTR3_ADDSET_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
N
N#define  FSMC_BTR3_ADDHLD                    ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FSMC_BTR3_ADDHLD_0                  ((uint32_t)0x00000010)        /*!<Bit 0 */
N#define  FSMC_BTR3_ADDHLD_1                  ((uint32_t)0x00000020)        /*!<Bit 1 */
N#define  FSMC_BTR3_ADDHLD_2                  ((uint32_t)0x00000040)        /*!<Bit 2 */
N#define  FSMC_BTR3_ADDHLD_3                  ((uint32_t)0x00000080)        /*!<Bit 3 */
N
N#define  FSMC_BTR3_DATAST                    ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
N#define  FSMC_BTR3_DATAST_0                  ((uint32_t)0x00000100)        /*!<Bit 0 */
N#define  FSMC_BTR3_DATAST_1                  ((uint32_t)0x00000200)        /*!<Bit 1 */
N#define  FSMC_BTR3_DATAST_2                  ((uint32_t)0x00000400)        /*!<Bit 2 */
N#define  FSMC_BTR3_DATAST_3                  ((uint32_t)0x00000800)        /*!<Bit 3 */
N
N#define  FSMC_BTR3_BUSTURN                   ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
N#define  FSMC_BTR3_BUSTURN_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
N#define  FSMC_BTR3_BUSTURN_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
N#define  FSMC_BTR3_BUSTURN_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
N#define  FSMC_BTR3_BUSTURN_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
N
N#define  FSMC_BTR3_CLKDIV                    ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
N#define  FSMC_BTR3_CLKDIV_0                  ((uint32_t)0x00100000)        /*!<Bit 0 */
N#define  FSMC_BTR3_CLKDIV_1                  ((uint32_t)0x00200000)        /*!<Bit 1 */
N#define  FSMC_BTR3_CLKDIV_2                  ((uint32_t)0x00400000)        /*!<Bit 2 */
N#define  FSMC_BTR3_CLKDIV_3                  ((uint32_t)0x00800000)        /*!<Bit 3 */
N
N#define  FSMC_BTR3_DATLAT                    ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
N#define  FSMC_BTR3_DATLAT_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
N#define  FSMC_BTR3_DATLAT_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
N#define  FSMC_BTR3_DATLAT_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
N#define  FSMC_BTR3_DATLAT_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
N
N#define  FSMC_BTR3_ACCMOD                    ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
N#define  FSMC_BTR3_ACCMOD_0                  ((uint32_t)0x10000000)        /*!<Bit 0 */
N#define  FSMC_BTR3_ACCMOD_1                  ((uint32_t)0x20000000)        /*!<Bit 1 */
N
N/******************  Bit definition for FSMC_BTR4 register  *******************/
N#define  FSMC_BTR4_ADDSET                    ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
N#define  FSMC_BTR4_ADDSET_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  FSMC_BTR4_ADDSET_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
N#define  FSMC_BTR4_ADDSET_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
N#define  FSMC_BTR4_ADDSET_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
N
N#define  FSMC_BTR4_ADDHLD                    ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FSMC_BTR4_ADDHLD_0                  ((uint32_t)0x00000010)        /*!<Bit 0 */
N#define  FSMC_BTR4_ADDHLD_1                  ((uint32_t)0x00000020)        /*!<Bit 1 */
N#define  FSMC_BTR4_ADDHLD_2                  ((uint32_t)0x00000040)        /*!<Bit 2 */
N#define  FSMC_BTR4_ADDHLD_3                  ((uint32_t)0x00000080)        /*!<Bit 3 */
N
N#define  FSMC_BTR4_DATAST                    ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
N#define  FSMC_BTR4_DATAST_0                  ((uint32_t)0x00000100)        /*!<Bit 0 */
N#define  FSMC_BTR4_DATAST_1                  ((uint32_t)0x00000200)        /*!<Bit 1 */
N#define  FSMC_BTR4_DATAST_2                  ((uint32_t)0x00000400)        /*!<Bit 2 */
N#define  FSMC_BTR4_DATAST_3                  ((uint32_t)0x00000800)        /*!<Bit 3 */
N
N#define  FSMC_BTR4_BUSTURN                   ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
N#define  FSMC_BTR4_BUSTURN_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
N#define  FSMC_BTR4_BUSTURN_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
N#define  FSMC_BTR4_BUSTURN_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
N#define  FSMC_BTR4_BUSTURN_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
N
N#define  FSMC_BTR4_CLKDIV                    ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
N#define  FSMC_BTR4_CLKDIV_0                  ((uint32_t)0x00100000)        /*!<Bit 0 */
N#define  FSMC_BTR4_CLKDIV_1                  ((uint32_t)0x00200000)        /*!<Bit 1 */
N#define  FSMC_BTR4_CLKDIV_2                  ((uint32_t)0x00400000)        /*!<Bit 2 */
N#define  FSMC_BTR4_CLKDIV_3                  ((uint32_t)0x00800000)        /*!<Bit 3 */
N
N#define  FSMC_BTR4_DATLAT                    ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
N#define  FSMC_BTR4_DATLAT_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
N#define  FSMC_BTR4_DATLAT_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
N#define  FSMC_BTR4_DATLAT_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
N#define  FSMC_BTR4_DATLAT_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
N
N#define  FSMC_BTR4_ACCMOD                    ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
N#define  FSMC_BTR4_ACCMOD_0                  ((uint32_t)0x10000000)        /*!<Bit 0 */
N#define  FSMC_BTR4_ACCMOD_1                  ((uint32_t)0x20000000)        /*!<Bit 1 */
N
N/******************  Bit definition for FSMC_BWTR1 register  ******************/
N#define  FSMC_BWTR1_ADDSET                   ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
N#define  FSMC_BWTR1_ADDSET_0                 ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  FSMC_BWTR1_ADDSET_1                 ((uint32_t)0x00000002)        /*!<Bit 1 */
N#define  FSMC_BWTR1_ADDSET_2                 ((uint32_t)0x00000004)        /*!<Bit 2 */
N#define  FSMC_BWTR1_ADDSET_3                 ((uint32_t)0x00000008)        /*!<Bit 3 */
N
N#define  FSMC_BWTR1_ADDHLD                   ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FSMC_BWTR1_ADDHLD_0                 ((uint32_t)0x00000010)        /*!<Bit 0 */
N#define  FSMC_BWTR1_ADDHLD_1                 ((uint32_t)0x00000020)        /*!<Bit 1 */
N#define  FSMC_BWTR1_ADDHLD_2                 ((uint32_t)0x00000040)        /*!<Bit 2 */
N#define  FSMC_BWTR1_ADDHLD_3                 ((uint32_t)0x00000080)        /*!<Bit 3 */
N
N#define  FSMC_BWTR1_DATAST                   ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
N#define  FSMC_BWTR1_DATAST_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
N#define  FSMC_BWTR1_DATAST_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
N#define  FSMC_BWTR1_DATAST_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
N#define  FSMC_BWTR1_DATAST_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
N
N#define  FSMC_BWTR1_BUSTURN                  ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround duration) */
N#define  FSMC_BWTR1_BUSTURN_0                ((uint32_t)0x00010000)        /*!<Bit 0 */
N#define  FSMC_BWTR1_BUSTURN_1                ((uint32_t)0x00020000)        /*!<Bit 1 */
N#define  FSMC_BWTR1_BUSTURN_2                ((uint32_t)0x00040000)        /*!<Bit 2 */
N#define  FSMC_BWTR1_BUSTURN_3                ((uint32_t)0x00080000)        /*!<Bit 3 */
N
N#define  FSMC_BWTR1_ACCMOD                   ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
N#define  FSMC_BWTR1_ACCMOD_0                 ((uint32_t)0x10000000)        /*!<Bit 0 */
N#define  FSMC_BWTR1_ACCMOD_1                 ((uint32_t)0x20000000)        /*!<Bit 1 */
N
N/******************  Bit definition for FSMC_BWTR2 register  ******************/
N#define  FSMC_BWTR2_ADDSET                   ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
N#define  FSMC_BWTR2_ADDSET_0                 ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  FSMC_BWTR2_ADDSET_1                 ((uint32_t)0x00000002)        /*!<Bit 1 */
N#define  FSMC_BWTR2_ADDSET_2                 ((uint32_t)0x00000004)        /*!<Bit 2 */
N#define  FSMC_BWTR2_ADDSET_3                 ((uint32_t)0x00000008)        /*!<Bit 3 */
N
N#define  FSMC_BWTR2_ADDHLD                   ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FSMC_BWTR2_ADDHLD_0                 ((uint32_t)0x00000010)        /*!<Bit 0 */
N#define  FSMC_BWTR2_ADDHLD_1                 ((uint32_t)0x00000020)        /*!<Bit 1 */
N#define  FSMC_BWTR2_ADDHLD_2                 ((uint32_t)0x00000040)        /*!<Bit 2 */
N#define  FSMC_BWTR2_ADDHLD_3                 ((uint32_t)0x00000080)        /*!<Bit 3 */
N
N#define  FSMC_BWTR2_DATAST                   ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
N#define  FSMC_BWTR2_DATAST_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
N#define  FSMC_BWTR2_DATAST_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
N#define  FSMC_BWTR2_DATAST_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
N#define  FSMC_BWTR2_DATAST_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
N
N#define  FSMC_BWTR2_BUSTURN                  ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround duration) */
N#define  FSMC_BWTR2_BUSTURN_0                ((uint32_t)0x00010000)        /*!<Bit 0 */
N#define  FSMC_BWTR2_BUSTURN_1                ((uint32_t)0x00020000)        /*!<Bit 1 */
N#define  FSMC_BWTR2_BUSTURN_2                ((uint32_t)0x00040000)        /*!<Bit 2 */
N#define  FSMC_BWTR2_BUSTURN_3                ((uint32_t)0x00080000)        /*!<Bit 3 */
N
N#define  FSMC_BWTR2_ACCMOD                   ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
N#define  FSMC_BWTR2_ACCMOD_0                 ((uint32_t)0x10000000)        /*!<Bit 0 */
N#define  FSMC_BWTR2_ACCMOD_1                 ((uint32_t)0x20000000)        /*!<Bit 1 */
N
N/******************  Bit definition for FSMC_BWTR3 register  ******************/
N#define  FSMC_BWTR3_ADDSET                   ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
N#define  FSMC_BWTR3_ADDSET_0                 ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  FSMC_BWTR3_ADDSET_1                 ((uint32_t)0x00000002)        /*!<Bit 1 */
N#define  FSMC_BWTR3_ADDSET_2                 ((uint32_t)0x00000004)        /*!<Bit 2 */
N#define  FSMC_BWTR3_ADDSET_3                 ((uint32_t)0x00000008)        /*!<Bit 3 */
N
N#define  FSMC_BWTR3_ADDHLD                   ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FSMC_BWTR3_ADDHLD_0                 ((uint32_t)0x00000010)        /*!<Bit 0 */
N#define  FSMC_BWTR3_ADDHLD_1                 ((uint32_t)0x00000020)        /*!<Bit 1 */
N#define  FSMC_BWTR3_ADDHLD_2                 ((uint32_t)0x00000040)        /*!<Bit 2 */
N#define  FSMC_BWTR3_ADDHLD_3                 ((uint32_t)0x00000080)        /*!<Bit 3 */
N
N#define  FSMC_BWTR3_DATAST                   ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
N#define  FSMC_BWTR3_DATAST_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
N#define  FSMC_BWTR3_DATAST_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
N#define  FSMC_BWTR3_DATAST_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
N#define  FSMC_BWTR3_DATAST_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
N
N#define  FSMC_BWTR3_BUSTURN                  ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround duration) */
N#define  FSMC_BWTR3_BUSTURN_0                ((uint32_t)0x00010000)        /*!<Bit 0 */
N#define  FSMC_BWTR3_BUSTURN_1                ((uint32_t)0x00020000)        /*!<Bit 1 */
N#define  FSMC_BWTR3_BUSTURN_2                ((uint32_t)0x00040000)        /*!<Bit 2 */
N#define  FSMC_BWTR3_BUSTURN_3                ((uint32_t)0x00080000)        /*!<Bit 3 */
N                                                      
N#define  FSMC_BWTR3_ACCMOD                   ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
N#define  FSMC_BWTR3_ACCMOD_0                 ((uint32_t)0x10000000)        /*!<Bit 0 */
N#define  FSMC_BWTR3_ACCMOD_1                 ((uint32_t)0x20000000)        /*!<Bit 1 */
N
N/******************  Bit definition for FSMC_BWTR4 register  ******************/
N#define  FSMC_BWTR4_ADDSET                   ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
N#define  FSMC_BWTR4_ADDSET_0                 ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  FSMC_BWTR4_ADDSET_1                 ((uint32_t)0x00000002)        /*!<Bit 1 */
N#define  FSMC_BWTR4_ADDSET_2                 ((uint32_t)0x00000004)        /*!<Bit 2 */
N#define  FSMC_BWTR4_ADDSET_3                 ((uint32_t)0x00000008)        /*!<Bit 3 */
N
N#define  FSMC_BWTR4_ADDHLD                   ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FSMC_BWTR4_ADDHLD_0                 ((uint32_t)0x00000010)        /*!<Bit 0 */
N#define  FSMC_BWTR4_ADDHLD_1                 ((uint32_t)0x00000020)        /*!<Bit 1 */
N#define  FSMC_BWTR4_ADDHLD_2                 ((uint32_t)0x00000040)        /*!<Bit 2 */
N#define  FSMC_BWTR4_ADDHLD_3                 ((uint32_t)0x00000080)        /*!<Bit 3 */
N
N#define  FSMC_BWTR4_DATAST                   ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
N#define  FSMC_BWTR4_DATAST_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
N#define  FSMC_BWTR4_DATAST_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
N#define  FSMC_BWTR4_DATAST_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
N#define  FSMC_BWTR4_DATAST_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
N
N#define  FSMC_BWTR4_BUSTURN                  ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround duration) */
N#define  FSMC_BWTR4_BUSTURN_0                ((uint32_t)0x00010000)        /*!<Bit 0 */
N#define  FSMC_BWTR4_BUSTURN_1                ((uint32_t)0x00020000)        /*!<Bit 1 */
N#define  FSMC_BWTR4_BUSTURN_2                ((uint32_t)0x00040000)        /*!<Bit 2 */
N#define  FSMC_BWTR4_BUSTURN_3                ((uint32_t)0x00080000)        /*!<Bit 3 */
N
N#define  FSMC_BWTR4_ACCMOD                   ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
N#define  FSMC_BWTR4_ACCMOD_0                 ((uint32_t)0x10000000)        /*!<Bit 0 */
N#define  FSMC_BWTR4_ACCMOD_1                 ((uint32_t)0x20000000)        /*!<Bit 1 */
N
N/******************  Bit definition for FSMC_PCR2 register  *******************/
N#define  FSMC_PCR2_PWAITEN                   ((uint32_t)0x00000002)        /*!<Wait feature enable bit */
N#define  FSMC_PCR2_PBKEN                     ((uint32_t)0x00000004)        /*!<PC Card/NAND Flash memory bank enable bit */
N#define  FSMC_PCR2_PTYP                      ((uint32_t)0x00000008)        /*!<Memory type */
N
N#define  FSMC_PCR2_PWID                      ((uint32_t)0x00000030)        /*!<PWID[1:0] bits (NAND Flash databus width) */
N#define  FSMC_PCR2_PWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
N#define  FSMC_PCR2_PWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
N
N#define  FSMC_PCR2_ECCEN                     ((uint32_t)0x00000040)        /*!<ECC computation logic enable bit */
N
N#define  FSMC_PCR2_TCLR                      ((uint32_t)0x00001E00)        /*!<TCLR[3:0] bits (CLE to RE delay) */
N#define  FSMC_PCR2_TCLR_0                    ((uint32_t)0x00000200)        /*!<Bit 0 */
N#define  FSMC_PCR2_TCLR_1                    ((uint32_t)0x00000400)        /*!<Bit 1 */
N#define  FSMC_PCR2_TCLR_2                    ((uint32_t)0x00000800)        /*!<Bit 2 */
N#define  FSMC_PCR2_TCLR_3                    ((uint32_t)0x00001000)        /*!<Bit 3 */
N
N#define  FSMC_PCR2_TAR                       ((uint32_t)0x0001E000)        /*!<TAR[3:0] bits (ALE to RE delay) */
N#define  FSMC_PCR2_TAR_0                     ((uint32_t)0x00002000)        /*!<Bit 0 */
N#define  FSMC_PCR2_TAR_1                     ((uint32_t)0x00004000)        /*!<Bit 1 */
N#define  FSMC_PCR2_TAR_2                     ((uint32_t)0x00008000)        /*!<Bit 2 */
N#define  FSMC_PCR2_TAR_3                     ((uint32_t)0x00010000)        /*!<Bit 3 */
N
N#define  FSMC_PCR2_ECCPS                     ((uint32_t)0x000E0000)        /*!<ECCPS[1:0] bits (ECC page size) */
N#define  FSMC_PCR2_ECCPS_0                   ((uint32_t)0x00020000)        /*!<Bit 0 */
N#define  FSMC_PCR2_ECCPS_1                   ((uint32_t)0x00040000)        /*!<Bit 1 */
N#define  FSMC_PCR2_ECCPS_2                   ((uint32_t)0x00080000)        /*!<Bit 2 */
N
N/******************  Bit definition for FSMC_PCR3 register  *******************/
N#define  FSMC_PCR3_PWAITEN                   ((uint32_t)0x00000002)        /*!<Wait feature enable bit */
N#define  FSMC_PCR3_PBKEN                     ((uint32_t)0x00000004)        /*!<PC Card/NAND Flash memory bank enable bit */
N#define  FSMC_PCR3_PTYP                      ((uint32_t)0x00000008)        /*!<Memory type */
N
N#define  FSMC_PCR3_PWID                      ((uint32_t)0x00000030)        /*!<PWID[1:0] bits (NAND Flash databus width) */
N#define  FSMC_PCR3_PWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
N#define  FSMC_PCR3_PWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
N
N#define  FSMC_PCR3_ECCEN                     ((uint32_t)0x00000040)        /*!<ECC computation logic enable bit */
N
N#define  FSMC_PCR3_TCLR                      ((uint32_t)0x00001E00)        /*!<TCLR[3:0] bits (CLE to RE delay) */
N#define  FSMC_PCR3_TCLR_0                    ((uint32_t)0x00000200)        /*!<Bit 0 */
N#define  FSMC_PCR3_TCLR_1                    ((uint32_t)0x00000400)        /*!<Bit 1 */
N#define  FSMC_PCR3_TCLR_2                    ((uint32_t)0x00000800)        /*!<Bit 2 */
N#define  FSMC_PCR3_TCLR_3                    ((uint32_t)0x00001000)        /*!<Bit 3 */
N
N#define  FSMC_PCR3_TAR                       ((uint32_t)0x0001E000)        /*!<TAR[3:0] bits (ALE to RE delay) */
N#define  FSMC_PCR3_TAR_0                     ((uint32_t)0x00002000)        /*!<Bit 0 */
N#define  FSMC_PCR3_TAR_1                     ((uint32_t)0x00004000)        /*!<Bit 1 */
N#define  FSMC_PCR3_TAR_2                     ((uint32_t)0x00008000)        /*!<Bit 2 */
N#define  FSMC_PCR3_TAR_3                     ((uint32_t)0x00010000)        /*!<Bit 3 */
N
N#define  FSMC_PCR3_ECCPS                     ((uint32_t)0x000E0000)        /*!<ECCPS[2:0] bits (ECC page size) */
N#define  FSMC_PCR3_ECCPS_0                   ((uint32_t)0x00020000)        /*!<Bit 0 */
N#define  FSMC_PCR3_ECCPS_1                   ((uint32_t)0x00040000)        /*!<Bit 1 */
N#define  FSMC_PCR3_ECCPS_2                   ((uint32_t)0x00080000)        /*!<Bit 2 */
N
N/******************  Bit definition for FSMC_PCR4 register  *******************/
N#define  FSMC_PCR4_PWAITEN                   ((uint32_t)0x00000002)        /*!<Wait feature enable bit */
N#define  FSMC_PCR4_PBKEN                     ((uint32_t)0x00000004)        /*!<PC Card/NAND Flash memory bank enable bit */
N#define  FSMC_PCR4_PTYP                      ((uint32_t)0x00000008)        /*!<Memory type */
N
N#define  FSMC_PCR4_PWID                      ((uint32_t)0x00000030)        /*!<PWID[1:0] bits (NAND Flash databus width) */
N#define  FSMC_PCR4_PWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
N#define  FSMC_PCR4_PWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
N
N#define  FSMC_PCR4_ECCEN                     ((uint32_t)0x00000040)        /*!<ECC computation logic enable bit */
N
N#define  FSMC_PCR4_TCLR                      ((uint32_t)0x00001E00)        /*!<TCLR[3:0] bits (CLE to RE delay) */
N#define  FSMC_PCR4_TCLR_0                    ((uint32_t)0x00000200)        /*!<Bit 0 */
N#define  FSMC_PCR4_TCLR_1                    ((uint32_t)0x00000400)        /*!<Bit 1 */
N#define  FSMC_PCR4_TCLR_2                    ((uint32_t)0x00000800)        /*!<Bit 2 */
N#define  FSMC_PCR4_TCLR_3                    ((uint32_t)0x00001000)        /*!<Bit 3 */
N
N#define  FSMC_PCR4_TAR                       ((uint32_t)0x0001E000)        /*!<TAR[3:0] bits (ALE to RE delay) */
N#define  FSMC_PCR4_TAR_0                     ((uint32_t)0x00002000)        /*!<Bit 0 */
N#define  FSMC_PCR4_TAR_1                     ((uint32_t)0x00004000)        /*!<Bit 1 */
N#define  FSMC_PCR4_TAR_2                     ((uint32_t)0x00008000)        /*!<Bit 2 */
N#define  FSMC_PCR4_TAR_3                     ((uint32_t)0x00010000)        /*!<Bit 3 */
N
N#define  FSMC_PCR4_ECCPS                     ((uint32_t)0x000E0000)        /*!<ECCPS[2:0] bits (ECC page size) */
N#define  FSMC_PCR4_ECCPS_0                   ((uint32_t)0x00020000)        /*!<Bit 0 */
N#define  FSMC_PCR4_ECCPS_1                   ((uint32_t)0x00040000)        /*!<Bit 1 */
N#define  FSMC_PCR4_ECCPS_2                   ((uint32_t)0x00080000)        /*!<Bit 2 */
N
N/*******************  Bit definition for FSMC_SR2 register  *******************/
N#define  FSMC_SR2_IRS                        ((uint8_t)0x01)               /*!<Interrupt Rising Edge status                */
N#define  FSMC_SR2_ILS                        ((uint8_t)0x02)               /*!<Interrupt Level status                      */
N#define  FSMC_SR2_IFS                        ((uint8_t)0x04)               /*!<Interrupt Falling Edge status               */
N#define  FSMC_SR2_IREN                       ((uint8_t)0x08)               /*!<Interrupt Rising Edge detection Enable bit  */
N#define  FSMC_SR2_ILEN                       ((uint8_t)0x10)               /*!<Interrupt Level detection Enable bit        */
N#define  FSMC_SR2_IFEN                       ((uint8_t)0x20)               /*!<Interrupt Falling Edge detection Enable bit */
N#define  FSMC_SR2_FEMPT                      ((uint8_t)0x40)               /*!<FIFO empty */
N
N/*******************  Bit definition for FSMC_SR3 register  *******************/
N#define  FSMC_SR3_IRS                        ((uint8_t)0x01)               /*!<Interrupt Rising Edge status                */
N#define  FSMC_SR3_ILS                        ((uint8_t)0x02)               /*!<Interrupt Level status                      */
N#define  FSMC_SR3_IFS                        ((uint8_t)0x04)               /*!<Interrupt Falling Edge status               */
N#define  FSMC_SR3_IREN                       ((uint8_t)0x08)               /*!<Interrupt Rising Edge detection Enable bit  */
N#define  FSMC_SR3_ILEN                       ((uint8_t)0x10)               /*!<Interrupt Level detection Enable bit        */
N#define  FSMC_SR3_IFEN                       ((uint8_t)0x20)               /*!<Interrupt Falling Edge detection Enable bit */
N#define  FSMC_SR3_FEMPT                      ((uint8_t)0x40)               /*!<FIFO empty */
N
N/*******************  Bit definition for FSMC_SR4 register  *******************/
N#define  FSMC_SR4_IRS                        ((uint8_t)0x01)               /*!<Interrupt Rising Edge status                 */
N#define  FSMC_SR4_ILS                        ((uint8_t)0x02)               /*!<Interrupt Level status                       */
N#define  FSMC_SR4_IFS                        ((uint8_t)0x04)               /*!<Interrupt Falling Edge status                */
N#define  FSMC_SR4_IREN                       ((uint8_t)0x08)               /*!<Interrupt Rising Edge detection Enable bit   */
N#define  FSMC_SR4_ILEN                       ((uint8_t)0x10)               /*!<Interrupt Level detection Enable bit         */
N#define  FSMC_SR4_IFEN                       ((uint8_t)0x20)               /*!<Interrupt Falling Edge detection Enable bit  */
N#define  FSMC_SR4_FEMPT                      ((uint8_t)0x40)               /*!<FIFO empty */
N
N/******************  Bit definition for FSMC_PMEM2 register  ******************/
N#define  FSMC_PMEM2_MEMSET2                  ((uint32_t)0x000000FF)        /*!<MEMSET2[7:0] bits (Common memory 2 setup time) */
N#define  FSMC_PMEM2_MEMSET2_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  FSMC_PMEM2_MEMSET2_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
N#define  FSMC_PMEM2_MEMSET2_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
N#define  FSMC_PMEM2_MEMSET2_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
N#define  FSMC_PMEM2_MEMSET2_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
N#define  FSMC_PMEM2_MEMSET2_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
N#define  FSMC_PMEM2_MEMSET2_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
N#define  FSMC_PMEM2_MEMSET2_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
N
N#define  FSMC_PMEM2_MEMWAIT2                 ((uint32_t)0x0000FF00)        /*!<MEMWAIT2[7:0] bits (Common memory 2 wait time) */
N#define  FSMC_PMEM2_MEMWAIT2_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
N#define  FSMC_PMEM2_MEMWAIT2_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
N#define  FSMC_PMEM2_MEMWAIT2_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
N#define  FSMC_PMEM2_MEMWAIT2_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
N#define  FSMC_PMEM2_MEMWAIT2_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
N#define  FSMC_PMEM2_MEMWAIT2_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
N#define  FSMC_PMEM2_MEMWAIT2_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
N#define  FSMC_PMEM2_MEMWAIT2_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
N
N#define  FSMC_PMEM2_MEMHOLD2                 ((uint32_t)0x00FF0000)        /*!<MEMHOLD2[7:0] bits (Common memory 2 hold time) */
N#define  FSMC_PMEM2_MEMHOLD2_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
N#define  FSMC_PMEM2_MEMHOLD2_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
N#define  FSMC_PMEM2_MEMHOLD2_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
N#define  FSMC_PMEM2_MEMHOLD2_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
N#define  FSMC_PMEM2_MEMHOLD2_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
N#define  FSMC_PMEM2_MEMHOLD2_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
N#define  FSMC_PMEM2_MEMHOLD2_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
N#define  FSMC_PMEM2_MEMHOLD2_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
N
N#define  FSMC_PMEM2_MEMHIZ2                  ((uint32_t)0xFF000000)        /*!<MEMHIZ2[7:0] bits (Common memory 2 databus HiZ time) */
N#define  FSMC_PMEM2_MEMHIZ2_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
N#define  FSMC_PMEM2_MEMHIZ2_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
N#define  FSMC_PMEM2_MEMHIZ2_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
N#define  FSMC_PMEM2_MEMHIZ2_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
N#define  FSMC_PMEM2_MEMHIZ2_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
N#define  FSMC_PMEM2_MEMHIZ2_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
N#define  FSMC_PMEM2_MEMHIZ2_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
N#define  FSMC_PMEM2_MEMHIZ2_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
N
N/******************  Bit definition for FSMC_PMEM3 register  ******************/
N#define  FSMC_PMEM3_MEMSET3                  ((uint32_t)0x000000FF)        /*!<MEMSET3[7:0] bits (Common memory 3 setup time) */
N#define  FSMC_PMEM3_MEMSET3_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  FSMC_PMEM3_MEMSET3_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
N#define  FSMC_PMEM3_MEMSET3_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
N#define  FSMC_PMEM3_MEMSET3_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
N#define  FSMC_PMEM3_MEMSET3_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
N#define  FSMC_PMEM3_MEMSET3_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
N#define  FSMC_PMEM3_MEMSET3_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
N#define  FSMC_PMEM3_MEMSET3_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
N
N#define  FSMC_PMEM3_MEMWAIT3                 ((uint32_t)0x0000FF00)        /*!<MEMWAIT3[7:0] bits (Common memory 3 wait time) */
N#define  FSMC_PMEM3_MEMWAIT3_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
N#define  FSMC_PMEM3_MEMWAIT3_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
N#define  FSMC_PMEM3_MEMWAIT3_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
N#define  FSMC_PMEM3_MEMWAIT3_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
N#define  FSMC_PMEM3_MEMWAIT3_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
N#define  FSMC_PMEM3_MEMWAIT3_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
N#define  FSMC_PMEM3_MEMWAIT3_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
N#define  FSMC_PMEM3_MEMWAIT3_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
N
N#define  FSMC_PMEM3_MEMHOLD3                 ((uint32_t)0x00FF0000)        /*!<MEMHOLD3[7:0] bits (Common memory 3 hold time) */
N#define  FSMC_PMEM3_MEMHOLD3_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
N#define  FSMC_PMEM3_MEMHOLD3_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
N#define  FSMC_PMEM3_MEMHOLD3_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
N#define  FSMC_PMEM3_MEMHOLD3_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
N#define  FSMC_PMEM3_MEMHOLD3_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
N#define  FSMC_PMEM3_MEMHOLD3_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
N#define  FSMC_PMEM3_MEMHOLD3_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
N#define  FSMC_PMEM3_MEMHOLD3_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
N
N#define  FSMC_PMEM3_MEMHIZ3                  ((uint32_t)0xFF000000)        /*!<MEMHIZ3[7:0] bits (Common memory 3 databus HiZ time) */
N#define  FSMC_PMEM3_MEMHIZ3_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
N#define  FSMC_PMEM3_MEMHIZ3_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
N#define  FSMC_PMEM3_MEMHIZ3_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
N#define  FSMC_PMEM3_MEMHIZ3_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
N#define  FSMC_PMEM3_MEMHIZ3_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
N#define  FSMC_PMEM3_MEMHIZ3_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
N#define  FSMC_PMEM3_MEMHIZ3_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
N#define  FSMC_PMEM3_MEMHIZ3_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
N
N/******************  Bit definition for FSMC_PMEM4 register  ******************/
N#define  FSMC_PMEM4_MEMSET4                  ((uint32_t)0x000000FF)        /*!<MEMSET4[7:0] bits (Common memory 4 setup time) */
N#define  FSMC_PMEM4_MEMSET4_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  FSMC_PMEM4_MEMSET4_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
N#define  FSMC_PMEM4_MEMSET4_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
N#define  FSMC_PMEM4_MEMSET4_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
N#define  FSMC_PMEM4_MEMSET4_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
N#define  FSMC_PMEM4_MEMSET4_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
N#define  FSMC_PMEM4_MEMSET4_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
N#define  FSMC_PMEM4_MEMSET4_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
N
N#define  FSMC_PMEM4_MEMWAIT4                 ((uint32_t)0x0000FF00)        /*!<MEMWAIT4[7:0] bits (Common memory 4 wait time) */
N#define  FSMC_PMEM4_MEMWAIT4_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
N#define  FSMC_PMEM4_MEMWAIT4_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
N#define  FSMC_PMEM4_MEMWAIT4_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
N#define  FSMC_PMEM4_MEMWAIT4_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
N#define  FSMC_PMEM4_MEMWAIT4_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
N#define  FSMC_PMEM4_MEMWAIT4_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
N#define  FSMC_PMEM4_MEMWAIT4_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
N#define  FSMC_PMEM4_MEMWAIT4_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
N
N#define  FSMC_PMEM4_MEMHOLD4                 ((uint32_t)0x00FF0000)        /*!<MEMHOLD4[7:0] bits (Common memory 4 hold time) */
N#define  FSMC_PMEM4_MEMHOLD4_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
N#define  FSMC_PMEM4_MEMHOLD4_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
N#define  FSMC_PMEM4_MEMHOLD4_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
N#define  FSMC_PMEM4_MEMHOLD4_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
N#define  FSMC_PMEM4_MEMHOLD4_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
N#define  FSMC_PMEM4_MEMHOLD4_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
N#define  FSMC_PMEM4_MEMHOLD4_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
N#define  FSMC_PMEM4_MEMHOLD4_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
N
N#define  FSMC_PMEM4_MEMHIZ4                  ((uint32_t)0xFF000000)        /*!<MEMHIZ4[7:0] bits (Common memory 4 databus HiZ time) */
N#define  FSMC_PMEM4_MEMHIZ4_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
N#define  FSMC_PMEM4_MEMHIZ4_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
N#define  FSMC_PMEM4_MEMHIZ4_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
N#define  FSMC_PMEM4_MEMHIZ4_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
N#define  FSMC_PMEM4_MEMHIZ4_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
N#define  FSMC_PMEM4_MEMHIZ4_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
N#define  FSMC_PMEM4_MEMHIZ4_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
N#define  FSMC_PMEM4_MEMHIZ4_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
N
N/******************  Bit definition for FSMC_PATT2 register  ******************/
N#define  FSMC_PATT2_ATTSET2                  ((uint32_t)0x000000FF)        /*!<ATTSET2[7:0] bits (Attribute memory 2 setup time) */
N#define  FSMC_PATT2_ATTSET2_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  FSMC_PATT2_ATTSET2_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
N#define  FSMC_PATT2_ATTSET2_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
N#define  FSMC_PATT2_ATTSET2_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
N#define  FSMC_PATT2_ATTSET2_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
N#define  FSMC_PATT2_ATTSET2_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
N#define  FSMC_PATT2_ATTSET2_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
N#define  FSMC_PATT2_ATTSET2_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
N
N#define  FSMC_PATT2_ATTWAIT2                 ((uint32_t)0x0000FF00)        /*!<ATTWAIT2[7:0] bits (Attribute memory 2 wait time) */
N#define  FSMC_PATT2_ATTWAIT2_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
N#define  FSMC_PATT2_ATTWAIT2_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
N#define  FSMC_PATT2_ATTWAIT2_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
N#define  FSMC_PATT2_ATTWAIT2_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
N#define  FSMC_PATT2_ATTWAIT2_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
N#define  FSMC_PATT2_ATTWAIT2_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
N#define  FSMC_PATT2_ATTWAIT2_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
N#define  FSMC_PATT2_ATTWAIT2_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
N
N#define  FSMC_PATT2_ATTHOLD2                 ((uint32_t)0x00FF0000)        /*!<ATTHOLD2[7:0] bits (Attribute memory 2 hold time) */
N#define  FSMC_PATT2_ATTHOLD2_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
N#define  FSMC_PATT2_ATTHOLD2_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
N#define  FSMC_PATT2_ATTHOLD2_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
N#define  FSMC_PATT2_ATTHOLD2_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
N#define  FSMC_PATT2_ATTHOLD2_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
N#define  FSMC_PATT2_ATTHOLD2_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
N#define  FSMC_PATT2_ATTHOLD2_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
N#define  FSMC_PATT2_ATTHOLD2_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
N
N#define  FSMC_PATT2_ATTHIZ2                  ((uint32_t)0xFF000000)        /*!<ATTHIZ2[7:0] bits (Attribute memory 2 databus HiZ time) */
N#define  FSMC_PATT2_ATTHIZ2_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
N#define  FSMC_PATT2_ATTHIZ2_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
N#define  FSMC_PATT2_ATTHIZ2_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
N#define  FSMC_PATT2_ATTHIZ2_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
N#define  FSMC_PATT2_ATTHIZ2_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
N#define  FSMC_PATT2_ATTHIZ2_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
N#define  FSMC_PATT2_ATTHIZ2_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
N#define  FSMC_PATT2_ATTHIZ2_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
N
N/******************  Bit definition for FSMC_PATT3 register  ******************/
N#define  FSMC_PATT3_ATTSET3                  ((uint32_t)0x000000FF)        /*!<ATTSET3[7:0] bits (Attribute memory 3 setup time) */
N#define  FSMC_PATT3_ATTSET3_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  FSMC_PATT3_ATTSET3_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
N#define  FSMC_PATT3_ATTSET3_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
N#define  FSMC_PATT3_ATTSET3_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
N#define  FSMC_PATT3_ATTSET3_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
N#define  FSMC_PATT3_ATTSET3_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
N#define  FSMC_PATT3_ATTSET3_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
N#define  FSMC_PATT3_ATTSET3_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
N
N#define  FSMC_PATT3_ATTWAIT3                 ((uint32_t)0x0000FF00)        /*!<ATTWAIT3[7:0] bits (Attribute memory 3 wait time) */
N#define  FSMC_PATT3_ATTWAIT3_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
N#define  FSMC_PATT3_ATTWAIT3_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
N#define  FSMC_PATT3_ATTWAIT3_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
N#define  FSMC_PATT3_ATTWAIT3_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
N#define  FSMC_PATT3_ATTWAIT3_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
N#define  FSMC_PATT3_ATTWAIT3_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
N#define  FSMC_PATT3_ATTWAIT3_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
N#define  FSMC_PATT3_ATTWAIT3_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
N
N#define  FSMC_PATT3_ATTHOLD3                 ((uint32_t)0x00FF0000)        /*!<ATTHOLD3[7:0] bits (Attribute memory 3 hold time) */
N#define  FSMC_PATT3_ATTHOLD3_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
N#define  FSMC_PATT3_ATTHOLD3_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
N#define  FSMC_PATT3_ATTHOLD3_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
N#define  FSMC_PATT3_ATTHOLD3_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
N#define  FSMC_PATT3_ATTHOLD3_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
N#define  FSMC_PATT3_ATTHOLD3_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
N#define  FSMC_PATT3_ATTHOLD3_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
N#define  FSMC_PATT3_ATTHOLD3_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
N
N#define  FSMC_PATT3_ATTHIZ3                  ((uint32_t)0xFF000000)        /*!<ATTHIZ3[7:0] bits (Attribute memory 3 databus HiZ time) */
N#define  FSMC_PATT3_ATTHIZ3_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
N#define  FSMC_PATT3_ATTHIZ3_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
N#define  FSMC_PATT3_ATTHIZ3_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
N#define  FSMC_PATT3_ATTHIZ3_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
N#define  FSMC_PATT3_ATTHIZ3_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
N#define  FSMC_PATT3_ATTHIZ3_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
N#define  FSMC_PATT3_ATTHIZ3_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
N#define  FSMC_PATT3_ATTHIZ3_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
N
N/******************  Bit definition for FSMC_PATT4 register  ******************/
N#define  FSMC_PATT4_ATTSET4                  ((uint32_t)0x000000FF)        /*!<ATTSET4[7:0] bits (Attribute memory 4 setup time) */
N#define  FSMC_PATT4_ATTSET4_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  FSMC_PATT4_ATTSET4_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
N#define  FSMC_PATT4_ATTSET4_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
N#define  FSMC_PATT4_ATTSET4_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
N#define  FSMC_PATT4_ATTSET4_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
N#define  FSMC_PATT4_ATTSET4_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
N#define  FSMC_PATT4_ATTSET4_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
N#define  FSMC_PATT4_ATTSET4_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
N
N#define  FSMC_PATT4_ATTWAIT4                 ((uint32_t)0x0000FF00)        /*!<ATTWAIT4[7:0] bits (Attribute memory 4 wait time) */
N#define  FSMC_PATT4_ATTWAIT4_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
N#define  FSMC_PATT4_ATTWAIT4_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
N#define  FSMC_PATT4_ATTWAIT4_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
N#define  FSMC_PATT4_ATTWAIT4_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
N#define  FSMC_PATT4_ATTWAIT4_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
N#define  FSMC_PATT4_ATTWAIT4_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
N#define  FSMC_PATT4_ATTWAIT4_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
N#define  FSMC_PATT4_ATTWAIT4_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
N
N#define  FSMC_PATT4_ATTHOLD4                 ((uint32_t)0x00FF0000)        /*!<ATTHOLD4[7:0] bits (Attribute memory 4 hold time) */
N#define  FSMC_PATT4_ATTHOLD4_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
N#define  FSMC_PATT4_ATTHOLD4_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
N#define  FSMC_PATT4_ATTHOLD4_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
N#define  FSMC_PATT4_ATTHOLD4_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
N#define  FSMC_PATT4_ATTHOLD4_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
N#define  FSMC_PATT4_ATTHOLD4_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
N#define  FSMC_PATT4_ATTHOLD4_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
N#define  FSMC_PATT4_ATTHOLD4_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
N
N#define  FSMC_PATT4_ATTHIZ4                  ((uint32_t)0xFF000000)        /*!<ATTHIZ4[7:0] bits (Attribute memory 4 databus HiZ time) */
N#define  FSMC_PATT4_ATTHIZ4_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
N#define  FSMC_PATT4_ATTHIZ4_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
N#define  FSMC_PATT4_ATTHIZ4_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
N#define  FSMC_PATT4_ATTHIZ4_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
N#define  FSMC_PATT4_ATTHIZ4_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
N#define  FSMC_PATT4_ATTHIZ4_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
N#define  FSMC_PATT4_ATTHIZ4_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
N#define  FSMC_PATT4_ATTHIZ4_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
N
N/******************  Bit definition for FSMC_PIO4 register  *******************/
N#define  FSMC_PIO4_IOSET4                    ((uint32_t)0x000000FF)        /*!<IOSET4[7:0] bits (I/O 4 setup time) */
N#define  FSMC_PIO4_IOSET4_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  FSMC_PIO4_IOSET4_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
N#define  FSMC_PIO4_IOSET4_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
N#define  FSMC_PIO4_IOSET4_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
N#define  FSMC_PIO4_IOSET4_4                  ((uint32_t)0x00000010)        /*!<Bit 4 */
N#define  FSMC_PIO4_IOSET4_5                  ((uint32_t)0x00000020)        /*!<Bit 5 */
N#define  FSMC_PIO4_IOSET4_6                  ((uint32_t)0x00000040)        /*!<Bit 6 */
N#define  FSMC_PIO4_IOSET4_7                  ((uint32_t)0x00000080)        /*!<Bit 7 */
N
N#define  FSMC_PIO4_IOWAIT4                   ((uint32_t)0x0000FF00)        /*!<IOWAIT4[7:0] bits (I/O 4 wait time) */
N#define  FSMC_PIO4_IOWAIT4_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
N#define  FSMC_PIO4_IOWAIT4_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
N#define  FSMC_PIO4_IOWAIT4_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
N#define  FSMC_PIO4_IOWAIT4_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
N#define  FSMC_PIO4_IOWAIT4_4                 ((uint32_t)0x00001000)        /*!<Bit 4 */
N#define  FSMC_PIO4_IOWAIT4_5                 ((uint32_t)0x00002000)        /*!<Bit 5 */
N#define  FSMC_PIO4_IOWAIT4_6                 ((uint32_t)0x00004000)        /*!<Bit 6 */
N#define  FSMC_PIO4_IOWAIT4_7                 ((uint32_t)0x00008000)        /*!<Bit 7 */
N
N#define  FSMC_PIO4_IOHOLD4                   ((uint32_t)0x00FF0000)        /*!<IOHOLD4[7:0] bits (I/O 4 hold time) */
N#define  FSMC_PIO4_IOHOLD4_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
N#define  FSMC_PIO4_IOHOLD4_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
N#define  FSMC_PIO4_IOHOLD4_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
N#define  FSMC_PIO4_IOHOLD4_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
N#define  FSMC_PIO4_IOHOLD4_4                 ((uint32_t)0x00100000)        /*!<Bit 4 */
N#define  FSMC_PIO4_IOHOLD4_5                 ((uint32_t)0x00200000)        /*!<Bit 5 */
N#define  FSMC_PIO4_IOHOLD4_6                 ((uint32_t)0x00400000)        /*!<Bit 6 */
N#define  FSMC_PIO4_IOHOLD4_7                 ((uint32_t)0x00800000)        /*!<Bit 7 */
N
N#define  FSMC_PIO4_IOHIZ4                    ((uint32_t)0xFF000000)        /*!<IOHIZ4[7:0] bits (I/O 4 databus HiZ time) */
N#define  FSMC_PIO4_IOHIZ4_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
N#define  FSMC_PIO4_IOHIZ4_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
N#define  FSMC_PIO4_IOHIZ4_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
N#define  FSMC_PIO4_IOHIZ4_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
N#define  FSMC_PIO4_IOHIZ4_4                  ((uint32_t)0x10000000)        /*!<Bit 4 */
N#define  FSMC_PIO4_IOHIZ4_5                  ((uint32_t)0x20000000)        /*!<Bit 5 */
N#define  FSMC_PIO4_IOHIZ4_6                  ((uint32_t)0x40000000)        /*!<Bit 6 */
N#define  FSMC_PIO4_IOHIZ4_7                  ((uint32_t)0x80000000)        /*!<Bit 7 */
N
N/******************  Bit definition for FSMC_ECCR2 register  ******************/
N#define  FSMC_ECCR2_ECC2                     ((uint32_t)0xFFFFFFFF)        /*!<ECC result */
N
N/******************  Bit definition for FSMC_ECCR3 register  ******************/
N#define  FSMC_ECCR3_ECC3                     ((uint32_t)0xFFFFFFFF)        /*!<ECC result */
N#endif /* STM32F40_41xxx || STM32F412xG || STM32F413_423xx */
N
N#if defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
X#if 0L || 0L || 0L || 0L
S/******************************************************************************/
S/*                                                                            */
S/*                          Flexible Memory Controller                        */
S/*                                                                            */
S/******************************************************************************/
S/******************  Bit definition for FMC_BCR1 register  *******************/
S#define  FMC_BCR1_MBKEN                     ((uint32_t)0x00000001)        /*!<Memory bank enable bit                 */
S#define  FMC_BCR1_MUXEN                     ((uint32_t)0x00000002)        /*!<Address/data multiplexing enable bit   */
S
S#define  FMC_BCR1_MTYP                      ((uint32_t)0x0000000C)        /*!<MTYP[1:0] bits (Memory type)           */
S#define  FMC_BCR1_MTYP_0                    ((uint32_t)0x00000004)        /*!<Bit 0 */
S#define  FMC_BCR1_MTYP_1                    ((uint32_t)0x00000008)        /*!<Bit 1 */
S
S#define  FMC_BCR1_MWID                      ((uint32_t)0x00000030)        /*!<MWID[1:0] bits (Memory data bus width) */
S#define  FMC_BCR1_MWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_BCR1_MWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
S
S#define  FMC_BCR1_FACCEN                    ((uint32_t)0x00000040)        /*!<Flash access enable        */
S#define  FMC_BCR1_BURSTEN                   ((uint32_t)0x00000100)        /*!<Burst enable bit           */
S#define  FMC_BCR1_WAITPOL                   ((uint32_t)0x00000200)        /*!<Wait signal polarity bit   */
S#define  FMC_BCR1_WRAPMOD                   ((uint32_t)0x00000400)        /*!<Wrapped burst mode support */
S#define  FMC_BCR1_WAITCFG                   ((uint32_t)0x00000800)        /*!<Wait timing configuration  */
S#define  FMC_BCR1_WREN                      ((uint32_t)0x00001000)        /*!<Write enable bit           */
S#define  FMC_BCR1_WAITEN                    ((uint32_t)0x00002000)        /*!<Wait enable bit            */
S#define  FMC_BCR1_EXTMOD                    ((uint32_t)0x00004000)        /*!<Extended mode enable       */
S#define  FMC_BCR1_ASYNCWAIT                 ((uint32_t)0x00008000)        /*!<Asynchronous wait          */
S#define  FMC_BCR1_CBURSTRW                  ((uint32_t)0x00080000)        /*!<Write burst enable         */
S#define  FMC_BCR1_CCLKEN                    ((uint32_t)0x00100000)        /*!<Continous clock enable     */
S
S/******************  Bit definition for FMC_BCR2 register  *******************/
S#define  FMC_BCR2_MBKEN                     ((uint32_t)0x00000001)        /*!<Memory bank enable bit                 */
S#define  FMC_BCR2_MUXEN                     ((uint32_t)0x00000002)        /*!<Address/data multiplexing enable bit   */
S
S#define  FMC_BCR2_MTYP                      ((uint32_t)0x0000000C)        /*!<MTYP[1:0] bits (Memory type)           */
S#define  FMC_BCR2_MTYP_0                    ((uint32_t)0x00000004)        /*!<Bit 0 */
S#define  FMC_BCR2_MTYP_1                    ((uint32_t)0x00000008)        /*!<Bit 1 */
S
S#define  FMC_BCR2_MWID                      ((uint32_t)0x00000030)        /*!<MWID[1:0] bits (Memory data bus width) */
S#define  FMC_BCR2_MWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_BCR2_MWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
S
S#define  FMC_BCR2_FACCEN                    ((uint32_t)0x00000040)        /*!<Flash access enable        */
S#define  FMC_BCR2_BURSTEN                   ((uint32_t)0x00000100)        /*!<Burst enable bit           */
S#define  FMC_BCR2_WAITPOL                   ((uint32_t)0x00000200)        /*!<Wait signal polarity bit   */
S#define  FMC_BCR2_WRAPMOD                   ((uint32_t)0x00000400)        /*!<Wrapped burst mode support */
S#define  FMC_BCR2_WAITCFG                   ((uint32_t)0x00000800)        /*!<Wait timing configuration  */
S#define  FMC_BCR2_WREN                      ((uint32_t)0x00001000)        /*!<Write enable bit           */
S#define  FMC_BCR2_WAITEN                    ((uint32_t)0x00002000)        /*!<Wait enable bit            */
S#define  FMC_BCR2_EXTMOD                    ((uint32_t)0x00004000)        /*!<Extended mode enable       */
S#define  FMC_BCR2_ASYNCWAIT                 ((uint32_t)0x00008000)        /*!<Asynchronous wait          */
S#define  FMC_BCR2_CBURSTRW                  ((uint32_t)0x00080000)        /*!<Write burst enable         */
S
S/******************  Bit definition for FMC_BCR3 register  *******************/
S#define  FMC_BCR3_MBKEN                     ((uint32_t)0x00000001)        /*!<Memory bank enable bit                 */
S#define  FMC_BCR3_MUXEN                     ((uint32_t)0x00000002)        /*!<Address/data multiplexing enable bit   */
S
S#define  FMC_BCR3_MTYP                      ((uint32_t)0x0000000C)        /*!<MTYP[1:0] bits (Memory type)           */
S#define  FMC_BCR3_MTYP_0                    ((uint32_t)0x00000004)        /*!<Bit 0 */
S#define  FMC_BCR3_MTYP_1                    ((uint32_t)0x00000008)        /*!<Bit 1 */
S
S#define  FMC_BCR3_MWID                      ((uint32_t)0x00000030)        /*!<MWID[1:0] bits (Memory data bus width) */
S#define  FMC_BCR3_MWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_BCR3_MWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
S
S#define  FMC_BCR3_FACCEN                    ((uint32_t)0x00000040)        /*!<Flash access enable        */
S#define  FMC_BCR3_BURSTEN                   ((uint32_t)0x00000100)        /*!<Burst enable bit           */
S#define  FMC_BCR3_WAITPOL                   ((uint32_t)0x00000200)        /*!<Wait signal polarity bit   */
S#define  FMC_BCR3_WRAPMOD                   ((uint32_t)0x00000400)        /*!<Wrapped burst mode support */
S#define  FMC_BCR3_WAITCFG                   ((uint32_t)0x00000800)        /*!<Wait timing configuration  */
S#define  FMC_BCR3_WREN                      ((uint32_t)0x00001000)        /*!<Write enable bit           */
S#define  FMC_BCR3_WAITEN                    ((uint32_t)0x00002000)        /*!<Wait enable bit            */
S#define  FMC_BCR3_EXTMOD                    ((uint32_t)0x00004000)        /*!<Extended mode enable       */
S#define  FMC_BCR3_ASYNCWAIT                 ((uint32_t)0x00008000)        /*!<Asynchronous wait          */
S#define  FMC_BCR3_CBURSTRW                  ((uint32_t)0x00080000)        /*!<Write burst enable         */
S
S/******************  Bit definition for FMC_BCR4 register  *******************/
S#define  FMC_BCR4_MBKEN                     ((uint32_t)0x00000001)        /*!<Memory bank enable bit                 */
S#define  FMC_BCR4_MUXEN                     ((uint32_t)0x00000002)        /*!<Address/data multiplexing enable bit   */
S
S#define  FMC_BCR4_MTYP                      ((uint32_t)0x0000000C)        /*!<MTYP[1:0] bits (Memory type)           */
S#define  FMC_BCR4_MTYP_0                    ((uint32_t)0x00000004)        /*!<Bit 0 */
S#define  FMC_BCR4_MTYP_1                    ((uint32_t)0x00000008)        /*!<Bit 1 */
S
S#define  FMC_BCR4_MWID                      ((uint32_t)0x00000030)        /*!<MWID[1:0] bits (Memory data bus width) */
S#define  FMC_BCR4_MWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_BCR4_MWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
S
S#define  FMC_BCR4_FACCEN                    ((uint32_t)0x00000040)        /*!<Flash access enable        */
S#define  FMC_BCR4_BURSTEN                   ((uint32_t)0x00000100)        /*!<Burst enable bit           */
S#define  FMC_BCR4_WAITPOL                   ((uint32_t)0x00000200)        /*!<Wait signal polarity bit   */
S#define  FMC_BCR4_WRAPMOD                   ((uint32_t)0x00000400)        /*!<Wrapped burst mode support */
S#define  FMC_BCR4_WAITCFG                   ((uint32_t)0x00000800)        /*!<Wait timing configuration  */
S#define  FMC_BCR4_WREN                      ((uint32_t)0x00001000)        /*!<Write enable bit           */
S#define  FMC_BCR4_WAITEN                    ((uint32_t)0x00002000)        /*!<Wait enable bit            */
S#define  FMC_BCR4_EXTMOD                    ((uint32_t)0x00004000)        /*!<Extended mode enable       */
S#define  FMC_BCR4_ASYNCWAIT                 ((uint32_t)0x00008000)        /*!<Asynchronous wait          */
S#define  FMC_BCR4_CBURSTRW                  ((uint32_t)0x00080000)        /*!<Write burst enable         */
S
S/******************  Bit definition for FMC_BTR1 register  ******************/
S#define  FMC_BTR1_ADDSET                    ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
S#define  FMC_BTR1_ADDSET_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_BTR1_ADDSET_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_BTR1_ADDSET_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_BTR1_ADDSET_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
S
S#define  FMC_BTR1_ADDHLD                    ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration)  */
S#define  FMC_BTR1_ADDHLD_0                  ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_BTR1_ADDHLD_1                  ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FMC_BTR1_ADDHLD_2                  ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FMC_BTR1_ADDHLD_3                  ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FMC_BTR1_DATAST                    ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
S#define  FMC_BTR1_DATAST_0                  ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_BTR1_DATAST_1                  ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_BTR1_DATAST_2                  ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_BTR1_DATAST_3                  ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_BTR1_DATAST_4                  ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_BTR1_DATAST_5                  ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_BTR1_DATAST_6                  ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_BTR1_DATAST_7                  ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_BTR1_BUSTURN                   ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
S#define  FMC_BTR1_BUSTURN_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_BTR1_BUSTURN_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_BTR1_BUSTURN_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_BTR1_BUSTURN_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
S
S#define  FMC_BTR1_CLKDIV                    ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FMC_BTR1_CLKDIV_0                  ((uint32_t)0x00100000)        /*!<Bit 0 */
S#define  FMC_BTR1_CLKDIV_1                  ((uint32_t)0x00200000)        /*!<Bit 1 */
S#define  FMC_BTR1_CLKDIV_2                  ((uint32_t)0x00400000)        /*!<Bit 2 */
S#define  FMC_BTR1_CLKDIV_3                  ((uint32_t)0x00800000)        /*!<Bit 3 */
S
S#define  FMC_BTR1_DATLAT                    ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
S#define  FMC_BTR1_DATLAT_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FMC_BTR1_DATLAT_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FMC_BTR1_DATLAT_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FMC_BTR1_DATLAT_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
S
S#define  FMC_BTR1_ACCMOD                    ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
S#define  FMC_BTR1_ACCMOD_0                  ((uint32_t)0x10000000)        /*!<Bit 0 */
S#define  FMC_BTR1_ACCMOD_1                  ((uint32_t)0x20000000)        /*!<Bit 1 */
S
S/******************  Bit definition for FMC_BTR2 register  *******************/
S#define  FMC_BTR2_ADDSET                    ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
S#define  FMC_BTR2_ADDSET_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_BTR2_ADDSET_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_BTR2_ADDSET_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_BTR2_ADDSET_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
S
S#define  FMC_BTR2_ADDHLD                    ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FMC_BTR2_ADDHLD_0                  ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_BTR2_ADDHLD_1                  ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FMC_BTR2_ADDHLD_2                  ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FMC_BTR2_ADDHLD_3                  ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FMC_BTR2_DATAST                    ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
S#define  FMC_BTR2_DATAST_0                  ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_BTR2_DATAST_1                  ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_BTR2_DATAST_2                  ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_BTR2_DATAST_3                  ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_BTR2_DATAST_4                  ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_BTR2_DATAST_5                  ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_BTR2_DATAST_6                  ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_BTR2_DATAST_7                  ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_BTR2_BUSTURN                   ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
S#define  FMC_BTR2_BUSTURN_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_BTR2_BUSTURN_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_BTR2_BUSTURN_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_BTR2_BUSTURN_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
S
S#define  FMC_BTR2_CLKDIV                    ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FMC_BTR2_CLKDIV_0                  ((uint32_t)0x00100000)        /*!<Bit 0 */
S#define  FMC_BTR2_CLKDIV_1                  ((uint32_t)0x00200000)        /*!<Bit 1 */
S#define  FMC_BTR2_CLKDIV_2                  ((uint32_t)0x00400000)        /*!<Bit 2 */
S#define  FMC_BTR2_CLKDIV_3                  ((uint32_t)0x00800000)        /*!<Bit 3 */
S
S#define  FMC_BTR2_DATLAT                    ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
S#define  FMC_BTR2_DATLAT_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FMC_BTR2_DATLAT_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FMC_BTR2_DATLAT_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FMC_BTR2_DATLAT_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
S
S#define  FMC_BTR2_ACCMOD                    ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
S#define  FMC_BTR2_ACCMOD_0                  ((uint32_t)0x10000000)        /*!<Bit 0 */
S#define  FMC_BTR2_ACCMOD_1                  ((uint32_t)0x20000000)        /*!<Bit 1 */
S
S/*******************  Bit definition for FMC_BTR3 register  *******************/
S#define  FMC_BTR3_ADDSET                    ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
S#define  FMC_BTR3_ADDSET_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_BTR3_ADDSET_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_BTR3_ADDSET_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_BTR3_ADDSET_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
S
S#define  FMC_BTR3_ADDHLD                    ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FMC_BTR3_ADDHLD_0                  ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_BTR3_ADDHLD_1                  ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FMC_BTR3_ADDHLD_2                  ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FMC_BTR3_ADDHLD_3                  ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FMC_BTR3_DATAST                    ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
S#define  FMC_BTR3_DATAST_0                  ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_BTR3_DATAST_1                  ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_BTR3_DATAST_2                  ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_BTR3_DATAST_3                  ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_BTR3_DATAST_4                  ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_BTR3_DATAST_5                  ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_BTR3_DATAST_6                  ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_BTR3_DATAST_7                  ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_BTR3_BUSTURN                   ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
S#define  FMC_BTR3_BUSTURN_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_BTR3_BUSTURN_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_BTR3_BUSTURN_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_BTR3_BUSTURN_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
S
S#define  FMC_BTR3_CLKDIV                    ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FMC_BTR3_CLKDIV_0                  ((uint32_t)0x00100000)        /*!<Bit 0 */
S#define  FMC_BTR3_CLKDIV_1                  ((uint32_t)0x00200000)        /*!<Bit 1 */
S#define  FMC_BTR3_CLKDIV_2                  ((uint32_t)0x00400000)        /*!<Bit 2 */
S#define  FMC_BTR3_CLKDIV_3                  ((uint32_t)0x00800000)        /*!<Bit 3 */
S
S#define  FMC_BTR3_DATLAT                    ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
S#define  FMC_BTR3_DATLAT_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FMC_BTR3_DATLAT_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FMC_BTR3_DATLAT_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FMC_BTR3_DATLAT_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
S
S#define  FMC_BTR3_ACCMOD                    ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
S#define  FMC_BTR3_ACCMOD_0                  ((uint32_t)0x10000000)        /*!<Bit 0 */
S#define  FMC_BTR3_ACCMOD_1                  ((uint32_t)0x20000000)        /*!<Bit 1 */
S
S/******************  Bit definition for FMC_BTR4 register  *******************/
S#define  FMC_BTR4_ADDSET                    ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
S#define  FMC_BTR4_ADDSET_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_BTR4_ADDSET_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_BTR4_ADDSET_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_BTR4_ADDSET_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
S
S#define  FMC_BTR4_ADDHLD                    ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FMC_BTR4_ADDHLD_0                  ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_BTR4_ADDHLD_1                  ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FMC_BTR4_ADDHLD_2                  ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FMC_BTR4_ADDHLD_3                  ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FMC_BTR4_DATAST                    ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
S#define  FMC_BTR4_DATAST_0                  ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_BTR4_DATAST_1                  ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_BTR4_DATAST_2                  ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_BTR4_DATAST_3                  ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_BTR4_DATAST_4                  ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_BTR4_DATAST_5                  ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_BTR4_DATAST_6                  ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_BTR4_DATAST_7                  ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_BTR4_BUSTURN                   ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
S#define  FMC_BTR4_BUSTURN_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_BTR4_BUSTURN_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_BTR4_BUSTURN_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_BTR4_BUSTURN_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
S
S#define  FMC_BTR4_CLKDIV                    ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FMC_BTR4_CLKDIV_0                  ((uint32_t)0x00100000)        /*!<Bit 0 */
S#define  FMC_BTR4_CLKDIV_1                  ((uint32_t)0x00200000)        /*!<Bit 1 */
S#define  FMC_BTR4_CLKDIV_2                  ((uint32_t)0x00400000)        /*!<Bit 2 */
S#define  FMC_BTR4_CLKDIV_3                  ((uint32_t)0x00800000)        /*!<Bit 3 */
S
S#define  FMC_BTR4_DATLAT                    ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
S#define  FMC_BTR4_DATLAT_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FMC_BTR4_DATLAT_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FMC_BTR4_DATLAT_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FMC_BTR4_DATLAT_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
S
S#define  FMC_BTR4_ACCMOD                    ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
S#define  FMC_BTR4_ACCMOD_0                  ((uint32_t)0x10000000)        /*!<Bit 0 */
S#define  FMC_BTR4_ACCMOD_1                  ((uint32_t)0x20000000)        /*!<Bit 1 */
S
S/******************  Bit definition for FMC_BWTR1 register  ******************/
S#define  FMC_BWTR1_ADDSET                   ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
S#define  FMC_BWTR1_ADDSET_0                 ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_BWTR1_ADDSET_1                 ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_BWTR1_ADDSET_2                 ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_BWTR1_ADDSET_3                 ((uint32_t)0x00000008)        /*!<Bit 3 */
S
S#define  FMC_BWTR1_ADDHLD                   ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FMC_BWTR1_ADDHLD_0                 ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_BWTR1_ADDHLD_1                 ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FMC_BWTR1_ADDHLD_2                 ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FMC_BWTR1_ADDHLD_3                 ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FMC_BWTR1_DATAST                   ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
S#define  FMC_BWTR1_DATAST_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_BWTR1_DATAST_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_BWTR1_DATAST_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_BWTR1_DATAST_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_BWTR1_DATAST_4                 ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_BWTR1_DATAST_5                 ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_BWTR1_DATAST_6                 ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_BWTR1_DATAST_7                 ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_BWTR1_BUSTURN                  ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround duration) */
S#define  FMC_BWTR1_BUSTURN_0                ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_BWTR1_BUSTURN_1                ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_BWTR1_BUSTURN_2                ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_BWTR1_BUSTURN_3                ((uint32_t)0x00080000)        /*!<Bit 3 */
S
S#define  FMC_BWTR1_ACCMOD                   ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
S#define  FMC_BWTR1_ACCMOD_0                 ((uint32_t)0x10000000)        /*!<Bit 0 */
S#define  FMC_BWTR1_ACCMOD_1                 ((uint32_t)0x20000000)        /*!<Bit 1 */
S
S/******************  Bit definition for FMC_BWTR2 register  ******************/
S#define  FMC_BWTR2_ADDSET                   ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
S#define  FMC_BWTR2_ADDSET_0                 ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_BWTR2_ADDSET_1                 ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_BWTR2_ADDSET_2                 ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_BWTR2_ADDSET_3                 ((uint32_t)0x00000008)        /*!<Bit 3 */
S
S#define  FMC_BWTR2_ADDHLD                   ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FMC_BWTR2_ADDHLD_0                 ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_BWTR2_ADDHLD_1                 ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FMC_BWTR2_ADDHLD_2                 ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FMC_BWTR2_ADDHLD_3                 ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FMC_BWTR2_DATAST                   ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
S#define  FMC_BWTR2_DATAST_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_BWTR2_DATAST_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_BWTR2_DATAST_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_BWTR2_DATAST_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_BWTR2_DATAST_4                 ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_BWTR2_DATAST_5                 ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_BWTR2_DATAST_6                 ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_BWTR2_DATAST_7                 ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_BWTR2_BUSTURN                  ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround duration) */
S#define  FMC_BWTR2_BUSTURN_0                ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_BWTR2_BUSTURN_1                ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_BWTR2_BUSTURN_2                ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_BWTR2_BUSTURN_3                ((uint32_t)0x00080000)        /*!<Bit 3 */
S
S#define  FMC_BWTR2_ACCMOD                   ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
S#define  FMC_BWTR2_ACCMOD_0                 ((uint32_t)0x10000000)        /*!<Bit 0 */
S#define  FMC_BWTR2_ACCMOD_1                 ((uint32_t)0x20000000)        /*!<Bit 1 */
S
S/******************  Bit definition for FMC_BWTR3 register  ******************/
S#define  FMC_BWTR3_ADDSET                   ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
S#define  FMC_BWTR3_ADDSET_0                 ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_BWTR3_ADDSET_1                 ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_BWTR3_ADDSET_2                 ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_BWTR3_ADDSET_3                 ((uint32_t)0x00000008)        /*!<Bit 3 */
S
S#define  FMC_BWTR3_ADDHLD                   ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FMC_BWTR3_ADDHLD_0                 ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_BWTR3_ADDHLD_1                 ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FMC_BWTR3_ADDHLD_2                 ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FMC_BWTR3_ADDHLD_3                 ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FMC_BWTR3_DATAST                   ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
S#define  FMC_BWTR3_DATAST_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_BWTR3_DATAST_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_BWTR3_DATAST_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_BWTR3_DATAST_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_BWTR3_DATAST_4                 ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_BWTR3_DATAST_5                 ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_BWTR3_DATAST_6                 ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_BWTR3_DATAST_7                 ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_BWTR3_BUSTURN                  ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround duration) */
S#define  FMC_BWTR3_BUSTURN_0                ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_BWTR3_BUSTURN_1                ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_BWTR3_BUSTURN_2                ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_BWTR3_BUSTURN_3                ((uint32_t)0x00080000)        /*!<Bit 3 */
S
S#define  FMC_BWTR3_ACCMOD                   ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
S#define  FMC_BWTR3_ACCMOD_0                 ((uint32_t)0x10000000)        /*!<Bit 0 */
S#define  FMC_BWTR3_ACCMOD_1                 ((uint32_t)0x20000000)        /*!<Bit 1 */
S
S/******************  Bit definition for FMC_BWTR4 register  ******************/
S#define  FMC_BWTR4_ADDSET                   ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
S#define  FMC_BWTR4_ADDSET_0                 ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_BWTR4_ADDSET_1                 ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_BWTR4_ADDSET_2                 ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_BWTR4_ADDSET_3                 ((uint32_t)0x00000008)        /*!<Bit 3 */
S
S#define  FMC_BWTR4_ADDHLD                   ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FMC_BWTR4_ADDHLD_0                 ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_BWTR4_ADDHLD_1                 ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FMC_BWTR4_ADDHLD_2                 ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FMC_BWTR4_ADDHLD_3                 ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FMC_BWTR4_DATAST                   ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
S#define  FMC_BWTR4_DATAST_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_BWTR4_DATAST_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_BWTR4_DATAST_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_BWTR4_DATAST_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_BWTR4_DATAST_4                 ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_BWTR4_DATAST_5                 ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_BWTR4_DATAST_6                 ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_BWTR4_DATAST_7                 ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_BWTR4_BUSTURN                  ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround duration) */
S#define  FMC_BWTR4_BUSTURN_0                ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_BWTR4_BUSTURN_1                ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_BWTR4_BUSTURN_2                ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_BWTR4_BUSTURN_3                ((uint32_t)0x00080000)        /*!<Bit 3 */
S
S#define  FMC_BWTR4_ACCMOD                   ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
S#define  FMC_BWTR4_ACCMOD_0                 ((uint32_t)0x10000000)        /*!<Bit 0 */
S#define  FMC_BWTR4_ACCMOD_1                 ((uint32_t)0x20000000)        /*!<Bit 1 */
S
S/******************  Bit definition for FMC_PCR2 register  *******************/
S#define  FMC_PCR2_PWAITEN                   ((uint32_t)0x00000002)        /*!<Wait feature enable bit                   */
S#define  FMC_PCR2_PBKEN                     ((uint32_t)0x00000004)        /*!<PC Card/NAND Flash memory bank enable bit */
S#define  FMC_PCR2_PTYP                      ((uint32_t)0x00000008)        /*!<Memory type                               */
S
S#define  FMC_PCR2_PWID                      ((uint32_t)0x00000030)        /*!<PWID[1:0] bits (NAND Flash databus width) */
S#define  FMC_PCR2_PWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_PCR2_PWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
S
S#define  FMC_PCR2_ECCEN                     ((uint32_t)0x00000040)        /*!<ECC computation logic enable bit          */
S
S#define  FMC_PCR2_TCLR                      ((uint32_t)0x00001E00)        /*!<TCLR[3:0] bits (CLE to RE delay)          */
S#define  FMC_PCR2_TCLR_0                    ((uint32_t)0x00000200)        /*!<Bit 0 */
S#define  FMC_PCR2_TCLR_1                    ((uint32_t)0x00000400)        /*!<Bit 1 */
S#define  FMC_PCR2_TCLR_2                    ((uint32_t)0x00000800)        /*!<Bit 2 */
S#define  FMC_PCR2_TCLR_3                    ((uint32_t)0x00001000)        /*!<Bit 3 */
S
S#define  FMC_PCR2_TAR                       ((uint32_t)0x0001E000)        /*!<TAR[3:0] bits (ALE to RE delay)           */
S#define  FMC_PCR2_TAR_0                     ((uint32_t)0x00002000)        /*!<Bit 0 */
S#define  FMC_PCR2_TAR_1                     ((uint32_t)0x00004000)        /*!<Bit 1 */
S#define  FMC_PCR2_TAR_2                     ((uint32_t)0x00008000)        /*!<Bit 2 */
S#define  FMC_PCR2_TAR_3                     ((uint32_t)0x00010000)        /*!<Bit 3 */
S
S#define  FMC_PCR2_ECCPS                     ((uint32_t)0x000E0000)        /*!<ECCPS[1:0] bits (ECC page size)           */
S#define  FMC_PCR2_ECCPS_0                   ((uint32_t)0x00020000)        /*!<Bit 0 */
S#define  FMC_PCR2_ECCPS_1                   ((uint32_t)0x00040000)        /*!<Bit 1 */
S#define  FMC_PCR2_ECCPS_2                   ((uint32_t)0x00080000)        /*!<Bit 2 */
S
S/******************  Bit definition for FMC_PCR3 register  *******************/
S#define  FMC_PCR3_PWAITEN                   ((uint32_t)0x00000002)        /*!<Wait feature enable bit                   */
S#define  FMC_PCR3_PBKEN                     ((uint32_t)0x00000004)        /*!<PC Card/NAND Flash memory bank enable bit */
S#define  FMC_PCR3_PTYP                      ((uint32_t)0x00000008)        /*!<Memory type                               */
S
S#define  FMC_PCR3_PWID                      ((uint32_t)0x00000030)        /*!<PWID[1:0] bits (NAND Flash databus width) */
S#define  FMC_PCR3_PWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_PCR3_PWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
S
S#define  FMC_PCR3_ECCEN                     ((uint32_t)0x00000040)        /*!<ECC computation logic enable bit          */
S
S#define  FMC_PCR3_TCLR                      ((uint32_t)0x00001E00)        /*!<TCLR[3:0] bits (CLE to RE delay)          */
S#define  FMC_PCR3_TCLR_0                    ((uint32_t)0x00000200)        /*!<Bit 0 */
S#define  FMC_PCR3_TCLR_1                    ((uint32_t)0x00000400)        /*!<Bit 1 */
S#define  FMC_PCR3_TCLR_2                    ((uint32_t)0x00000800)        /*!<Bit 2 */
S#define  FMC_PCR3_TCLR_3                    ((uint32_t)0x00001000)        /*!<Bit 3 */
S
S#define  FMC_PCR3_TAR                       ((uint32_t)0x0001E000)        /*!<TAR[3:0] bits (ALE to RE delay)           */
S#define  FMC_PCR3_TAR_0                     ((uint32_t)0x00002000)        /*!<Bit 0 */
S#define  FMC_PCR3_TAR_1                     ((uint32_t)0x00004000)        /*!<Bit 1 */
S#define  FMC_PCR3_TAR_2                     ((uint32_t)0x00008000)        /*!<Bit 2 */
S#define  FMC_PCR3_TAR_3                     ((uint32_t)0x00010000)        /*!<Bit 3 */
S
S#define  FMC_PCR3_ECCPS                     ((uint32_t)0x000E0000)        /*!<ECCPS[2:0] bits (ECC page size)           */
S#define  FMC_PCR3_ECCPS_0                   ((uint32_t)0x00020000)        /*!<Bit 0 */
S#define  FMC_PCR3_ECCPS_1                   ((uint32_t)0x00040000)        /*!<Bit 1 */
S#define  FMC_PCR3_ECCPS_2                   ((uint32_t)0x00080000)        /*!<Bit 2 */
S
S/******************  Bit definition for FMC_PCR4 register  *******************/
S#define  FMC_PCR4_PWAITEN                   ((uint32_t)0x00000002)        /*!<Wait feature enable bit                   */
S#define  FMC_PCR4_PBKEN                     ((uint32_t)0x00000004)        /*!<PC Card/NAND Flash memory bank enable bit */
S#define  FMC_PCR4_PTYP                      ((uint32_t)0x00000008)        /*!<Memory type                               */
S
S#define  FMC_PCR4_PWID                      ((uint32_t)0x00000030)        /*!<PWID[1:0] bits (NAND Flash databus width) */
S#define  FMC_PCR4_PWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_PCR4_PWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
S
S#define  FMC_PCR4_ECCEN                     ((uint32_t)0x00000040)        /*!<ECC computation logic enable bit          */
S
S#define  FMC_PCR4_TCLR                      ((uint32_t)0x00001E00)        /*!<TCLR[3:0] bits (CLE to RE delay)          */
S#define  FMC_PCR4_TCLR_0                    ((uint32_t)0x00000200)        /*!<Bit 0 */
S#define  FMC_PCR4_TCLR_1                    ((uint32_t)0x00000400)        /*!<Bit 1 */
S#define  FMC_PCR4_TCLR_2                    ((uint32_t)0x00000800)        /*!<Bit 2 */
S#define  FMC_PCR4_TCLR_3                    ((uint32_t)0x00001000)        /*!<Bit 3 */
S
S#define  FMC_PCR4_TAR                       ((uint32_t)0x0001E000)        /*!<TAR[3:0] bits (ALE to RE delay)           */
S#define  FMC_PCR4_TAR_0                     ((uint32_t)0x00002000)        /*!<Bit 0 */
S#define  FMC_PCR4_TAR_1                     ((uint32_t)0x00004000)        /*!<Bit 1 */
S#define  FMC_PCR4_TAR_2                     ((uint32_t)0x00008000)        /*!<Bit 2 */
S#define  FMC_PCR4_TAR_3                     ((uint32_t)0x00010000)        /*!<Bit 3 */
S
S#define  FMC_PCR4_ECCPS                     ((uint32_t)0x000E0000)        /*!<ECCPS[2:0] bits (ECC page size)           */
S#define  FMC_PCR4_ECCPS_0                   ((uint32_t)0x00020000)        /*!<Bit 0 */
S#define  FMC_PCR4_ECCPS_1                   ((uint32_t)0x00040000)        /*!<Bit 1 */
S#define  FMC_PCR4_ECCPS_2                   ((uint32_t)0x00080000)        /*!<Bit 2 */
S
S/*******************  Bit definition for FMC_SR2 register  *******************/
S#define  FMC_SR2_IRS                        ((uint8_t)0x01)               /*!<Interrupt Rising Edge status                */
S#define  FMC_SR2_ILS                        ((uint8_t)0x02)               /*!<Interrupt Level status                      */
S#define  FMC_SR2_IFS                        ((uint8_t)0x04)               /*!<Interrupt Falling Edge status               */
S#define  FMC_SR2_IREN                       ((uint8_t)0x08)               /*!<Interrupt Rising Edge detection Enable bit  */
S#define  FMC_SR2_ILEN                       ((uint8_t)0x10)               /*!<Interrupt Level detection Enable bit        */
S#define  FMC_SR2_IFEN                       ((uint8_t)0x20)               /*!<Interrupt Falling Edge detection Enable bit */
S#define  FMC_SR2_FEMPT                      ((uint8_t)0x40)               /*!<FIFO empty                                  */
S
S/*******************  Bit definition for FMC_SR3 register  *******************/
S#define  FMC_SR3_IRS                        ((uint8_t)0x01)               /*!<Interrupt Rising Edge status                */
S#define  FMC_SR3_ILS                        ((uint8_t)0x02)               /*!<Interrupt Level status                      */
S#define  FMC_SR3_IFS                        ((uint8_t)0x04)               /*!<Interrupt Falling Edge status               */
S#define  FMC_SR3_IREN                       ((uint8_t)0x08)               /*!<Interrupt Rising Edge detection Enable bit  */
S#define  FMC_SR3_ILEN                       ((uint8_t)0x10)               /*!<Interrupt Level detection Enable bit        */
S#define  FMC_SR3_IFEN                       ((uint8_t)0x20)               /*!<Interrupt Falling Edge detection Enable bit */
S#define  FMC_SR3_FEMPT                      ((uint8_t)0x40)               /*!<FIFO empty                                  */
S
S/*******************  Bit definition for FMC_SR4 register  *******************/
S#define  FMC_SR4_IRS                        ((uint8_t)0x01)               /*!<Interrupt Rising Edge status                */
S#define  FMC_SR4_ILS                        ((uint8_t)0x02)               /*!<Interrupt Level status                      */
S#define  FMC_SR4_IFS                        ((uint8_t)0x04)               /*!<Interrupt Falling Edge status               */
S#define  FMC_SR4_IREN                       ((uint8_t)0x08)               /*!<Interrupt Rising Edge detection Enable bit  */
S#define  FMC_SR4_ILEN                       ((uint8_t)0x10)               /*!<Interrupt Level detection Enable bit        */
S#define  FMC_SR4_IFEN                       ((uint8_t)0x20)               /*!<Interrupt Falling Edge detection Enable bit */
S#define  FMC_SR4_FEMPT                      ((uint8_t)0x40)               /*!<FIFO empty                                  */
S
S/******************  Bit definition for FMC_PMEM2 register  ******************/
S#define  FMC_PMEM2_MEMSET2                  ((uint32_t)0x000000FF)        /*!<MEMSET2[7:0] bits (Common memory 2 setup time) */
S#define  FMC_PMEM2_MEMSET2_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_PMEM2_MEMSET2_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_PMEM2_MEMSET2_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_PMEM2_MEMSET2_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  FMC_PMEM2_MEMSET2_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  FMC_PMEM2_MEMSET2_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
S#define  FMC_PMEM2_MEMSET2_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
S#define  FMC_PMEM2_MEMSET2_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
S
S#define  FMC_PMEM2_MEMWAIT2                 ((uint32_t)0x0000FF00)        /*!<MEMWAIT2[7:0] bits (Common memory 2 wait time) */
S#define  FMC_PMEM2_MEMWAIT2_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_PMEM2_MEMWAIT2_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_PMEM2_MEMWAIT2_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_PMEM2_MEMWAIT2_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_PMEM2_MEMWAIT2_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_PMEM2_MEMWAIT2_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_PMEM2_MEMWAIT2_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_PMEM2_MEMWAIT2_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_PMEM2_MEMHOLD2                 ((uint32_t)0x00FF0000)        /*!<MEMHOLD2[7:0] bits (Common memory 2 hold time) */
S#define  FMC_PMEM2_MEMHOLD2_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_PMEM2_MEMHOLD2_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_PMEM2_MEMHOLD2_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_PMEM2_MEMHOLD2_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
S#define  FMC_PMEM2_MEMHOLD2_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
S#define  FMC_PMEM2_MEMHOLD2_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
S#define  FMC_PMEM2_MEMHOLD2_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
S#define  FMC_PMEM2_MEMHOLD2_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
S
S#define  FMC_PMEM2_MEMHIZ2                  ((uint32_t)0xFF000000)        /*!<MEMHIZ2[7:0] bits (Common memory 2 databus HiZ time) */
S#define  FMC_PMEM2_MEMHIZ2_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FMC_PMEM2_MEMHIZ2_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FMC_PMEM2_MEMHIZ2_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FMC_PMEM2_MEMHIZ2_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
S#define  FMC_PMEM2_MEMHIZ2_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
S#define  FMC_PMEM2_MEMHIZ2_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
S#define  FMC_PMEM2_MEMHIZ2_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
S#define  FMC_PMEM2_MEMHIZ2_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
S
S/******************  Bit definition for FMC_PMEM3 register  ******************/
S#define  FMC_PMEM3_MEMSET3                  ((uint32_t)0x000000FF)        /*!<MEMSET3[7:0] bits (Common memory 3 setup time) */
S#define  FMC_PMEM3_MEMSET3_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_PMEM3_MEMSET3_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_PMEM3_MEMSET3_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_PMEM3_MEMSET3_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  FMC_PMEM3_MEMSET3_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  FMC_PMEM3_MEMSET3_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
S#define  FMC_PMEM3_MEMSET3_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
S#define  FMC_PMEM3_MEMSET3_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
S
S#define  FMC_PMEM3_MEMWAIT3                 ((uint32_t)0x0000FF00)        /*!<MEMWAIT3[7:0] bits (Common memory 3 wait time) */
S#define  FMC_PMEM3_MEMWAIT3_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_PMEM3_MEMWAIT3_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_PMEM3_MEMWAIT3_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_PMEM3_MEMWAIT3_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_PMEM3_MEMWAIT3_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_PMEM3_MEMWAIT3_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_PMEM3_MEMWAIT3_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_PMEM3_MEMWAIT3_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_PMEM3_MEMHOLD3                 ((uint32_t)0x00FF0000)        /*!<MEMHOLD3[7:0] bits (Common memory 3 hold time) */
S#define  FMC_PMEM3_MEMHOLD3_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_PMEM3_MEMHOLD3_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_PMEM3_MEMHOLD3_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_PMEM3_MEMHOLD3_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
S#define  FMC_PMEM3_MEMHOLD3_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
S#define  FMC_PMEM3_MEMHOLD3_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
S#define  FMC_PMEM3_MEMHOLD3_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
S#define  FMC_PMEM3_MEMHOLD3_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
S
S#define  FMC_PMEM3_MEMHIZ3                  ((uint32_t)0xFF000000)        /*!<MEMHIZ3[7:0] bits (Common memory 3 databus HiZ time) */
S#define  FMC_PMEM3_MEMHIZ3_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FMC_PMEM3_MEMHIZ3_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FMC_PMEM3_MEMHIZ3_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FMC_PMEM3_MEMHIZ3_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
S#define  FMC_PMEM3_MEMHIZ3_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
S#define  FMC_PMEM3_MEMHIZ3_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
S#define  FMC_PMEM3_MEMHIZ3_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
S#define  FMC_PMEM3_MEMHIZ3_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
S
S/******************  Bit definition for FMC_PMEM4 register  ******************/
S#define  FMC_PMEM4_MEMSET4                  ((uint32_t)0x000000FF)        /*!<MEMSET4[7:0] bits (Common memory 4 setup time) */
S#define  FMC_PMEM4_MEMSET4_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_PMEM4_MEMSET4_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_PMEM4_MEMSET4_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_PMEM4_MEMSET4_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  FMC_PMEM4_MEMSET4_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  FMC_PMEM4_MEMSET4_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
S#define  FMC_PMEM4_MEMSET4_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
S#define  FMC_PMEM4_MEMSET4_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
S
S#define  FMC_PMEM4_MEMWAIT4                 ((uint32_t)0x0000FF00)        /*!<MEMWAIT4[7:0] bits (Common memory 4 wait time) */
S#define  FMC_PMEM4_MEMWAIT4_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_PMEM4_MEMWAIT4_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_PMEM4_MEMWAIT4_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_PMEM4_MEMWAIT4_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_PMEM4_MEMWAIT4_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_PMEM4_MEMWAIT4_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_PMEM4_MEMWAIT4_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_PMEM4_MEMWAIT4_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_PMEM4_MEMHOLD4                 ((uint32_t)0x00FF0000)        /*!<MEMHOLD4[7:0] bits (Common memory 4 hold time) */
S#define  FMC_PMEM4_MEMHOLD4_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_PMEM4_MEMHOLD4_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_PMEM4_MEMHOLD4_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_PMEM4_MEMHOLD4_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
S#define  FMC_PMEM4_MEMHOLD4_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
S#define  FMC_PMEM4_MEMHOLD4_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
S#define  FMC_PMEM4_MEMHOLD4_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
S#define  FMC_PMEM4_MEMHOLD4_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
S
S#define  FMC_PMEM4_MEMHIZ4                  ((uint32_t)0xFF000000)        /*!<MEMHIZ4[7:0] bits (Common memory 4 databus HiZ time) */
S#define  FMC_PMEM4_MEMHIZ4_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FMC_PMEM4_MEMHIZ4_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FMC_PMEM4_MEMHIZ4_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FMC_PMEM4_MEMHIZ4_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
S#define  FMC_PMEM4_MEMHIZ4_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
S#define  FMC_PMEM4_MEMHIZ4_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
S#define  FMC_PMEM4_MEMHIZ4_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
S#define  FMC_PMEM4_MEMHIZ4_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
S
S/******************  Bit definition for FMC_PATT2 register  ******************/
S#define  FMC_PATT2_ATTSET2                  ((uint32_t)0x000000FF)        /*!<ATTSET2[7:0] bits (Attribute memory 2 setup time) */
S#define  FMC_PATT2_ATTSET2_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_PATT2_ATTSET2_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_PATT2_ATTSET2_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_PATT2_ATTSET2_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  FMC_PATT2_ATTSET2_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  FMC_PATT2_ATTSET2_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
S#define  FMC_PATT2_ATTSET2_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
S#define  FMC_PATT2_ATTSET2_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
S
S#define  FMC_PATT2_ATTWAIT2                 ((uint32_t)0x0000FF00)        /*!<ATTWAIT2[7:0] bits (Attribute memory 2 wait time) */
S#define  FMC_PATT2_ATTWAIT2_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_PATT2_ATTWAIT2_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_PATT2_ATTWAIT2_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_PATT2_ATTWAIT2_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_PATT2_ATTWAIT2_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_PATT2_ATTWAIT2_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_PATT2_ATTWAIT2_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_PATT2_ATTWAIT2_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_PATT2_ATTHOLD2                 ((uint32_t)0x00FF0000)        /*!<ATTHOLD2[7:0] bits (Attribute memory 2 hold time) */
S#define  FMC_PATT2_ATTHOLD2_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_PATT2_ATTHOLD2_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_PATT2_ATTHOLD2_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_PATT2_ATTHOLD2_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
S#define  FMC_PATT2_ATTHOLD2_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
S#define  FMC_PATT2_ATTHOLD2_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
S#define  FMC_PATT2_ATTHOLD2_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
S#define  FMC_PATT2_ATTHOLD2_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
S
S#define  FMC_PATT2_ATTHIZ2                  ((uint32_t)0xFF000000)        /*!<ATTHIZ2[7:0] bits (Attribute memory 2 databus HiZ time) */
S#define  FMC_PATT2_ATTHIZ2_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FMC_PATT2_ATTHIZ2_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FMC_PATT2_ATTHIZ2_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FMC_PATT2_ATTHIZ2_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
S#define  FMC_PATT2_ATTHIZ2_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
S#define  FMC_PATT2_ATTHIZ2_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
S#define  FMC_PATT2_ATTHIZ2_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
S#define  FMC_PATT2_ATTHIZ2_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
S
S/******************  Bit definition for FMC_PATT3 register  ******************/
S#define  FMC_PATT3_ATTSET3                  ((uint32_t)0x000000FF)        /*!<ATTSET3[7:0] bits (Attribute memory 3 setup time) */
S#define  FMC_PATT3_ATTSET3_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_PATT3_ATTSET3_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_PATT3_ATTSET3_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_PATT3_ATTSET3_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  FMC_PATT3_ATTSET3_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  FMC_PATT3_ATTSET3_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
S#define  FMC_PATT3_ATTSET3_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
S#define  FMC_PATT3_ATTSET3_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
S
S#define  FMC_PATT3_ATTWAIT3                 ((uint32_t)0x0000FF00)        /*!<ATTWAIT3[7:0] bits (Attribute memory 3 wait time) */
S#define  FMC_PATT3_ATTWAIT3_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_PATT3_ATTWAIT3_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_PATT3_ATTWAIT3_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_PATT3_ATTWAIT3_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_PATT3_ATTWAIT3_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_PATT3_ATTWAIT3_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_PATT3_ATTWAIT3_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_PATT3_ATTWAIT3_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_PATT3_ATTHOLD3                 ((uint32_t)0x00FF0000)        /*!<ATTHOLD3[7:0] bits (Attribute memory 3 hold time) */
S#define  FMC_PATT3_ATTHOLD3_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_PATT3_ATTHOLD3_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_PATT3_ATTHOLD3_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_PATT3_ATTHOLD3_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
S#define  FMC_PATT3_ATTHOLD3_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
S#define  FMC_PATT3_ATTHOLD3_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
S#define  FMC_PATT3_ATTHOLD3_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
S#define  FMC_PATT3_ATTHOLD3_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
S
S#define  FMC_PATT3_ATTHIZ3                  ((uint32_t)0xFF000000)        /*!<ATTHIZ3[7:0] bits (Attribute memory 3 databus HiZ time) */
S#define  FMC_PATT3_ATTHIZ3_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FMC_PATT3_ATTHIZ3_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FMC_PATT3_ATTHIZ3_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FMC_PATT3_ATTHIZ3_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
S#define  FMC_PATT3_ATTHIZ3_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
S#define  FMC_PATT3_ATTHIZ3_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
S#define  FMC_PATT3_ATTHIZ3_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
S#define  FMC_PATT3_ATTHIZ3_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
S
S/******************  Bit definition for FMC_PATT4 register  ******************/
S#define  FMC_PATT4_ATTSET4                  ((uint32_t)0x000000FF)        /*!<ATTSET4[7:0] bits (Attribute memory 4 setup time) */
S#define  FMC_PATT4_ATTSET4_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_PATT4_ATTSET4_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_PATT4_ATTSET4_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_PATT4_ATTSET4_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  FMC_PATT4_ATTSET4_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  FMC_PATT4_ATTSET4_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
S#define  FMC_PATT4_ATTSET4_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
S#define  FMC_PATT4_ATTSET4_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
S
S#define  FMC_PATT4_ATTWAIT4                 ((uint32_t)0x0000FF00)        /*!<ATTWAIT4[7:0] bits (Attribute memory 4 wait time) */
S#define  FMC_PATT4_ATTWAIT4_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_PATT4_ATTWAIT4_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_PATT4_ATTWAIT4_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_PATT4_ATTWAIT4_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_PATT4_ATTWAIT4_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_PATT4_ATTWAIT4_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_PATT4_ATTWAIT4_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_PATT4_ATTWAIT4_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_PATT4_ATTHOLD4                 ((uint32_t)0x00FF0000)        /*!<ATTHOLD4[7:0] bits (Attribute memory 4 hold time) */
S#define  FMC_PATT4_ATTHOLD4_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_PATT4_ATTHOLD4_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_PATT4_ATTHOLD4_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_PATT4_ATTHOLD4_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
S#define  FMC_PATT4_ATTHOLD4_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
S#define  FMC_PATT4_ATTHOLD4_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
S#define  FMC_PATT4_ATTHOLD4_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
S#define  FMC_PATT4_ATTHOLD4_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
S
S#define  FMC_PATT4_ATTHIZ4                  ((uint32_t)0xFF000000)        /*!<ATTHIZ4[7:0] bits (Attribute memory 4 databus HiZ time) */
S#define  FMC_PATT4_ATTHIZ4_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FMC_PATT4_ATTHIZ4_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FMC_PATT4_ATTHIZ4_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FMC_PATT4_ATTHIZ4_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
S#define  FMC_PATT4_ATTHIZ4_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
S#define  FMC_PATT4_ATTHIZ4_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
S#define  FMC_PATT4_ATTHIZ4_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
S#define  FMC_PATT4_ATTHIZ4_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
S
S/******************  Bit definition for FMC_PIO4 register  *******************/
S#define  FMC_PIO4_IOSET4                    ((uint32_t)0x000000FF)        /*!<IOSET4[7:0] bits (I/O 4 setup time) */
S#define  FMC_PIO4_IOSET4_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_PIO4_IOSET4_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_PIO4_IOSET4_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_PIO4_IOSET4_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  FMC_PIO4_IOSET4_4                  ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  FMC_PIO4_IOSET4_5                  ((uint32_t)0x00000020)        /*!<Bit 5 */
S#define  FMC_PIO4_IOSET4_6                  ((uint32_t)0x00000040)        /*!<Bit 6 */
S#define  FMC_PIO4_IOSET4_7                  ((uint32_t)0x00000080)        /*!<Bit 7 */
S
S#define  FMC_PIO4_IOWAIT4                   ((uint32_t)0x0000FF00)        /*!<IOWAIT4[7:0] bits (I/O 4 wait time) */
S#define  FMC_PIO4_IOWAIT4_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_PIO4_IOWAIT4_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_PIO4_IOWAIT4_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_PIO4_IOWAIT4_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_PIO4_IOWAIT4_4                 ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_PIO4_IOWAIT4_5                 ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_PIO4_IOWAIT4_6                 ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_PIO4_IOWAIT4_7                 ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_PIO4_IOHOLD4                   ((uint32_t)0x00FF0000)        /*!<IOHOLD4[7:0] bits (I/O 4 hold time) */
S#define  FMC_PIO4_IOHOLD4_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_PIO4_IOHOLD4_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_PIO4_IOHOLD4_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_PIO4_IOHOLD4_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
S#define  FMC_PIO4_IOHOLD4_4                 ((uint32_t)0x00100000)        /*!<Bit 4 */
S#define  FMC_PIO4_IOHOLD4_5                 ((uint32_t)0x00200000)        /*!<Bit 5 */
S#define  FMC_PIO4_IOHOLD4_6                 ((uint32_t)0x00400000)        /*!<Bit 6 */
S#define  FMC_PIO4_IOHOLD4_7                 ((uint32_t)0x00800000)        /*!<Bit 7 */
S
S#define  FMC_PIO4_IOHIZ4                    ((uint32_t)0xFF000000)        /*!<IOHIZ4[7:0] bits (I/O 4 databus HiZ time) */
S#define  FMC_PIO4_IOHIZ4_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FMC_PIO4_IOHIZ4_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FMC_PIO4_IOHIZ4_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FMC_PIO4_IOHIZ4_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
S#define  FMC_PIO4_IOHIZ4_4                  ((uint32_t)0x10000000)        /*!<Bit 4 */
S#define  FMC_PIO4_IOHIZ4_5                  ((uint32_t)0x20000000)        /*!<Bit 5 */
S#define  FMC_PIO4_IOHIZ4_6                  ((uint32_t)0x40000000)        /*!<Bit 6 */
S#define  FMC_PIO4_IOHIZ4_7                  ((uint32_t)0x80000000)        /*!<Bit 7 */
S
S/******************  Bit definition for FMC_ECCR2 register  ******************/
S#define  FMC_ECCR2_ECC2                     ((uint32_t)0xFFFFFFFF)        /*!<ECC result */
S
S/******************  Bit definition for FMC_ECCR3 register  ******************/
S#define  FMC_ECCR3_ECC3                     ((uint32_t)0xFFFFFFFF)        /*!<ECC result */
S
S/******************  Bit definition for FMC_SDCR1 register  ******************/
S#define  FMC_SDCR1_NC                       ((uint32_t)0x00000003)        /*!<NC[1:0] bits (Number of column bits) */
S#define  FMC_SDCR1_NC_0                     ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_SDCR1_NC_1                     ((uint32_t)0x00000002)        /*!<Bit 1 */
S
S#define  FMC_SDCR1_NR                       ((uint32_t)0x0000000C)        /*!<NR[1:0] bits (Number of row bits) */
S#define  FMC_SDCR1_NR_0                     ((uint32_t)0x00000004)        /*!<Bit 0 */
S#define  FMC_SDCR1_NR_1                     ((uint32_t)0x00000008)        /*!<Bit 1 */
S
S#define  FMC_SDCR1_MWID                     ((uint32_t)0x00000030)        /*!<NR[1:0] bits (Number of row bits) */
S#define  FMC_SDCR1_MWID_0                   ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_SDCR1_MWID_1                   ((uint32_t)0x00000020)        /*!<Bit 1 */
S
S#define  FMC_SDCR1_NB                       ((uint32_t)0x00000040)        /*!<Number of internal bank */
S
S#define  FMC_SDCR1_CAS                      ((uint32_t)0x00000180)        /*!<CAS[1:0] bits (CAS latency) */
S#define  FMC_SDCR1_CAS_0                    ((uint32_t)0x00000080)        /*!<Bit 0 */
S#define  FMC_SDCR1_CAS_1                    ((uint32_t)0x00000100)        /*!<Bit 1 */
S
S#define  FMC_SDCR1_WP                       ((uint32_t)0x00000200)        /*!<Write protection */
S
S#define  FMC_SDCR1_SDCLK                    ((uint32_t)0x00000C00)        /*!<SDRAM clock configuration */
S#define  FMC_SDCR1_SDCLK_0                  ((uint32_t)0x00000400)        /*!<Bit 0 */
S#define  FMC_SDCR1_SDCLK_1                  ((uint32_t)0x00000800)        /*!<Bit 1 */
S
S#define  FMC_SDCR1_RBURST                   ((uint32_t)0x00001000)        /*!<Read burst */
S
S#define  FMC_SDCR1_RPIPE                    ((uint32_t)0x00006000)        /*!<Write protection */
S#define  FMC_SDCR1_RPIPE_0                  ((uint32_t)0x00002000)        /*!<Bit 0 */
S#define  FMC_SDCR1_RPIPE_1                  ((uint32_t)0x00004000)        /*!<Bit 1 */
S
S/******************  Bit definition for FMC_SDCR2 register  ******************/
S#define  FMC_SDCR2_NC                       ((uint32_t)0x00000003)        /*!<NC[1:0] bits (Number of column bits) */
S#define  FMC_SDCR2_NC_0                     ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_SDCR2_NC_1                     ((uint32_t)0x00000002)        /*!<Bit 1 */
S
S#define  FMC_SDCR2_NR                       ((uint32_t)0x0000000C)        /*!<NR[1:0] bits (Number of row bits) */
S#define  FMC_SDCR2_NR_0                     ((uint32_t)0x00000004)        /*!<Bit 0 */
S#define  FMC_SDCR2_NR_1                     ((uint32_t)0x00000008)        /*!<Bit 1 */
S
S#define  FMC_SDCR2_MWID                     ((uint32_t)0x00000030)        /*!<NR[1:0] bits (Number of row bits) */
S#define  FMC_SDCR2_MWID_0                   ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_SDCR2_MWID_1                   ((uint32_t)0x00000020)        /*!<Bit 1 */
S
S#define  FMC_SDCR2_NB                       ((uint32_t)0x00000040)        /*!<Number of internal bank */
S
S#define  FMC_SDCR2_CAS                      ((uint32_t)0x00000180)        /*!<CAS[1:0] bits (CAS latency) */
S#define  FMC_SDCR2_CAS_0                    ((uint32_t)0x00000080)        /*!<Bit 0 */
S#define  FMC_SDCR2_CAS_1                    ((uint32_t)0x00000100)        /*!<Bit 1 */
S
S#define  FMC_SDCR2_WP                       ((uint32_t)0x00000200)        /*!<Write protection */
S
S#define  FMC_SDCR2_SDCLK                    ((uint32_t)0x00000C00)        /*!<SDCLK[1:0] (SDRAM clock configuration) */
S#define  FMC_SDCR2_SDCLK_0                  ((uint32_t)0x00000400)        /*!<Bit 0 */
S#define  FMC_SDCR2_SDCLK_1                  ((uint32_t)0x00000800)        /*!<Bit 1 */
S
S#define  FMC_SDCR2_RBURST                   ((uint32_t)0x00001000)        /*!<Read burst */
S
S#define  FMC_SDCR2_RPIPE                    ((uint32_t)0x00006000)        /*!<RPIPE[1:0](Read pipe) */
S#define  FMC_SDCR2_RPIPE_0                  ((uint32_t)0x00002000)        /*!<Bit 0 */
S#define  FMC_SDCR2_RPIPE_1                  ((uint32_t)0x00004000)        /*!<Bit 1 */
S
S/******************  Bit definition for FMC_SDTR1 register  ******************/
S#define  FMC_SDTR1_TMRD                     ((uint32_t)0x0000000F)        /*!<TMRD[3:0] bits (Load mode register to active) */
S#define  FMC_SDTR1_TMRD_0                   ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_SDTR1_TMRD_1                   ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_SDTR1_TMRD_2                   ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_SDTR1_TMRD_3                   ((uint32_t)0x00000008)        /*!<Bit 3 */
S                                            
S#define  FMC_SDTR1_TXSR                     ((uint32_t)0x000000F0)        /*!<TXSR[3:0] bits (Exit self refresh) */
S#define  FMC_SDTR1_TXSR_0                   ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_SDTR1_TXSR_1                   ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FMC_SDTR1_TXSR_2                   ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FMC_SDTR1_TXSR_3                   ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FMC_SDTR1_TRAS                     ((uint32_t)0x00000F00)        /*!<TRAS[3:0] bits (Self refresh time) */
S#define  FMC_SDTR1_TRAS_0                   ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_SDTR1_TRAS_1                   ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_SDTR1_TRAS_2                   ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_SDTR1_TRAS_3                   ((uint32_t)0x00000800)        /*!<Bit 3 */
S
S#define  FMC_SDTR1_TRC                      ((uint32_t)0x0000F000)        /*!<TRC[2:0] bits (Row cycle delay) */
S#define  FMC_SDTR1_TRC_0                    ((uint32_t)0x00001000)        /*!<Bit 0 */
S#define  FMC_SDTR1_TRC_1                    ((uint32_t)0x00002000)        /*!<Bit 1 */
S#define  FMC_SDTR1_TRC_2                    ((uint32_t)0x00004000)        /*!<Bit 2 */
S
S#define  FMC_SDTR1_TWR                      ((uint32_t)0x000F0000)        /*!<TRC[2:0] bits (Write recovery delay) */
S#define  FMC_SDTR1_TWR_0                    ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_SDTR1_TWR_1                    ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_SDTR1_TWR_2                    ((uint32_t)0x00040000)        /*!<Bit 2 */
S
S#define  FMC_SDTR1_TRP                      ((uint32_t)0x00F00000)        /*!<TRP[2:0] bits (Row precharge delay) */
S#define  FMC_SDTR1_TRP_0                    ((uint32_t)0x00100000)        /*!<Bit 0 */
S#define  FMC_SDTR1_TRP_1                    ((uint32_t)0x00200000)        /*!<Bit 1 */
S#define  FMC_SDTR1_TRP_2                    ((uint32_t)0x00400000)        /*!<Bit 2 */
S
S#define  FMC_SDTR1_TRCD                     ((uint32_t)0x0F000000)        /*!<TRP[2:0] bits (Row to column delay) */
S#define  FMC_SDTR1_TRCD_0                   ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FMC_SDTR1_TRCD_1                   ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FMC_SDTR1_TRCD_2                   ((uint32_t)0x04000000)        /*!<Bit 2 */
S
S/******************  Bit definition for FMC_SDTR2 register  ******************/
S#define  FMC_SDTR2_TMRD                     ((uint32_t)0x0000000F)        /*!<TMRD[3:0] bits (Load mode register to active) */
S#define  FMC_SDTR2_TMRD_0                   ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_SDTR2_TMRD_1                   ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_SDTR2_TMRD_2                   ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_SDTR2_TMRD_3                   ((uint32_t)0x00000008)        /*!<Bit 3 */
S                                            
S#define  FMC_SDTR2_TXSR                     ((uint32_t)0x000000F0)        /*!<TXSR[3:0] bits (Exit self refresh) */
S#define  FMC_SDTR2_TXSR_0                   ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_SDTR2_TXSR_1                   ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FMC_SDTR2_TXSR_2                   ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FMC_SDTR2_TXSR_3                   ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FMC_SDTR2_TRAS                     ((uint32_t)0x00000F00)        /*!<TRAS[3:0] bits (Self refresh time) */
S#define  FMC_SDTR2_TRAS_0                   ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_SDTR2_TRAS_1                   ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_SDTR2_TRAS_2                   ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_SDTR2_TRAS_3                   ((uint32_t)0x00000800)        /*!<Bit 3 */
S
S#define  FMC_SDTR2_TRC                      ((uint32_t)0x0000F000)        /*!<TRC[2:0] bits (Row cycle delay) */
S#define  FMC_SDTR2_TRC_0                    ((uint32_t)0x00001000)        /*!<Bit 0 */
S#define  FMC_SDTR2_TRC_1                    ((uint32_t)0x00002000)        /*!<Bit 1 */
S#define  FMC_SDTR2_TRC_2                    ((uint32_t)0x00004000)        /*!<Bit 2 */
S
S#define  FMC_SDTR2_TWR                      ((uint32_t)0x000F0000)        /*!<TRC[2:0] bits (Write recovery delay) */
S#define  FMC_SDTR2_TWR_0                    ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_SDTR2_TWR_1                    ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_SDTR2_TWR_2                    ((uint32_t)0x00040000)        /*!<Bit 2 */
S
S#define  FMC_SDTR2_TRP                      ((uint32_t)0x00F00000)        /*!<TRP[2:0] bits (Row precharge delay) */
S#define  FMC_SDTR2_TRP_0                    ((uint32_t)0x00100000)        /*!<Bit 0 */
S#define  FMC_SDTR2_TRP_1                    ((uint32_t)0x00200000)        /*!<Bit 1 */
S#define  FMC_SDTR2_TRP_2                    ((uint32_t)0x00400000)        /*!<Bit 2 */
S
S#define  FMC_SDTR2_TRCD                     ((uint32_t)0x0F000000)        /*!<TRP[2:0] bits (Row to column delay) */
S#define  FMC_SDTR2_TRCD_0                   ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FMC_SDTR2_TRCD_1                   ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FMC_SDTR2_TRCD_2                   ((uint32_t)0x04000000)        /*!<Bit 2 */
S
S/******************  Bit definition for FMC_SDCMR register  ******************/
S#define  FMC_SDCMR_MODE                     ((uint32_t)0x00000007)        /*!<MODE[2:0] bits (Command mode) */
S#define  FMC_SDCMR_MODE_0                   ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_SDCMR_MODE_1                   ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_SDCMR_MODE_2                   ((uint32_t)0x00000003)        /*!<Bit 2 */
S                                            
S#define  FMC_SDCMR_CTB2                     ((uint32_t)0x00000008)        /*!<Command target 2 */
S
S#define  FMC_SDCMR_CTB1                     ((uint32_t)0x00000010)        /*!<Command target 1 */
S
S#define  FMC_SDCMR_NRFS                     ((uint32_t)0x000001E0)        /*!<NRFS[3:0] bits (Number of auto-refresh) */
S#define  FMC_SDCMR_NRFS_0                   ((uint32_t)0x00000020)        /*!<Bit 0 */
S#define  FMC_SDCMR_NRFS_1                   ((uint32_t)0x00000040)        /*!<Bit 1 */
S#define  FMC_SDCMR_NRFS_2                   ((uint32_t)0x00000080)        /*!<Bit 2 */
S#define  FMC_SDCMR_NRFS_3                   ((uint32_t)0x00000100)        /*!<Bit 3 */
S
S#define  FMC_SDCMR_MRD                      ((uint32_t)0x003FFE00)        /*!<MRD[12:0] bits (Mode register definition) */
S
S/******************  Bit definition for FMC_SDRTR register  ******************/
S#define  FMC_SDRTR_CRE                      ((uint32_t)0x00000001)        /*!<Clear refresh error flag */
S
S#define  FMC_SDRTR_COUNT                    ((uint32_t)0x00003FFE)        /*!<COUNT[12:0] bits (Refresh timer count) */
S
S#define  FMC_SDRTR_REIE                     ((uint32_t)0x00004000)        /*!<RES interupt enable */
S
S/******************  Bit definition for FMC_SDSR register  ******************/
S#define  FMC_SDSR_RE                        ((uint32_t)0x00000001)        /*!<Refresh error flag */
S
S#define  FMC_SDSR_MODES1                    ((uint32_t)0x00000006)        /*!<MODES1[1:0]bits (Status mode for bank 1) */
S#define  FMC_SDSR_MODES1_0                  ((uint32_t)0x00000002)        /*!<Bit 0 */
S#define  FMC_SDSR_MODES1_1                  ((uint32_t)0x00000004)        /*!<Bit 1 */
S
S#define  FMC_SDSR_MODES2                    ((uint32_t)0x00000018)        /*!<MODES2[1:0]bits (Status mode for bank 2) */
S#define  FMC_SDSR_MODES2_0                  ((uint32_t)0x00000008)        /*!<Bit 0 */
S#define  FMC_SDSR_MODES2_1                  ((uint32_t)0x00000010)        /*!<Bit 1 */
S
S#define  FMC_SDSR_BUSY                      ((uint32_t)0x00000020)        /*!<Busy status */
S
N#endif /* STM32F427_437xx ||  STM32F429_439xx || STM32F446xx || STM32F469_479xx */
N
N/******************************************************************************/
N/*                                                                            */
N/*                            General Purpose I/O                             */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bits definition for GPIO_MODER register  *****************/
N#define GPIO_MODER_MODER0                    ((uint32_t)0x00000003)
N#define GPIO_MODER_MODER0_0                  ((uint32_t)0x00000001)
N#define GPIO_MODER_MODER0_1                  ((uint32_t)0x00000002)
N
N#define GPIO_MODER_MODER1                    ((uint32_t)0x0000000C)
N#define GPIO_MODER_MODER1_0                  ((uint32_t)0x00000004)
N#define GPIO_MODER_MODER1_1                  ((uint32_t)0x00000008)
N
N#define GPIO_MODER_MODER2                    ((uint32_t)0x00000030)
N#define GPIO_MODER_MODER2_0                  ((uint32_t)0x00000010)
N#define GPIO_MODER_MODER2_1                  ((uint32_t)0x00000020)
N
N#define GPIO_MODER_MODER3                    ((uint32_t)0x000000C0)
N#define GPIO_MODER_MODER3_0                  ((uint32_t)0x00000040)
N#define GPIO_MODER_MODER3_1                  ((uint32_t)0x00000080)
N
N#define GPIO_MODER_MODER4                    ((uint32_t)0x00000300)
N#define GPIO_MODER_MODER4_0                  ((uint32_t)0x00000100)
N#define GPIO_MODER_MODER4_1                  ((uint32_t)0x00000200)
N
N#define GPIO_MODER_MODER5                    ((uint32_t)0x00000C00)
N#define GPIO_MODER_MODER5_0                  ((uint32_t)0x00000400)
N#define GPIO_MODER_MODER5_1                  ((uint32_t)0x00000800)
N
N#define GPIO_MODER_MODER6                    ((uint32_t)0x00003000)
N#define GPIO_MODER_MODER6_0                  ((uint32_t)0x00001000)
N#define GPIO_MODER_MODER6_1                  ((uint32_t)0x00002000)
N
N#define GPIO_MODER_MODER7                    ((uint32_t)0x0000C000)
N#define GPIO_MODER_MODER7_0                  ((uint32_t)0x00004000)
N#define GPIO_MODER_MODER7_1                  ((uint32_t)0x00008000)
N
N#define GPIO_MODER_MODER8                    ((uint32_t)0x00030000)
N#define GPIO_MODER_MODER8_0                  ((uint32_t)0x00010000)
N#define GPIO_MODER_MODER8_1                  ((uint32_t)0x00020000)
N
N#define GPIO_MODER_MODER9                    ((uint32_t)0x000C0000)
N#define GPIO_MODER_MODER9_0                  ((uint32_t)0x00040000)
N#define GPIO_MODER_MODER9_1                  ((uint32_t)0x00080000)
N
N#define GPIO_MODER_MODER10                   ((uint32_t)0x00300000)
N#define GPIO_MODER_MODER10_0                 ((uint32_t)0x00100000)
N#define GPIO_MODER_MODER10_1                 ((uint32_t)0x00200000)
N
N#define GPIO_MODER_MODER11                   ((uint32_t)0x00C00000)
N#define GPIO_MODER_MODER11_0                 ((uint32_t)0x00400000)
N#define GPIO_MODER_MODER11_1                 ((uint32_t)0x00800000)
N
N#define GPIO_MODER_MODER12                   ((uint32_t)0x03000000)
N#define GPIO_MODER_MODER12_0                 ((uint32_t)0x01000000)
N#define GPIO_MODER_MODER12_1                 ((uint32_t)0x02000000)
N
N#define GPIO_MODER_MODER13                   ((uint32_t)0x0C000000)
N#define GPIO_MODER_MODER13_0                 ((uint32_t)0x04000000)
N#define GPIO_MODER_MODER13_1                 ((uint32_t)0x08000000)
N
N#define GPIO_MODER_MODER14                   ((uint32_t)0x30000000)
N#define GPIO_MODER_MODER14_0                 ((uint32_t)0x10000000)
N#define GPIO_MODER_MODER14_1                 ((uint32_t)0x20000000)
N
N#define GPIO_MODER_MODER15                   ((uint32_t)0xC0000000)
N#define GPIO_MODER_MODER15_0                 ((uint32_t)0x40000000)
N#define GPIO_MODER_MODER15_1                 ((uint32_t)0x80000000)
N
N/******************  Bits definition for GPIO_OTYPER register  ****************/
N#define GPIO_OTYPER_OT_0                     ((uint32_t)0x00000001)
N#define GPIO_OTYPER_OT_1                     ((uint32_t)0x00000002)
N#define GPIO_OTYPER_OT_2                     ((uint32_t)0x00000004)
N#define GPIO_OTYPER_OT_3                     ((uint32_t)0x00000008)
N#define GPIO_OTYPER_OT_4                     ((uint32_t)0x00000010)
N#define GPIO_OTYPER_OT_5                     ((uint32_t)0x00000020)
N#define GPIO_OTYPER_OT_6                     ((uint32_t)0x00000040)
N#define GPIO_OTYPER_OT_7                     ((uint32_t)0x00000080)
N#define GPIO_OTYPER_OT_8                     ((uint32_t)0x00000100)
N#define GPIO_OTYPER_OT_9                     ((uint32_t)0x00000200)
N#define GPIO_OTYPER_OT_10                    ((uint32_t)0x00000400)
N#define GPIO_OTYPER_OT_11                    ((uint32_t)0x00000800)
N#define GPIO_OTYPER_OT_12                    ((uint32_t)0x00001000)
N#define GPIO_OTYPER_OT_13                    ((uint32_t)0x00002000)
N#define GPIO_OTYPER_OT_14                    ((uint32_t)0x00004000)
N#define GPIO_OTYPER_OT_15                    ((uint32_t)0x00008000)
N
N/******************  Bits definition for GPIO_OSPEEDR register  ***************/
N#define GPIO_OSPEEDER_OSPEEDR0               ((uint32_t)0x00000003)
N#define GPIO_OSPEEDER_OSPEEDR0_0             ((uint32_t)0x00000001)
N#define GPIO_OSPEEDER_OSPEEDR0_1             ((uint32_t)0x00000002)
N
N#define GPIO_OSPEEDER_OSPEEDR1               ((uint32_t)0x0000000C)
N#define GPIO_OSPEEDER_OSPEEDR1_0             ((uint32_t)0x00000004)
N#define GPIO_OSPEEDER_OSPEEDR1_1             ((uint32_t)0x00000008)
N
N#define GPIO_OSPEEDER_OSPEEDR2               ((uint32_t)0x00000030)
N#define GPIO_OSPEEDER_OSPEEDR2_0             ((uint32_t)0x00000010)
N#define GPIO_OSPEEDER_OSPEEDR2_1             ((uint32_t)0x00000020)
N
N#define GPIO_OSPEEDER_OSPEEDR3               ((uint32_t)0x000000C0)
N#define GPIO_OSPEEDER_OSPEEDR3_0             ((uint32_t)0x00000040)
N#define GPIO_OSPEEDER_OSPEEDR3_1             ((uint32_t)0x00000080)
N
N#define GPIO_OSPEEDER_OSPEEDR4               ((uint32_t)0x00000300)
N#define GPIO_OSPEEDER_OSPEEDR4_0             ((uint32_t)0x00000100)
N#define GPIO_OSPEEDER_OSPEEDR4_1             ((uint32_t)0x00000200)
N
N#define GPIO_OSPEEDER_OSPEEDR5               ((uint32_t)0x00000C00)
N#define GPIO_OSPEEDER_OSPEEDR5_0             ((uint32_t)0x00000400)
N#define GPIO_OSPEEDER_OSPEEDR5_1             ((uint32_t)0x00000800)
N
N#define GPIO_OSPEEDER_OSPEEDR6               ((uint32_t)0x00003000)
N#define GPIO_OSPEEDER_OSPEEDR6_0             ((uint32_t)0x00001000)
N#define GPIO_OSPEEDER_OSPEEDR6_1             ((uint32_t)0x00002000)
N
N#define GPIO_OSPEEDER_OSPEEDR7               ((uint32_t)0x0000C000)
N#define GPIO_OSPEEDER_OSPEEDR7_0             ((uint32_t)0x00004000)
N#define GPIO_OSPEEDER_OSPEEDR7_1             ((uint32_t)0x00008000)
N
N#define GPIO_OSPEEDER_OSPEEDR8               ((uint32_t)0x00030000)
N#define GPIO_OSPEEDER_OSPEEDR8_0             ((uint32_t)0x00010000)
N#define GPIO_OSPEEDER_OSPEEDR8_1             ((uint32_t)0x00020000)
N
N#define GPIO_OSPEEDER_OSPEEDR9               ((uint32_t)0x000C0000)
N#define GPIO_OSPEEDER_OSPEEDR9_0             ((uint32_t)0x00040000)
N#define GPIO_OSPEEDER_OSPEEDR9_1             ((uint32_t)0x00080000)
N
N#define GPIO_OSPEEDER_OSPEEDR10              ((uint32_t)0x00300000)
N#define GPIO_OSPEEDER_OSPEEDR10_0            ((uint32_t)0x00100000)
N#define GPIO_OSPEEDER_OSPEEDR10_1            ((uint32_t)0x00200000)
N
N#define GPIO_OSPEEDER_OSPEEDR11              ((uint32_t)0x00C00000)
N#define GPIO_OSPEEDER_OSPEEDR11_0            ((uint32_t)0x00400000)
N#define GPIO_OSPEEDER_OSPEEDR11_1            ((uint32_t)0x00800000)
N
N#define GPIO_OSPEEDER_OSPEEDR12              ((uint32_t)0x03000000)
N#define GPIO_OSPEEDER_OSPEEDR12_0            ((uint32_t)0x01000000)
N#define GPIO_OSPEEDER_OSPEEDR12_1            ((uint32_t)0x02000000)
N
N#define GPIO_OSPEEDER_OSPEEDR13              ((uint32_t)0x0C000000)
N#define GPIO_OSPEEDER_OSPEEDR13_0            ((uint32_t)0x04000000)
N#define GPIO_OSPEEDER_OSPEEDR13_1            ((uint32_t)0x08000000)
N
N#define GPIO_OSPEEDER_OSPEEDR14              ((uint32_t)0x30000000)
N#define GPIO_OSPEEDER_OSPEEDR14_0            ((uint32_t)0x10000000)
N#define GPIO_OSPEEDER_OSPEEDR14_1            ((uint32_t)0x20000000)
N
N#define GPIO_OSPEEDER_OSPEEDR15              ((uint32_t)0xC0000000)
N#define GPIO_OSPEEDER_OSPEEDR15_0            ((uint32_t)0x40000000)
N#define GPIO_OSPEEDER_OSPEEDR15_1            ((uint32_t)0x80000000)
N
N/******************  Bits definition for GPIO_PUPDR register  *****************/
N#define GPIO_PUPDR_PUPDR0                    ((uint32_t)0x00000003)
N#define GPIO_PUPDR_PUPDR0_0                  ((uint32_t)0x00000001)
N#define GPIO_PUPDR_PUPDR0_1                  ((uint32_t)0x00000002)
N
N#define GPIO_PUPDR_PUPDR1                    ((uint32_t)0x0000000C)
N#define GPIO_PUPDR_PUPDR1_0                  ((uint32_t)0x00000004)
N#define GPIO_PUPDR_PUPDR1_1                  ((uint32_t)0x00000008)
N
N#define GPIO_PUPDR_PUPDR2                    ((uint32_t)0x00000030)
N#define GPIO_PUPDR_PUPDR2_0                  ((uint32_t)0x00000010)
N#define GPIO_PUPDR_PUPDR2_1                  ((uint32_t)0x00000020)
N
N#define GPIO_PUPDR_PUPDR3                    ((uint32_t)0x000000C0)
N#define GPIO_PUPDR_PUPDR3_0                  ((uint32_t)0x00000040)
N#define GPIO_PUPDR_PUPDR3_1                  ((uint32_t)0x00000080)
N
N#define GPIO_PUPDR_PUPDR4                    ((uint32_t)0x00000300)
N#define GPIO_PUPDR_PUPDR4_0                  ((uint32_t)0x00000100)
N#define GPIO_PUPDR_PUPDR4_1                  ((uint32_t)0x00000200)
N
N#define GPIO_PUPDR_PUPDR5                    ((uint32_t)0x00000C00)
N#define GPIO_PUPDR_PUPDR5_0                  ((uint32_t)0x00000400)
N#define GPIO_PUPDR_PUPDR5_1                  ((uint32_t)0x00000800)
N
N#define GPIO_PUPDR_PUPDR6                    ((uint32_t)0x00003000)
N#define GPIO_PUPDR_PUPDR6_0                  ((uint32_t)0x00001000)
N#define GPIO_PUPDR_PUPDR6_1                  ((uint32_t)0x00002000)
N
N#define GPIO_PUPDR_PUPDR7                    ((uint32_t)0x0000C000)
N#define GPIO_PUPDR_PUPDR7_0                  ((uint32_t)0x00004000)
N#define GPIO_PUPDR_PUPDR7_1                  ((uint32_t)0x00008000)
N
N#define GPIO_PUPDR_PUPDR8                    ((uint32_t)0x00030000)
N#define GPIO_PUPDR_PUPDR8_0                  ((uint32_t)0x00010000)
N#define GPIO_PUPDR_PUPDR8_1                  ((uint32_t)0x00020000)
N
N#define GPIO_PUPDR_PUPDR9                    ((uint32_t)0x000C0000)
N#define GPIO_PUPDR_PUPDR9_0                  ((uint32_t)0x00040000)
N#define GPIO_PUPDR_PUPDR9_1                  ((uint32_t)0x00080000)
N
N#define GPIO_PUPDR_PUPDR10                   ((uint32_t)0x00300000)
N#define GPIO_PUPDR_PUPDR10_0                 ((uint32_t)0x00100000)
N#define GPIO_PUPDR_PUPDR10_1                 ((uint32_t)0x00200000)
N
N#define GPIO_PUPDR_PUPDR11                   ((uint32_t)0x00C00000)
N#define GPIO_PUPDR_PUPDR11_0                 ((uint32_t)0x00400000)
N#define GPIO_PUPDR_PUPDR11_1                 ((uint32_t)0x00800000)
N
N#define GPIO_PUPDR_PUPDR12                   ((uint32_t)0x03000000)
N#define GPIO_PUPDR_PUPDR12_0                 ((uint32_t)0x01000000)
N#define GPIO_PUPDR_PUPDR12_1                 ((uint32_t)0x02000000)
N
N#define GPIO_PUPDR_PUPDR13                   ((uint32_t)0x0C000000)
N#define GPIO_PUPDR_PUPDR13_0                 ((uint32_t)0x04000000)
N#define GPIO_PUPDR_PUPDR13_1                 ((uint32_t)0x08000000)
N
N#define GPIO_PUPDR_PUPDR14                   ((uint32_t)0x30000000)
N#define GPIO_PUPDR_PUPDR14_0                 ((uint32_t)0x10000000)
N#define GPIO_PUPDR_PUPDR14_1                 ((uint32_t)0x20000000)
N
N#define GPIO_PUPDR_PUPDR15                   ((uint32_t)0xC0000000)
N#define GPIO_PUPDR_PUPDR15_0                 ((uint32_t)0x40000000)
N#define GPIO_PUPDR_PUPDR15_1                 ((uint32_t)0x80000000)
N
N/******************  Bits definition for GPIO_IDR register  *******************/
N#define GPIO_IDR_IDR_0                       ((uint32_t)0x00000001)
N#define GPIO_IDR_IDR_1                       ((uint32_t)0x00000002)
N#define GPIO_IDR_IDR_2                       ((uint32_t)0x00000004)
N#define GPIO_IDR_IDR_3                       ((uint32_t)0x00000008)
N#define GPIO_IDR_IDR_4                       ((uint32_t)0x00000010)
N#define GPIO_IDR_IDR_5                       ((uint32_t)0x00000020)
N#define GPIO_IDR_IDR_6                       ((uint32_t)0x00000040)
N#define GPIO_IDR_IDR_7                       ((uint32_t)0x00000080)
N#define GPIO_IDR_IDR_8                       ((uint32_t)0x00000100)
N#define GPIO_IDR_IDR_9                       ((uint32_t)0x00000200)
N#define GPIO_IDR_IDR_10                      ((uint32_t)0x00000400)
N#define GPIO_IDR_IDR_11                      ((uint32_t)0x00000800)
N#define GPIO_IDR_IDR_12                      ((uint32_t)0x00001000)
N#define GPIO_IDR_IDR_13                      ((uint32_t)0x00002000)
N#define GPIO_IDR_IDR_14                      ((uint32_t)0x00004000)
N#define GPIO_IDR_IDR_15                      ((uint32_t)0x00008000)
N/* Old GPIO_IDR register bits definition, maintained for legacy purpose */
N#define GPIO_OTYPER_IDR_0                    GPIO_IDR_IDR_0
N#define GPIO_OTYPER_IDR_1                    GPIO_IDR_IDR_1
N#define GPIO_OTYPER_IDR_2                    GPIO_IDR_IDR_2
N#define GPIO_OTYPER_IDR_3                    GPIO_IDR_IDR_3
N#define GPIO_OTYPER_IDR_4                    GPIO_IDR_IDR_4
N#define GPIO_OTYPER_IDR_5                    GPIO_IDR_IDR_5
N#define GPIO_OTYPER_IDR_6                    GPIO_IDR_IDR_6
N#define GPIO_OTYPER_IDR_7                    GPIO_IDR_IDR_7
N#define GPIO_OTYPER_IDR_8                    GPIO_IDR_IDR_8
N#define GPIO_OTYPER_IDR_9                    GPIO_IDR_IDR_9
N#define GPIO_OTYPER_IDR_10                   GPIO_IDR_IDR_10
N#define GPIO_OTYPER_IDR_11                   GPIO_IDR_IDR_11
N#define GPIO_OTYPER_IDR_12                   GPIO_IDR_IDR_12
N#define GPIO_OTYPER_IDR_13                   GPIO_IDR_IDR_13
N#define GPIO_OTYPER_IDR_14                   GPIO_IDR_IDR_14
N#define GPIO_OTYPER_IDR_15                   GPIO_IDR_IDR_15
N
N/******************  Bits definition for GPIO_ODR register  *******************/
N#define GPIO_ODR_ODR_0                       ((uint32_t)0x00000001)
N#define GPIO_ODR_ODR_1                       ((uint32_t)0x00000002)
N#define GPIO_ODR_ODR_2                       ((uint32_t)0x00000004)
N#define GPIO_ODR_ODR_3                       ((uint32_t)0x00000008)
N#define GPIO_ODR_ODR_4                       ((uint32_t)0x00000010)
N#define GPIO_ODR_ODR_5                       ((uint32_t)0x00000020)
N#define GPIO_ODR_ODR_6                       ((uint32_t)0x00000040)
N#define GPIO_ODR_ODR_7                       ((uint32_t)0x00000080)
N#define GPIO_ODR_ODR_8                       ((uint32_t)0x00000100)
N#define GPIO_ODR_ODR_9                       ((uint32_t)0x00000200)
N#define GPIO_ODR_ODR_10                      ((uint32_t)0x00000400)
N#define GPIO_ODR_ODR_11                      ((uint32_t)0x00000800)
N#define GPIO_ODR_ODR_12                      ((uint32_t)0x00001000)
N#define GPIO_ODR_ODR_13                      ((uint32_t)0x00002000)
N#define GPIO_ODR_ODR_14                      ((uint32_t)0x00004000)
N#define GPIO_ODR_ODR_15                      ((uint32_t)0x00008000)
N/* Old GPIO_ODR register bits definition, maintained for legacy purpose */
N#define GPIO_OTYPER_ODR_0                    GPIO_ODR_ODR_0
N#define GPIO_OTYPER_ODR_1                    GPIO_ODR_ODR_1
N#define GPIO_OTYPER_ODR_2                    GPIO_ODR_ODR_2
N#define GPIO_OTYPER_ODR_3                    GPIO_ODR_ODR_3
N#define GPIO_OTYPER_ODR_4                    GPIO_ODR_ODR_4
N#define GPIO_OTYPER_ODR_5                    GPIO_ODR_ODR_5
N#define GPIO_OTYPER_ODR_6                    GPIO_ODR_ODR_6
N#define GPIO_OTYPER_ODR_7                    GPIO_ODR_ODR_7
N#define GPIO_OTYPER_ODR_8                    GPIO_ODR_ODR_8
N#define GPIO_OTYPER_ODR_9                    GPIO_ODR_ODR_9
N#define GPIO_OTYPER_ODR_10                   GPIO_ODR_ODR_10
N#define GPIO_OTYPER_ODR_11                   GPIO_ODR_ODR_11
N#define GPIO_OTYPER_ODR_12                   GPIO_ODR_ODR_12
N#define GPIO_OTYPER_ODR_13                   GPIO_ODR_ODR_13
N#define GPIO_OTYPER_ODR_14                   GPIO_ODR_ODR_14
N#define GPIO_OTYPER_ODR_15                   GPIO_ODR_ODR_15
N
N/******************  Bits definition for GPIO_BSRR register  ******************/
N#define GPIO_BSRR_BS_0                       ((uint32_t)0x00000001)
N#define GPIO_BSRR_BS_1                       ((uint32_t)0x00000002)
N#define GPIO_BSRR_BS_2                       ((uint32_t)0x00000004)
N#define GPIO_BSRR_BS_3                       ((uint32_t)0x00000008)
N#define GPIO_BSRR_BS_4                       ((uint32_t)0x00000010)
N#define GPIO_BSRR_BS_5                       ((uint32_t)0x00000020)
N#define GPIO_BSRR_BS_6                       ((uint32_t)0x00000040)
N#define GPIO_BSRR_BS_7                       ((uint32_t)0x00000080)
N#define GPIO_BSRR_BS_8                       ((uint32_t)0x00000100)
N#define GPIO_BSRR_BS_9                       ((uint32_t)0x00000200)
N#define GPIO_BSRR_BS_10                      ((uint32_t)0x00000400)
N#define GPIO_BSRR_BS_11                      ((uint32_t)0x00000800)
N#define GPIO_BSRR_BS_12                      ((uint32_t)0x00001000)
N#define GPIO_BSRR_BS_13                      ((uint32_t)0x00002000)
N#define GPIO_BSRR_BS_14                      ((uint32_t)0x00004000)
N#define GPIO_BSRR_BS_15                      ((uint32_t)0x00008000)
N#define GPIO_BSRR_BR_0                       ((uint32_t)0x00010000)
N#define GPIO_BSRR_BR_1                       ((uint32_t)0x00020000)
N#define GPIO_BSRR_BR_2                       ((uint32_t)0x00040000)
N#define GPIO_BSRR_BR_3                       ((uint32_t)0x00080000)
N#define GPIO_BSRR_BR_4                       ((uint32_t)0x00100000)
N#define GPIO_BSRR_BR_5                       ((uint32_t)0x00200000)
N#define GPIO_BSRR_BR_6                       ((uint32_t)0x00400000)
N#define GPIO_BSRR_BR_7                       ((uint32_t)0x00800000)
N#define GPIO_BSRR_BR_8                       ((uint32_t)0x01000000)
N#define GPIO_BSRR_BR_9                       ((uint32_t)0x02000000)
N#define GPIO_BSRR_BR_10                      ((uint32_t)0x04000000)
N#define GPIO_BSRR_BR_11                      ((uint32_t)0x08000000)
N#define GPIO_BSRR_BR_12                      ((uint32_t)0x10000000)
N#define GPIO_BSRR_BR_13                      ((uint32_t)0x20000000)
N#define GPIO_BSRR_BR_14                      ((uint32_t)0x40000000)
N#define GPIO_BSRR_BR_15                      ((uint32_t)0x80000000)
N
N/******************************************************************************/
N/*                                                                            */
N/*                                    HASH                                    */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bits definition for HASH_CR register  ********************/
N#define HASH_CR_INIT                         ((uint32_t)0x00000004)
N#define HASH_CR_DMAE                         ((uint32_t)0x00000008)
N#define HASH_CR_DATATYPE                     ((uint32_t)0x00000030)
N#define HASH_CR_DATATYPE_0                   ((uint32_t)0x00000010)
N#define HASH_CR_DATATYPE_1                   ((uint32_t)0x00000020)
N#define HASH_CR_MODE                         ((uint32_t)0x00000040)
N#define HASH_CR_ALGO                         ((uint32_t)0x00040080)
N#define HASH_CR_ALGO_0                       ((uint32_t)0x00000080)
N#define HASH_CR_ALGO_1                       ((uint32_t)0x00040000)
N#define HASH_CR_NBW                          ((uint32_t)0x00000F00)
N#define HASH_CR_NBW_0                        ((uint32_t)0x00000100)
N#define HASH_CR_NBW_1                        ((uint32_t)0x00000200)
N#define HASH_CR_NBW_2                        ((uint32_t)0x00000400)
N#define HASH_CR_NBW_3                        ((uint32_t)0x00000800)
N#define HASH_CR_DINNE                        ((uint32_t)0x00001000)
N#define HASH_CR_MDMAT                        ((uint32_t)0x00002000)
N#define HASH_CR_LKEY                         ((uint32_t)0x00010000)
N
N/******************  Bits definition for HASH_STR register  *******************/
N#define HASH_STR_NBW                         ((uint32_t)0x0000001F)
N#define HASH_STR_NBW_0                       ((uint32_t)0x00000001)
N#define HASH_STR_NBW_1                       ((uint32_t)0x00000002)
N#define HASH_STR_NBW_2                       ((uint32_t)0x00000004)
N#define HASH_STR_NBW_3                       ((uint32_t)0x00000008)
N#define HASH_STR_NBW_4                       ((uint32_t)0x00000010)
N#define HASH_STR_DCAL                        ((uint32_t)0x00000100)
N
N/******************  Bits definition for HASH_IMR register  *******************/
N#define HASH_IMR_DINIM                       ((uint32_t)0x00000001)
N#define HASH_IMR_DCIM                        ((uint32_t)0x00000002)
N
N/******************  Bits definition for HASH_SR register  ********************/
N#define HASH_SR_DINIS                        ((uint32_t)0x00000001)
N#define HASH_SR_DCIS                         ((uint32_t)0x00000002)
N#define HASH_SR_DMAS                         ((uint32_t)0x00000004)
N#define HASH_SR_BUSY                         ((uint32_t)0x00000008)
N
N/******************************************************************************/
N/*                                                                            */
N/*                      Inter-integrated Circuit Interface                    */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for I2C_CR1 register  ********************/
N#define  I2C_CR1_PE                          ((uint16_t)0x0001)            /*!<Peripheral Enable                             */
N#define  I2C_CR1_SMBUS                       ((uint16_t)0x0002)            /*!<SMBus Mode                                    */
N#define  I2C_CR1_SMBTYPE                     ((uint16_t)0x0008)            /*!<SMBus Type                                    */
N#define  I2C_CR1_ENARP                       ((uint16_t)0x0010)            /*!<ARP Enable                                    */
N#define  I2C_CR1_ENPEC                       ((uint16_t)0x0020)            /*!<PEC Enable                                    */
N#define  I2C_CR1_ENGC                        ((uint16_t)0x0040)            /*!<General Call Enable                           */
N#define  I2C_CR1_NOSTRETCH                   ((uint16_t)0x0080)            /*!<Clock Stretching Disable (Slave mode)         */
N#define  I2C_CR1_START                       ((uint16_t)0x0100)            /*!<Start Generation                              */
N#define  I2C_CR1_STOP                        ((uint16_t)0x0200)            /*!<Stop Generation                               */
N#define  I2C_CR1_ACK                         ((uint16_t)0x0400)            /*!<Acknowledge Enable                            */
N#define  I2C_CR1_POS                         ((uint16_t)0x0800)            /*!<Acknowledge/PEC Position (for data reception) */
N#define  I2C_CR1_PEC                         ((uint16_t)0x1000)            /*!<Packet Error Checking                         */
N#define  I2C_CR1_ALERT                       ((uint16_t)0x2000)            /*!<SMBus Alert                                   */
N#define  I2C_CR1_SWRST                       ((uint16_t)0x8000)            /*!<Software Reset                                */
N
N/*******************  Bit definition for I2C_CR2 register  ********************/
N#define  I2C_CR2_FREQ                        ((uint16_t)0x003F)            /*!<FREQ[5:0] bits (Peripheral Clock Frequency)   */
N#define  I2C_CR2_FREQ_0                      ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  I2C_CR2_FREQ_1                      ((uint16_t)0x0002)            /*!<Bit 1 */
N#define  I2C_CR2_FREQ_2                      ((uint16_t)0x0004)            /*!<Bit 2 */
N#define  I2C_CR2_FREQ_3                      ((uint16_t)0x0008)            /*!<Bit 3 */
N#define  I2C_CR2_FREQ_4                      ((uint16_t)0x0010)            /*!<Bit 4 */
N#define  I2C_CR2_FREQ_5                      ((uint16_t)0x0020)            /*!<Bit 5 */
N
N#define  I2C_CR2_ITERREN                     ((uint16_t)0x0100)            /*!<Error Interrupt Enable  */
N#define  I2C_CR2_ITEVTEN                     ((uint16_t)0x0200)            /*!<Event Interrupt Enable  */
N#define  I2C_CR2_ITBUFEN                     ((uint16_t)0x0400)            /*!<Buffer Interrupt Enable */
N#define  I2C_CR2_DMAEN                       ((uint16_t)0x0800)            /*!<DMA Requests Enable     */
N#define  I2C_CR2_LAST                        ((uint16_t)0x1000)            /*!<DMA Last Transfer       */
N
N/*******************  Bit definition for I2C_OAR1 register  *******************/
N#define  I2C_OAR1_ADD1_7                     ((uint16_t)0x00FE)            /*!<Interface Address */
N#define  I2C_OAR1_ADD8_9                     ((uint16_t)0x0300)            /*!<Interface Address */
N
N#define  I2C_OAR1_ADD0                       ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  I2C_OAR1_ADD1                       ((uint16_t)0x0002)            /*!<Bit 1 */
N#define  I2C_OAR1_ADD2                       ((uint16_t)0x0004)            /*!<Bit 2 */
N#define  I2C_OAR1_ADD3                       ((uint16_t)0x0008)            /*!<Bit 3 */
N#define  I2C_OAR1_ADD4                       ((uint16_t)0x0010)            /*!<Bit 4 */
N#define  I2C_OAR1_ADD5                       ((uint16_t)0x0020)            /*!<Bit 5 */
N#define  I2C_OAR1_ADD6                       ((uint16_t)0x0040)            /*!<Bit 6 */
N#define  I2C_OAR1_ADD7                       ((uint16_t)0x0080)            /*!<Bit 7 */
N#define  I2C_OAR1_ADD8                       ((uint16_t)0x0100)            /*!<Bit 8 */
N#define  I2C_OAR1_ADD9                       ((uint16_t)0x0200)            /*!<Bit 9 */
N
N#define  I2C_OAR1_ADDMODE                    ((uint16_t)0x8000)            /*!<Addressing Mode (Slave mode) */
N
N/*******************  Bit definition for I2C_OAR2 register  *******************/
N#define  I2C_OAR2_ENDUAL                     ((uint8_t)0x01)               /*!<Dual addressing mode enable */
N#define  I2C_OAR2_ADD2                       ((uint8_t)0xFE)               /*!<Interface address           */
N
N/********************  Bit definition for I2C_DR register  ********************/
N#define  I2C_DR_DR                           ((uint8_t)0xFF)               /*!<8-bit Data Register         */
N
N/*******************  Bit definition for I2C_SR1 register  ********************/
N#define  I2C_SR1_SB                          ((uint16_t)0x0001)            /*!<Start Bit (Master mode)                         */
N#define  I2C_SR1_ADDR                        ((uint16_t)0x0002)            /*!<Address sent (master mode)/matched (slave mode) */
N#define  I2C_SR1_BTF                         ((uint16_t)0x0004)            /*!<Byte Transfer Finished                          */
N#define  I2C_SR1_ADD10                       ((uint16_t)0x0008)            /*!<10-bit header sent (Master mode)                */
N#define  I2C_SR1_STOPF                       ((uint16_t)0x0010)            /*!<Stop detection (Slave mode)                     */
N#define  I2C_SR1_RXNE                        ((uint16_t)0x0040)            /*!<Data Register not Empty (receivers)             */
N#define  I2C_SR1_TXE                         ((uint16_t)0x0080)            /*!<Data Register Empty (transmitters)              */
N#define  I2C_SR1_BERR                        ((uint16_t)0x0100)            /*!<Bus Error                                       */
N#define  I2C_SR1_ARLO                        ((uint16_t)0x0200)            /*!<Arbitration Lost (master mode)                  */
N#define  I2C_SR1_AF                          ((uint16_t)0x0400)            /*!<Acknowledge Failure                             */
N#define  I2C_SR1_OVR                         ((uint16_t)0x0800)            /*!<Overrun/Underrun                                */
N#define  I2C_SR1_PECERR                      ((uint16_t)0x1000)            /*!<PEC Error in reception                          */
N#define  I2C_SR1_TIMEOUT                     ((uint16_t)0x4000)            /*!<Timeout or Tlow Error                           */
N#define  I2C_SR1_SMBALERT                    ((uint16_t)0x8000)            /*!<SMBus Alert                                     */
N
N/*******************  Bit definition for I2C_SR2 register  ********************/
N#define  I2C_SR2_MSL                         ((uint16_t)0x0001)            /*!<Master/Slave                              */
N#define  I2C_SR2_BUSY                        ((uint16_t)0x0002)            /*!<Bus Busy                                  */
N#define  I2C_SR2_TRA                         ((uint16_t)0x0004)            /*!<Transmitter/Receiver                      */
N#define  I2C_SR2_GENCALL                     ((uint16_t)0x0010)            /*!<General Call Address (Slave mode)         */
N#define  I2C_SR2_SMBDEFAULT                  ((uint16_t)0x0020)            /*!<SMBus Device Default Address (Slave mode) */
N#define  I2C_SR2_SMBHOST                     ((uint16_t)0x0040)            /*!<SMBus Host Header (Slave mode)            */
N#define  I2C_SR2_DUALF                       ((uint16_t)0x0080)            /*!<Dual Flag (Slave mode)                    */
N#define  I2C_SR2_PEC                         ((uint16_t)0xFF00)            /*!<Packet Error Checking Register            */
N
N/*******************  Bit definition for I2C_CCR register  ********************/
N#define  I2C_CCR_CCR                         ((uint16_t)0x0FFF)            /*!<Clock Control Register in Fast/Standard mode (Master mode) */
N#define  I2C_CCR_DUTY                        ((uint16_t)0x4000)            /*!<Fast Mode Duty Cycle                                       */
N#define  I2C_CCR_FS                          ((uint16_t)0x8000)            /*!<I2C Master Mode Selection                                  */
N
N/******************  Bit definition for I2C_TRISE register  *******************/
N#define  I2C_TRISE_TRISE                     ((uint8_t)0x3F)               /*!<Maximum Rise Time in Fast/Standard mode (Master mode) */
N
N/******************  Bit definition for I2C_FLTR register  *******************/
N#define  I2C_FLTR_DNF                     ((uint8_t)0x0F)                  /*!<Digital Noise Filter */
N#define  I2C_FLTR_ANOFF                   ((uint8_t)0x10)                  /*!<Analog Noise Filter OFF */
N
N#if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
X#if 0L || 0L || 0L || 0L
S/******************************************************************************/
S/*                                                                            */
S/*              Fast-mode Plus Inter-integrated circuit (FMPI2C)              */
S/*                                                                            */
S/******************************************************************************/
S/*******************  Bit definition for I2C_CR1 register  *******************/
S#define  FMPI2C_CR1_PE                          ((uint32_t)0x00000001)        /*!< Peripheral enable                   */
S#define  FMPI2C_CR1_TXIE                        ((uint32_t)0x00000002)        /*!< TX interrupt enable                 */
S#define  FMPI2C_CR1_RXIE                        ((uint32_t)0x00000004)        /*!< RX interrupt enable                 */
S#define  FMPI2C_CR1_ADDRIE                      ((uint32_t)0x00000008)        /*!< Address match interrupt enable      */
S#define  FMPI2C_CR1_NACKIE                      ((uint32_t)0x00000010)        /*!< NACK received interrupt enable      */
S#define  FMPI2C_CR1_STOPIE                      ((uint32_t)0x00000020)        /*!< STOP detection interrupt enable     */
S#define  FMPI2C_CR1_TCIE                        ((uint32_t)0x00000040)        /*!< Transfer complete interrupt enable  */
S#define  FMPI2C_CR1_ERRIE                       ((uint32_t)0x00000080)        /*!< Errors interrupt enable             */
S#define  FMPI2C_CR1_DFN                         ((uint32_t)0x00000F00)        /*!< Digital noise filter                */
S#define  FMPI2C_CR1_ANFOFF                      ((uint32_t)0x00001000)        /*!< Analog noise filter OFF             */
S#define  FMPI2C_CR1_TXDMAEN                     ((uint32_t)0x00004000)        /*!< DMA transmission requests enable    */
S#define  FMPI2C_CR1_RXDMAEN                     ((uint32_t)0x00008000)        /*!< DMA reception requests enable       */
S#define  FMPI2C_CR1_SBC                         ((uint32_t)0x00010000)        /*!< Slave byte control                  */
S#define  FMPI2C_CR1_NOSTRETCH                   ((uint32_t)0x00020000)        /*!< Clock stretching disable            */
S#define  FMPI2C_CR1_GCEN                        ((uint32_t)0x00080000)        /*!< General call enable                 */
S#define  FMPI2C_CR1_SMBHEN                      ((uint32_t)0x00100000)        /*!< SMBus host address enable           */
S#define  FMPI2C_CR1_SMBDEN                      ((uint32_t)0x00200000)        /*!< SMBus device default address enable */
S#define  FMPI2C_CR1_ALERTEN                     ((uint32_t)0x00400000)        /*!< SMBus alert enable                  */
S#define  FMPI2C_CR1_PECEN                       ((uint32_t)0x00800000)        /*!< PEC enable                          */
S
S/******************  Bit definition for I2C_CR2 register  ********************/
S#define  FMPI2C_CR2_SADD                        ((uint32_t)0x000003FF)        /*!< Slave address (master mode)                             */
S#define  FMPI2C_CR2_RD_WRN                      ((uint32_t)0x00000400)        /*!< Transfer direction (master mode)                        */
S#define  FMPI2C_CR2_ADD10                       ((uint32_t)0x00000800)        /*!< 10-bit addressing mode (master mode)                    */
S#define  FMPI2C_CR2_HEAD10R                     ((uint32_t)0x00001000)        /*!< 10-bit address header only read direction (master mode) */
S#define  FMPI2C_CR2_START                       ((uint32_t)0x00002000)        /*!< START generation                                        */
S#define  FMPI2C_CR2_STOP                        ((uint32_t)0x00004000)        /*!< STOP generation (master mode)                           */
S#define  FMPI2C_CR2_NACK                        ((uint32_t)0x00008000)        /*!< NACK generation (slave mode)                            */
S#define  FMPI2C_CR2_NBYTES                      ((uint32_t)0x00FF0000)        /*!< Number of bytes                                         */
S#define  FMPI2C_CR2_RELOAD                      ((uint32_t)0x01000000)        /*!< NBYTES reload mode                                      */
S#define  FMPI2C_CR2_AUTOEND                     ((uint32_t)0x02000000)        /*!< Automatic end mode (master mode)                        */
S#define  FMPI2C_CR2_PECBYTE                     ((uint32_t)0x04000000)        /*!< Packet error checking byte                              */
S
S/*******************  Bit definition for I2C_OAR1 register  ******************/
S#define  FMPI2C_OAR1_OA1                        ((uint32_t)0x000003FF)        /*!< Interface own address 1   */
S#define  FMPI2C_OAR1_OA1MODE                    ((uint32_t)0x00000400)        /*!< Own address 1 10-bit mode */
S#define  FMPI2C_OAR1_OA1EN                      ((uint32_t)0x00008000)        /*!< Own address 1 enable     */
S
S/*******************  Bit definition for I2C_OAR2 register  *******************/
S#define  FMPI2C_OAR2_OA2                        ((uint32_t)0x000000FE)        /*!< Interface own address 2 */
S#define  FMPI2C_OAR2_OA2MSK                     ((uint32_t)0x00000700)        /*!< Own address 2 masks     */
S#define  FMPI2C_OAR2_OA2EN                      ((uint32_t)0x00008000)        /*!< Own address 2 enable    */
S
S/*******************  Bit definition for I2C_TIMINGR register *****************/
S#define  FMPI2C_TIMINGR_SCLL                    ((uint32_t)0x000000FF)        /*!< SCL low period (master mode)  */
S#define  FMPI2C_TIMINGR_SCLH                    ((uint32_t)0x0000FF00)        /*!< SCL high period (master mode) */
S#define  FMPI2C_TIMINGR_SDADEL                  ((uint32_t)0x000F0000)        /*!< Data hold time                */
S#define  FMPI2C_TIMINGR_SCLDEL                  ((uint32_t)0x00F00000)        /*!< Data setup time               */
S#define  FMPI2C_TIMINGR_PRESC                   ((uint32_t)0xF0000000)        /*!< Timings prescaler             */
S
S/******************* Bit definition for I2C_TIMEOUTR register *****************/
S#define  FMPI2C_TIMEOUTR_TIMEOUTA               ((uint32_t)0x00000FFF)        /*!< Bus timeout A                 */
S#define  FMPI2C_TIMEOUTR_TIDLE                  ((uint32_t)0x00001000)        /*!< Idle clock timeout detection  */
S#define  FMPI2C_TIMEOUTR_TIMOUTEN               ((uint32_t)0x00008000)        /*!< Clock timeout enable          */
S#define  FMPI2C_TIMEOUTR_TIMEOUTB               ((uint32_t)0x0FFF0000)        /*!< Bus timeout B                 */
S#define  FMPI2C_TIMEOUTR_TEXTEN                 ((uint32_t)0x80000000)        /*!< Extended clock timeout enable */
S
S/******************  Bit definition for I2C_ISR register  *********************/
S#define  FMPI2C_ISR_TXE                         ((uint32_t)0x00000001)        /*!< Transmit data register empty    */
S#define  FMPI2C_ISR_TXIS                        ((uint32_t)0x00000002)        /*!< Transmit interrupt status       */
S#define  FMPI2C_ISR_RXNE                        ((uint32_t)0x00000004)        /*!< Receive data register not empty */
S#define  FMPI2C_ISR_ADDR                        ((uint32_t)0x00000008)        /*!< Address matched (slave mode)    */
S#define  FMPI2C_ISR_NACKF                       ((uint32_t)0x00000010)        /*!< NACK received flag              */
S#define  FMPI2C_ISR_STOPF                       ((uint32_t)0x00000020)        /*!< STOP detection flag             */
S#define  FMPI2C_ISR_TC                          ((uint32_t)0x00000040)        /*!< Transfer complete (master mode) */
S#define  FMPI2C_ISR_TCR                         ((uint32_t)0x00000080)        /*!< Transfer complete reload        */
S#define  FMPI2C_ISR_BERR                        ((uint32_t)0x00000100)        /*!< Bus error                       */
S#define  FMPI2C_ISR_ARLO                        ((uint32_t)0x00000200)        /*!< Arbitration lost                */
S#define  FMPI2C_ISR_OVR                         ((uint32_t)0x00000400)        /*!< Overrun/Underrun                */
S#define  FMPI2C_ISR_PECERR                      ((uint32_t)0x00000800)        /*!< PEC error in reception          */
S#define  FMPI2C_ISR_TIMEOUT                     ((uint32_t)0x00001000)        /*!< Timeout or Tlow detection flag  */
S#define  FMPI2C_ISR_ALERT                       ((uint32_t)0x00002000)        /*!< SMBus alert                     */
S#define  FMPI2C_ISR_BUSY                        ((uint32_t)0x00008000)        /*!< Bus busy                        */
S#define  FMPI2C_ISR_DIR                         ((uint32_t)0x00010000)        /*!< Transfer direction (slave mode) */
S#define  FMPI2C_ISR_ADDCODE                     ((uint32_t)0x00FE0000)        /*!< Address match code (slave mode) */
S
S/******************  Bit definition for I2C_ICR register  *********************/
S#define  FMPI2C_ICR_ADDRCF                      ((uint32_t)0x00000008)        /*!< Address matched clear flag  */
S#define  FMPI2C_ICR_NACKCF                      ((uint32_t)0x00000010)        /*!< NACK clear flag             */
S#define  FMPI2C_ICR_STOPCF                      ((uint32_t)0x00000020)        /*!< STOP detection clear flag   */
S#define  FMPI2C_ICR_BERRCF                      ((uint32_t)0x00000100)        /*!< Bus error clear flag */
S#define  FMPI2C_ICR_ARLOCF                      ((uint32_t)0x00000200)        /*!< Arbitration lost clear flag */
S#define  FMPI2C_ICR_OVRCF                       ((uint32_t)0x00000400)        /*!< Overrun/Underrun clear flag */
S#define  FMPI2C_ICR_PECCF                       ((uint32_t)0x00000800)        /*!< PAC error clear flag        */
S#define  FMPI2C_ICR_TIMOUTCF                    ((uint32_t)0x00001000)        /*!< Timeout clear flag          */
S#define  FMPI2C_ICR_ALERTCF                     ((uint32_t)0x00002000)        /*!< Alert clear flag            */
S
S/******************  Bit definition for I2C_PECR register  ********************/
S#define  FMPI2C_PECR_PEC                        ((uint32_t)0x000000FF)        /*!< PEC register */
S
S/******************  Bit definition for I2C_RXDR register  *********************/
S#define  FMPI2C_RXDR_RXDATA                     ((uint32_t)0x000000FF)        /*!< 8-bit receive data */
S
S/******************  Bit definition for I2C_TXDR register  *********************/
S#define  FMPI2C_TXDR_TXDATA                     ((uint32_t)0x000000FF)        /*!< 8-bit transmit data */
N#endif /* STM32F410xx || STM32F412xG || STM32F413_423xx || STM32F446xx */
N/******************************************************************************/
N/*                                                                            */
N/*                           Independent WATCHDOG                             */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for IWDG_KR register  ********************/
N#define  IWDG_KR_KEY                         ((uint16_t)0xFFFF)            /*!<Key value (write only, read 0000h)  */
N
N/*******************  Bit definition for IWDG_PR register  ********************/
N#define  IWDG_PR_PR                          ((uint8_t)0x07)               /*!<PR[2:0] (Prescaler divider)         */
N#define  IWDG_PR_PR_0                        ((uint8_t)0x01)               /*!<Bit 0 */
N#define  IWDG_PR_PR_1                        ((uint8_t)0x02)               /*!<Bit 1 */
N#define  IWDG_PR_PR_2                        ((uint8_t)0x04)               /*!<Bit 2 */
N
N/*******************  Bit definition for IWDG_RLR register  *******************/
N#define  IWDG_RLR_RL                         ((uint16_t)0x0FFF)            /*!<Watchdog counter reload value        */
N
N/*******************  Bit definition for IWDG_SR register  ********************/
N#define  IWDG_SR_PVU                         ((uint8_t)0x01)               /*!<Watchdog prescaler value update      */
N#define  IWDG_SR_RVU                         ((uint8_t)0x02)               /*!<Watchdog counter reload value update */
N
N/******************************************************************************/
N/*                                                                            */
N/*                      LCD-TFT Display Controller (LTDC)                     */
N/*                                                                            */
N/******************************************************************************/
N
N/********************  Bit definition for LTDC_SSCR register  *****************/
N
N#define LTDC_SSCR_VSH                       ((uint32_t)0x000007FF)              /*!< Vertical Synchronization Height */
N#define LTDC_SSCR_HSW                       ((uint32_t)0x0FFF0000)              /*!< Horizontal Synchronization Width */
N
N/********************  Bit definition for LTDC_BPCR register  *****************/
N
N#define LTDC_BPCR_AVBP                      ((uint32_t)0x000007FF)              /*!< Accumulated Vertical Back Porch */
N#define LTDC_BPCR_AHBP                      ((uint32_t)0x0FFF0000)              /*!< Accumulated Horizontal Back Porch */
N
N/********************  Bit definition for LTDC_AWCR register  *****************/
N
N#define LTDC_AWCR_AAH                       ((uint32_t)0x000007FF)              /*!< Accumulated Active heigh */
N#define LTDC_AWCR_AAW                       ((uint32_t)0x0FFF0000)              /*!< Accumulated Active Width */
N
N/********************  Bit definition for LTDC_TWCR register  *****************/
N
N#define LTDC_TWCR_TOTALH                    ((uint32_t)0x000007FF)              /*!< Total Heigh */
N#define LTDC_TWCR_TOTALW                    ((uint32_t)0x0FFF0000)              /*!< Total Width */
N
N/********************  Bit definition for LTDC_GCR register  ******************/
N
N#define LTDC_GCR_LTDCEN                     ((uint32_t)0x00000001)              /*!< LCD-TFT controller enable bit */
N#define LTDC_GCR_DBW                        ((uint32_t)0x00000070)              /*!< Dither Blue Width */
N#define LTDC_GCR_DGW                        ((uint32_t)0x00000700)              /*!< Dither Green Width */
N#define LTDC_GCR_DRW                        ((uint32_t)0x00007000)              /*!< Dither Red Width */
N#define LTDC_GCR_DEN                        ((uint32_t)0x00010000)              /*!< Dither Enable */
N#define LTDC_GCR_PCPOL                      ((uint32_t)0x10000000)              /*!< Pixel Clock Polarity */
N#define LTDC_GCR_DEPOL                      ((uint32_t)0x20000000)              /*!< Data Enable Polarity */
N#define LTDC_GCR_VSPOL                      ((uint32_t)0x40000000)              /*!< Vertical Synchronization Polarity */
N#define LTDC_GCR_HSPOL                      ((uint32_t)0x80000000)              /*!< Horizontal Synchronization Polarity */
N
N/* Legacy defines */
N#define LTDC_GCR_DTEN                       LTDC_GCR_DEN
N
N/********************  Bit definition for LTDC_SRCR register  *****************/
N
N#define LTDC_SRCR_IMR                      ((uint32_t)0x00000001)               /*!< Immediate Reload */
N#define LTDC_SRCR_VBR                      ((uint32_t)0x00000002)               /*!< Vertical Blanking Reload */
N
N/********************  Bit definition for LTDC_BCCR register  *****************/
N
N#define LTDC_BCCR_BCBLUE                    ((uint32_t)0x000000FF)              /*!< Background Blue value */
N#define LTDC_BCCR_BCGREEN                   ((uint32_t)0x0000FF00)              /*!< Background Green value */
N#define LTDC_BCCR_BCRED                     ((uint32_t)0x00FF0000)              /*!< Background Red value */
N
N/********************  Bit definition for LTDC_IER register  ******************/
N
N#define LTDC_IER_LIE                        ((uint32_t)0x00000001)              /*!< Line Interrupt Enable */
N#define LTDC_IER_FUIE                       ((uint32_t)0x00000002)              /*!< FIFO Underrun Interrupt Enable */
N#define LTDC_IER_TERRIE                     ((uint32_t)0x00000004)              /*!< Transfer Error Interrupt Enable */
N#define LTDC_IER_RRIE                       ((uint32_t)0x00000008)              /*!< Register Reload interrupt enable */
N
N/********************  Bit definition for LTDC_ISR register  ******************/
N
N#define LTDC_ISR_LIF                        ((uint32_t)0x00000001)              /*!< Line Interrupt Flag */
N#define LTDC_ISR_FUIF                       ((uint32_t)0x00000002)              /*!< FIFO Underrun Interrupt Flag */
N#define LTDC_ISR_TERRIF                     ((uint32_t)0x00000004)              /*!< Transfer Error Interrupt Flag */
N#define LTDC_ISR_RRIF                       ((uint32_t)0x00000008)              /*!< Register Reload interrupt Flag */
N
N/********************  Bit definition for LTDC_ICR register  ******************/
N
N#define LTDC_ICR_CLIF                       ((uint32_t)0x00000001)              /*!< Clears the Line Interrupt Flag */
N#define LTDC_ICR_CFUIF                      ((uint32_t)0x00000002)              /*!< Clears the FIFO Underrun Interrupt Flag */
N#define LTDC_ICR_CTERRIF                    ((uint32_t)0x00000004)              /*!< Clears the Transfer Error Interrupt Flag */
N#define LTDC_ICR_CRRIF                      ((uint32_t)0x00000008)              /*!< Clears Register Reload interrupt Flag */
N
N/********************  Bit definition for LTDC_LIPCR register  ****************/
N
N#define LTDC_LIPCR_LIPOS                    ((uint32_t)0x000007FF)              /*!< Line Interrupt Position */
N
N/********************  Bit definition for LTDC_CPSR register  *****************/
N
N#define LTDC_CPSR_CYPOS                     ((uint32_t)0x0000FFFF)              /*!< Current Y Position */
N#define LTDC_CPSR_CXPOS                     ((uint32_t)0xFFFF0000)              /*!< Current X Position */
N
N/********************  Bit definition for LTDC_CDSR register  *****************/
N
N#define LTDC_CDSR_VDES                      ((uint32_t)0x00000001)              /*!< Vertical Data Enable Status */
N#define LTDC_CDSR_HDES                      ((uint32_t)0x00000002)              /*!< Horizontal Data Enable Status */
N#define LTDC_CDSR_VSYNCS                    ((uint32_t)0x00000004)              /*!< Vertical Synchronization Status */
N#define LTDC_CDSR_HSYNCS                    ((uint32_t)0x00000008)              /*!< Horizontal Synchronization Status */
N
N/********************  Bit definition for LTDC_LxCR register  *****************/
N
N#define LTDC_LxCR_LEN                       ((uint32_t)0x00000001)              /*!< Layer Enable */
N#define LTDC_LxCR_COLKEN                    ((uint32_t)0x00000002)              /*!< Color Keying Enable */
N#define LTDC_LxCR_CLUTEN                    ((uint32_t)0x00000010)              /*!< Color Lockup Table Enable */
N
N/********************  Bit definition for LTDC_LxWHPCR register  **************/
N
N#define LTDC_LxWHPCR_WHSTPOS                ((uint32_t)0x00000FFF)              /*!< Window Horizontal Start Position */
N#define LTDC_LxWHPCR_WHSPPOS                ((uint32_t)0xFFFF0000)              /*!< Window Horizontal Stop Position */
N
N/********************  Bit definition for LTDC_LxWVPCR register  **************/
N
N#define LTDC_LxWVPCR_WVSTPOS                ((uint32_t)0x00000FFF)              /*!< Window Vertical Start Position */
N#define LTDC_LxWVPCR_WVSPPOS                ((uint32_t)0xFFFF0000)              /*!< Window Vertical Stop Position */
N
N/********************  Bit definition for LTDC_LxCKCR register  ***************/
N
N#define LTDC_LxCKCR_CKBLUE                  ((uint32_t)0x000000FF)              /*!< Color Key Blue value */
N#define LTDC_LxCKCR_CKGREEN                 ((uint32_t)0x0000FF00)              /*!< Color Key Green value */
N#define LTDC_LxCKCR_CKRED                   ((uint32_t)0x00FF0000)              /*!< Color Key Red value */
N
N/********************  Bit definition for LTDC_LxPFCR register  ***************/
N
N#define LTDC_LxPFCR_PF                      ((uint32_t)0x00000007)              /*!< Pixel Format */
N
N/********************  Bit definition for LTDC_LxCACR register  ***************/
N
N#define LTDC_LxCACR_CONSTA                  ((uint32_t)0x000000FF)              /*!< Constant Alpha */
N
N/********************  Bit definition for LTDC_LxDCCR register  ***************/
N
N#define LTDC_LxDCCR_DCBLUE                  ((uint32_t)0x000000FF)              /*!< Default Color Blue */
N#define LTDC_LxDCCR_DCGREEN                 ((uint32_t)0x0000FF00)              /*!< Default Color Green */
N#define LTDC_LxDCCR_DCRED                   ((uint32_t)0x00FF0000)              /*!< Default Color Red */
N#define LTDC_LxDCCR_DCALPHA                 ((uint32_t)0xFF000000)              /*!< Default Color Alpha */
N                                
N/********************  Bit definition for LTDC_LxBFCR register  ***************/
N
N#define LTDC_LxBFCR_BF2                     ((uint32_t)0x00000007)              /*!< Blending Factor 2 */
N#define LTDC_LxBFCR_BF1                     ((uint32_t)0x00000700)              /*!< Blending Factor 1 */
N
N/********************  Bit definition for LTDC_LxCFBAR register  **************/
N
N#define LTDC_LxCFBAR_CFBADD                 ((uint32_t)0xFFFFFFFF)              /*!< Color Frame Buffer Start Address */
N
N/********************  Bit definition for LTDC_LxCFBLR register  **************/
N
N#define LTDC_LxCFBLR_CFBLL                  ((uint32_t)0x00001FFF)              /*!< Color Frame Buffer Line Length */
N#define LTDC_LxCFBLR_CFBP                   ((uint32_t)0x1FFF0000)              /*!< Color Frame Buffer Pitch in bytes */
N
N/********************  Bit definition for LTDC_LxCFBLNR register  *************/
N
N#define LTDC_LxCFBLNR_CFBLNBR               ((uint32_t)0x000007FF)              /*!< Frame Buffer Line Number */
N
N/********************  Bit definition for LTDC_LxCLUTWR register  *************/
N
N#define LTDC_LxCLUTWR_BLUE                  ((uint32_t)0x000000FF)              /*!< Blue value */
N#define LTDC_LxCLUTWR_GREEN                 ((uint32_t)0x0000FF00)              /*!< Green value */
N#define LTDC_LxCLUTWR_RED                   ((uint32_t)0x00FF0000)              /*!< Red value */
N#define LTDC_LxCLUTWR_CLUTADD               ((uint32_t)0xFF000000)              /*!< CLUT address */
N
N#if defined(STM32F469_479xx)
X#if 0L
S/******************************************************************************/
S/*                                                                            */
S/*                                    DSI                                     */
S/*                                                                            */
S/******************************************************************************/
S/*******************  Bit definition for DSI_VR register  *****************/
S#define DSI_VR                         ((uint32_t)0x3133302A)               /*!< DSI Host Version */
S
S/*******************  Bit definition for DSI_CR register  *****************/
S#define DSI_CR_EN                      ((uint32_t)0x00000001)               /*!< DSI Host power up and reset */
S
S/*******************  Bit definition for DSI_CCR register  ****************/
S#define DSI_CCR_TXECKDIV               ((uint32_t)0x000000FF)               /*!< TX Escape Clock Division */
S#define DSI_CCR_TXECKDIV0              ((uint32_t)0x00000001)
S#define DSI_CCR_TXECKDIV1              ((uint32_t)0x00000002)
S#define DSI_CCR_TXECKDIV2              ((uint32_t)0x00000004)
S#define DSI_CCR_TXECKDIV3              ((uint32_t)0x00000008)
S#define DSI_CCR_TXECKDIV4              ((uint32_t)0x00000010)
S#define DSI_CCR_TXECKDIV5              ((uint32_t)0x00000020)
S#define DSI_CCR_TXECKDIV6              ((uint32_t)0x00000040)
S#define DSI_CCR_TXECKDIV7              ((uint32_t)0x00000080)
S
S#define DSI_CCR_TOCKDIV                ((uint32_t)0x0000FF00)               /*!< Timeout Clock Division */
S#define DSI_CCR_TOCKDIV0               ((uint32_t)0x00000100)
S#define DSI_CCR_TOCKDIV1               ((uint32_t)0x00000200)
S#define DSI_CCR_TOCKDIV2               ((uint32_t)0x00000400)
S#define DSI_CCR_TOCKDIV3               ((uint32_t)0x00000800)
S#define DSI_CCR_TOCKDIV4               ((uint32_t)0x00001000)
S#define DSI_CCR_TOCKDIV5               ((uint32_t)0x00002000)
S#define DSI_CCR_TOCKDIV6               ((uint32_t)0x00004000)
S#define DSI_CCR_TOCKDIV7               ((uint32_t)0x00008000)
S
S/*******************  Bit definition for DSI_LVCIDR register  *************/
S#define DSI_LVCIDR_VCID                ((uint32_t)0x00000003)               /*!< Virtual Channel ID */
S#define DSI_LVCIDR_VCID0               ((uint32_t)0x00000001)
S#define DSI_LVCIDR_VCID1               ((uint32_t)0x00000002)
S
S/*******************  Bit definition for DSI_LCOLCR register  *************/
S#define DSI_LCOLCR_COLC                ((uint32_t)0x0000000F)               /*!< Color Coding */
S#define DSI_LCOLCR_COLC0               ((uint32_t)0x00000001)
S#define DSI_LCOLCR_COLC1               ((uint32_t)0x00000020)
S#define DSI_LCOLCR_COLC2               ((uint32_t)0x00000040)
S#define DSI_LCOLCR_COLC3               ((uint32_t)0x00000080)
S
S#define DSI_LCOLCR_LPE                 ((uint32_t)0x00000100)               /*!< Loosly Packet Enable */
S
S/*******************  Bit definition for DSI_LPCR register  ***************/
S#define DSI_LPCR_DEP                   ((uint32_t)0x00000001)               /*!< Data Enable Polarity */
S#define DSI_LPCR_VSP                   ((uint32_t)0x00000002)               /*!< VSYNC Polarity */
S#define DSI_LPCR_HSP                   ((uint32_t)0x00000004)               /*!< HSYNC Polarity */
S
S/*******************  Bit definition for DSI_LPMCR register  **************/
S#define DSI_LPMCR_VLPSIZE              ((uint32_t)0x000000FF)               /*!< VACT Largest Packet Size */
S#define DSI_LPMCR_VLPSIZE0             ((uint32_t)0x00000001)
S#define DSI_LPMCR_VLPSIZE1             ((uint32_t)0x00000002)
S#define DSI_LPMCR_VLPSIZE2             ((uint32_t)0x00000004)
S#define DSI_LPMCR_VLPSIZE3             ((uint32_t)0x00000008)
S#define DSI_LPMCR_VLPSIZE4             ((uint32_t)0x00000010)
S#define DSI_LPMCR_VLPSIZE5             ((uint32_t)0x00000020)
S#define DSI_LPMCR_VLPSIZE6             ((uint32_t)0x00000040)
S#define DSI_LPMCR_VLPSIZE7             ((uint32_t)0x00000080)
S
S#define DSI_LPMCR_LPSIZE               ((uint32_t)0x00FF0000)               /*!< Largest Packet Size */
S#define DSI_LPMCR_LPSIZE0              ((uint32_t)0x00010000)
S#define DSI_LPMCR_LPSIZE1              ((uint32_t)0x00020000)
S#define DSI_LPMCR_LPSIZE2              ((uint32_t)0x00040000)
S#define DSI_LPMCR_LPSIZE3              ((uint32_t)0x00080000)
S#define DSI_LPMCR_LPSIZE4              ((uint32_t)0x00100000)
S#define DSI_LPMCR_LPSIZE5              ((uint32_t)0x00200000)
S#define DSI_LPMCR_LPSIZE6              ((uint32_t)0x00400000)
S#define DSI_LPMCR_LPSIZE7              ((uint32_t)0x00800000)
S
S/*******************  Bit definition for DSI_PCR register  ****************/
S#define DSI_PCR_ETTXE                  ((uint32_t)0x00000001)               /*!< EoTp Transmission Enable */
S#define DSI_PCR_ETRXE                  ((uint32_t)0x00000002)               /*!< EoTp Reception Enable */
S#define DSI_PCR_BTAE                   ((uint32_t)0x00000004)               /*!< Bus Turn Around Enable */
S#define DSI_PCR_ECCRXE                 ((uint32_t)0x00000008)               /*!< ECC Reception Enable */
S#define DSI_PCR_CRCRXE                 ((uint32_t)0x00000010)               /*!< CRC Reception Enable */
S
S/*******************  Bit definition for DSI_GVCIDR register  *************/
S#define DSI_GVCIDR_VCID                ((uint32_t)0x00000003)               /*!< Virtual Channel ID */
S#define DSI_GVCIDR_VCID0               ((uint32_t)0x00000001)
S#define DSI_GVCIDR_VCID1               ((uint32_t)0x00000002)
S
S/*******************  Bit definition for DSI_MCR register  ****************/
S#define DSI_MCR_CMDM                   ((uint32_t)0x00000001)               /*!< Command Mode */
S
S/*******************  Bit definition for DSI_VMCR register  ***************/
S#define DSI_VMCR_VMT                   ((uint32_t)0x00000003)               /*!< Video Mode Type */
S#define DSI_VMCR_VMT0                  ((uint32_t)0x00000001)
S#define DSI_VMCR_VMT1                  ((uint32_t)0x00000002)
S
S#define DSI_VMCR_LPVSAE                ((uint32_t)0x00000100)               /*!< Low-Power Vertical Sync Active Enable */
S#define DSI_VMCR_LPVBPE                ((uint32_t)0x00000200)               /*!< Low-power Vertical Back-Porch Enable */
S#define DSI_VMCR_LPVFPE                ((uint32_t)0x00000400)               /*!< Low-power Vertical Front-porch Enable */
S#define DSI_VMCR_LPVAE                 ((uint32_t)0x00000800)               /*!< Low-Power Vertical Active Enable */
S#define DSI_VMCR_LPHBPE                ((uint32_t)0x00001000)               /*!< Low-Power Horizontal Back-Porch Enable */
S#define DSI_VMCR_LPHFPE                ((uint32_t)0x00002000)               /*!< Low-Power Horizontal Front-Porch Enable */
S#define DSI_VMCR_FBTAAE                ((uint32_t)0x00004000)               /*!< Frame Bus-Turn-Around Acknowledge Enable */
S#define DSI_VMCR_LPCE                  ((uint32_t)0x00008000)               /*!< Low-Power Command Enable */
S#define DSI_VMCR_PGE                   ((uint32_t)0x00010000)               /*!< Pattern Generator Enable */
S#define DSI_VMCR_PGM                   ((uint32_t)0x00100000)               /*!< Pattern Generator Mode */
S#define DSI_VMCR_PGO                   ((uint32_t)0x01000000)               /*!< Pattern Generator Orientation */
S
S/*******************  Bit definition for DSI_VPCR register  ***************/
S#define DSI_VPCR_VPSIZE                ((uint32_t)0x00003FFF)               /*!< Video Packet Size */
S#define DSI_VPCR_VPSIZE0               ((uint32_t)0x00000001)
S#define DSI_VPCR_VPSIZE1               ((uint32_t)0x00000002)
S#define DSI_VPCR_VPSIZE2               ((uint32_t)0x00000004)
S#define DSI_VPCR_VPSIZE3               ((uint32_t)0x00000008)
S#define DSI_VPCR_VPSIZE4               ((uint32_t)0x00000010)
S#define DSI_VPCR_VPSIZE5               ((uint32_t)0x00000020)
S#define DSI_VPCR_VPSIZE6               ((uint32_t)0x00000040)
S#define DSI_VPCR_VPSIZE7               ((uint32_t)0x00000080)
S#define DSI_VPCR_VPSIZE8               ((uint32_t)0x00000100)
S#define DSI_VPCR_VPSIZE9               ((uint32_t)0x00000200)
S#define DSI_VPCR_VPSIZE10              ((uint32_t)0x00000400)
S#define DSI_VPCR_VPSIZE11              ((uint32_t)0x00000800)
S#define DSI_VPCR_VPSIZE12              ((uint32_t)0x00001000)
S#define DSI_VPCR_VPSIZE13              ((uint32_t)0x00002000)
S
S/*******************  Bit definition for DSI_VCCR register  ***************/
S#define DSI_VCCR_NUMC                  ((uint32_t)0x00001FFF)               /*!< Number of Chunks */
S#define DSI_VCCR_NUMC0                 ((uint32_t)0x00000001)
S#define DSI_VCCR_NUMC1                 ((uint32_t)0x00000002)
S#define DSI_VCCR_NUMC2                 ((uint32_t)0x00000004)
S#define DSI_VCCR_NUMC3                 ((uint32_t)0x00000008)
S#define DSI_VCCR_NUMC4                 ((uint32_t)0x00000010)
S#define DSI_VCCR_NUMC5                 ((uint32_t)0x00000020)
S#define DSI_VCCR_NUMC6                 ((uint32_t)0x00000040)
S#define DSI_VCCR_NUMC7                 ((uint32_t)0x00000080)
S#define DSI_VCCR_NUMC8                 ((uint32_t)0x00000100)
S#define DSI_VCCR_NUMC9                 ((uint32_t)0x00000200)
S#define DSI_VCCR_NUMC10                ((uint32_t)0x00000400)
S#define DSI_VCCR_NUMC11                ((uint32_t)0x00000800)
S#define DSI_VCCR_NUMC12                ((uint32_t)0x00001000)
S
S/*******************  Bit definition for DSI_VNPCR register  **************/
S#define DSI_VNPCR_NPSIZE               ((uint32_t)0x00001FFF)               /*!< Null Packet Size */
S#define DSI_VNPCR_NPSIZE0              ((uint32_t)0x00000001)
S#define DSI_VNPCR_NPSIZE1              ((uint32_t)0x00000002)
S#define DSI_VNPCR_NPSIZE2              ((uint32_t)0x00000004)
S#define DSI_VNPCR_NPSIZE3              ((uint32_t)0x00000008)
S#define DSI_VNPCR_NPSIZE4              ((uint32_t)0x00000010)
S#define DSI_VNPCR_NPSIZE5              ((uint32_t)0x00000020)
S#define DSI_VNPCR_NPSIZE6              ((uint32_t)0x00000040)
S#define DSI_VNPCR_NPSIZE7              ((uint32_t)0x00000080)
S#define DSI_VNPCR_NPSIZE8              ((uint32_t)0x00000100)
S#define DSI_VNPCR_NPSIZE9              ((uint32_t)0x00000200)
S#define DSI_VNPCR_NPSIZE10             ((uint32_t)0x00000400)
S#define DSI_VNPCR_NPSIZE11             ((uint32_t)0x00000800)
S#define DSI_VNPCR_NPSIZE12             ((uint32_t)0x00001000)
S
S/*******************  Bit definition for DSI_VHSACR register  *************/
S#define DSI_VHSACR_HSA                 ((uint32_t)0x00000FFF)               /*!< Horizontal Synchronism Active duration */
S#define DSI_VHSACR_HSA0                ((uint32_t)0x00000001)
S#define DSI_VHSACR_HSA1                ((uint32_t)0x00000002)
S#define DSI_VHSACR_HSA2                ((uint32_t)0x00000004)
S#define DSI_VHSACR_HSA3                ((uint32_t)0x00000008)
S#define DSI_VHSACR_HSA4                ((uint32_t)0x00000010)
S#define DSI_VHSACR_HSA5                ((uint32_t)0x00000020)
S#define DSI_VHSACR_HSA6                ((uint32_t)0x00000040)
S#define DSI_VHSACR_HSA7                ((uint32_t)0x00000080)
S#define DSI_VHSACR_HSA8                ((uint32_t)0x00000100)
S#define DSI_VHSACR_HSA9                ((uint32_t)0x00000200)
S#define DSI_VHSACR_HSA10               ((uint32_t)0x00000400)
S#define DSI_VHSACR_HSA11               ((uint32_t)0x00000800)
S
S/*******************  Bit definition for DSI_VHBPCR register  *************/
S#define DSI_VHBPCR_HBP                 ((uint32_t)0x00000FFF)               /*!< Horizontal Back-Porch duration */
S#define DSI_VHBPCR_HBP0                ((uint32_t)0x00000001)
S#define DSI_VHBPCR_HBP1                ((uint32_t)0x00000002)
S#define DSI_VHBPCR_HBP2                ((uint32_t)0x00000004)
S#define DSI_VHBPCR_HBP3                ((uint32_t)0x00000008)
S#define DSI_VHBPCR_HBP4                ((uint32_t)0x00000010)
S#define DSI_VHBPCR_HBP5                ((uint32_t)0x00000020)
S#define DSI_VHBPCR_HBP6                ((uint32_t)0x00000040)
S#define DSI_VHBPCR_HBP7                ((uint32_t)0x00000080)
S#define DSI_VHBPCR_HBP8                ((uint32_t)0x00000100)
S#define DSI_VHBPCR_HBP9                ((uint32_t)0x00000200)
S#define DSI_VHBPCR_HBP10               ((uint32_t)0x00000400)
S#define DSI_VHBPCR_HBP11               ((uint32_t)0x00000800)
S
S/*******************  Bit definition for DSI_VLCR register  ***************/
S#define DSI_VLCR_HLINE                 ((uint32_t)0x00007FFF)               /*!< Horizontal Line duration */
S#define DSI_VLCR_HLINE0                ((uint32_t)0x00000001)
S#define DSI_VLCR_HLINE1                ((uint32_t)0x00000002)
S#define DSI_VLCR_HLINE2                ((uint32_t)0x00000004)
S#define DSI_VLCR_HLINE3                ((uint32_t)0x00000008)
S#define DSI_VLCR_HLINE4                ((uint32_t)0x00000010)
S#define DSI_VLCR_HLINE5                ((uint32_t)0x00000020)
S#define DSI_VLCR_HLINE6                ((uint32_t)0x00000040)
S#define DSI_VLCR_HLINE7                ((uint32_t)0x00000080)
S#define DSI_VLCR_HLINE8                ((uint32_t)0x00000100)
S#define DSI_VLCR_HLINE9                ((uint32_t)0x00000200)
S#define DSI_VLCR_HLINE10               ((uint32_t)0x00000400)
S#define DSI_VLCR_HLINE11               ((uint32_t)0x00000800)
S#define DSI_VLCR_HLINE12               ((uint32_t)0x00001000)
S#define DSI_VLCR_HLINE13               ((uint32_t)0x00002000)
S#define DSI_VLCR_HLINE14               ((uint32_t)0x00004000)
S
S/*******************  Bit definition for DSI_VVSACR register  *************/
S#define DSI_VVSACR_VSA                 ((uint32_t)0x000003FF)               /*!< Vertical Synchronism Active duration */
S#define DSI_VVSACR_VSA0                ((uint32_t)0x00000001)
S#define DSI_VVSACR_VSA1                ((uint32_t)0x00000002)
S#define DSI_VVSACR_VSA2                ((uint32_t)0x00000004)
S#define DSI_VVSACR_VSA3                ((uint32_t)0x00000008)
S#define DSI_VVSACR_VSA4                ((uint32_t)0x00000010)
S#define DSI_VVSACR_VSA5                ((uint32_t)0x00000020)
S#define DSI_VVSACR_VSA6                ((uint32_t)0x00000040)
S#define DSI_VVSACR_VSA7                ((uint32_t)0x00000080)
S#define DSI_VVSACR_VSA8                ((uint32_t)0x00000100)
S#define DSI_VVSACR_VSA9                ((uint32_t)0x00000200)
S
S/*******************  Bit definition for DSI_VVBPCR register  *************/
S#define DSI_VVBPCR_VBP                 ((uint32_t)0x000003FF)               /*!< Vertical Back-Porch duration */
S#define DSI_VVBPCR_VBP0                ((uint32_t)0x00000001)
S#define DSI_VVBPCR_VBP1                ((uint32_t)0x00000002)
S#define DSI_VVBPCR_VBP2                ((uint32_t)0x00000004)
S#define DSI_VVBPCR_VBP3                ((uint32_t)0x00000008)
S#define DSI_VVBPCR_VBP4                ((uint32_t)0x00000010)
S#define DSI_VVBPCR_VBP5                ((uint32_t)0x00000020)
S#define DSI_VVBPCR_VBP6                ((uint32_t)0x00000040)
S#define DSI_VVBPCR_VBP7                ((uint32_t)0x00000080)
S#define DSI_VVBPCR_VBP8                ((uint32_t)0x00000100)
S#define DSI_VVBPCR_VBP9                ((uint32_t)0x00000200)
S
S/*******************  Bit definition for DSI_VVFPCR register  *************/
S#define DSI_VVFPCR_VFP                 ((uint32_t)0x000003FF)               /*!< Vertical Front-Porch duration */
S#define DSI_VVFPCR_VFP0                ((uint32_t)0x00000001)
S#define DSI_VVFPCR_VFP1                ((uint32_t)0x00000002)
S#define DSI_VVFPCR_VFP2                ((uint32_t)0x00000004)
S#define DSI_VVFPCR_VFP3                ((uint32_t)0x00000008)
S#define DSI_VVFPCR_VFP4                ((uint32_t)0x00000010)
S#define DSI_VVFPCR_VFP5                ((uint32_t)0x00000020)
S#define DSI_VVFPCR_VFP6                ((uint32_t)0x00000040)
S#define DSI_VVFPCR_VFP7                ((uint32_t)0x00000080)
S#define DSI_VVFPCR_VFP8                ((uint32_t)0x00000100)
S#define DSI_VVFPCR_VFP9                ((uint32_t)0x00000200)
S
S/*******************  Bit definition for DSI_VVACR register  **************/
S#define DSI_VVACR_VA                   ((uint32_t)0x00003FFF)               /*!< Vertical Active duration */
S#define DSI_VVACR_VA0                  ((uint32_t)0x00000001)
S#define DSI_VVACR_VA1                  ((uint32_t)0x00000002)
S#define DSI_VVACR_VA2                  ((uint32_t)0x00000004)
S#define DSI_VVACR_VA3                  ((uint32_t)0x00000008)
S#define DSI_VVACR_VA4                  ((uint32_t)0x00000010)
S#define DSI_VVACR_VA5                  ((uint32_t)0x00000020)
S#define DSI_VVACR_VA6                  ((uint32_t)0x00000040)
S#define DSI_VVACR_VA7                  ((uint32_t)0x00000080)
S#define DSI_VVACR_VA8                  ((uint32_t)0x00000100)
S#define DSI_VVACR_VA9                  ((uint32_t)0x00000200)
S#define DSI_VVACR_VA10                 ((uint32_t)0x00000400)
S#define DSI_VVACR_VA11                 ((uint32_t)0x00000800)
S#define DSI_VVACR_VA12                 ((uint32_t)0x00001000)
S#define DSI_VVACR_VA13                 ((uint32_t)0x00002000)
S
S/*******************  Bit definition for DSI_LCCR register  ***************/
S#define DSI_LCCR_CMDSIZE               ((uint32_t)0x0000FFFF)               /*!< Command Size */
S#define DSI_LCCR_CMDSIZE0              ((uint32_t)0x00000001)
S#define DSI_LCCR_CMDSIZE1              ((uint32_t)0x00000002)
S#define DSI_LCCR_CMDSIZE2              ((uint32_t)0x00000004)
S#define DSI_LCCR_CMDSIZE3              ((uint32_t)0x00000008)
S#define DSI_LCCR_CMDSIZE4              ((uint32_t)0x00000010)
S#define DSI_LCCR_CMDSIZE5              ((uint32_t)0x00000020)
S#define DSI_LCCR_CMDSIZE6              ((uint32_t)0x00000040)
S#define DSI_LCCR_CMDSIZE7              ((uint32_t)0x00000080)
S#define DSI_LCCR_CMDSIZE8              ((uint32_t)0x00000100)
S#define DSI_LCCR_CMDSIZE9              ((uint32_t)0x00000200)
S#define DSI_LCCR_CMDSIZE10             ((uint32_t)0x00000400)
S#define DSI_LCCR_CMDSIZE11             ((uint32_t)0x00000800)
S#define DSI_LCCR_CMDSIZE12             ((uint32_t)0x00001000)
S#define DSI_LCCR_CMDSIZE13             ((uint32_t)0x00002000)
S#define DSI_LCCR_CMDSIZE14             ((uint32_t)0x00004000)
S#define DSI_LCCR_CMDSIZE15             ((uint32_t)0x00008000)
S
S/*******************  Bit definition for DSI_CMCR register  ***************/
S#define DSI_CMCR_TEARE                 ((uint32_t)0x00000001)               /*!< Tearing Effect Acknowledge Request Enable */
S#define DSI_CMCR_ARE                   ((uint32_t)0x00000002)               /*!< Acknowledge Request Enable */
S#define DSI_CMCR_GSW0TX                ((uint32_t)0x00000100)               /*!< Generic Short Write Zero parameters Transmission */
S#define DSI_CMCR_GSW1TX                ((uint32_t)0x00000200)               /*!< Generic Short Write One parameters Transmission */
S#define DSI_CMCR_GSW2TX                ((uint32_t)0x00000400)               /*!< Generic Short Write Two parameters Transmission */
S#define DSI_CMCR_GSR0TX                ((uint32_t)0x00000800)               /*!< Generic Short Read Zero parameters Transmission */
S#define DSI_CMCR_GSR1TX                ((uint32_t)0x00001000)               /*!< Generic Short Read One parameters Transmission */
S#define DSI_CMCR_GSR2TX                ((uint32_t)0x00002000)               /*!< Generic Short Read Two parameters Transmission */
S#define DSI_CMCR_GLWTX                 ((uint32_t)0x00004000)               /*!< Generic Long Write Transmission */
S#define DSI_CMCR_DSW0TX                ((uint32_t)0x00010000)               /*!< DCS Short Write Zero parameter Transmission */
S#define DSI_CMCR_DSW1TX                ((uint32_t)0x00020000)               /*!< DCS Short Read One parameter Transmission */
S#define DSI_CMCR_DSR0TX                ((uint32_t)0x00040000)               /*!< DCS Short Read Zero parameter Transmission */
S#define DSI_CMCR_DLWTX                 ((uint32_t)0x00080000)               /*!< DCS Long Write Transmission */
S#define DSI_CMCR_MRDPS                 ((uint32_t)0x01000000)               /*!< Maximum Read Packet Size */
S
S/*******************  Bit definition for DSI_GHCR register  ***************/
S#define DSI_GHCR_DT                    ((uint32_t)0x0000003F)               /*!< Type */
S#define DSI_GHCR_DT0                   ((uint32_t)0x00000001)
S#define DSI_GHCR_DT1                   ((uint32_t)0x00000002)
S#define DSI_GHCR_DT2                   ((uint32_t)0x00000004)
S#define DSI_GHCR_DT3                   ((uint32_t)0x00000008)
S#define DSI_GHCR_DT4                   ((uint32_t)0x00000010)
S#define DSI_GHCR_DT5                   ((uint32_t)0x00000020)
S
S#define DSI_GHCR_VCID                  ((uint32_t)0x000000C0)               /*!< Channel */
S#define DSI_GHCR_VCID0                 ((uint32_t)0x00000040)
S#define DSI_GHCR_VCID1                 ((uint32_t)0x00000080)
S
S#define DSI_GHCR_WCLSB                 ((uint32_t)0x0000FF00)               /*!< WordCount LSB */
S#define DSI_GHCR_WCLSB0                ((uint32_t)0x00000100)
S#define DSI_GHCR_WCLSB1                ((uint32_t)0x00000200)
S#define DSI_GHCR_WCLSB2                ((uint32_t)0x00000400)
S#define DSI_GHCR_WCLSB3                ((uint32_t)0x00000800)
S#define DSI_GHCR_WCLSB4                ((uint32_t)0x00001000)
S#define DSI_GHCR_WCLSB5                ((uint32_t)0x00002000)
S#define DSI_GHCR_WCLSB6                ((uint32_t)0x00004000)
S#define DSI_GHCR_WCLSB7                ((uint32_t)0x00008000)
S
S#define DSI_GHCR_WCMSB                 ((uint32_t)0x00FF0000)               /*!< WordCount MSB */
S#define DSI_GHCR_WCMSB0                ((uint32_t)0x00010000)
S#define DSI_GHCR_WCMSB1                ((uint32_t)0x00020000)
S#define DSI_GHCR_WCMSB2                ((uint32_t)0x00040000)
S#define DSI_GHCR_WCMSB3                ((uint32_t)0x00080000)
S#define DSI_GHCR_WCMSB4                ((uint32_t)0x00100000)
S#define DSI_GHCR_WCMSB5                ((uint32_t)0x00200000)
S#define DSI_GHCR_WCMSB6                ((uint32_t)0x00400000)
S#define DSI_GHCR_WCMSB7                ((uint32_t)0x00800000)
S
S/*******************  Bit definition for DSI_GPDR register  ***************/
S#define DSI_GPDR_DATA1                 ((uint32_t)0x000000FF)               /*!< Payload Byte 1 */
S#define DSI_GPDR_DATA1_0               ((uint32_t)0x00000001)
S#define DSI_GPDR_DATA1_1               ((uint32_t)0x00000002)
S#define DSI_GPDR_DATA1_2               ((uint32_t)0x00000004)
S#define DSI_GPDR_DATA1_3               ((uint32_t)0x00000008)
S#define DSI_GPDR_DATA1_4               ((uint32_t)0x00000010)
S#define DSI_GPDR_DATA1_5               ((uint32_t)0x00000020)
S#define DSI_GPDR_DATA1_6               ((uint32_t)0x00000040)
S#define DSI_GPDR_DATA1_7               ((uint32_t)0x00000080)
S
S#define DSI_GPDR_DATA2                 ((uint32_t)0x0000FF00)               /*!< Payload Byte 2 */
S#define DSI_GPDR_DATA2_0               ((uint32_t)0x00000100)
S#define DSI_GPDR_DATA2_1               ((uint32_t)0x00000200)
S#define DSI_GPDR_DATA2_2               ((uint32_t)0x00000400)
S#define DSI_GPDR_DATA2_3               ((uint32_t)0x00000800)
S#define DSI_GPDR_DATA2_4               ((uint32_t)0x00001000)
S#define DSI_GPDR_DATA2_5               ((uint32_t)0x00002000)
S#define DSI_GPDR_DATA2_6               ((uint32_t)0x00004000)
S#define DSI_GPDR_DATA2_7               ((uint32_t)0x00008000)
S
S#define DSI_GPDR_DATA3                 ((uint32_t)0x00FF0000)               /*!< Payload Byte 3 */
S#define DSI_GPDR_DATA3_0               ((uint32_t)0x00010000)
S#define DSI_GPDR_DATA3_1               ((uint32_t)0x00020000)
S#define DSI_GPDR_DATA3_2               ((uint32_t)0x00040000)
S#define DSI_GPDR_DATA3_3               ((uint32_t)0x00080000)
S#define DSI_GPDR_DATA3_4               ((uint32_t)0x00100000)
S#define DSI_GPDR_DATA3_5               ((uint32_t)0x00200000)
S#define DSI_GPDR_DATA3_6               ((uint32_t)0x00400000)
S#define DSI_GPDR_DATA3_7               ((uint32_t)0x00800000)
S
S#define DSI_GPDR_DATA4                 ((uint32_t)0xFF000000)               /*!< Payload Byte 4 */
S#define DSI_GPDR_DATA4_0               ((uint32_t)0x01000000)
S#define DSI_GPDR_DATA4_1               ((uint32_t)0x02000000)
S#define DSI_GPDR_DATA4_2               ((uint32_t)0x04000000)
S#define DSI_GPDR_DATA4_3               ((uint32_t)0x08000000)
S#define DSI_GPDR_DATA4_4               ((uint32_t)0x10000000)
S#define DSI_GPDR_DATA4_5               ((uint32_t)0x20000000)
S#define DSI_GPDR_DATA4_6               ((uint32_t)0x40000000)
S#define DSI_GPDR_DATA4_7               ((uint32_t)0x80000000)
S
S/*******************  Bit definition for DSI_GPSR register  ***************/
S#define DSI_GPSR_CMDFE                 ((uint32_t)0x00000001)               /*!< Command FIFO Empty */
S#define DSI_GPSR_CMDFF                 ((uint32_t)0x00000002)               /*!< Command FIFO Full */
S#define DSI_GPSR_PWRFE                 ((uint32_t)0x00000004)               /*!< Payload Write FIFO Empty */
S#define DSI_GPSR_PWRFF                 ((uint32_t)0x00000008)               /*!< Payload Write FIFO Full */
S#define DSI_GPSR_PRDFE                 ((uint32_t)0x00000010)               /*!< Payload Read FIFO Empty */
S#define DSI_GPSR_PRDFF                 ((uint32_t)0x00000020)               /*!< Payload Read FIFO Full */
S#define DSI_GPSR_RCB                   ((uint32_t)0x00000040)               /*!< Read Command Busy */
S
S/*******************  Bit definition for DSI_TCCR0 register  **************/
S#define DSI_TCCR0_LPRX_TOCNT           ((uint32_t)0x0000FFFF)               /*!< Low-power Reception Timeout Counter */
S#define DSI_TCCR0_LPRX_TOCNT0          ((uint32_t)0x00000001)
S#define DSI_TCCR0_LPRX_TOCNT1          ((uint32_t)0x00000002)
S#define DSI_TCCR0_LPRX_TOCNT2          ((uint32_t)0x00000004)
S#define DSI_TCCR0_LPRX_TOCNT3          ((uint32_t)0x00000008)
S#define DSI_TCCR0_LPRX_TOCNT4          ((uint32_t)0x00000010)
S#define DSI_TCCR0_LPRX_TOCNT5          ((uint32_t)0x00000020)
S#define DSI_TCCR0_LPRX_TOCNT6          ((uint32_t)0x00000040)
S#define DSI_TCCR0_LPRX_TOCNT7          ((uint32_t)0x00000080)
S#define DSI_TCCR0_LPRX_TOCNT8          ((uint32_t)0x00000100)
S#define DSI_TCCR0_LPRX_TOCNT9          ((uint32_t)0x00000200)
S#define DSI_TCCR0_LPRX_TOCNT10         ((uint32_t)0x00000400)
S#define DSI_TCCR0_LPRX_TOCNT11         ((uint32_t)0x00000800)
S#define DSI_TCCR0_LPRX_TOCNT12         ((uint32_t)0x00001000)
S#define DSI_TCCR0_LPRX_TOCNT13         ((uint32_t)0x00002000)
S#define DSI_TCCR0_LPRX_TOCNT14         ((uint32_t)0x00004000)
S#define DSI_TCCR0_LPRX_TOCNT15         ((uint32_t)0x00008000)
S
S#define DSI_TCCR0_HSTX_TOCNT           ((uint32_t)0xFFFF0000)               /*!< High-Speed Transmission Timeout Counter */
S#define DSI_TCCR0_HSTX_TOCNT0          ((uint32_t)0x00010000)
S#define DSI_TCCR0_HSTX_TOCNT1          ((uint32_t)0x00020000)
S#define DSI_TCCR0_HSTX_TOCNT2          ((uint32_t)0x00040000)
S#define DSI_TCCR0_HSTX_TOCNT3          ((uint32_t)0x00080000)
S#define DSI_TCCR0_HSTX_TOCNT4          ((uint32_t)0x00100000)
S#define DSI_TCCR0_HSTX_TOCNT5          ((uint32_t)0x00200000)
S#define DSI_TCCR0_HSTX_TOCNT6          ((uint32_t)0x00400000)
S#define DSI_TCCR0_HSTX_TOCNT7          ((uint32_t)0x00800000)
S#define DSI_TCCR0_HSTX_TOCNT8          ((uint32_t)0x01000000)
S#define DSI_TCCR0_HSTX_TOCNT9          ((uint32_t)0x02000000)
S#define DSI_TCCR0_HSTX_TOCNT10         ((uint32_t)0x04000000)
S#define DSI_TCCR0_HSTX_TOCNT11         ((uint32_t)0x08000000)
S#define DSI_TCCR0_HSTX_TOCNT12         ((uint32_t)0x10000000)
S#define DSI_TCCR0_HSTX_TOCNT13         ((uint32_t)0x20000000)
S#define DSI_TCCR0_HSTX_TOCNT14         ((uint32_t)0x40000000)
S#define DSI_TCCR0_HSTX_TOCNT15         ((uint32_t)0x80000000)
S
S/*******************  Bit definition for DSI_TCCR1 register  **************/
S#define DSI_TCCR1_HSRD_TOCNT           ((uint32_t)0x0000FFFF)               /*!< High-Speed Read Timeout Counter */
S#define DSI_TCCR1_HSRD_TOCNT0          ((uint32_t)0x00000001)
S#define DSI_TCCR1_HSRD_TOCNT1          ((uint32_t)0x00000002)
S#define DSI_TCCR1_HSRD_TOCNT2          ((uint32_t)0x00000004)
S#define DSI_TCCR1_HSRD_TOCNT3          ((uint32_t)0x00000008)
S#define DSI_TCCR1_HSRD_TOCNT4          ((uint32_t)0x00000010)
S#define DSI_TCCR1_HSRD_TOCNT5          ((uint32_t)0x00000020)
S#define DSI_TCCR1_HSRD_TOCNT6          ((uint32_t)0x00000040)
S#define DSI_TCCR1_HSRD_TOCNT7          ((uint32_t)0x00000080)
S#define DSI_TCCR1_HSRD_TOCNT8          ((uint32_t)0x00000100)
S#define DSI_TCCR1_HSRD_TOCNT9          ((uint32_t)0x00000200)
S#define DSI_TCCR1_HSRD_TOCNT10         ((uint32_t)0x00000400)
S#define DSI_TCCR1_HSRD_TOCNT11         ((uint32_t)0x00000800)
S#define DSI_TCCR1_HSRD_TOCNT12         ((uint32_t)0x00001000)
S#define DSI_TCCR1_HSRD_TOCNT13         ((uint32_t)0x00002000)
S#define DSI_TCCR1_HSRD_TOCNT14         ((uint32_t)0x00004000)
S#define DSI_TCCR1_HSRD_TOCNT15         ((uint32_t)0x00008000)
S
S/*******************  Bit definition for DSI_TCCR2 register  **************/
S#define DSI_TCCR2_LPRD_TOCNT           ((uint32_t)0x0000FFFF)               /*!< Low-Power Read Timeout Counter */
S#define DSI_TCCR2_LPRD_TOCNT0          ((uint32_t)0x00000001)
S#define DSI_TCCR2_LPRD_TOCNT1          ((uint32_t)0x00000002)
S#define DSI_TCCR2_LPRD_TOCNT2          ((uint32_t)0x00000004)
S#define DSI_TCCR2_LPRD_TOCNT3          ((uint32_t)0x00000008)
S#define DSI_TCCR2_LPRD_TOCNT4          ((uint32_t)0x00000010)
S#define DSI_TCCR2_LPRD_TOCNT5          ((uint32_t)0x00000020)
S#define DSI_TCCR2_LPRD_TOCNT6          ((uint32_t)0x00000040)
S#define DSI_TCCR2_LPRD_TOCNT7          ((uint32_t)0x00000080)
S#define DSI_TCCR2_LPRD_TOCNT8          ((uint32_t)0x00000100)
S#define DSI_TCCR2_LPRD_TOCNT9          ((uint32_t)0x00000200)
S#define DSI_TCCR2_LPRD_TOCNT10         ((uint32_t)0x00000400)
S#define DSI_TCCR2_LPRD_TOCNT11         ((uint32_t)0x00000800)
S#define DSI_TCCR2_LPRD_TOCNT12         ((uint32_t)0x00001000)
S#define DSI_TCCR2_LPRD_TOCNT13         ((uint32_t)0x00002000)
S#define DSI_TCCR2_LPRD_TOCNT14         ((uint32_t)0x00004000)
S#define DSI_TCCR2_LPRD_TOCNT15         ((uint32_t)0x00008000)
S
S/*******************  Bit definition for DSI_TCCR3 register  **************/
S#define DSI_TCCR3_HSWR_TOCNT           ((uint32_t)0x0000FFFF)               /*!< High-Speed Write Timeout Counter */
S#define DSI_TCCR3_HSWR_TOCNT0          ((uint32_t)0x00000001)
S#define DSI_TCCR3_HSWR_TOCNT1          ((uint32_t)0x00000002)
S#define DSI_TCCR3_HSWR_TOCNT2          ((uint32_t)0x00000004)
S#define DSI_TCCR3_HSWR_TOCNT3          ((uint32_t)0x00000008)
S#define DSI_TCCR3_HSWR_TOCNT4          ((uint32_t)0x00000010)
S#define DSI_TCCR3_HSWR_TOCNT5          ((uint32_t)0x00000020)
S#define DSI_TCCR3_HSWR_TOCNT6          ((uint32_t)0x00000040)
S#define DSI_TCCR3_HSWR_TOCNT7          ((uint32_t)0x00000080)
S#define DSI_TCCR3_HSWR_TOCNT8          ((uint32_t)0x00000100)
S#define DSI_TCCR3_HSWR_TOCNT9          ((uint32_t)0x00000200)
S#define DSI_TCCR3_HSWR_TOCNT10         ((uint32_t)0x00000400)
S#define DSI_TCCR3_HSWR_TOCNT11         ((uint32_t)0x00000800)
S#define DSI_TCCR3_HSWR_TOCNT12         ((uint32_t)0x00001000)
S#define DSI_TCCR3_HSWR_TOCNT13         ((uint32_t)0x00002000)
S#define DSI_TCCR3_HSWR_TOCNT14         ((uint32_t)0x00004000)
S#define DSI_TCCR3_HSWR_TOCNT15         ((uint32_t)0x00008000)
S
S#define DSI_TCCR3_PM                   ((uint32_t)0x01000000)               /*!< Presp Mode */
S
S/*******************  Bit definition for DSI_TCCR4 register  **************/
S#define DSI_TCCR4_LPWR_TOCNT           ((uint32_t)0x0000FFFF)               /*!< Low-Power Write Timeout Counter */
S#define DSI_TCCR4_LPWR_TOCNT0          ((uint32_t)0x00000001)
S#define DSI_TCCR4_LPWR_TOCNT1          ((uint32_t)0x00000002)
S#define DSI_TCCR4_LPWR_TOCNT2          ((uint32_t)0x00000004)
S#define DSI_TCCR4_LPWR_TOCNT3          ((uint32_t)0x00000008)
S#define DSI_TCCR4_LPWR_TOCNT4          ((uint32_t)0x00000010)
S#define DSI_TCCR4_LPWR_TOCNT5          ((uint32_t)0x00000020)
S#define DSI_TCCR4_LPWR_TOCNT6          ((uint32_t)0x00000040)
S#define DSI_TCCR4_LPWR_TOCNT7          ((uint32_t)0x00000080)
S#define DSI_TCCR4_LPWR_TOCNT8          ((uint32_t)0x00000100)
S#define DSI_TCCR4_LPWR_TOCNT9          ((uint32_t)0x00000200)
S#define DSI_TCCR4_LPWR_TOCNT10         ((uint32_t)0x00000400)
S#define DSI_TCCR4_LPWR_TOCNT11         ((uint32_t)0x00000800)
S#define DSI_TCCR4_LPWR_TOCNT12         ((uint32_t)0x00001000)
S#define DSI_TCCR4_LPWR_TOCNT13         ((uint32_t)0x00002000)
S#define DSI_TCCR4_LPWR_TOCNT14         ((uint32_t)0x00004000)
S#define DSI_TCCR4_LPWR_TOCNT15         ((uint32_t)0x00008000)
S
S/*******************  Bit definition for DSI_TCCR5 register  **************/
S#define DSI_TCCR5_BTA_TOCNT            ((uint32_t)0x0000FFFF)               /*!< Bus-Turn-Around Timeout Counter */
S#define DSI_TCCR5_BTA_TOCNT0           ((uint32_t)0x00000001)
S#define DSI_TCCR5_BTA_TOCNT1           ((uint32_t)0x00000002)
S#define DSI_TCCR5_BTA_TOCNT2           ((uint32_t)0x00000004)
S#define DSI_TCCR5_BTA_TOCNT3           ((uint32_t)0x00000008)
S#define DSI_TCCR5_BTA_TOCNT4           ((uint32_t)0x00000010)
S#define DSI_TCCR5_BTA_TOCNT5           ((uint32_t)0x00000020)
S#define DSI_TCCR5_BTA_TOCNT6           ((uint32_t)0x00000040)
S#define DSI_TCCR5_BTA_TOCNT7           ((uint32_t)0x00000080)
S#define DSI_TCCR5_BTA_TOCNT8           ((uint32_t)0x00000100)
S#define DSI_TCCR5_BTA_TOCNT9           ((uint32_t)0x00000200)
S#define DSI_TCCR5_BTA_TOCNT10          ((uint32_t)0x00000400)
S#define DSI_TCCR5_BTA_TOCNT11          ((uint32_t)0x00000800)
S#define DSI_TCCR5_BTA_TOCNT12          ((uint32_t)0x00001000)
S#define DSI_TCCR5_BTA_TOCNT13          ((uint32_t)0x00002000)
S#define DSI_TCCR5_BTA_TOCNT14          ((uint32_t)0x00004000)
S#define DSI_TCCR5_BTA_TOCNT15          ((uint32_t)0x00008000)
S
S/*******************  Bit definition for DSI_TDCR register  ***************/
S#define DSI_TDCR_3DM                   ((uint32_t)0x00000003)               /*!< 3D Mode */
S#define DSI_TDCR_3DM0                  ((uint32_t)0x00000001)
S#define DSI_TDCR_3DM1                  ((uint32_t)0x00000002)
S
S#define DSI_TDCR_3DF                   ((uint32_t)0x0000000C)               /*!< 3D Format */
S#define DSI_TDCR_3DF0                  ((uint32_t)0x00000004)
S#define DSI_TDCR_3DF1                  ((uint32_t)0x00000008)
S
S#define DSI_TDCR_SVS                   ((uint32_t)0x00000010)               /*!< Second VSYNC */
S#define DSI_TDCR_RF                    ((uint32_t)0x00000020)               /*!< Right First */
S#define DSI_TDCR_S3DC                  ((uint32_t)0x00010000)               /*!< Send 3D Control */
S
S/*******************  Bit definition for DSI_CLCR register  ***************/
S#define DSI_CLCR_DPCC                  ((uint32_t)0x00000001)               /*!< D-PHY Clock Control */
S#define DSI_CLCR_ACR                   ((uint32_t)0x00000002)               /*!< Automatic Clocklane Control */
S
S/*******************  Bit definition for DSI_CLTCR register  **************/
S#define DSI_CLTCR_LP2HS_TIME           ((uint32_t)0x000003FF)               /*!< Low-Power to High-Speed Time */
S#define DSI_CLTCR_LP2HS_TIME0          ((uint32_t)0x00000001)
S#define DSI_CLTCR_LP2HS_TIME1          ((uint32_t)0x00000002)
S#define DSI_CLTCR_LP2HS_TIME2          ((uint32_t)0x00000004)
S#define DSI_CLTCR_LP2HS_TIME3          ((uint32_t)0x00000008)
S#define DSI_CLTCR_LP2HS_TIME4          ((uint32_t)0x00000010)
S#define DSI_CLTCR_LP2HS_TIME5          ((uint32_t)0x00000020)
S#define DSI_CLTCR_LP2HS_TIME6          ((uint32_t)0x00000040)
S#define DSI_CLTCR_LP2HS_TIME7          ((uint32_t)0x00000080)
S#define DSI_CLTCR_LP2HS_TIME8          ((uint32_t)0x00000100)
S#define DSI_CLTCR_LP2HS_TIME9          ((uint32_t)0x00000200)
S
S#define DSI_CLTCR_HS2LP_TIME           ((uint32_t)0x03FF0000)               /*!< High-Speed to Low-Power Time */
S#define DSI_CLTCR_HS2LP_TIME0          ((uint32_t)0x00010000)
S#define DSI_CLTCR_HS2LP_TIME1          ((uint32_t)0x00020000)
S#define DSI_CLTCR_HS2LP_TIME2          ((uint32_t)0x00040000)
S#define DSI_CLTCR_HS2LP_TIME3          ((uint32_t)0x00080000)
S#define DSI_CLTCR_HS2LP_TIME4          ((uint32_t)0x00100000)
S#define DSI_CLTCR_HS2LP_TIME5          ((uint32_t)0x00200000)
S#define DSI_CLTCR_HS2LP_TIME6          ((uint32_t)0x00400000)
S#define DSI_CLTCR_HS2LP_TIME7          ((uint32_t)0x00800000)
S#define DSI_CLTCR_HS2LP_TIME8          ((uint32_t)0x01000000)
S#define DSI_CLTCR_HS2LP_TIME9          ((uint32_t)0x02000000)
S
S/*******************  Bit definition for DSI_DLTCR register  **************/
S#define DSI_DLTCR_MRD_TIME             ((uint32_t)0x00007FFF)               /*!< Maximum Read Time */
S#define DSI_DLTCR_MRD_TIME0            ((uint32_t)0x00000001)
S#define DSI_DLTCR_MRD_TIME1            ((uint32_t)0x00000002)
S#define DSI_DLTCR_MRD_TIME2            ((uint32_t)0x00000004)
S#define DSI_DLTCR_MRD_TIME3            ((uint32_t)0x00000008)
S#define DSI_DLTCR_MRD_TIME4            ((uint32_t)0x00000010)
S#define DSI_DLTCR_MRD_TIME5            ((uint32_t)0x00000020)
S#define DSI_DLTCR_MRD_TIME6            ((uint32_t)0x00000040)
S#define DSI_DLTCR_MRD_TIME7            ((uint32_t)0x00000080)
S#define DSI_DLTCR_MRD_TIME8            ((uint32_t)0x00000100)
S#define DSI_DLTCR_MRD_TIME9            ((uint32_t)0x00000200)
S#define DSI_DLTCR_MRD_TIME10           ((uint32_t)0x00000400)
S#define DSI_DLTCR_MRD_TIME11           ((uint32_t)0x00000800)
S#define DSI_DLTCR_MRD_TIME12           ((uint32_t)0x00001000)
S#define DSI_DLTCR_MRD_TIME13           ((uint32_t)0x00002000)
S#define DSI_DLTCR_MRD_TIME14           ((uint32_t)0x00004000)
S
S#define DSI_DLTCR_LP2HS_TIME           ((uint32_t)0x00FF0000)               /*!< Low-Power To High-Speed Time */
S#define DSI_DLTCR_LP2HS_TIME0          ((uint32_t)0x00010000)
S#define DSI_DLTCR_LP2HS_TIME1          ((uint32_t)0x00020000)
S#define DSI_DLTCR_LP2HS_TIME2          ((uint32_t)0x00040000)
S#define DSI_DLTCR_LP2HS_TIME3          ((uint32_t)0x00080000)
S#define DSI_DLTCR_LP2HS_TIME4          ((uint32_t)0x00100000)
S#define DSI_DLTCR_LP2HS_TIME5          ((uint32_t)0x00200000)
S#define DSI_DLTCR_LP2HS_TIME6          ((uint32_t)0x00400000)
S#define DSI_DLTCR_LP2HS_TIME7          ((uint32_t)0x00800000)
S
S#define DSI_DLTCR_HS2LP_TIME           ((uint32_t)0xFF000000)               /*!< High-Speed To Low-Power Time */
S#define DSI_DLTCR_HS2LP_TIME0          ((uint32_t)0x01000000)
S#define DSI_DLTCR_HS2LP_TIME1          ((uint32_t)0x02000000)
S#define DSI_DLTCR_HS2LP_TIME2          ((uint32_t)0x04000000)
S#define DSI_DLTCR_HS2LP_TIME3          ((uint32_t)0x08000000)
S#define DSI_DLTCR_HS2LP_TIME4          ((uint32_t)0x10000000)
S#define DSI_DLTCR_HS2LP_TIME5          ((uint32_t)0x20000000)
S#define DSI_DLTCR_HS2LP_TIME6          ((uint32_t)0x40000000)
S#define DSI_DLTCR_HS2LP_TIME7          ((uint32_t)0x80000000)
S
S/*******************  Bit definition for DSI_PCTLR register  **************/
S#define DSI_PCTLR_DEN                  ((uint32_t)0x00000002)               /*!< Digital Enable */
S#define DSI_PCTLR_CKE                  ((uint32_t)0x00000004)               /*!< Clock Enable */
S
S/*******************  Bit definition for DSI_PCONFR register  *************/
S#define DSI_PCONFR_NL                  ((uint32_t)0x00000003)               /*!< Number of Lanes */
S#define DSI_PCONFR_NL0                 ((uint32_t)0x00000001)
S#define DSI_PCONFR_NL1                 ((uint32_t)0x00000002)
S                                     
S#define DSI_PCONFR_SW_TIME             ((uint32_t)0x0000FF00)               /*!< Stop Wait Time */
S#define DSI_PCONFR_SW_TIME0            ((uint32_t)0x00000100)
S#define DSI_PCONFR_SW_TIME1            ((uint32_t)0x00000200)
S#define DSI_PCONFR_SW_TIME2            ((uint32_t)0x00000400)
S#define DSI_PCONFR_SW_TIME3            ((uint32_t)0x00000800)
S#define DSI_PCONFR_SW_TIME4            ((uint32_t)0x00001000)
S#define DSI_PCONFR_SW_TIME5            ((uint32_t)0x00002000)
S#define DSI_PCONFR_SW_TIME6            ((uint32_t)0x00004000)
S#define DSI_PCONFR_SW_TIME7            ((uint32_t)0x00008000)
S
S/*******************  Bit definition for DSI_PUCR register  ***************/
S#define DSI_PUCR_URCL                  ((uint32_t)0x00000001)               /*!< ULPS Request on Clock Lane */
S#define DSI_PUCR_UECL                  ((uint32_t)0x00000002)               /*!< ULPS Exit on Clock Lane */
S#define DSI_PUCR_URDL                  ((uint32_t)0x00000004)               /*!< ULPS Request on Data Lane */
S#define DSI_PUCR_UEDL                  ((uint32_t)0x00000008)               /*!< ULPS Exit on Data Lane */
S
S/*******************  Bit definition for DSI_PTTCR register  **************/
S#define DSI_PTTCR_TX_TRIG              ((uint32_t)0x0000000F)               /*!< Transmission Trigger */
S#define DSI_PTTCR_TX_TRIG0             ((uint32_t)0x00000001)
S#define DSI_PTTCR_TX_TRIG1             ((uint32_t)0x00000002)
S#define DSI_PTTCR_TX_TRIG2             ((uint32_t)0x00000004)
S#define DSI_PTTCR_TX_TRIG3             ((uint32_t)0x00000008)
S
S/*******************  Bit definition for DSI_PSR register  ****************/
S#define DSI_PSR_PD                     ((uint32_t)0x00000002)               /*!< PHY Direction */
S#define DSI_PSR_PSSC                   ((uint32_t)0x00000004)               /*!< PHY Stop State Clock lane */
S#define DSI_PSR_UANC                   ((uint32_t)0x00000008)               /*!< ULPS Active Not Clock lane */
S#define DSI_PSR_PSS0                   ((uint32_t)0x00000010)               /*!< PHY Stop State lane 0 */
S#define DSI_PSR_UAN0                   ((uint32_t)0x00000020)               /*!< ULPS Active Not lane 0 */
S#define DSI_PSR_RUE0                   ((uint32_t)0x00000040)               /*!< RX ULPS Escape lane 0 */
S#define DSI_PSR_PSS1                   ((uint32_t)0x00000080)               /*!< PHY Stop State lane 1 */
S#define DSI_PSR_UAN1                   ((uint32_t)0x00000100)               /*!< ULPS Active Not lane 1 */
S
S/*******************  Bit definition for DSI_ISR0 register  ***************/
S#define DSI_ISR0_AE0                   ((uint32_t)0x00000001)               /*!< Acknowledge Error 0 */
S#define DSI_ISR0_AE1                   ((uint32_t)0x00000002)               /*!< Acknowledge Error 1 */
S#define DSI_ISR0_AE2                   ((uint32_t)0x00000004)               /*!< Acknowledge Error 2 */
S#define DSI_ISR0_AE3                   ((uint32_t)0x00000008)               /*!< Acknowledge Error 3 */
S#define DSI_ISR0_AE4                   ((uint32_t)0x00000010)               /*!< Acknowledge Error 4 */
S#define DSI_ISR0_AE5                   ((uint32_t)0x00000020)               /*!< Acknowledge Error 5 */
S#define DSI_ISR0_AE6                   ((uint32_t)0x00000040)               /*!< Acknowledge Error 6 */
S#define DSI_ISR0_AE7                   ((uint32_t)0x00000080)               /*!< Acknowledge Error 7 */
S#define DSI_ISR0_AE8                   ((uint32_t)0x00000100)               /*!< Acknowledge Error 8 */
S#define DSI_ISR0_AE9                   ((uint32_t)0x00000200)               /*!< Acknowledge Error 9 */
S#define DSI_ISR0_AE10                  ((uint32_t)0x00000400)               /*!< Acknowledge Error 10 */
S#define DSI_ISR0_AE11                  ((uint32_t)0x00000800)               /*!< Acknowledge Error 11 */
S#define DSI_ISR0_AE12                  ((uint32_t)0x00001000)               /*!< Acknowledge Error 12 */
S#define DSI_ISR0_AE13                  ((uint32_t)0x00002000)               /*!< Acknowledge Error 13 */
S#define DSI_ISR0_AE14                  ((uint32_t)0x00004000)               /*!< Acknowledge Error 14 */
S#define DSI_ISR0_AE15                  ((uint32_t)0x00008000)               /*!< Acknowledge Error 15 */
S#define DSI_ISR0_PE0                   ((uint32_t)0x00010000)               /*!< PHY Error 0 */
S#define DSI_ISR0_PE1                   ((uint32_t)0x00020000)               /*!< PHY Error 1 */
S#define DSI_ISR0_PE2                   ((uint32_t)0x00040000)               /*!< PHY Error 2 */
S#define DSI_ISR0_PE3                   ((uint32_t)0x00080000)               /*!< PHY Error 3 */
S#define DSI_ISR0_PE4                   ((uint32_t)0x00100000)               /*!< PHY Error 4 */
S
S/*******************  Bit definition for DSI_ISR1 register  ***************/
S#define DSI_ISR1_TOHSTX                ((uint32_t)0x00000001)               /*!< Timeout High-Speed Transmission */
S#define DSI_ISR1_TOLPRX                ((uint32_t)0x00000002)               /*!< Timeout Low-Power Reception */
S#define DSI_ISR1_ECCSE                 ((uint32_t)0x00000004)               /*!< ECC Single-bit Error */
S#define DSI_ISR1_ECCME                 ((uint32_t)0x00000008)               /*!< ECC Multi-bit Error */
S#define DSI_ISR1_CRCE                  ((uint32_t)0x00000010)               /*!< CRC Error */
S#define DSI_ISR1_PSE                   ((uint32_t)0x00000020)               /*!< Packet Size Error */
S#define DSI_ISR1_EOTPE                 ((uint32_t)0x00000040)               /*!< EoTp Error */
S#define DSI_ISR1_LPWRE                 ((uint32_t)0x00000080)               /*!< LTDC Payload Write Error */
S#define DSI_ISR1_GCWRE                 ((uint32_t)0x00000100)               /*!< Generic Command Write Error */
S#define DSI_ISR1_GPWRE                 ((uint32_t)0x00000200)               /*!< Generic Payload Write Error */
S#define DSI_ISR1_GPTXE                 ((uint32_t)0x00000400)               /*!< Generic Payload Transmit Error */
S#define DSI_ISR1_GPRDE                 ((uint32_t)0x00000800)               /*!< Generic Payload Read Error */
S#define DSI_ISR1_GPRXE                 ((uint32_t)0x00001000)               /*!< Generic Payload Receive Error */
S
S/*******************  Bit definition for DSI_IER0 register  ***************/
S#define DSI_IER0_AE0IE                 ((uint32_t)0x00000001)               /*!< Acknowledge Error 0 Interrupt Enable */
S#define DSI_IER0_AE1IE                 ((uint32_t)0x00000002)               /*!< Acknowledge Error 1 Interrupt Enable */
S#define DSI_IER0_AE2IE                 ((uint32_t)0x00000004)               /*!< Acknowledge Error 2 Interrupt Enable */
S#define DSI_IER0_AE3IE                 ((uint32_t)0x00000008)               /*!< Acknowledge Error 3 Interrupt Enable */
S#define DSI_IER0_AE4IE                 ((uint32_t)0x00000010)               /*!< Acknowledge Error 4 Interrupt Enable */
S#define DSI_IER0_AE5IE                 ((uint32_t)0x00000020)               /*!< Acknowledge Error 5 Interrupt Enable */
S#define DSI_IER0_AE6IE                 ((uint32_t)0x00000040)               /*!< Acknowledge Error 6 Interrupt Enable */
S#define DSI_IER0_AE7IE                 ((uint32_t)0x00000080)               /*!< Acknowledge Error 7 Interrupt Enable */
S#define DSI_IER0_AE8IE                 ((uint32_t)0x00000100)               /*!< Acknowledge Error 8 Interrupt Enable */
S#define DSI_IER0_AE9IE                 ((uint32_t)0x00000200)               /*!< Acknowledge Error 9 Interrupt Enable */
S#define DSI_IER0_AE10IE                ((uint32_t)0x00000400)               /*!< Acknowledge Error 10 Interrupt Enable */
S#define DSI_IER0_AE11IE                ((uint32_t)0x00000800)               /*!< Acknowledge Error 11 Interrupt Enable */
S#define DSI_IER0_AE12IE                ((uint32_t)0x00001000)               /*!< Acknowledge Error 12 Interrupt Enable */
S#define DSI_IER0_AE13IE                ((uint32_t)0x00002000)               /*!< Acknowledge Error 13 Interrupt Enable */
S#define DSI_IER0_AE14IE                ((uint32_t)0x00004000)               /*!< Acknowledge Error 14 Interrupt Enable */
S#define DSI_IER0_AE15IE                ((uint32_t)0x00008000)               /*!< Acknowledge Error 15 Interrupt Enable */
S#define DSI_IER0_PE0IE                 ((uint32_t)0x00010000)               /*!< PHY Error 0 Interrupt Enable */
S#define DSI_IER0_PE1IE                 ((uint32_t)0x00020000)               /*!< PHY Error 1 Interrupt Enable */
S#define DSI_IER0_PE2IE                 ((uint32_t)0x00040000)               /*!< PHY Error 2 Interrupt Enable */
S#define DSI_IER0_PE3IE                 ((uint32_t)0x00080000)               /*!< PHY Error 3 Interrupt Enable */
S#define DSI_IER0_PE4IE                 ((uint32_t)0x00100000)               /*!< PHY Error 4 Interrupt Enable */
S
S/*******************  Bit definition for DSI_IER1 register  ***************/
S#define DSI_IER1_TOHSTXIE              ((uint32_t)0x00000001)               /*!< Timeout High-Speed Transmission Interrupt Enable */
S#define DSI_IER1_TOLPRXIE              ((uint32_t)0x00000002)               /*!< Timeout Low-Power Reception Interrupt Enable */
S#define DSI_IER1_ECCSEIE               ((uint32_t)0x00000004)               /*!< ECC Single-bit Error Interrupt Enable */
S#define DSI_IER1_ECCMEIE               ((uint32_t)0x00000008)               /*!< ECC Multi-bit Error Interrupt Enable */
S#define DSI_IER1_CRCEIE                ((uint32_t)0x00000010)               /*!< CRC Error Interrupt Enable */
S#define DSI_IER1_PSEIE                 ((uint32_t)0x00000020)               /*!< Packet Size Error Interrupt Enable */
S#define DSI_IER1_EOTPEIE               ((uint32_t)0x00000040)               /*!< EoTp Error Interrupt Enable */
S#define DSI_IER1_LPWREIE               ((uint32_t)0x00000080)               /*!< LTDC Payload Write Error Interrupt Enable */
S#define DSI_IER1_GCWREIE               ((uint32_t)0x00000100)               /*!< Generic Command Write Error Interrupt Enable */
S#define DSI_IER1_GPWREIE               ((uint32_t)0x00000200)               /*!< Generic Payload Write Error Interrupt Enable */
S#define DSI_IER1_GPTXEIE               ((uint32_t)0x00000400)               /*!< Generic Payload Transmit Error Interrupt Enable */
S#define DSI_IER1_GPRDEIE               ((uint32_t)0x00000800)               /*!< Generic Payload Read Error Interrupt Enable */
S#define DSI_IER1_GPRXEIE               ((uint32_t)0x00001000)               /*!< Generic Payload Receive Error Interrupt Enable */
S
S/*******************  Bit definition for DSI_FIR0 register  ***************/
S#define DSI_FIR0_FAE0                  ((uint32_t)0x00000001)               /*!< Force Acknowledge Error 0 */
S#define DSI_FIR0_FAE1                  ((uint32_t)0x00000002)               /*!< Force Acknowledge Error 1 */
S#define DSI_FIR0_FAE2                  ((uint32_t)0x00000004)               /*!< Force Acknowledge Error 2 */
S#define DSI_FIR0_FAE3                  ((uint32_t)0x00000008)               /*!< Force Acknowledge Error 3 */
S#define DSI_FIR0_FAE4                  ((uint32_t)0x00000010)               /*!< Force Acknowledge Error 4 */
S#define DSI_FIR0_FAE5                  ((uint32_t)0x00000020)               /*!< Force Acknowledge Error 5 */
S#define DSI_FIR0_FAE6                  ((uint32_t)0x00000040)               /*!< Force Acknowledge Error 6 */
S#define DSI_FIR0_FAE7                  ((uint32_t)0x00000080)               /*!< Force Acknowledge Error 7 */
S#define DSI_FIR0_FAE8                  ((uint32_t)0x00000100)               /*!< Force Acknowledge Error 8 */
S#define DSI_FIR0_FAE9                  ((uint32_t)0x00000200)               /*!< Force Acknowledge Error 9 */
S#define DSI_FIR0_FAE10                 ((uint32_t)0x00000400)               /*!< Force Acknowledge Error 10 */
S#define DSI_FIR0_FAE11                 ((uint32_t)0x00000800)               /*!< Force Acknowledge Error 11 */
S#define DSI_FIR0_FAE12                 ((uint32_t)0x00001000)               /*!< Force Acknowledge Error 12 */
S#define DSI_FIR0_FAE13                 ((uint32_t)0x00002000)               /*!< Force Acknowledge Error 13 */
S#define DSI_FIR0_FAE14                 ((uint32_t)0x00004000)               /*!< Force Acknowledge Error 14 */
S#define DSI_FIR0_FAE15                 ((uint32_t)0x00008000)               /*!< Force Acknowledge Error 15 */
S#define DSI_FIR0_FPE0                  ((uint32_t)0x00010000)               /*!< Force PHY Error 0 */
S#define DSI_FIR0_FPE1                  ((uint32_t)0x00020000)               /*!< Force PHY Error 1 */
S#define DSI_FIR0_FPE2                  ((uint32_t)0x00040000)               /*!< Force PHY Error 2 */
S#define DSI_FIR0_FPE3                  ((uint32_t)0x00080000)               /*!< Force PHY Error 3 */
S#define DSI_FIR0_FPE4                  ((uint32_t)0x00100000)               /*!< Force PHY Error 4 */
S
S/*******************  Bit definition for DSI_FIR1 register  ***************/
S#define DSI_FIR1_FTOHSTX               ((uint32_t)0x00000001)               /*!< Force Timeout High-Speed Transmission */
S#define DSI_FIR1_FTOLPRX               ((uint32_t)0x00000002)               /*!< Force Timeout Low-Power Reception */
S#define DSI_FIR1_FECCSE                ((uint32_t)0x00000004)               /*!< Force ECC Single-bit Error */
S#define DSI_FIR1_FECCME                ((uint32_t)0x00000008)               /*!< Force ECC Multi-bit Error */
S#define DSI_FIR1_FCRCE                 ((uint32_t)0x00000010)               /*!< Force CRC Error */
S#define DSI_FIR1_FPSE                  ((uint32_t)0x00000020)               /*!< Force Packet Size Error */
S#define DSI_FIR1_FEOTPE                ((uint32_t)0x00000040)               /*!< Force EoTp Error */
S#define DSI_FIR1_FLPWRE                ((uint32_t)0x00000080)               /*!< Force LTDC Payload Write Error */
S#define DSI_FIR1_FGCWRE                ((uint32_t)0x00000100)               /*!< Force Generic Command Write Error */
S#define DSI_FIR1_FGPWRE                ((uint32_t)0x00000200)               /*!< Force Generic Payload Write Error */
S#define DSI_FIR1_FGPTXE                ((uint32_t)0x00000400)               /*!< Force Generic Payload Transmit Error */
S#define DSI_FIR1_FGPRDE                ((uint32_t)0x00000800)               /*!< Force Generic Payload Read Error */
S#define DSI_FIR1_FGPRXE                ((uint32_t)0x00001000)               /*!< Force Generic Payload Receive Error */
S
S/*******************  Bit definition for DSI_VSCR register  ***************/
S#define DSI_VSCR_EN                    ((uint32_t)0x00000001)               /*!< Enable */
S#define DSI_VSCR_UR                    ((uint32_t)0x00000100)               /*!< Update Register */
S
S/*******************  Bit definition for DSI_LCVCIDR register  ************/
S#define DSI_LCVCIDR_VCID               ((uint32_t)0x00000003)               /*!< Virtual Channel ID */
S#define DSI_LCVCIDR_VCID0              ((uint32_t)0x00000001)
S#define DSI_LCVCIDR_VCID1              ((uint32_t)0x00000002)
S
S/*******************  Bit definition for DSI_LCCCR register  **************/
S#define DSI_LCCCR_COLC                 ((uint32_t)0x0000000F)               /*!< Color Coding */
S#define DSI_LCCCR_COLC0                ((uint32_t)0x00000001)
S#define DSI_LCCCR_COLC1                ((uint32_t)0x00000002)
S#define DSI_LCCCR_COLC2                ((uint32_t)0x00000004)
S#define DSI_LCCCR_COLC3                ((uint32_t)0x00000008)
S
S#define DSI_LCCCR_LPE                  ((uint32_t)0x00000100)               /*!< Loosely Packed Enable */
S
S/*******************  Bit definition for DSI_LPMCCR register  *************/
S#define DSI_LPMCCR_VLPSIZE             ((uint32_t)0x000000FF)               /*!< VACT Largest Packet Size */
S#define DSI_LPMCCR_VLPSIZE0            ((uint32_t)0x00000001)
S#define DSI_LPMCCR_VLPSIZE1            ((uint32_t)0x00000002)
S#define DSI_LPMCCR_VLPSIZE2            ((uint32_t)0x00000004)
S#define DSI_LPMCCR_VLPSIZE3            ((uint32_t)0x00000008)
S#define DSI_LPMCCR_VLPSIZE4            ((uint32_t)0x00000010)
S#define DSI_LPMCCR_VLPSIZE5            ((uint32_t)0x00000020)
S#define DSI_LPMCCR_VLPSIZE6            ((uint32_t)0x00000040)
S#define DSI_LPMCCR_VLPSIZE7            ((uint32_t)0x00000080)
S
S#define DSI_LPMCCR_LPSIZE              ((uint32_t)0x00FF0000)               /*!< Largest Packet Size */
S#define DSI_LPMCCR_LPSIZE0             ((uint32_t)0x00010000)
S#define DSI_LPMCCR_LPSIZE1             ((uint32_t)0x00020000)
S#define DSI_LPMCCR_LPSIZE2             ((uint32_t)0x00040000)
S#define DSI_LPMCCR_LPSIZE3             ((uint32_t)0x00080000)
S#define DSI_LPMCCR_LPSIZE4             ((uint32_t)0x00100000)
S#define DSI_LPMCCR_LPSIZE5             ((uint32_t)0x00200000)
S#define DSI_LPMCCR_LPSIZE6             ((uint32_t)0x00400000)
S#define DSI_LPMCCR_LPSIZE7             ((uint32_t)0x00800000)
S
S/*******************  Bit definition for DSI_VMCCR register  **************/
S#define DSI_VMCCR_VMT                  ((uint32_t)0x00000003)               /*!< Video Mode Type */
S#define DSI_VMCCR_VMT0                 ((uint32_t)0x00000001)
S#define DSI_VMCCR_VMT1                 ((uint32_t)0x00000002)
S
S#define DSI_VMCCR_LPVSAE               ((uint32_t)0x00000100)               /*!< Low-power Vertical Sync time Enable */
S#define DSI_VMCCR_LPVBPE               ((uint32_t)0x00000200)               /*!< Low-power Vertical Back-porch Enable */
S#define DSI_VMCCR_LPVFPE               ((uint32_t)0x00000400)               /*!< Low-power Vertical Front-porch Enable */
S#define DSI_VMCCR_LPVAE                ((uint32_t)0x00000800)               /*!< Low-power Vertical Active Enable */
S#define DSI_VMCCR_LPHBPE               ((uint32_t)0x00001000)               /*!< Low-power Horizontal Back-porch Enable */
S#define DSI_VMCCR_LPHFE                ((uint32_t)0x00002000)               /*!< Low-power Horizontal Front-porch Enable */
S#define DSI_VMCCR_FBTAAE               ((uint32_t)0x00004000)               /*!< Frame BTA Acknowledge Enable */
S#define DSI_VMCCR_LPCE                 ((uint32_t)0x00008000)               /*!< Low-power Command Enable */
S
S/*******************  Bit definition for DSI_VPCCR register  **************/
S#define DSI_VPCCR_VPSIZE               ((uint32_t)0x00003FFF)               /*!< Video Packet Size */
S#define DSI_VPCCR_VPSIZE0              ((uint32_t)0x00000001)
S#define DSI_VPCCR_VPSIZE1              ((uint32_t)0x00000002)
S#define DSI_VPCCR_VPSIZE2              ((uint32_t)0x00000004)
S#define DSI_VPCCR_VPSIZE3              ((uint32_t)0x00000008)
S#define DSI_VPCCR_VPSIZE4              ((uint32_t)0x00000010)
S#define DSI_VPCCR_VPSIZE5              ((uint32_t)0x00000020)
S#define DSI_VPCCR_VPSIZE6              ((uint32_t)0x00000040)
S#define DSI_VPCCR_VPSIZE7              ((uint32_t)0x00000080)
S#define DSI_VPCCR_VPSIZE8              ((uint32_t)0x00000100)
S#define DSI_VPCCR_VPSIZE9              ((uint32_t)0x00000200)
S#define DSI_VPCCR_VPSIZE10             ((uint32_t)0x00000400)
S#define DSI_VPCCR_VPSIZE11             ((uint32_t)0x00000800)
S#define DSI_VPCCR_VPSIZE12             ((uint32_t)0x00001000)
S#define DSI_VPCCR_VPSIZE13             ((uint32_t)0x00002000)
S
S/*******************  Bit definition for DSI_VCCCR register  **************/
S#define DSI_VCCCR_NUMC                 ((uint32_t)0x00001FFF)               /*!< Number of Chunks */
S#define DSI_VCCCR_NUMC0                ((uint32_t)0x00000001)
S#define DSI_VCCCR_NUMC1                ((uint32_t)0x00000002)
S#define DSI_VCCCR_NUMC2                ((uint32_t)0x00000004)
S#define DSI_VCCCR_NUMC3                ((uint32_t)0x00000008)
S#define DSI_VCCCR_NUMC4                ((uint32_t)0x00000010)
S#define DSI_VCCCR_NUMC5                ((uint32_t)0x00000020)
S#define DSI_VCCCR_NUMC6                ((uint32_t)0x00000040)
S#define DSI_VCCCR_NUMC7                ((uint32_t)0x00000080)
S#define DSI_VCCCR_NUMC8                ((uint32_t)0x00000100)
S#define DSI_VCCCR_NUMC9                ((uint32_t)0x00000200)
S#define DSI_VCCCR_NUMC10               ((uint32_t)0x00000400)
S#define DSI_VCCCR_NUMC11               ((uint32_t)0x00000800)
S#define DSI_VCCCR_NUMC12               ((uint32_t)0x00001000)
S
S/*******************  Bit definition for DSI_VNPCCR register  *************/
S#define DSI_VNPCCR_NPSIZE              ((uint32_t)0x00001FFF)               /*!< Number of Chunks */
S#define DSI_VNPCCR_NPSIZE0             ((uint32_t)0x00000001)
S#define DSI_VNPCCR_NPSIZE1             ((uint32_t)0x00000002)
S#define DSI_VNPCCR_NPSIZE2             ((uint32_t)0x00000004)
S#define DSI_VNPCCR_NPSIZE3             ((uint32_t)0x00000008)
S#define DSI_VNPCCR_NPSIZE4             ((uint32_t)0x00000010)
S#define DSI_VNPCCR_NPSIZE5             ((uint32_t)0x00000020)
S#define DSI_VNPCCR_NPSIZE6             ((uint32_t)0x00000040)
S#define DSI_VNPCCR_NPSIZE7             ((uint32_t)0x00000080)
S#define DSI_VNPCCR_NPSIZE8             ((uint32_t)0x00000100)
S#define DSI_VNPCCR_NPSIZE9             ((uint32_t)0x00000200)
S#define DSI_VNPCCR_NPSIZE10            ((uint32_t)0x00000400)
S#define DSI_VNPCCR_NPSIZE11            ((uint32_t)0x00000800)
S#define DSI_VNPCCR_NPSIZE12            ((uint32_t)0x00001000)
S
S/*******************  Bit definition for DSI_VHSACCR register  ************/
S#define DSI_VHSACCR_HSA                ((uint32_t)0x00000FFF)               /*!< Horizontal Synchronism Active duration */
S#define DSI_VHSACCR_HSA0               ((uint32_t)0x00000001)
S#define DSI_VHSACCR_HSA1               ((uint32_t)0x00000002)
S#define DSI_VHSACCR_HSA2               ((uint32_t)0x00000004)
S#define DSI_VHSACCR_HSA3               ((uint32_t)0x00000008)
S#define DSI_VHSACCR_HSA4               ((uint32_t)0x00000010)
S#define DSI_VHSACCR_HSA5               ((uint32_t)0x00000020)
S#define DSI_VHSACCR_HSA6               ((uint32_t)0x00000040)
S#define DSI_VHSACCR_HSA7               ((uint32_t)0x00000080)
S#define DSI_VHSACCR_HSA8               ((uint32_t)0x00000100)
S#define DSI_VHSACCR_HSA9               ((uint32_t)0x00000200)
S#define DSI_VHSACCR_HSA10              ((uint32_t)0x00000400)
S#define DSI_VHSACCR_HSA11              ((uint32_t)0x00000800)
S
S/*******************  Bit definition for DSI_VHBPCCR register  ************/
S#define DSI_VHBPCCR_HBP                ((uint32_t)0x00000FFF)               /*!< Horizontal Back-Porch duration */
S#define DSI_VHBPCCR_HBP0               ((uint32_t)0x00000001)
S#define DSI_VHBPCCR_HBP1               ((uint32_t)0x00000002)
S#define DSI_VHBPCCR_HBP2               ((uint32_t)0x00000004)
S#define DSI_VHBPCCR_HBP3               ((uint32_t)0x00000008)
S#define DSI_VHBPCCR_HBP4               ((uint32_t)0x00000010)
S#define DSI_VHBPCCR_HBP5               ((uint32_t)0x00000020)
S#define DSI_VHBPCCR_HBP6               ((uint32_t)0x00000040)
S#define DSI_VHBPCCR_HBP7               ((uint32_t)0x00000080)
S#define DSI_VHBPCCR_HBP8               ((uint32_t)0x00000100)
S#define DSI_VHBPCCR_HBP9               ((uint32_t)0x00000200)
S#define DSI_VHBPCCR_HBP10              ((uint32_t)0x00000400)
S#define DSI_VHBPCCR_HBP11              ((uint32_t)0x00000800)
S
S/*******************  Bit definition for DSI_VLCCR register  **************/
S#define DSI_VLCCR_HLINE                ((uint32_t)0x00007FFF)               /*!< Horizontal Line duration */
S#define DSI_VLCCR_HLINE0               ((uint32_t)0x00000001)
S#define DSI_VLCCR_HLINE1               ((uint32_t)0x00000002)
S#define DSI_VLCCR_HLINE2               ((uint32_t)0x00000004)
S#define DSI_VLCCR_HLINE3               ((uint32_t)0x00000008)
S#define DSI_VLCCR_HLINE4               ((uint32_t)0x00000010)
S#define DSI_VLCCR_HLINE5               ((uint32_t)0x00000020)
S#define DSI_VLCCR_HLINE6               ((uint32_t)0x00000040)
S#define DSI_VLCCR_HLINE7               ((uint32_t)0x00000080)
S#define DSI_VLCCR_HLINE8               ((uint32_t)0x00000100)
S#define DSI_VLCCR_HLINE9               ((uint32_t)0x00000200)
S#define DSI_VLCCR_HLINE10              ((uint32_t)0x00000400)
S#define DSI_VLCCR_HLINE11              ((uint32_t)0x00000800)
S#define DSI_VLCCR_HLINE12              ((uint32_t)0x00001000)
S#define DSI_VLCCR_HLINE13              ((uint32_t)0x00002000)
S#define DSI_VLCCR_HLINE14              ((uint32_t)0x00004000)
S
S/*******************  Bit definition for DSI_VVSACCR register  ***************/
S#define DSI_VVSACCR_VSA                   ((uint32_t)0x000003FF)               /*!< Vertical Synchronism Active duration */
S#define DSI_VVSACCR_VSA0                  ((uint32_t)0x00000001)
S#define DSI_VVSACCR_VSA1                  ((uint32_t)0x00000002)
S#define DSI_VVSACCR_VSA2                  ((uint32_t)0x00000004)
S#define DSI_VVSACCR_VSA3                  ((uint32_t)0x00000008)
S#define DSI_VVSACCR_VSA4                  ((uint32_t)0x00000010)
S#define DSI_VVSACCR_VSA5                  ((uint32_t)0x00000020)
S#define DSI_VVSACCR_VSA6                  ((uint32_t)0x00000040)
S#define DSI_VVSACCR_VSA7                  ((uint32_t)0x00000080)
S#define DSI_VVSACCR_VSA8                  ((uint32_t)0x00000100)
S#define DSI_VVSACCR_VSA9                  ((uint32_t)0x00000200)
S
S/*******************  Bit definition for DSI_VVBPCCR register  ************/
S#define DSI_VVBPCCR_VBP                ((uint32_t)0x000003FF)               /*!< Vertical Back-Porch duration */
S#define DSI_VVBPCCR_VBP0               ((uint32_t)0x00000001)
S#define DSI_VVBPCCR_VBP1               ((uint32_t)0x00000002)
S#define DSI_VVBPCCR_VBP2               ((uint32_t)0x00000004)
S#define DSI_VVBPCCR_VBP3               ((uint32_t)0x00000008)
S#define DSI_VVBPCCR_VBP4               ((uint32_t)0x00000010)
S#define DSI_VVBPCCR_VBP5               ((uint32_t)0x00000020)
S#define DSI_VVBPCCR_VBP6               ((uint32_t)0x00000040)
S#define DSI_VVBPCCR_VBP7               ((uint32_t)0x00000080)
S#define DSI_VVBPCCR_VBP8               ((uint32_t)0x00000100)
S#define DSI_VVBPCCR_VBP9               ((uint32_t)0x00000200)
S
S/*******************  Bit definition for DSI_VVFPCCR register  ************/
S#define DSI_VVFPCCR_VFP                ((uint32_t)0x000003FF)               /*!< Vertical Front-Porch duration */
S#define DSI_VVFPCCR_VFP0               ((uint32_t)0x00000001)
S#define DSI_VVFPCCR_VFP1               ((uint32_t)0x00000002)
S#define DSI_VVFPCCR_VFP2               ((uint32_t)0x00000004)
S#define DSI_VVFPCCR_VFP3               ((uint32_t)0x00000008)
S#define DSI_VVFPCCR_VFP4               ((uint32_t)0x00000010)
S#define DSI_VVFPCCR_VFP5               ((uint32_t)0x00000020)
S#define DSI_VVFPCCR_VFP6               ((uint32_t)0x00000040)
S#define DSI_VVFPCCR_VFP7               ((uint32_t)0x00000080)
S#define DSI_VVFPCCR_VFP8               ((uint32_t)0x00000100)
S#define DSI_VVFPCCR_VFP9               ((uint32_t)0x00000200)
S
S/*******************  Bit definition for DSI_VVACCR register  *************/
S#define DSI_VVACCR_VA                  ((uint32_t)0x00003FFF)               /*!< Vertical Active duration */
S#define DSI_VVACCR_VA0                 ((uint32_t)0x00000001)
S#define DSI_VVACCR_VA1                 ((uint32_t)0x00000002)
S#define DSI_VVACCR_VA2                 ((uint32_t)0x00000004)
S#define DSI_VVACCR_VA3                 ((uint32_t)0x00000008)
S#define DSI_VVACCR_VA4                 ((uint32_t)0x00000010)
S#define DSI_VVACCR_VA5                 ((uint32_t)0x00000020)
S#define DSI_VVACCR_VA6                 ((uint32_t)0x00000040)
S#define DSI_VVACCR_VA7                 ((uint32_t)0x00000080)
S#define DSI_VVACCR_VA8                 ((uint32_t)0x00000100)
S#define DSI_VVACCR_VA9                 ((uint32_t)0x00000200)
S#define DSI_VVACCR_VA10                ((uint32_t)0x00000400)
S#define DSI_VVACCR_VA11                ((uint32_t)0x00000800)
S#define DSI_VVACCR_VA12                ((uint32_t)0x00001000)
S#define DSI_VVACCR_VA13                ((uint32_t)0x00002000)
S
S/*******************  Bit definition for DSI_TDCCR register  **************/
S#define DSI_TDCCR_3DM                  ((uint32_t)0x00000003)               /*!< 3D Mode */
S#define DSI_TDCCR_3DM0                 ((uint32_t)0x00000001)
S#define DSI_TDCCR_3DM1                 ((uint32_t)0x00000002)
S
S#define DSI_TDCCR_3DF                  ((uint32_t)0x0000000C)               /*!< 3D Format */
S#define DSI_TDCCR_3DF0                 ((uint32_t)0x00000004)
S#define DSI_TDCCR_3DF1                 ((uint32_t)0x00000008)
S
S#define DSI_TDCCR_SVS                  ((uint32_t)0x00000010)               /*!< Second VSYNC */
S#define DSI_TDCCR_RF                   ((uint32_t)0x00000020)               /*!< Right First */
S#define DSI_TDCCR_S3DC                 ((uint32_t)0x00010000)               /*!< Send 3D Control */
S
S/*******************  Bit definition for DSI_WCFGR register  ***************/
S#define DSI_WCFGR_DSIM                   ((uint32_t)0x00000001)              /*!< DSI Mode */
S#define DSI_WCFGR_COLMUX                 ((uint32_t)0x0000000E)              /*!< Color Multiplexing */
S#define DSI_WCFGR_COLMUX0                ((uint32_t)0x00000002)
S#define DSI_WCFGR_COLMUX1                ((uint32_t)0x00000004)
S#define DSI_WCFGR_COLMUX2                ((uint32_t)0x00000008)
S 
S#define DSI_WCFGR_TESRC                  ((uint32_t)0x00000010)              /*!< Tearing Effect Source */
S#define DSI_WCFGR_TEPOL                  ((uint32_t)0x00000020)              /*!< Tearing Effect Polarity */
S#define DSI_WCFGR_AR                     ((uint32_t)0x00000040)              /*!< Automatic Refresh */
S#define DSI_WCFGR_VSPOL                  ((uint32_t)0x00000080)              /*!< VSync Polarity */
S
S/*******************  Bit definition for DSI_WCR register  *****************/
S#define DSI_WCR_COLM                     ((uint32_t)0x00000001)              /*!< Color Mode */
S#define DSI_WCR_SHTDN                    ((uint32_t)0x00000002)              /*!< Shutdown */
S#define DSI_WCR_LTDCEN                   ((uint32_t)0x00000004)              /*!< LTDC Enable */
S#define DSI_WCR_DSIEN                    ((uint32_t)0x00000008)              /*!< DSI Enable */
S
S/*******************  Bit definition for DSI_WIER register  ****************/
S#define DSI_WIER_TEIE                    ((uint32_t)0x00000001)              /*!< Tearing Effect Interrupt Enable */
S#define DSI_WIER_ERIE                    ((uint32_t)0x00000002)              /*!< End of Refresh Interrupt Enable */
S#define DSI_WIER_PLLLIE                  ((uint32_t)0x00000200)              /*!< PLL Lock Interrupt Enable */
S#define DSI_WIER_PLLUIE                  ((uint32_t)0x00000400)              /*!< PLL Unlock Interrupt Enable */
S#define DSI_WIER_RRIE                    ((uint32_t)0x00002000)              /*!< Regulator Ready Interrupt Enable */
S
S/*******************  Bit definition for DSI_WISR register  ****************/
S#define DSI_WISR_TEIF                    ((uint32_t)0x00000001)              /*!< Tearing Effect Interrupt Flag */
S#define DSI_WISR_ERIF                    ((uint32_t)0x00000002)              /*!< End of Refresh Interrupt Flag */
S#define DSI_WISR_BUSY                    ((uint32_t)0x00000004)              /*!< Busy Flag */
S#define DSI_WISR_PLLLS                   ((uint32_t)0x00000100)              /*!< PLL Lock Status */
S#define DSI_WISR_PLLLIF                  ((uint32_t)0x00000200)              /*!< PLL Lock Interrupt Flag */
S#define DSI_WISR_PLLUIF                  ((uint32_t)0x00000400)              /*!< PLL Unlock Interrupt Flag */
S#define DSI_WISR_RRS                     ((uint32_t)0x00001000)              /*!< Regulator Ready Flag */
S#define DSI_WISR_RRIF                    ((uint32_t)0x00002000)              /*!< Regulator Ready Interrupt Flag */
S
S/*******************  Bit definition for DSI_WIFCR register  ***************/
S#define DSI_WIFCR_CTEIF                  ((uint32_t)0x00000001)              /*!< Clear Tearing Effect Interrupt Flag */
S#define DSI_WIFCR_CERIF                  ((uint32_t)0x00000002)              /*!< Clear End of Refresh Interrupt Flag */
S#define DSI_WIFCR_CPLLLIF                ((uint32_t)0x00000200)              /*!< Clear PLL Lock Interrupt Flag */
S#define DSI_WIFCR_CPLLUIF                ((uint32_t)0x00000400)              /*!< Clear PLL Unlock Interrupt Flag */
S#define DSI_WIFCR_CRRIF                  ((uint32_t)0x00002000)              /*!< Clear Regulator Ready Interrupt Flag */
S
S/*******************  Bit definition for DSI_WPCR0 register  ***************/
S#define DSI_WPCR0_UIX4                   ((uint32_t)0x0000003F)              /*!< Unit Interval multiplied by 4 */
S#define DSI_WPCR0_UIX4_0                 ((uint32_t)0x00000001)
S#define DSI_WPCR0_UIX4_1                 ((uint32_t)0x00000002)
S#define DSI_WPCR0_UIX4_2                 ((uint32_t)0x00000004)
S#define DSI_WPCR0_UIX4_3                 ((uint32_t)0x00000008)
S#define DSI_WPCR0_UIX4_4                 ((uint32_t)0x00000010)
S#define DSI_WPCR0_UIX4_5                 ((uint32_t)0x00000020)
S
S#define DSI_WPCR0_SWCL                   ((uint32_t)0x00000040)              /*!< Swap pins on clock lane */
S#define DSI_WPCR0_SWDL0                  ((uint32_t)0x00000080)              /*!< Swap pins on data lane 1 */
S#define DSI_WPCR0_SWDL1                  ((uint32_t)0x00000100)              /*!< Swap pins on data lane 2 */
S#define DSI_WPCR0_HSICL                  ((uint32_t)0x00000200)              /*!< Invert the high-speed data signal on clock lane */
S#define DSI_WPCR0_HSIDL0                 ((uint32_t)0x00000400)              /*!< Invert the high-speed data signal on lane 1 */
S#define DSI_WPCR0_HSIDL1                 ((uint32_t)0x00000800)              /*!< Invert the high-speed data signal on lane 2 */
S#define DSI_WPCR0_FTXSMCL                ((uint32_t)0x00001000)              /*!< Force clock lane in TX stop mode */
S#define DSI_WPCR0_FTXSMDL                ((uint32_t)0x00002000)              /*!< Force data lanes in TX stop mode */
S#define DSI_WPCR0_CDOFFDL                ((uint32_t)0x00004000)              /*!< Contention detection OFF */
S#define DSI_WPCR0_TDDL                   ((uint32_t)0x00010000)              /*!< Turn Disable Data Lanes */
S#define DSI_WPCR0_PDEN                   ((uint32_t)0x00040000)              /*!< Pull-Down Enable */
S#define DSI_WPCR0_TCLKPREPEN             ((uint32_t)0x00080000)              /*!< Timer for t-CLKPREP Enable */
S#define DSI_WPCR0_TCLKZEROEN             ((uint32_t)0x00100000)              /*!< Timer for t-CLKZERO Enable */
S#define DSI_WPCR0_THSPREPEN              ((uint32_t)0x00200000)              /*!< Timer for t-HSPREP Enable */
S#define DSI_WPCR0_THSTRAILEN             ((uint32_t)0x00400000)              /*!< Timer for t-HSTRAIL Enable */
S#define DSI_WPCR0_THSZEROEN              ((uint32_t)0x00800000)              /*!< Timer for t-HSZERO Enable */
S#define DSI_WPCR0_TLPXDEN                ((uint32_t)0x01000000)              /*!< Timer for t-LPXD Enable */
S#define DSI_WPCR0_THSEXITEN              ((uint32_t)0x02000000)              /*!< Timer for t-HSEXIT Enable */
S#define DSI_WPCR0_TLPXCEN                ((uint32_t)0x04000000)              /*!< Timer for t-LPXC Enable */
S#define DSI_WPCR0_TCLKPOSTEN             ((uint32_t)0x08000000)              /*!< Timer for t-CLKPOST Enable */
S
S/*******************  Bit definition for DSI_WPCR1 register  ***************/
S#define DSI_WPCR1_HSTXDCL                ((uint32_t)0x00000003)              /*!< High-Speed Transmission Delay on Clock Lane */
S#define DSI_WPCR1_HSTXDCL0               ((uint32_t)0x00000001)
S#define DSI_WPCR1_HSTXDCL1               ((uint32_t)0x00000002)
S
S#define DSI_WPCR1_HSTXDDL                ((uint32_t)0x0000000C)              /*!< High-Speed Transmission Delay on Data Lane */
S#define DSI_WPCR1_HSTXDDL0               ((uint32_t)0x00000004)
S#define DSI_WPCR1_HSTXDDL1               ((uint32_t)0x00000008)
S
S#define DSI_WPCR1_LPSRCCL                ((uint32_t)0x000000C0)              /*!< Low-Power transmission Slew Rate Compensation on Clock Lane */
S#define DSI_WPCR1_LPSRCCL0               ((uint32_t)0x00000040)
S#define DSI_WPCR1_LPSRCCL1               ((uint32_t)0x00000080)
S
S#define DSI_WPCR1_LPSRCDL                ((uint32_t)0x00000300)              /*!< Low-Power transmission Slew Rate Compensation on Data Lane */
S#define DSI_WPCR1_LPSRCDL0               ((uint32_t)0x00000100)
S#define DSI_WPCR1_LPSRCDL1               ((uint32_t)0x00000200)
S
S#define DSI_WPCR1_SDDC                   ((uint32_t)0x00001000)              /*!< SDD Control */
S
S#define DSI_WPCR1_LPRXVCDL               ((uint32_t)0x0000C000)              /*!< Low-Power Reception V-IL Compensation on Data Lanes */
S#define DSI_WPCR1_LPRXVCDL0              ((uint32_t)0x00004000)
S#define DSI_WPCR1_LPRXVCDL1              ((uint32_t)0x00008000)
S
S#define DSI_WPCR1_HSTXSRCCL              ((uint32_t)0x00030000)              /*!< High-Speed Transmission Delay on Clock Lane */
S#define DSI_WPCR1_HSTXSRCCL0             ((uint32_t)0x00010000)
S#define DSI_WPCR1_HSTXSRCCL1             ((uint32_t)0x00020000)
S
S#define DSI_WPCR1_HSTXSRCDL              ((uint32_t)0x000C0000)              /*!< High-Speed Transmission Delay on Data Lane */
S#define DSI_WPCR1_HSTXSRCDL0             ((uint32_t)0x00040000)
S#define DSI_WPCR1_HSTXSRCDL1             ((uint32_t)0x00080000)
S
S#define DSI_WPCR1_FLPRXLPM               ((uint32_t)0x00400000)              /*!< Forces LP Receiver in Low-Power Mode */
S
S#define DSI_WPCR1_LPRXFT                 ((uint32_t)0x06000000)              /*!< Low-Power RX low-pass Filtering Tuning */
S#define DSI_WPCR1_LPRXFT0                ((uint32_t)0x02000000)
S#define DSI_WPCR1_LPRXFT1                ((uint32_t)0x04000000)
S
S/*******************  Bit definition for DSI_WPCR2 register  ***************/
S#define DSI_WPCR2_TCLKPREP               ((uint32_t)0x000000FF)              /*!< t-CLKPREP */
S#define DSI_WPCR2_TCLKPREP0              ((uint32_t)0x00000001)
S#define DSI_WPCR2_TCLKPREP1              ((uint32_t)0x00000002)
S#define DSI_WPCR2_TCLKPREP2              ((uint32_t)0x00000004)
S#define DSI_WPCR2_TCLKPREP3              ((uint32_t)0x00000008)
S#define DSI_WPCR2_TCLKPREP4              ((uint32_t)0x00000010)
S#define DSI_WPCR2_TCLKPREP5              ((uint32_t)0x00000020)
S#define DSI_WPCR2_TCLKPREP6              ((uint32_t)0x00000040)
S#define DSI_WPCR2_TCLKPREP7              ((uint32_t)0x00000080)
S
S#define DSI_WPCR2_TCLKZERO               ((uint32_t)0x0000FF00)              /*!< t-CLKZERO */
S#define DSI_WPCR2_TCLKZERO0              ((uint32_t)0x00000100)
S#define DSI_WPCR2_TCLKZERO1              ((uint32_t)0x00000200)
S#define DSI_WPCR2_TCLKZERO2              ((uint32_t)0x00000400)
S#define DSI_WPCR2_TCLKZERO3              ((uint32_t)0x00000800)
S#define DSI_WPCR2_TCLKZERO4              ((uint32_t)0x00001000)
S#define DSI_WPCR2_TCLKZERO5              ((uint32_t)0x00002000)
S#define DSI_WPCR2_TCLKZERO6              ((uint32_t)0x00004000)
S#define DSI_WPCR2_TCLKZERO7              ((uint32_t)0x00008000)
S
S#define DSI_WPCR2_THSPREP                ((uint32_t)0x00FF0000)              /*!< t-HSPREP */
S#define DSI_WPCR2_THSPREP0               ((uint32_t)0x00010000)
S#define DSI_WPCR2_THSPREP1               ((uint32_t)0x00020000)
S#define DSI_WPCR2_THSPREP2               ((uint32_t)0x00040000)
S#define DSI_WPCR2_THSPREP3               ((uint32_t)0x00080000)
S#define DSI_WPCR2_THSPREP4               ((uint32_t)0x00100000)
S#define DSI_WPCR2_THSPREP5               ((uint32_t)0x00200000)
S#define DSI_WPCR2_THSPREP6               ((uint32_t)0x00400000)
S#define DSI_WPCR2_THSPREP7               ((uint32_t)0x00800000)
S
S#define DSI_WPCR2_THSTRAIL               ((uint32_t)0xFF000000)              /*!< t-HSTRAIL */
S#define DSI_WPCR2_THSTRAIL0              ((uint32_t)0x01000000)
S#define DSI_WPCR2_THSTRAIL1              ((uint32_t)0x02000000)
S#define DSI_WPCR2_THSTRAIL2              ((uint32_t)0x04000000)
S#define DSI_WPCR2_THSTRAIL3              ((uint32_t)0x08000000)
S#define DSI_WPCR2_THSTRAIL4              ((uint32_t)0x10000000)
S#define DSI_WPCR2_THSTRAIL5              ((uint32_t)0x20000000)
S#define DSI_WPCR2_THSTRAIL6              ((uint32_t)0x40000000)
S#define DSI_WPCR2_THSTRAIL7              ((uint32_t)0x80000000)
S
S/*******************  Bit definition for DSI_WPCR3 register  ***************/
S#define DSI_WPCR3_THSZERO                ((uint32_t)0x000000FF)              /*!< t-HSZERO */
S#define DSI_WPCR3_THSZERO0               ((uint32_t)0x00000001)
S#define DSI_WPCR3_THSZERO1               ((uint32_t)0x00000002)
S#define DSI_WPCR3_THSZERO2               ((uint32_t)0x00000004)
S#define DSI_WPCR3_THSZERO3               ((uint32_t)0x00000008)
S#define DSI_WPCR3_THSZERO4               ((uint32_t)0x00000010)
S#define DSI_WPCR3_THSZERO5               ((uint32_t)0x00000020)
S#define DSI_WPCR3_THSZERO6               ((uint32_t)0x00000040)
S#define DSI_WPCR3_THSZERO7               ((uint32_t)0x00000080)
S
S#define DSI_WPCR3_TLPXD                  ((uint32_t)0x0000FF00)              /*!< t-LPXD */
S#define DSI_WPCR3_TLPXD0                 ((uint32_t)0x00000100)
S#define DSI_WPCR3_TLPXD1                 ((uint32_t)0x00000200)
S#define DSI_WPCR3_TLPXD2                 ((uint32_t)0x00000400)
S#define DSI_WPCR3_TLPXD3                 ((uint32_t)0x00000800)
S#define DSI_WPCR3_TLPXD4                 ((uint32_t)0x00001000)
S#define DSI_WPCR3_TLPXD5                 ((uint32_t)0x00002000)
S#define DSI_WPCR3_TLPXD6                 ((uint32_t)0x00004000)
S#define DSI_WPCR3_TLPXD7                 ((uint32_t)0x00008000)
S
S#define DSI_WPCR3_THSEXIT                ((uint32_t)0x00FF0000)              /*!< t-HSEXIT */
S#define DSI_WPCR3_THSEXIT0               ((uint32_t)0x00010000)
S#define DSI_WPCR3_THSEXIT1               ((uint32_t)0x00020000)
S#define DSI_WPCR3_THSEXIT2               ((uint32_t)0x00040000)
S#define DSI_WPCR3_THSEXIT3               ((uint32_t)0x00080000)
S#define DSI_WPCR3_THSEXIT4               ((uint32_t)0x00100000)
S#define DSI_WPCR3_THSEXIT5               ((uint32_t)0x00200000)
S#define DSI_WPCR3_THSEXIT6               ((uint32_t)0x00400000)
S#define DSI_WPCR3_THSEXIT7               ((uint32_t)0x00800000)
S
S#define DSI_WPCR3_TLPXC                  ((uint32_t)0xFF000000)              /*!< t-LPXC */
S#define DSI_WPCR3_TLPXC0                 ((uint32_t)0x01000000)
S#define DSI_WPCR3_TLPXC1                 ((uint32_t)0x02000000)
S#define DSI_WPCR3_TLPXC2                 ((uint32_t)0x04000000)
S#define DSI_WPCR3_TLPXC3                 ((uint32_t)0x08000000)
S#define DSI_WPCR3_TLPXC4                 ((uint32_t)0x10000000)
S#define DSI_WPCR3_TLPXC5                 ((uint32_t)0x20000000)
S#define DSI_WPCR3_TLPXC6                 ((uint32_t)0x40000000)
S#define DSI_WPCR3_TLPXC7                 ((uint32_t)0x80000000)
S
S/*******************  Bit definition for DSI_WPCR4 register  ***************/
S#define DSI_WPCR4_TCLKPOST               ((uint32_t)0x000000FF)              /*!< t-CLKPOST */
S#define DSI_WPCR4_TCLKPOST0              ((uint32_t)0x00000001)
S#define DSI_WPCR4_TCLKPOST1              ((uint32_t)0x00000002)
S#define DSI_WPCR4_TCLKPOST2              ((uint32_t)0x00000004)
S#define DSI_WPCR4_TCLKPOST3              ((uint32_t)0x00000008)
S#define DSI_WPCR4_TCLKPOST4              ((uint32_t)0x00000010)
S#define DSI_WPCR4_TCLKPOST5              ((uint32_t)0x00000020)
S#define DSI_WPCR4_TCLKPOST6              ((uint32_t)0x00000040)
S#define DSI_WPCR4_TCLKPOST7              ((uint32_t)0x00000080)
S
S/*******************  Bit definition for DSI_WRPCR register  ***************/
S#define DSI_WRPCR_PLLEN                  ((uint32_t)0x00000001)              /*!< PLL Enable */
S#define DSI_WRPCR_PLL_NDIV               ((uint32_t)0x000001FC)              /*!< PLL Loop Division Factor */
S#define DSI_WRPCR_PLL_NDIV0              ((uint32_t)0x00000004)
S#define DSI_WRPCR_PLL_NDIV1              ((uint32_t)0x00000008)
S#define DSI_WRPCR_PLL_NDIV2              ((uint32_t)0x00000010)
S#define DSI_WRPCR_PLL_NDIV3              ((uint32_t)0x00000020)
S#define DSI_WRPCR_PLL_NDIV4              ((uint32_t)0x00000040)
S#define DSI_WRPCR_PLL_NDIV5              ((uint32_t)0x00000080)
S#define DSI_WRPCR_PLL_NDIV6              ((uint32_t)0x00000100)
S
S#define DSI_WRPCR_PLL_IDF                ((uint32_t)0x00007800)              /*!< PLL Input Division Factor */
S#define DSI_WRPCR_PLL_IDF0               ((uint32_t)0x00000800)
S#define DSI_WRPCR_PLL_IDF1               ((uint32_t)0x00001000)
S#define DSI_WRPCR_PLL_IDF2               ((uint32_t)0x00002000)
S#define DSI_WRPCR_PLL_IDF3               ((uint32_t)0x00004000)
S
S#define DSI_WRPCR_PLL_ODF                ((uint32_t)0x00030000)              /*!< PLL Output Division Factor */
S#define DSI_WRPCR_PLL_ODF0               ((uint32_t)0x00010000)
S#define DSI_WRPCR_PLL_ODF1               ((uint32_t)0x00020000)
S
S#define DSI_WRPCR_REGEN                  ((uint32_t)0x01000000)              /*!< Regulator Enable */
N#endif /* STM32F469_479xx */
N
N/******************************************************************************/
N/*                                                                            */
N/*                             Power Control                                  */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for PWR_CR register  ********************/
N#define  PWR_CR_LPDS                         ((uint32_t)0x00000001)     /*!< Low-Power Deepsleep                 */
N#define  PWR_CR_PDDS                         ((uint32_t)0x00000002)     /*!< Power Down Deepsleep                */
N#define  PWR_CR_CWUF                         ((uint32_t)0x00000004)     /*!< Clear Wakeup Flag                   */
N#define  PWR_CR_CSBF                         ((uint32_t)0x00000008)     /*!< Clear Standby Flag                  */
N#define  PWR_CR_PVDE                         ((uint32_t)0x00000010)     /*!< Power Voltage Detector Enable       */
N
N#define  PWR_CR_PLS                          ((uint32_t)0x000000E0)     /*!< PLS[2:0] bits (PVD Level Selection) */
N#define  PWR_CR_PLS_0                        ((uint32_t)0x00000020)     /*!< Bit 0 */
N#define  PWR_CR_PLS_1                        ((uint32_t)0x00000040)     /*!< Bit 1 */
N#define  PWR_CR_PLS_2                        ((uint32_t)0x00000080)     /*!< Bit 2 */
N
N/*!< PVD level configuration */
N#define  PWR_CR_PLS_LEV0                     ((uint32_t)0x00000000)     /*!< PVD level 0 */
N#define  PWR_CR_PLS_LEV1                     ((uint32_t)0x00000020)     /*!< PVD level 1 */
N#define  PWR_CR_PLS_LEV2                     ((uint32_t)0x00000040)     /*!< PVD level 2 */
N#define  PWR_CR_PLS_LEV3                     ((uint32_t)0x00000060)     /*!< PVD level 3 */
N#define  PWR_CR_PLS_LEV4                     ((uint32_t)0x00000080)     /*!< PVD level 4 */
N#define  PWR_CR_PLS_LEV5                     ((uint32_t)0x000000A0)     /*!< PVD level 5 */
N#define  PWR_CR_PLS_LEV6                     ((uint32_t)0x000000C0)     /*!< PVD level 6 */
N#define  PWR_CR_PLS_LEV7                     ((uint32_t)0x000000E0)     /*!< PVD level 7 */
N
N#define  PWR_CR_DBP                          ((uint32_t)0x00000100)     /*!< Disable Backup Domain write protection                     */
N#define  PWR_CR_FPDS                         ((uint32_t)0x00000200)     /*!< Flash power down in Stop mode                              */
N#define  PWR_CR_LPUDS                        ((uint32_t)0x00000400)     /*!< Low-Power Regulator in Stop under-drive mode               */
N#define  PWR_CR_MRUDS                        ((uint32_t)0x00000800)     /*!< Main regulator in Stop under-drive mode                    */
N
N#define  PWR_CR_LPLVDS                       ((uint32_t)0x00000400)     /*!< Low-power regulator Low Voltage in Deep Sleep mode         */
N#define  PWR_CR_MRLVDS                       ((uint32_t)0x00000800)     /*!< Main regulator Low Voltage in Deep Sleep mode              */
N
N#define  PWR_CR_ADCDC1                       ((uint32_t)0x00002000)     /*!< Refer to AN4073 on how to use this bit */ 
N
N#define  PWR_CR_VOS                          ((uint32_t)0x0000C000)     /*!< VOS[1:0] bits (Regulator voltage scaling output selection) */
N#define  PWR_CR_VOS_0                        ((uint32_t)0x00004000)     /*!< Bit 0 */
N#define  PWR_CR_VOS_1                        ((uint32_t)0x00008000)     /*!< Bit 1 */
N
N#define  PWR_CR_ODEN                         ((uint32_t)0x00010000)     /*!< Over Drive enable                   */
N#define  PWR_CR_ODSWEN                       ((uint32_t)0x00020000)     /*!< Over Drive switch enabled           */
N#define  PWR_CR_UDEN                         ((uint32_t)0x000C0000)     /*!< Under Drive enable in stop mode     */
N#define  PWR_CR_UDEN_0                       ((uint32_t)0x00040000)     /*!< Bit 0                               */
N#define  PWR_CR_UDEN_1                       ((uint32_t)0x00080000)     /*!< Bit 1                               */
N
N#define  PWR_CR_FMSSR                        ((uint32_t)0x00100000)     /*!< Flash Memory Sleep System Run        */
N#define  PWR_CR_FISSR                        ((uint32_t)0x00200000)     /*!< Flash Interface Stop while System Run */
N
N/* Legacy define */
N#define  PWR_CR_PMODE                        PWR_CR_VOS
N
N/*******************  Bit definition for PWR_CSR register  ********************/
N#define  PWR_CSR_WUF                         ((uint32_t)0x00000001)     /*!< Wakeup Flag                                      */
N#define  PWR_CSR_SBF                         ((uint32_t)0x00000002)     /*!< Standby Flag                                     */
N#define  PWR_CSR_PVDO                        ((uint32_t)0x00000004)     /*!< PVD Output                                       */
N#define  PWR_CSR_BRR                         ((uint32_t)0x00000008)     /*!< Backup regulator ready                           */
N#define  PWR_CSR_WUPP                        ((uint32_t)0x00000080)     /*!< WKUP pin Polarity                                */
N#define  PWR_CSR_EWUP                        ((uint32_t)0x00000100)     /*!< Enable WKUP pin                                  */
N#define  PWR_CSR_BRE                         ((uint32_t)0x00000200)     /*!< Backup regulator enable                          */
N#define  PWR_CSR_VOSRDY                      ((uint32_t)0x00004000)     /*!< Regulator voltage scaling output selection ready */
N#define  PWR_CSR_ODRDY                       ((uint32_t)0x00010000)     /*!< Over Drive generator ready                       */
N#define  PWR_CSR_ODSWRDY                     ((uint32_t)0x00020000)     /*!< Over Drive Switch ready                          */
N#define  PWR_CSR_UDSWRDY                     ((uint32_t)0x000C0000)     /*!< Under Drive ready                                */
N
N/* Legacy define */
N#define  PWR_CSR_REGRDY                      PWR_CSR_VOSRDY
N
N#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
X#if 0L || 0L || 0L || 0L
S/******************************************************************************/
S/*                                                                            */
S/*                                    QUADSPI                                 */
S/*                                                                            */
S/******************************************************************************/
S/*****************  Bit definition for QUADSPI_CR register  *******************/
S#define  QUADSPI_CR_EN                           ((uint32_t)0x00000001)            /*!< Enable                             */
S#define  QUADSPI_CR_ABORT                        ((uint32_t)0x00000002)            /*!< Abort request                      */
S#define  QUADSPI_CR_DMAEN                        ((uint32_t)0x00000004)            /*!< DMA Enable                         */
S#define  QUADSPI_CR_TCEN                         ((uint32_t)0x00000008)            /*!< Timeout Counter Enable             */
S#define  QUADSPI_CR_SSHIFT                       ((uint32_t)0x00000010)            /*!< SSHIFT Sample Shift                */
S#define  QUADSPI_CR_DFM                          ((uint32_t)0x00000040)            /*!< Dual Flash Mode                    */
S#define  QUADSPI_CR_FSEL                         ((uint32_t)0x00000080)            /*!< Flash Select                       */
S#define  QUADSPI_CR_FTHRES                       ((uint32_t)0x00001F00)            /*!< FTHRES[3:0] FIFO Level             */
S#define  QUADSPI_CR_FTHRES_0                     ((uint32_t)0x00000100)            /*!< Bit 0 */
S#define  QUADSPI_CR_FTHRES_1                     ((uint32_t)0x00000200)            /*!< Bit 1 */
S#define  QUADSPI_CR_FTHRES_2                     ((uint32_t)0x00000400)            /*!< Bit 2 */
S#define  QUADSPI_CR_FTHRES_3                     ((uint32_t)0x00000800)            /*!< Bit 3 */
S#define  QUADSPI_CR_FTHRES_4                     ((uint32_t)0x00001000)            /*!< Bit 4 */
S#define  QUADSPI_CR_TEIE                         ((uint32_t)0x00010000)            /*!< Transfer Error Interrupt Enable    */
S#define  QUADSPI_CR_TCIE                         ((uint32_t)0x00020000)            /*!< Transfer Complete Interrupt Enable */
S#define  QUADSPI_CR_FTIE                         ((uint32_t)0x00040000)            /*!< FIFO Threshold Interrupt Enable    */
S#define  QUADSPI_CR_SMIE                         ((uint32_t)0x00080000)            /*!< Status Match Interrupt Enable      */
S#define  QUADSPI_CR_TOIE                         ((uint32_t)0x00100000)            /*!< TimeOut Interrupt Enable           */
S#define  QUADSPI_CR_APMS                         ((uint32_t)0x00400000)            /*!< Bit 1                              */
S#define  QUADSPI_CR_PMM                          ((uint32_t)0x00800000)            /*!< Polling Match Mode                 */
S#define  QUADSPI_CR_PRESCALER                    ((uint32_t)0xFF000000)            /*!< PRESCALER[7:0] Clock prescaler     */
S#define  QUADSPI_CR_PRESCALER_0                  ((uint32_t)0x01000000)            /*!< Bit 0 */
S#define  QUADSPI_CR_PRESCALER_1                  ((uint32_t)0x02000000)            /*!< Bit 1 */
S#define  QUADSPI_CR_PRESCALER_2                  ((uint32_t)0x04000000)            /*!< Bit 2 */
S#define  QUADSPI_CR_PRESCALER_3                  ((uint32_t)0x08000000)            /*!< Bit 3 */
S#define  QUADSPI_CR_PRESCALER_4                  ((uint32_t)0x10000000)            /*!< Bit 4 */
S#define  QUADSPI_CR_PRESCALER_5                  ((uint32_t)0x20000000)            /*!< Bit 5 */
S#define  QUADSPI_CR_PRESCALER_6                  ((uint32_t)0x40000000)            /*!< Bit 6 */
S#define  QUADSPI_CR_PRESCALER_7                  ((uint32_t)0x80000000)            /*!< Bit 7 */
S
S/*****************  Bit definition for QUADSPI_DCR register  ******************/
S#define  QUADSPI_DCR_CKMODE                      ((uint32_t)0x00000001)            /*!< Mode 0 / Mode 3                 */
S#define  QUADSPI_DCR_CSHT                        ((uint32_t)0x00000700)            /*!< CSHT[2:0]: ChipSelect High Time */
S#define  QUADSPI_DCR_CSHT_0                      ((uint32_t)0x00000100)            /*!< Bit 0 */
S#define  QUADSPI_DCR_CSHT_1                      ((uint32_t)0x00000200)            /*!< Bit 1 */
S#define  QUADSPI_DCR_CSHT_2                      ((uint32_t)0x00000400)            /*!< Bit 2 */
S#define  QUADSPI_DCR_FSIZE                       ((uint32_t)0x001F0000)            /*!< FSIZE[4:0]: Flash Size          */
S#define  QUADSPI_DCR_FSIZE_0                     ((uint32_t)0x00010000)            /*!< Bit 0 */
S#define  QUADSPI_DCR_FSIZE_1                     ((uint32_t)0x00020000)            /*!< Bit 1 */
S#define  QUADSPI_DCR_FSIZE_2                     ((uint32_t)0x00040000)            /*!< Bit 2 */
S#define  QUADSPI_DCR_FSIZE_3                     ((uint32_t)0x00080000)            /*!< Bit 3 */
S#define  QUADSPI_DCR_FSIZE_4                     ((uint32_t)0x00100000)            /*!< Bit 4 */
S
S/******************  Bit definition for QUADSPI_SR register  *******************/
S#define  QUADSPI_SR_TEF                          ((uint32_t)0x00000001)             /*!< Transfer Error Flag     */
S#define  QUADSPI_SR_TCF                          ((uint32_t)0x00000002)             /*!< Transfer Complete Flag  */
S#define  QUADSPI_SR_FTF                          ((uint32_t)0x00000004)             /*!< FIFO Threshlod Flag     */
S#define  QUADSPI_SR_SMF                          ((uint32_t)0x00000008)             /*!< Status Match Flag       */
S#define  QUADSPI_SR_TOF                          ((uint32_t)0x00000010)             /*!< Timeout Flag            */
S#define  QUADSPI_SR_BUSY                         ((uint32_t)0x00000020)             /*!< Busy                    */
S#define  QUADSPI_SR_FLEVEL                       ((uint32_t)0x00003F00)             /*!< FIFO Level              */
S#define  QUADSPI_SR_FLEVEL_0                     ((uint32_t)0x00000100)             /*!< Bit 0 */
S#define  QUADSPI_SR_FLEVEL_1                     ((uint32_t)0x00000200)             /*!< Bit 1 */
S#define  QUADSPI_SR_FLEVEL_2                     ((uint32_t)0x00000400)             /*!< Bit 2 */
S#define  QUADSPI_SR_FLEVEL_3                     ((uint32_t)0x00000800)             /*!< Bit 3 */
S#define  QUADSPI_SR_FLEVEL_4                     ((uint32_t)0x00001000)             /*!< Bit 4 */
S#define  QUADSPI_SR_FLEVEL_5                     ((uint32_t)0x00002000)             /*!< Bit 5 */
S
S/******************  Bit definition for QUADSPI_FCR register  ******************/
S#define  QUADSPI_FCR_CTEF                        ((uint32_t)0x00000001)             /*!< Clear Transfer Error Flag    */
S#define  QUADSPI_FCR_CTCF                        ((uint32_t)0x00000002)             /*!< Clear Transfer Complete Flag */
S#define  QUADSPI_FCR_CSMF                        ((uint32_t)0x00000008)             /*!< Clear Status Match Flag      */
S#define  QUADSPI_FCR_CTOF                        ((uint32_t)0x00000010)             /*!< Clear Timeout Flag           */
S
S/******************  Bit definition for QUADSPI_DLR register  ******************/
S#define  QUADSPI_DLR_DL                        ((uint32_t)0xFFFFFFFF)               /*!< DL[31:0]: Data Length */
S
S/******************  Bit definition for QUADSPI_CCR register  ******************/
S#define  QUADSPI_CCR_INSTRUCTION                  ((uint32_t)0x000000FF)            /*!< INSTRUCTION[7:0]: Instruction */
S#define  QUADSPI_CCR_INSTRUCTION_0                ((uint32_t)0x00000001)            /*!< Bit 0 */
S#define  QUADSPI_CCR_INSTRUCTION_1                ((uint32_t)0x00000002)            /*!< Bit 1 */
S#define  QUADSPI_CCR_INSTRUCTION_2                ((uint32_t)0x00000004)            /*!< Bit 2 */
S#define  QUADSPI_CCR_INSTRUCTION_3                ((uint32_t)0x00000008)            /*!< Bit 3 */
S#define  QUADSPI_CCR_INSTRUCTION_4                ((uint32_t)0x00000010)            /*!< Bit 4 */
S#define  QUADSPI_CCR_INSTRUCTION_5                ((uint32_t)0x00000020)            /*!< Bit 5 */
S#define  QUADSPI_CCR_INSTRUCTION_6                ((uint32_t)0x00000040)            /*!< Bit 6 */
S#define  QUADSPI_CCR_INSTRUCTION_7                ((uint32_t)0x00000080)            /*!< Bit 7 */
S#define  QUADSPI_CCR_IMODE                        ((uint32_t)0x00000300)            /*!< IMODE[1:0]: Instruction Mode */
S#define  QUADSPI_CCR_IMODE_0                      ((uint32_t)0x00000100)            /*!< Bit 0 */
S#define  QUADSPI_CCR_IMODE_1                      ((uint32_t)0x00000200)            /*!< Bit 1 */
S#define  QUADSPI_CCR_ADMODE                       ((uint32_t)0x00000C00)            /*!< ADMODE[1:0]: Address Mode */
S#define  QUADSPI_CCR_ADMODE_0                     ((uint32_t)0x00000400)            /*!< Bit 0 */
S#define  QUADSPI_CCR_ADMODE_1                     ((uint32_t)0x00000800)            /*!< Bit 1 */
S#define  QUADSPI_CCR_ADSIZE                       ((uint32_t)0x00003000)            /*!< ADSIZE[1:0]: Address Size */
S#define  QUADSPI_CCR_ADSIZE_0                     ((uint32_t)0x00001000)            /*!< Bit 0 */
S#define  QUADSPI_CCR_ADSIZE_1                     ((uint32_t)0x00002000)            /*!< Bit 1 */
S#define  QUADSPI_CCR_ABMODE                       ((uint32_t)0x0000C000)            /*!< ABMODE[1:0]: Alternate Bytes Mode */
S#define  QUADSPI_CCR_ABMODE_0                     ((uint32_t)0x00004000)            /*!< Bit 0 */
S#define  QUADSPI_CCR_ABMODE_1                     ((uint32_t)0x00008000)            /*!< Bit 1 */
S#define  QUADSPI_CCR_ABSIZE                       ((uint32_t)0x00030000)            /*!< ABSIZE[1:0]: Instruction Mode */
S#define  QUADSPI_CCR_ABSIZE_0                     ((uint32_t)0x00010000)            /*!< Bit 0 */
S#define  QUADSPI_CCR_ABSIZE_1                     ((uint32_t)0x00020000)            /*!< Bit 1 */
S#define  QUADSPI_CCR_DCYC                         ((uint32_t)0x007C0000)            /*!< DCYC[4:0]: Dummy Cycles */
S#define  QUADSPI_CCR_DCYC_0                       ((uint32_t)0x00040000)            /*!< Bit 0 */
S#define  QUADSPI_CCR_DCYC_1                       ((uint32_t)0x00080000)            /*!< Bit 1 */
S#define  QUADSPI_CCR_DCYC_2                       ((uint32_t)0x00100000)            /*!< Bit 2 */
S#define  QUADSPI_CCR_DCYC_3                       ((uint32_t)0x00200000)            /*!< Bit 3 */
S#define  QUADSPI_CCR_DCYC_4                       ((uint32_t)0x00400000)            /*!< Bit 4 */
S#define  QUADSPI_CCR_DMODE                        ((uint32_t)0x03000000)            /*!< DMODE[1:0]: Data Mode */
S#define  QUADSPI_CCR_DMODE_0                      ((uint32_t)0x01000000)            /*!< Bit 0 */
S#define  QUADSPI_CCR_DMODE_1                      ((uint32_t)0x02000000)            /*!< Bit 1 */
S#define  QUADSPI_CCR_FMODE                        ((uint32_t)0x0C000000)            /*!< FMODE[1:0]: Functional Mode */
S#define  QUADSPI_CCR_FMODE_0                      ((uint32_t)0x04000000)            /*!< Bit 0 */
S#define  QUADSPI_CCR_FMODE_1                      ((uint32_t)0x08000000)            /*!< Bit 1 */
S#define  QUADSPI_CCR_SIOO                         ((uint32_t)0x10000000)            /*!< SIOO: Send Instruction Only Once Mode */
S#define  QUADSPI_CCR_DHHC                         ((uint32_t)0x40000000)            /*!< DHHC: Delay Half Hclk Cycle */
S#define  QUADSPI_CCR_DDRM                         ((uint32_t)0x80000000)            /*!< DDRM: Double Data Rate Mode */ 
S/******************  Bit definition for QUADSPI_AR register  *******************/
S#define  QUADSPI_AR_ADDRESS                       ((uint32_t)0xFFFFFFFF)            /*!< ADDRESS[31:0]: Address */
S
S/******************  Bit definition for QUADSPI_ABR register  ******************/
S#define  QUADSPI_ABR_ALTERNATE                    ((uint32_t)0xFFFFFFFF)            /*!< ALTERNATE[31:0]: Alternate Bytes */
S
S/******************  Bit definition for QUADSPI_DR register  *******************/
S#define  QUADSPI_DR_DATA                          ((uint32_t)0xFFFFFFFF)            /*!< DATA[31:0]: Data */
S
S/******************  Bit definition for QUADSPI_PSMKR register  ****************/
S#define  QUADSPI_PSMKR_MASK                       ((uint32_t)0xFFFFFFFF)            /*!< MASK[31:0]: Status Mask */
S
S/******************  Bit definition for QUADSPI_PSMAR register  ****************/
S#define  QUADSPI_PSMAR_MATCH                      ((uint32_t)0xFFFFFFFF)            /*!< MATCH[31:0]: Status Match */
S
S/******************  Bit definition for QUADSPI_PIR register  *****************/
S#define  QUADSPI_PIR_INTERVAL                     ((uint32_t)0x0000FFFF)            /*!< INTERVAL[15:0]: Polling Interval */
S
S/******************  Bit definition for QUADSPI_LPTR register  *****************/
S#define  QUADSPI_LPTR_TIMEOUT                     ((uint32_t)0x0000FFFF)            /*!< TIMEOUT[15:0]: Timeout period */
N#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx || STM32F469_479xx */
N
N/******************************************************************************/
N/*                                                                            */
N/*                         Reset and Clock Control                            */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for RCC_CR register  ********************/
N#define  RCC_CR_HSION                        ((uint32_t)0x00000001)
N#define  RCC_CR_HSIRDY                       ((uint32_t)0x00000002)
N
N#define  RCC_CR_HSITRIM                      ((uint32_t)0x000000F8)
N#define  RCC_CR_HSITRIM_0                    ((uint32_t)0x00000008)/*!<Bit 0 */
N#define  RCC_CR_HSITRIM_1                    ((uint32_t)0x00000010)/*!<Bit 1 */
N#define  RCC_CR_HSITRIM_2                    ((uint32_t)0x00000020)/*!<Bit 2 */
N#define  RCC_CR_HSITRIM_3                    ((uint32_t)0x00000040)/*!<Bit 3 */
N#define  RCC_CR_HSITRIM_4                    ((uint32_t)0x00000080)/*!<Bit 4 */
N
N#define  RCC_CR_HSICAL                       ((uint32_t)0x0000FF00)
N#define  RCC_CR_HSICAL_0                     ((uint32_t)0x00000100)/*!<Bit 0 */
N#define  RCC_CR_HSICAL_1                     ((uint32_t)0x00000200)/*!<Bit 1 */
N#define  RCC_CR_HSICAL_2                     ((uint32_t)0x00000400)/*!<Bit 2 */
N#define  RCC_CR_HSICAL_3                     ((uint32_t)0x00000800)/*!<Bit 3 */
N#define  RCC_CR_HSICAL_4                     ((uint32_t)0x00001000)/*!<Bit 4 */
N#define  RCC_CR_HSICAL_5                     ((uint32_t)0x00002000)/*!<Bit 5 */
N#define  RCC_CR_HSICAL_6                     ((uint32_t)0x00004000)/*!<Bit 6 */
N#define  RCC_CR_HSICAL_7                     ((uint32_t)0x00008000)/*!<Bit 7 */
N
N#define  RCC_CR_HSEON                        ((uint32_t)0x00010000)
N#define  RCC_CR_HSERDY                       ((uint32_t)0x00020000)
N#define  RCC_CR_HSEBYP                       ((uint32_t)0x00040000)
N#define  RCC_CR_CSSON                        ((uint32_t)0x00080000)
N#define  RCC_CR_PLLON                        ((uint32_t)0x01000000)
N#define  RCC_CR_PLLRDY                       ((uint32_t)0x02000000)
N#define  RCC_CR_PLLI2SON                     ((uint32_t)0x04000000)
N#define  RCC_CR_PLLI2SRDY                    ((uint32_t)0x08000000)
N#define  RCC_CR_PLLSAION                     ((uint32_t)0x10000000)
N#define  RCC_CR_PLLSAIRDY                    ((uint32_t)0x20000000)
N
N/********************  Bit definition for RCC_PLLCFGR register  ***************/
N#define  RCC_PLLCFGR_PLLM                    ((uint32_t)0x0000003F)
N#define  RCC_PLLCFGR_PLLM_0                  ((uint32_t)0x00000001)
N#define  RCC_PLLCFGR_PLLM_1                  ((uint32_t)0x00000002)
N#define  RCC_PLLCFGR_PLLM_2                  ((uint32_t)0x00000004)
N#define  RCC_PLLCFGR_PLLM_3                  ((uint32_t)0x00000008)
N#define  RCC_PLLCFGR_PLLM_4                  ((uint32_t)0x00000010)
N#define  RCC_PLLCFGR_PLLM_5                  ((uint32_t)0x00000020)
N
N#define  RCC_PLLCFGR_PLLN                     ((uint32_t)0x00007FC0)
N#define  RCC_PLLCFGR_PLLN_0                   ((uint32_t)0x00000040)
N#define  RCC_PLLCFGR_PLLN_1                   ((uint32_t)0x00000080)
N#define  RCC_PLLCFGR_PLLN_2                   ((uint32_t)0x00000100)
N#define  RCC_PLLCFGR_PLLN_3                   ((uint32_t)0x00000200)
N#define  RCC_PLLCFGR_PLLN_4                   ((uint32_t)0x00000400)
N#define  RCC_PLLCFGR_PLLN_5                   ((uint32_t)0x00000800)
N#define  RCC_PLLCFGR_PLLN_6                   ((uint32_t)0x00001000)
N#define  RCC_PLLCFGR_PLLN_7                   ((uint32_t)0x00002000)
N#define  RCC_PLLCFGR_PLLN_8                   ((uint32_t)0x00004000)
N
N#define  RCC_PLLCFGR_PLLP                    ((uint32_t)0x00030000)
N#define  RCC_PLLCFGR_PLLP_0                  ((uint32_t)0x00010000)
N#define  RCC_PLLCFGR_PLLP_1                  ((uint32_t)0x00020000)
N
N#define  RCC_PLLCFGR_PLLSRC                  ((uint32_t)0x00400000)
N#define  RCC_PLLCFGR_PLLSRC_HSE              ((uint32_t)0x00400000)
N#define  RCC_PLLCFGR_PLLSRC_HSI              ((uint32_t)0x00000000)
N
N#define  RCC_PLLCFGR_PLLQ                    ((uint32_t)0x0F000000)
N#define  RCC_PLLCFGR_PLLQ_0                  ((uint32_t)0x01000000)
N#define  RCC_PLLCFGR_PLLQ_1                  ((uint32_t)0x02000000)
N#define  RCC_PLLCFGR_PLLQ_2                  ((uint32_t)0x04000000)
N#define  RCC_PLLCFGR_PLLQ_3                  ((uint32_t)0x08000000)
N
N#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
X#if 0L || 0L || 0L || 0L
S#define  RCC_PLLCFGR_PLLR                    ((uint32_t)0x70000000)
S#define  RCC_PLLCFGR_PLLR_0                  ((uint32_t)0x10000000)
S#define  RCC_PLLCFGR_PLLR_1                  ((uint32_t)0x20000000)
S#define  RCC_PLLCFGR_PLLR_2                  ((uint32_t)0x40000000)
N#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx || STM32F469_479xx */
N
N/********************  Bit definition for RCC_CFGR register  ******************/
N/*!< SW configuration */
N#define  RCC_CFGR_SW                         ((uint32_t)0x00000003)        /*!< SW[1:0] bits (System clock Switch) */
N#define  RCC_CFGR_SW_0                       ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  RCC_CFGR_SW_1                       ((uint32_t)0x00000002)        /*!< Bit 1 */
N
N#define  RCC_CFGR_SW_HSI                     ((uint32_t)0x00000000)        /*!< HSI selected as system clock */
N#define  RCC_CFGR_SW_HSE                     ((uint32_t)0x00000001)        /*!< HSE selected as system clock */
N#define  RCC_CFGR_SW_PLL                     ((uint32_t)0x00000002)        /*!< PLL/PLLP selected as system clock */
N#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
X#if 0L || 0L || 0L || 0L
S#define  RCC_CFGR_SW_PLLR                    ((uint32_t)0x00000003)        /*!< PLL/PLLR selected as system clock */
N#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx || STM32F469_479xx */
N
N/*!< SWS configuration */
N#define  RCC_CFGR_SWS                        ((uint32_t)0x0000000C)        /*!< SWS[1:0] bits (System Clock Switch Status) */
N#define  RCC_CFGR_SWS_0                      ((uint32_t)0x00000004)        /*!< Bit 0 */
N#define  RCC_CFGR_SWS_1                      ((uint32_t)0x00000008)        /*!< Bit 1 */
N
N#define  RCC_CFGR_SWS_HSI                    ((uint32_t)0x00000000)        /*!< HSI oscillator used as system clock */
N#define  RCC_CFGR_SWS_HSE                    ((uint32_t)0x00000004)        /*!< HSE oscillator used as system clock */
N#define  RCC_CFGR_SWS_PLL                    ((uint32_t)0x00000008)        /*!< PLL/PLLP used as system clock       */
N#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F469_479xx) || defined(STM32F446xx)
X#if 0L || 0L || 0L || 0L
S#define  RCC_CFGR_SWS_PLLR                   ((uint32_t)0x0000000C)        /*!< PLL/PLLR used as system clock       */
N#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx || STM32F469_479xx */
N
N/*!< HPRE configuration */
N#define  RCC_CFGR_HPRE                       ((uint32_t)0x000000F0)        /*!< HPRE[3:0] bits (AHB prescaler) */
N#define  RCC_CFGR_HPRE_0                     ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  RCC_CFGR_HPRE_1                     ((uint32_t)0x00000020)        /*!< Bit 1 */
N#define  RCC_CFGR_HPRE_2                     ((uint32_t)0x00000040)        /*!< Bit 2 */
N#define  RCC_CFGR_HPRE_3                     ((uint32_t)0x00000080)        /*!< Bit 3 */
N
N#define  RCC_CFGR_HPRE_DIV1                  ((uint32_t)0x00000000)        /*!< SYSCLK not divided */
N#define  RCC_CFGR_HPRE_DIV2                  ((uint32_t)0x00000080)        /*!< SYSCLK divided by 2 */
N#define  RCC_CFGR_HPRE_DIV4                  ((uint32_t)0x00000090)        /*!< SYSCLK divided by 4 */
N#define  RCC_CFGR_HPRE_DIV8                  ((uint32_t)0x000000A0)        /*!< SYSCLK divided by 8 */
N#define  RCC_CFGR_HPRE_DIV16                 ((uint32_t)0x000000B0)        /*!< SYSCLK divided by 16 */
N#define  RCC_CFGR_HPRE_DIV64                 ((uint32_t)0x000000C0)        /*!< SYSCLK divided by 64 */
N#define  RCC_CFGR_HPRE_DIV128                ((uint32_t)0x000000D0)        /*!< SYSCLK divided by 128 */
N#define  RCC_CFGR_HPRE_DIV256                ((uint32_t)0x000000E0)        /*!< SYSCLK divided by 256 */
N#define  RCC_CFGR_HPRE_DIV512                ((uint32_t)0x000000F0)        /*!< SYSCLK divided by 512 */
N
N#if defined(STM32F410xx)
X#if 0L
S/*!< MCO1EN configuration */
S#define  RCC_CFGR_MCO1EN                     ((uint32_t)0x00000100)        /*!< MCO1EN bit */
S/*!< MCO1EN configuration */
S#define  RCC_CFGR_MCO2EN                     ((uint32_t)0x00000200)        /*!< MCO2EN bit */
N#endif /* STM32F410xx */
N/*!< PPRE1 configuration */
N#define  RCC_CFGR_PPRE1                      ((uint32_t)0x00001C00)        /*!< PRE1[2:0] bits (APB1 prescaler) */
N#define  RCC_CFGR_PPRE1_0                    ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  RCC_CFGR_PPRE1_1                    ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  RCC_CFGR_PPRE1_2                    ((uint32_t)0x00001000)        /*!< Bit 2 */
N
N#define  RCC_CFGR_PPRE1_DIV1                 ((uint32_t)0x00000000)        /*!< HCLK not divided */
N#define  RCC_CFGR_PPRE1_DIV2                 ((uint32_t)0x00001000)        /*!< HCLK divided by 2 */
N#define  RCC_CFGR_PPRE1_DIV4                 ((uint32_t)0x00001400)        /*!< HCLK divided by 4 */
N#define  RCC_CFGR_PPRE1_DIV8                 ((uint32_t)0x00001800)        /*!< HCLK divided by 8 */
N#define  RCC_CFGR_PPRE1_DIV16                ((uint32_t)0x00001C00)        /*!< HCLK divided by 16 */
N
N/*!< PPRE2 configuration */
N#define  RCC_CFGR_PPRE2                      ((uint32_t)0x0000E000)        /*!< PRE2[2:0] bits (APB2 prescaler) */
N#define  RCC_CFGR_PPRE2_0                    ((uint32_t)0x00002000)        /*!< Bit 0 */
N#define  RCC_CFGR_PPRE2_1                    ((uint32_t)0x00004000)        /*!< Bit 1 */
N#define  RCC_CFGR_PPRE2_2                    ((uint32_t)0x00008000)        /*!< Bit 2 */
N
N#define  RCC_CFGR_PPRE2_DIV1                 ((uint32_t)0x00000000)        /*!< HCLK not divided */
N#define  RCC_CFGR_PPRE2_DIV2                 ((uint32_t)0x00008000)        /*!< HCLK divided by 2 */
N#define  RCC_CFGR_PPRE2_DIV4                 ((uint32_t)0x0000A000)        /*!< HCLK divided by 4 */
N#define  RCC_CFGR_PPRE2_DIV8                 ((uint32_t)0x0000C000)        /*!< HCLK divided by 8 */
N#define  RCC_CFGR_PPRE2_DIV16                ((uint32_t)0x0000E000)        /*!< HCLK divided by 16 */
N
N/*!< RTCPRE configuration */
N#define  RCC_CFGR_RTCPRE                     ((uint32_t)0x001F0000)
N#define  RCC_CFGR_RTCPRE_0                   ((uint32_t)0x00010000)
N#define  RCC_CFGR_RTCPRE_1                   ((uint32_t)0x00020000)
N#define  RCC_CFGR_RTCPRE_2                   ((uint32_t)0x00040000)
N#define  RCC_CFGR_RTCPRE_3                   ((uint32_t)0x00080000)
N#define  RCC_CFGR_RTCPRE_4                   ((uint32_t)0x00100000)
N
N/*!< MCO1 configuration */
N#define  RCC_CFGR_MCO1                       ((uint32_t)0x00600000)
N#define  RCC_CFGR_MCO1_0                     ((uint32_t)0x00200000)
N#define  RCC_CFGR_MCO1_1                     ((uint32_t)0x00400000)
N
N#define  RCC_CFGR_I2SSRC                     ((uint32_t)0x00800000)
N
N#define  RCC_CFGR_MCO1PRE                    ((uint32_t)0x07000000)
N#define  RCC_CFGR_MCO1PRE_0                  ((uint32_t)0x01000000)
N#define  RCC_CFGR_MCO1PRE_1                  ((uint32_t)0x02000000)
N#define  RCC_CFGR_MCO1PRE_2                  ((uint32_t)0x04000000)
N
N#define  RCC_CFGR_MCO2PRE                    ((uint32_t)0x38000000)
N#define  RCC_CFGR_MCO2PRE_0                  ((uint32_t)0x08000000)
N#define  RCC_CFGR_MCO2PRE_1                  ((uint32_t)0x10000000)
N#define  RCC_CFGR_MCO2PRE_2                  ((uint32_t)0x20000000)
N
N#define  RCC_CFGR_MCO2                       ((uint32_t)0xC0000000)
N#define  RCC_CFGR_MCO2_0                     ((uint32_t)0x40000000)
N#define  RCC_CFGR_MCO2_1                     ((uint32_t)0x80000000)
N
N/********************  Bit definition for RCC_CIR register  *******************/
N#define  RCC_CIR_LSIRDYF                     ((uint32_t)0x00000001)
N#define  RCC_CIR_LSERDYF                     ((uint32_t)0x00000002)
N#define  RCC_CIR_HSIRDYF                     ((uint32_t)0x00000004)
N#define  RCC_CIR_HSERDYF                     ((uint32_t)0x00000008)
N#define  RCC_CIR_PLLRDYF                     ((uint32_t)0x00000010)
N#define  RCC_CIR_PLLI2SRDYF                  ((uint32_t)0x00000020)
N#define  RCC_CIR_PLLSAIRDYF                  ((uint32_t)0x00000040)
N#define  RCC_CIR_CSSF                        ((uint32_t)0x00000080)
N#define  RCC_CIR_LSIRDYIE                    ((uint32_t)0x00000100)
N#define  RCC_CIR_LSERDYIE                    ((uint32_t)0x00000200)
N#define  RCC_CIR_HSIRDYIE                    ((uint32_t)0x00000400)
N#define  RCC_CIR_HSERDYIE                    ((uint32_t)0x00000800)
N#define  RCC_CIR_PLLRDYIE                    ((uint32_t)0x00001000)
N#define  RCC_CIR_PLLI2SRDYIE                 ((uint32_t)0x00002000)
N#define  RCC_CIR_PLLSAIRDYIE                 ((uint32_t)0x00004000)
N#define  RCC_CIR_LSIRDYC                     ((uint32_t)0x00010000)
N#define  RCC_CIR_LSERDYC                     ((uint32_t)0x00020000)
N#define  RCC_CIR_HSIRDYC                     ((uint32_t)0x00040000)
N#define  RCC_CIR_HSERDYC                     ((uint32_t)0x00080000)
N#define  RCC_CIR_PLLRDYC                     ((uint32_t)0x00100000)
N#define  RCC_CIR_PLLI2SRDYC                  ((uint32_t)0x00200000)
N#define  RCC_CIR_PLLSAIRDYC                  ((uint32_t)0x00400000)
N#define  RCC_CIR_CSSC                        ((uint32_t)0x00800000)
N
N/********************  Bit definition for RCC_AHB1RSTR register  **************/
N#define  RCC_AHB1RSTR_GPIOARST               ((uint32_t)0x00000001)
N#define  RCC_AHB1RSTR_GPIOBRST               ((uint32_t)0x00000002)
N#define  RCC_AHB1RSTR_GPIOCRST               ((uint32_t)0x00000004)
N#define  RCC_AHB1RSTR_GPIODRST               ((uint32_t)0x00000008)
N#define  RCC_AHB1RSTR_GPIOERST               ((uint32_t)0x00000010)
N#define  RCC_AHB1RSTR_GPIOFRST               ((uint32_t)0x00000020)
N#define  RCC_AHB1RSTR_GPIOGRST               ((uint32_t)0x00000040)
N#define  RCC_AHB1RSTR_GPIOHRST               ((uint32_t)0x00000080)
N#define  RCC_AHB1RSTR_GPIOIRST               ((uint32_t)0x00000100)
N#define  RCC_AHB1RSTR_GPIOJRST               ((uint32_t)0x00000200)
N#define  RCC_AHB1RSTR_GPIOKRST               ((uint32_t)0x00000400)
N#define  RCC_AHB1RSTR_CRCRST                 ((uint32_t)0x00001000)
N#define  RCC_AHB1RSTR_DMA1RST                ((uint32_t)0x00200000)
N#define  RCC_AHB1RSTR_DMA2RST                ((uint32_t)0x00400000)
N#define  RCC_AHB1RSTR_DMA2DRST               ((uint32_t)0x00800000)
N#define  RCC_AHB1RSTR_ETHMACRST              ((uint32_t)0x02000000)
N#define  RCC_AHB1RSTR_OTGHRST                ((uint32_t)0x10000000)
N
N/********************  Bit definition for RCC_AHB2RSTR register  **************/
N#define  RCC_AHB2RSTR_DCMIRST                ((uint32_t)0x00000001)
N#define  RCC_AHB2RSTR_CRYPRST                ((uint32_t)0x00000010)
N#define  RCC_AHB2RSTR_HASHRST                ((uint32_t)0x00000020)
N /* maintained for legacy purpose */
N#define  RCC_AHB2RSTR_HSAHRST                RCC_AHB2RSTR_HASHRST
N#define  RCC_AHB2RSTR_RNGRST                 ((uint32_t)0x00000040)
N#define  RCC_AHB2RSTR_OTGFSRST               ((uint32_t)0x00000080)
N
N/********************  Bit definition for RCC_AHB3RSTR register  **************/
N#if defined(STM32F40_41xxx) || defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 1L || 0L || 0L
N#define  RCC_AHB3RSTR_FSMCRST                ((uint32_t)0x00000001)
N#endif /* STM32F40_41xxx || STM32F412xG || STM32F413_423xx */
N
N#if defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
X#if 0L || 0L || 0L || 0L
S#define  RCC_AHB3RSTR_FMCRST                ((uint32_t)0x00000001)
N#endif /* STM32F427_437xx ||  STM32F429_439xx || STM32F446xx || STM32F469_479xx */
N#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
X#if 0L || 0L || 0L || 0L
S#define  RCC_AHB3RSTR_QSPIRST               ((uint32_t)0x00000002)
N#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx || STM32F469_479xx */
N
N/********************  Bit definition for RCC_APB1RSTR register  **************/
N#define  RCC_APB1RSTR_TIM2RST                ((uint32_t)0x00000001)
N#define  RCC_APB1RSTR_TIM3RST                ((uint32_t)0x00000002)
N#define  RCC_APB1RSTR_TIM4RST                ((uint32_t)0x00000004)
N#define  RCC_APB1RSTR_TIM5RST                ((uint32_t)0x00000008)
N#define  RCC_APB1RSTR_TIM6RST                ((uint32_t)0x00000010)
N#define  RCC_APB1RSTR_TIM7RST                ((uint32_t)0x00000020)
N#define  RCC_APB1RSTR_TIM12RST               ((uint32_t)0x00000040)
N#define  RCC_APB1RSTR_TIM13RST               ((uint32_t)0x00000080)
N#define  RCC_APB1RSTR_TIM14RST               ((uint32_t)0x00000100)
N#if defined(STM32F410xx) || defined(STM32F413_423xx)
X#if 0L || 0L
S#define  RCC_APB1RSTR_LPTIM1RST              ((uint32_t)0x00000200)
N#endif /* STM32F410xx || STM32F413_423xx */
N#define  RCC_APB1RSTR_WWDGRST                ((uint32_t)0x00000800)
N#define  RCC_APB1RSTR_SPI2RST                ((uint32_t)0x00004000)
N#define  RCC_APB1RSTR_SPI3RST                ((uint32_t)0x00008000)
N#if defined(STM32F446xx)
X#if 0L
S#define  RCC_APB1RSTR_SPDIFRXRST             ((uint32_t)0x00010000)
N#endif /* STM32F446xx */
N#define  RCC_APB1RSTR_USART2RST              ((uint32_t)0x00020000)
N#define  RCC_APB1RSTR_USART3RST              ((uint32_t)0x00040000)
N#define  RCC_APB1RSTR_UART4RST               ((uint32_t)0x00080000)
N#define  RCC_APB1RSTR_UART5RST               ((uint32_t)0x00100000)
N#define  RCC_APB1RSTR_I2C1RST                ((uint32_t)0x00200000)
N#define  RCC_APB1RSTR_I2C2RST                ((uint32_t)0x00400000)
N#define  RCC_APB1RSTR_I2C3RST                ((uint32_t)0x00800000)
N#if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
X#if 0L || 0L || 0L || 0L
S#define  RCC_APB1RSTR_FMPI2C1RST             ((uint32_t)0x01000000)
N#endif /* STM32F410xx || STM32F412xG || STM32F413_423xx || STM32F446xx */
N#define  RCC_APB1RSTR_CAN1RST                ((uint32_t)0x02000000)
N#define  RCC_APB1RSTR_CAN2RST                ((uint32_t)0x04000000)
N#if defined(STM32F446xx)
X#if 0L
S#define  RCC_APB1RSTR_CECRST                 ((uint32_t)0x08000000)
N#endif /* STM32F446xx */
N#define  RCC_APB1RSTR_PWRRST                 ((uint32_t)0x10000000)
N#define  RCC_APB1RSTR_DACRST                 ((uint32_t)0x20000000)
N#define  RCC_APB1RSTR_UART7RST               ((uint32_t)0x40000000)
N#define  RCC_APB1RSTR_UART8RST               ((uint32_t)0x80000000)
N
N/********************  Bit definition for RCC_APB2RSTR register  **************/
N#define  RCC_APB2RSTR_TIM1RST                ((uint32_t)0x00000001)
N#define  RCC_APB2RSTR_TIM8RST                ((uint32_t)0x00000002)
N#define  RCC_APB2RSTR_USART1RST              ((uint32_t)0x00000010)
N#define  RCC_APB2RSTR_USART6RST              ((uint32_t)0x00000020)
N#define  RCC_APB2RSTR_UART9RST               ((uint32_t)0x00000040)
N#define  RCC_APB2RSTR_UART10RST              ((uint32_t)0x00000080)
N#define  RCC_APB2RSTR_ADCRST                 ((uint32_t)0x00000100)
N#define  RCC_APB2RSTR_SDIORST                ((uint32_t)0x00000800)
N#define  RCC_APB2RSTR_SPI1RST                ((uint32_t)0x00001000)
N#define  RCC_APB2RSTR_SPI4RST                ((uint32_t)0x00002000)
N#define  RCC_APB2RSTR_SYSCFGRST              ((uint32_t)0x00004000)
N#define  RCC_APB2RSTR_TIM9RST                ((uint32_t)0x00010000)
N#define  RCC_APB2RSTR_TIM10RST               ((uint32_t)0x00020000)
N#define  RCC_APB2RSTR_TIM11RST               ((uint32_t)0x00040000)
N#define  RCC_APB2RSTR_SPI5RST                ((uint32_t)0x00100000)
N#define  RCC_APB2RSTR_SPI6RST                ((uint32_t)0x00200000)
N#define  RCC_APB2RSTR_SAI1RST                ((uint32_t)0x00400000)
N#if defined(STM32F446xx)
X#if 0L
S#define  RCC_APB2RSTR_SAI2RST                ((uint32_t)0x00800000)
N#endif /* STM32F446xx */
N#define  RCC_APB2RSTR_LTDCRST                ((uint32_t)0x04000000)
N#if defined(STM32F469_479xx)
X#if 0L
S#define  RCC_APB2RSTR_DSIRST                 ((uint32_t)0x08000000)
N#endif /* STM32F469_479xx */
N#if defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 0L || 0L
S#define  RCC_APB2RSTR_DFSDM1RST              ((uint32_t)0x01000000)
N#endif /* STM32F412xG || STM32F413_423xx */
N
N#if defined(STM32F413_423xx)
X#if 0L
S#define  RCC_APB2RSTR_DFSDM2RST              ((uint32_t)0x02000000)
N#endif /* STM32F413_423xx */
N/* Old definitions, maintained for legacy purpose */
N#define  RCC_APB2RSTR_SPI1                   RCC_APB2RSTR_SPI1RST
N#define  RCC_APB2RSTR_DFSDMRST               RCC_APB2RSTR_DFSDM1RST
N
N/********************  Bit definition for RCC_AHB1ENR register  ***************/
N#define  RCC_AHB1ENR_GPIOAEN                 ((uint32_t)0x00000001)
N#define  RCC_AHB1ENR_GPIOBEN                 ((uint32_t)0x00000002)
N#define  RCC_AHB1ENR_GPIOCEN                 ((uint32_t)0x00000004)
N#define  RCC_AHB1ENR_GPIODEN                 ((uint32_t)0x00000008)
N#define  RCC_AHB1ENR_GPIOEEN                 ((uint32_t)0x00000010)
N#define  RCC_AHB1ENR_GPIOFEN                 ((uint32_t)0x00000020)
N#define  RCC_AHB1ENR_GPIOGEN                 ((uint32_t)0x00000040)
N#define  RCC_AHB1ENR_GPIOHEN                 ((uint32_t)0x00000080)
N#define  RCC_AHB1ENR_GPIOIEN                 ((uint32_t)0x00000100)
N#define  RCC_AHB1ENR_GPIOJEN                 ((uint32_t)0x00000200)
N#define  RCC_AHB1ENR_GPIOKEN                 ((uint32_t)0x00000400)
N#define  RCC_AHB1ENR_CRCEN                   ((uint32_t)0x00001000)
N#define  RCC_AHB1ENR_BKPSRAMEN               ((uint32_t)0x00040000)
N#define  RCC_AHB1ENR_CCMDATARAMEN            ((uint32_t)0x00100000)
N#define  RCC_AHB1ENR_DMA1EN                  ((uint32_t)0x00200000)
N#define  RCC_AHB1ENR_DMA2EN                  ((uint32_t)0x00400000)
N#define  RCC_AHB1ENR_DMA2DEN                 ((uint32_t)0x00800000)
N#define  RCC_AHB1ENR_ETHMACEN                ((uint32_t)0x02000000)
N#define  RCC_AHB1ENR_ETHMACTXEN              ((uint32_t)0x04000000)
N#define  RCC_AHB1ENR_ETHMACRXEN              ((uint32_t)0x08000000)
N#define  RCC_AHB1ENR_ETHMACPTPEN             ((uint32_t)0x10000000)
N#define  RCC_AHB1ENR_OTGHSEN                 ((uint32_t)0x20000000)
N#define  RCC_AHB1ENR_OTGHSULPIEN             ((uint32_t)0x40000000)
N
N/********************  Bit definition for RCC_AHB2ENR register  ***************/
N#define  RCC_AHB2ENR_DCMIEN                  ((uint32_t)0x00000001)
N#define  RCC_AHB2ENR_CRYPEN                  ((uint32_t)0x00000010)
N#define  RCC_AHB2ENR_HASHEN                  ((uint32_t)0x00000020)
N#define  RCC_AHB2ENR_RNGEN                   ((uint32_t)0x00000040)
N#define  RCC_AHB2ENR_OTGFSEN                 ((uint32_t)0x00000080)
N
N/********************  Bit definition for RCC_AHB3ENR register  ***************/
N
N#if defined(STM32F40_41xxx) || defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 1L || 0L || 0L
N#define  RCC_AHB3ENR_FSMCEN                  ((uint32_t)0x00000001)
N#endif /* STM32F40_41xxx || STM32F412xG || STM32F413_423xx */
N
N#if defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
X#if 0L || 0L || 0L || 0L
S#define  RCC_AHB3ENR_FMCEN                  ((uint32_t)0x00000001)
N#endif /* STM32F427_437xx ||  STM32F429_439xx || STM32F446xx || STM32F469_479xx */
N
N#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
X#if 0L || 0L || 0L || 0L
S#define  RCC_AHB3ENR_QSPIEN                 ((uint32_t)0x00000002)
N#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx || STM32F469_479xx */
N
N/********************  Bit definition for RCC_APB1ENR register  ***************/
N#define  RCC_APB1ENR_TIM2EN                  ((uint32_t)0x00000001)
N#define  RCC_APB1ENR_TIM3EN                  ((uint32_t)0x00000002)
N#define  RCC_APB1ENR_TIM4EN                  ((uint32_t)0x00000004)
N#define  RCC_APB1ENR_TIM5EN                  ((uint32_t)0x00000008)
N#define  RCC_APB1ENR_TIM6EN                  ((uint32_t)0x00000010)
N#define  RCC_APB1ENR_TIM7EN                  ((uint32_t)0x00000020)
N#define  RCC_APB1ENR_TIM12EN                 ((uint32_t)0x00000040)
N#define  RCC_APB1ENR_TIM13EN                 ((uint32_t)0x00000080)
N#define  RCC_APB1ENR_TIM14EN                 ((uint32_t)0x00000100)
N#if defined(STM32F410xx) || defined(STM32F413_423xx)
X#if 0L || 0L
S#define  RCC_APB1ENR_LPTIM1EN                ((uint32_t)0x00000200)
N#endif /* STM32F410xx || STM32F413_423xx */
N#define  RCC_APB1ENR_WWDGEN                  ((uint32_t)0x00000800)
N#define  RCC_APB1ENR_SPI2EN                  ((uint32_t)0x00004000)
N#define  RCC_APB1ENR_SPI3EN                  ((uint32_t)0x00008000)
N#if defined(STM32F446xx)
X#if 0L
S#define  RCC_APB1ENR_SPDIFRXEN               ((uint32_t)0x00010000)
N#endif /* STM32F446xx */
N#define  RCC_APB1ENR_USART2EN                ((uint32_t)0x00020000)
N#define  RCC_APB1ENR_USART3EN                ((uint32_t)0x00040000)
N#define  RCC_APB1ENR_UART4EN                 ((uint32_t)0x00080000)
N#define  RCC_APB1ENR_UART5EN                 ((uint32_t)0x00100000)
N#define  RCC_APB1ENR_I2C1EN                  ((uint32_t)0x00200000)
N#define  RCC_APB1ENR_I2C2EN                  ((uint32_t)0x00400000)
N#define  RCC_APB1ENR_I2C3EN                  ((uint32_t)0x00800000)
N#if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
X#if 0L || 0L || 0L || 0L
S#define  RCC_APB1ENR_FMPI2C1EN               ((uint32_t)0x01000000)
N#endif /* STM32F410xx || STM32F412xG || STM32F413_423xx || STM32F446xx */
N#define  RCC_APB1ENR_CAN1EN                  ((uint32_t)0x02000000)
N#define  RCC_APB1ENR_CAN2EN                  ((uint32_t)0x04000000)
N#if defined(STM32F446xx)
X#if 0L
S#define  RCC_APB1ENR_CECEN                   ((uint32_t)0x08000000)
N#endif /* STM32F446xx */
N#define  RCC_APB1ENR_PWREN                   ((uint32_t)0x10000000)
N#define  RCC_APB1ENR_DACEN                   ((uint32_t)0x20000000)
N#define  RCC_APB1ENR_UART7EN                 ((uint32_t)0x40000000)
N#define  RCC_APB1ENR_UART8EN                 ((uint32_t)0x80000000)
N
N/********************  Bit definition for RCC_APB2ENR register  ***************/
N#define  RCC_APB2ENR_TIM1EN                  ((uint32_t)0x00000001)
N#define  RCC_APB2ENR_TIM8EN                  ((uint32_t)0x00000002)
N#define  RCC_APB2ENR_USART1EN                ((uint32_t)0x00000010)
N#define  RCC_APB2ENR_USART6EN                ((uint32_t)0x00000020)
N#define  RCC_APB2ENR_UART9EN                 ((uint32_t)0x00000040)
N#define  RCC_APB2ENR_UART10EN                ((uint32_t)0x00000080)
N#define  RCC_APB2ENR_ADC1EN                  ((uint32_t)0x00000100)
N#define  RCC_APB2ENR_ADC2EN                  ((uint32_t)0x00000200)
N#define  RCC_APB2ENR_ADC3EN                  ((uint32_t)0x00000400)
N#define  RCC_APB2ENR_SDIOEN                  ((uint32_t)0x00000800)
N#define  RCC_APB2ENR_SPI1EN                  ((uint32_t)0x00001000)
N#define  RCC_APB2ENR_SPI4EN                  ((uint32_t)0x00002000)
N#define  RCC_APB2ENR_SYSCFGEN                ((uint32_t)0x00004000)
N#define  RCC_APB2ENR_EXTIEN                  ((uint32_t)0x00008000)
N#define  RCC_APB2ENR_TIM9EN                  ((uint32_t)0x00010000)
N#define  RCC_APB2ENR_TIM10EN                 ((uint32_t)0x00020000)
N#define  RCC_APB2ENR_TIM11EN                 ((uint32_t)0x00040000)
N#define  RCC_APB2ENR_SPI5EN                  ((uint32_t)0x00100000)
N#define  RCC_APB2ENR_SPI6EN                  ((uint32_t)0x00200000)
N#define  RCC_APB2ENR_SAI1EN                  ((uint32_t)0x00400000)
N#if defined(STM32F446xx)
X#if 0L
S#define  RCC_APB2ENR_SAI2EN                  ((uint32_t)0x00800000)
N#endif /* STM32F446xx */
N#define  RCC_APB2ENR_LTDCEN                  ((uint32_t)0x04000000)
N#if defined(STM32F469_479xx)
X#if 0L
S#define  RCC_APB2ENR_DSIEN                   ((uint32_t)0x08000000)
N#endif /* STM32F469_479xx */
N#if defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 0L || 0L
S#define  RCC_APB2ENR_DFSDM1EN                ((uint32_t)0x01000000)
N#endif /* STM32F412xG || STM32F413_423xx */
N#if defined(STM32F413_423xx)
X#if 0L
S#define  RCC_APB2ENR_DFSDM2EN                ((uint32_t)0x02000000)
N#endif /* STM32F413_423xx */
N/********************  Bit definition for RCC_AHB1LPENR register  *************/
N#define  RCC_AHB1LPENR_GPIOALPEN             ((uint32_t)0x00000001)
N#define  RCC_AHB1LPENR_GPIOBLPEN             ((uint32_t)0x00000002)
N#define  RCC_AHB1LPENR_GPIOCLPEN             ((uint32_t)0x00000004)
N#define  RCC_AHB1LPENR_GPIODLPEN             ((uint32_t)0x00000008)
N#define  RCC_AHB1LPENR_GPIOELPEN             ((uint32_t)0x00000010)
N#define  RCC_AHB1LPENR_GPIOFLPEN             ((uint32_t)0x00000020)
N#define  RCC_AHB1LPENR_GPIOGLPEN             ((uint32_t)0x00000040)
N#define  RCC_AHB1LPENR_GPIOHLPEN             ((uint32_t)0x00000080)
N#define  RCC_AHB1LPENR_GPIOILPEN             ((uint32_t)0x00000100)
N#define  RCC_AHB1LPENR_GPIOJLPEN             ((uint32_t)0x00000200)
N#define  RCC_AHB1LPENR_GPIOKLPEN             ((uint32_t)0x00000400)
N#define  RCC_AHB1LPENR_CRCLPEN               ((uint32_t)0x00001000)
N#define  RCC_AHB1LPENR_FLITFLPEN             ((uint32_t)0x00008000)
N#define  RCC_AHB1LPENR_SRAM1LPEN             ((uint32_t)0x00010000)
N#define  RCC_AHB1LPENR_SRAM2LPEN             ((uint32_t)0x00020000)
N#define  RCC_AHB1LPENR_BKPSRAMLPEN           ((uint32_t)0x00040000)
N#define  RCC_AHB1LPENR_SRAM3LPEN             ((uint32_t)0x00080000)
N#define  RCC_AHB1LPENR_DMA1LPEN              ((uint32_t)0x00200000)
N#define  RCC_AHB1LPENR_DMA2LPEN              ((uint32_t)0x00400000)
N#define  RCC_AHB1LPENR_DMA2DLPEN             ((uint32_t)0x00800000)
N#define  RCC_AHB1LPENR_ETHMACLPEN            ((uint32_t)0x02000000)
N#define  RCC_AHB1LPENR_ETHMACTXLPEN          ((uint32_t)0x04000000)
N#define  RCC_AHB1LPENR_ETHMACRXLPEN          ((uint32_t)0x08000000)
N#define  RCC_AHB1LPENR_ETHMACPTPLPEN         ((uint32_t)0x10000000)
N#define  RCC_AHB1LPENR_OTGHSLPEN             ((uint32_t)0x20000000)
N#define  RCC_AHB1LPENR_OTGHSULPILPEN         ((uint32_t)0x40000000)
N
N/********************  Bit definition for RCC_AHB2LPENR register  *************/
N#define  RCC_AHB2LPENR_DCMILPEN              ((uint32_t)0x00000001)
N#define  RCC_AHB2LPENR_CRYPLPEN              ((uint32_t)0x00000010)
N#define  RCC_AHB2LPENR_HASHLPEN              ((uint32_t)0x00000020)
N#define  RCC_AHB2LPENR_RNGLPEN               ((uint32_t)0x00000040)
N#define  RCC_AHB2LPENR_OTGFSLPEN             ((uint32_t)0x00000080)
N
N/********************  Bit definition for RCC_AHB3LPENR register  *************/
N#if defined(STM32F40_41xxx) || defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 1L || 0L || 0L
N#define  RCC_AHB3LPENR_FSMCLPEN              ((uint32_t)0x00000001)
N#endif /* STM32F40_41xxx || STM32F412xG || STM32F413_423xx */
N
N#if defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
X#if 0L || 0L || 0L || 0L
S#define  RCC_AHB3LPENR_FMCLPEN              ((uint32_t)0x00000001)
N#endif /* STM32F427_437xx ||  STM32F429_439xx  || STM32F446xx || STM32F469_479xx */
N#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
X#if 0L || 0L || 0L || 0L
S#define  RCC_AHB3LPENR_QSPILPEN             ((uint32_t)0x00000002)
N#endif /* STM32F412xG || STM32F413_423xx || STM32F469_479xx || STM32F446xx */
N
N/********************  Bit definition for RCC_APB1LPENR register  *************/
N#define  RCC_APB1LPENR_TIM2LPEN              ((uint32_t)0x00000001)
N#define  RCC_APB1LPENR_TIM3LPEN              ((uint32_t)0x00000002)
N#define  RCC_APB1LPENR_TIM4LPEN              ((uint32_t)0x00000004)
N#define  RCC_APB1LPENR_TIM5LPEN              ((uint32_t)0x00000008)
N#define  RCC_APB1LPENR_TIM6LPEN              ((uint32_t)0x00000010)
N#define  RCC_APB1LPENR_TIM7LPEN              ((uint32_t)0x00000020)
N#define  RCC_APB1LPENR_TIM12LPEN             ((uint32_t)0x00000040)
N#define  RCC_APB1LPENR_TIM13LPEN             ((uint32_t)0x00000080)
N#define  RCC_APB1LPENR_TIM14LPEN             ((uint32_t)0x00000100)
N#if defined(STM32F410xx) || defined(STM32F413_423xx)
X#if 0L || 0L
S#define  RCC_APB1LPENR_LPTIM1LPEN            ((uint32_t)0x00000200)
N#endif /* STM32F410xx || STM32F413_423xx */
N#define  RCC_APB1LPENR_WWDGLPEN              ((uint32_t)0x00000800)
N#define  RCC_APB1LPENR_SPI2LPEN              ((uint32_t)0x00004000)
N#define  RCC_APB1LPENR_SPI3LPEN              ((uint32_t)0x00008000)
N#if defined(STM32F446xx)
X#if 0L
S#define  RCC_APB1LPENR_SPDIFRXLPEN           ((uint32_t)0x00010000)
N#endif /* STM32F446xx */
N#define  RCC_APB1LPENR_USART2LPEN            ((uint32_t)0x00020000)
N#define  RCC_APB1LPENR_USART3LPEN            ((uint32_t)0x00040000)
N#define  RCC_APB1LPENR_UART4LPEN             ((uint32_t)0x00080000)
N#define  RCC_APB1LPENR_UART5LPEN             ((uint32_t)0x00100000)
N#define  RCC_APB1LPENR_I2C1LPEN              ((uint32_t)0x00200000)
N#define  RCC_APB1LPENR_I2C2LPEN              ((uint32_t)0x00400000)
N#define  RCC_APB1LPENR_I2C3LPEN              ((uint32_t)0x00800000)
N#if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
X#if 0L || 0L || 0L || 0L
S#define  RCC_APB1LPENR_FMPI2C1LPEN           ((uint32_t)0x01000000)
N#endif /* STM32F410xx || STM32F412xG || STM32F413_423xx || STM32F446xx */
N#define  RCC_APB1LPENR_CAN1LPEN              ((uint32_t)0x02000000)
N#define  RCC_APB1LPENR_CAN2LPEN              ((uint32_t)0x04000000)
N#if defined(STM32F446xx)
X#if 0L
S#define  RCC_APB1LPENR_CECLPEN               ((uint32_t)0x08000000)
N#endif /* STM32F446xx */
N#define  RCC_APB1LPENR_PWRLPEN               ((uint32_t)0x10000000)
N#define  RCC_APB1LPENR_DACLPEN               ((uint32_t)0x20000000)
N#define  RCC_APB1LPENR_UART7LPEN             ((uint32_t)0x40000000)
N#define  RCC_APB1LPENR_UART8LPEN             ((uint32_t)0x80000000)
N
N/********************  Bit definition for RCC_APB2LPENR register  *************/
N#define  RCC_APB2LPENR_TIM1LPEN              ((uint32_t)0x00000001)
N#define  RCC_APB2LPENR_TIM8LPEN              ((uint32_t)0x00000002)
N#define  RCC_APB2LPENR_USART1LPEN            ((uint32_t)0x00000010)
N#define  RCC_APB2LPENR_USART6LPEN            ((uint32_t)0x00000020)
N#define  RCC_APB2LPENR_UART9LPEN             ((uint32_t)0x00000040)
N#define  RCC_APB2LPENR_UART10LPEN            ((uint32_t)0x00000080)
N#define  RCC_APB2LPENR_ADC1LPEN              ((uint32_t)0x00000100)
N#define  RCC_APB2LPENR_ADC2PEN               ((uint32_t)0x00000200)
N#define  RCC_APB2LPENR_ADC3LPEN              ((uint32_t)0x00000400)
N#define  RCC_APB2LPENR_SDIOLPEN              ((uint32_t)0x00000800)
N#define  RCC_APB2LPENR_SPI1LPEN              ((uint32_t)0x00001000)
N#define  RCC_APB2LPENR_SPI4LPEN              ((uint32_t)0x00002000)
N#define  RCC_APB2LPENR_SYSCFGLPEN            ((uint32_t)0x00004000)
N#define  RCC_APB2LPENR_TIM9LPEN              ((uint32_t)0x00010000)
N#define  RCC_APB2LPENR_TIM10LPEN             ((uint32_t)0x00020000)
N#define  RCC_APB2LPENR_TIM11LPEN             ((uint32_t)0x00040000)
N#define  RCC_APB2LPENR_SPI5LPEN              ((uint32_t)0x00100000)
N#define  RCC_APB2LPENR_SPI6LPEN              ((uint32_t)0x00200000)
N#define  RCC_APB2LPENR_SAI1LPEN              ((uint32_t)0x00400000)
N#if defined(STM32F446xx)
X#if 0L
S#define  RCC_APB2LPENR_SAI2LPEN              ((uint32_t)0x00800000)
N#endif /* STM32F446xx */
N#define  RCC_APB2LPENR_LTDCLPEN              ((uint32_t)0x04000000)
N#if defined(STM32F469_479xx)
X#if 0L
S#define  RCC_APB2LPENR_DSILPEN               ((uint32_t)0x08000000)
N#endif /* STM32F469_479xx */
N#if defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 0L || 0L
S#define  RCC_APB2LPENR_DFSDM1LPEN            ((uint32_t)0x01000000)
N#endif /* STM32F412xG || STM32F413_423xx */
N#if defined(STM32F413_423xx)
X#if 0L
S#define  RCC_APB2LPENR_DFSDM2LPEN            ((uint32_t)0x02000000)
N#endif /* STM32F413_423xx */
N
N/********************  Bit definition for RCC_BDCR register  ******************/
N#define  RCC_BDCR_LSEON                      ((uint32_t)0x00000001)
N#define  RCC_BDCR_LSERDY                     ((uint32_t)0x00000002)
N#define  RCC_BDCR_LSEBYP                     ((uint32_t)0x00000004)
N#define  RCC_BDCR_LSEMOD                     ((uint32_t)0x00000008)
N
N#define  RCC_BDCR_RTCSEL                    ((uint32_t)0x00000300)
N#define  RCC_BDCR_RTCSEL_0                  ((uint32_t)0x00000100)
N#define  RCC_BDCR_RTCSEL_1                  ((uint32_t)0x00000200)
N
N#define  RCC_BDCR_RTCEN                      ((uint32_t)0x00008000)
N#define  RCC_BDCR_BDRST                      ((uint32_t)0x00010000)
N
N/********************  Bit definition for RCC_CSR register  *******************/
N#define  RCC_CSR_LSION                       ((uint32_t)0x00000001)
N#define  RCC_CSR_LSIRDY                      ((uint32_t)0x00000002)
N#define  RCC_CSR_RMVF                        ((uint32_t)0x01000000)
N#define  RCC_CSR_BORRSTF                     ((uint32_t)0x02000000)
N#define  RCC_CSR_PADRSTF                     ((uint32_t)0x04000000)
N#define  RCC_CSR_PORRSTF                     ((uint32_t)0x08000000)
N#define  RCC_CSR_SFTRSTF                     ((uint32_t)0x10000000)
N#define  RCC_CSR_WDGRSTF                     ((uint32_t)0x20000000)
N#define  RCC_CSR_WWDGRSTF                    ((uint32_t)0x40000000)
N#define  RCC_CSR_LPWRRSTF                    ((uint32_t)0x80000000)
N
N/********************  Bit definition for RCC_SSCGR register  *****************/
N#define  RCC_SSCGR_MODPER                    ((uint32_t)0x00001FFF)
N#define  RCC_SSCGR_INCSTEP                   ((uint32_t)0x0FFFE000)
N#define  RCC_SSCGR_SPREADSEL                 ((uint32_t)0x40000000)
N#define  RCC_SSCGR_SSCGEN                    ((uint32_t)0x80000000)
N
N/********************  Bit definition for RCC_PLLI2SCFGR register  ************/
N#define  RCC_PLLI2SCFGR_PLLI2SM              ((uint32_t)0x0000003F)
N#define  RCC_PLLI2SCFGR_PLLI2SM_0            ((uint32_t)0x00000001)
N#define  RCC_PLLI2SCFGR_PLLI2SM_1            ((uint32_t)0x00000002)
N#define  RCC_PLLI2SCFGR_PLLI2SM_2            ((uint32_t)0x00000004)
N#define  RCC_PLLI2SCFGR_PLLI2SM_3            ((uint32_t)0x00000008)
N#define  RCC_PLLI2SCFGR_PLLI2SM_4            ((uint32_t)0x00000010)
N#define  RCC_PLLI2SCFGR_PLLI2SM_5            ((uint32_t)0x00000020)
N
N#define  RCC_PLLI2SCFGR_PLLI2SN              ((uint32_t)0x00007FC0)
N#define  RCC_PLLI2SCFGR_PLLI2SN_0            ((uint32_t)0x00000040)
N#define  RCC_PLLI2SCFGR_PLLI2SN_1            ((uint32_t)0x00000080)
N#define  RCC_PLLI2SCFGR_PLLI2SN_2            ((uint32_t)0x00000100)
N#define  RCC_PLLI2SCFGR_PLLI2SN_3            ((uint32_t)0x00000200)
N#define  RCC_PLLI2SCFGR_PLLI2SN_4            ((uint32_t)0x00000400)
N#define  RCC_PLLI2SCFGR_PLLI2SN_5            ((uint32_t)0x00000800)
N#define  RCC_PLLI2SCFGR_PLLI2SN_6            ((uint32_t)0x00001000)
N#define  RCC_PLLI2SCFGR_PLLI2SN_7            ((uint32_t)0x00002000)
N#define  RCC_PLLI2SCFGR_PLLI2SN_8            ((uint32_t)0x00004000)
N
N#if defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 0L || 0L
S#define  RCC_PLLI2SCFGR_PLLI2SSRC            ((uint32_t)0x00400000)
N#endif /* STM32F412xG || STM32F413_423xx */
N
N#if defined(STM32F446xx)
X#if 0L
S#define  RCC_PLLI2SCFGR_PLLI2SP              ((uint32_t)0x00030000)
S#define  RCC_PLLI2SCFGR_PLLI2SP_0            ((uint32_t)0x00010000)
S#define  RCC_PLLI2SCFGR_PLLI2SP_1            ((uint32_t)0x00020000)
N#endif /* STM32F446xx */
N
N#define  RCC_PLLI2SCFGR_PLLI2SQ              ((uint32_t)0x0F000000)
N#define  RCC_PLLI2SCFGR_PLLI2SQ_0            ((uint32_t)0x01000000)
N#define  RCC_PLLI2SCFGR_PLLI2SQ_1            ((uint32_t)0x02000000)
N#define  RCC_PLLI2SCFGR_PLLI2SQ_2            ((uint32_t)0x04000000)
N#define  RCC_PLLI2SCFGR_PLLI2SQ_3            ((uint32_t)0x08000000)
N
N#define  RCC_PLLI2SCFGR_PLLI2SR              ((uint32_t)0x70000000)
N#define  RCC_PLLI2SCFGR_PLLI2SR_0            ((uint32_t)0x10000000)
N#define  RCC_PLLI2SCFGR_PLLI2SR_1            ((uint32_t)0x20000000)
N#define  RCC_PLLI2SCFGR_PLLI2SR_2            ((uint32_t)0x40000000)
N
N/********************  Bit definition for RCC_PLLSAICFGR register  ************/
N#if defined(STM32F446xx)
X#if 0L
S#define  RCC_PLLSAICFGR_PLLSAIM              ((uint32_t)0x0000003F)
S#define  RCC_PLLSAICFGR_PLLSAIM_0            ((uint32_t)0x00000001)
S#define  RCC_PLLSAICFGR_PLLSAIM_1            ((uint32_t)0x00000002)
S#define  RCC_PLLSAICFGR_PLLSAIM_2            ((uint32_t)0x00000004)
S#define  RCC_PLLSAICFGR_PLLSAIM_3            ((uint32_t)0x00000008)
S#define  RCC_PLLSAICFGR_PLLSAIM_4            ((uint32_t)0x00000010)
S#define  RCC_PLLSAICFGR_PLLSAIM_5            ((uint32_t)0x00000020)
N#endif /* STM32F446xx */
N
N#define  RCC_PLLSAICFGR_PLLSAIN              ((uint32_t)0x00007FC0)
N#define  RCC_PLLSAICFGR_PLLSAIN_0            ((uint32_t)0x00000040)
N#define  RCC_PLLSAICFGR_PLLSAIN_1            ((uint32_t)0x00000080)
N#define  RCC_PLLSAICFGR_PLLSAIN_2            ((uint32_t)0x00000100)
N#define  RCC_PLLSAICFGR_PLLSAIN_3            ((uint32_t)0x00000200)
N#define  RCC_PLLSAICFGR_PLLSAIN_4            ((uint32_t)0x00000400)
N#define  RCC_PLLSAICFGR_PLLSAIN_5            ((uint32_t)0x00000800)
N#define  RCC_PLLSAICFGR_PLLSAIN_6            ((uint32_t)0x00001000)
N#define  RCC_PLLSAICFGR_PLLSAIN_7            ((uint32_t)0x00002000)
N#define  RCC_PLLSAICFGR_PLLSAIN_8            ((uint32_t)0x00004000)
N
N#if defined(STM32F446xx) || defined(STM32F469_479xx)  
X#if 0L || 0L  
S#define  RCC_PLLSAICFGR_PLLSAIP              ((uint32_t)0x00030000)
S#define  RCC_PLLSAICFGR_PLLSAIP_0            ((uint32_t)0x00010000)
S#define  RCC_PLLSAICFGR_PLLSAIP_1            ((uint32_t)0x00020000)
N#endif /* STM32F446xx || STM32F469_479xx */
N
N#define  RCC_PLLSAICFGR_PLLSAIQ              ((uint32_t)0x0F000000)
N#define  RCC_PLLSAICFGR_PLLSAIQ_0            ((uint32_t)0x01000000)
N#define  RCC_PLLSAICFGR_PLLSAIQ_1            ((uint32_t)0x02000000)
N#define  RCC_PLLSAICFGR_PLLSAIQ_2            ((uint32_t)0x04000000)
N#define  RCC_PLLSAICFGR_PLLSAIQ_3            ((uint32_t)0x08000000)
N
N#define  RCC_PLLSAICFGR_PLLSAIR              ((uint32_t)0x70000000)
N#define  RCC_PLLSAICFGR_PLLSAIR_0            ((uint32_t)0x10000000)
N#define  RCC_PLLSAICFGR_PLLSAIR_1            ((uint32_t)0x20000000)
N#define  RCC_PLLSAICFGR_PLLSAIR_2            ((uint32_t)0x40000000)
N
N/********************  Bit definition for RCC_DCKCFGR register  ***************/
N#define  RCC_DCKCFGR_PLLI2SDIVQ              ((uint32_t)0x0000001F)
N#define  RCC_DCKCFGR_PLLSAIDIVQ              ((uint32_t)0x00001F00)
N#define  RCC_DCKCFGR_PLLSAIDIVR              ((uint32_t)0x00030000)
N
N#if defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 0L || 0L
S#define  RCC_DCKCFGR_CKDFSDM1SEL             ((uint32_t)0x80000000)
S#define  RCC_DCKCFGR_CKDFSDM1ASEL            ((uint32_t)0x00008000)
N#endif /* STM32F412xG || STM32F413_423xx */
N
N#if defined(STM32F413_423xx)
X#if 0L
S#define  RCC_DCKCFGR_PLLI2SDIVR              ((uint32_t)0x0000001F)
S#define  RCC_DCKCFGR_PLLI2SDIVR_0            ((uint32_t)0x00000001)
S#define  RCC_DCKCFGR_PLLI2SDIVR_1            ((uint32_t)0x00000002)
S#define  RCC_DCKCFGR_PLLI2SDIVR_2            ((uint32_t)0x00000004)
S#define  RCC_DCKCFGR_PLLI2SDIVR_3            ((uint32_t)0x00000008)
S#define  RCC_DCKCFGR_PLLI2SDIVR_4            ((uint32_t)0x00000010)
S
S#define  RCC_DCKCFGR_PLLDIVR                 ((uint32_t)0x00001F00)
S#define  RCC_DCKCFGR_PLLDIVR_0               ((uint32_t)0x00000100)
S#define  RCC_DCKCFGR_PLLDIVR_1               ((uint32_t)0x00000200)
S#define  RCC_DCKCFGR_PLLDIVR_2               ((uint32_t)0x00000400)
S#define  RCC_DCKCFGR_PLLDIVR_3               ((uint32_t)0x00000800)
S#define  RCC_DCKCFGR_PLLDIVR_4               ((uint32_t)0x00001000)
S#define  RCC_DCKCFGR_CKDFSDM2ASEL            ((uint32_t)0x00004000)
N#endif /* STM32F413_423xx */
N
N#define  RCC_DCKCFGR_SAI1ASRC                ((uint32_t)0x00300000)
N#define  RCC_DCKCFGR_SAI1ASRC_0              ((uint32_t)0x00100000)
N#define  RCC_DCKCFGR_SAI1ASRC_1              ((uint32_t)0x00200000)
N#if defined(STM32F446xx)
X#if 0L
S#define  RCC_DCKCFGR_SAI1SRC                 ((uint32_t)0x00300000)
S#define  RCC_DCKCFGR_SAI1SRC_0               ((uint32_t)0x00100000)
S#define  RCC_DCKCFGR_SAI1SRC_1               ((uint32_t)0x00200000)
N#endif /* STM32F446xx */
N
N#define  RCC_DCKCFGR_SAI1BSRC                ((uint32_t)0x00C00000)
N#define  RCC_DCKCFGR_SAI1BSRC_0              ((uint32_t)0x00400000)
N#define  RCC_DCKCFGR_SAI1BSRC_1              ((uint32_t)0x00800000)
N#if defined(STM32F446xx)
X#if 0L
S#define  RCC_DCKCFGR_SAI2SRC                 ((uint32_t)0x00C00000)
S#define  RCC_DCKCFGR_SAI2SRC_0               ((uint32_t)0x00400000)
S#define  RCC_DCKCFGR_SAI2SRC_1               ((uint32_t)0x00800000)
N#endif /* STM32F446xx */
N
N#define  RCC_DCKCFGR_TIMPRE                  ((uint32_t)0x01000000)
N#if defined(STM32F469_479xx)
X#if 0L
S#define  RCC_DCKCFGR_CK48MSEL                ((uint32_t)0x08000000)
S#define  RCC_DCKCFGR_SDIOSEL                 ((uint32_t)0x10000000)
S#define  RCC_DCKCFGR_DSISEL                  ((uint32_t)0x20000000)
N#endif /* STM32F469_479xx */
N
N#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
X#if 0L || 0L || 0L
S#define  RCC_DCKCFGR_I2S1SRC                 ((uint32_t)0x06000000)
S#define  RCC_DCKCFGR_I2S1SRC_0               ((uint32_t)0x02000000)
S#define  RCC_DCKCFGR_I2S1SRC_1               ((uint32_t)0x04000000)
S#define  RCC_DCKCFGR_I2S2SRC                 ((uint32_t)0x18000000)
S#define  RCC_DCKCFGR_I2S2SRC_0               ((uint32_t)0x08000000)
S#define  RCC_DCKCFGR_I2S2SRC_1               ((uint32_t)0x10000000)
S
S/********************  Bit definition for RCC_CKGATENR register  ***************/
S#define  RCC_CKGATENR_AHB2APB1_CKEN          ((uint32_t)0x00000001)
S#define  RCC_CKGATENR_AHB2APB2_CKEN          ((uint32_t)0x00000002)
S#define  RCC_CKGATENR_CM4DBG_CKEN            ((uint32_t)0x00000004)
S#define  RCC_CKGATENR_SPARE_CKEN             ((uint32_t)0x00000008)
S#define  RCC_CKGATENR_SRAM_CKEN              ((uint32_t)0x00000010)
S#define  RCC_CKGATENR_FLITF_CKEN             ((uint32_t)0x00000020)
S#define  RCC_CKGATENR_RCC_CKEN               ((uint32_t)0x00000040)
S#if defined(STM32F412xG) || defined(STM32F413_423xx)
S#define  RCC_CKGATENR_RCC_EVTCTL             ((uint32_t)0x00000080)
S#endif /* STM32F412xG || STM32F413_423xx */
S
S/********************  Bit definition for RCC_DCKCFGR2 register  ***************/
S#define  RCC_DCKCFGR2_FMPI2C1SEL             ((uint32_t)0x00C00000)
S#define  RCC_DCKCFGR2_FMPI2C1SEL_0           ((uint32_t)0x00400000)
S#define  RCC_DCKCFGR2_FMPI2C1SEL_1           ((uint32_t)0x00800000)
S#define  RCC_DCKCFGR2_CECSEL                 ((uint32_t)0x04000000)
S#define  RCC_DCKCFGR2_CK48MSEL               ((uint32_t)0x08000000)
S#define  RCC_DCKCFGR2_SDIOSEL                ((uint32_t)0x10000000)
S#if defined(STM32F446xx)
S#define  RCC_DCKCFGR2_SPDIFRXSEL             ((uint32_t)0x20000000)
S#endif /* STM32F446xx */
S#if defined(STM32F413_423xx)
S#define  RCC_DCKCFGR2_LPTIM1SEL              ((uint32_t)0xC0000000)
S#define  RCC_DCKCFGR2_LPTIM1SEL_0            ((uint32_t)0x40000000)
S#define  RCC_DCKCFGR2_LPTIM1SEL_1            ((uint32_t)0x80000000)
S#endif /* STM32F413_423xx */
N#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx */
N
N#if defined(STM32F410xx)
X#if 0L
S#define  RCC_DCKCFGR_I2SSRC                  ((uint32_t)0x06000000)
S#define  RCC_DCKCFGR_I2SSRC_0                ((uint32_t)0x02000000)
S#define  RCC_DCKCFGR_I2SSRC_1                ((uint32_t)0x04000000)
N#endif /* STM32F410xx */
N
N#if defined(STM32F410xx)
X#if 0L
S/********************  Bit definition for RCC_DCKCFGR2 register  **************/
S#define  RCC_DCKCFGR2_FMPI2C1SEL             ((uint32_t)0x00C00000)
S#define  RCC_DCKCFGR2_FMPI2C1SEL_0           ((uint32_t)0x00400000)
S#define  RCC_DCKCFGR2_FMPI2C1SEL_1           ((uint32_t)0x00800000)
S#define  RCC_DCKCFGR2_LPTIM1SEL              ((uint32_t)0xC0000000)
S#define  RCC_DCKCFGR2_LPTIM1SEL_0            ((uint32_t)0x40000000)
S#define  RCC_DCKCFGR2_LPTIM1SEL_1            ((uint32_t)0x80000000)
N#endif /* STM32F410xx */
N/******************************************************************************/
N/*                                                                            */
N/*                                    RNG                                     */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bits definition for RNG_CR register  *******************/
N#define RNG_CR_RNGEN                         ((uint32_t)0x00000004)
N#define RNG_CR_IE                            ((uint32_t)0x00000008)
N
N/********************  Bits definition for RNG_SR register  *******************/
N#define RNG_SR_DRDY                          ((uint32_t)0x00000001)
N#define RNG_SR_CECS                          ((uint32_t)0x00000002)
N#define RNG_SR_SECS                          ((uint32_t)0x00000004)
N#define RNG_SR_CEIS                          ((uint32_t)0x00000020)
N#define RNG_SR_SEIS                          ((uint32_t)0x00000040)
N
N/******************************************************************************/
N/*                                                                            */
N/*                           Real-Time Clock (RTC)                            */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bits definition for RTC_TR register  *******************/
N#define RTC_TR_PM                            ((uint32_t)0x00400000)
N#define RTC_TR_HT                            ((uint32_t)0x00300000)
N#define RTC_TR_HT_0                          ((uint32_t)0x00100000)
N#define RTC_TR_HT_1                          ((uint32_t)0x00200000)
N#define RTC_TR_HU                            ((uint32_t)0x000F0000)
N#define RTC_TR_HU_0                          ((uint32_t)0x00010000)
N#define RTC_TR_HU_1                          ((uint32_t)0x00020000)
N#define RTC_TR_HU_2                          ((uint32_t)0x00040000)
N#define RTC_TR_HU_3                          ((uint32_t)0x00080000)
N#define RTC_TR_MNT                           ((uint32_t)0x00007000)
N#define RTC_TR_MNT_0                         ((uint32_t)0x00001000)
N#define RTC_TR_MNT_1                         ((uint32_t)0x00002000)
N#define RTC_TR_MNT_2                         ((uint32_t)0x00004000)
N#define RTC_TR_MNU                           ((uint32_t)0x00000F00)
N#define RTC_TR_MNU_0                         ((uint32_t)0x00000100)
N#define RTC_TR_MNU_1                         ((uint32_t)0x00000200)
N#define RTC_TR_MNU_2                         ((uint32_t)0x00000400)
N#define RTC_TR_MNU_3                         ((uint32_t)0x00000800)
N#define RTC_TR_ST                            ((uint32_t)0x00000070)
N#define RTC_TR_ST_0                          ((uint32_t)0x00000010)
N#define RTC_TR_ST_1                          ((uint32_t)0x00000020)
N#define RTC_TR_ST_2                          ((uint32_t)0x00000040)
N#define RTC_TR_SU                            ((uint32_t)0x0000000F)
N#define RTC_TR_SU_0                          ((uint32_t)0x00000001)
N#define RTC_TR_SU_1                          ((uint32_t)0x00000002)
N#define RTC_TR_SU_2                          ((uint32_t)0x00000004)
N#define RTC_TR_SU_3                          ((uint32_t)0x00000008)
N
N/********************  Bits definition for RTC_DR register  *******************/
N#define RTC_DR_YT                            ((uint32_t)0x00F00000)
N#define RTC_DR_YT_0                          ((uint32_t)0x00100000)
N#define RTC_DR_YT_1                          ((uint32_t)0x00200000)
N#define RTC_DR_YT_2                          ((uint32_t)0x00400000)
N#define RTC_DR_YT_3                          ((uint32_t)0x00800000)
N#define RTC_DR_YU                            ((uint32_t)0x000F0000)
N#define RTC_DR_YU_0                          ((uint32_t)0x00010000)
N#define RTC_DR_YU_1                          ((uint32_t)0x00020000)
N#define RTC_DR_YU_2                          ((uint32_t)0x00040000)
N#define RTC_DR_YU_3                          ((uint32_t)0x00080000)
N#define RTC_DR_WDU                           ((uint32_t)0x0000E000)
N#define RTC_DR_WDU_0                         ((uint32_t)0x00002000)
N#define RTC_DR_WDU_1                         ((uint32_t)0x00004000)
N#define RTC_DR_WDU_2                         ((uint32_t)0x00008000)
N#define RTC_DR_MT                            ((uint32_t)0x00001000)
N#define RTC_DR_MU                            ((uint32_t)0x00000F00)
N#define RTC_DR_MU_0                          ((uint32_t)0x00000100)
N#define RTC_DR_MU_1                          ((uint32_t)0x00000200)
N#define RTC_DR_MU_2                          ((uint32_t)0x00000400)
N#define RTC_DR_MU_3                          ((uint32_t)0x00000800)
N#define RTC_DR_DT                            ((uint32_t)0x00000030)
N#define RTC_DR_DT_0                          ((uint32_t)0x00000010)
N#define RTC_DR_DT_1                          ((uint32_t)0x00000020)
N#define RTC_DR_DU                            ((uint32_t)0x0000000F)
N#define RTC_DR_DU_0                          ((uint32_t)0x00000001)
N#define RTC_DR_DU_1                          ((uint32_t)0x00000002)
N#define RTC_DR_DU_2                          ((uint32_t)0x00000004)
N#define RTC_DR_DU_3                          ((uint32_t)0x00000008)
N
N/********************  Bits definition for RTC_CR register  *******************/
N#define RTC_CR_COE                           ((uint32_t)0x00800000)
N#define RTC_CR_OSEL                          ((uint32_t)0x00600000)
N#define RTC_CR_OSEL_0                        ((uint32_t)0x00200000)
N#define RTC_CR_OSEL_1                        ((uint32_t)0x00400000)
N#define RTC_CR_POL                           ((uint32_t)0x00100000)
N#define RTC_CR_COSEL                         ((uint32_t)0x00080000)
N#define RTC_CR_BCK                           ((uint32_t)0x00040000)
N#define RTC_CR_SUB1H                         ((uint32_t)0x00020000)
N#define RTC_CR_ADD1H                         ((uint32_t)0x00010000)
N#define RTC_CR_TSIE                          ((uint32_t)0x00008000)
N#define RTC_CR_WUTIE                         ((uint32_t)0x00004000)
N#define RTC_CR_ALRBIE                        ((uint32_t)0x00002000)
N#define RTC_CR_ALRAIE                        ((uint32_t)0x00001000)
N#define RTC_CR_TSE                           ((uint32_t)0x00000800)
N#define RTC_CR_WUTE                          ((uint32_t)0x00000400)
N#define RTC_CR_ALRBE                         ((uint32_t)0x00000200)
N#define RTC_CR_ALRAE                         ((uint32_t)0x00000100)
N#define RTC_CR_DCE                           ((uint32_t)0x00000080)
N#define RTC_CR_FMT                           ((uint32_t)0x00000040)
N#define RTC_CR_BYPSHAD                       ((uint32_t)0x00000020)
N#define RTC_CR_REFCKON                       ((uint32_t)0x00000010)
N#define RTC_CR_TSEDGE                        ((uint32_t)0x00000008)
N#define RTC_CR_WUCKSEL                       ((uint32_t)0x00000007)
N#define RTC_CR_WUCKSEL_0                     ((uint32_t)0x00000001)
N#define RTC_CR_WUCKSEL_1                     ((uint32_t)0x00000002)
N#define RTC_CR_WUCKSEL_2                     ((uint32_t)0x00000004)
N
N/********************  Bits definition for RTC_ISR register  ******************/
N#define RTC_ISR_RECALPF                      ((uint32_t)0x00010000)
N#define RTC_ISR_TAMP1F                       ((uint32_t)0x00002000)
N#define RTC_ISR_TAMP2F                       ((uint32_t)0x00004000)
N#define RTC_ISR_TSOVF                        ((uint32_t)0x00001000)
N#define RTC_ISR_TSF                          ((uint32_t)0x00000800)
N#define RTC_ISR_WUTF                         ((uint32_t)0x00000400)
N#define RTC_ISR_ALRBF                        ((uint32_t)0x00000200)
N#define RTC_ISR_ALRAF                        ((uint32_t)0x00000100)
N#define RTC_ISR_INIT                         ((uint32_t)0x00000080)
N#define RTC_ISR_INITF                        ((uint32_t)0x00000040)
N#define RTC_ISR_RSF                          ((uint32_t)0x00000020)
N#define RTC_ISR_INITS                        ((uint32_t)0x00000010)
N#define RTC_ISR_SHPF                         ((uint32_t)0x00000008)
N#define RTC_ISR_WUTWF                        ((uint32_t)0x00000004)
N#define RTC_ISR_ALRBWF                       ((uint32_t)0x00000002)
N#define RTC_ISR_ALRAWF                       ((uint32_t)0x00000001)
N
N/********************  Bits definition for RTC_PRER register  *****************/
N#define RTC_PRER_PREDIV_A                    ((uint32_t)0x007F0000)
N#define RTC_PRER_PREDIV_S                    ((uint32_t)0x00001FFF)
N
N/********************  Bits definition for RTC_WUTR register  *****************/
N#define RTC_WUTR_WUT                         ((uint32_t)0x0000FFFF)
N
N/********************  Bits definition for RTC_CALIBR register  ***************/
N#define RTC_CALIBR_DCS                       ((uint32_t)0x00000080)
N#define RTC_CALIBR_DC                        ((uint32_t)0x0000001F)
N
N/********************  Bits definition for RTC_ALRMAR register  ***************/
N#define RTC_ALRMAR_MSK4                      ((uint32_t)0x80000000)
N#define RTC_ALRMAR_WDSEL                     ((uint32_t)0x40000000)
N#define RTC_ALRMAR_DT                        ((uint32_t)0x30000000)
N#define RTC_ALRMAR_DT_0                      ((uint32_t)0x10000000)
N#define RTC_ALRMAR_DT_1                      ((uint32_t)0x20000000)
N#define RTC_ALRMAR_DU                        ((uint32_t)0x0F000000)
N#define RTC_ALRMAR_DU_0                      ((uint32_t)0x01000000)
N#define RTC_ALRMAR_DU_1                      ((uint32_t)0x02000000)
N#define RTC_ALRMAR_DU_2                      ((uint32_t)0x04000000)
N#define RTC_ALRMAR_DU_3                      ((uint32_t)0x08000000)
N#define RTC_ALRMAR_MSK3                      ((uint32_t)0x00800000)
N#define RTC_ALRMAR_PM                        ((uint32_t)0x00400000)
N#define RTC_ALRMAR_HT                        ((uint32_t)0x00300000)
N#define RTC_ALRMAR_HT_0                      ((uint32_t)0x00100000)
N#define RTC_ALRMAR_HT_1                      ((uint32_t)0x00200000)
N#define RTC_ALRMAR_HU                        ((uint32_t)0x000F0000)
N#define RTC_ALRMAR_HU_0                      ((uint32_t)0x00010000)
N#define RTC_ALRMAR_HU_1                      ((uint32_t)0x00020000)
N#define RTC_ALRMAR_HU_2                      ((uint32_t)0x00040000)
N#define RTC_ALRMAR_HU_3                      ((uint32_t)0x00080000)
N#define RTC_ALRMAR_MSK2                      ((uint32_t)0x00008000)
N#define RTC_ALRMAR_MNT                       ((uint32_t)0x00007000)
N#define RTC_ALRMAR_MNT_0                     ((uint32_t)0x00001000)
N#define RTC_ALRMAR_MNT_1                     ((uint32_t)0x00002000)
N#define RTC_ALRMAR_MNT_2                     ((uint32_t)0x00004000)
N#define RTC_ALRMAR_MNU                       ((uint32_t)0x00000F00)
N#define RTC_ALRMAR_MNU_0                     ((uint32_t)0x00000100)
N#define RTC_ALRMAR_MNU_1                     ((uint32_t)0x00000200)
N#define RTC_ALRMAR_MNU_2                     ((uint32_t)0x00000400)
N#define RTC_ALRMAR_MNU_3                     ((uint32_t)0x00000800)
N#define RTC_ALRMAR_MSK1                      ((uint32_t)0x00000080)
N#define RTC_ALRMAR_ST                        ((uint32_t)0x00000070)
N#define RTC_ALRMAR_ST_0                      ((uint32_t)0x00000010)
N#define RTC_ALRMAR_ST_1                      ((uint32_t)0x00000020)
N#define RTC_ALRMAR_ST_2                      ((uint32_t)0x00000040)
N#define RTC_ALRMAR_SU                        ((uint32_t)0x0000000F)
N#define RTC_ALRMAR_SU_0                      ((uint32_t)0x00000001)
N#define RTC_ALRMAR_SU_1                      ((uint32_t)0x00000002)
N#define RTC_ALRMAR_SU_2                      ((uint32_t)0x00000004)
N#define RTC_ALRMAR_SU_3                      ((uint32_t)0x00000008)
N
N/********************  Bits definition for RTC_ALRMBR register  ***************/
N#define RTC_ALRMBR_MSK4                      ((uint32_t)0x80000000)
N#define RTC_ALRMBR_WDSEL                     ((uint32_t)0x40000000)
N#define RTC_ALRMBR_DT                        ((uint32_t)0x30000000)
N#define RTC_ALRMBR_DT_0                      ((uint32_t)0x10000000)
N#define RTC_ALRMBR_DT_1                      ((uint32_t)0x20000000)
N#define RTC_ALRMBR_DU                        ((uint32_t)0x0F000000)
N#define RTC_ALRMBR_DU_0                      ((uint32_t)0x01000000)
N#define RTC_ALRMBR_DU_1                      ((uint32_t)0x02000000)
N#define RTC_ALRMBR_DU_2                      ((uint32_t)0x04000000)
N#define RTC_ALRMBR_DU_3                      ((uint32_t)0x08000000)
N#define RTC_ALRMBR_MSK3                      ((uint32_t)0x00800000)
N#define RTC_ALRMBR_PM                        ((uint32_t)0x00400000)
N#define RTC_ALRMBR_HT                        ((uint32_t)0x00300000)
N#define RTC_ALRMBR_HT_0                      ((uint32_t)0x00100000)
N#define RTC_ALRMBR_HT_1                      ((uint32_t)0x00200000)
N#define RTC_ALRMBR_HU                        ((uint32_t)0x000F0000)
N#define RTC_ALRMBR_HU_0                      ((uint32_t)0x00010000)
N#define RTC_ALRMBR_HU_1                      ((uint32_t)0x00020000)
N#define RTC_ALRMBR_HU_2                      ((uint32_t)0x00040000)
N#define RTC_ALRMBR_HU_3                      ((uint32_t)0x00080000)
N#define RTC_ALRMBR_MSK2                      ((uint32_t)0x00008000)
N#define RTC_ALRMBR_MNT                       ((uint32_t)0x00007000)
N#define RTC_ALRMBR_MNT_0                     ((uint32_t)0x00001000)
N#define RTC_ALRMBR_MNT_1                     ((uint32_t)0x00002000)
N#define RTC_ALRMBR_MNT_2                     ((uint32_t)0x00004000)
N#define RTC_ALRMBR_MNU                       ((uint32_t)0x00000F00)
N#define RTC_ALRMBR_MNU_0                     ((uint32_t)0x00000100)
N#define RTC_ALRMBR_MNU_1                     ((uint32_t)0x00000200)
N#define RTC_ALRMBR_MNU_2                     ((uint32_t)0x00000400)
N#define RTC_ALRMBR_MNU_3                     ((uint32_t)0x00000800)
N#define RTC_ALRMBR_MSK1                      ((uint32_t)0x00000080)
N#define RTC_ALRMBR_ST                        ((uint32_t)0x00000070)
N#define RTC_ALRMBR_ST_0                      ((uint32_t)0x00000010)
N#define RTC_ALRMBR_ST_1                      ((uint32_t)0x00000020)
N#define RTC_ALRMBR_ST_2                      ((uint32_t)0x00000040)
N#define RTC_ALRMBR_SU                        ((uint32_t)0x0000000F)
N#define RTC_ALRMBR_SU_0                      ((uint32_t)0x00000001)
N#define RTC_ALRMBR_SU_1                      ((uint32_t)0x00000002)
N#define RTC_ALRMBR_SU_2                      ((uint32_t)0x00000004)
N#define RTC_ALRMBR_SU_3                      ((uint32_t)0x00000008)
N
N/********************  Bits definition for RTC_WPR register  ******************/
N#define RTC_WPR_KEY                          ((uint32_t)0x000000FF)
N
N/********************  Bits definition for RTC_SSR register  ******************/
N#define RTC_SSR_SS                           ((uint32_t)0x0000FFFF)
N
N/********************  Bits definition for RTC_SHIFTR register  ***************/
N#define RTC_SHIFTR_SUBFS                     ((uint32_t)0x00007FFF)
N#define RTC_SHIFTR_ADD1S                     ((uint32_t)0x80000000)
N
N/********************  Bits definition for RTC_TSTR register  *****************/
N#define RTC_TSTR_PM                          ((uint32_t)0x00400000)
N#define RTC_TSTR_HT                          ((uint32_t)0x00300000)
N#define RTC_TSTR_HT_0                        ((uint32_t)0x00100000)
N#define RTC_TSTR_HT_1                        ((uint32_t)0x00200000)
N#define RTC_TSTR_HU                          ((uint32_t)0x000F0000)
N#define RTC_TSTR_HU_0                        ((uint32_t)0x00010000)
N#define RTC_TSTR_HU_1                        ((uint32_t)0x00020000)
N#define RTC_TSTR_HU_2                        ((uint32_t)0x00040000)
N#define RTC_TSTR_HU_3                        ((uint32_t)0x00080000)
N#define RTC_TSTR_MNT                         ((uint32_t)0x00007000)
N#define RTC_TSTR_MNT_0                       ((uint32_t)0x00001000)
N#define RTC_TSTR_MNT_1                       ((uint32_t)0x00002000)
N#define RTC_TSTR_MNT_2                       ((uint32_t)0x00004000)
N#define RTC_TSTR_MNU                         ((uint32_t)0x00000F00)
N#define RTC_TSTR_MNU_0                       ((uint32_t)0x00000100)
N#define RTC_TSTR_MNU_1                       ((uint32_t)0x00000200)
N#define RTC_TSTR_MNU_2                       ((uint32_t)0x00000400)
N#define RTC_TSTR_MNU_3                       ((uint32_t)0x00000800)
N#define RTC_TSTR_ST                          ((uint32_t)0x00000070)
N#define RTC_TSTR_ST_0                        ((uint32_t)0x00000010)
N#define RTC_TSTR_ST_1                        ((uint32_t)0x00000020)
N#define RTC_TSTR_ST_2                        ((uint32_t)0x00000040)
N#define RTC_TSTR_SU                          ((uint32_t)0x0000000F)
N#define RTC_TSTR_SU_0                        ((uint32_t)0x00000001)
N#define RTC_TSTR_SU_1                        ((uint32_t)0x00000002)
N#define RTC_TSTR_SU_2                        ((uint32_t)0x00000004)
N#define RTC_TSTR_SU_3                        ((uint32_t)0x00000008)
N
N/********************  Bits definition for RTC_TSDR register  *****************/
N#define RTC_TSDR_WDU                         ((uint32_t)0x0000E000)
N#define RTC_TSDR_WDU_0                       ((uint32_t)0x00002000)
N#define RTC_TSDR_WDU_1                       ((uint32_t)0x00004000)
N#define RTC_TSDR_WDU_2                       ((uint32_t)0x00008000)
N#define RTC_TSDR_MT                          ((uint32_t)0x00001000)
N#define RTC_TSDR_MU                          ((uint32_t)0x00000F00)
N#define RTC_TSDR_MU_0                        ((uint32_t)0x00000100)
N#define RTC_TSDR_MU_1                        ((uint32_t)0x00000200)
N#define RTC_TSDR_MU_2                        ((uint32_t)0x00000400)
N#define RTC_TSDR_MU_3                        ((uint32_t)0x00000800)
N#define RTC_TSDR_DT                          ((uint32_t)0x00000030)
N#define RTC_TSDR_DT_0                        ((uint32_t)0x00000010)
N#define RTC_TSDR_DT_1                        ((uint32_t)0x00000020)
N#define RTC_TSDR_DU                          ((uint32_t)0x0000000F)
N#define RTC_TSDR_DU_0                        ((uint32_t)0x00000001)
N#define RTC_TSDR_DU_1                        ((uint32_t)0x00000002)
N#define RTC_TSDR_DU_2                        ((uint32_t)0x00000004)
N#define RTC_TSDR_DU_3                        ((uint32_t)0x00000008)
N
N/********************  Bits definition for RTC_TSSSR register  ****************/
N#define RTC_TSSSR_SS                         ((uint32_t)0x0000FFFF)
N
N/********************  Bits definition for RTC_CAL register  *****************/
N#define RTC_CALR_CALP                        ((uint32_t)0x00008000)
N#define RTC_CALR_CALW8                       ((uint32_t)0x00004000)
N#define RTC_CALR_CALW16                      ((uint32_t)0x00002000)
N#define RTC_CALR_CALM                        ((uint32_t)0x000001FF)
N#define RTC_CALR_CALM_0                      ((uint32_t)0x00000001)
N#define RTC_CALR_CALM_1                      ((uint32_t)0x00000002)
N#define RTC_CALR_CALM_2                      ((uint32_t)0x00000004)
N#define RTC_CALR_CALM_3                      ((uint32_t)0x00000008)
N#define RTC_CALR_CALM_4                      ((uint32_t)0x00000010)
N#define RTC_CALR_CALM_5                      ((uint32_t)0x00000020)
N#define RTC_CALR_CALM_6                      ((uint32_t)0x00000040)
N#define RTC_CALR_CALM_7                      ((uint32_t)0x00000080)
N#define RTC_CALR_CALM_8                      ((uint32_t)0x00000100)
N
N/********************  Bits definition for RTC_TAFCR register  ****************/
N#define RTC_TAFCR_ALARMOUTTYPE               ((uint32_t)0x00040000)
N#define RTC_TAFCR_TSINSEL                    ((uint32_t)0x00020000)
N#define RTC_TAFCR_TAMPINSEL                  ((uint32_t)0x00010000)
N#define RTC_TAFCR_TAMPPUDIS                  ((uint32_t)0x00008000)
N#define RTC_TAFCR_TAMPPRCH                   ((uint32_t)0x00006000)
N#define RTC_TAFCR_TAMPPRCH_0                 ((uint32_t)0x00002000)
N#define RTC_TAFCR_TAMPPRCH_1                 ((uint32_t)0x00004000)
N#define RTC_TAFCR_TAMPFLT                    ((uint32_t)0x00001800)
N#define RTC_TAFCR_TAMPFLT_0                  ((uint32_t)0x00000800)
N#define RTC_TAFCR_TAMPFLT_1                  ((uint32_t)0x00001000)
N#define RTC_TAFCR_TAMPFREQ                   ((uint32_t)0x00000700)
N#define RTC_TAFCR_TAMPFREQ_0                 ((uint32_t)0x00000100)
N#define RTC_TAFCR_TAMPFREQ_1                 ((uint32_t)0x00000200)
N#define RTC_TAFCR_TAMPFREQ_2                 ((uint32_t)0x00000400)
N#define RTC_TAFCR_TAMPTS                     ((uint32_t)0x00000080)
N#define RTC_TAFCR_TAMP2TRG                   ((uint32_t)0x00000010)
N#define RTC_TAFCR_TAMP2E                     ((uint32_t)0x00000008) 
N#define RTC_TAFCR_TAMPIE                     ((uint32_t)0x00000004)
N#define RTC_TAFCR_TAMP1TRG                   ((uint32_t)0x00000002)
N#define RTC_TAFCR_TAMP1E                     ((uint32_t)0x00000001)
N
N/********************  Bits definition for RTC_ALRMASSR register  *************/
N#define RTC_ALRMASSR_MASKSS                  ((uint32_t)0x0F000000)
N#define RTC_ALRMASSR_MASKSS_0                ((uint32_t)0x01000000)
N#define RTC_ALRMASSR_MASKSS_1                ((uint32_t)0x02000000)
N#define RTC_ALRMASSR_MASKSS_2                ((uint32_t)0x04000000)
N#define RTC_ALRMASSR_MASKSS_3                ((uint32_t)0x08000000)
N#define RTC_ALRMASSR_SS                      ((uint32_t)0x00007FFF)
N
N/********************  Bits definition for RTC_ALRMBSSR register  *************/
N#define RTC_ALRMBSSR_MASKSS                  ((uint32_t)0x0F000000)
N#define RTC_ALRMBSSR_MASKSS_0                ((uint32_t)0x01000000)
N#define RTC_ALRMBSSR_MASKSS_1                ((uint32_t)0x02000000)
N#define RTC_ALRMBSSR_MASKSS_2                ((uint32_t)0x04000000)
N#define RTC_ALRMBSSR_MASKSS_3                ((uint32_t)0x08000000)
N#define RTC_ALRMBSSR_SS                      ((uint32_t)0x00007FFF)
N
N/********************  Bits definition for RTC_BKP0R register  ****************/
N#define RTC_BKP0R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP1R register  ****************/
N#define RTC_BKP1R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP2R register  ****************/
N#define RTC_BKP2R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP3R register  ****************/
N#define RTC_BKP3R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP4R register  ****************/
N#define RTC_BKP4R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP5R register  ****************/
N#define RTC_BKP5R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP6R register  ****************/
N#define RTC_BKP6R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP7R register  ****************/
N#define RTC_BKP7R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP8R register  ****************/
N#define RTC_BKP8R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP9R register  ****************/
N#define RTC_BKP9R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP10R register  ***************/
N#define RTC_BKP10R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP11R register  ***************/
N#define RTC_BKP11R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP12R register  ***************/
N#define RTC_BKP12R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP13R register  ***************/
N#define RTC_BKP13R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP14R register  ***************/
N#define RTC_BKP14R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP15R register  ***************/
N#define RTC_BKP15R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP16R register  ***************/
N#define RTC_BKP16R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP17R register  ***************/
N#define RTC_BKP17R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP18R register  ***************/
N#define RTC_BKP18R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP19R register  ***************/
N#define RTC_BKP19R                           ((uint32_t)0xFFFFFFFF)
N
N/******************************************************************************/
N/*                                                                            */
N/*                          Serial Audio Interface                            */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for SAI_GCR register  *******************/
N#define  SAI_GCR_SYNCIN                  ((uint32_t)0x00000003)        /*!<SYNCIN[1:0] bits (Synchronization Inputs)   */
N#define  SAI_GCR_SYNCIN_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  SAI_GCR_SYNCIN_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
N
N#define  SAI_GCR_SYNCOUT                 ((uint32_t)0x00000030)        /*!<SYNCOUT[1:0] bits (Synchronization Outputs) */
N#define  SAI_GCR_SYNCOUT_0               ((uint32_t)0x00000010)        /*!<Bit 0 */
N#define  SAI_GCR_SYNCOUT_1               ((uint32_t)0x00000020)        /*!<Bit 1 */
N
N/*******************  Bit definition for SAI_xCR1 register  *******************/
N#define  SAI_xCR1_MODE                    ((uint32_t)0x00000003)        /*!<MODE[1:0] bits (Audio Block Mode)           */
N#define  SAI_xCR1_MODE_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  SAI_xCR1_MODE_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
N
N#define  SAI_xCR1_PRTCFG                  ((uint32_t)0x0000000C)        /*!<PRTCFG[1:0] bits (Protocol Configuration)   */
N#define  SAI_xCR1_PRTCFG_0                ((uint32_t)0x00000004)        /*!<Bit 0 */
N#define  SAI_xCR1_PRTCFG_1                ((uint32_t)0x00000008)        /*!<Bit 1 */
N
N#define  SAI_xCR1_DS                      ((uint32_t)0x000000E0)        /*!<DS[1:0] bits (Data Size) */
N#define  SAI_xCR1_DS_0                    ((uint32_t)0x00000020)        /*!<Bit 0 */
N#define  SAI_xCR1_DS_1                    ((uint32_t)0x00000040)        /*!<Bit 1 */
N#define  SAI_xCR1_DS_2                    ((uint32_t)0x00000080)        /*!<Bit 2 */
N
N#define  SAI_xCR1_LSBFIRST                ((uint32_t)0x00000100)        /*!<LSB First Configuration  */
N#define  SAI_xCR1_CKSTR                   ((uint32_t)0x00000200)        /*!<ClocK STRobing edge      */
N
N#define  SAI_xCR1_SYNCEN                  ((uint32_t)0x00000C00)        /*!<SYNCEN[1:0](SYNChronization ENable) */
N#define  SAI_xCR1_SYNCEN_0                ((uint32_t)0x00000400)        /*!<Bit 0 */
N#define  SAI_xCR1_SYNCEN_1                ((uint32_t)0x00000800)        /*!<Bit 1 */
N
N#define  SAI_xCR1_MONO                    ((uint32_t)0x00001000)        /*!<Mono mode                  */
N#define  SAI_xCR1_OUTDRIV                 ((uint32_t)0x00002000)        /*!<Output Drive               */
N#define  SAI_xCR1_SAIEN                   ((uint32_t)0x00010000)        /*!<Audio Block enable         */
N#define  SAI_xCR1_DMAEN                   ((uint32_t)0x00020000)        /*!<DMA enable                 */
N#define  SAI_xCR1_NODIV                   ((uint32_t)0x00080000)        /*!<No Divider Configuration   */
N
N#define  SAI_xCR1_MCKDIV                  ((uint32_t)0x00780000)        /*!<MCKDIV[3:0] (Master ClocK Divider)  */
N#define  SAI_xCR1_MCKDIV_0                ((uint32_t)0x00080000)        /*!<Bit 0  */
N#define  SAI_xCR1_MCKDIV_1                ((uint32_t)0x00100000)        /*!<Bit 1  */
N#define  SAI_xCR1_MCKDIV_2                ((uint32_t)0x00200000)        /*!<Bit 2  */
N#define  SAI_xCR1_MCKDIV_3                ((uint32_t)0x00400000)        /*!<Bit 3  */
N
N/*******************  Bit definition for SAI_xCR2 register  *******************/
N#define  SAI_xCR2_FTH                     ((uint32_t)0x00000003)        /*!<FTH[1:0](Fifo THreshold)  */
N#define  SAI_xCR2_FTH_0                   ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  SAI_xCR2_FTH_1                   ((uint32_t)0x00000002)        /*!<Bit 1 */
N
N#define  SAI_xCR2_FFLUSH                  ((uint32_t)0x00000008)        /*!<Fifo FLUSH                       */
N#define  SAI_xCR2_TRIS                    ((uint32_t)0x00000010)        /*!<TRIState Management on data line */
N#define  SAI_xCR2_MUTE                    ((uint32_t)0x00000020)        /*!<Mute mode                        */
N#define  SAI_xCR2_MUTEVAL                 ((uint32_t)0x00000040)        /*!<Muate value                      */
N
N#define  SAI_xCR2_MUTECNT                  ((uint32_t)0x00001F80)       /*!<MUTECNT[5:0] (MUTE counter) */
N#define  SAI_xCR2_MUTECNT_0               ((uint32_t)0x00000080)        /*!<Bit 0 */
N#define  SAI_xCR2_MUTECNT_1               ((uint32_t)0x00000100)        /*!<Bit 1 */
N#define  SAI_xCR2_MUTECNT_2               ((uint32_t)0x00000200)        /*!<Bit 2 */
N#define  SAI_xCR2_MUTECNT_3               ((uint32_t)0x00000400)        /*!<Bit 3 */
N#define  SAI_xCR2_MUTECNT_4               ((uint32_t)0x00000800)        /*!<Bit 4 */
N#define  SAI_xCR2_MUTECNT_5               ((uint32_t)0x00001000)        /*!<Bit 5 */
N
N#define  SAI_xCR2_CPL                     ((uint32_t)0x00002000)        /*!< Complement Bit             */
N
N#define  SAI_xCR2_COMP                    ((uint32_t)0x0000C000)        /*!<COMP[1:0] (Companding mode) */
N#define  SAI_xCR2_COMP_0                  ((uint32_t)0x00004000)        /*!<Bit 0 */
N#define  SAI_xCR2_COMP_1                  ((uint32_t)0x00008000)        /*!<Bit 1 */
N
N/******************  Bit definition for SAI_xFRCR register  *******************/
N#define  SAI_xFRCR_FRL                    ((uint32_t)0x000000FF)        /*!<FRL[1:0](Frame length)  */
N#define  SAI_xFRCR_FRL_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  SAI_xFRCR_FRL_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
N#define  SAI_xFRCR_FRL_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
N#define  SAI_xFRCR_FRL_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
N#define  SAI_xFRCR_FRL_4                  ((uint32_t)0x00000010)        /*!<Bit 4 */
N#define  SAI_xFRCR_FRL_5                  ((uint32_t)0x00000020)        /*!<Bit 5 */
N#define  SAI_xFRCR_FRL_6                  ((uint32_t)0x00000040)        /*!<Bit 6 */
N#define  SAI_xFRCR_FRL_7                  ((uint32_t)0x00000080)        /*!<Bit 7 */
N
N#define  SAI_xFRCR_FSALL                  ((uint32_t)0x00007F00)        /*!<FRL[1:0] (Frame synchronization active level length)  */
N#define  SAI_xFRCR_FSALL_0                ((uint32_t)0x00000100)        /*!<Bit 0 */
N#define  SAI_xFRCR_FSALL_1                ((uint32_t)0x00000200)        /*!<Bit 1 */
N#define  SAI_xFRCR_FSALL_2                ((uint32_t)0x00000400)        /*!<Bit 2 */
N#define  SAI_xFRCR_FSALL_3                ((uint32_t)0x00000800)        /*!<Bit 3 */
N#define  SAI_xFRCR_FSALL_4                ((uint32_t)0x00001000)        /*!<Bit 4 */
N#define  SAI_xFRCR_FSALL_5                ((uint32_t)0x00002000)        /*!<Bit 5 */
N#define  SAI_xFRCR_FSALL_6                ((uint32_t)0x00004000)        /*!<Bit 6 */
N
N#define  SAI_xFRCR_FSDEF                  ((uint32_t)0x00010000)        /*!< Frame Synchronization Definition */
N#define  SAI_xFRCR_FSPOL                  ((uint32_t)0x00020000)        /*!<Frame Synchronization POLarity    */
N#define  SAI_xFRCR_FSOFF                  ((uint32_t)0x00040000)        /*!<Frame Synchronization OFFset      */
N/* Legacy defines */
N#define  SAI_xFRCR_FSPO                   SAI_xFRCR_FSPOL
N
N/******************  Bit definition for SAI_xSLOTR register  *******************/
N#define  SAI_xSLOTR_FBOFF                 ((uint32_t)0x0000001F)        /*!<FRL[4:0](First Bit Offset)  */
N#define  SAI_xSLOTR_FBOFF_0               ((uint32_t)0x00000001)        /*!<Bit 0 */
N#define  SAI_xSLOTR_FBOFF_1               ((uint32_t)0x00000002)        /*!<Bit 1 */
N#define  SAI_xSLOTR_FBOFF_2               ((uint32_t)0x00000004)        /*!<Bit 2 */
N#define  SAI_xSLOTR_FBOFF_3               ((uint32_t)0x00000008)        /*!<Bit 3 */
N#define  SAI_xSLOTR_FBOFF_4               ((uint32_t)0x00000010)        /*!<Bit 4 */
N                                     
N#define  SAI_xSLOTR_SLOTSZ                ((uint32_t)0x000000C0)        /*!<SLOTSZ[1:0] (Slot size)  */
N#define  SAI_xSLOTR_SLOTSZ_0              ((uint32_t)0x00000040)        /*!<Bit 0 */
N#define  SAI_xSLOTR_SLOTSZ_1              ((uint32_t)0x00000080)        /*!<Bit 1 */
N
N#define  SAI_xSLOTR_NBSLOT                ((uint32_t)0x00000F00)        /*!<NBSLOT[3:0] (Number of Slot in audio Frame)  */
N#define  SAI_xSLOTR_NBSLOT_0              ((uint32_t)0x00000100)        /*!<Bit 0 */
N#define  SAI_xSLOTR_NBSLOT_1              ((uint32_t)0x00000200)        /*!<Bit 1 */
N#define  SAI_xSLOTR_NBSLOT_2              ((uint32_t)0x00000400)        /*!<Bit 2 */
N#define  SAI_xSLOTR_NBSLOT_3              ((uint32_t)0x00000800)        /*!<Bit 3 */
N
N#define  SAI_xSLOTR_SLOTEN                ((uint32_t)0xFFFF0000)        /*!<SLOTEN[15:0] (Slot Enable)  */
N
N/*******************  Bit definition for SAI_xIMR register  *******************/
N#define  SAI_xIMR_OVRUDRIE                ((uint32_t)0x00000001)        /*!<Overrun underrun interrupt enable                              */
N#define  SAI_xIMR_MUTEDETIE               ((uint32_t)0x00000002)        /*!<Mute detection interrupt enable                                */
N#define  SAI_xIMR_WCKCFGIE                ((uint32_t)0x00000004)        /*!<Wrong Clock Configuration interrupt enable                     */
N#define  SAI_xIMR_FREQIE                  ((uint32_t)0x00000008)        /*!<FIFO request interrupt enable                                  */
N#define  SAI_xIMR_CNRDYIE                 ((uint32_t)0x00000010)        /*!<Codec not ready interrupt enable                               */
N#define  SAI_xIMR_AFSDETIE                ((uint32_t)0x00000020)        /*!<Anticipated frame synchronization detection interrupt enable   */
N#define  SAI_xIMR_LFSDETIE                ((uint32_t)0x00000040)        /*!<Late frame synchronization detection interrupt enable          */
N
N/********************  Bit definition for SAI_xSR register  *******************/
N#define  SAI_xSR_OVRUDR                   ((uint32_t)0x00000001)         /*!<Overrun underrun                               */
N#define  SAI_xSR_MUTEDET                  ((uint32_t)0x00000002)         /*!<Mute detection                                 */
N#define  SAI_xSR_WCKCFG                   ((uint32_t)0x00000004)         /*!<Wrong Clock Configuration                      */
N#define  SAI_xSR_FREQ                     ((uint32_t)0x00000008)         /*!<FIFO request                                   */
N#define  SAI_xSR_CNRDY                    ((uint32_t)0x00000010)         /*!<Codec not ready                                */
N#define  SAI_xSR_AFSDET                   ((uint32_t)0x00000020)         /*!<Anticipated frame synchronization detection    */
N#define  SAI_xSR_LFSDET                   ((uint32_t)0x00000040)         /*!<Late frame synchronization detection           */
N
N#define  SAI_xSR_FLVL                     ((uint32_t)0x00070000)         /*!<FLVL[2:0] (FIFO Level Threshold)               */
N#define  SAI_xSR_FLVL_0                   ((uint32_t)0x00010000)         /*!<Bit 0 */
N#define  SAI_xSR_FLVL_1                   ((uint32_t)0x00020000)         /*!<Bit 1 */
N#define  SAI_xSR_FLVL_2                   ((uint32_t)0x00030000)         /*!<Bit 2 */
N
N/******************  Bit definition for SAI_xCLRFR register  ******************/
N#define  SAI_xCLRFR_COVRUDR               ((uint32_t)0x00000001)        /*!<Clear Overrun underrun                               */
N#define  SAI_xCLRFR_CMUTEDET              ((uint32_t)0x00000002)        /*!<Clear Mute detection                                 */
N#define  SAI_xCLRFR_CWCKCFG               ((uint32_t)0x00000004)        /*!<Clear Wrong Clock Configuration                      */
N#define  SAI_xCLRFR_CFREQ                 ((uint32_t)0x00000008)        /*!<Clear FIFO request                                   */
N#define  SAI_xCLRFR_CCNRDY                ((uint32_t)0x00000010)        /*!<Clear Codec not ready                                */
N#define  SAI_xCLRFR_CAFSDET               ((uint32_t)0x00000020)        /*!<Clear Anticipated frame synchronization detection    */
N#define  SAI_xCLRFR_CLFSDET               ((uint32_t)0x00000040)        /*!<Clear Late frame synchronization detection           */
N
N/******************  Bit definition for SAI_xDR register  ******************/
N#define  SAI_xDR_DATA                     ((uint32_t)0xFFFFFFFF)        
N
N#if defined(STM32F446xx)
X#if 0L
S/******************************************************************************/
S/*                                                                            */
S/*                              SPDIF-RX Interface                            */
S/*                                                                            */
S/******************************************************************************/
S/********************  Bit definition for SPDIFRX_CR register  *******************/
S#define  SPDIFRX_CR_SPDIFEN                  ((uint32_t)0x00000003)        /*!<Peripheral Block Enable                      */
S#define  SPDIFRX_CR_RXDMAEN                  ((uint32_t)0x00000004)        /*!<Receiver DMA Enable for data flow            */
S#define  SPDIFRX_CR_RXSTEO                   ((uint32_t)0x00000008)        /*!<Stereo Mode                                  */
S#define  SPDIFRX_CR_DRFMT                    ((uint32_t)0x00000030)        /*!<RX Data format                               */
S#define  SPDIFRX_CR_PMSK                     ((uint32_t)0x00000040)        /*!<Mask Parity error bit                        */
S#define  SPDIFRX_CR_VMSK                     ((uint32_t)0x00000080)        /*!<Mask of Validity bit                         */
S#define  SPDIFRX_CR_CUMSK                    ((uint32_t)0x00000100)        /*!<Mask of channel status and user bits         */
S#define  SPDIFRX_CR_PTMSK                    ((uint32_t)0x00000200)        /*!<Mask of Preamble Type bits                   */
S#define  SPDIFRX_CR_CBDMAEN                  ((uint32_t)0x00000400)        /*!<Control Buffer DMA ENable for control flow   */
S#define  SPDIFRX_CR_CHSEL                    ((uint32_t)0x00000800)        /*!<Channel Selection                            */
S#define  SPDIFRX_CR_NBTR                     ((uint32_t)0x00003000)        /*!<Maximum allowed re-tries during synchronization phase */
S#define  SPDIFRX_CR_WFA                      ((uint32_t)0x00004000)        /*!<Wait For Activity     */
S#define  SPDIFRX_CR_INSEL                    ((uint32_t)0x00070000)        /*!<SPDIFRX input selection */
S
S/*******************  Bit definition for SPDIFRX_IMR register  *******************/
S#define  SPDIFRX_IMR_RXNEIE                   ((uint32_t)0x00000001)        /*!<RXNE interrupt enable                              */
S#define  SPDIFRX_IMR_CSRNEIE                  ((uint32_t)0x00000002)        /*!<Control Buffer Ready Interrupt Enable              */
S#define  SPDIFRX_IMR_PERRIE                   ((uint32_t)0x00000004)        /*!<Parity error interrupt enable                      */
S#define  SPDIFRX_IMR_OVRIE                    ((uint32_t)0x00000008)        /*!<Overrun error Interrupt Enable                     */
S#define  SPDIFRX_IMR_SBLKIE                   ((uint32_t)0x00000010)        /*!<Synchronization Block Detected Interrupt Enable    */
S#define  SPDIFRX_IMR_SYNCDIE                  ((uint32_t)0x00000020)        /*!<Synchronization Done                               */
S#define  SPDIFRX_IMR_IFEIE                    ((uint32_t)0x00000040)        /*!<Serial Interface Error Interrupt Enable            */
S
S/*******************  Bit definition for SPDIFRX_SR register  *******************/
S#define  SPDIFRX_SR_RXNE                   ((uint32_t)0x00000001)       /*!<Read data register not empty                          */
S#define  SPDIFRX_SR_CSRNE                  ((uint32_t)0x00000002)       /*!<The Control Buffer register is not empty              */
S#define  SPDIFRX_SR_PERR                   ((uint32_t)0x00000004)       /*!<Parity error                                          */
S#define  SPDIFRX_SR_OVR                    ((uint32_t)0x00000008)       /*!<Overrun error                                         */
S#define  SPDIFRX_SR_SBD                    ((uint32_t)0x00000010)       /*!<Synchronization Block Detected                        */
S#define  SPDIFRX_SR_SYNCD                  ((uint32_t)0x00000020)       /*!<Synchronization Done                                  */
S#define  SPDIFRX_SR_FERR                   ((uint32_t)0x00000040)       /*!<Framing error                                         */
S#define  SPDIFRX_SR_SERR                   ((uint32_t)0x00000080)       /*!<Synchronization error                                 */
S#define  SPDIFRX_SR_TERR                   ((uint32_t)0x00000100)       /*!<Time-out error                                        */
S#define  SPDIFRX_SR_WIDTH5                 ((uint32_t)0x7FFF0000)       /*!<Duration of 5 symbols counted with SPDIFRX_clk        */
S
S/*******************  Bit definition for SPDIFRX_IFCR register  *******************/
S#define  SPDIFRX_IFCR_PERRCF               ((uint32_t)0x00000004)       /*!<Clears the Parity error flag                         */
S#define  SPDIFRX_IFCR_OVRCF                ((uint32_t)0x00000008)       /*!<Clears the Overrun error flag                        */
S#define  SPDIFRX_IFCR_SBDCF                ((uint32_t)0x00000010)       /*!<Clears the Synchronization Block Detected flag       */
S#define  SPDIFRX_IFCR_SYNCDCF              ((uint32_t)0x00000020)       /*!<Clears the Synchronization Done flag                 */
S
S/*******************  Bit definition for SPDIFRX_DR register  (DRFMT = 0b00 case) *******************/
S#define  SPDIFRX_DR0_DR                    ((uint32_t)0x00FFFFFF)        /*!<Data value            */
S#define  SPDIFRX_DR0_PE                    ((uint32_t)0x01000000)        /*!<Parity Error bit      */
S#define  SPDIFRX_DR0_V                     ((uint32_t)0x02000000)        /*!<Validity bit          */
S#define  SPDIFRX_DR0_U                     ((uint32_t)0x04000000)        /*!<User bit              */
S#define  SPDIFRX_DR0_C                     ((uint32_t)0x08000000)        /*!<Channel Status bit    */
S#define  SPDIFRX_DR0_PT                    ((uint32_t)0x30000000)        /*!<Preamble Type         */
S
S/*******************  Bit definition for SPDIFRX_DR register  (DRFMT = 0b01 case) *******************/
S#define  SPDIFRX_DR1_DR                    ((uint32_t)0xFFFFFF00)        /*!<Data value            */
S#define  SPDIFRX_DR1_PT                    ((uint32_t)0x00000030)        /*!<Preamble Type         */
S#define  SPDIFRX_DR1_C                     ((uint32_t)0x00000008)        /*!<Channel Status bit    */
S#define  SPDIFRX_DR1_U                     ((uint32_t)0x00000004)        /*!<User bit              */
S#define  SPDIFRX_DR1_V                     ((uint32_t)0x00000002)        /*!<Validity bit          */
S#define  SPDIFRX_DR1_PE                    ((uint32_t)0x00000001)        /*!<Parity Error bit      */
S
S/*******************  Bit definition for SPDIFRX_DR register  (DRFMT = 0b10 case) *******************/
S#define  SPDIFRX_DR1_DRNL1                 ((uint32_t)0xFFFF0000)        /*!<Data value Channel B      */
S#define  SPDIFRX_DR1_DRNL2                 ((uint32_t)0x0000FFFF)        /*!<Data value Channel A      */
S
S/*******************  Bit definition for SPDIFRX_CSR register   *******************/
S#define  SPDIFRX_CSR_USR                     ((uint32_t)0x0000FFFF)        /*!<User data information           */
S#define  SPDIFRX_CSR_CS                      ((uint32_t)0x00FF0000)        /*!<Channel A status information    */
S#define  SPDIFRX_CSR_SOB                     ((uint32_t)0x01000000)        /*!<Start Of Block                  */
S
S/*******************  Bit definition for SPDIFRX_DIR register    *******************/
S#define  SPDIFRX_DIR_THI                 ((uint32_t)0x000013FF)        /*!<Threshold LOW      */
S#define  SPDIFRX_DIR_TLO                 ((uint32_t)0x1FFF0000)        /*!<Threshold HIGH     */
N#endif /* STM32F446xx */
N
N/******************************************************************************/
N/*                                                                            */
N/*                          SD host Interface                                 */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bit definition for SDIO_POWER register  ******************/
N#define  SDIO_POWER_PWRCTRL                  ((uint8_t)0x03)               /*!<PWRCTRL[1:0] bits (Power supply control bits) */
N#define  SDIO_POWER_PWRCTRL_0                ((uint8_t)0x01)               /*!<Bit 0 */
N#define  SDIO_POWER_PWRCTRL_1                ((uint8_t)0x02)               /*!<Bit 1 */
N
N/******************  Bit definition for SDIO_CLKCR register  ******************/
N#define  SDIO_CLKCR_CLKDIV                   ((uint16_t)0x00FF)            /*!<Clock divide factor             */
N#define  SDIO_CLKCR_CLKEN                    ((uint16_t)0x0100)            /*!<Clock enable bit                */
N#define  SDIO_CLKCR_PWRSAV                   ((uint16_t)0x0200)            /*!<Power saving configuration bit  */
N#define  SDIO_CLKCR_BYPASS                   ((uint16_t)0x0400)            /*!<Clock divider bypass enable bit */
N
N#define  SDIO_CLKCR_WIDBUS                   ((uint16_t)0x1800)            /*!<WIDBUS[1:0] bits (Wide bus mode enable bit) */
N#define  SDIO_CLKCR_WIDBUS_0                 ((uint16_t)0x0800)            /*!<Bit 0 */
N#define  SDIO_CLKCR_WIDBUS_1                 ((uint16_t)0x1000)            /*!<Bit 1 */
N
N#define  SDIO_CLKCR_NEGEDGE                  ((uint16_t)0x2000)            /*!<SDIO_CK dephasing selection bit */
N#define  SDIO_CLKCR_HWFC_EN                  ((uint16_t)0x4000)            /*!<HW Flow Control enable          */
N
N/*******************  Bit definition for SDIO_ARG register  *******************/
N#define  SDIO_ARG_CMDARG                     ((uint32_t)0xFFFFFFFF)            /*!<Command argument */
N
N/*******************  Bit definition for SDIO_CMD register  *******************/
N#define  SDIO_CMD_CMDINDEX                   ((uint16_t)0x003F)            /*!<Command Index                               */
N
N#define  SDIO_CMD_WAITRESP                   ((uint16_t)0x00C0)            /*!<WAITRESP[1:0] bits (Wait for response bits) */
N#define  SDIO_CMD_WAITRESP_0                 ((uint16_t)0x0040)            /*!< Bit 0 */
N#define  SDIO_CMD_WAITRESP_1                 ((uint16_t)0x0080)            /*!< Bit 1 */
N
N#define  SDIO_CMD_WAITINT                    ((uint16_t)0x0100)            /*!<CPSM Waits for Interrupt Request                               */
N#define  SDIO_CMD_WAITPEND                   ((uint16_t)0x0200)            /*!<CPSM Waits for ends of data transfer (CmdPend internal signal) */
N#define  SDIO_CMD_CPSMEN                     ((uint16_t)0x0400)            /*!<Command path state machine (CPSM) Enable bit                   */
N#define  SDIO_CMD_SDIOSUSPEND                ((uint16_t)0x0800)            /*!<SD I/O suspend command                                         */
N#define  SDIO_CMD_ENCMDCOMPL                 ((uint16_t)0x1000)            /*!<Enable CMD completion                                          */
N#define  SDIO_CMD_NIEN                       ((uint16_t)0x2000)            /*!<Not Interrupt Enable */
N#define  SDIO_CMD_CEATACMD                   ((uint16_t)0x4000)            /*!<CE-ATA command       */
N
N/*****************  Bit definition for SDIO_RESPCMD register  *****************/
N#define  SDIO_RESPCMD_RESPCMD                ((uint8_t)0x3F)               /*!<Response command index */
N
N/******************  Bit definition for SDIO_RESP0 register  ******************/
N#define  SDIO_RESP0_CARDSTATUS0              ((uint32_t)0xFFFFFFFF)        /*!<Card Status */
N
N/******************  Bit definition for SDIO_RESP1 register  ******************/
N#define  SDIO_RESP1_CARDSTATUS1              ((uint32_t)0xFFFFFFFF)        /*!<Card Status */
N
N/******************  Bit definition for SDIO_RESP2 register  ******************/
N#define  SDIO_RESP2_CARDSTATUS2              ((uint32_t)0xFFFFFFFF)        /*!<Card Status */
N
N/******************  Bit definition for SDIO_RESP3 register  ******************/
N#define  SDIO_RESP3_CARDSTATUS3              ((uint32_t)0xFFFFFFFF)        /*!<Card Status */
N
N/******************  Bit definition for SDIO_RESP4 register  ******************/
N#define  SDIO_RESP4_CARDSTATUS4              ((uint32_t)0xFFFFFFFF)        /*!<Card Status */
N
N/******************  Bit definition for SDIO_DTIMER register  *****************/
N#define  SDIO_DTIMER_DATATIME                ((uint32_t)0xFFFFFFFF)        /*!<Data timeout period. */
N
N/******************  Bit definition for SDIO_DLEN register  *******************/
N#define  SDIO_DLEN_DATALENGTH                ((uint32_t)0x01FFFFFF)        /*!<Data length value    */
N
N/******************  Bit definition for SDIO_DCTRL register  ******************/
N#define  SDIO_DCTRL_DTEN                     ((uint16_t)0x0001)            /*!<Data transfer enabled bit         */
N#define  SDIO_DCTRL_DTDIR                    ((uint16_t)0x0002)            /*!<Data transfer direction selection */
N#define  SDIO_DCTRL_DTMODE                   ((uint16_t)0x0004)            /*!<Data transfer mode selection      */
N#define  SDIO_DCTRL_DMAEN                    ((uint16_t)0x0008)            /*!<DMA enabled bit                   */
N
N#define  SDIO_DCTRL_DBLOCKSIZE               ((uint16_t)0x00F0)            /*!<DBLOCKSIZE[3:0] bits (Data block size) */
N#define  SDIO_DCTRL_DBLOCKSIZE_0             ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  SDIO_DCTRL_DBLOCKSIZE_1             ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  SDIO_DCTRL_DBLOCKSIZE_2             ((uint16_t)0x0040)            /*!<Bit 2 */
N#define  SDIO_DCTRL_DBLOCKSIZE_3             ((uint16_t)0x0080)            /*!<Bit 3 */
N
N#define  SDIO_DCTRL_RWSTART                  ((uint16_t)0x0100)            /*!<Read wait start         */
N#define  SDIO_DCTRL_RWSTOP                   ((uint16_t)0x0200)            /*!<Read wait stop          */
N#define  SDIO_DCTRL_RWMOD                    ((uint16_t)0x0400)            /*!<Read wait mode          */
N#define  SDIO_DCTRL_SDIOEN                   ((uint16_t)0x0800)            /*!<SD I/O enable functions */
N
N/******************  Bit definition for SDIO_DCOUNT register  *****************/
N#define  SDIO_DCOUNT_DATACOUNT               ((uint32_t)0x01FFFFFF)        /*!<Data count value */
N
N/******************  Bit definition for SDIO_STA register  ********************/
N#define  SDIO_STA_CCRCFAIL                   ((uint32_t)0x00000001)        /*!<Command response received (CRC check failed)  */
N#define  SDIO_STA_DCRCFAIL                   ((uint32_t)0x00000002)        /*!<Data block sent/received (CRC check failed)   */
N#define  SDIO_STA_CTIMEOUT                   ((uint32_t)0x00000004)        /*!<Command response timeout                      */
N#define  SDIO_STA_DTIMEOUT                   ((uint32_t)0x00000008)        /*!<Data timeout                                  */
N#define  SDIO_STA_TXUNDERR                   ((uint32_t)0x00000010)        /*!<Transmit FIFO underrun error                  */
N#define  SDIO_STA_RXOVERR                    ((uint32_t)0x00000020)        /*!<Received FIFO overrun error                   */
N#define  SDIO_STA_CMDREND                    ((uint32_t)0x00000040)        /*!<Command response received (CRC check passed)  */
N#define  SDIO_STA_CMDSENT                    ((uint32_t)0x00000080)        /*!<Command sent (no response required)           */
N#define  SDIO_STA_DATAEND                    ((uint32_t)0x00000100)        /*!<Data end (data counter, SDIDCOUNT, is zero)   */
N#define  SDIO_STA_STBITERR                   ((uint32_t)0x00000200)        /*!<Start bit not detected on all data signals in wide bus mode */
N#define  SDIO_STA_DBCKEND                    ((uint32_t)0x00000400)        /*!<Data block sent/received (CRC check passed)   */
N#define  SDIO_STA_CMDACT                     ((uint32_t)0x00000800)        /*!<Command transfer in progress                  */
N#define  SDIO_STA_TXACT                      ((uint32_t)0x00001000)        /*!<Data transmit in progress                     */
N#define  SDIO_STA_RXACT                      ((uint32_t)0x00002000)        /*!<Data receive in progress                      */
N#define  SDIO_STA_TXFIFOHE                   ((uint32_t)0x00004000)        /*!<Transmit FIFO Half Empty: at least 8 words can be written into the FIFO */
N#define  SDIO_STA_RXFIFOHF                   ((uint32_t)0x00008000)        /*!<Receive FIFO Half Full: there are at least 8 words in the FIFO */
N#define  SDIO_STA_TXFIFOF                    ((uint32_t)0x00010000)        /*!<Transmit FIFO full                            */
N#define  SDIO_STA_RXFIFOF                    ((uint32_t)0x00020000)        /*!<Receive FIFO full                             */
N#define  SDIO_STA_TXFIFOE                    ((uint32_t)0x00040000)        /*!<Transmit FIFO empty                           */
N#define  SDIO_STA_RXFIFOE                    ((uint32_t)0x00080000)        /*!<Receive FIFO empty                            */
N#define  SDIO_STA_TXDAVL                     ((uint32_t)0x00100000)        /*!<Data available in transmit FIFO               */
N#define  SDIO_STA_RXDAVL                     ((uint32_t)0x00200000)        /*!<Data available in receive FIFO                */
N#define  SDIO_STA_SDIOIT                     ((uint32_t)0x00400000)        /*!<SDIO interrupt received                       */
N#define  SDIO_STA_CEATAEND                   ((uint32_t)0x00800000)        /*!<CE-ATA command completion signal received for CMD61 */
N
N/*******************  Bit definition for SDIO_ICR register  *******************/
N#define  SDIO_ICR_CCRCFAILC                  ((uint32_t)0x00000001)        /*!<CCRCFAIL flag clear bit */
N#define  SDIO_ICR_DCRCFAILC                  ((uint32_t)0x00000002)        /*!<DCRCFAIL flag clear bit */
N#define  SDIO_ICR_CTIMEOUTC                  ((uint32_t)0x00000004)        /*!<CTIMEOUT flag clear bit */
N#define  SDIO_ICR_DTIMEOUTC                  ((uint32_t)0x00000008)        /*!<DTIMEOUT flag clear bit */
N#define  SDIO_ICR_TXUNDERRC                  ((uint32_t)0x00000010)        /*!<TXUNDERR flag clear bit */
N#define  SDIO_ICR_RXOVERRC                   ((uint32_t)0x00000020)        /*!<RXOVERR flag clear bit  */
N#define  SDIO_ICR_CMDRENDC                   ((uint32_t)0x00000040)        /*!<CMDREND flag clear bit  */
N#define  SDIO_ICR_CMDSENTC                   ((uint32_t)0x00000080)        /*!<CMDSENT flag clear bit  */
N#define  SDIO_ICR_DATAENDC                   ((uint32_t)0x00000100)        /*!<DATAEND flag clear bit  */
N#define  SDIO_ICR_STBITERRC                  ((uint32_t)0x00000200)        /*!<STBITERR flag clear bit */
N#define  SDIO_ICR_DBCKENDC                   ((uint32_t)0x00000400)        /*!<DBCKEND flag clear bit  */
N#define  SDIO_ICR_SDIOITC                    ((uint32_t)0x00400000)        /*!<SDIOIT flag clear bit   */
N#define  SDIO_ICR_CEATAENDC                  ((uint32_t)0x00800000)        /*!<CEATAEND flag clear bit */
N
N/******************  Bit definition for SDIO_MASK register  *******************/
N#define  SDIO_MASK_CCRCFAILIE                ((uint32_t)0x00000001)        /*!<Command CRC Fail Interrupt Enable          */
N#define  SDIO_MASK_DCRCFAILIE                ((uint32_t)0x00000002)        /*!<Data CRC Fail Interrupt Enable             */
N#define  SDIO_MASK_CTIMEOUTIE                ((uint32_t)0x00000004)        /*!<Command TimeOut Interrupt Enable           */
N#define  SDIO_MASK_DTIMEOUTIE                ((uint32_t)0x00000008)        /*!<Data TimeOut Interrupt Enable              */
N#define  SDIO_MASK_TXUNDERRIE                ((uint32_t)0x00000010)        /*!<Tx FIFO UnderRun Error Interrupt Enable    */
N#define  SDIO_MASK_RXOVERRIE                 ((uint32_t)0x00000020)        /*!<Rx FIFO OverRun Error Interrupt Enable     */
N#define  SDIO_MASK_CMDRENDIE                 ((uint32_t)0x00000040)        /*!<Command Response Received Interrupt Enable */
N#define  SDIO_MASK_CMDSENTIE                 ((uint32_t)0x00000080)        /*!<Command Sent Interrupt Enable              */
N#define  SDIO_MASK_DATAENDIE                 ((uint32_t)0x00000100)        /*!<Data End Interrupt Enable                  */
N#define  SDIO_MASK_STBITERRIE                ((uint32_t)0x00000200)        /*!<Start Bit Error Interrupt Enable           */
N#define  SDIO_MASK_DBCKENDIE                 ((uint32_t)0x00000400)        /*!<Data Block End Interrupt Enable            */
N#define  SDIO_MASK_CMDACTIE                  ((uint32_t)0x00000800)        /*!<CCommand Acting Interrupt Enable           */
N#define  SDIO_MASK_TXACTIE                   ((uint32_t)0x00001000)        /*!<Data Transmit Acting Interrupt Enable      */
N#define  SDIO_MASK_RXACTIE                   ((uint32_t)0x00002000)        /*!<Data receive acting interrupt enabled      */
N#define  SDIO_MASK_TXFIFOHEIE                ((uint32_t)0x00004000)        /*!<Tx FIFO Half Empty interrupt Enable        */
N#define  SDIO_MASK_RXFIFOHFIE                ((uint32_t)0x00008000)        /*!<Rx FIFO Half Full interrupt Enable         */
N#define  SDIO_MASK_TXFIFOFIE                 ((uint32_t)0x00010000)        /*!<Tx FIFO Full interrupt Enable              */
N#define  SDIO_MASK_RXFIFOFIE                 ((uint32_t)0x00020000)        /*!<Rx FIFO Full interrupt Enable              */
N#define  SDIO_MASK_TXFIFOEIE                 ((uint32_t)0x00040000)        /*!<Tx FIFO Empty interrupt Enable             */
N#define  SDIO_MASK_RXFIFOEIE                 ((uint32_t)0x00080000)        /*!<Rx FIFO Empty interrupt Enable             */
N#define  SDIO_MASK_TXDAVLIE                  ((uint32_t)0x00100000)        /*!<Data available in Tx FIFO interrupt Enable */
N#define  SDIO_MASK_RXDAVLIE                  ((uint32_t)0x00200000)        /*!<Data available in Rx FIFO interrupt Enable */
N#define  SDIO_MASK_SDIOITIE                  ((uint32_t)0x00400000)        /*!<SDIO Mode Interrupt Received interrupt Enable */
N#define  SDIO_MASK_CEATAENDIE                ((uint32_t)0x00800000)        /*!<CE-ATA command completion signal received Interrupt Enable */
N
N/*****************  Bit definition for SDIO_FIFOCNT register  *****************/
N#define  SDIO_FIFOCNT_FIFOCOUNT              ((uint32_t)0x00FFFFFF)        /*!<Remaining number of words to be written to or read from the FIFO */
N
N/******************  Bit definition for SDIO_FIFO register  *******************/
N#define  SDIO_FIFO_FIFODATA                  ((uint32_t)0xFFFFFFFF)        /*!<Receive and transmit FIFO data */
N
N/******************************************************************************/
N/*                                                                            */
N/*                        Serial Peripheral Interface                         */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for SPI_CR1 register  ********************/
N#define  SPI_CR1_CPHA                        ((uint16_t)0x0001)            /*!<Clock Phase      */
N#define  SPI_CR1_CPOL                        ((uint16_t)0x0002)            /*!<Clock Polarity   */
N#define  SPI_CR1_MSTR                        ((uint16_t)0x0004)            /*!<Master Selection */
N
N#define  SPI_CR1_BR                          ((uint16_t)0x0038)            /*!<BR[2:0] bits (Baud Rate Control) */
N#define  SPI_CR1_BR_0                        ((uint16_t)0x0008)            /*!<Bit 0 */
N#define  SPI_CR1_BR_1                        ((uint16_t)0x0010)            /*!<Bit 1 */
N#define  SPI_CR1_BR_2                        ((uint16_t)0x0020)            /*!<Bit 2 */
N
N#define  SPI_CR1_SPE                         ((uint16_t)0x0040)            /*!<SPI Enable                          */
N#define  SPI_CR1_LSBFIRST                    ((uint16_t)0x0080)            /*!<Frame Format                        */
N#define  SPI_CR1_SSI                         ((uint16_t)0x0100)            /*!<Internal slave select               */
N#define  SPI_CR1_SSM                         ((uint16_t)0x0200)            /*!<Software slave management           */
N#define  SPI_CR1_RXONLY                      ((uint16_t)0x0400)            /*!<Receive only                        */
N#define  SPI_CR1_DFF                         ((uint16_t)0x0800)            /*!<Data Frame Format                   */
N#define  SPI_CR1_CRCNEXT                     ((uint16_t)0x1000)            /*!<Transmit CRC next                   */
N#define  SPI_CR1_CRCEN                       ((uint16_t)0x2000)            /*!<Hardware CRC calculation enable     */
N#define  SPI_CR1_BIDIOE                      ((uint16_t)0x4000)            /*!<Output enable in bidirectional mode */
N#define  SPI_CR1_BIDIMODE                    ((uint16_t)0x8000)            /*!<Bidirectional data mode enable      */
N
N/*******************  Bit definition for SPI_CR2 register  ********************/
N#define  SPI_CR2_RXDMAEN                     ((uint8_t)0x01)               /*!<Rx Buffer DMA Enable                 */
N#define  SPI_CR2_TXDMAEN                     ((uint8_t)0x02)               /*!<Tx Buffer DMA Enable                 */
N#define  SPI_CR2_SSOE                        ((uint8_t)0x04)               /*!<SS Output Enable                     */
N#define  SPI_CR2_ERRIE                       ((uint8_t)0x20)               /*!<Error Interrupt Enable               */
N#define  SPI_CR2_RXNEIE                      ((uint8_t)0x40)               /*!<RX buffer Not Empty Interrupt Enable */
N#define  SPI_CR2_TXEIE                       ((uint8_t)0x80)               /*!<Tx buffer Empty Interrupt Enable     */
N
N/********************  Bit definition for SPI_SR register  ********************/
N#define  SPI_SR_RXNE                         ((uint8_t)0x01)               /*!<Receive buffer Not Empty */
N#define  SPI_SR_TXE                          ((uint8_t)0x02)               /*!<Transmit buffer Empty    */
N#define  SPI_SR_CHSIDE                       ((uint8_t)0x04)               /*!<Channel side             */
N#define  SPI_SR_UDR                          ((uint8_t)0x08)               /*!<Underrun flag            */
N#define  SPI_SR_CRCERR                       ((uint8_t)0x10)               /*!<CRC Error flag           */
N#define  SPI_SR_MODF                         ((uint8_t)0x20)               /*!<Mode fault               */
N#define  SPI_SR_OVR                          ((uint8_t)0x40)               /*!<Overrun flag             */
N#define  SPI_SR_BSY                          ((uint8_t)0x80)               /*!<Busy flag                */
N
N/********************  Bit definition for SPI_DR register  ********************/
N#define  SPI_DR_DR                           ((uint16_t)0xFFFF)            /*!<Data Register           */
N
N/*******************  Bit definition for SPI_CRCPR register  ******************/
N#define  SPI_CRCPR_CRCPOLY                   ((uint16_t)0xFFFF)            /*!<CRC polynomial register */
N
N/******************  Bit definition for SPI_RXCRCR register  ******************/
N#define  SPI_RXCRCR_RXCRC                    ((uint16_t)0xFFFF)            /*!<Rx CRC Register         */
N
N/******************  Bit definition for SPI_TXCRCR register  ******************/
N#define  SPI_TXCRCR_TXCRC                    ((uint16_t)0xFFFF)            /*!<Tx CRC Register         */
N
N/******************  Bit definition for SPI_I2SCFGR register  *****************/
N#define  SPI_I2SCFGR_CHLEN                   ((uint16_t)0x0001)            /*!<Channel length (number of bits per audio channel) */
N
N#define  SPI_I2SCFGR_DATLEN                  ((uint16_t)0x0006)            /*!<DATLEN[1:0] bits (Data length to be transferred)  */
N#define  SPI_I2SCFGR_DATLEN_0                ((uint16_t)0x0002)            /*!<Bit 0 */
N#define  SPI_I2SCFGR_DATLEN_1                ((uint16_t)0x0004)            /*!<Bit 1 */
N
N#define  SPI_I2SCFGR_CKPOL                   ((uint16_t)0x0008)            /*!<steady state clock polarity               */
N
N#define  SPI_I2SCFGR_I2SSTD                  ((uint16_t)0x0030)            /*!<I2SSTD[1:0] bits (I2S standard selection) */
N#define  SPI_I2SCFGR_I2SSTD_0                ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  SPI_I2SCFGR_I2SSTD_1                ((uint16_t)0x0020)            /*!<Bit 1 */
N
N#define  SPI_I2SCFGR_PCMSYNC                 ((uint16_t)0x0080)            /*!<PCM frame synchronization                 */
N
N#define  SPI_I2SCFGR_I2SCFG                  ((uint16_t)0x0300)            /*!<I2SCFG[1:0] bits (I2S configuration mode) */
N#define  SPI_I2SCFGR_I2SCFG_0                ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  SPI_I2SCFGR_I2SCFG_1                ((uint16_t)0x0200)            /*!<Bit 1 */
N
N#define  SPI_I2SCFGR_I2SE                    ((uint16_t)0x0400)            /*!<I2S Enable         */
N#define  SPI_I2SCFGR_I2SMOD                  ((uint16_t)0x0800)            /*!<I2S mode selection */
N#if defined(STM32F413_423xx) || defined(STM32F446xx)
X#if 0L || 0L
S#define  SPI_I2SCFGR_ASTRTEN                 ((uint16_t)0x1000)            /*!<Asynchronous start enable */
N#endif /* STM32F413_423xx */
N
N/******************  Bit definition for SPI_I2SPR register  *******************/
N#define  SPI_I2SPR_I2SDIV                    ((uint16_t)0x00FF)            /*!<I2S Linear prescaler         */
N#define  SPI_I2SPR_ODD                       ((uint16_t)0x0100)            /*!<Odd factor for the prescaler */
N#define  SPI_I2SPR_MCKOE                     ((uint16_t)0x0200)            /*!<Master Clock Output Enable   */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                 SYSCFG                                     */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bit definition for SYSCFG_MEMRMP register  ***************/  
N#define SYSCFG_MEMRMP_MEM_MODE          ((uint32_t)0x00000007) /*!< SYSCFG_Memory Remap Config */
N#define SYSCFG_MEMRMP_MEM_MODE_0        ((uint32_t)0x00000001) /*!<Bit 0 */
N#define SYSCFG_MEMRMP_MEM_MODE_1        ((uint32_t)0x00000002) /*!<Bit 1 */
N#define SYSCFG_MEMRMP_MEM_MODE_2        ((uint32_t)0x00000004) /*!<Bit 2 */
N
N#define SYSCFG_MEMRMP_FB_MODE           ((uint32_t)0x00000100) /*!< User Flash Bank mode */
N
N#define SYSCFG_MEMRMP_SWP_FMC           ((uint32_t)0x00000C00) /*!< FMC memory mapping swap */
N#define SYSCFG_MEMRMP_SWP_FMC_0         ((uint32_t)0x00000400) /*!<Bit 0 */
N#define SYSCFG_MEMRMP_SWP_FMC_1         ((uint32_t)0x00000800) /*!<Bit 1 */
N
N
N/******************  Bit definition for SYSCFG_PMC register  ******************/
N#define SYSCFG_PMC_ADCxDC2              ((uint32_t)0x00070000) /*!< Refer to AN4073 on how to use this bit  */
N#define SYSCFG_PMC_ADC1DC2              ((uint32_t)0x00010000) /*!< Refer to AN4073 on how to use this bit  */
N#define SYSCFG_PMC_ADC2DC2              ((uint32_t)0x00020000) /*!< Refer to AN4073 on how to use this bit  */
N#define SYSCFG_PMC_ADC3DC2              ((uint32_t)0x00040000) /*!< Refer to AN4073 on how to use this bit  */
N
N#define SYSCFG_PMC_MII_RMII_SEL         ((uint32_t)0x00800000) /*!<Ethernet PHY interface selection */
N/* Old MII_RMII_SEL bit definition, maintained for legacy purpose */
N#define SYSCFG_PMC_MII_RMII             SYSCFG_PMC_MII_RMII_SEL
N
N/*****************  Bit definition for SYSCFG_EXTICR1 register  ***************/
N#define SYSCFG_EXTICR1_EXTI0            ((uint16_t)0x000F) /*!<EXTI 0 configuration */
N#define SYSCFG_EXTICR1_EXTI1            ((uint16_t)0x00F0) /*!<EXTI 1 configuration */
N#define SYSCFG_EXTICR1_EXTI2            ((uint16_t)0x0F00) /*!<EXTI 2 configuration */
N#define SYSCFG_EXTICR1_EXTI3            ((uint16_t)0xF000) /*!<EXTI 3 configuration */
N/** 
N  * @brief   EXTI0 configuration  
N  */ 
N#define SYSCFG_EXTICR1_EXTI0_PA         ((uint16_t)0x0000) /*!<PA[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PB         ((uint16_t)0x0001) /*!<PB[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PC         ((uint16_t)0x0002) /*!<PC[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PD         ((uint16_t)0x0003) /*!<PD[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PE         ((uint16_t)0x0004) /*!<PE[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PF         ((uint16_t)0x0005) /*!<PF[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PG         ((uint16_t)0x0006) /*!<PG[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PH         ((uint16_t)0x0007) /*!<PH[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PI         ((uint16_t)0x0008) /*!<PI[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PJ         ((uint16_t)0x0009) /*!<PJ[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PK         ((uint16_t)0x000A) /*!<PK[0] pin */
N
N/** 
N  * @brief   EXTI1 configuration  
N  */ 
N#define SYSCFG_EXTICR1_EXTI1_PA         ((uint16_t)0x0000) /*!<PA[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PB         ((uint16_t)0x0010) /*!<PB[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PC         ((uint16_t)0x0020) /*!<PC[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PD         ((uint16_t)0x0030) /*!<PD[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PE         ((uint16_t)0x0040) /*!<PE[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PF         ((uint16_t)0x0050) /*!<PF[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PG         ((uint16_t)0x0060) /*!<PG[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PH         ((uint16_t)0x0070) /*!<PH[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PI         ((uint16_t)0x0080) /*!<PI[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PJ         ((uint16_t)0x0090) /*!<PJ[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PK         ((uint16_t)0x00A0) /*!<PK[1] pin */
N
N/** 
N  * @brief   EXTI2 configuration  
N  */ 
N#define SYSCFG_EXTICR1_EXTI2_PA         ((uint16_t)0x0000) /*!<PA[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PB         ((uint16_t)0x0100) /*!<PB[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PC         ((uint16_t)0x0200) /*!<PC[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PD         ((uint16_t)0x0300) /*!<PD[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PE         ((uint16_t)0x0400) /*!<PE[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PF         ((uint16_t)0x0500) /*!<PF[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PG         ((uint16_t)0x0600) /*!<PG[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PH         ((uint16_t)0x0700) /*!<PH[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PI         ((uint16_t)0x0800) /*!<PI[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PJ         ((uint16_t)0x0900) /*!<PJ[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PK         ((uint16_t)0x0A00) /*!<PK[2] pin */
N
N/** 
N  * @brief   EXTI3 configuration  
N  */ 
N#define SYSCFG_EXTICR1_EXTI3_PA         ((uint16_t)0x0000) /*!<PA[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PB         ((uint16_t)0x1000) /*!<PB[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PC         ((uint16_t)0x2000) /*!<PC[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PD         ((uint16_t)0x3000) /*!<PD[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PE         ((uint16_t)0x4000) /*!<PE[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PF         ((uint16_t)0x5000) /*!<PF[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PG         ((uint16_t)0x6000) /*!<PG[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PH         ((uint16_t)0x7000) /*!<PH[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PI         ((uint16_t)0x8000) /*!<PI[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PJ         ((uint16_t)0x9000) /*!<PJ[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PK         ((uint16_t)0xA000) /*!<PK[3] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR2 register  ***************/
N#define SYSCFG_EXTICR2_EXTI4            ((uint16_t)0x000F) /*!<EXTI 4 configuration */
N#define SYSCFG_EXTICR2_EXTI5            ((uint16_t)0x00F0) /*!<EXTI 5 configuration */
N#define SYSCFG_EXTICR2_EXTI6            ((uint16_t)0x0F00) /*!<EXTI 6 configuration */
N#define SYSCFG_EXTICR2_EXTI7            ((uint16_t)0xF000) /*!<EXTI 7 configuration */
N/** 
N  * @brief   EXTI4 configuration  
N  */ 
N#define SYSCFG_EXTICR2_EXTI4_PA         ((uint16_t)0x0000) /*!<PA[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PB         ((uint16_t)0x0001) /*!<PB[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PC         ((uint16_t)0x0002) /*!<PC[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PD         ((uint16_t)0x0003) /*!<PD[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PE         ((uint16_t)0x0004) /*!<PE[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PF         ((uint16_t)0x0005) /*!<PF[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PG         ((uint16_t)0x0006) /*!<PG[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PH         ((uint16_t)0x0007) /*!<PH[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PI         ((uint16_t)0x0008) /*!<PI[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PJ         ((uint16_t)0x0009) /*!<PJ[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PK         ((uint16_t)0x000A) /*!<PK[4] pin */
N
N/** 
N  * @brief   EXTI5 configuration  
N  */ 
N#define SYSCFG_EXTICR2_EXTI5_PA         ((uint16_t)0x0000) /*!<PA[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PB         ((uint16_t)0x0010) /*!<PB[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PC         ((uint16_t)0x0020) /*!<PC[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PD         ((uint16_t)0x0030) /*!<PD[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PE         ((uint16_t)0x0040) /*!<PE[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PF         ((uint16_t)0x0050) /*!<PF[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PG         ((uint16_t)0x0060) /*!<PG[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PH         ((uint16_t)0x0070) /*!<PH[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PI         ((uint16_t)0x0080) /*!<PI[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PJ         ((uint16_t)0x0090) /*!<PJ[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PK         ((uint16_t)0x00A0) /*!<PK[5] pin */
N
N/** 
N  * @brief   EXTI6 configuration  
N  */ 
N#define SYSCFG_EXTICR2_EXTI6_PA         ((uint16_t)0x0000) /*!<PA[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PB         ((uint16_t)0x0100) /*!<PB[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PC         ((uint16_t)0x0200) /*!<PC[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PD         ((uint16_t)0x0300) /*!<PD[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PE         ((uint16_t)0x0400) /*!<PE[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PF         ((uint16_t)0x0500) /*!<PF[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PG         ((uint16_t)0x0600) /*!<PG[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PH         ((uint16_t)0x0700) /*!<PH[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PI         ((uint16_t)0x0800) /*!<PI[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PJ         ((uint16_t)0x0900) /*!<PJ[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PK         ((uint16_t)0x0A00) /*!<PK[6] pin */
N
N/** 
N  * @brief   EXTI7 configuration  
N  */ 
N#define SYSCFG_EXTICR2_EXTI7_PA         ((uint16_t)0x0000) /*!<PA[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PB         ((uint16_t)0x1000) /*!<PB[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PC         ((uint16_t)0x2000) /*!<PC[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PD         ((uint16_t)0x3000) /*!<PD[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PE         ((uint16_t)0x4000) /*!<PE[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PF         ((uint16_t)0x5000) /*!<PF[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PG         ((uint16_t)0x6000) /*!<PG[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PH         ((uint16_t)0x7000) /*!<PH[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PI         ((uint16_t)0x8000) /*!<PI[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PJ         ((uint16_t)0x9000) /*!<PJ[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PK         ((uint16_t)0xA000) /*!<PK[7] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR3 register  ***************/
N#define SYSCFG_EXTICR3_EXTI8            ((uint16_t)0x000F) /*!<EXTI 8 configuration */
N#define SYSCFG_EXTICR3_EXTI9            ((uint16_t)0x00F0) /*!<EXTI 9 configuration */
N#define SYSCFG_EXTICR3_EXTI10           ((uint16_t)0x0F00) /*!<EXTI 10 configuration */
N#define SYSCFG_EXTICR3_EXTI11           ((uint16_t)0xF000) /*!<EXTI 11 configuration */
N           
N/** 
N  * @brief   EXTI8 configuration  
N  */ 
N#define SYSCFG_EXTICR3_EXTI8_PA         ((uint16_t)0x0000) /*!<PA[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PB         ((uint16_t)0x0001) /*!<PB[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PC         ((uint16_t)0x0002) /*!<PC[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PD         ((uint16_t)0x0003) /*!<PD[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PE         ((uint16_t)0x0004) /*!<PE[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PF         ((uint16_t)0x0005) /*!<PF[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PG         ((uint16_t)0x0006) /*!<PG[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PH         ((uint16_t)0x0007) /*!<PH[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PI         ((uint16_t)0x0008) /*!<PI[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PJ         ((uint16_t)0x0009) /*!<PJ[8] pin */
N
N/** 
N  * @brief   EXTI9 configuration  
N  */ 
N#define SYSCFG_EXTICR3_EXTI9_PA         ((uint16_t)0x0000) /*!<PA[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PB         ((uint16_t)0x0010) /*!<PB[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PC         ((uint16_t)0x0020) /*!<PC[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PD         ((uint16_t)0x0030) /*!<PD[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PE         ((uint16_t)0x0040) /*!<PE[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PF         ((uint16_t)0x0050) /*!<PF[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PG         ((uint16_t)0x0060) /*!<PG[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PH         ((uint16_t)0x0070) /*!<PH[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PI         ((uint16_t)0x0080) /*!<PI[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PJ         ((uint16_t)0x0090) /*!<PJ[9] pin */
N
N/** 
N  * @brief   EXTI10 configuration  
N  */ 
N#define SYSCFG_EXTICR3_EXTI10_PA        ((uint16_t)0x0000) /*!<PA[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PB        ((uint16_t)0x0100) /*!<PB[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PC        ((uint16_t)0x0200) /*!<PC[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PD        ((uint16_t)0x0300) /*!<PD[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PE        ((uint16_t)0x0400) /*!<PE[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PF        ((uint16_t)0x0500) /*!<PF[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PG        ((uint16_t)0x0600) /*!<PG[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PH        ((uint16_t)0x0700) /*!<PH[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PI        ((uint16_t)0x0800) /*!<PI[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PJ        ((uint16_t)0x0900) /*!<PJ[10] pin */
N
N/** 
N  * @brief   EXTI11 configuration  
N  */ 
N#define SYSCFG_EXTICR3_EXTI11_PA        ((uint16_t)0x0000) /*!<PA[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PB        ((uint16_t)0x1000) /*!<PB[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PC        ((uint16_t)0x2000) /*!<PC[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PD        ((uint16_t)0x3000) /*!<PD[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PE        ((uint16_t)0x4000) /*!<PE[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PF        ((uint16_t)0x5000) /*!<PF[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PG        ((uint16_t)0x6000) /*!<PG[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PH        ((uint16_t)0x7000) /*!<PH[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PI        ((uint16_t)0x8000) /*!<PI[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PJ        ((uint16_t)0x9000) /*!<PJ[11] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR4 register  ***************/
N#define SYSCFG_EXTICR4_EXTI12           ((uint16_t)0x000F) /*!<EXTI 12 configuration */
N#define SYSCFG_EXTICR4_EXTI13           ((uint16_t)0x00F0) /*!<EXTI 13 configuration */
N#define SYSCFG_EXTICR4_EXTI14           ((uint16_t)0x0F00) /*!<EXTI 14 configuration */
N#define SYSCFG_EXTICR4_EXTI15           ((uint16_t)0xF000) /*!<EXTI 15 configuration */
N/** 
N  * @brief   EXTI12 configuration  
N  */ 
N#define SYSCFG_EXTICR4_EXTI12_PA        ((uint16_t)0x0000) /*!<PA[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PB        ((uint16_t)0x0001) /*!<PB[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PC        ((uint16_t)0x0002) /*!<PC[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PD        ((uint16_t)0x0003) /*!<PD[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PE        ((uint16_t)0x0004) /*!<PE[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PF        ((uint16_t)0x0005) /*!<PF[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PG        ((uint16_t)0x0006) /*!<PG[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PH        ((uint16_t)0x0007) /*!<PH[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PI        ((uint16_t)0x0008) /*!<PI[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PJ        ((uint16_t)0x0009) /*!<PJ[12] pin */
N
N/** 
N  * @brief   EXTI13 configuration  
N  */ 
N#define SYSCFG_EXTICR4_EXTI13_PA        ((uint16_t)0x0000) /*!<PA[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PB        ((uint16_t)0x0010) /*!<PB[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PC        ((uint16_t)0x0020) /*!<PC[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PD        ((uint16_t)0x0030) /*!<PD[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PE        ((uint16_t)0x0040) /*!<PE[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PF        ((uint16_t)0x0050) /*!<PF[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PG        ((uint16_t)0x0060) /*!<PG[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PH        ((uint16_t)0x0070) /*!<PH[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PI        ((uint16_t)0x0008) /*!<PI[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PJ        ((uint16_t)0x0009) /*!<PJ[13] pin */
N
N/** 
N  * @brief   EXTI14 configuration  
N  */ 
N#define SYSCFG_EXTICR4_EXTI14_PA        ((uint16_t)0x0000) /*!<PA[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PB        ((uint16_t)0x0100) /*!<PB[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PC        ((uint16_t)0x0200) /*!<PC[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PD        ((uint16_t)0x0300) /*!<PD[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PE        ((uint16_t)0x0400) /*!<PE[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PF        ((uint16_t)0x0500) /*!<PF[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PG        ((uint16_t)0x0600) /*!<PG[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PH        ((uint16_t)0x0700) /*!<PH[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PI        ((uint16_t)0x0800) /*!<PI[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PJ        ((uint16_t)0x0900) /*!<PJ[14] pin */
N
N/** 
N  * @brief   EXTI15 configuration  
N  */ 
N#define SYSCFG_EXTICR4_EXTI15_PA        ((uint16_t)0x0000) /*!<PA[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PB        ((uint16_t)0x1000) /*!<PB[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PC        ((uint16_t)0x2000) /*!<PC[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PD        ((uint16_t)0x3000) /*!<PD[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PE        ((uint16_t)0x4000) /*!<PE[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PF        ((uint16_t)0x5000) /*!<PF[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PG        ((uint16_t)0x6000) /*!<PG[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PH        ((uint16_t)0x7000) /*!<PH[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PI        ((uint16_t)0x8000) /*!<PI[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PJ        ((uint16_t)0x9000) /*!<PJ[15] pin */
N
N#if defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 0L || 0L
S/******************  Bit definition for SYSCFG_CFGR register  *****************/
S#define SYSCFG_CFGR_FMPI2C1_SCL         ((uint32_t)0x00000001) /*!<FM+ drive capability for FMPI2C1_SCL pin */
S#define SYSCFG_CFGR_FMPI2C1_SDA         ((uint32_t)0x00000002) /*!<FM+ drive capability for FMPI2C1_SDA pin */
N#endif /* STM32F412xG || STM32413_423xx */
N
N#if defined (STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 0L || 0L || 0L
S/******************  Bit definition for SYSCFG_CFGR2 register  ****************/
S#define SYSCFG_CFGR2_CLL                ((uint32_t)0x00000001) /*!< Core Lockup Lock */
S#define SYSCFG_CFGR2_PVDL               ((uint32_t)0x00000004) /*!<  PVD Lock */
N#endif /* STM32F410xx || STM32F412xG || STM32F413_423xx */
N/******************  Bit definition for SYSCFG_CMPCR register  ****************/  
N#define SYSCFG_CMPCR_CMP_PD             ((uint32_t)0x00000001) /*!<Compensation cell ready flag */
N#define SYSCFG_CMPCR_READY              ((uint32_t)0x00000100) /*!<Compensation cell power-down */
N
N#if defined(STM32F413_423xx)
X#if 0L
S/******************  Bit definition for SYSCFG_MCHDLYCR register  *****************/
S#define SYSCFG_MCHDLYCR_BSCKSEL         ((uint32_t)0x00000001) /*!<Bitstream clock source selection                     */
S#define SYSCFG_MCHDLYCR_MCHDLY1EN       ((uint32_t)0x00000002) /*!<MCHDLY clock enable for DFSDM1                       */
S#define SYSCFG_MCHDLYCR_DFSDM1D0SEL     ((uint32_t)0x00000004) /*!<Source selection for DatIn0 for DFSDM1               */
S#define SYSCFG_MCHDLYCR_DFSDM1D2SEL     ((uint32_t)0x00000008) /*!<Source selection for DatIn2 for DFSDM1               */
S#define SYSCFG_MCHDLYCR_DFSDM1CK02SEL   ((uint32_t)0x00000010) /*!<Distribution of the bitstreamclock gated by TIM4 OC2 */
S#define SYSCFG_MCHDLYCR_DFSDM1CK13SEL   ((uint32_t)0x00000020) /*!<Distribution of the bitstreamclock gated by TIM4 OC1 */
S#define SYSCFG_MCHDLYCR_DFSDM1CFG       ((uint32_t)0x00000040) /*!<Source selection for DFSDM1                          */
S#define SYSCFG_MCHDLYCR_DFSDM1CKOSEL    ((uint32_t)0x00000080) /*!<Source selection for 1_CKOUT                         */
S#define SYSCFG_MCHDLYCR_MCHDLY2EN       ((uint32_t)0x00000100) /*!<MCHDLY clock enable for DFSDM2                       */
S#define SYSCFG_MCHDLYCR_DFSDM2D0SEL     ((uint32_t)0x00000200) /*!<Source selection for DatIn0 for DFSDM2               */
S#define SYSCFG_MCHDLYCR_DFSDM2D2SEL     ((uint32_t)0x00000400) /*!<Source selection for DatIn2 for DFSDM2               */
S#define SYSCFG_MCHDLYCR_DFSDM2D4SEL     ((uint32_t)0x00000800) /*!<Source selection for DatIn4 for DFSDM2               */
S#define SYSCFG_MCHDLYCR_DFSDM2D6SEL     ((uint32_t)0x00001000) /*!<Source selection for DatIn6 for DFSDM2               */
S#define SYSCFG_MCHDLYCR_DFSDM2CK04SEL   ((uint32_t)0x00002000) /*!<Distribution of the bitstreamclock gated by TIM3 OC4 */
S#define SYSCFG_MCHDLYCR_DFSDM2CK15SEL   ((uint32_t)0x00004000) /*!<Distribution of the bitstreamclock gated by TIM3 OC3 */
S#define SYSCFG_MCHDLYCR_DFSDM2CK26SEL   ((uint32_t)0x00008000) /*!Distribution of the bitstreamclock gated by TIM3 OC2  */
S#define SYSCFG_MCHDLYCR_DFSDM2CK37SEL   ((uint32_t)0x00010000) /*!<Distribution of the bitstreamclock gated by TIM3 OC1 */
S#define SYSCFG_MCHDLYCR_DFSDM2CFG       ((uint32_t)0x00020000) /*!<Source selection for DFSDM2                          */
S#define SYSCFG_MCHDLYCR_DFSDM2CKOSEL    ((uint32_t)0x00040000) /*!<Source selection for 2_CKOUT                         */
N#endif /* STM32F413_423xx */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                    TIM                                     */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for TIM_CR1 register  ********************/
N#define  TIM_CR1_CEN                         ((uint16_t)0x0001)            /*!<Counter enable        */
N#define  TIM_CR1_UDIS                        ((uint16_t)0x0002)            /*!<Update disable        */
N#define  TIM_CR1_URS                         ((uint16_t)0x0004)            /*!<Update request source */
N#define  TIM_CR1_OPM                         ((uint16_t)0x0008)            /*!<One pulse mode        */
N#define  TIM_CR1_DIR                         ((uint16_t)0x0010)            /*!<Direction             */
N
N#define  TIM_CR1_CMS                         ((uint16_t)0x0060)            /*!<CMS[1:0] bits (Center-aligned mode selection) */
N#define  TIM_CR1_CMS_0                       ((uint16_t)0x0020)            /*!<Bit 0 */
N#define  TIM_CR1_CMS_1                       ((uint16_t)0x0040)            /*!<Bit 1 */
N
N#define  TIM_CR1_ARPE                        ((uint16_t)0x0080)            /*!<Auto-reload preload enable     */
N
N#define  TIM_CR1_CKD                         ((uint16_t)0x0300)            /*!<CKD[1:0] bits (clock division) */
N#define  TIM_CR1_CKD_0                       ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_CR1_CKD_1                       ((uint16_t)0x0200)            /*!<Bit 1 */
N
N/*******************  Bit definition for TIM_CR2 register  ********************/
N#define  TIM_CR2_CCPC                        ((uint16_t)0x0001)            /*!<Capture/Compare Preloaded Control        */
N#define  TIM_CR2_CCUS                        ((uint16_t)0x0004)            /*!<Capture/Compare Control Update Selection */
N#define  TIM_CR2_CCDS                        ((uint16_t)0x0008)            /*!<Capture/Compare DMA Selection            */
N
N#define  TIM_CR2_MMS                         ((uint16_t)0x0070)            /*!<MMS[2:0] bits (Master Mode Selection) */
N#define  TIM_CR2_MMS_0                       ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_CR2_MMS_1                       ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_CR2_MMS_2                       ((uint16_t)0x0040)            /*!<Bit 2 */
N
N#define  TIM_CR2_TI1S                        ((uint16_t)0x0080)            /*!<TI1 Selection */
N#define  TIM_CR2_OIS1                        ((uint16_t)0x0100)            /*!<Output Idle state 1 (OC1 output)  */
N#define  TIM_CR2_OIS1N                       ((uint16_t)0x0200)            /*!<Output Idle state 1 (OC1N output) */
N#define  TIM_CR2_OIS2                        ((uint16_t)0x0400)            /*!<Output Idle state 2 (OC2 output)  */
N#define  TIM_CR2_OIS2N                       ((uint16_t)0x0800)            /*!<Output Idle state 2 (OC2N output) */
N#define  TIM_CR2_OIS3                        ((uint16_t)0x1000)            /*!<Output Idle state 3 (OC3 output)  */
N#define  TIM_CR2_OIS3N                       ((uint16_t)0x2000)            /*!<Output Idle state 3 (OC3N output) */
N#define  TIM_CR2_OIS4                        ((uint16_t)0x4000)            /*!<Output Idle state 4 (OC4 output)  */
N
N/*******************  Bit definition for TIM_SMCR register  *******************/
N#define  TIM_SMCR_SMS                        ((uint16_t)0x0007)            /*!<SMS[2:0] bits (Slave mode selection)    */
N#define  TIM_SMCR_SMS_0                      ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  TIM_SMCR_SMS_1                      ((uint16_t)0x0002)            /*!<Bit 1 */
N#define  TIM_SMCR_SMS_2                      ((uint16_t)0x0004)            /*!<Bit 2 */
N
N#define  TIM_SMCR_TS                         ((uint16_t)0x0070)            /*!<TS[2:0] bits (Trigger selection)        */
N#define  TIM_SMCR_TS_0                       ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_SMCR_TS_1                       ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_SMCR_TS_2                       ((uint16_t)0x0040)            /*!<Bit 2 */
N
N#define  TIM_SMCR_MSM                        ((uint16_t)0x0080)            /*!<Master/slave mode                       */
N
N#define  TIM_SMCR_ETF                        ((uint16_t)0x0F00)            /*!<ETF[3:0] bits (External trigger filter) */
N#define  TIM_SMCR_ETF_0                      ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_SMCR_ETF_1                      ((uint16_t)0x0200)            /*!<Bit 1 */
N#define  TIM_SMCR_ETF_2                      ((uint16_t)0x0400)            /*!<Bit 2 */
N#define  TIM_SMCR_ETF_3                      ((uint16_t)0x0800)            /*!<Bit 3 */
N
N#define  TIM_SMCR_ETPS                       ((uint16_t)0x3000)            /*!<ETPS[1:0] bits (External trigger prescaler) */
N#define  TIM_SMCR_ETPS_0                     ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  TIM_SMCR_ETPS_1                     ((uint16_t)0x2000)            /*!<Bit 1 */
N
N#define  TIM_SMCR_ECE                        ((uint16_t)0x4000)            /*!<External clock enable     */
N#define  TIM_SMCR_ETP                        ((uint16_t)0x8000)            /*!<External trigger polarity */
N
N/*******************  Bit definition for TIM_DIER register  *******************/
N#define  TIM_DIER_UIE                        ((uint16_t)0x0001)            /*!<Update interrupt enable */
N#define  TIM_DIER_CC1IE                      ((uint16_t)0x0002)            /*!<Capture/Compare 1 interrupt enable   */
N#define  TIM_DIER_CC2IE                      ((uint16_t)0x0004)            /*!<Capture/Compare 2 interrupt enable   */
N#define  TIM_DIER_CC3IE                      ((uint16_t)0x0008)            /*!<Capture/Compare 3 interrupt enable   */
N#define  TIM_DIER_CC4IE                      ((uint16_t)0x0010)            /*!<Capture/Compare 4 interrupt enable   */
N#define  TIM_DIER_COMIE                      ((uint16_t)0x0020)            /*!<COM interrupt enable                 */
N#define  TIM_DIER_TIE                        ((uint16_t)0x0040)            /*!<Trigger interrupt enable             */
N#define  TIM_DIER_BIE                        ((uint16_t)0x0080)            /*!<Break interrupt enable               */
N#define  TIM_DIER_UDE                        ((uint16_t)0x0100)            /*!<Update DMA request enable            */
N#define  TIM_DIER_CC1DE                      ((uint16_t)0x0200)            /*!<Capture/Compare 1 DMA request enable */
N#define  TIM_DIER_CC2DE                      ((uint16_t)0x0400)            /*!<Capture/Compare 2 DMA request enable */
N#define  TIM_DIER_CC3DE                      ((uint16_t)0x0800)            /*!<Capture/Compare 3 DMA request enable */
N#define  TIM_DIER_CC4DE                      ((uint16_t)0x1000)            /*!<Capture/Compare 4 DMA request enable */
N#define  TIM_DIER_COMDE                      ((uint16_t)0x2000)            /*!<COM DMA request enable               */
N#define  TIM_DIER_TDE                        ((uint16_t)0x4000)            /*!<Trigger DMA request enable           */
N
N/********************  Bit definition for TIM_SR register  ********************/
N#define  TIM_SR_UIF                          ((uint16_t)0x0001)            /*!<Update interrupt Flag              */
N#define  TIM_SR_CC1IF                        ((uint16_t)0x0002)            /*!<Capture/Compare 1 interrupt Flag   */
N#define  TIM_SR_CC2IF                        ((uint16_t)0x0004)            /*!<Capture/Compare 2 interrupt Flag   */
N#define  TIM_SR_CC3IF                        ((uint16_t)0x0008)            /*!<Capture/Compare 3 interrupt Flag   */
N#define  TIM_SR_CC4IF                        ((uint16_t)0x0010)            /*!<Capture/Compare 4 interrupt Flag   */
N#define  TIM_SR_COMIF                        ((uint16_t)0x0020)            /*!<COM interrupt Flag                 */
N#define  TIM_SR_TIF                          ((uint16_t)0x0040)            /*!<Trigger interrupt Flag             */
N#define  TIM_SR_BIF                          ((uint16_t)0x0080)            /*!<Break interrupt Flag               */
N#define  TIM_SR_CC1OF                        ((uint16_t)0x0200)            /*!<Capture/Compare 1 Overcapture Flag */
N#define  TIM_SR_CC2OF                        ((uint16_t)0x0400)            /*!<Capture/Compare 2 Overcapture Flag */
N#define  TIM_SR_CC3OF                        ((uint16_t)0x0800)            /*!<Capture/Compare 3 Overcapture Flag */
N#define  TIM_SR_CC4OF                        ((uint16_t)0x1000)            /*!<Capture/Compare 4 Overcapture Flag */
N
N/*******************  Bit definition for TIM_EGR register  ********************/
N#define  TIM_EGR_UG                          ((uint8_t)0x01)               /*!<Update Generation                         */
N#define  TIM_EGR_CC1G                        ((uint8_t)0x02)               /*!<Capture/Compare 1 Generation              */
N#define  TIM_EGR_CC2G                        ((uint8_t)0x04)               /*!<Capture/Compare 2 Generation              */
N#define  TIM_EGR_CC3G                        ((uint8_t)0x08)               /*!<Capture/Compare 3 Generation              */
N#define  TIM_EGR_CC4G                        ((uint8_t)0x10)               /*!<Capture/Compare 4 Generation              */
N#define  TIM_EGR_COMG                        ((uint8_t)0x20)               /*!<Capture/Compare Control Update Generation */
N#define  TIM_EGR_TG                          ((uint8_t)0x40)               /*!<Trigger Generation                        */
N#define  TIM_EGR_BG                          ((uint8_t)0x80)               /*!<Break Generation                          */
N
N/******************  Bit definition for TIM_CCMR1 register  *******************/
N#define  TIM_CCMR1_CC1S                      ((uint16_t)0x0003)            /*!<CC1S[1:0] bits (Capture/Compare 1 Selection) */
N#define  TIM_CCMR1_CC1S_0                    ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  TIM_CCMR1_CC1S_1                    ((uint16_t)0x0002)            /*!<Bit 1 */
N
N#define  TIM_CCMR1_OC1FE                     ((uint16_t)0x0004)            /*!<Output Compare 1 Fast enable                 */
N#define  TIM_CCMR1_OC1PE                     ((uint16_t)0x0008)            /*!<Output Compare 1 Preload enable              */
N
N#define  TIM_CCMR1_OC1M                      ((uint16_t)0x0070)            /*!<OC1M[2:0] bits (Output Compare 1 Mode)       */
N#define  TIM_CCMR1_OC1M_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_CCMR1_OC1M_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_CCMR1_OC1M_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
N
N#define  TIM_CCMR1_OC1CE                     ((uint16_t)0x0080)            /*!<Output Compare 1Clear Enable                 */
N
N#define  TIM_CCMR1_CC2S                      ((uint16_t)0x0300)            /*!<CC2S[1:0] bits (Capture/Compare 2 Selection) */
N#define  TIM_CCMR1_CC2S_0                    ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_CCMR1_CC2S_1                    ((uint16_t)0x0200)            /*!<Bit 1 */
N
N#define  TIM_CCMR1_OC2FE                     ((uint16_t)0x0400)            /*!<Output Compare 2 Fast enable                 */
N#define  TIM_CCMR1_OC2PE                     ((uint16_t)0x0800)            /*!<Output Compare 2 Preload enable              */
N
N#define  TIM_CCMR1_OC2M                      ((uint16_t)0x7000)            /*!<OC2M[2:0] bits (Output Compare 2 Mode)       */
N#define  TIM_CCMR1_OC2M_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  TIM_CCMR1_OC2M_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
N#define  TIM_CCMR1_OC2M_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
N
N#define  TIM_CCMR1_OC2CE                     ((uint16_t)0x8000)            /*!<Output Compare 2 Clear Enable */
N
N/*----------------------------------------------------------------------------*/
N
N#define  TIM_CCMR1_IC1PSC                    ((uint16_t)0x000C)            /*!<IC1PSC[1:0] bits (Input Capture 1 Prescaler) */
N#define  TIM_CCMR1_IC1PSC_0                  ((uint16_t)0x0004)            /*!<Bit 0 */
N#define  TIM_CCMR1_IC1PSC_1                  ((uint16_t)0x0008)            /*!<Bit 1 */
N
N#define  TIM_CCMR1_IC1F                      ((uint16_t)0x00F0)            /*!<IC1F[3:0] bits (Input Capture 1 Filter)      */
N#define  TIM_CCMR1_IC1F_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_CCMR1_IC1F_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_CCMR1_IC1F_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
N#define  TIM_CCMR1_IC1F_3                    ((uint16_t)0x0080)            /*!<Bit 3 */
N
N#define  TIM_CCMR1_IC2PSC                    ((uint16_t)0x0C00)            /*!<IC2PSC[1:0] bits (Input Capture 2 Prescaler)  */
N#define  TIM_CCMR1_IC2PSC_0                  ((uint16_t)0x0400)            /*!<Bit 0 */
N#define  TIM_CCMR1_IC2PSC_1                  ((uint16_t)0x0800)            /*!<Bit 1 */
N
N#define  TIM_CCMR1_IC2F                      ((uint16_t)0xF000)            /*!<IC2F[3:0] bits (Input Capture 2 Filter)       */
N#define  TIM_CCMR1_IC2F_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  TIM_CCMR1_IC2F_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
N#define  TIM_CCMR1_IC2F_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
N#define  TIM_CCMR1_IC2F_3                    ((uint16_t)0x8000)            /*!<Bit 3 */
N
N/******************  Bit definition for TIM_CCMR2 register  *******************/
N#define  TIM_CCMR2_CC3S                      ((uint16_t)0x0003)            /*!<CC3S[1:0] bits (Capture/Compare 3 Selection)  */
N#define  TIM_CCMR2_CC3S_0                    ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  TIM_CCMR2_CC3S_1                    ((uint16_t)0x0002)            /*!<Bit 1 */
N
N#define  TIM_CCMR2_OC3FE                     ((uint16_t)0x0004)            /*!<Output Compare 3 Fast enable           */
N#define  TIM_CCMR2_OC3PE                     ((uint16_t)0x0008)            /*!<Output Compare 3 Preload enable        */
N
N#define  TIM_CCMR2_OC3M                      ((uint16_t)0x0070)            /*!<OC3M[2:0] bits (Output Compare 3 Mode) */
N#define  TIM_CCMR2_OC3M_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_CCMR2_OC3M_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_CCMR2_OC3M_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
N
N#define  TIM_CCMR2_OC3CE                     ((uint16_t)0x0080)            /*!<Output Compare 3 Clear Enable */
N
N#define  TIM_CCMR2_CC4S                      ((uint16_t)0x0300)            /*!<CC4S[1:0] bits (Capture/Compare 4 Selection) */
N#define  TIM_CCMR2_CC4S_0                    ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_CCMR2_CC4S_1                    ((uint16_t)0x0200)            /*!<Bit 1 */
N
N#define  TIM_CCMR2_OC4FE                     ((uint16_t)0x0400)            /*!<Output Compare 4 Fast enable    */
N#define  TIM_CCMR2_OC4PE                     ((uint16_t)0x0800)            /*!<Output Compare 4 Preload enable */
N
N#define  TIM_CCMR2_OC4M                      ((uint16_t)0x7000)            /*!<OC4M[2:0] bits (Output Compare 4 Mode) */
N#define  TIM_CCMR2_OC4M_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  TIM_CCMR2_OC4M_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
N#define  TIM_CCMR2_OC4M_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
N
N#define  TIM_CCMR2_OC4CE                     ((uint16_t)0x8000)            /*!<Output Compare 4 Clear Enable */
N
N/*----------------------------------------------------------------------------*/
N
N#define  TIM_CCMR2_IC3PSC                    ((uint16_t)0x000C)            /*!<IC3PSC[1:0] bits (Input Capture 3 Prescaler) */
N#define  TIM_CCMR2_IC3PSC_0                  ((uint16_t)0x0004)            /*!<Bit 0 */
N#define  TIM_CCMR2_IC3PSC_1                  ((uint16_t)0x0008)            /*!<Bit 1 */
N
N#define  TIM_CCMR2_IC3F                      ((uint16_t)0x00F0)            /*!<IC3F[3:0] bits (Input Capture 3 Filter) */
N#define  TIM_CCMR2_IC3F_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_CCMR2_IC3F_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_CCMR2_IC3F_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
N#define  TIM_CCMR2_IC3F_3                    ((uint16_t)0x0080)            /*!<Bit 3 */
N
N#define  TIM_CCMR2_IC4PSC                    ((uint16_t)0x0C00)            /*!<IC4PSC[1:0] bits (Input Capture 4 Prescaler) */
N#define  TIM_CCMR2_IC4PSC_0                  ((uint16_t)0x0400)            /*!<Bit 0 */
N#define  TIM_CCMR2_IC4PSC_1                  ((uint16_t)0x0800)            /*!<Bit 1 */
N
N#define  TIM_CCMR2_IC4F                      ((uint16_t)0xF000)            /*!<IC4F[3:0] bits (Input Capture 4 Filter) */
N#define  TIM_CCMR2_IC4F_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  TIM_CCMR2_IC4F_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
N#define  TIM_CCMR2_IC4F_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
N#define  TIM_CCMR2_IC4F_3                    ((uint16_t)0x8000)            /*!<Bit 3 */
N
N/*******************  Bit definition for TIM_CCER register  *******************/
N#define  TIM_CCER_CC1E                       ((uint16_t)0x0001)            /*!<Capture/Compare 1 output enable                 */
N#define  TIM_CCER_CC1P                       ((uint16_t)0x0002)            /*!<Capture/Compare 1 output Polarity               */
N#define  TIM_CCER_CC1NE                      ((uint16_t)0x0004)            /*!<Capture/Compare 1 Complementary output enable   */
N#define  TIM_CCER_CC1NP                      ((uint16_t)0x0008)            /*!<Capture/Compare 1 Complementary output Polarity */
N#define  TIM_CCER_CC2E                       ((uint16_t)0x0010)            /*!<Capture/Compare 2 output enable                 */
N#define  TIM_CCER_CC2P                       ((uint16_t)0x0020)            /*!<Capture/Compare 2 output Polarity               */
N#define  TIM_CCER_CC2NE                      ((uint16_t)0x0040)            /*!<Capture/Compare 2 Complementary output enable   */
N#define  TIM_CCER_CC2NP                      ((uint16_t)0x0080)            /*!<Capture/Compare 2 Complementary output Polarity */
N#define  TIM_CCER_CC3E                       ((uint16_t)0x0100)            /*!<Capture/Compare 3 output enable                 */
N#define  TIM_CCER_CC3P                       ((uint16_t)0x0200)            /*!<Capture/Compare 3 output Polarity               */
N#define  TIM_CCER_CC3NE                      ((uint16_t)0x0400)            /*!<Capture/Compare 3 Complementary output enable   */
N#define  TIM_CCER_CC3NP                      ((uint16_t)0x0800)            /*!<Capture/Compare 3 Complementary output Polarity */
N#define  TIM_CCER_CC4E                       ((uint16_t)0x1000)            /*!<Capture/Compare 4 output enable                 */
N#define  TIM_CCER_CC4P                       ((uint16_t)0x2000)            /*!<Capture/Compare 4 output Polarity               */
N#define  TIM_CCER_CC4NP                      ((uint16_t)0x8000)            /*!<Capture/Compare 4 Complementary output Polarity */
N
N/*******************  Bit definition for TIM_CNT register  ********************/
N#define  TIM_CNT_CNT                         ((uint16_t)0xFFFF)            /*!<Counter Value            */
N
N/*******************  Bit definition for TIM_PSC register  ********************/
N#define  TIM_PSC_PSC                         ((uint16_t)0xFFFF)            /*!<Prescaler Value          */
N
N/*******************  Bit definition for TIM_ARR register  ********************/
N#define  TIM_ARR_ARR                         ((uint16_t)0xFFFF)            /*!<actual auto-reload Value */
N
N/*******************  Bit definition for TIM_RCR register  ********************/
N#define  TIM_RCR_REP                         ((uint8_t)0xFF)               /*!<Repetition Counter Value */
N
N/*******************  Bit definition for TIM_CCR1 register  *******************/
N#define  TIM_CCR1_CCR1                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 1 Value  */
N
N/*******************  Bit definition for TIM_CCR2 register  *******************/
N#define  TIM_CCR2_CCR2                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 2 Value  */
N
N/*******************  Bit definition for TIM_CCR3 register  *******************/
N#define  TIM_CCR3_CCR3                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 3 Value  */
N
N/*******************  Bit definition for TIM_CCR4 register  *******************/
N#define  TIM_CCR4_CCR4                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 4 Value  */
N
N/*******************  Bit definition for TIM_BDTR register  *******************/
N#define  TIM_BDTR_DTG                        ((uint16_t)0x00FF)            /*!<DTG[0:7] bits (Dead-Time Generator set-up) */
N#define  TIM_BDTR_DTG_0                      ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  TIM_BDTR_DTG_1                      ((uint16_t)0x0002)            /*!<Bit 1 */
N#define  TIM_BDTR_DTG_2                      ((uint16_t)0x0004)            /*!<Bit 2 */
N#define  TIM_BDTR_DTG_3                      ((uint16_t)0x0008)            /*!<Bit 3 */
N#define  TIM_BDTR_DTG_4                      ((uint16_t)0x0010)            /*!<Bit 4 */
N#define  TIM_BDTR_DTG_5                      ((uint16_t)0x0020)            /*!<Bit 5 */
N#define  TIM_BDTR_DTG_6                      ((uint16_t)0x0040)            /*!<Bit 6 */
N#define  TIM_BDTR_DTG_7                      ((uint16_t)0x0080)            /*!<Bit 7 */
N
N#define  TIM_BDTR_LOCK                       ((uint16_t)0x0300)            /*!<LOCK[1:0] bits (Lock Configuration) */
N#define  TIM_BDTR_LOCK_0                     ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_BDTR_LOCK_1                     ((uint16_t)0x0200)            /*!<Bit 1 */
N
N#define  TIM_BDTR_OSSI                       ((uint16_t)0x0400)            /*!<Off-State Selection for Idle mode */
N#define  TIM_BDTR_OSSR                       ((uint16_t)0x0800)            /*!<Off-State Selection for Run mode  */
N#define  TIM_BDTR_BKE                        ((uint16_t)0x1000)            /*!<Break enable                      */
N#define  TIM_BDTR_BKP                        ((uint16_t)0x2000)            /*!<Break Polarity                    */
N#define  TIM_BDTR_AOE                        ((uint16_t)0x4000)            /*!<Automatic Output enable           */
N#define  TIM_BDTR_MOE                        ((uint16_t)0x8000)            /*!<Main Output enable                */
N
N/*******************  Bit definition for TIM_DCR register  ********************/
N#define  TIM_DCR_DBA                         ((uint16_t)0x001F)            /*!<DBA[4:0] bits (DMA Base Address) */
N#define  TIM_DCR_DBA_0                       ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  TIM_DCR_DBA_1                       ((uint16_t)0x0002)            /*!<Bit 1 */
N#define  TIM_DCR_DBA_2                       ((uint16_t)0x0004)            /*!<Bit 2 */
N#define  TIM_DCR_DBA_3                       ((uint16_t)0x0008)            /*!<Bit 3 */
N#define  TIM_DCR_DBA_4                       ((uint16_t)0x0010)            /*!<Bit 4 */
N
N#define  TIM_DCR_DBL                         ((uint16_t)0x1F00)            /*!<DBL[4:0] bits (DMA Burst Length) */
N#define  TIM_DCR_DBL_0                       ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_DCR_DBL_1                       ((uint16_t)0x0200)            /*!<Bit 1 */
N#define  TIM_DCR_DBL_2                       ((uint16_t)0x0400)            /*!<Bit 2 */
N#define  TIM_DCR_DBL_3                       ((uint16_t)0x0800)            /*!<Bit 3 */
N#define  TIM_DCR_DBL_4                       ((uint16_t)0x1000)            /*!<Bit 4 */
N
N/*******************  Bit definition for TIM_DMAR register  *******************/
N#define  TIM_DMAR_DMAB                       ((uint16_t)0xFFFF)            /*!<DMA register for burst accesses                    */
N
N/*******************  Bit definition for TIM_OR register  *********************/
N#define TIM_OR_TI4_RMP                       ((uint16_t)0x00C0)            /*!<TI4_RMP[1:0] bits (TIM5 Input 4 remap)             */
N#define TIM_OR_TI4_RMP_0                     ((uint16_t)0x0040)            /*!<Bit 0 */
N#define TIM_OR_TI4_RMP_1                     ((uint16_t)0x0080)            /*!<Bit 1 */
N#define TIM_OR_ITR1_RMP                      ((uint16_t)0x0C00)            /*!<ITR1_RMP[1:0] bits (TIM2 Internal trigger 1 remap) */
N#define TIM_OR_ITR1_RMP_0                    ((uint16_t)0x0400)            /*!<Bit 0 */
N#define TIM_OR_ITR1_RMP_1                    ((uint16_t)0x0800)            /*!<Bit 1 */
N
N#if defined(STM32F410xx) || defined(STM32F413_423xx)
X#if 0L || 0L
S/******************************************************************************/
S/*                                                                            */
S/*                         Low Power Timer (LPTIM)                            */
S/*                                                                            */
S/******************************************************************************/
S/******************  Bit definition for LPTIM_ISR register  *******************/
S#define  LPTIM_ISR_CMPM                         ((uint32_t)0x00000001)            /*!< Compare match                       */
S#define  LPTIM_ISR_ARRM                         ((uint32_t)0x00000002)            /*!< Autoreload match                    */
S#define  LPTIM_ISR_EXTTRIG                      ((uint32_t)0x00000004)            /*!< External trigger edge event         */
S#define  LPTIM_ISR_CMPOK                        ((uint32_t)0x00000008)            /*!< Compare register update OK          */
S#define  LPTIM_ISR_ARROK                        ((uint32_t)0x00000010)            /*!< Autoreload register update OK       */
S#define  LPTIM_ISR_UP                           ((uint32_t)0x00000020)            /*!< Counter direction change down to up */
S#define  LPTIM_ISR_DOWN                         ((uint32_t)0x00000040)            /*!< Counter direction change up to down */
S
S/******************  Bit definition for LPTIM_ICR register  *******************/
S#define  LPTIM_ICR_CMPMCF                       ((uint32_t)0x00000001)            /*!< Compare match Clear Flag                       */
S#define  LPTIM_ICR_ARRMCF                       ((uint32_t)0x00000002)            /*!< Autoreload match Clear Flag                    */
S#define  LPTIM_ICR_EXTTRIGCF                    ((uint32_t)0x00000004)            /*!< External trigger edge event Clear Flag         */
S#define  LPTIM_ICR_CMPOKCF                      ((uint32_t)0x00000008)            /*!< Compare register update OK Clear Flag          */
S#define  LPTIM_ICR_ARROKCF                      ((uint32_t)0x00000010)            /*!< Autoreload register update OK Clear Flag       */
S#define  LPTIM_ICR_UPCF                         ((uint32_t)0x00000020)            /*!< Counter direction change down to up Clear Flag */
S#define  LPTIM_ICR_DOWNCF                       ((uint32_t)0x00000040)            /*!< Counter direction change up to down Clear Flag */
S
S/******************  Bit definition for LPTIM_IER register ********************/
S#define  LPTIM_IER_CMPMIE                       ((uint32_t)0x00000001)            /*!< Compare match Interrupt Enable                       */
S#define  LPTIM_IER_ARRMIE                       ((uint32_t)0x00000002)            /*!< Autoreload match Interrupt Enable                    */
S#define  LPTIM_IER_EXTTRIGIE                    ((uint32_t)0x00000004)            /*!< External trigger edge event Interrupt Enable         */
S#define  LPTIM_IER_CMPOKIE                      ((uint32_t)0x00000008)            /*!< Compare register update OK Interrupt Enable          */
S#define  LPTIM_IER_ARROKIE                      ((uint32_t)0x00000010)            /*!< Autoreload register update OK Interrupt Enable       */
S#define  LPTIM_IER_UPIE                         ((uint32_t)0x00000020)            /*!< Counter direction change down to up Interrupt Enable */
S#define  LPTIM_IER_DOWNIE                       ((uint32_t)0x00000040)            /*!< Counter direction change up to down Interrupt Enable */
S
S/******************  Bit definition for LPTIM_CFGR register *******************/
S#define  LPTIM_CFGR_CKSEL                       ((uint32_t)0x00000001)             /*!< Clock selector */
S
S#define  LPTIM_CFGR_CKPOL                       ((uint32_t)0x00000006)             /*!< CKPOL[1:0] bits (Clock polarity) */
S#define  LPTIM_CFGR_CKPOL_0                     ((uint32_t)0x00000002)             /*!< Bit 0 */
S#define  LPTIM_CFGR_CKPOL_1                     ((uint32_t)0x00000004)             /*!< Bit 1 */
S
S#define  LPTIM_CFGR_CKFLT                       ((uint32_t)0x00000018)             /*!< CKFLT[1:0] bits (Configurable digital filter for external clock) */
S#define  LPTIM_CFGR_CKFLT_0                     ((uint32_t)0x00000008)             /*!< Bit 0 */
S#define  LPTIM_CFGR_CKFLT_1                     ((uint32_t)0x00000010)             /*!< Bit 1 */
S
S#define  LPTIM_CFGR_TRGFLT                      ((uint32_t)0x000000C0)             /*!< TRGFLT[1:0] bits (Configurable digital filter for trigger) */
S#define  LPTIM_CFGR_TRGFLT_0                    ((uint32_t)0x00000040)             /*!< Bit 0 */
S#define  LPTIM_CFGR_TRGFLT_1                    ((uint32_t)0x00000080)             /*!< Bit 1 */
S
S#define  LPTIM_CFGR_PRESC                       ((uint32_t)0x00000E00)             /*!< PRESC[2:0] bits (Clock prescaler) */
S#define  LPTIM_CFGR_PRESC_0                     ((uint32_t)0x00000200)             /*!< Bit 0 */
S#define  LPTIM_CFGR_PRESC_1                     ((uint32_t)0x00000400)             /*!< Bit 1 */
S#define  LPTIM_CFGR_PRESC_2                     ((uint32_t)0x00000800)             /*!< Bit 2 */
S
S#define  LPTIM_CFGR_TRIGSEL                     ((uint32_t)0x0000E000)             /*!< TRIGSEL[2:0]] bits (Trigger selector) */
S#define  LPTIM_CFGR_TRIGSEL_0                   ((uint32_t)0x00002000)             /*!< Bit 0 */
S#define  LPTIM_CFGR_TRIGSEL_1                   ((uint32_t)0x00004000)             /*!< Bit 1 */
S#define  LPTIM_CFGR_TRIGSEL_2                   ((uint32_t)0x00008000)             /*!< Bit 2 */
S
S#define  LPTIM_CFGR_TRIGEN                      ((uint32_t)0x00060000)             /*!< TRIGEN[1:0] bits (Trigger enable and polarity) */
S#define  LPTIM_CFGR_TRIGEN_0                    ((uint32_t)0x00020000)             /*!< Bit 0 */
S#define  LPTIM_CFGR_TRIGEN_1                    ((uint32_t)0x00040000)             /*!< Bit 1 */
S
S#define  LPTIM_CFGR_TIMOUT                      ((uint32_t)0x00080000)             /*!< Timout enable           */
S#define  LPTIM_CFGR_WAVE                        ((uint32_t)0x00100000)             /*!< Waveform shape          */
S#define  LPTIM_CFGR_WAVPOL                      ((uint32_t)0x00200000)             /*!< Waveform shape polarity */
S#define  LPTIM_CFGR_PRELOAD                     ((uint32_t)0x00400000)             /*!< Reg update mode         */
S#define  LPTIM_CFGR_COUNTMODE                   ((uint32_t)0x00800000)             /*!< Counter mode enable     */     
S#define  LPTIM_CFGR_ENC                         ((uint32_t)0x01000000)             /*!< Encoder mode enable     */          
S
S/******************  Bit definition for LPTIM_CR register  ********************/
S#define  LPTIM_CR_ENABLE                        ((uint32_t)0x00000001)             /*!< LPTIMer enable                 */
S#define  LPTIM_CR_SNGSTRT                       ((uint32_t)0x00000002)             /*!< Timer start in single mode     */
S#define  LPTIM_CR_CNTSTRT                       ((uint32_t)0x00000004)             /*!< Timer start in continuous mode */
S
S/******************  Bit definition for LPTIM_CMP register  *******************/
S#define  LPTIM_CMP_CMP                          ((uint32_t)0x0000FFFF)             /*!< Compare register     */
S
S/******************  Bit definition for LPTIM_ARR register  *******************/
S#define  LPTIM_ARR_ARR                          ((uint32_t)0x0000FFFF)             /*!< Auto reload register */
S
S/******************  Bit definition for LPTIM_CNT register  *******************/
S#define  LPTIM_CNT_CNT                          ((uint32_t)0x0000FFFF)             /*!< Counter register     */
S
S/******************  Bit definition for LPTIM_OR register  *******************/
S#define  LPTIM_OR_OR                           ((uint32_t)0x00000003)               /*!< LPTIMER[1:0] bits (Remap selection) */
S#define  LPTIM_OR_OR_0                         ((uint32_t)0x00000001)               /*!< Bit 0 */
S#define  LPTIM_OR_OR_1                         ((uint32_t)0x00000002)               /*!< Bit 1 */
N#endif /* STM32F410xx || STM32F413_423xx */
N
N/******************************************************************************/
N/*                                                                            */
N/*         Universal Synchronous Asynchronous Receiver Transmitter            */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for USART_SR register  *******************/
N#define  USART_SR_PE                         ((uint16_t)0x0001)            /*!<Parity Error                 */
N#define  USART_SR_FE                         ((uint16_t)0x0002)            /*!<Framing Error                */
N#define  USART_SR_NE                         ((uint16_t)0x0004)            /*!<Noise Error Flag             */
N#define  USART_SR_ORE                        ((uint16_t)0x0008)            /*!<OverRun Error                */
N#define  USART_SR_IDLE                       ((uint16_t)0x0010)            /*!<IDLE line detected           */
N#define  USART_SR_RXNE                       ((uint16_t)0x0020)            /*!<Read Data Register Not Empty */
N#define  USART_SR_TC                         ((uint16_t)0x0040)            /*!<Transmission Complete        */
N#define  USART_SR_TXE                        ((uint16_t)0x0080)            /*!<Transmit Data Register Empty */
N#define  USART_SR_LBD                        ((uint16_t)0x0100)            /*!<LIN Break Detection Flag     */
N#define  USART_SR_CTS                        ((uint16_t)0x0200)            /*!<CTS Flag                     */
N
N/*******************  Bit definition for USART_DR register  *******************/
N#define  USART_DR_DR                         ((uint16_t)0x01FF)            /*!<Data value */
N
N/******************  Bit definition for USART_BRR register  *******************/
N#define  USART_BRR_DIV_Fraction              ((uint16_t)0x000F)            /*!<Fraction of USARTDIV */
N#define  USART_BRR_DIV_Mantissa              ((uint16_t)0xFFF0)            /*!<Mantissa of USARTDIV */
N
N/******************  Bit definition for USART_CR1 register  *******************/
N#define  USART_CR1_SBK                       ((uint16_t)0x0001)            /*!<Send Break                             */
N#define  USART_CR1_RWU                       ((uint16_t)0x0002)            /*!<Receiver wakeup                        */
N#define  USART_CR1_RE                        ((uint16_t)0x0004)            /*!<Receiver Enable                        */
N#define  USART_CR1_TE                        ((uint16_t)0x0008)            /*!<Transmitter Enable                     */
N#define  USART_CR1_IDLEIE                    ((uint16_t)0x0010)            /*!<IDLE Interrupt Enable                  */
N#define  USART_CR1_RXNEIE                    ((uint16_t)0x0020)            /*!<RXNE Interrupt Enable                  */
N#define  USART_CR1_TCIE                      ((uint16_t)0x0040)            /*!<Transmission Complete Interrupt Enable */
N#define  USART_CR1_TXEIE                     ((uint16_t)0x0080)            /*!<PE Interrupt Enable                    */
N#define  USART_CR1_PEIE                      ((uint16_t)0x0100)            /*!<PE Interrupt Enable                    */
N#define  USART_CR1_PS                        ((uint16_t)0x0200)            /*!<Parity Selection                       */
N#define  USART_CR1_PCE                       ((uint16_t)0x0400)            /*!<Parity Control Enable                  */
N#define  USART_CR1_WAKE                      ((uint16_t)0x0800)            /*!<Wakeup method                          */
N#define  USART_CR1_M                         ((uint16_t)0x1000)            /*!<Word length                            */
N#define  USART_CR1_UE                        ((uint16_t)0x2000)            /*!<USART Enable                           */
N#define  USART_CR1_OVER8                     ((uint16_t)0x8000)            /*!<USART Oversampling by 8 enable         */
N
N/******************  Bit definition for USART_CR2 register  *******************/
N#define  USART_CR2_ADD                       ((uint16_t)0x000F)            /*!<Address of the USART node            */
N#define  USART_CR2_LBDL                      ((uint16_t)0x0020)            /*!<LIN Break Detection Length           */
N#define  USART_CR2_LBDIE                     ((uint16_t)0x0040)            /*!<LIN Break Detection Interrupt Enable */
N#define  USART_CR2_LBCL                      ((uint16_t)0x0100)            /*!<Last Bit Clock pulse                 */
N#define  USART_CR2_CPHA                      ((uint16_t)0x0200)            /*!<Clock Phase                          */
N#define  USART_CR2_CPOL                      ((uint16_t)0x0400)            /*!<Clock Polarity                       */
N#define  USART_CR2_CLKEN                     ((uint16_t)0x0800)            /*!<Clock Enable                         */
N
N#define  USART_CR2_STOP                      ((uint16_t)0x3000)            /*!<STOP[1:0] bits (STOP bits) */
N#define  USART_CR2_STOP_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  USART_CR2_STOP_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
N
N#define  USART_CR2_LINEN                     ((uint16_t)0x4000)            /*!<LIN mode enable */
N
N/******************  Bit definition for USART_CR3 register  *******************/
N#define  USART_CR3_EIE                       ((uint16_t)0x0001)            /*!<Error Interrupt Enable      */
N#define  USART_CR3_IREN                      ((uint16_t)0x0002)            /*!<IrDA mode Enable            */
N#define  USART_CR3_IRLP                      ((uint16_t)0x0004)            /*!<IrDA Low-Power              */
N#define  USART_CR3_HDSEL                     ((uint16_t)0x0008)            /*!<Half-Duplex Selection       */
N#define  USART_CR3_NACK                      ((uint16_t)0x0010)            /*!<Smartcard NACK enable       */
N#define  USART_CR3_SCEN                      ((uint16_t)0x0020)            /*!<Smartcard mode enable       */
N#define  USART_CR3_DMAR                      ((uint16_t)0x0040)            /*!<DMA Enable Receiver         */
N#define  USART_CR3_DMAT                      ((uint16_t)0x0080)            /*!<DMA Enable Transmitter      */
N#define  USART_CR3_RTSE                      ((uint16_t)0x0100)            /*!<RTS Enable                  */
N#define  USART_CR3_CTSE                      ((uint16_t)0x0200)            /*!<CTS Enable                  */
N#define  USART_CR3_CTSIE                     ((uint16_t)0x0400)            /*!<CTS Interrupt Enable        */
N#define  USART_CR3_ONEBIT                    ((uint16_t)0x0800)            /*!<USART One bit method enable */
N
N/******************  Bit definition for USART_GTPR register  ******************/
N#define  USART_GTPR_PSC                      ((uint16_t)0x00FF)            /*!<PSC[7:0] bits (Prescaler value) */
N#define  USART_GTPR_PSC_0                    ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  USART_GTPR_PSC_1                    ((uint16_t)0x0002)            /*!<Bit 1 */
N#define  USART_GTPR_PSC_2                    ((uint16_t)0x0004)            /*!<Bit 2 */
N#define  USART_GTPR_PSC_3                    ((uint16_t)0x0008)            /*!<Bit 3 */
N#define  USART_GTPR_PSC_4                    ((uint16_t)0x0010)            /*!<Bit 4 */
N#define  USART_GTPR_PSC_5                    ((uint16_t)0x0020)            /*!<Bit 5 */
N#define  USART_GTPR_PSC_6                    ((uint16_t)0x0040)            /*!<Bit 6 */
N#define  USART_GTPR_PSC_7                    ((uint16_t)0x0080)            /*!<Bit 7 */
N
N#define  USART_GTPR_GT                       ((uint16_t)0xFF00)            /*!<Guard time value */
N
N/******************************************************************************/
N/*                                                                            */
N/*                            Window WATCHDOG                                 */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for WWDG_CR register  ********************/
N#define  WWDG_CR_T                           ((uint8_t)0x7F)               /*!<T[6:0] bits (7-Bit counter (MSB to LSB)) */
N#define  WWDG_CR_T_0                         ((uint8_t)0x01)               /*!<Bit 0 */
N#define  WWDG_CR_T_1                         ((uint8_t)0x02)               /*!<Bit 1 */
N#define  WWDG_CR_T_2                         ((uint8_t)0x04)               /*!<Bit 2 */
N#define  WWDG_CR_T_3                         ((uint8_t)0x08)               /*!<Bit 3 */
N#define  WWDG_CR_T_4                         ((uint8_t)0x10)               /*!<Bit 4 */
N#define  WWDG_CR_T_5                         ((uint8_t)0x20)               /*!<Bit 5 */
N#define  WWDG_CR_T_6                         ((uint8_t)0x40)               /*!<Bit 6 */
N/* Legacy defines */
N#define  WWDG_CR_T0                          WWDG_CR_T_0
N#define  WWDG_CR_T1                          WWDG_CR_T_1
N#define  WWDG_CR_T2                          WWDG_CR_T_2
N#define  WWDG_CR_T3                          WWDG_CR_T_3
N#define  WWDG_CR_T4                          WWDG_CR_T_4
N#define  WWDG_CR_T5                          WWDG_CR_T_5
N#define  WWDG_CR_T6                          WWDG_CR_T_6
N
N#define  WWDG_CR_WDGA                        ((uint8_t)0x80)               /*!<Activation bit */
N
N/*******************  Bit definition for WWDG_CFR register  *******************/
N#define  WWDG_CFR_W                          ((uint16_t)0x007F)            /*!<W[6:0] bits (7-bit window value) */
N#define  WWDG_CFR_W_0                        ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  WWDG_CFR_W_1                        ((uint16_t)0x0002)            /*!<Bit 1 */
N#define  WWDG_CFR_W_2                        ((uint16_t)0x0004)            /*!<Bit 2 */
N#define  WWDG_CFR_W_3                        ((uint16_t)0x0008)            /*!<Bit 3 */
N#define  WWDG_CFR_W_4                        ((uint16_t)0x0010)            /*!<Bit 4 */
N#define  WWDG_CFR_W_5                        ((uint16_t)0x0020)            /*!<Bit 5 */
N#define  WWDG_CFR_W_6                        ((uint16_t)0x0040)            /*!<Bit 6 */
N/* Legacy defines */
N#define  WWDG_CFR_W0                         WWDG_CFR_W_0
N#define  WWDG_CFR_W1                         WWDG_CFR_W_1
N#define  WWDG_CFR_W2                         WWDG_CFR_W_2
N#define  WWDG_CFR_W3                         WWDG_CFR_W_3
N#define  WWDG_CFR_W4                         WWDG_CFR_W_4
N#define  WWDG_CFR_W5                         WWDG_CFR_W_5
N#define  WWDG_CFR_W6                         WWDG_CFR_W_6
N
N#define  WWDG_CFR_WDGTB                      ((uint16_t)0x0180)            /*!<WDGTB[1:0] bits (Timer Base) */
N#define  WWDG_CFR_WDGTB_0                    ((uint16_t)0x0080)            /*!<Bit 0 */
N#define  WWDG_CFR_WDGTB_1                    ((uint16_t)0x0100)            /*!<Bit 1 */
N/* Legacy defines */
N#define  WWDG_CFR_WDGTB0                     WWDG_CFR_WDGTB_0
N#define  WWDG_CFR_WDGTB1                     WWDG_CFR_WDGTB_1
N
N#define  WWDG_CFR_EWI                        ((uint16_t)0x0200)            /*!<Early Wakeup Interrupt */
N
N/*******************  Bit definition for WWDG_SR register  ********************/
N#define  WWDG_SR_EWIF                        ((uint8_t)0x01)               /*!<Early Wakeup Interrupt Flag */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                                DBG                                         */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for DBGMCU_IDCODE register  *************/
N#define  DBGMCU_IDCODE_DEV_ID                ((uint32_t)0x00000FFF)
N#define  DBGMCU_IDCODE_REV_ID                ((uint32_t)0xFFFF0000)
N
N/********************  Bit definition for DBGMCU_CR register  *****************/
N#define  DBGMCU_CR_DBG_SLEEP                 ((uint32_t)0x00000001)
N#define  DBGMCU_CR_DBG_STOP                  ((uint32_t)0x00000002)
N#define  DBGMCU_CR_DBG_STANDBY               ((uint32_t)0x00000004)
N#define  DBGMCU_CR_TRACE_IOEN                ((uint32_t)0x00000020)
N
N#define  DBGMCU_CR_TRACE_MODE                ((uint32_t)0x000000C0)
N#define  DBGMCU_CR_TRACE_MODE_0              ((uint32_t)0x00000040)/*!<Bit 0 */
N#define  DBGMCU_CR_TRACE_MODE_1              ((uint32_t)0x00000080)/*!<Bit 1 */
N
N/********************  Bit definition for DBGMCU_APB1_FZ register  ************/
N#define  DBGMCU_APB1_FZ_DBG_TIM2_STOP            ((uint32_t)0x00000001)
N#define  DBGMCU_APB1_FZ_DBG_TIM3_STOP            ((uint32_t)0x00000002)
N#define  DBGMCU_APB1_FZ_DBG_TIM4_STOP            ((uint32_t)0x00000004)
N#define  DBGMCU_APB1_FZ_DBG_TIM5_STOP            ((uint32_t)0x00000008)
N#define  DBGMCU_APB1_FZ_DBG_TIM6_STOP            ((uint32_t)0x00000010)
N#define  DBGMCU_APB1_FZ_DBG_TIM7_STOP            ((uint32_t)0x00000020)
N#define  DBGMCU_APB1_FZ_DBG_TIM12_STOP           ((uint32_t)0x00000040)
N#define  DBGMCU_APB1_FZ_DBG_TIM13_STOP           ((uint32_t)0x00000080)
N#define  DBGMCU_APB1_FZ_DBG_TIM14_STOP           ((uint32_t)0x00000100)
N#define  DBGMCU_APB1_FZ_DBG_RTC_STOP             ((uint32_t)0x00000400)
N#define  DBGMCU_APB1_FZ_DBG_WWDG_STOP            ((uint32_t)0x00000800)
N#define  DBGMCU_APB1_FZ_DBG_IWDG_STOP            ((uint32_t)0x00001000)
N#define  DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT   ((uint32_t)0x00200000)
N#define  DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT   ((uint32_t)0x00400000)
N#define  DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT   ((uint32_t)0x00800000)
N#define  DBGMCU_APB1_FZ_DBG_CAN1_STOP            ((uint32_t)0x02000000)
N#define  DBGMCU_APB1_FZ_DBG_CAN2_STOP            ((uint32_t)0x04000000)
N/* Old IWDGSTOP bit definition, maintained for legacy purpose */
N#define  DBGMCU_APB1_FZ_DBG_IWDEG_STOP           DBGMCU_APB1_FZ_DBG_IWDG_STOP
N
N/********************  Bit definition for DBGMCU_APB1_FZ register  ************/
N#define  DBGMCU_APB1_FZ_DBG_TIM1_STOP        ((uint32_t)0x00000001)
N#define  DBGMCU_APB1_FZ_DBG_TIM8_STOP        ((uint32_t)0x00000002)
N#define  DBGMCU_APB1_FZ_DBG_TIM9_STOP        ((uint32_t)0x00010000)
N#define  DBGMCU_APB1_FZ_DBG_TIM10_STOP       ((uint32_t)0x00020000)
N#define  DBGMCU_APB1_FZ_DBG_TIM11_STOP       ((uint32_t)0x00040000)
N
N/******************************************************************************/
N/*                                                                            */
N/*                Ethernet MAC Registers bits definitions                     */
N/*                                                                            */
N/******************************************************************************/
N/* Bit definition for Ethernet MAC Control Register register */
N#define ETH_MACCR_WD      ((uint32_t)0x00800000)  /* Watchdog disable */
N#define ETH_MACCR_JD      ((uint32_t)0x00400000)  /* Jabber disable */
N#define ETH_MACCR_IFG     ((uint32_t)0x000E0000)  /* Inter-frame gap */
N#define ETH_MACCR_IFG_96Bit     ((uint32_t)0x00000000)  /* Minimum IFG between frames during transmission is 96Bit */
N  #define ETH_MACCR_IFG_88Bit     ((uint32_t)0x00020000)  /* Minimum IFG between frames during transmission is 88Bit */
N  #define ETH_MACCR_IFG_80Bit     ((uint32_t)0x00040000)  /* Minimum IFG between frames during transmission is 80Bit */
N  #define ETH_MACCR_IFG_72Bit     ((uint32_t)0x00060000)  /* Minimum IFG between frames during transmission is 72Bit */
N  #define ETH_MACCR_IFG_64Bit     ((uint32_t)0x00080000)  /* Minimum IFG between frames during transmission is 64Bit */        
N  #define ETH_MACCR_IFG_56Bit     ((uint32_t)0x000A0000)  /* Minimum IFG between frames during transmission is 56Bit */
N  #define ETH_MACCR_IFG_48Bit     ((uint32_t)0x000C0000)  /* Minimum IFG between frames during transmission is 48Bit */
N  #define ETH_MACCR_IFG_40Bit     ((uint32_t)0x000E0000)  /* Minimum IFG between frames during transmission is 40Bit */              
N#define ETH_MACCR_CSD     ((uint32_t)0x00010000)  /* Carrier sense disable (during transmission) */
N#define ETH_MACCR_FES     ((uint32_t)0x00004000)  /* Fast ethernet speed */
N#define ETH_MACCR_ROD     ((uint32_t)0x00002000)  /* Receive own disable */
N#define ETH_MACCR_LM      ((uint32_t)0x00001000)  /* loopback mode */
N#define ETH_MACCR_DM      ((uint32_t)0x00000800)  /* Duplex mode */
N#define ETH_MACCR_IPCO    ((uint32_t)0x00000400)  /* IP Checksum offload */
N#define ETH_MACCR_RD      ((uint32_t)0x00000200)  /* Retry disable */
N#define ETH_MACCR_APCS    ((uint32_t)0x00000080)  /* Automatic Pad/CRC stripping */
N#define ETH_MACCR_BL      ((uint32_t)0x00000060)  /* Back-off limit: random integer number (r) of slot time delays before rescheduling
N                                                       a transmission attempt during retries after a collision: 0 =< r <2^k */
N  #define ETH_MACCR_BL_10    ((uint32_t)0x00000000)  /* k = min (n, 10) */
N  #define ETH_MACCR_BL_8     ((uint32_t)0x00000020)  /* k = min (n, 8) */
N  #define ETH_MACCR_BL_4     ((uint32_t)0x00000040)  /* k = min (n, 4) */
N  #define ETH_MACCR_BL_1     ((uint32_t)0x00000060)  /* k = min (n, 1) */ 
N#define ETH_MACCR_DC      ((uint32_t)0x00000010)  /* Defferal check */
N#define ETH_MACCR_TE      ((uint32_t)0x00000008)  /* Transmitter enable */
N#define ETH_MACCR_RE      ((uint32_t)0x00000004)  /* Receiver enable */
N
N/* Bit definition for Ethernet MAC Frame Filter Register */
N#define ETH_MACFFR_RA     ((uint32_t)0x80000000)  /* Receive all */ 
N#define ETH_MACFFR_HPF    ((uint32_t)0x00000400)  /* Hash or perfect filter */ 
N#define ETH_MACFFR_SAF    ((uint32_t)0x00000200)  /* Source address filter enable */ 
N#define ETH_MACFFR_SAIF   ((uint32_t)0x00000100)  /* SA inverse filtering */ 
N#define ETH_MACFFR_PCF    ((uint32_t)0x000000C0)  /* Pass control frames: 3 cases */
N  #define ETH_MACFFR_PCF_BlockAll                ((uint32_t)0x00000040)  /* MAC filters all control frames from reaching the application */
N  #define ETH_MACFFR_PCF_ForwardAll              ((uint32_t)0x00000080)  /* MAC forwards all control frames to application even if they fail the Address Filter */
N  #define ETH_MACFFR_PCF_ForwardPassedAddrFilter ((uint32_t)0x000000C0)  /* MAC forwards control frames that pass the Address Filter. */ 
N#define ETH_MACFFR_BFD    ((uint32_t)0x00000020)  /* Broadcast frame disable */ 
N#define ETH_MACFFR_PAM    ((uint32_t)0x00000010)  /* Pass all mutlicast */ 
N#define ETH_MACFFR_DAIF   ((uint32_t)0x00000008)  /* DA Inverse filtering */ 
N#define ETH_MACFFR_HM     ((uint32_t)0x00000004)  /* Hash multicast */ 
N#define ETH_MACFFR_HU     ((uint32_t)0x00000002)  /* Hash unicast */
N#define ETH_MACFFR_PM     ((uint32_t)0x00000001)  /* Promiscuous mode */
N
N/* Bit definition for Ethernet MAC Hash Table High Register */
N#define ETH_MACHTHR_HTH   ((uint32_t)0xFFFFFFFF)  /* Hash table high */
N
N/* Bit definition for Ethernet MAC Hash Table Low Register */
N#define ETH_MACHTLR_HTL   ((uint32_t)0xFFFFFFFF)  /* Hash table low */
N
N/* Bit definition for Ethernet MAC MII Address Register */
N#define ETH_MACMIIAR_PA   ((uint32_t)0x0000F800)  /* Physical layer address */ 
N#define ETH_MACMIIAR_MR   ((uint32_t)0x000007C0)  /* MII register in the selected PHY */ 
N#define ETH_MACMIIAR_CR   ((uint32_t)0x0000001C)  /* CR clock range: 6 cases */ 
N  #define ETH_MACMIIAR_CR_Div42   ((uint32_t)0x00000000)  /* HCLK:60-100 MHz; MDC clock= HCLK/42 */
N  #define ETH_MACMIIAR_CR_Div62   ((uint32_t)0x00000004)  /* HCLK:100-150 MHz; MDC clock= HCLK/62 */
N  #define ETH_MACMIIAR_CR_Div16   ((uint32_t)0x00000008)  /* HCLK:20-35 MHz; MDC clock= HCLK/16 */
N  #define ETH_MACMIIAR_CR_Div26   ((uint32_t)0x0000000C)  /* HCLK:35-60 MHz; MDC clock= HCLK/26 */
N  #define ETH_MACMIIAR_CR_Div102  ((uint32_t)0x00000010)  /* HCLK:150-168 MHz; MDC clock= HCLK/102 */  
N#define ETH_MACMIIAR_MW   ((uint32_t)0x00000002)  /* MII write */ 
N#define ETH_MACMIIAR_MB   ((uint32_t)0x00000001)  /* MII busy */ 
N  
N/* Bit definition for Ethernet MAC MII Data Register */
N#define ETH_MACMIIDR_MD   ((uint32_t)0x0000FFFF)  /* MII data: read/write data from/to PHY */
N
N/* Bit definition for Ethernet MAC Flow Control Register */
N#define ETH_MACFCR_PT     ((uint32_t)0xFFFF0000)  /* Pause time */
N#define ETH_MACFCR_ZQPD   ((uint32_t)0x00000080)  /* Zero-quanta pause disable */
N#define ETH_MACFCR_PLT    ((uint32_t)0x00000030)  /* Pause low threshold: 4 cases */
N  #define ETH_MACFCR_PLT_Minus4   ((uint32_t)0x00000000)  /* Pause time minus 4 slot times */
N  #define ETH_MACFCR_PLT_Minus28  ((uint32_t)0x00000010)  /* Pause time minus 28 slot times */
N  #define ETH_MACFCR_PLT_Minus144 ((uint32_t)0x00000020)  /* Pause time minus 144 slot times */
N  #define ETH_MACFCR_PLT_Minus256 ((uint32_t)0x00000030)  /* Pause time minus 256 slot times */      
N#define ETH_MACFCR_UPFD   ((uint32_t)0x00000008)  /* Unicast pause frame detect */
N#define ETH_MACFCR_RFCE   ((uint32_t)0x00000004)  /* Receive flow control enable */
N#define ETH_MACFCR_TFCE   ((uint32_t)0x00000002)  /* Transmit flow control enable */
N#define ETH_MACFCR_FCBBPA ((uint32_t)0x00000001)  /* Flow control busy/backpressure activate */
N
N/* Bit definition for Ethernet MAC VLAN Tag Register */
N#define ETH_MACVLANTR_VLANTC ((uint32_t)0x00010000)  /* 12-bit VLAN tag comparison */
N#define ETH_MACVLANTR_VLANTI ((uint32_t)0x0000FFFF)  /* VLAN tag identifier (for receive frames) */
N
N/* Bit definition for Ethernet MAC Remote Wake-UpFrame Filter Register */ 
N#define ETH_MACRWUFFR_D   ((uint32_t)0xFFFFFFFF)  /* Wake-up frame filter register data */
N/* Eight sequential Writes to this address (offset 0x28) will write all Wake-UpFrame Filter Registers.
N   Eight sequential Reads from this address (offset 0x28) will read all Wake-UpFrame Filter Registers. */
N/* Wake-UpFrame Filter Reg0 : Filter 0 Byte Mask
N   Wake-UpFrame Filter Reg1 : Filter 1 Byte Mask
N   Wake-UpFrame Filter Reg2 : Filter 2 Byte Mask
N   Wake-UpFrame Filter Reg3 : Filter 3 Byte Mask
N   Wake-UpFrame Filter Reg4 : RSVD - Filter3 Command - RSVD - Filter2 Command - 
N                              RSVD - Filter1 Command - RSVD - Filter0 Command
N   Wake-UpFrame Filter Re5 : Filter3 Offset - Filter2 Offset - Filter1 Offset - Filter0 Offset
N   Wake-UpFrame Filter Re6 : Filter1 CRC16 - Filter0 CRC16
N   Wake-UpFrame Filter Re7 : Filter3 CRC16 - Filter2 CRC16 */
N
N/* Bit definition for Ethernet MAC PMT Control and Status Register */ 
N#define ETH_MACPMTCSR_WFFRPR ((uint32_t)0x80000000)  /* Wake-Up Frame Filter Register Pointer Reset */
N#define ETH_MACPMTCSR_GU     ((uint32_t)0x00000200)  /* Global Unicast */
N#define ETH_MACPMTCSR_WFR    ((uint32_t)0x00000040)  /* Wake-Up Frame Received */
N#define ETH_MACPMTCSR_MPR    ((uint32_t)0x00000020)  /* Magic Packet Received */
N#define ETH_MACPMTCSR_WFE    ((uint32_t)0x00000004)  /* Wake-Up Frame Enable */
N#define ETH_MACPMTCSR_MPE    ((uint32_t)0x00000002)  /* Magic Packet Enable */
N#define ETH_MACPMTCSR_PD     ((uint32_t)0x00000001)  /* Power Down */
N
N/* Bit definition for Ethernet MAC Status Register */
N#define ETH_MACSR_TSTS      ((uint32_t)0x00000200)  /* Time stamp trigger status */
N#define ETH_MACSR_MMCTS     ((uint32_t)0x00000040)  /* MMC transmit status */
N#define ETH_MACSR_MMMCRS    ((uint32_t)0x00000020)  /* MMC receive status */
N#define ETH_MACSR_MMCS      ((uint32_t)0x00000010)  /* MMC status */
N#define ETH_MACSR_PMTS      ((uint32_t)0x00000008)  /* PMT status */
N
N/* Bit definition for Ethernet MAC Interrupt Mask Register */
N#define ETH_MACIMR_TSTIM     ((uint32_t)0x00000200)  /* Time stamp trigger interrupt mask */
N#define ETH_MACIMR_PMTIM     ((uint32_t)0x00000008)  /* PMT interrupt mask */
N
N/* Bit definition for Ethernet MAC Address0 High Register */
N#define ETH_MACA0HR_MACA0H   ((uint32_t)0x0000FFFF)  /* MAC address0 high */
N
N/* Bit definition for Ethernet MAC Address0 Low Register */
N#define ETH_MACA0LR_MACA0L   ((uint32_t)0xFFFFFFFF)  /* MAC address0 low */
N
N/* Bit definition for Ethernet MAC Address1 High Register */
N#define ETH_MACA1HR_AE       ((uint32_t)0x80000000)  /* Address enable */
N#define ETH_MACA1HR_SA       ((uint32_t)0x40000000)  /* Source address */
N#define ETH_MACA1HR_MBC      ((uint32_t)0x3F000000)  /* Mask byte control: bits to mask for comparison of the MAC Address bytes */
N  #define ETH_MACA1HR_MBC_HBits15_8    ((uint32_t)0x20000000)  /* Mask MAC Address high reg bits [15:8] */
N  #define ETH_MACA1HR_MBC_HBits7_0     ((uint32_t)0x10000000)  /* Mask MAC Address high reg bits [7:0] */
N  #define ETH_MACA1HR_MBC_LBits31_24   ((uint32_t)0x08000000)  /* Mask MAC Address low reg bits [31:24] */
N  #define ETH_MACA1HR_MBC_LBits23_16   ((uint32_t)0x04000000)  /* Mask MAC Address low reg bits [23:16] */
N  #define ETH_MACA1HR_MBC_LBits15_8    ((uint32_t)0x02000000)  /* Mask MAC Address low reg bits [15:8] */
N  #define ETH_MACA1HR_MBC_LBits7_0     ((uint32_t)0x01000000)  /* Mask MAC Address low reg bits [7:0] */ 
N#define ETH_MACA1HR_MACA1H   ((uint32_t)0x0000FFFF)  /* MAC address1 high */
N
N/* Bit definition for Ethernet MAC Address1 Low Register */
N#define ETH_MACA1LR_MACA1L   ((uint32_t)0xFFFFFFFF)  /* MAC address1 low */
N
N/* Bit definition for Ethernet MAC Address2 High Register */
N#define ETH_MACA2HR_AE       ((uint32_t)0x80000000)  /* Address enable */
N#define ETH_MACA2HR_SA       ((uint32_t)0x40000000)  /* Source address */
N#define ETH_MACA2HR_MBC      ((uint32_t)0x3F000000)  /* Mask byte control */
N  #define ETH_MACA2HR_MBC_HBits15_8    ((uint32_t)0x20000000)  /* Mask MAC Address high reg bits [15:8] */
N  #define ETH_MACA2HR_MBC_HBits7_0     ((uint32_t)0x10000000)  /* Mask MAC Address high reg bits [7:0] */
N  #define ETH_MACA2HR_MBC_LBits31_24   ((uint32_t)0x08000000)  /* Mask MAC Address low reg bits [31:24] */
N  #define ETH_MACA2HR_MBC_LBits23_16   ((uint32_t)0x04000000)  /* Mask MAC Address low reg bits [23:16] */
N  #define ETH_MACA2HR_MBC_LBits15_8    ((uint32_t)0x02000000)  /* Mask MAC Address low reg bits [15:8] */
N  #define ETH_MACA2HR_MBC_LBits7_0     ((uint32_t)0x01000000)  /* Mask MAC Address low reg bits [70] */
N#define ETH_MACA2HR_MACA2H   ((uint32_t)0x0000FFFF)  /* MAC address1 high */
N
N/* Bit definition for Ethernet MAC Address2 Low Register */
N#define ETH_MACA2LR_MACA2L   ((uint32_t)0xFFFFFFFF)  /* MAC address2 low */
N
N/* Bit definition for Ethernet MAC Address3 High Register */
N#define ETH_MACA3HR_AE       ((uint32_t)0x80000000)  /* Address enable */
N#define ETH_MACA3HR_SA       ((uint32_t)0x40000000)  /* Source address */
N#define ETH_MACA3HR_MBC      ((uint32_t)0x3F000000)  /* Mask byte control */
N  #define ETH_MACA3HR_MBC_HBits15_8    ((uint32_t)0x20000000)  /* Mask MAC Address high reg bits [15:8] */
N  #define ETH_MACA3HR_MBC_HBits7_0     ((uint32_t)0x10000000)  /* Mask MAC Address high reg bits [7:0] */
N  #define ETH_MACA3HR_MBC_LBits31_24   ((uint32_t)0x08000000)  /* Mask MAC Address low reg bits [31:24] */
N  #define ETH_MACA3HR_MBC_LBits23_16   ((uint32_t)0x04000000)  /* Mask MAC Address low reg bits [23:16] */
N  #define ETH_MACA3HR_MBC_LBits15_8    ((uint32_t)0x02000000)  /* Mask MAC Address low reg bits [15:8] */
N  #define ETH_MACA3HR_MBC_LBits7_0     ((uint32_t)0x01000000)  /* Mask MAC Address low reg bits [70] */
N#define ETH_MACA3HR_MACA3H   ((uint32_t)0x0000FFFF)  /* MAC address3 high */
N
N/* Bit definition for Ethernet MAC Address3 Low Register */
N#define ETH_MACA3LR_MACA3L   ((uint32_t)0xFFFFFFFF)  /* MAC address3 low */
N
N/******************************************************************************/
N/*                Ethernet MMC Registers bits definition                      */
N/******************************************************************************/
N
N/* Bit definition for Ethernet MMC Contol Register */
N#define ETH_MMCCR_MCFHP      ((uint32_t)0x00000020)  /* MMC counter Full-Half preset */
N#define ETH_MMCCR_MCP        ((uint32_t)0x00000010)  /* MMC counter preset */
N#define ETH_MMCCR_MCF        ((uint32_t)0x00000008)  /* MMC Counter Freeze */
N#define ETH_MMCCR_ROR        ((uint32_t)0x00000004)  /* Reset on Read */
N#define ETH_MMCCR_CSR        ((uint32_t)0x00000002)  /* Counter Stop Rollover */
N#define ETH_MMCCR_CR         ((uint32_t)0x00000001)  /* Counters Reset */
N
N/* Bit definition for Ethernet MMC Receive Interrupt Register */
N#define ETH_MMCRIR_RGUFS     ((uint32_t)0x00020000)  /* Set when Rx good unicast frames counter reaches half the maximum value */
N#define ETH_MMCRIR_RFAES     ((uint32_t)0x00000040)  /* Set when Rx alignment error counter reaches half the maximum value */
N#define ETH_MMCRIR_RFCES     ((uint32_t)0x00000020)  /* Set when Rx crc error counter reaches half the maximum value */
N
N/* Bit definition for Ethernet MMC Transmit Interrupt Register */
N#define ETH_MMCTIR_TGFS      ((uint32_t)0x00200000)  /* Set when Tx good frame count counter reaches half the maximum value */
N#define ETH_MMCTIR_TGFMSCS   ((uint32_t)0x00008000)  /* Set when Tx good multi col counter reaches half the maximum value */
N#define ETH_MMCTIR_TGFSCS    ((uint32_t)0x00004000)  /* Set when Tx good single col counter reaches half the maximum value */
N
N/* Bit definition for Ethernet MMC Receive Interrupt Mask Register */
N#define ETH_MMCRIMR_RGUFM    ((uint32_t)0x00020000)  /* Mask the interrupt when Rx good unicast frames counter reaches half the maximum value */
N#define ETH_MMCRIMR_RFAEM    ((uint32_t)0x00000040)  /* Mask the interrupt when when Rx alignment error counter reaches half the maximum value */
N#define ETH_MMCRIMR_RFCEM    ((uint32_t)0x00000020)  /* Mask the interrupt when Rx crc error counter reaches half the maximum value */
N
N/* Bit definition for Ethernet MMC Transmit Interrupt Mask Register */
N#define ETH_MMCTIMR_TGFM     ((uint32_t)0x00200000)  /* Mask the interrupt when Tx good frame count counter reaches half the maximum value */
N#define ETH_MMCTIMR_TGFMSCM  ((uint32_t)0x00008000)  /* Mask the interrupt when Tx good multi col counter reaches half the maximum value */
N#define ETH_MMCTIMR_TGFSCM   ((uint32_t)0x00004000)  /* Mask the interrupt when Tx good single col counter reaches half the maximum value */
N
N/* Bit definition for Ethernet MMC Transmitted Good Frames after Single Collision Counter Register */
N#define ETH_MMCTGFSCCR_TGFSCC     ((uint32_t)0xFFFFFFFF)  /* Number of successfully transmitted frames after a single collision in Half-duplex mode. */
N
N/* Bit definition for Ethernet MMC Transmitted Good Frames after More than a Single Collision Counter Register */
N#define ETH_MMCTGFMSCCR_TGFMSCC   ((uint32_t)0xFFFFFFFF)  /* Number of successfully transmitted frames after more than a single collision in Half-duplex mode. */
N
N/* Bit definition for Ethernet MMC Transmitted Good Frames Counter Register */
N#define ETH_MMCTGFCR_TGFC    ((uint32_t)0xFFFFFFFF)  /* Number of good frames transmitted. */
N
N/* Bit definition for Ethernet MMC Received Frames with CRC Error Counter Register */
N#define ETH_MMCRFCECR_RFCEC  ((uint32_t)0xFFFFFFFF)  /* Number of frames received with CRC error. */
N
N/* Bit definition for Ethernet MMC Received Frames with Alignement Error Counter Register */
N#define ETH_MMCRFAECR_RFAEC  ((uint32_t)0xFFFFFFFF)  /* Number of frames received with alignment (dribble) error */
N
N/* Bit definition for Ethernet MMC Received Good Unicast Frames Counter Register */
N#define ETH_MMCRGUFCR_RGUFC  ((uint32_t)0xFFFFFFFF)  /* Number of good unicast frames received. */
N
N/******************************************************************************/
N/*               Ethernet PTP Registers bits definition                       */
N/******************************************************************************/
N
N/* Bit definition for Ethernet PTP Time Stamp Contol Register */
N#define ETH_PTPTSCR_TSCNT       ((uint32_t)0x00030000)  /* Time stamp clock node type */
N#define ETH_PTPTSSR_TSSMRME     ((uint32_t)0x00008000)  /* Time stamp snapshot for message relevant to master enable */
N#define ETH_PTPTSSR_TSSEME      ((uint32_t)0x00004000)  /* Time stamp snapshot for event message enable */
N#define ETH_PTPTSSR_TSSIPV4FE   ((uint32_t)0x00002000)  /* Time stamp snapshot for IPv4 frames enable */
N#define ETH_PTPTSSR_TSSIPV6FE   ((uint32_t)0x00001000)  /* Time stamp snapshot for IPv6 frames enable */
N#define ETH_PTPTSSR_TSSPTPOEFE  ((uint32_t)0x00000800)  /* Time stamp snapshot for PTP over ethernet frames enable */
N#define ETH_PTPTSSR_TSPTPPSV2E  ((uint32_t)0x00000400)  /* Time stamp PTP packet snooping for version2 format enable */
N#define ETH_PTPTSSR_TSSSR       ((uint32_t)0x00000200)  /* Time stamp Sub-seconds rollover */
N#define ETH_PTPTSSR_TSSARFE     ((uint32_t)0x00000100)  /* Time stamp snapshot for all received frames enable */
N
N#define ETH_PTPTSCR_TSARU    ((uint32_t)0x00000020)  /* Addend register update */
N#define ETH_PTPTSCR_TSITE    ((uint32_t)0x00000010)  /* Time stamp interrupt trigger enable */
N#define ETH_PTPTSCR_TSSTU    ((uint32_t)0x00000008)  /* Time stamp update */
N#define ETH_PTPTSCR_TSSTI    ((uint32_t)0x00000004)  /* Time stamp initialize */
N#define ETH_PTPTSCR_TSFCU    ((uint32_t)0x00000002)  /* Time stamp fine or coarse update */
N#define ETH_PTPTSCR_TSE      ((uint32_t)0x00000001)  /* Time stamp enable */
N
N/* Bit definition for Ethernet PTP Sub-Second Increment Register */
N#define ETH_PTPSSIR_STSSI    ((uint32_t)0x000000FF)  /* System time Sub-second increment value */
N
N/* Bit definition for Ethernet PTP Time Stamp High Register */
N#define ETH_PTPTSHR_STS      ((uint32_t)0xFFFFFFFF)  /* System Time second */
N
N/* Bit definition for Ethernet PTP Time Stamp Low Register */
N#define ETH_PTPTSLR_STPNS    ((uint32_t)0x80000000)  /* System Time Positive or negative time */
N#define ETH_PTPTSLR_STSS     ((uint32_t)0x7FFFFFFF)  /* System Time sub-seconds */
N
N/* Bit definition for Ethernet PTP Time Stamp High Update Register */
N#define ETH_PTPTSHUR_TSUS    ((uint32_t)0xFFFFFFFF)  /* Time stamp update seconds */
N
N/* Bit definition for Ethernet PTP Time Stamp Low Update Register */
N#define ETH_PTPTSLUR_TSUPNS  ((uint32_t)0x80000000)  /* Time stamp update Positive or negative time */
N#define ETH_PTPTSLUR_TSUSS   ((uint32_t)0x7FFFFFFF)  /* Time stamp update sub-seconds */
N
N/* Bit definition for Ethernet PTP Time Stamp Addend Register */
N#define ETH_PTPTSAR_TSA      ((uint32_t)0xFFFFFFFF)  /* Time stamp addend */
N
N/* Bit definition for Ethernet PTP Target Time High Register */
N#define ETH_PTPTTHR_TTSH     ((uint32_t)0xFFFFFFFF)  /* Target time stamp high */
N
N/* Bit definition for Ethernet PTP Target Time Low Register */
N#define ETH_PTPTTLR_TTSL     ((uint32_t)0xFFFFFFFF)  /* Target time stamp low */
N
N/* Bit definition for Ethernet PTP Time Stamp Status Register */
N#define ETH_PTPTSSR_TSTTR    ((uint32_t)0x00000020)  /* Time stamp target time reached */
N#define ETH_PTPTSSR_TSSO     ((uint32_t)0x00000010)  /* Time stamp seconds overflow */
N
N/******************************************************************************/
N/*                 Ethernet DMA Registers bits definition                     */
N/******************************************************************************/
N
N/* Bit definition for Ethernet DMA Bus Mode Register */
N#define ETH_DMABMR_AAB       ((uint32_t)0x02000000)  /* Address-Aligned beats */
N#define ETH_DMABMR_FPM        ((uint32_t)0x01000000)  /* 4xPBL mode */
N#define ETH_DMABMR_USP       ((uint32_t)0x00800000)  /* Use separate PBL */
N#define ETH_DMABMR_RDP       ((uint32_t)0x007E0000)  /* RxDMA PBL */
N  #define ETH_DMABMR_RDP_1Beat    ((uint32_t)0x00020000)  /* maximum number of beats to be transferred in one RxDMA transaction is 1 */
N  #define ETH_DMABMR_RDP_2Beat    ((uint32_t)0x00040000)  /* maximum number of beats to be transferred in one RxDMA transaction is 2 */
N  #define ETH_DMABMR_RDP_4Beat    ((uint32_t)0x00080000)  /* maximum number of beats to be transferred in one RxDMA transaction is 4 */
N  #define ETH_DMABMR_RDP_8Beat    ((uint32_t)0x00100000)  /* maximum number of beats to be transferred in one RxDMA transaction is 8 */
N  #define ETH_DMABMR_RDP_16Beat   ((uint32_t)0x00200000)  /* maximum number of beats to be transferred in one RxDMA transaction is 16 */
N  #define ETH_DMABMR_RDP_32Beat   ((uint32_t)0x00400000)  /* maximum number of beats to be transferred in one RxDMA transaction is 32 */                
N  #define ETH_DMABMR_RDP_4xPBL_4Beat   ((uint32_t)0x01020000)  /* maximum number of beats to be transferred in one RxDMA transaction is 4 */
N  #define ETH_DMABMR_RDP_4xPBL_8Beat   ((uint32_t)0x01040000)  /* maximum number of beats to be transferred in one RxDMA transaction is 8 */
N  #define ETH_DMABMR_RDP_4xPBL_16Beat  ((uint32_t)0x01080000)  /* maximum number of beats to be transferred in one RxDMA transaction is 16 */
N  #define ETH_DMABMR_RDP_4xPBL_32Beat  ((uint32_t)0x01100000)  /* maximum number of beats to be transferred in one RxDMA transaction is 32 */
N  #define ETH_DMABMR_RDP_4xPBL_64Beat  ((uint32_t)0x01200000)  /* maximum number of beats to be transferred in one RxDMA transaction is 64 */
N  #define ETH_DMABMR_RDP_4xPBL_128Beat ((uint32_t)0x01400000)  /* maximum number of beats to be transferred in one RxDMA transaction is 128 */  
N#define ETH_DMABMR_FB        ((uint32_t)0x00010000)  /* Fixed Burst */
N#define ETH_DMABMR_RTPR      ((uint32_t)0x0000C000)  /* Rx Tx priority ratio */
N  #define ETH_DMABMR_RTPR_1_1     ((uint32_t)0x00000000)  /* Rx Tx priority ratio */
N  #define ETH_DMABMR_RTPR_2_1     ((uint32_t)0x00004000)  /* Rx Tx priority ratio */
N  #define ETH_DMABMR_RTPR_3_1     ((uint32_t)0x00008000)  /* Rx Tx priority ratio */
N  #define ETH_DMABMR_RTPR_4_1     ((uint32_t)0x0000C000)  /* Rx Tx priority ratio */  
N#define ETH_DMABMR_PBL    ((uint32_t)0x00003F00)  /* Programmable burst length */
N  #define ETH_DMABMR_PBL_1Beat    ((uint32_t)0x00000100)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 1 */
N  #define ETH_DMABMR_PBL_2Beat    ((uint32_t)0x00000200)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 2 */
N  #define ETH_DMABMR_PBL_4Beat    ((uint32_t)0x00000400)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */
N  #define ETH_DMABMR_PBL_8Beat    ((uint32_t)0x00000800)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */
N  #define ETH_DMABMR_PBL_16Beat   ((uint32_t)0x00001000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */
N  #define ETH_DMABMR_PBL_32Beat   ((uint32_t)0x00002000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */                
N  #define ETH_DMABMR_PBL_4xPBL_4Beat   ((uint32_t)0x01000100)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */
N  #define ETH_DMABMR_PBL_4xPBL_8Beat   ((uint32_t)0x01000200)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */
N  #define ETH_DMABMR_PBL_4xPBL_16Beat  ((uint32_t)0x01000400)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */
N  #define ETH_DMABMR_PBL_4xPBL_32Beat  ((uint32_t)0x01000800)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */
N  #define ETH_DMABMR_PBL_4xPBL_64Beat  ((uint32_t)0x01001000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 64 */
N  #define ETH_DMABMR_PBL_4xPBL_128Beat ((uint32_t)0x01002000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 128 */
N#define ETH_DMABMR_EDE       ((uint32_t)0x00000080)  /* Enhanced Descriptor Enable */
N#define ETH_DMABMR_DSL       ((uint32_t)0x0000007C)  /* Descriptor Skip Length */
N#define ETH_DMABMR_DA        ((uint32_t)0x00000002)  /* DMA arbitration scheme */
N#define ETH_DMABMR_SR        ((uint32_t)0x00000001)  /* Software reset */
N
N/* Bit definition for Ethernet DMA Transmit Poll Demand Register */
N#define ETH_DMATPDR_TPD      ((uint32_t)0xFFFFFFFF)  /* Transmit poll demand */
N
N/* Bit definition for Ethernet DMA Receive Poll Demand Register */
N#define ETH_DMARPDR_RPD      ((uint32_t)0xFFFFFFFF)  /* Receive poll demand  */
N
N/* Bit definition for Ethernet DMA Receive Descriptor List Address Register */
N#define ETH_DMARDLAR_SRL     ((uint32_t)0xFFFFFFFF)  /* Start of receive list */
N
N/* Bit definition for Ethernet DMA Transmit Descriptor List Address Register */
N#define ETH_DMATDLAR_STL     ((uint32_t)0xFFFFFFFF)  /* Start of transmit list */
N
N/* Bit definition for Ethernet DMA Status Register */
N#define ETH_DMASR_TSTS       ((uint32_t)0x20000000)  /* Time-stamp trigger status */
N#define ETH_DMASR_PMTS       ((uint32_t)0x10000000)  /* PMT status */
N#define ETH_DMASR_MMCS       ((uint32_t)0x08000000)  /* MMC status */
N#define ETH_DMASR_EBS        ((uint32_t)0x03800000)  /* Error bits status */
N  /* combination with EBS[2:0] for GetFlagStatus function */
N  #define ETH_DMASR_EBS_DescAccess      ((uint32_t)0x02000000)  /* Error bits 0-data buffer, 1-desc. access */
N  #define ETH_DMASR_EBS_ReadTransf      ((uint32_t)0x01000000)  /* Error bits 0-write trnsf, 1-read transfr */
N  #define ETH_DMASR_EBS_DataTransfTx    ((uint32_t)0x00800000)  /* Error bits 0-Rx DMA, 1-Tx DMA */
N#define ETH_DMASR_TPS         ((uint32_t)0x00700000)  /* Transmit process state */
N  #define ETH_DMASR_TPS_Stopped         ((uint32_t)0x00000000)  /* Stopped - Reset or Stop Tx Command issued  */
N  #define ETH_DMASR_TPS_Fetching        ((uint32_t)0x00100000)  /* Running - fetching the Tx descriptor */
N  #define ETH_DMASR_TPS_Waiting         ((uint32_t)0x00200000)  /* Running - waiting for status */
N  #define ETH_DMASR_TPS_Reading         ((uint32_t)0x00300000)  /* Running - reading the data from host memory */
N  #define ETH_DMASR_TPS_Suspended       ((uint32_t)0x00600000)  /* Suspended - Tx Descriptor unavailabe */
N  #define ETH_DMASR_TPS_Closing         ((uint32_t)0x00700000)  /* Running - closing Rx descriptor */
N#define ETH_DMASR_RPS         ((uint32_t)0x000E0000)  /* Receive process state */
N  #define ETH_DMASR_RPS_Stopped         ((uint32_t)0x00000000)  /* Stopped - Reset or Stop Rx Command issued */
N  #define ETH_DMASR_RPS_Fetching        ((uint32_t)0x00020000)  /* Running - fetching the Rx descriptor */
N  #define ETH_DMASR_RPS_Waiting         ((uint32_t)0x00060000)  /* Running - waiting for packet */
N  #define ETH_DMASR_RPS_Suspended       ((uint32_t)0x00080000)  /* Suspended - Rx Descriptor unavailable */
N  #define ETH_DMASR_RPS_Closing         ((uint32_t)0x000A0000)  /* Running - closing descriptor */
N  #define ETH_DMASR_RPS_Queuing         ((uint32_t)0x000E0000)  /* Running - queuing the recieve frame into host memory */
N#define ETH_DMASR_NIS        ((uint32_t)0x00010000)  /* Normal interrupt summary */
N#define ETH_DMASR_AIS        ((uint32_t)0x00008000)  /* Abnormal interrupt summary */
N#define ETH_DMASR_ERS        ((uint32_t)0x00004000)  /* Early receive status */
N#define ETH_DMASR_FBES       ((uint32_t)0x00002000)  /* Fatal bus error status */
N#define ETH_DMASR_ETS        ((uint32_t)0x00000400)  /* Early transmit status */
N#define ETH_DMASR_RWTS       ((uint32_t)0x00000200)  /* Receive watchdog timeout status */
N#define ETH_DMASR_RPSS       ((uint32_t)0x00000100)  /* Receive process stopped status */
N#define ETH_DMASR_RBUS       ((uint32_t)0x00000080)  /* Receive buffer unavailable status */
N#define ETH_DMASR_RS         ((uint32_t)0x00000040)  /* Receive status */
N#define ETH_DMASR_TUS        ((uint32_t)0x00000020)  /* Transmit underflow status */
N#define ETH_DMASR_ROS        ((uint32_t)0x00000010)  /* Receive overflow status */
N#define ETH_DMASR_TJTS       ((uint32_t)0x00000008)  /* Transmit jabber timeout status */
N#define ETH_DMASR_TBUS       ((uint32_t)0x00000004)  /* Transmit buffer unavailable status */
N#define ETH_DMASR_TPSS       ((uint32_t)0x00000002)  /* Transmit process stopped status */
N#define ETH_DMASR_TS         ((uint32_t)0x00000001)  /* Transmit status */
N
N/* Bit definition for Ethernet DMA Operation Mode Register */
N#define ETH_DMAOMR_DTCEFD    ((uint32_t)0x04000000)  /* Disable Dropping of TCP/IP checksum error frames */
N#define ETH_DMAOMR_RSF       ((uint32_t)0x02000000)  /* Receive store and forward */
N#define ETH_DMAOMR_DFRF      ((uint32_t)0x01000000)  /* Disable flushing of received frames */
N#define ETH_DMAOMR_TSF       ((uint32_t)0x00200000)  /* Transmit store and forward */
N#define ETH_DMAOMR_FTF       ((uint32_t)0x00100000)  /* Flush transmit FIFO */
N#define ETH_DMAOMR_TTC       ((uint32_t)0x0001C000)  /* Transmit threshold control */
N  #define ETH_DMAOMR_TTC_64Bytes       ((uint32_t)0x00000000)  /* threshold level of the MTL Transmit FIFO is 64 Bytes */
N  #define ETH_DMAOMR_TTC_128Bytes      ((uint32_t)0x00004000)  /* threshold level of the MTL Transmit FIFO is 128 Bytes */
N  #define ETH_DMAOMR_TTC_192Bytes      ((uint32_t)0x00008000)  /* threshold level of the MTL Transmit FIFO is 192 Bytes */
N  #define ETH_DMAOMR_TTC_256Bytes      ((uint32_t)0x0000C000)  /* threshold level of the MTL Transmit FIFO is 256 Bytes */
N  #define ETH_DMAOMR_TTC_40Bytes       ((uint32_t)0x00010000)  /* threshold level of the MTL Transmit FIFO is 40 Bytes */
N  #define ETH_DMAOMR_TTC_32Bytes       ((uint32_t)0x00014000)  /* threshold level of the MTL Transmit FIFO is 32 Bytes */
N  #define ETH_DMAOMR_TTC_24Bytes       ((uint32_t)0x00018000)  /* threshold level of the MTL Transmit FIFO is 24 Bytes */
N  #define ETH_DMAOMR_TTC_16Bytes       ((uint32_t)0x0001C000)  /* threshold level of the MTL Transmit FIFO is 16 Bytes */
N#define ETH_DMAOMR_ST        ((uint32_t)0x00002000)  /* Start/stop transmission command */
N#define ETH_DMAOMR_FEF       ((uint32_t)0x00000080)  /* Forward error frames */
N#define ETH_DMAOMR_FUGF      ((uint32_t)0x00000040)  /* Forward undersized good frames */
N#define ETH_DMAOMR_RTC       ((uint32_t)0x00000018)  /* receive threshold control */
N  #define ETH_DMAOMR_RTC_64Bytes       ((uint32_t)0x00000000)  /* threshold level of the MTL Receive FIFO is 64 Bytes */
N  #define ETH_DMAOMR_RTC_32Bytes       ((uint32_t)0x00000008)  /* threshold level of the MTL Receive FIFO is 32 Bytes */
N  #define ETH_DMAOMR_RTC_96Bytes       ((uint32_t)0x00000010)  /* threshold level of the MTL Receive FIFO is 96 Bytes */
N  #define ETH_DMAOMR_RTC_128Bytes      ((uint32_t)0x00000018)  /* threshold level of the MTL Receive FIFO is 128 Bytes */
N#define ETH_DMAOMR_OSF       ((uint32_t)0x00000004)  /* operate on second frame */
N#define ETH_DMAOMR_SR        ((uint32_t)0x00000002)  /* Start/stop receive */
N
N/* Bit definition for Ethernet DMA Interrupt Enable Register */
N#define ETH_DMAIER_NISE      ((uint32_t)0x00010000)  /* Normal interrupt summary enable */
N#define ETH_DMAIER_AISE      ((uint32_t)0x00008000)  /* Abnormal interrupt summary enable */
N#define ETH_DMAIER_ERIE      ((uint32_t)0x00004000)  /* Early receive interrupt enable */
N#define ETH_DMAIER_FBEIE     ((uint32_t)0x00002000)  /* Fatal bus error interrupt enable */
N#define ETH_DMAIER_ETIE      ((uint32_t)0x00000400)  /* Early transmit interrupt enable */
N#define ETH_DMAIER_RWTIE     ((uint32_t)0x00000200)  /* Receive watchdog timeout interrupt enable */
N#define ETH_DMAIER_RPSIE     ((uint32_t)0x00000100)  /* Receive process stopped interrupt enable */
N#define ETH_DMAIER_RBUIE     ((uint32_t)0x00000080)  /* Receive buffer unavailable interrupt enable */
N#define ETH_DMAIER_RIE       ((uint32_t)0x00000040)  /* Receive interrupt enable */
N#define ETH_DMAIER_TUIE      ((uint32_t)0x00000020)  /* Transmit Underflow interrupt enable */
N#define ETH_DMAIER_ROIE      ((uint32_t)0x00000010)  /* Receive Overflow interrupt enable */
N#define ETH_DMAIER_TJTIE     ((uint32_t)0x00000008)  /* Transmit jabber timeout interrupt enable */
N#define ETH_DMAIER_TBUIE     ((uint32_t)0x00000004)  /* Transmit buffer unavailable interrupt enable */
N#define ETH_DMAIER_TPSIE     ((uint32_t)0x00000002)  /* Transmit process stopped interrupt enable */
N#define ETH_DMAIER_TIE       ((uint32_t)0x00000001)  /* Transmit interrupt enable */
N
N/* Bit definition for Ethernet DMA Missed Frame and Buffer Overflow Counter Register */
N#define ETH_DMAMFBOCR_OFOC   ((uint32_t)0x10000000)  /* Overflow bit for FIFO overflow counter */
N#define ETH_DMAMFBOCR_MFA    ((uint32_t)0x0FFE0000)  /* Number of frames missed by the application */
N#define ETH_DMAMFBOCR_OMFC   ((uint32_t)0x00010000)  /* Overflow bit for missed frame counter */
N#define ETH_DMAMFBOCR_MFC    ((uint32_t)0x0000FFFF)  /* Number of frames missed by the controller */
N
N/* Bit definition for Ethernet DMA Current Host Transmit Descriptor Register */
N#define ETH_DMACHTDR_HTDAP   ((uint32_t)0xFFFFFFFF)  /* Host transmit descriptor address pointer */
N
N/* Bit definition for Ethernet DMA Current Host Receive Descriptor Register */
N#define ETH_DMACHRDR_HRDAP   ((uint32_t)0xFFFFFFFF)  /* Host receive descriptor address pointer */
N
N/* Bit definition for Ethernet DMA Current Host Transmit Buffer Address Register */
N#define ETH_DMACHTBAR_HTBAP  ((uint32_t)0xFFFFFFFF)  /* Host transmit buffer address pointer */
N
N/* Bit definition for Ethernet DMA Current Host Receive Buffer Address Register */
N#define ETH_DMACHRBAR_HRBAP  ((uint32_t)0xFFFFFFFF)  /* Host receive buffer address pointer */
N
N/**
N  *
N  */
N
N /**
N  * @}
N  */ 
N
N#ifdef USE_STDPERIPH_DRIVER
N  #include "stm32f4xx_conf.h"
L 1 "..\..\Service\stm32f4xx_conf.h" 1
N/**
N  ******************************************************************************
N  * @file    Project/STM32F4xx_StdPeriph_Templates/stm32f4xx_conf.h  
N  * @author  MCD Application Team
N  * @version V1.5.0
N  * @date    06-March-2015
N  * @brief   Library configuration file.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_CONF_H
N#define __STM32F4xx_CONF_H
N
N/* Includes ------------------------------------------------------------------*/
N/* Uncomment the line below to enable peripheral header file inclusion */
N#include "stm32f4xx_adc.h"
L 1 "..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\stm32f4xx_adc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_adc.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    04-November-2016
N  * @brief   This file contains all the functions prototypes for the ADC firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_ADC_H
N#define __STM32F4xx_ADC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
L 1 "..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include\stm32f4xx.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    09-November-2016
N  * @brief   CMSIS Cortex-M4 Device Peripheral Access Layer Header File. 
N  *          This file contains all the peripheral register's definitions, bits 
N  *          definitions and memory mapping for STM32F4xx devices.            
N  *            
N  *          The file is the unique include file that the application programmer
N  *          is using in the C source code, usually in main.c. This file contains:
N  *           - Configuration section that allows to select:
N  *              - The device used in the target application
N  *              - To use or not the peripherals drivers in application code(i.e. 
N  *                code will be based on direct access to peripherals registers 
N  *                rather than drivers API), this option is controlled by 
N  *                "#define USE_STDPERIPH_DRIVER"
N  *              - To change few application-specific parameters such as the HSE 
N  *                crystal frequency
N  *           - Data structures and the address mapping for all peripherals
N  *           - Peripherals registers declarations and bits definition
N  *           - Macros to access peripherals registers hardware
N  *  
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************  
N  */ 
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup stm32f4xx
N  * @{
N  */
N    
N#ifndef __STM32F4xx_H
S#define __STM32F4xx_H
S
S#ifdef __cplusplus
S extern "C" {
S#endif /* __cplusplus */
S  
S/** @addtogroup Library_configuration_section
S  * @{
S  */
S  
S/* Uncomment the line below according to the target STM32 device used in your
S   application 
S  */
S
S#if !defined(STM32F40_41xxx) && !defined(STM32F427_437xx) && !defined(STM32F429_439xx) && !defined(STM32F401xx) && !defined(STM32F410xx) && \
S    !defined(STM32F411xE) && !defined(STM32F412xG) && !defined(STM32F413_423xx) && !defined(STM32F446xx) && !defined(STM32F469_479xx)
X#if !defined(STM32F40_41xxx) && !defined(STM32F427_437xx) && !defined(STM32F429_439xx) && !defined(STM32F401xx) && !defined(STM32F410xx) &&     !defined(STM32F411xE) && !defined(STM32F412xG) && !defined(STM32F413_423xx) && !defined(STM32F446xx) && !defined(STM32F469_479xx)
S  #define STM32F40_41xxx    /*!< STM32F405RG, STM32F405VG, STM32F405ZG, STM32F415RG, STM32F415VG, STM32F415ZG,
S                                      STM32F407VG, STM32F407VE, STM32F407ZG, STM32F407ZE, STM32F407IG, STM32F407IE, 
S                                      STM32F417VG, STM32F417VE, STM32F417ZG, STM32F417ZE, STM32F417IG and STM32F417IE Devices */
S
S  /* #define STM32F427_437xx */  /*!< STM32F427VG, STM32F427VI, STM32F427ZG, STM32F427ZI, STM32F427IG, STM32F427II,
S                                      STM32F437VG, STM32F437VI, STM32F437ZG, STM32F437ZI, STM32F437IG, STM32F437II Devices */
S
S  /* #define STM32F429_439xx */  /*!< STM32F429VG, STM32F429VI, STM32F429ZG, STM32F429ZI, STM32F429BG, STM32F429BI,
S                                      STM32F429NG, STM32F439NI, STM32F429IG, STM32F429II, STM32F439VG, STM32F439VI,
S                                      STM32F439ZG, STM32F439ZI, STM32F439BG, STM32F439BI, STM32F439NG, STM32F439NI,
S                                      STM32F439IG and STM32F439II Devices */
S
S  /* #define STM32F401xx */      /*!< STM32F401CB, STM32F401CC,  STM32F401RB, STM32F401RC, STM32F401VB, STM32F401VC,
S                                      STM32F401CD, STM32F401RD, STM32F401VD, STM32F401CExx, STM32F401RE and STM32F401VE Devices */
S
S  /* #define STM32F410xx */      /*!< STM32F410Tx, STM32F410Cx and STM32F410Rx */
S
S  /* #define STM32F411xE */      /*!< STM32F411CC, STM32F411RC, STM32F411VC, STM32F411CE, STM32F411RE and STM32F411VE Devices */
S
S  /* #define STM32F412xG */      /*!< STM32F412CEU, STM32F412CGU, STM32F412ZET, STM32F412ZGT, STM32F412ZEJ, STM32F412ZGJ,
S                                      STM32F412VET, STM32F412VGT, STM32F412VEH, STM32F412VGH, STM32F412RET, STM32F412RGT,
S                                      STM32F412REY and STM32F412RGY Devices */
S                                      
S  /* #define STM32F413_423xx */  /*!< STM32F413CGU, STM32F413CHU, STM32F413MGY, STM32F413MHY, STM32F413RGT, STM32F413VGT,
S                                      STM32F413ZGT, STM32F413RHT, STM32F413VHT, STM32F413ZHT, STM32F413VGH, STM32F413ZGJ,
S                                      STM32F413VHH, STM32F413ZHJ, STM32F423CHU, STM32F423RHT, STM32F423VHT, STM32F423ZHT,
S                                      STM32F423VHH and STM32F423ZHJ devices */
S
S  /* #define STM32F446xx */      /*!< STM32F446MC, STM32F446ME, STM32F446RC, STM32F446RE, STM32F446VC, STM32F446VE, STM32F446ZC 
S                                      and STM32F446ZE Devices */
S
S  /* #define STM32F469_479xx */  /*!< STM32F479AI, STM32F479II, STM32F479BI, STM32F479NI, STM32F479AG, STM32F479IG, STM32F479BG,
S                                      STM32F479NG, STM32F479AE, STM32F479IE, STM32F479BE, STM32F479NE Devices */
S
S#endif /* STM32F40_41xxx && STM32F427_437xx && STM32F429_439xx && STM32F401xx && STM32F410xx && STM32F411xE && STM32F412xG && STM32F413_423xx && STM32F446xx && STM32F469_479xx */
S
S/* Old STM32F40XX definition, maintained for legacy purpose */
S#ifdef STM32F40XX
S  #define STM32F40_41xxx
S#endif /* STM32F40XX */
S
S/* Old STM32F427X definition, maintained for legacy purpose */
S#ifdef STM32F427X
S  #define STM32F427_437xx
S#endif /* STM32F427X */
S
S/*  Tip: To avoid modifying this file each time you need to switch between these
S        devices, you can define the device in your toolchain compiler preprocessor.
S  */
S
S#if !defined(STM32F40_41xxx) && !defined(STM32F427_437xx) && !defined(STM32F429_439xx) && !defined(STM32F401xx) && !defined(STM32F410xx) && \
S    !defined(STM32F411xE) && !defined(STM32F412xG) && !defined(STM32F413_423xx) && !defined(STM32F446xx) && !defined(STM32F469_479xx)
X#if !defined(STM32F40_41xxx) && !defined(STM32F427_437xx) && !defined(STM32F429_439xx) && !defined(STM32F401xx) && !defined(STM32F410xx) &&     !defined(STM32F411xE) && !defined(STM32F412xG) && !defined(STM32F413_423xx) && !defined(STM32F446xx) && !defined(STM32F469_479xx)
S #error "Please select first the target STM32F4xx device used in your application (in stm32f4xx.h file)"
S#endif /* STM32F40_41xxx && STM32F427_437xx && STM32F429_439xx && STM32F401xx && STM32F410xx && STM32F411xE && STM32F412xG && STM32F413_23xx && STM32F446xx && STM32F469_479xx */
S
S#if !defined  (USE_STDPERIPH_DRIVER)
S/**
S * @brief Comment the line below if you will not use the peripherals drivers.
S   In this case, these drivers will not be included and the application code will 
S   be based on direct access to peripherals registers 
S   */
S  /*#define USE_STDPERIPH_DRIVER */
S#endif /* USE_STDPERIPH_DRIVER */
S
S/**
S * @brief In the following line adjust the value of External High Speed oscillator (HSE)
S   used in your application 
S   
S   Tip: To avoid modifying this file each time you need to use different HSE, you
S        can define the HSE value in your toolchain compiler preprocessor.
S  */           
S#if defined(STM32F40_41xxx) || defined(STM32F427_437xx)  || defined(STM32F429_439xx) || defined(STM32F401xx) || \
S    defined(STM32F410xx) || defined(STM32F411xE) || defined(STM32F469_479xx)
X#if defined(STM32F40_41xxx) || defined(STM32F427_437xx)  || defined(STM32F429_439xx) || defined(STM32F401xx) ||     defined(STM32F410xx) || defined(STM32F411xE) || defined(STM32F469_479xx)
S #if !defined  (HSE_VALUE) 
S  #define HSE_VALUE    ((uint32_t)25000000) /*!< Value of the External oscillator in Hz */
S #endif /* HSE_VALUE */
S#elif defined (STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
S #if !defined  (HSE_VALUE) 
S  #define HSE_VALUE    ((uint32_t)8000000) /*!< Value of the External oscillator in Hz */
S #endif /* HSE_VALUE */
S#endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F401xx || STM32F411xE || STM32F469_479xx */
S/**
S * @brief In the following line adjust the External High Speed oscillator (HSE) Startup 
S   Timeout value 
S   */
S#if !defined  (HSE_STARTUP_TIMEOUT) 
S  #define HSE_STARTUP_TIMEOUT    ((uint16_t)0x05000)   /*!< Time out for HSE start up */
S#endif /* HSE_STARTUP_TIMEOUT */   
S
S#if !defined  (HSI_VALUE)   
S  #define HSI_VALUE    ((uint32_t)16000000) /*!< Value of the Internal oscillator in Hz*/
S#endif /* HSI_VALUE */   
S
S/**
S * @brief STM32F4XX Standard Peripherals Library version number V1.8.0
S   */
S#define __STM32F4XX_STDPERIPH_VERSION_MAIN   (0x01) /*!< [31:24] main version */
S#define __STM32F4XX_STDPERIPH_VERSION_SUB1   (0x08) /*!< [23:16] sub1 version */
S#define __STM32F4XX_STDPERIPH_VERSION_SUB2   (0x00) /*!< [15:8]  sub2 version */
S#define __STM32F4XX_STDPERIPH_VERSION_RC     (0x00) /*!< [7:0]  release candidate */ 
S#define __STM32F4XX_STDPERIPH_VERSION        ((__STM32F4XX_STDPERIPH_VERSION_MAIN << 24)\
S                                             |(__STM32F4XX_STDPERIPH_VERSION_SUB1 << 16)\
S                                             |(__STM32F4XX_STDPERIPH_VERSION_SUB2 << 8)\
S                                             |(__STM32F4XX_STDPERIPH_VERSION_RC))
X#define __STM32F4XX_STDPERIPH_VERSION        ((__STM32F4XX_STDPERIPH_VERSION_MAIN << 24)                                             |(__STM32F4XX_STDPERIPH_VERSION_SUB1 << 16)                                             |(__STM32F4XX_STDPERIPH_VERSION_SUB2 << 8)                                             |(__STM32F4XX_STDPERIPH_VERSION_RC))
S
S/**
S  * @}
S  */
S
S/** @addtogroup Configuration_section_for_CMSIS
S  * @{
S  */
S
S/**
S * @brief Configuration of the Cortex-M4 Processor and Core Peripherals 
S */
S#define __CM4_REV                 0x0001  /*!< Core revision r0p1                            */
S#define __MPU_PRESENT             1       /*!< STM32F4XX provides an MPU                     */
S#define __NVIC_PRIO_BITS          4       /*!< STM32F4XX uses 4 Bits for the Priority Levels */
S#define __Vendor_SysTickConfig    0       /*!< Set to 1 if different SysTick Config is used  */
S#define __FPU_PRESENT             1       /*!< FPU present                                   */
S
S/**
S * @brief STM32F4XX Interrupt Number Definition, according to the selected device 
S *        in @ref Library_configuration_section 
S */
Stypedef enum IRQn
S{
S/******  Cortex-M4 Processor Exceptions Numbers ****************************************************************/
S  NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                                          */
S  MemoryManagement_IRQn       = -12,    /*!< 4 Cortex-M4 Memory Management Interrupt                           */
S  BusFault_IRQn               = -11,    /*!< 5 Cortex-M4 Bus Fault Interrupt                                   */
S  UsageFault_IRQn             = -10,    /*!< 6 Cortex-M4 Usage Fault Interrupt                                 */
S  SVCall_IRQn                 = -5,     /*!< 11 Cortex-M4 SV Call Interrupt                                    */
S  DebugMonitor_IRQn           = -4,     /*!< 12 Cortex-M4 Debug Monitor Interrupt                              */
S  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M4 Pend SV Interrupt                                    */
S  SysTick_IRQn                = -1,     /*!< 15 Cortex-M4 System Tick Interrupt                                */
S/******  STM32 specific Interrupt Numbers **********************************************************************/
S  WWDG_IRQn                   = 0,      /*!< Window WatchDog Interrupt                                         */
S  PVD_IRQn                    = 1,      /*!< PVD through EXTI Line detection Interrupt                         */
S  TAMP_STAMP_IRQn             = 2,      /*!< Tamper and TimeStamp interrupts through the EXTI line             */
S  RTC_WKUP_IRQn               = 3,      /*!< RTC Wakeup interrupt through the EXTI line                        */
S  FLASH_IRQn                  = 4,      /*!< FLASH global Interrupt                                            */
S  RCC_IRQn                    = 5,      /*!< RCC global Interrupt                                              */
S  EXTI0_IRQn                  = 6,      /*!< EXTI Line0 Interrupt                                              */
S  EXTI1_IRQn                  = 7,      /*!< EXTI Line1 Interrupt                                              */
S  EXTI2_IRQn                  = 8,      /*!< EXTI Line2 Interrupt                                              */
S  EXTI3_IRQn                  = 9,      /*!< EXTI Line3 Interrupt                                              */
S  EXTI4_IRQn                  = 10,     /*!< EXTI Line4 Interrupt                                              */
S  DMA1_Stream0_IRQn           = 11,     /*!< DMA1 Stream 0 global Interrupt                                    */
S  DMA1_Stream1_IRQn           = 12,     /*!< DMA1 Stream 1 global Interrupt                                    */
S  DMA1_Stream2_IRQn           = 13,     /*!< DMA1 Stream 2 global Interrupt                                    */
S  DMA1_Stream3_IRQn           = 14,     /*!< DMA1 Stream 3 global Interrupt                                    */
S  DMA1_Stream4_IRQn           = 15,     /*!< DMA1 Stream 4 global Interrupt                                    */
S  DMA1_Stream5_IRQn           = 16,     /*!< DMA1 Stream 5 global Interrupt                                    */
S  DMA1_Stream6_IRQn           = 17,     /*!< DMA1 Stream 6 global Interrupt                                    */
S  ADC_IRQn                    = 18,     /*!< ADC1, ADC2 and ADC3 global Interrupts                             */
S
S#if defined(STM32F40_41xxx)
S  CAN1_TX_IRQn                = 19,     /*!< CAN1 TX Interrupt                                                 */
S  CAN1_RX0_IRQn               = 20,     /*!< CAN1 RX0 Interrupt                                                */
S  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                                */
S  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                                */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
S  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break interrupt and TIM9 global interrupt                    */
S  TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global interrupt                  */
S  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                                    */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                             */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                             */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                             */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
S  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                                           */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
S  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
S  OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS Wakeup through EXTI line interrupt                     */
S  TIM8_BRK_TIM12_IRQn         = 43,     /*!< TIM8 Break Interrupt and TIM12 global interrupt                   */
S  TIM8_UP_TIM13_IRQn          = 44,     /*!< TIM8 Update Interrupt and TIM13 global interrupt                  */
S  TIM8_TRG_COM_TIM14_IRQn     = 45,     /*!< TIM8 Trigger and Commutation Interrupt and TIM14 global interrupt */
S  TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare Interrupt                                    */
S  DMA1_Stream7_IRQn           = 47,     /*!< DMA1 Stream7 Interrupt                                            */
S  FSMC_IRQn                   = 48,     /*!< FSMC global Interrupt                                             */
S  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                             */
S  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                             */
S  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                             */
S  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                                            */
S  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                                            */
S  TIM6_DAC_IRQn               = 54,     /*!< TIM6 global and DAC1&2 underrun error  interrupts                 */
S  TIM7_IRQn                   = 55,     /*!< TIM7 global interrupt                                             */
S  DMA2_Stream0_IRQn           = 56,     /*!< DMA2 Stream 0 global Interrupt                                    */
S  DMA2_Stream1_IRQn           = 57,     /*!< DMA2 Stream 1 global Interrupt                                    */
S  DMA2_Stream2_IRQn           = 58,     /*!< DMA2 Stream 2 global Interrupt                                    */
S  DMA2_Stream3_IRQn           = 59,     /*!< DMA2 Stream 3 global Interrupt                                    */
S  DMA2_Stream4_IRQn           = 60,     /*!< DMA2 Stream 4 global Interrupt                                    */
S  ETH_IRQn                    = 61,     /*!< Ethernet global Interrupt                                         */
S  ETH_WKUP_IRQn               = 62,     /*!< Ethernet Wakeup through EXTI line Interrupt                       */
S  CAN2_TX_IRQn                = 63,     /*!< CAN2 TX Interrupt                                                 */
S  CAN2_RX0_IRQn               = 64,     /*!< CAN2 RX0 Interrupt                                                */
S  CAN2_RX1_IRQn               = 65,     /*!< CAN2 RX1 Interrupt                                                */
S  CAN2_SCE_IRQn               = 66,     /*!< CAN2 SCE Interrupt                                                */
S  OTG_FS_IRQn                 = 67,     /*!< USB OTG FS global Interrupt                                       */
S  DMA2_Stream5_IRQn           = 68,     /*!< DMA2 Stream 5 global interrupt                                    */
S  DMA2_Stream6_IRQn           = 69,     /*!< DMA2 Stream 6 global interrupt                                    */
S  DMA2_Stream7_IRQn           = 70,     /*!< DMA2 Stream 7 global interrupt                                    */
S  USART6_IRQn                 = 71,     /*!< USART6 global interrupt                                           */
S  I2C3_EV_IRQn                = 72,     /*!< I2C3 event interrupt                                              */
S  I2C3_ER_IRQn                = 73,     /*!< I2C3 error interrupt                                              */
S  OTG_HS_EP1_OUT_IRQn         = 74,     /*!< USB OTG HS End Point 1 Out global interrupt                       */
S  OTG_HS_EP1_IN_IRQn          = 75,     /*!< USB OTG HS End Point 1 In global interrupt                        */
S  OTG_HS_WKUP_IRQn            = 76,     /*!< USB OTG HS Wakeup through EXTI interrupt                          */
S  OTG_HS_IRQn                 = 77,     /*!< USB OTG HS global interrupt                                       */
S  DCMI_IRQn                   = 78,     /*!< DCMI global interrupt                                             */
S  CRYP_IRQn                   = 79,     /*!< CRYP crypto global interrupt                                      */
S  HASH_RNG_IRQn               = 80,     /*!< Hash and Rng global interrupt                                     */
S  FPU_IRQn                    = 81      /*!< FPU global interrupt                                              */
S#endif /* STM32F40_41xxx */
S
S#if defined(STM32F427_437xx)
S  CAN1_TX_IRQn                = 19,     /*!< CAN1 TX Interrupt                                                 */
S  CAN1_RX0_IRQn               = 20,     /*!< CAN1 RX0 Interrupt                                                */
S  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                                */
S  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                                */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
S  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break interrupt and TIM9 global interrupt                    */
S  TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global interrupt                  */
S  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                                    */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                             */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                             */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                             */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
S  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                                           */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
S  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
S  OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS Wakeup through EXTI line interrupt                     */
S  TIM8_BRK_TIM12_IRQn         = 43,     /*!< TIM8 Break Interrupt and TIM12 global interrupt                   */
S  TIM8_UP_TIM13_IRQn          = 44,     /*!< TIM8 Update Interrupt and TIM13 global interrupt                  */
S  TIM8_TRG_COM_TIM14_IRQn     = 45,     /*!< TIM8 Trigger and Commutation Interrupt and TIM14 global interrupt */
S  TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare Interrupt                                    */
S  DMA1_Stream7_IRQn           = 47,     /*!< DMA1 Stream7 Interrupt                                            */
S  FMC_IRQn                    = 48,     /*!< FMC global Interrupt                                              */
S  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                             */
S  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                             */
S  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                             */
S  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                                            */
S  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                                            */
S  TIM6_DAC_IRQn               = 54,     /*!< TIM6 global and DAC1&2 underrun error  interrupts                 */
S  TIM7_IRQn                   = 55,     /*!< TIM7 global interrupt                                             */
S  DMA2_Stream0_IRQn           = 56,     /*!< DMA2 Stream 0 global Interrupt                                    */
S  DMA2_Stream1_IRQn           = 57,     /*!< DMA2 Stream 1 global Interrupt                                    */
S  DMA2_Stream2_IRQn           = 58,     /*!< DMA2 Stream 2 global Interrupt                                    */
S  DMA2_Stream3_IRQn           = 59,     /*!< DMA2 Stream 3 global Interrupt                                    */
S  DMA2_Stream4_IRQn           = 60,     /*!< DMA2 Stream 4 global Interrupt                                    */
S  ETH_IRQn                    = 61,     /*!< Ethernet global Interrupt                                         */
S  ETH_WKUP_IRQn               = 62,     /*!< Ethernet Wakeup through EXTI line Interrupt                       */
S  CAN2_TX_IRQn                = 63,     /*!< CAN2 TX Interrupt                                                 */
S  CAN2_RX0_IRQn               = 64,     /*!< CAN2 RX0 Interrupt                                                */
S  CAN2_RX1_IRQn               = 65,     /*!< CAN2 RX1 Interrupt                                                */
S  CAN2_SCE_IRQn               = 66,     /*!< CAN2 SCE Interrupt                                                */
S  OTG_FS_IRQn                 = 67,     /*!< USB OTG FS global Interrupt                                       */
S  DMA2_Stream5_IRQn           = 68,     /*!< DMA2 Stream 5 global interrupt                                    */
S  DMA2_Stream6_IRQn           = 69,     /*!< DMA2 Stream 6 global interrupt                                    */
S  DMA2_Stream7_IRQn           = 70,     /*!< DMA2 Stream 7 global interrupt                                    */
S  USART6_IRQn                 = 71,     /*!< USART6 global interrupt                                           */
S  I2C3_EV_IRQn                = 72,     /*!< I2C3 event interrupt                                              */
S  I2C3_ER_IRQn                = 73,     /*!< I2C3 error interrupt                                              */
S  OTG_HS_EP1_OUT_IRQn         = 74,     /*!< USB OTG HS End Point 1 Out global interrupt                       */
S  OTG_HS_EP1_IN_IRQn          = 75,     /*!< USB OTG HS End Point 1 In global interrupt                        */
S  OTG_HS_WKUP_IRQn            = 76,     /*!< USB OTG HS Wakeup through EXTI interrupt                          */
S  OTG_HS_IRQn                 = 77,     /*!< USB OTG HS global interrupt                                       */
S  DCMI_IRQn                   = 78,     /*!< DCMI global interrupt                                             */
S  CRYP_IRQn                   = 79,     /*!< CRYP crypto global interrupt                                      */
S  HASH_RNG_IRQn               = 80,     /*!< Hash and Rng global interrupt                                     */
S  FPU_IRQn                    = 81,     /*!< FPU global interrupt                                              */
S  UART7_IRQn                  = 82,     /*!< UART7 global interrupt                                            */
S  UART8_IRQn                  = 83,     /*!< UART8 global interrupt                                            */
S  SPI4_IRQn                   = 84,     /*!< SPI4 global Interrupt                                             */
S  SPI5_IRQn                   = 85,     /*!< SPI5 global Interrupt                                             */
S  SPI6_IRQn                   = 86,     /*!< SPI6 global Interrupt                                             */
S  SAI1_IRQn                   = 87,     /*!< SAI1 global Interrupt                                             */
S  DMA2D_IRQn                  = 90      /*!< DMA2D global Interrupt                                            */
S#endif /* STM32F427_437xx */
S    
S#if defined(STM32F429_439xx)
S  CAN1_TX_IRQn                = 19,     /*!< CAN1 TX Interrupt                                                 */
S  CAN1_RX0_IRQn               = 20,     /*!< CAN1 RX0 Interrupt                                                */
S  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                                */
S  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                                */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
S  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break interrupt and TIM9 global interrupt                    */
S  TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global interrupt                  */
S  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                                    */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                             */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                             */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                             */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */  
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
S  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                                           */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
S  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
S  OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS Wakeup through EXTI line interrupt                     */    
S  TIM8_BRK_TIM12_IRQn         = 43,     /*!< TIM8 Break Interrupt and TIM12 global interrupt                   */
S  TIM8_UP_TIM13_IRQn          = 44,     /*!< TIM8 Update Interrupt and TIM13 global interrupt                  */
S  TIM8_TRG_COM_TIM14_IRQn     = 45,     /*!< TIM8 Trigger and Commutation Interrupt and TIM14 global interrupt */
S  TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare Interrupt                                    */
S  DMA1_Stream7_IRQn           = 47,     /*!< DMA1 Stream7 Interrupt                                            */
S  FMC_IRQn                    = 48,     /*!< FMC global Interrupt                                              */
S  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                             */
S  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                             */
S  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                             */
S  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                                            */
S  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                                            */
S  TIM6_DAC_IRQn               = 54,     /*!< TIM6 global and DAC1&2 underrun error  interrupts                 */
S  TIM7_IRQn                   = 55,     /*!< TIM7 global interrupt                                             */
S  DMA2_Stream0_IRQn           = 56,     /*!< DMA2 Stream 0 global Interrupt                                    */
S  DMA2_Stream1_IRQn           = 57,     /*!< DMA2 Stream 1 global Interrupt                                    */
S  DMA2_Stream2_IRQn           = 58,     /*!< DMA2 Stream 2 global Interrupt                                    */
S  DMA2_Stream3_IRQn           = 59,     /*!< DMA2 Stream 3 global Interrupt                                    */
S  DMA2_Stream4_IRQn           = 60,     /*!< DMA2 Stream 4 global Interrupt                                    */
S  ETH_IRQn                    = 61,     /*!< Ethernet global Interrupt                                         */
S  ETH_WKUP_IRQn               = 62,     /*!< Ethernet Wakeup through EXTI line Interrupt                       */
S  CAN2_TX_IRQn                = 63,     /*!< CAN2 TX Interrupt                                                 */
S  CAN2_RX0_IRQn               = 64,     /*!< CAN2 RX0 Interrupt                                                */
S  CAN2_RX1_IRQn               = 65,     /*!< CAN2 RX1 Interrupt                                                */
S  CAN2_SCE_IRQn               = 66,     /*!< CAN2 SCE Interrupt                                                */
S  OTG_FS_IRQn                 = 67,     /*!< USB OTG FS global Interrupt                                       */
S  DMA2_Stream5_IRQn           = 68,     /*!< DMA2 Stream 5 global interrupt                                    */
S  DMA2_Stream6_IRQn           = 69,     /*!< DMA2 Stream 6 global interrupt                                    */
S  DMA2_Stream7_IRQn           = 70,     /*!< DMA2 Stream 7 global interrupt                                    */
S  USART6_IRQn                 = 71,     /*!< USART6 global interrupt                                           */
S  I2C3_EV_IRQn                = 72,     /*!< I2C3 event interrupt                                              */
S  I2C3_ER_IRQn                = 73,     /*!< I2C3 error interrupt                                              */
S  OTG_HS_EP1_OUT_IRQn         = 74,     /*!< USB OTG HS End Point 1 Out global interrupt                       */
S  OTG_HS_EP1_IN_IRQn          = 75,     /*!< USB OTG HS End Point 1 In global interrupt                        */
S  OTG_HS_WKUP_IRQn            = 76,     /*!< USB OTG HS Wakeup through EXTI interrupt                          */
S  OTG_HS_IRQn                 = 77,     /*!< USB OTG HS global interrupt                                       */
S  DCMI_IRQn                   = 78,     /*!< DCMI global interrupt                                             */
S  CRYP_IRQn                   = 79,     /*!< CRYP crypto global interrupt                                      */
S  HASH_RNG_IRQn               = 80,     /*!< Hash and Rng global interrupt                                     */
S  FPU_IRQn                    = 81,     /*!< FPU global interrupt                                              */
S  UART7_IRQn                  = 82,     /*!< UART7 global interrupt                                            */
S  UART8_IRQn                  = 83,     /*!< UART8 global interrupt                                            */
S  SPI4_IRQn                   = 84,     /*!< SPI4 global Interrupt                                             */
S  SPI5_IRQn                   = 85,     /*!< SPI5 global Interrupt                                             */
S  SPI6_IRQn                   = 86,     /*!< SPI6 global Interrupt                                             */
S  SAI1_IRQn                   = 87,     /*!< SAI1 global Interrupt                                             */
S  LTDC_IRQn                   = 88,     /*!< LTDC global Interrupt                                             */
S  LTDC_ER_IRQn                = 89,     /*!< LTDC Error global Interrupt                                       */
S  DMA2D_IRQn                  = 90      /*!< DMA2D global Interrupt                                            */
S#endif /* STM32F429_439xx */
S
S#if defined(STM32F410xx)
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
S  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break interrupt and TIM9 global interrupt                    */
S  TIM1_UP_IRQn                = 25,     /*!< TIM1 Update Interrupt                                             */
S  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                                    */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
S  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
S  DMA1_Stream7_IRQn           = 47,     /*!< DMA1 Stream7 Interrupt                                            */
S  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                             */
S  TIM6_DAC_IRQn               = 54,     /*!< TIM6 global Interrupt and DAC Global Interrupt                    */
S  DMA2_Stream0_IRQn           = 56,     /*!< DMA2 Stream 0 global Interrupt                                    */
S  DMA2_Stream1_IRQn           = 57,     /*!< DMA2 Stream 1 global Interrupt                                    */
S  DMA2_Stream2_IRQn           = 58,     /*!< DMA2 Stream 2 global Interrupt                                    */
S  DMA2_Stream3_IRQn           = 59,     /*!< DMA2 Stream 3 global Interrupt                                    */
S  DMA2_Stream4_IRQn           = 60,     /*!< DMA2 Stream 4 global Interrupt                                    */
S  DMA2_Stream5_IRQn           = 68,     /*!< DMA2 Stream 5 global interrupt                                    */
S  DMA2_Stream6_IRQn           = 69,     /*!< DMA2 Stream 6 global interrupt                                    */
S  DMA2_Stream7_IRQn           = 70,     /*!< DMA2 Stream 7 global interrupt                                    */
S  USART6_IRQn                 = 71,     /*!< USART6 global interrupt                                           */
S  RNG_IRQn                    = 80,     /*!< RNG global Interrupt                                              */
S  FPU_IRQn                    = 81,     /*!< FPU global interrupt                                              */
S  SPI5_IRQn                   = 85,     /*!< SPI5 global Interrupt                                             */
S  FMPI2C1_EV_IRQn             = 95,     /*!< FMPI2C1 Event Interrupt                                           */
S  FMPI2C1_ER_IRQn             = 96,     /*!< FMPI2C1 Error Interrupt                                           */
S  LPTIM1_IRQn                 = 97      /*!< LPTIM1 interrupt                                                  */
S#endif /* STM32F410xx */
S   
S#if defined(STM32F401xx) || defined(STM32F411xE)
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
S  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break interrupt and TIM9 global interrupt                    */
S  TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global interrupt                  */
S  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                                    */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                             */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                             */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                             */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
S  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
S  OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS Wakeup through EXTI line interrupt                     */
S  DMA1_Stream7_IRQn           = 47,     /*!< DMA1 Stream7 Interrupt                                            */
S  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                             */
S  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                             */
S  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                             */
S  DMA2_Stream0_IRQn           = 56,     /*!< DMA2 Stream 0 global Interrupt                                    */
S  DMA2_Stream1_IRQn           = 57,     /*!< DMA2 Stream 1 global Interrupt                                    */
S  DMA2_Stream2_IRQn           = 58,     /*!< DMA2 Stream 2 global Interrupt                                    */
S  DMA2_Stream3_IRQn           = 59,     /*!< DMA2 Stream 3 global Interrupt                                    */
S  DMA2_Stream4_IRQn           = 60,     /*!< DMA2 Stream 4 global Interrupt                                    */
S  OTG_FS_IRQn                 = 67,     /*!< USB OTG FS global Interrupt                                       */
S  DMA2_Stream5_IRQn           = 68,     /*!< DMA2 Stream 5 global interrupt                                    */
S  DMA2_Stream6_IRQn           = 69,     /*!< DMA2 Stream 6 global interrupt                                    */
S  DMA2_Stream7_IRQn           = 70,     /*!< DMA2 Stream 7 global interrupt                                    */
S  USART6_IRQn                 = 71,     /*!< USART6 global interrupt                                           */
S  I2C3_EV_IRQn                = 72,     /*!< I2C3 event interrupt                                              */
S  I2C3_ER_IRQn                = 73,     /*!< I2C3 error interrupt                                              */
S  FPU_IRQn                    = 81,      /*!< FPU global interrupt                                             */
S#if defined(STM32F401xx)
S  SPI4_IRQn                   = 84       /*!< SPI4 global Interrupt                                            */
S#endif /* STM32F411xE */
S#if defined(STM32F411xE)
S  SPI4_IRQn                   = 84,     /*!< SPI4 global Interrupt                                             */
S  SPI5_IRQn                   = 85      /*!< SPI5 global Interrupt                                             */
S#endif /* STM32F411xE */
S#endif /* STM32F401xx || STM32F411xE */
S
S#if defined(STM32F469_479xx)
S  CAN1_TX_IRQn                = 19,     /*!< CAN1 TX Interrupt                                                 */
S  CAN1_RX0_IRQn               = 20,     /*!< CAN1 RX0 Interrupt                                                */
S  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                                */
S  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                                */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
S  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break interrupt and TIM9 global interrupt                    */
S  TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global interrupt                  */
S  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                                    */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                             */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                             */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                             */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
S  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                                           */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
S  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
S  OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS Wakeup through EXTI line interrupt                     */
S  TIM8_BRK_TIM12_IRQn         = 43,     /*!< TIM8 Break Interrupt and TIM12 global interrupt                   */
S  TIM8_UP_TIM13_IRQn          = 44,     /*!< TIM8 Update Interrupt and TIM13 global interrupt                  */
S  TIM8_TRG_COM_TIM14_IRQn     = 45,     /*!< TIM8 Trigger and Commutation Interrupt and TIM14 global interrupt */
S  TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare Interrupt                                    */
S  DMA1_Stream7_IRQn           = 47,     /*!< DMA1 Stream7 Interrupt                                            */
S  FMC_IRQn                    = 48,     /*!< FMC global Interrupt                                              */
S  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                             */
S  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                             */
S  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                             */
S  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                                            */
S  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                                            */
S  TIM6_DAC_IRQn               = 54,     /*!< TIM6 global and DAC1&2 underrun error  interrupts                 */
S  TIM7_IRQn                   = 55,     /*!< TIM7 global interrupt                                             */
S  DMA2_Stream0_IRQn           = 56,     /*!< DMA2 Stream 0 global Interrupt                                    */
S  DMA2_Stream1_IRQn           = 57,     /*!< DMA2 Stream 1 global Interrupt                                    */
S  DMA2_Stream2_IRQn           = 58,     /*!< DMA2 Stream 2 global Interrupt                                    */
S  DMA2_Stream3_IRQn           = 59,     /*!< DMA2 Stream 3 global Interrupt                                    */
S  DMA2_Stream4_IRQn           = 60,     /*!< DMA2 Stream 4 global Interrupt                                    */
S  ETH_IRQn                    = 61,     /*!< Ethernet global Interrupt                                         */
S  ETH_WKUP_IRQn               = 62,     /*!< Ethernet Wakeup through EXTI line Interrupt                       */
S  CAN2_TX_IRQn                = 63,     /*!< CAN2 TX Interrupt                                                 */
S  CAN2_RX0_IRQn               = 64,     /*!< CAN2 RX0 Interrupt                                                */
S  CAN2_RX1_IRQn               = 65,     /*!< CAN2 RX1 Interrupt                                                */
S  CAN2_SCE_IRQn               = 66,     /*!< CAN2 SCE Interrupt                                                */
S  OTG_FS_IRQn                 = 67,     /*!< USB OTG FS global Interrupt                                       */
S  DMA2_Stream5_IRQn           = 68,     /*!< DMA2 Stream 5 global interrupt                                    */
S  DMA2_Stream6_IRQn           = 69,     /*!< DMA2 Stream 6 global interrupt                                    */
S  DMA2_Stream7_IRQn           = 70,     /*!< DMA2 Stream 7 global interrupt                                    */
S  USART6_IRQn                 = 71,     /*!< USART6 global interrupt                                           */
S  I2C3_EV_IRQn                = 72,     /*!< I2C3 event interrupt                                              */
S  I2C3_ER_IRQn                = 73,     /*!< I2C3 error interrupt                                              */
S  OTG_HS_EP1_OUT_IRQn         = 74,     /*!< USB OTG HS End Point 1 Out global interrupt                       */
S  OTG_HS_EP1_IN_IRQn          = 75,     /*!< USB OTG HS End Point 1 In global interrupt                        */
S  OTG_HS_WKUP_IRQn            = 76,     /*!< USB OTG HS Wakeup through EXTI interrupt                          */
S  OTG_HS_IRQn                 = 77,     /*!< USB OTG HS global interrupt                                       */
S  DCMI_IRQn                   = 78,     /*!< DCMI global interrupt                                             */
S  CRYP_IRQn                   = 79,     /*!< CRYP crypto global interrupt                                      */
S  HASH_RNG_IRQn               = 80,     /*!< Hash and Rng global interrupt                                     */
S  FPU_IRQn                    = 81,     /*!< FPU global interrupt                                              */
S  UART7_IRQn                  = 82,     /*!< UART7 global interrupt                                            */
S  UART8_IRQn                  = 83,     /*!< UART8 global interrupt                                            */
S  SPI4_IRQn                   = 84,     /*!< SPI4 global Interrupt                                             */
S  SPI5_IRQn                   = 85,     /*!< SPI5 global Interrupt                                             */
S  SPI6_IRQn                   = 86,     /*!< SPI6 global Interrupt                                             */
S  SAI1_IRQn                   = 87,     /*!< SAI1 global Interrupt                                             */
S  LTDC_IRQn                   = 88,     /*!< LTDC global Interrupt                                             */
S  LTDC_ER_IRQn                = 89,     /*!< LTDC Error global Interrupt                                       */
S  DMA2D_IRQn                  = 90,     /*!< DMA2D global Interrupt                                            */
S  QUADSPI_IRQn                = 91,     /*!< QUADSPI global Interrupt                                          */
S  DSI_IRQn                    = 92      /*!< DSI global Interrupt                                              */
S#endif /* STM32F469_479xx */
S
S#if defined(STM32F446xx)
S  CAN1_TX_IRQn                = 19,     /*!< CAN1 TX Interrupt                                                 */
S  CAN1_RX0_IRQn               = 20,     /*!< CAN1 RX0 Interrupt                                                */
S  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                                */
S  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                                */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
S  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break interrupt and TIM9 global interrupt                    */
S  TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global interrupt                  */
S  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                                    */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                             */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                             */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                             */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */  
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
S  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                                           */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
S  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
S  OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS Wakeup through EXTI line interrupt                     */    
S  TIM8_BRK_IRQn               = 43,     /*!< TIM8 Break Interrupt                                              */
S  TIM8_BRK_TIM12_IRQn         = 43,     /*!< TIM8 Break Interrupt and TIM12 global interrupt                   */
S  TIM8_UP_TIM13_IRQn          = 44,     /*!< TIM8 Update Interrupt and TIM13 global interrupt                  */
S  TIM8_TRG_COM_TIM14_IRQn     = 45,     /*!< TIM8 Trigger and Commutation Interrupt and TIM14 global interrupt */
S  DMA1_Stream7_IRQn           = 47,     /*!< DMA1 Stream7 Interrupt                                            */
S  FMC_IRQn                    = 48,     /*!< FMC global Interrupt                                              */
S  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                             */
S  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                             */
S  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                             */
S  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                                            */
S  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                                            */
S  TIM6_DAC_IRQn               = 54,     /*!< TIM6 global and DAC1&2 underrun error  interrupts                 */
S  TIM7_IRQn                   = 55,     /*!< TIM7 global interrupt                                             */
S  DMA2_Stream0_IRQn           = 56,     /*!< DMA2 Stream 0 global Interrupt                                    */
S  DMA2_Stream1_IRQn           = 57,     /*!< DMA2 Stream 1 global Interrupt                                    */
S  DMA2_Stream2_IRQn           = 58,     /*!< DMA2 Stream 2 global Interrupt                                    */
S  DMA2_Stream3_IRQn           = 59,     /*!< DMA2 Stream 3 global Interrupt                                    */
S  DMA2_Stream4_IRQn           = 60,     /*!< DMA2 Stream 4 global Interrupt                                    */
S  CAN2_TX_IRQn                = 63,     /*!< CAN2 TX Interrupt                                                 */
S  CAN2_RX0_IRQn               = 64,     /*!< CAN2 RX0 Interrupt                                                */
S  CAN2_RX1_IRQn               = 65,     /*!< CAN2 RX1 Interrupt                                                */
S  CAN2_SCE_IRQn               = 66,     /*!< CAN2 SCE Interrupt                                                */
S  OTG_FS_IRQn                 = 67,     /*!< USB OTG FS global Interrupt                                       */
S  DMA2_Stream5_IRQn           = 68,     /*!< DMA2 Stream 5 global interrupt                                    */
S  DMA2_Stream6_IRQn           = 69,     /*!< DMA2 Stream 6 global interrupt                                    */
S  DMA2_Stream7_IRQn           = 70,     /*!< DMA2 Stream 7 global interrupt                                    */
S  USART6_IRQn                 = 71,     /*!< USART6 global interrupt                                           */
S  I2C3_EV_IRQn                = 72,     /*!< I2C3 event interrupt                                              */
S  I2C3_ER_IRQn                = 73,     /*!< I2C3 error interrupt                                              */
S  OTG_HS_EP1_OUT_IRQn         = 74,     /*!< USB OTG HS End Point 1 Out global interrupt                       */
S  OTG_HS_EP1_IN_IRQn          = 75,     /*!< USB OTG HS End Point 1 In global interrupt                        */
S  OTG_HS_WKUP_IRQn            = 76,     /*!< USB OTG HS Wakeup through EXTI interrupt                          */
S  OTG_HS_IRQn                 = 77,     /*!< USB OTG HS global interrupt                                       */
S  DCMI_IRQn                   = 78,     /*!< DCMI global interrupt                                             */
S  FPU_IRQn                    = 81,     /*!< FPU global interrupt                                              */
S  SPI4_IRQn                   = 84,     /*!< SPI4 global Interrupt                                             */
S  SAI1_IRQn                   = 87,     /*!< SAI1 global Interrupt                                             */
S  SAI2_IRQn                   = 91,     /*!< SAI2 global Interrupt                                             */
S  QUADSPI_IRQn                = 92,     /*!< QuadSPI global Interrupt                                          */
S  CEC_IRQn                    = 93,     /*!< QuadSPI global Interrupt                                          */
S  SPDIF_RX_IRQn               = 94,     /*!< QuadSPI global Interrupt                                          */
S  FMPI2C1_EV_IRQn             = 95,     /*!< FMPI2C Event Interrupt                                            */
S  FMPI2C1_ER_IRQn             = 96      /*!< FMPCI2C Error Interrupt                                           */
S#endif /* STM32F446xx */
S
S#if defined(STM32F412xG)
S  CAN1_TX_IRQn                = 19,     /*!< CAN1 TX Interrupt                                                 */
S  CAN1_RX0_IRQn               = 20,     /*!< CAN1 RX0 Interrupt                                                */
S  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                                */
S  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                                */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
S  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break interrupt and TIM9 global interrupt                    */
S  TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global interrupt                  */
S  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                                    */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                             */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                             */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                             */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */  
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
S  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                                           */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
S  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
S  OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS Wakeup through EXTI line interrupt                     */
S  TIM8_BRK_TIM12_IRQn         = 43,     /*!< TIM8 Break Interrupt and TIM12 global interrupt                   */
S  TIM8_UP_TIM13_IRQn          = 44,     /*!< TIM8 Update Interrupt and TIM13 global interrupt                  */
S  TIM8_TRG_COM_TIM14_IRQn     = 45,     /*!< TIM8 Trigger and Commutation Interrupt and TIM14 global interrupt */
S  TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare Interrupt                                    */
S  DMA1_Stream7_IRQn           = 47,     /*!< DMA1 Stream7 Interrupt                                            */
S  FSMC_IRQn                   = 48,     /*!< FSMC global Interrupt                                              */
S  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                             */
S  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                             */
S  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                             */
S  TIM6_IRQn                   = 54,     /*!< TIM6 global interrupt                                             */
S  TIM7_IRQn                   = 55,     /*!< TIM7 global interrupt                                             */
S  DMA2_Stream0_IRQn           = 56,     /*!< DMA2 Stream 0 global Interrupt                                    */
S  DMA2_Stream1_IRQn           = 57,     /*!< DMA2 Stream 1 global Interrupt                                    */
S  DMA2_Stream2_IRQn           = 58,     /*!< DMA2 Stream 2 global Interrupt                                    */
S  DMA2_Stream3_IRQn           = 59,     /*!< DMA2 Stream 3 global Interrupt                                    */
S  DMA2_Stream4_IRQn           = 60,     /*!< DMA2 Stream 4 global Interrupt                                    */
S  DFSDM1_FLT0_IRQn            = 61,     /*!< DFSDM1 Filter 0 global Interrupt                                  */
S  DFSDM1_FLT1_IRQn            = 62,     /*!< DFSDM1 Filter 1 global Interrupt                                  */
S  CAN2_TX_IRQn                = 63,     /*!< CAN2 TX Interrupt                                                 */
S  CAN2_RX0_IRQn               = 64,     /*!< CAN2 RX0 Interrupt                                                */
S  CAN2_RX1_IRQn               = 65,     /*!< CAN2 RX1 Interrupt                                                */
S  CAN2_SCE_IRQn               = 66,     /*!< CAN2 SCE Interrupt                                                */
S  OTG_FS_IRQn                 = 67,     /*!< USB OTG FS global Interrupt                                       */
S  DMA2_Stream5_IRQn           = 68,     /*!< DMA2 Stream 5 global interrupt                                    */
S  DMA2_Stream6_IRQn           = 69,     /*!< DMA2 Stream 6 global interrupt                                    */
S  DMA2_Stream7_IRQn           = 70,     /*!< DMA2 Stream 7 global interrupt                                    */
S  USART6_IRQn                 = 71,     /*!< USART6 global interrupt                                           */
S  I2C3_EV_IRQn                = 72,     /*!< I2C3 event interrupt                                              */
S  I2C3_ER_IRQn                = 73,     /*!< I2C3 error interrupt                                              */
S  RNG_IRQn                    = 80,     /*!< RNG global Interrupt                                              */
S  FPU_IRQn                    = 81,     /*!< FPU global interrupt                                              */
S  SPI4_IRQn                   = 84,     /*!< SPI4 global Interrupt                                             */
S  SPI5_IRQn                   = 85,      /*!< SPI5 global Interrupt                                            */
S  QUADSPI_IRQn                = 92,     /*!< QuadSPI global Interrupt                                          */
S  FMPI2C1_EV_IRQn             = 95,     /*!< FMPI2C1 Event Interrupt                                           */
S  FMPI2C1_ER_IRQn             = 96      /*!< FMPI2C1 Error Interrupt                                           */
S#endif /* STM32F412xG */
S
S#if defined(STM32F413_423xx)
S  CAN1_TX_IRQn                = 19,     /*!< CAN1 TX Interrupt                                                 */
S  CAN1_RX0_IRQn               = 20,     /*!< CAN1 RX0 Interrupt                                                */
S  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                                */
S  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                                */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
S  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break interrupt and TIM9 global interrupt                    */
S  TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global interrupt                  */
S  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */
S  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                                    */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                             */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                             */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                             */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */  
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
S  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                                           */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
S  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
S  OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS Wakeup through EXTI line interrupt                     */
S  TIM8_BRK_TIM12_IRQn         = 43,     /*!< TIM8 Break Interrupt and TIM12 global interrupt                   */
S  TIM8_UP_TIM13_IRQn          = 44,     /*!< TIM8 Update Interrupt and TIM13 global interrupt                  */
S  TIM8_TRG_COM_TIM14_IRQn     = 45,     /*!< TIM8 Trigger and Commutation Interrupt and TIM14 global interrupt */
S  TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare Interrupt                                    */
S  DMA1_Stream7_IRQn           = 47,     /*!< DMA1 Stream7 Interrupt                                            */
S  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                             */
S  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                             */
S  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                             */
S  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                                            */
S  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                                            */
S  TIM6_DAC_IRQn               = 54,     /*!< TIM6 and DAC1&2 global Interrupt                                  */
S  TIM7_IRQn                   = 55,     /*!< TIM7 global interrupt                                             */
S  DMA2_Stream0_IRQn           = 56,     /*!< DMA2 Stream 0 global Interrupt                                    */
S  DMA2_Stream1_IRQn           = 57,     /*!< DMA2 Stream 1 global Interrupt                                    */
S  DMA2_Stream2_IRQn           = 58,     /*!< DMA2 Stream 2 global Interrupt                                    */
S  DMA2_Stream3_IRQn           = 59,     /*!< DMA2 Stream 3 global Interrupt                                    */
S  DMA2_Stream4_IRQn           = 60,     /*!< DMA2 Stream 4 global Interrupt                                    */
S  DFSDM1_FLT0_IRQn            = 61,     /*!< DFSDM1 Filter 0 global Interrupt                                  */
S  DFSDM1_FLT1_IRQn            = 62,     /*!< DFSDM1 Filter 1 global Interrupt                                  */
S  CAN2_TX_IRQn                = 63,     /*!< CAN2 TX Interrupt                                                 */
S  CAN2_RX0_IRQn               = 64,     /*!< CAN2 RX0 Interrupt                                                */
S  CAN2_RX1_IRQn               = 65,     /*!< CAN2 RX1 Interrupt                                                */
S  CAN2_SCE_IRQn               = 66,     /*!< CAN2 SCE Interrupt                                                */
S  OTG_FS_IRQn                 = 67,     /*!< USB OTG FS global Interrupt                                       */
S  DMA2_Stream5_IRQn           = 68,     /*!< DMA2 Stream 5 global interrupt                                    */
S  DMA2_Stream6_IRQn           = 69,     /*!< DMA2 Stream 6 global interrupt                                    */
S  DMA2_Stream7_IRQn           = 70,     /*!< DMA2 Stream 7 global interrupt                                    */
S  USART6_IRQn                 = 71,     /*!< USART6 global interrupt                                           */
S  I2C3_EV_IRQn                = 72,     /*!< I2C3 event interrupt                                              */
S  I2C3_ER_IRQn                = 73,     /*!< I2C3 error interrupt                                              */
S  CAN3_TX_IRQn                = 74,     /*!< CAN3 TX Interrupt                                                 */
S  CAN3_RX0_IRQn               = 75,     /*!< CAN3 RX0 Interrupt                                                */
S  CAN3_RX1_IRQn               = 76,     /*!< CAN3 RX1 Interrupt                                                */
S  CAN3_SCE_IRQn               = 77,     /*!< CAN3 SCE Interrupt                                                */
S  RNG_IRQn                    = 80,     /*!< RNG global Interrupt                                              */
S  FPU_IRQn                    = 81,     /*!< FPU global interrupt                                              */
S  UART7_IRQn                  = 82,     /*!< UART7 global interrupt                                            */  
S  UART8_IRQn                  = 83,     /*!< UART8 global interrupt                                            */   
S  SPI4_IRQn                   = 84,     /*!< SPI4 global Interrupt                                             */
S  SPI5_IRQn                   = 85,     /*!< SPI5 global Interrupt                                             */
S  SAI1_IRQn                   = 87,     /*!< Serial Audio Interface 1 global interrupt                         */
S  UART9_IRQn                  = 88,     /*!< UART9 global Interrupt                                            */
S  UART10_IRQn                 = 89,     /*!< UART10 global Interrupt                                           */  
S  QUADSPI_IRQn                = 92,     /*!< QuadSPI global Interrupt                                          */
S  FMPI2C1_EV_IRQn             = 95,     /*!< FMPI2C1 Event Interrupt                                           */
S  FMPI2C1_ER_IRQn             = 96,     /*!< FMPI2C1 Error Interrupt                                           */
S  LPTIM1_IRQn                 = 97,     /*!< LP TIM1 interrupt                                                 */
S  DFSDM2_FLT0_IRQn            = 98,     /*!< DFSDM2 Filter 0 global Interrupt                                  */
S  DFSDM2_FLT1_IRQn            = 99,     /*!< DFSDM2 Filter 1 global Interrupt                                  */
S  DFSDM2_FLT2_IRQn            = 100,    /*!< DFSDM2 Filter 2 global Interrupt                                  */
S  DFSDM2_FLT3_IRQn            = 101     /*!< DFSDM2 Filter 3 global Interrupt                                  */
S#endif /* STM32F413_423xx */
S} IRQn_Type;
S
S/**
S  * @}
S  */
S
S#include "core_cm4.h"             /* Cortex-M4 processor and core peripherals */
S#include "system_stm32f4xx.h"
S#include <stdint.h>
S
S/** @addtogroup Exported_types
S  * @{
S  */  
S/*!< STM32F10x Standard Peripheral Library old types (maintained for legacy purpose) */
Stypedef int32_t  s32;
Stypedef int16_t s16;
Stypedef int8_t  s8;
S
Stypedef const int32_t sc32;  /*!< Read Only */
Stypedef const int16_t sc16;  /*!< Read Only */
Stypedef const int8_t sc8;   /*!< Read Only */
S
Stypedef __IO int32_t  vs32;
Stypedef __IO int16_t  vs16;
Stypedef __IO int8_t   vs8;
S
Stypedef __I int32_t vsc32;  /*!< Read Only */
Stypedef __I int16_t vsc16;  /*!< Read Only */
Stypedef __I int8_t vsc8;   /*!< Read Only */
S
Stypedef uint32_t  u32;
Stypedef uint16_t u16;
Stypedef uint8_t  u8;
S
Stypedef const uint32_t uc32;  /*!< Read Only */
Stypedef const uint16_t uc16;  /*!< Read Only */
Stypedef const uint8_t uc8;   /*!< Read Only */
S
Stypedef __IO uint32_t  vu32;
Stypedef __IO uint16_t vu16;
Stypedef __IO uint8_t  vu8;
S
Stypedef __I uint32_t vuc32;  /*!< Read Only */
Stypedef __I uint16_t vuc16;  /*!< Read Only */
Stypedef __I uint8_t vuc8;   /*!< Read Only */
S
Stypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;
S
Stypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
S#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
S
Stypedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
S
S/**
S  * @}
S  */
S
S/** @addtogroup Peripheral_registers_structures
S  * @{
S  */   
S
S/** 
S  * @brief Analog to Digital Converter  
S  */
S
Stypedef struct
S{
S  __IO uint32_t SR;     /*!< ADC status register,                         Address offset: 0x00 */
S  __IO uint32_t CR1;    /*!< ADC control register 1,                      Address offset: 0x04 */      
S  __IO uint32_t CR2;    /*!< ADC control register 2,                      Address offset: 0x08 */
S  __IO uint32_t SMPR1;  /*!< ADC sample time register 1,                  Address offset: 0x0C */
S  __IO uint32_t SMPR2;  /*!< ADC sample time register 2,                  Address offset: 0x10 */
S  __IO uint32_t JOFR1;  /*!< ADC injected channel data offset register 1, Address offset: 0x14 */
S  __IO uint32_t JOFR2;  /*!< ADC injected channel data offset register 2, Address offset: 0x18 */
S  __IO uint32_t JOFR3;  /*!< ADC injected channel data offset register 3, Address offset: 0x1C */
S  __IO uint32_t JOFR4;  /*!< ADC injected channel data offset register 4, Address offset: 0x20 */
S  __IO uint32_t HTR;    /*!< ADC watchdog higher threshold register,      Address offset: 0x24 */
S  __IO uint32_t LTR;    /*!< ADC watchdog lower threshold register,       Address offset: 0x28 */
S  __IO uint32_t SQR1;   /*!< ADC regular sequence register 1,             Address offset: 0x2C */
S  __IO uint32_t SQR2;   /*!< ADC regular sequence register 2,             Address offset: 0x30 */
S  __IO uint32_t SQR3;   /*!< ADC regular sequence register 3,             Address offset: 0x34 */
S  __IO uint32_t JSQR;   /*!< ADC injected sequence register,              Address offset: 0x38 */
S  __IO uint32_t JDR1;   /*!< ADC injected data register 1,                Address offset: 0x3C */
S  __IO uint32_t JDR2;   /*!< ADC injected data register 2,                Address offset: 0x40 */
S  __IO uint32_t JDR3;   /*!< ADC injected data register 3,                Address offset: 0x44 */
S  __IO uint32_t JDR4;   /*!< ADC injected data register 4,                Address offset: 0x48 */
S  __IO uint32_t DR;     /*!< ADC regular data register,                   Address offset: 0x4C */
S} ADC_TypeDef;
S
Stypedef struct
S{
S  __IO uint32_t CSR;    /*!< ADC Common status register,                  Address offset: ADC1 base address + 0x300 */
S  __IO uint32_t CCR;    /*!< ADC common control register,                 Address offset: ADC1 base address + 0x304 */
S  __IO uint32_t CDR;    /*!< ADC common regular data register for dual
S                             AND triple modes,                            Address offset: ADC1 base address + 0x308 */
S} ADC_Common_TypeDef;
S
S
S/** 
S  * @brief Controller Area Network TxMailBox 
S  */
S
Stypedef struct
S{
S  __IO uint32_t TIR;  /*!< CAN TX mailbox identifier register */
S  __IO uint32_t TDTR; /*!< CAN mailbox data length control and time stamp register */
S  __IO uint32_t TDLR; /*!< CAN mailbox data low register */
S  __IO uint32_t TDHR; /*!< CAN mailbox data high register */
S} CAN_TxMailBox_TypeDef;
S
S/** 
S  * @brief Controller Area Network FIFOMailBox 
S  */
S  
Stypedef struct
S{
S  __IO uint32_t RIR;  /*!< CAN receive FIFO mailbox identifier register */
S  __IO uint32_t RDTR; /*!< CAN receive FIFO mailbox data length control and time stamp register */
S  __IO uint32_t RDLR; /*!< CAN receive FIFO mailbox data low register */
S  __IO uint32_t RDHR; /*!< CAN receive FIFO mailbox data high register */
S} CAN_FIFOMailBox_TypeDef;
S
S/** 
S  * @brief Controller Area Network FilterRegister 
S  */
S  
Stypedef struct
S{
S  __IO uint32_t FR1; /*!< CAN Filter bank register 1 */
S  __IO uint32_t FR2; /*!< CAN Filter bank register 1 */
S} CAN_FilterRegister_TypeDef;
S
S/** 
S  * @brief Controller Area Network 
S  */
S  
Stypedef struct
S{
S  __IO uint32_t              MCR;                 /*!< CAN master control register,         Address offset: 0x00          */
S  __IO uint32_t              MSR;                 /*!< CAN master status register,          Address offset: 0x04          */
S  __IO uint32_t              TSR;                 /*!< CAN transmit status register,        Address offset: 0x08          */
S  __IO uint32_t              RF0R;                /*!< CAN receive FIFO 0 register,         Address offset: 0x0C          */
S  __IO uint32_t              RF1R;                /*!< CAN receive FIFO 1 register,         Address offset: 0x10          */
S  __IO uint32_t              IER;                 /*!< CAN interrupt enable register,       Address offset: 0x14          */
S  __IO uint32_t              ESR;                 /*!< CAN error status register,           Address offset: 0x18          */
S  __IO uint32_t              BTR;                 /*!< CAN bit timing register,             Address offset: 0x1C          */
S  uint32_t                   RESERVED0[88];       /*!< Reserved, 0x020 - 0x17F                                            */
S  CAN_TxMailBox_TypeDef      sTxMailBox[3];       /*!< CAN Tx MailBox,                      Address offset: 0x180 - 0x1AC */
S  CAN_FIFOMailBox_TypeDef    sFIFOMailBox[2];     /*!< CAN FIFO MailBox,                    Address offset: 0x1B0 - 0x1CC */
S  uint32_t                   RESERVED1[12];       /*!< Reserved, 0x1D0 - 0x1FF                                            */
S  __IO uint32_t              FMR;                 /*!< CAN filter master register,          Address offset: 0x200         */
S  __IO uint32_t              FM1R;                /*!< CAN filter mode register,            Address offset: 0x204         */
S  uint32_t                   RESERVED2;           /*!< Reserved, 0x208                                                    */
S  __IO uint32_t              FS1R;                /*!< CAN filter scale register,           Address offset: 0x20C         */
S  uint32_t                   RESERVED3;           /*!< Reserved, 0x210                                                    */
S  __IO uint32_t              FFA1R;               /*!< CAN filter FIFO assignment register, Address offset: 0x214         */
S  uint32_t                   RESERVED4;           /*!< Reserved, 0x218                                                    */
S  __IO uint32_t              FA1R;                /*!< CAN filter activation register,      Address offset: 0x21C         */
S  uint32_t                   RESERVED5[8];        /*!< Reserved, 0x220-0x23F                                              */ 
S  CAN_FilterRegister_TypeDef sFilterRegister[28]; /*!< CAN Filter Register,                 Address offset: 0x240-0x31C   */
S} CAN_TypeDef;
S
S#if defined(STM32F446xx)
S/**
S  * @brief Consumer Electronics Control
S  */
Stypedef struct
S{
S  __IO uint32_t CR;           /*!< CEC control register,              Address offset:0x00 */
S  __IO uint32_t CFGR;         /*!< CEC configuration register,        Address offset:0x04 */
S  __IO uint32_t TXDR;         /*!< CEC Tx data register ,             Address offset:0x08 */
S  __IO uint32_t RXDR;         /*!< CEC Rx Data Register,              Address offset:0x0C */
S  __IO uint32_t ISR;          /*!< CEC Interrupt and Status Register, Address offset:0x10 */
S  __IO uint32_t IER;          /*!< CEC interrupt enable register,     Address offset:0x14 */
S}CEC_TypeDef;
S#endif /* STM32F446xx */
S
S/** 
S  * @brief CRC calculation unit 
S  */
S
Stypedef struct
S{
S  __IO uint32_t DR;         /*!< CRC Data register,             Address offset: 0x00 */
S  __IO uint8_t  IDR;        /*!< CRC Independent data register, Address offset: 0x04 */
S  uint8_t       RESERVED0;  /*!< Reserved, 0x05                                      */
S  uint16_t      RESERVED1;  /*!< Reserved, 0x06                                      */
S  __IO uint32_t CR;         /*!< CRC Control register,          Address offset: 0x08 */
S} CRC_TypeDef;
S
S/** 
S  * @brief Digital to Analog Converter
S  */
S
Stypedef struct
S{
S  __IO uint32_t CR;       /*!< DAC control register,                                    Address offset: 0x00 */
S  __IO uint32_t SWTRIGR;  /*!< DAC software trigger register,                           Address offset: 0x04 */
S  __IO uint32_t DHR12R1;  /*!< DAC channel1 12-bit right-aligned data holding register, Address offset: 0x08 */
S  __IO uint32_t DHR12L1;  /*!< DAC channel1 12-bit left aligned data holding register,  Address offset: 0x0C */
S  __IO uint32_t DHR8R1;   /*!< DAC channel1 8-bit right aligned data holding register,  Address offset: 0x10 */
S  __IO uint32_t DHR12R2;  /*!< DAC channel2 12-bit right aligned data holding register, Address offset: 0x14 */
S  __IO uint32_t DHR12L2;  /*!< DAC channel2 12-bit left aligned data holding register,  Address offset: 0x18 */
S  __IO uint32_t DHR8R2;   /*!< DAC channel2 8-bit right-aligned data holding register,  Address offset: 0x1C */
S  __IO uint32_t DHR12RD;  /*!< Dual DAC 12-bit right-aligned data holding register,     Address offset: 0x20 */
S  __IO uint32_t DHR12LD;  /*!< DUAL DAC 12-bit left aligned data holding register,      Address offset: 0x24 */
S  __IO uint32_t DHR8RD;   /*!< DUAL DAC 8-bit right aligned data holding register,      Address offset: 0x28 */
S  __IO uint32_t DOR1;     /*!< DAC channel1 data output register,                       Address offset: 0x2C */
S  __IO uint32_t DOR2;     /*!< DAC channel2 data output register,                       Address offset: 0x30 */
S  __IO uint32_t SR;       /*!< DAC status register,                                     Address offset: 0x34 */
S} DAC_TypeDef;
S
S#if defined(STM32F412xG) || defined(STM32F413_423xx)
S/**
S  * @brief DFSDM module registers
S  */
Stypedef struct
S{
S  __IO uint32_t FLTCR1;         /*!< DFSDM control register1,                          Address offset: 0x100 */
S  __IO uint32_t FLTCR2;         /*!< DFSDM control register2,                          Address offset: 0x104 */
S  __IO uint32_t FLTISR;         /*!< DFSDM interrupt and status register,              Address offset: 0x108 */
S  __IO uint32_t FLTICR;         /*!< DFSDM interrupt flag clear register,              Address offset: 0x10C */
S  __IO uint32_t FLTJCHGR;       /*!< DFSDM injected channel group selection register,  Address offset: 0x110 */
S  __IO uint32_t FLTFCR;         /*!< DFSDM filter control register,                    Address offset: 0x114 */
S  __IO uint32_t FLTJDATAR;      /*!< DFSDM data register for injected group,           Address offset: 0x118 */
S  __IO uint32_t FLTRDATAR;      /*!< DFSDM data register for regular group,            Address offset: 0x11C */
S  __IO uint32_t FLTAWHTR;       /*!< DFSDM analog watchdog high threshold register,    Address offset: 0x120 */
S  __IO uint32_t FLTAWLTR;       /*!< DFSDM analog watchdog low threshold register,     Address offset: 0x124 */
S  __IO uint32_t FLTAWSR;        /*!< DFSDM analog watchdog status register             Address offset: 0x128 */
S  __IO uint32_t FLTAWCFR;       /*!< DFSDM analog watchdog clear flag register         Address offset: 0x12C */
S  __IO uint32_t FLTEXMAX;       /*!< DFSDM extreme detector maximum register,          Address offset: 0x130 */
S  __IO uint32_t FLTEXMIN;       /*!< DFSDM extreme detector minimum register           Address offset: 0x134 */
S  __IO uint32_t FLTCNVTIMR;     /*!< DFSDM conversion timer,                           Address offset: 0x138 */
S} DFSDM_Filter_TypeDef;
S
S/**
S  * @brief DFSDM channel configuration registers
S  */
Stypedef struct
S{
S  __IO uint32_t CHCFGR1;     /*!< DFSDM channel configuration register1,            Address offset: 0x00 */
S  __IO uint32_t CHCFGR2;     /*!< DFSDM channel configuration register2,            Address offset: 0x04 */
S  __IO uint32_t CHAWSCDR;    /*!< DFSDM channel analog watchdog and
S                                  short circuit detector register,                  Address offset: 0x08 */
S  __IO uint32_t CHWDATAR;    /*!< DFSDM channel watchdog filter data register,      Address offset: 0x0C */
S  __IO uint32_t CHDATINR;    /*!< DFSDM channel data input register,                Address offset: 0x10 */
S} DFSDM_Channel_TypeDef;
S
S/* Legacy Defines */
S#define DFSDM_TypeDef        DFSDM_Filter_TypeDef
S#endif /* STM32F412xG || STM32F413_423xx */
S/** 
S  * @brief Debug MCU
S  */
S
Stypedef struct
S{
S  __IO uint32_t IDCODE;  /*!< MCU device ID code,               Address offset: 0x00 */
S  __IO uint32_t CR;      /*!< Debug MCU configuration register, Address offset: 0x04 */
S  __IO uint32_t APB1FZ;  /*!< Debug MCU APB1 freeze register,   Address offset: 0x08 */
S  __IO uint32_t APB2FZ;  /*!< Debug MCU APB2 freeze register,   Address offset: 0x0C */
S}DBGMCU_TypeDef;
S
S/** 
S  * @brief DCMI
S  */
S
Stypedef struct
S{
S  __IO uint32_t CR;       /*!< DCMI control register 1,                       Address offset: 0x00 */
S  __IO uint32_t SR;       /*!< DCMI status register,                          Address offset: 0x04 */
S  __IO uint32_t RISR;     /*!< DCMI raw interrupt status register,            Address offset: 0x08 */
S  __IO uint32_t IER;      /*!< DCMI interrupt enable register,                Address offset: 0x0C */
S  __IO uint32_t MISR;     /*!< DCMI masked interrupt status register,         Address offset: 0x10 */
S  __IO uint32_t ICR;      /*!< DCMI interrupt clear register,                 Address offset: 0x14 */
S  __IO uint32_t ESCR;     /*!< DCMI embedded synchronization code register,   Address offset: 0x18 */
S  __IO uint32_t ESUR;     /*!< DCMI embedded synchronization unmask register, Address offset: 0x1C */
S  __IO uint32_t CWSTRTR;  /*!< DCMI crop window start,                        Address offset: 0x20 */
S  __IO uint32_t CWSIZER;  /*!< DCMI crop window size,                         Address offset: 0x24 */
S  __IO uint32_t DR;       /*!< DCMI data register,                            Address offset: 0x28 */
S} DCMI_TypeDef;
S
S/** 
S  * @brief DMA Controller
S  */
S
Stypedef struct
S{
S  __IO uint32_t CR;     /*!< DMA stream x configuration register      */
S  __IO uint32_t NDTR;   /*!< DMA stream x number of data register     */
S  __IO uint32_t PAR;    /*!< DMA stream x peripheral address register */
S  __IO uint32_t M0AR;   /*!< DMA stream x memory 0 address register   */
S  __IO uint32_t M1AR;   /*!< DMA stream x memory 1 address register   */
S  __IO uint32_t FCR;    /*!< DMA stream x FIFO control register       */
S} DMA_Stream_TypeDef;
S
Stypedef struct
S{
S  __IO uint32_t LISR;   /*!< DMA low interrupt status register,      Address offset: 0x00 */
S  __IO uint32_t HISR;   /*!< DMA high interrupt status register,     Address offset: 0x04 */
S  __IO uint32_t LIFCR;  /*!< DMA low interrupt flag clear register,  Address offset: 0x08 */
S  __IO uint32_t HIFCR;  /*!< DMA high interrupt flag clear register, Address offset: 0x0C */
S} DMA_TypeDef;
S 
S/** 
S  * @brief DMA2D Controller
S  */
S
Stypedef struct
S{
S  __IO uint32_t CR;            /*!< DMA2D Control Register,                         Address offset: 0x00 */
S  __IO uint32_t ISR;           /*!< DMA2D Interrupt Status Register,                Address offset: 0x04 */
S  __IO uint32_t IFCR;          /*!< DMA2D Interrupt Flag Clear Register,            Address offset: 0x08 */
S  __IO uint32_t FGMAR;         /*!< DMA2D Foreground Memory Address Register,       Address offset: 0x0C */
S  __IO uint32_t FGOR;          /*!< DMA2D Foreground Offset Register,               Address offset: 0x10 */
S  __IO uint32_t BGMAR;         /*!< DMA2D Background Memory Address Register,       Address offset: 0x14 */
S  __IO uint32_t BGOR;          /*!< DMA2D Background Offset Register,               Address offset: 0x18 */
S  __IO uint32_t FGPFCCR;       /*!< DMA2D Foreground PFC Control Register,          Address offset: 0x1C */
S  __IO uint32_t FGCOLR;        /*!< DMA2D Foreground Color Register,                Address offset: 0x20 */
S  __IO uint32_t BGPFCCR;       /*!< DMA2D Background PFC Control Register,          Address offset: 0x24 */
S  __IO uint32_t BGCOLR;        /*!< DMA2D Background Color Register,                Address offset: 0x28 */
S  __IO uint32_t FGCMAR;        /*!< DMA2D Foreground CLUT Memory Address Register,  Address offset: 0x2C */
S  __IO uint32_t BGCMAR;        /*!< DMA2D Background CLUT Memory Address Register,  Address offset: 0x30 */
S  __IO uint32_t OPFCCR;        /*!< DMA2D Output PFC Control Register,              Address offset: 0x34 */
S  __IO uint32_t OCOLR;         /*!< DMA2D Output Color Register,                    Address offset: 0x38 */
S  __IO uint32_t OMAR;          /*!< DMA2D Output Memory Address Register,           Address offset: 0x3C */
S  __IO uint32_t OOR;           /*!< DMA2D Output Offset Register,                   Address offset: 0x40 */
S  __IO uint32_t NLR;           /*!< DMA2D Number of Line Register,                  Address offset: 0x44 */
S  __IO uint32_t LWR;           /*!< DMA2D Line Watermark Register,                  Address offset: 0x48 */
S  __IO uint32_t AMTCR;         /*!< DMA2D AHB Master Timer Configuration Register,  Address offset: 0x4C */
S  uint32_t      RESERVED[236]; /*!< Reserved, 0x50-0x3FF */
S  __IO uint32_t FGCLUT[256];   /*!< DMA2D Foreground CLUT,                          Address offset:400-7FF */
S  __IO uint32_t BGCLUT[256];   /*!< DMA2D Background CLUT,                          Address offset:800-BFF */
S} DMA2D_TypeDef;
S
S#if defined(STM32F469_479xx)
S/** 
S  * @brief DSI Controller
S  */
S
Stypedef struct
S{
S  __IO uint32_t VR;             /*!< DSI Host Version Register,                                 Address offset: 0x00       */
S  __IO uint32_t CR;             /*!< DSI Host Control Register,                                 Address offset: 0x04       */
S  __IO uint32_t CCR;            /*!< DSI HOST Clock Control Register,                           Address offset: 0x08       */
S  __IO uint32_t LVCIDR;         /*!< DSI Host LTDC VCID Register,                               Address offset: 0x0C       */
S  __IO uint32_t LCOLCR;         /*!< DSI Host LTDC Color Coding Register,                       Address offset: 0x10       */ 
S  __IO uint32_t LPCR;           /*!< DSI Host LTDC Polarity Configuration Register,             Address offset: 0x14       */
S  __IO uint32_t LPMCR;          /*!< DSI Host Low-Power Mode Configuration Register,            Address offset: 0x18       */
S  uint32_t      RESERVED0[4];   /*!< Reserved, 0x1C - 0x2B                                                                 */
S  __IO uint32_t PCR;            /*!< DSI Host Protocol Configuration Register,                  Address offset: 0x2C       */ 
S  __IO uint32_t GVCIDR;         /*!< DSI Host Generic VCID Register,                            Address offset: 0x30       */
S  __IO uint32_t MCR;            /*!< DSI Host Mode Configuration Register,                      Address offset: 0x34       */
S  __IO uint32_t VMCR;           /*!< DSI Host Video Mode Configuration Register,                Address offset: 0x38       */
S  __IO uint32_t VPCR;           /*!< DSI Host Video Packet Configuration Register,              Address offset: 0x3C       */
S  __IO uint32_t VCCR;           /*!< DSI Host Video Chunks Configuration Register,              Address offset: 0x40       */
S  __IO uint32_t VNPCR;          /*!< DSI Host Video Null Packet Configuration Register,         Address offset: 0x44       */
S  __IO uint32_t VHSACR;         /*!< DSI Host Video HSA Configuration Register,                 Address offset: 0x48       */
S  __IO uint32_t VHBPCR;         /*!< DSI Host Video HBP Configuration Register,                 Address offset: 0x4C       */
S  __IO uint32_t VLCR;           /*!< DSI Host Video Line Configuration Register,                Address offset: 0x50       */
S  __IO uint32_t VVSACR;         /*!< DSI Host Video VSA Configuration Register,                 Address offset: 0x54       */
S  __IO uint32_t VVBPCR;         /*!< DSI Host Video VBP Configuration Register,                 Address offset: 0x58       */
S  __IO uint32_t VVFPCR;         /*!< DSI Host Video VFP Configuration Register,                 Address offset: 0x5C       */
S  __IO uint32_t VVACR;          /*!< DSI Host Video VA Configuration Register,                  Address offset: 0x60       */
S  __IO uint32_t LCCR;           /*!< DSI Host LTDC Command Configuration Register,              Address offset: 0x64       */ 
S  __IO uint32_t CMCR;           /*!< DSI Host Command Mode Configuration Register,              Address offset: 0x68       */
S  __IO uint32_t GHCR;           /*!< DSI Host Generic Header Configuration Register,            Address offset: 0x6C       */
S  __IO uint32_t GPDR;           /*!< DSI Host Generic Payload Data Register,                    Address offset: 0x70       */
S  __IO uint32_t GPSR;           /*!< DSI Host Generic Packet Status Register,                   Address offset: 0x74       */
S  __IO uint32_t TCCR[6];        /*!< DSI Host Timeout Counter Configuration Register,           Address offset: 0x78-0x8F  */
S  __IO uint32_t TDCR;           /*!< DSI Host 3D Configuration Register,                        Address offset: 0x90       */ 
S  __IO uint32_t CLCR;           /*!< DSI Host Clock Lane Configuration Register,                Address offset: 0x94       */
S  __IO uint32_t CLTCR;          /*!< DSI Host Clock Lane Timer Configuration Register,          Address offset: 0x98       */
S  __IO uint32_t DLTCR;          /*!< DSI Host Data Lane Timer Configuration Register,           Address offset: 0x9C       */
S  __IO uint32_t PCTLR;          /*!< DSI Host PHY Control Register,                             Address offset: 0xA0       */ 
S  __IO uint32_t PCONFR;         /*!< DSI Host PHY Configuration Register,                       Address offset: 0xA4       */ 
S  __IO uint32_t PUCR;           /*!< DSI Host PHY ULPS Control Register,                        Address offset: 0xA8       */
S  __IO uint32_t PTTCR;          /*!< DSI Host PHY TX Triggers Configuration Register,           Address offset: 0xAC       */
S  __IO uint32_t PSR;            /*!< DSI Host PHY Status Register,                              Address offset: 0xB0       */
S  uint32_t      RESERVED1[2];   /*!< Reserved, 0xB4 - 0xBB                                                                 */
S  __IO uint32_t ISR[2];         /*!< DSI Host Interrupt & Status Register,                      Address offset: 0xBC-0xC3  */
S  __IO uint32_t IER[2];         /*!< DSI Host Interrupt Enable Register,                        Address offset: 0xC4-0xCB  */
S  uint32_t      RESERVED2[3];   /*!< Reserved, 0xD0 - 0xD7                                                                 */
S  __IO uint32_t FIR[2];         /*!< DSI Host Force Interrupt Register,                         Address offset: 0xD8-0xDF  */
S  uint32_t      RESERVED3[8];   /*!< Reserved, 0xE0 - 0xFF                                                                 */
S  __IO uint32_t VSCR;           /*!< DSI Host Video Shadow Control Register,                    Address offset: 0x100      */
S  uint32_t      RESERVED4[2];   /*!< Reserved, 0x104 - 0x10B                                                               */
S  __IO uint32_t LCVCIDR;        /*!< DSI Host LTDC Current VCID Register,                       Address offset: 0x10C      */
S  __IO uint32_t LCCCR;          /*!< DSI Host LTDC Current Color Coding Register,               Address offset: 0x110      */
S  uint32_t      RESERVED5;      /*!< Reserved, 0x114                                                                       */
S  __IO uint32_t LPMCCR;         /*!< DSI Host Low-power Mode Current Configuration Register,    Address offset: 0x118      */
S  uint32_t      RESERVED6[7];   /*!< Reserved, 0x11C - 0x137                                                               */
S  __IO uint32_t VMCCR;          /*!< DSI Host Video Mode Current Configuration Register,        Address offset: 0x138      */
S  __IO uint32_t VPCCR;          /*!< DSI Host Video Packet Current Configuration Register,      Address offset: 0x13C      */
S  __IO uint32_t VCCCR;          /*!< DSI Host Video Chuncks Current Configuration Register,     Address offset: 0x140      */
S  __IO uint32_t VNPCCR;         /*!< DSI Host Video Null Packet Current Configuration Register, Address offset: 0x144      */
S  __IO uint32_t VHSACCR;        /*!< DSI Host Video HSA Current Configuration Register,         Address offset: 0x148      */
S  __IO uint32_t VHBPCCR;        /*!< DSI Host Video HBP Current Configuration Register,         Address offset: 0x14C      */
S  __IO uint32_t VLCCR;          /*!< DSI Host Video Line Current Configuration Register,        Address offset: 0x150      */
S  __IO uint32_t VVSACCR;        /*!< DSI Host Video VSA Current Configuration Register,         Address offset: 0x154      */ 
S  __IO uint32_t VVBPCCR;        /*!< DSI Host Video VBP Current Configuration Register,         Address offset: 0x158      */
S  __IO uint32_t VVFPCCR;        /*!< DSI Host Video VFP Current Configuration Register,         Address offset: 0x15C      */
S  __IO uint32_t VVACCR;         /*!< DSI Host Video VA Current Configuration Register,          Address offset: 0x160      */
S  uint32_t      RESERVED7[11];  /*!< Reserved, 0x164 - 0x18F                                                               */
S  __IO uint32_t TDCCR;          /*!< DSI Host 3D Current Configuration Register,                Address offset: 0x190      */
S  uint32_t      RESERVED8[155]; /*!< Reserved, 0x194 - 0x3FF                                                               */
S  __IO uint32_t WCFGR;          /*!< DSI Wrapper Configuration Register,                       Address offset: 0x400       */
S  __IO uint32_t WCR;            /*!< DSI Wrapper Control Register,                             Address offset: 0x404       */
S  __IO uint32_t WIER;           /*!< DSI Wrapper Interrupt Enable Register,                    Address offset: 0x408       */
S  __IO uint32_t WISR;           /*!< DSI Wrapper Interrupt and Status Register,                Address offset: 0x40C       */
S  __IO uint32_t WIFCR;          /*!< DSI Wrapper Interrupt Flag Clear Register,                Address offset: 0x410       */
S  uint32_t      RESERVED9;      /*!< Reserved, 0x414                                                                       */
S  __IO uint32_t WPCR[5];        /*!< DSI Wrapper PHY Configuration Register,                   Address offset: 0x418-0x42B */
S  uint32_t      RESERVED10;     /*!< Reserved, 0x42C                                                                       */
S  __IO uint32_t WRPCR;          /*!< DSI Wrapper Regulator and PLL Control Register, Address offset: 0x430                 */
S} DSI_TypeDef;
S#endif /* STM32F469_479xx */
S
S/** 
S  * @brief Ethernet MAC
S  */
S
Stypedef struct
S{
S  __IO uint32_t MACCR;
S  __IO uint32_t MACFFR;
S  __IO uint32_t MACHTHR;
S  __IO uint32_t MACHTLR;
S  __IO uint32_t MACMIIAR;
S  __IO uint32_t MACMIIDR;
S  __IO uint32_t MACFCR;
S  __IO uint32_t MACVLANTR;             /*    8 */
S  uint32_t      RESERVED0[2];
S  __IO uint32_t MACRWUFFR;             /*   11 */
S  __IO uint32_t MACPMTCSR;
S  uint32_t      RESERVED1[2];
S  __IO uint32_t MACSR;                 /*   15 */
S  __IO uint32_t MACIMR;
S  __IO uint32_t MACA0HR;
S  __IO uint32_t MACA0LR;
S  __IO uint32_t MACA1HR;
S  __IO uint32_t MACA1LR;
S  __IO uint32_t MACA2HR;
S  __IO uint32_t MACA2LR;
S  __IO uint32_t MACA3HR;
S  __IO uint32_t MACA3LR;               /*   24 */
S  uint32_t      RESERVED2[40];
S  __IO uint32_t MMCCR;                 /*   65 */
S  __IO uint32_t MMCRIR;
S  __IO uint32_t MMCTIR;
S  __IO uint32_t MMCRIMR;
S  __IO uint32_t MMCTIMR;               /*   69 */
S  uint32_t      RESERVED3[14];
S  __IO uint32_t MMCTGFSCCR;            /*   84 */
S  __IO uint32_t MMCTGFMSCCR;
S  uint32_t      RESERVED4[5];
S  __IO uint32_t MMCTGFCR;
S  uint32_t      RESERVED5[10];
S  __IO uint32_t MMCRFCECR;
S  __IO uint32_t MMCRFAECR;
S  uint32_t      RESERVED6[10];
S  __IO uint32_t MMCRGUFCR;
S  uint32_t      RESERVED7[334];
S  __IO uint32_t PTPTSCR;
S  __IO uint32_t PTPSSIR;
S  __IO uint32_t PTPTSHR;
S  __IO uint32_t PTPTSLR;
S  __IO uint32_t PTPTSHUR;
S  __IO uint32_t PTPTSLUR;
S  __IO uint32_t PTPTSAR;
S  __IO uint32_t PTPTTHR;
S  __IO uint32_t PTPTTLR;
S  __IO uint32_t RESERVED8;
S  __IO uint32_t PTPTSSR;
S  uint32_t      RESERVED9[565];
S  __IO uint32_t DMABMR;
S  __IO uint32_t DMATPDR;
S  __IO uint32_t DMARPDR;
S  __IO uint32_t DMARDLAR;
S  __IO uint32_t DMATDLAR;
S  __IO uint32_t DMASR;
S  __IO uint32_t DMAOMR;
S  __IO uint32_t DMAIER;
S  __IO uint32_t DMAMFBOCR;
S  __IO uint32_t DMARSWTR;
S  uint32_t      RESERVED10[8];
S  __IO uint32_t DMACHTDR;
S  __IO uint32_t DMACHRDR;
S  __IO uint32_t DMACHTBAR;
S  __IO uint32_t DMACHRBAR;
S} ETH_TypeDef;
S
S/** 
S  * @brief External Interrupt/Event Controller
S  */
S
Stypedef struct
S{
S  __IO uint32_t IMR;    /*!< EXTI Interrupt mask register,            Address offset: 0x00 */
S  __IO uint32_t EMR;    /*!< EXTI Event mask register,                Address offset: 0x04 */
S  __IO uint32_t RTSR;   /*!< EXTI Rising trigger selection register,  Address offset: 0x08 */
S  __IO uint32_t FTSR;   /*!< EXTI Falling trigger selection register, Address offset: 0x0C */
S  __IO uint32_t SWIER;  /*!< EXTI Software interrupt event register,  Address offset: 0x10 */
S  __IO uint32_t PR;     /*!< EXTI Pending register,                   Address offset: 0x14 */
S} EXTI_TypeDef;
S
S/** 
S  * @brief FLASH Registers
S  */
S
Stypedef struct
S{
S  __IO uint32_t ACR;      /*!< FLASH access control register,   Address offset: 0x00 */
S  __IO uint32_t KEYR;     /*!< FLASH key register,              Address offset: 0x04 */
S  __IO uint32_t OPTKEYR;  /*!< FLASH option key register,       Address offset: 0x08 */
S  __IO uint32_t SR;       /*!< FLASH status register,           Address offset: 0x0C */
S  __IO uint32_t CR;       /*!< FLASH control register,          Address offset: 0x10 */
S  __IO uint32_t OPTCR;    /*!< FLASH option control register ,  Address offset: 0x14 */
S  __IO uint32_t OPTCR1;   /*!< FLASH option control register 1, Address offset: 0x18 */
S} FLASH_TypeDef;
S
S#if defined(STM32F40_41xxx) || defined(STM32F412xG) || defined(STM32F413_423xx)
S/** 
S  * @brief Flexible Static Memory Controller
S  */
S
Stypedef struct
S{
S  __IO uint32_t BTCR[8];    /*!< NOR/PSRAM chip-select control register(BCR) and chip-select timing register(BTR), Address offset: 0x00-1C */   
S} FSMC_Bank1_TypeDef; 
S
S/** 
S  * @brief Flexible Static Memory Controller Bank1E
S  */
S  
Stypedef struct
S{
S  __IO uint32_t BWTR[7];    /*!< NOR/PSRAM write timing registers, Address offset: 0x104-0x11C */
S} FSMC_Bank1E_TypeDef;
S
S/** 
S  * @brief Flexible Static Memory Controller Bank2
S  */
S  
Stypedef struct
S{
S  __IO uint32_t PCR2;       /*!< NAND Flash control register 2,                       Address offset: 0x60 */
S  __IO uint32_t SR2;        /*!< NAND Flash FIFO status and interrupt register 2,     Address offset: 0x64 */
S  __IO uint32_t PMEM2;      /*!< NAND Flash Common memory space timing register 2,    Address offset: 0x68 */
S  __IO uint32_t PATT2;      /*!< NAND Flash Attribute memory space timing register 2, Address offset: 0x6C */
S  uint32_t      RESERVED0;  /*!< Reserved, 0x70                                                            */
S  __IO uint32_t ECCR2;      /*!< NAND Flash ECC result registers 2,                   Address offset: 0x74 */
S} FSMC_Bank2_TypeDef;
S
S/** 
S  * @brief Flexible Static Memory Controller Bank3
S  */
S  
Stypedef struct
S{
S  __IO uint32_t PCR3;       /*!< NAND Flash control register 3,                       Address offset: 0x80 */
S  __IO uint32_t SR3;        /*!< NAND Flash FIFO status and interrupt register 3,     Address offset: 0x84 */
S  __IO uint32_t PMEM3;      /*!< NAND Flash Common memory space timing register 3,    Address offset: 0x88 */
S  __IO uint32_t PATT3;      /*!< NAND Flash Attribute memory space timing register 3, Address offset: 0x8C */
S  uint32_t      RESERVED0;  /*!< Reserved, 0x90                                                            */
S  __IO uint32_t ECCR3;      /*!< NAND Flash ECC result registers 3,                   Address offset: 0x94 */
S} FSMC_Bank3_TypeDef;
S
S/** 
S  * @brief Flexible Static Memory Controller Bank4
S  */
S  
Stypedef struct
S{
S  __IO uint32_t PCR4;       /*!< PC Card  control register 4,                       Address offset: 0xA0 */
S  __IO uint32_t SR4;        /*!< PC Card  FIFO status and interrupt register 4,     Address offset: 0xA4 */
S  __IO uint32_t PMEM4;      /*!< PC Card  Common memory space timing register 4,    Address offset: 0xA8 */
S  __IO uint32_t PATT4;      /*!< PC Card  Attribute memory space timing register 4, Address offset: 0xAC */
S  __IO uint32_t PIO4;       /*!< PC Card  I/O space timing register 4,              Address offset: 0xB0 */
S} FSMC_Bank4_TypeDef; 
S#endif /* STM32F40_41xxx || STM32F412xG || STM32F413_423xx */
S
S#if defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
S/** 
S  * @brief Flexible Memory Controller
S  */
S
Stypedef struct
S{
S  __IO uint32_t BTCR[8];    /*!< NOR/PSRAM chip-select control register(BCR) and chip-select timing register(BTR), Address offset: 0x00-1C */   
S} FMC_Bank1_TypeDef; 
S
S/** 
S  * @brief Flexible Memory Controller Bank1E
S  */
S  
Stypedef struct
S{
S  __IO uint32_t BWTR[7];    /*!< NOR/PSRAM write timing registers, Address offset: 0x104-0x11C */
S} FMC_Bank1E_TypeDef;
S
S/** 
S  * @brief Flexible Memory Controller Bank2
S  */
S  
Stypedef struct
S{
S  __IO uint32_t PCR2;       /*!< NAND Flash control register 2,                       Address offset: 0x60 */
S  __IO uint32_t SR2;        /*!< NAND Flash FIFO status and interrupt register 2,     Address offset: 0x64 */
S  __IO uint32_t PMEM2;      /*!< NAND Flash Common memory space timing register 2,    Address offset: 0x68 */
S  __IO uint32_t PATT2;      /*!< NAND Flash Attribute memory space timing register 2, Address offset: 0x6C */
S  uint32_t      RESERVED0;  /*!< Reserved, 0x70                                                            */
S  __IO uint32_t ECCR2;      /*!< NAND Flash ECC result registers 2,                   Address offset: 0x74 */
S} FMC_Bank2_TypeDef;
S
S/** 
S  * @brief Flexible Memory Controller Bank3
S  */
S  
Stypedef struct
S{
S  __IO uint32_t PCR3;       /*!< NAND Flash control register 3,                       Address offset: 0x80 */
S  __IO uint32_t SR3;        /*!< NAND Flash FIFO status and interrupt register 3,     Address offset: 0x84 */
S  __IO uint32_t PMEM3;      /*!< NAND Flash Common memory space timing register 3,    Address offset: 0x88 */
S  __IO uint32_t PATT3;      /*!< NAND Flash Attribute memory space timing register 3, Address offset: 0x8C */
S  uint32_t      RESERVED0;  /*!< Reserved, 0x90                                                            */
S  __IO uint32_t ECCR3;      /*!< NAND Flash ECC result registers 3,                   Address offset: 0x94 */
S} FMC_Bank3_TypeDef;
S
S/** 
S  * @brief Flexible Memory Controller Bank4
S  */
S  
Stypedef struct
S{
S  __IO uint32_t PCR4;       /*!< PC Card  control register 4,                       Address offset: 0xA0 */
S  __IO uint32_t SR4;        /*!< PC Card  FIFO status and interrupt register 4,     Address offset: 0xA4 */
S  __IO uint32_t PMEM4;      /*!< PC Card  Common memory space timing register 4,    Address offset: 0xA8 */
S  __IO uint32_t PATT4;      /*!< PC Card  Attribute memory space timing register 4, Address offset: 0xAC */
S  __IO uint32_t PIO4;       /*!< PC Card  I/O space timing register 4,              Address offset: 0xB0 */
S} FMC_Bank4_TypeDef; 
S
S/** 
S  * @brief Flexible Memory Controller Bank5_6
S  */
S  
Stypedef struct
S{
S  __IO uint32_t SDCR[2];        /*!< SDRAM Control registers ,      Address offset: 0x140-0x144  */
S  __IO uint32_t SDTR[2];        /*!< SDRAM Timing registers ,       Address offset: 0x148-0x14C  */
S  __IO uint32_t SDCMR;       /*!< SDRAM Command Mode register,    Address offset: 0x150  */
S  __IO uint32_t SDRTR;       /*!< SDRAM Refresh Timer register,   Address offset: 0x154  */
S  __IO uint32_t SDSR;        /*!< SDRAM Status register,          Address offset: 0x158  */
S} FMC_Bank5_6_TypeDef; 
S#endif /* STM32F427_437xx ||  STM32F429_439xx || STM32F446xx || STM32F469_479xx */
S
S/** 
S  * @brief General Purpose I/O
S  */
S
Stypedef struct
S{
S  __IO uint32_t MODER;    /*!< GPIO port mode register,               Address offset: 0x00      */
S  __IO uint32_t OTYPER;   /*!< GPIO port output type register,        Address offset: 0x04      */
S  __IO uint32_t OSPEEDR;  /*!< GPIO port output speed register,       Address offset: 0x08      */
S  __IO uint32_t PUPDR;    /*!< GPIO port pull-up/pull-down register,  Address offset: 0x0C      */
S  __IO uint32_t IDR;      /*!< GPIO port input data register,         Address offset: 0x10      */
S  __IO uint32_t ODR;      /*!< GPIO port output data register,        Address offset: 0x14      */
S  __IO uint16_t BSRRL;    /*!< GPIO port bit set/reset low register,  Address offset: 0x18      */
S  __IO uint16_t BSRRH;    /*!< GPIO port bit set/reset high register, Address offset: 0x1A      */
S  __IO uint32_t LCKR;     /*!< GPIO port configuration lock register, Address offset: 0x1C      */
S  __IO uint32_t AFR[2];   /*!< GPIO alternate function registers,     Address offset: 0x20-0x24 */
S} GPIO_TypeDef;
S
S/** 
S  * @brief System configuration controller
S  */
S  
Stypedef struct
S{
S  __IO uint32_t MEMRMP;       /*!< SYSCFG memory remap register,                      Address offset: 0x00      */
S  __IO uint32_t PMC;          /*!< SYSCFG peripheral mode configuration register,     Address offset: 0x04      */
S  __IO uint32_t EXTICR[4];    /*!< SYSCFG external interrupt configuration registers, Address offset: 0x08-0x14 */
S#if defined (STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx)
S  uint32_t      RESERVED;     /*!< Reserved, 0x18                                                               */
S  __IO uint32_t CFGR2;        /*!< Reserved, 0x1C                                                               */
S  __IO uint32_t CMPCR;        /*!< SYSCFG Compensation cell control register,         Address offset: 0x20      */
S  uint32_t      RESERVED1[2]; /*!< Reserved, 0x24-0x28                                                          */
S  __IO uint32_t CFGR;         /*!< SYSCFG Configuration register,                     Address offset: 0x2C      */
S#else  /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F401xx || STM32F411xE || STM32F446xx || STM32F469_479xx */
S  uint32_t      RESERVED[2];  /*!< Reserved, 0x18-0x1C                                                          */ 
S  __IO uint32_t CMPCR;        /*!< SYSCFG Compensation cell control register,         Address offset: 0x20      */
S#endif /* STM32F410xx || defined(STM32F412xG) || defined(STM32F413_423xx) */
S#if defined(STM32F413_423xx)
S  __IO uint32_t MCHDLYCR;     /*!< SYSCFG multi-channel delay register,               Address offset: 0x30      */
S#endif /* STM32F413_423xx */
S} SYSCFG_TypeDef;
S
S/** 
S  * @brief Inter-integrated Circuit Interface
S  */
S
Stypedef struct
S{
S  __IO uint16_t CR1;        /*!< I2C Control register 1,     Address offset: 0x00 */
S  uint16_t      RESERVED0;  /*!< Reserved, 0x02                                   */
S  __IO uint16_t CR2;        /*!< I2C Control register 2,     Address offset: 0x04 */
S  uint16_t      RESERVED1;  /*!< Reserved, 0x06                                   */
S  __IO uint16_t OAR1;       /*!< I2C Own address register 1, Address offset: 0x08 */
S  uint16_t      RESERVED2;  /*!< Reserved, 0x0A                                   */
S  __IO uint16_t OAR2;       /*!< I2C Own address register 2, Address offset: 0x0C */
S  uint16_t      RESERVED3;  /*!< Reserved, 0x0E                                   */
S  __IO uint16_t DR;         /*!< I2C Data register,          Address offset: 0x10 */
S  uint16_t      RESERVED4;  /*!< Reserved, 0x12                                   */
S  __IO uint16_t SR1;        /*!< I2C Status register 1,      Address offset: 0x14 */
S  uint16_t      RESERVED5;  /*!< Reserved, 0x16                                   */
S  __IO uint16_t SR2;        /*!< I2C Status register 2,      Address offset: 0x18 */
S  uint16_t      RESERVED6;  /*!< Reserved, 0x1A                                   */
S  __IO uint16_t CCR;        /*!< I2C Clock control register, Address offset: 0x1C */
S  uint16_t      RESERVED7;  /*!< Reserved, 0x1E                                   */
S  __IO uint16_t TRISE;      /*!< I2C TRISE register,         Address offset: 0x20 */
S  uint16_t      RESERVED8;  /*!< Reserved, 0x22                                   */
S  __IO uint16_t FLTR;       /*!< I2C FLTR register,          Address offset: 0x24 */
S  uint16_t      RESERVED9;  /*!< Reserved, 0x26                                   */
S} I2C_TypeDef;
S
S#if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) 
S/**
S  * @brief Inter-integrated Circuit Interface
S  */
S
Stypedef struct
S{
S  __IO uint32_t CR1;      /*!< FMPI2C Control register 1,            Address offset: 0x00 */
S  __IO uint32_t CR2;      /*!< FMPI2C Control register 2,            Address offset: 0x04 */
S  __IO uint32_t OAR1;     /*!< FMPI2C Own address 1 register,        Address offset: 0x08 */
S  __IO uint32_t OAR2;     /*!< FMPI2C Own address 2 register,        Address offset: 0x0C */
S  __IO uint32_t TIMINGR;  /*!< FMPI2C Timing register,               Address offset: 0x10 */
S  __IO uint32_t TIMEOUTR; /*!< FMPI2C Timeout register,              Address offset: 0x14 */
S  __IO uint32_t ISR;      /*!< FMPI2C Interrupt and status register, Address offset: 0x18 */
S  __IO uint32_t ICR;      /*!< FMPI2C Interrupt clear register,      Address offset: 0x1C */
S  __IO uint32_t PECR;     /*!< FMPI2C PEC register,                  Address offset: 0x20 */
S  __IO uint32_t RXDR;     /*!< FMPI2C Receive data register,         Address offset: 0x24 */
S  __IO uint32_t TXDR;     /*!< FMPI2C Transmit data register,        Address offset: 0x28 */
S}FMPI2C_TypeDef;
S#endif /* STM32F410xx || STM32F412xG || STM32F413_423xx || STM32F446xx */
S
S/** 
S  * @brief Independent WATCHDOG
S  */
S
Stypedef struct
S{
S  __IO uint32_t KR;   /*!< IWDG Key register,       Address offset: 0x00 */
S  __IO uint32_t PR;   /*!< IWDG Prescaler register, Address offset: 0x04 */
S  __IO uint32_t RLR;  /*!< IWDG Reload register,    Address offset: 0x08 */
S  __IO uint32_t SR;   /*!< IWDG Status register,    Address offset: 0x0C */
S} IWDG_TypeDef;
S
S/** 
S  * @brief LCD-TFT Display Controller
S  */
S  
Stypedef struct
S{
S  uint32_t      RESERVED0[2];  /*!< Reserved, 0x00-0x04 */
S  __IO uint32_t SSCR;          /*!< LTDC Synchronization Size Configuration Register,    Address offset: 0x08 */
S  __IO uint32_t BPCR;          /*!< LTDC Back Porch Configuration Register,              Address offset: 0x0C */
S  __IO uint32_t AWCR;          /*!< LTDC Active Width Configuration Register,            Address offset: 0x10 */
S  __IO uint32_t TWCR;          /*!< LTDC Total Width Configuration Register,             Address offset: 0x14 */
S  __IO uint32_t GCR;           /*!< LTDC Global Control Register,                        Address offset: 0x18 */
S  uint32_t      RESERVED1[2];  /*!< Reserved, 0x1C-0x20 */
S  __IO uint32_t SRCR;          /*!< LTDC Shadow Reload Configuration Register,           Address offset: 0x24 */
S  uint32_t      RESERVED2[1];  /*!< Reserved, 0x28 */
S  __IO uint32_t BCCR;          /*!< LTDC Background Color Configuration Register,        Address offset: 0x2C */
S  uint32_t      RESERVED3[1];  /*!< Reserved, 0x30 */
S  __IO uint32_t IER;           /*!< LTDC Interrupt Enable Register,                      Address offset: 0x34 */
S  __IO uint32_t ISR;           /*!< LTDC Interrupt Status Register,                      Address offset: 0x38 */
S  __IO uint32_t ICR;           /*!< LTDC Interrupt Clear Register,                       Address offset: 0x3C */
S  __IO uint32_t LIPCR;         /*!< LTDC Line Interrupt Position Configuration Register, Address offset: 0x40 */
S  __IO uint32_t CPSR;          /*!< LTDC Current Position Status Register,               Address offset: 0x44 */
S  __IO uint32_t CDSR;         /*!< LTDC Current Display Status Register,                       Address offset: 0x48 */
S} LTDC_TypeDef;  
S
S/** 
S  * @brief LCD-TFT Display layer x Controller
S  */
S  
Stypedef struct
S{  
S  __IO uint32_t CR;            /*!< LTDC Layerx Control Register                                  Address offset: 0x84 */
S  __IO uint32_t WHPCR;         /*!< LTDC Layerx Window Horizontal Position Configuration Register Address offset: 0x88 */
S  __IO uint32_t WVPCR;         /*!< LTDC Layerx Window Vertical Position Configuration Register   Address offset: 0x8C */
S  __IO uint32_t CKCR;          /*!< LTDC Layerx Color Keying Configuration Register               Address offset: 0x90 */
S  __IO uint32_t PFCR;          /*!< LTDC Layerx Pixel Format Configuration Register               Address offset: 0x94 */
S  __IO uint32_t CACR;          /*!< LTDC Layerx Constant Alpha Configuration Register             Address offset: 0x98 */
S  __IO uint32_t DCCR;          /*!< LTDC Layerx Default Color Configuration Register              Address offset: 0x9C */
S  __IO uint32_t BFCR;          /*!< LTDC Layerx Blending Factors Configuration Register           Address offset: 0xA0 */
S  uint32_t      RESERVED0[2];  /*!< Reserved */
S  __IO uint32_t CFBAR;         /*!< LTDC Layerx Color Frame Buffer Address Register               Address offset: 0xAC */
S  __IO uint32_t CFBLR;         /*!< LTDC Layerx Color Frame Buffer Length Register                Address offset: 0xB0 */
S  __IO uint32_t CFBLNR;        /*!< LTDC Layerx ColorFrame Buffer Line Number Register            Address offset: 0xB4 */
S  uint32_t      RESERVED1[3];  /*!< Reserved */
S  __IO uint32_t CLUTWR;         /*!< LTDC Layerx CLUT Write Register                               Address offset: 0x144 */
S
S} LTDC_Layer_TypeDef;
S
S/** 
S  * @brief Power Control
S  */
S
Stypedef struct
S{
S  __IO uint32_t CR;   /*!< PWR power control register,        Address offset: 0x00 */
S  __IO uint32_t CSR;  /*!< PWR power control/status register, Address offset: 0x04 */
S} PWR_TypeDef;
S
S/** 
S  * @brief Reset and Clock Control
S  */
S
Stypedef struct
S{
S  __IO uint32_t CR;            /*!< RCC clock control register,                                  Address offset: 0x00 */
S  __IO uint32_t PLLCFGR;       /*!< RCC PLL configuration register,                              Address offset: 0x04 */
S  __IO uint32_t CFGR;          /*!< RCC clock configuration register,                            Address offset: 0x08 */
S  __IO uint32_t CIR;           /*!< RCC clock interrupt register,                                Address offset: 0x0C */
S  __IO uint32_t AHB1RSTR;      /*!< RCC AHB1 peripheral reset register,                          Address offset: 0x10 */
S  __IO uint32_t AHB2RSTR;      /*!< RCC AHB2 peripheral reset register,                          Address offset: 0x14 */
S  __IO uint32_t AHB3RSTR;      /*!< RCC AHB3 peripheral reset register,                          Address offset: 0x18 */
S  uint32_t      RESERVED0;     /*!< Reserved, 0x1C                                                                    */
S  __IO uint32_t APB1RSTR;      /*!< RCC APB1 peripheral reset register,                          Address offset: 0x20 */
S  __IO uint32_t APB2RSTR;      /*!< RCC APB2 peripheral reset register,                          Address offset: 0x24 */
S  uint32_t      RESERVED1[2];  /*!< Reserved, 0x28-0x2C                                                               */
S  __IO uint32_t AHB1ENR;       /*!< RCC AHB1 peripheral clock register,                          Address offset: 0x30 */
S  __IO uint32_t AHB2ENR;       /*!< RCC AHB2 peripheral clock register,                          Address offset: 0x34 */
S  __IO uint32_t AHB3ENR;       /*!< RCC AHB3 peripheral clock register,                          Address offset: 0x38 */
S  uint32_t      RESERVED2;     /*!< Reserved, 0x3C                                                                    */
S  __IO uint32_t APB1ENR;       /*!< RCC APB1 peripheral clock enable register,                   Address offset: 0x40 */
S  __IO uint32_t APB2ENR;       /*!< RCC APB2 peripheral clock enable register,                   Address offset: 0x44 */
S  uint32_t      RESERVED3[2];  /*!< Reserved, 0x48-0x4C                                                               */
S  __IO uint32_t AHB1LPENR;     /*!< RCC AHB1 peripheral clock enable in low power mode register, Address offset: 0x50 */
S  __IO uint32_t AHB2LPENR;     /*!< RCC AHB2 peripheral clock enable in low power mode register, Address offset: 0x54 */
S  __IO uint32_t AHB3LPENR;     /*!< RCC AHB3 peripheral clock enable in low power mode register, Address offset: 0x58 */
S  uint32_t      RESERVED4;     /*!< Reserved, 0x5C                                                                    */
S  __IO uint32_t APB1LPENR;     /*!< RCC APB1 peripheral clock enable in low power mode register, Address offset: 0x60 */
S  __IO uint32_t APB2LPENR;     /*!< RCC APB2 peripheral clock enable in low power mode register, Address offset: 0x64 */
S  uint32_t      RESERVED5[2];  /*!< Reserved, 0x68-0x6C                                                               */
S  __IO uint32_t BDCR;          /*!< RCC Backup domain control register,                          Address offset: 0x70 */
S  __IO uint32_t CSR;           /*!< RCC clock control & status register,                         Address offset: 0x74 */
S  uint32_t      RESERVED6[2];  /*!< Reserved, 0x78-0x7C                                                               */
S  __IO uint32_t SSCGR;         /*!< RCC spread spectrum clock generation register,               Address offset: 0x80 */
S  __IO uint32_t PLLI2SCFGR;    /*!< RCC PLLI2S configuration register,                           Address offset: 0x84 */
S  __IO uint32_t PLLSAICFGR;    /*!< RCC PLLSAI configuration register,                           Address offset: 0x88 */
S  __IO uint32_t DCKCFGR;       /*!< RCC Dedicated Clocks configuration register,                 Address offset: 0x8C */
S  __IO uint32_t CKGATENR;      /*!< RCC Clocks Gated Enable Register,                            Address offset: 0x90 */ /* Only for STM32F412xG, STM32413_423xx and STM32F446xx devices */
S  __IO uint32_t DCKCFGR2;      /*!< RCC Dedicated Clocks configuration register 2,               Address offset: 0x94 */ /* Only for STM32F410xx, STM32F412xG, STM32413_423xx and STM32F446xx devices */
S
S} RCC_TypeDef;
S
S/** 
S  * @brief Real-Time Clock
S  */
S
Stypedef struct
S{
S  __IO uint32_t TR;      /*!< RTC time register,                                        Address offset: 0x00 */
S  __IO uint32_t DR;      /*!< RTC date register,                                        Address offset: 0x04 */
S  __IO uint32_t CR;      /*!< RTC control register,                                     Address offset: 0x08 */
S  __IO uint32_t ISR;     /*!< RTC initialization and status register,                   Address offset: 0x0C */
S  __IO uint32_t PRER;    /*!< RTC prescaler register,                                   Address offset: 0x10 */
S  __IO uint32_t WUTR;    /*!< RTC wakeup timer register,                                Address offset: 0x14 */
S  __IO uint32_t CALIBR;  /*!< RTC calibration register,                                 Address offset: 0x18 */
S  __IO uint32_t ALRMAR;  /*!< RTC alarm A register,                                     Address offset: 0x1C */
S  __IO uint32_t ALRMBR;  /*!< RTC alarm B register,                                     Address offset: 0x20 */
S  __IO uint32_t WPR;     /*!< RTC write protection register,                            Address offset: 0x24 */
S  __IO uint32_t SSR;     /*!< RTC sub second register,                                  Address offset: 0x28 */
S  __IO uint32_t SHIFTR;  /*!< RTC shift control register,                               Address offset: 0x2C */
S  __IO uint32_t TSTR;    /*!< RTC time stamp time register,                             Address offset: 0x30 */
S  __IO uint32_t TSDR;    /*!< RTC time stamp date register,                             Address offset: 0x34 */
S  __IO uint32_t TSSSR;   /*!< RTC time-stamp sub second register,                       Address offset: 0x38 */
S  __IO uint32_t CALR;    /*!< RTC calibration register,                                 Address offset: 0x3C */
S  __IO uint32_t TAFCR;   /*!< RTC tamper and alternate function configuration register, Address offset: 0x40 */
S  __IO uint32_t ALRMASSR;/*!< RTC alarm A sub second register,                          Address offset: 0x44 */
S  __IO uint32_t ALRMBSSR;/*!< RTC alarm B sub second register,                          Address offset: 0x48 */
S  uint32_t RESERVED7;    /*!< Reserved, 0x4C                                                                 */
S  __IO uint32_t BKP0R;   /*!< RTC backup register 1,                                    Address offset: 0x50 */
S  __IO uint32_t BKP1R;   /*!< RTC backup register 1,                                    Address offset: 0x54 */
S  __IO uint32_t BKP2R;   /*!< RTC backup register 2,                                    Address offset: 0x58 */
S  __IO uint32_t BKP3R;   /*!< RTC backup register 3,                                    Address offset: 0x5C */
S  __IO uint32_t BKP4R;   /*!< RTC backup register 4,                                    Address offset: 0x60 */
S  __IO uint32_t BKP5R;   /*!< RTC backup register 5,                                    Address offset: 0x64 */
S  __IO uint32_t BKP6R;   /*!< RTC backup register 6,                                    Address offset: 0x68 */
S  __IO uint32_t BKP7R;   /*!< RTC backup register 7,                                    Address offset: 0x6C */
S  __IO uint32_t BKP8R;   /*!< RTC backup register 8,                                    Address offset: 0x70 */
S  __IO uint32_t BKP9R;   /*!< RTC backup register 9,                                    Address offset: 0x74 */
S  __IO uint32_t BKP10R;  /*!< RTC backup register 10,                                   Address offset: 0x78 */
S  __IO uint32_t BKP11R;  /*!< RTC backup register 11,                                   Address offset: 0x7C */
S  __IO uint32_t BKP12R;  /*!< RTC backup register 12,                                   Address offset: 0x80 */
S  __IO uint32_t BKP13R;  /*!< RTC backup register 13,                                   Address offset: 0x84 */
S  __IO uint32_t BKP14R;  /*!< RTC backup register 14,                                   Address offset: 0x88 */
S  __IO uint32_t BKP15R;  /*!< RTC backup register 15,                                   Address offset: 0x8C */
S  __IO uint32_t BKP16R;  /*!< RTC backup register 16,                                   Address offset: 0x90 */
S  __IO uint32_t BKP17R;  /*!< RTC backup register 17,                                   Address offset: 0x94 */
S  __IO uint32_t BKP18R;  /*!< RTC backup register 18,                                   Address offset: 0x98 */
S  __IO uint32_t BKP19R;  /*!< RTC backup register 19,                                   Address offset: 0x9C */
S} RTC_TypeDef;
S
S
S/** 
S  * @brief Serial Audio Interface
S  */
S  
Stypedef struct
S{
S  __IO uint32_t GCR;      /*!< SAI global configuration register,        Address offset: 0x00 */
S} SAI_TypeDef;
S
Stypedef struct
S{
S  __IO uint32_t CR1;      /*!< SAI block x configuration register 1,     Address offset: 0x04 */
S  __IO uint32_t CR2;      /*!< SAI block x configuration register 2,     Address offset: 0x08 */
S  __IO uint32_t FRCR;     /*!< SAI block x frame configuration register, Address offset: 0x0C */
S  __IO uint32_t SLOTR;    /*!< SAI block x slot register,                Address offset: 0x10 */
S  __IO uint32_t IMR;      /*!< SAI block x interrupt mask register,      Address offset: 0x14 */
S  __IO uint32_t SR;       /*!< SAI block x status register,              Address offset: 0x18 */
S  __IO uint32_t CLRFR;    /*!< SAI block x clear flag register,          Address offset: 0x1C */
S  __IO uint32_t DR;       /*!< SAI block x data register,                Address offset: 0x20 */
S} SAI_Block_TypeDef;
S
S/** 
S  * @brief SD host Interface
S  */
S
Stypedef struct
S{
S  __IO uint32_t POWER;          /*!< SDIO power control register,    Address offset: 0x00 */
S  __IO uint32_t CLKCR;          /*!< SDI clock control register,     Address offset: 0x04 */
S  __IO uint32_t ARG;            /*!< SDIO argument register,         Address offset: 0x08 */
S  __IO uint32_t CMD;            /*!< SDIO command register,          Address offset: 0x0C */
S  __I uint32_t  RESPCMD;        /*!< SDIO command response register, Address offset: 0x10 */
S  __I uint32_t  RESP1;          /*!< SDIO response 1 register,       Address offset: 0x14 */
S  __I uint32_t  RESP2;          /*!< SDIO response 2 register,       Address offset: 0x18 */
S  __I uint32_t  RESP3;          /*!< SDIO response 3 register,       Address offset: 0x1C */
S  __I uint32_t  RESP4;          /*!< SDIO response 4 register,       Address offset: 0x20 */
S  __IO uint32_t DTIMER;         /*!< SDIO data timer register,       Address offset: 0x24 */
S  __IO uint32_t DLEN;           /*!< SDIO data length register,      Address offset: 0x28 */
S  __IO uint32_t DCTRL;          /*!< SDIO data control register,     Address offset: 0x2C */
S  __I uint32_t  DCOUNT;         /*!< SDIO data counter register,     Address offset: 0x30 */
S  __I uint32_t  STA;            /*!< SDIO status register,           Address offset: 0x34 */
S  __IO uint32_t ICR;            /*!< SDIO interrupt clear register,  Address offset: 0x38 */
S  __IO uint32_t MASK;           /*!< SDIO mask register,             Address offset: 0x3C */
S  uint32_t      RESERVED0[2];   /*!< Reserved, 0x40-0x44                                  */
S  __I uint32_t  FIFOCNT;        /*!< SDIO FIFO counter register,     Address offset: 0x48 */
S  uint32_t      RESERVED1[13];  /*!< Reserved, 0x4C-0x7C                                  */
S  __IO uint32_t FIFO;           /*!< SDIO data FIFO register,        Address offset: 0x80 */
S} SDIO_TypeDef;
S
S/** 
S  * @brief Serial Peripheral Interface
S  */
S
Stypedef struct
S{
S  __IO uint16_t CR1;        /*!< SPI control register 1 (not used in I2S mode),      Address offset: 0x00 */
S  uint16_t      RESERVED0;  /*!< Reserved, 0x02                                                           */
S  __IO uint16_t CR2;        /*!< SPI control register 2,                             Address offset: 0x04 */
S  uint16_t      RESERVED1;  /*!< Reserved, 0x06                                                           */
S  __IO uint16_t SR;         /*!< SPI status register,                                Address offset: 0x08 */
S  uint16_t      RESERVED2;  /*!< Reserved, 0x0A                                                           */
S  __IO uint16_t DR;         /*!< SPI data register,                                  Address offset: 0x0C */
S  uint16_t      RESERVED3;  /*!< Reserved, 0x0E                                                           */
S  __IO uint16_t CRCPR;      /*!< SPI CRC polynomial register (not used in I2S mode), Address offset: 0x10 */
S  uint16_t      RESERVED4;  /*!< Reserved, 0x12                                                           */
S  __IO uint16_t RXCRCR;     /*!< SPI RX CRC register (not used in I2S mode),         Address offset: 0x14 */
S  uint16_t      RESERVED5;  /*!< Reserved, 0x16                                                           */
S  __IO uint16_t TXCRCR;     /*!< SPI TX CRC register (not used in I2S mode),         Address offset: 0x18 */
S  uint16_t      RESERVED6;  /*!< Reserved, 0x1A                                                           */
S  __IO uint16_t I2SCFGR;    /*!< SPI_I2S configuration register,                     Address offset: 0x1C */
S  uint16_t      RESERVED7;  /*!< Reserved, 0x1E                                                           */
S  __IO uint16_t I2SPR;      /*!< SPI_I2S prescaler register,                         Address offset: 0x20 */
S  uint16_t      RESERVED8;  /*!< Reserved, 0x22                                                           */
S} SPI_TypeDef;
S
S#if defined(STM32F446xx)
S/** 
S  * @brief SPDIFRX Interface
S  */
Stypedef struct
S{
S  __IO uint32_t   CR;           /*!< Control register,                   Address offset: 0x00 */
S  __IO uint16_t   IMR;          /*!< Interrupt mask register,            Address offset: 0x04 */
S  uint16_t        RESERVED0;    /*!< Reserved,  0x06                                          */  
S  __IO uint32_t   SR;           /*!< Status register,                    Address offset: 0x08 */
S  __IO uint16_t   IFCR;         /*!< Interrupt Flag Clear register,      Address offset: 0x0C */
S  uint16_t        RESERVED1;    /*!< Reserved,  0x0E                                          */   
S  __IO uint32_t   DR;           /*!< Data input register,                Address offset: 0x10 */
S  __IO uint32_t   CSR;          /*!< Channel Status register,            Address offset: 0x14 */
S   __IO uint32_t  DIR;          /*!< Debug Information register,         Address offset: 0x18 */
S  uint16_t        RESERVED2;    /*!< Reserved,  0x1A                                          */   
S} SPDIFRX_TypeDef;
S#endif /* STM32F446xx */
S
S#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
S/** 
S  * @brief QUAD Serial Peripheral Interface
S  */
Stypedef struct
S{
S  __IO uint32_t CR;       /*!< QUADSPI Control register,                           Address offset: 0x00 */
S  __IO uint32_t DCR;      /*!< QUADSPI Device Configuration register,              Address offset: 0x04 */
S  __IO uint32_t SR;       /*!< QUADSPI Status register,                            Address offset: 0x08 */
S  __IO uint32_t FCR;      /*!< QUADSPI Flag Clear register,                        Address offset: 0x0C */
S  __IO uint32_t DLR;      /*!< QUADSPI Data Length register,                       Address offset: 0x10 */
S  __IO uint32_t CCR;      /*!< QUADSPI Communication Configuration register,       Address offset: 0x14 */
S  __IO uint32_t AR;       /*!< QUADSPI Address register,                           Address offset: 0x18 */
S  __IO uint32_t ABR;      /*!< QUADSPI Alternate Bytes register,                   Address offset: 0x1C */
S  __IO uint32_t DR;       /*!< QUADSPI Data register,                              Address offset: 0x20 */
S  __IO uint32_t PSMKR;    /*!< QUADSPI Polling Status Mask register,               Address offset: 0x24 */
S  __IO uint32_t PSMAR;    /*!< QUADSPI Polling Status Match register,              Address offset: 0x28 */
S  __IO uint32_t PIR;      /*!< QUADSPI Polling Interval register,                  Address offset: 0x2C */
S  __IO uint32_t LPTR;     /*!< QUADSPI Low Power Timeout register,                 Address offset: 0x30 */
S} QUADSPI_TypeDef;
S#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx || STM32F469_479xx */
S
S#if defined(STM32F446xx)
S/** 
S  * @brief SPDIF-RX Interface
S  */
Stypedef struct
S{
S  __IO uint32_t   CR;           /*!< Control register,                   Address offset: 0x00 */
S  __IO uint16_t   IMR;          /*!< Interrupt mask register,            Address offset: 0x04 */
S  uint16_t        RESERVED0;    /*!< Reserved,  0x06                                          */  
S  __IO uint32_t   SR;           /*!< Status register,                    Address offset: 0x08 */
S  __IO uint16_t   IFCR;         /*!< Interrupt Flag Clear register,      Address offset: 0x0C */
S  uint16_t        RESERVED1;    /*!< Reserved,  0x0E                                          */   
S  __IO uint32_t   DR;           /*!< Data input register,                Address offset: 0x10 */
S  __IO uint32_t   CSR;          /*!< Channel Status register,            Address offset: 0x14 */
S   __IO uint32_t  DIR;          /*!< Debug Information register,         Address offset: 0x18 */
S  uint16_t        RESERVED2;    /*!< Reserved,  0x1A                                          */   
S} SPDIF_TypeDef;
S#endif /* STM32F446xx */
S
S/** 
S  * @brief TIM
S  */
S
Stypedef struct
S{
S  __IO uint16_t CR1;         /*!< TIM control register 1,              Address offset: 0x00 */
S  uint16_t      RESERVED0;   /*!< Reserved, 0x02                                            */
S  __IO uint16_t CR2;         /*!< TIM control register 2,              Address offset: 0x04 */
S  uint16_t      RESERVED1;   /*!< Reserved, 0x06                                            */
S  __IO uint16_t SMCR;        /*!< TIM slave mode control register,     Address offset: 0x08 */
S  uint16_t      RESERVED2;   /*!< Reserved, 0x0A                                            */
S  __IO uint16_t DIER;        /*!< TIM DMA/interrupt enable register,   Address offset: 0x0C */
S  uint16_t      RESERVED3;   /*!< Reserved, 0x0E                                            */
S  __IO uint16_t SR;          /*!< TIM status register,                 Address offset: 0x10 */
S  uint16_t      RESERVED4;   /*!< Reserved, 0x12                                            */
S  __IO uint16_t EGR;         /*!< TIM event generation register,       Address offset: 0x14 */
S  uint16_t      RESERVED5;   /*!< Reserved, 0x16                                            */
S  __IO uint16_t CCMR1;       /*!< TIM capture/compare mode register 1, Address offset: 0x18 */
S  uint16_t      RESERVED6;   /*!< Reserved, 0x1A                                            */
S  __IO uint16_t CCMR2;       /*!< TIM capture/compare mode register 2, Address offset: 0x1C */
S  uint16_t      RESERVED7;   /*!< Reserved, 0x1E                                            */
S  __IO uint16_t CCER;        /*!< TIM capture/compare enable register, Address offset: 0x20 */
S  uint16_t      RESERVED8;   /*!< Reserved, 0x22                                            */
S  __IO uint32_t CNT;         /*!< TIM counter register,                Address offset: 0x24 */
S  __IO uint16_t PSC;         /*!< TIM prescaler,                       Address offset: 0x28 */
S  uint16_t      RESERVED9;   /*!< Reserved, 0x2A                                            */
S  __IO uint32_t ARR;         /*!< TIM auto-reload register,            Address offset: 0x2C */
S  __IO uint16_t RCR;         /*!< TIM repetition counter register,     Address offset: 0x30 */
S  uint16_t      RESERVED10;  /*!< Reserved, 0x32                                            */
S  __IO uint32_t CCR1;        /*!< TIM capture/compare register 1,      Address offset: 0x34 */
S  __IO uint32_t CCR2;        /*!< TIM capture/compare register 2,      Address offset: 0x38 */
S  __IO uint32_t CCR3;        /*!< TIM capture/compare register 3,      Address offset: 0x3C */
S  __IO uint32_t CCR4;        /*!< TIM capture/compare register 4,      Address offset: 0x40 */
S  __IO uint16_t BDTR;        /*!< TIM break and dead-time register,    Address offset: 0x44 */
S  uint16_t      RESERVED11;  /*!< Reserved, 0x46                                            */
S  __IO uint16_t DCR;         /*!< TIM DMA control register,            Address offset: 0x48 */
S  uint16_t      RESERVED12;  /*!< Reserved, 0x4A                                            */
S  __IO uint16_t DMAR;        /*!< TIM DMA address for full transfer,   Address offset: 0x4C */
S  uint16_t      RESERVED13;  /*!< Reserved, 0x4E                                            */
S  __IO uint16_t OR;          /*!< TIM option register,                 Address offset: 0x50 */
S  uint16_t      RESERVED14;  /*!< Reserved, 0x52                                            */
S} TIM_TypeDef;
S
S/** 
S  * @brief Universal Synchronous Asynchronous Receiver Transmitter
S  */
S 
Stypedef struct
S{
S  __IO uint16_t SR;         /*!< USART Status register,                   Address offset: 0x00 */
S  uint16_t      RESERVED0;  /*!< Reserved, 0x02                                                */
S  __IO uint16_t DR;         /*!< USART Data register,                     Address offset: 0x04 */
S  uint16_t      RESERVED1;  /*!< Reserved, 0x06                                                */
S  __IO uint16_t BRR;        /*!< USART Baud rate register,                Address offset: 0x08 */
S  uint16_t      RESERVED2;  /*!< Reserved, 0x0A                                                */
S  __IO uint16_t CR1;        /*!< USART Control register 1,                Address offset: 0x0C */
S  uint16_t      RESERVED3;  /*!< Reserved, 0x0E                                                */
S  __IO uint16_t CR2;        /*!< USART Control register 2,                Address offset: 0x10 */
S  uint16_t      RESERVED4;  /*!< Reserved, 0x12                                                */
S  __IO uint16_t CR3;        /*!< USART Control register 3,                Address offset: 0x14 */
S  uint16_t      RESERVED5;  /*!< Reserved, 0x16                                                */
S  __IO uint16_t GTPR;       /*!< USART Guard time and prescaler register, Address offset: 0x18 */
S  uint16_t      RESERVED6;  /*!< Reserved, 0x1A                                                */
S} USART_TypeDef;
S
S/** 
S  * @brief Window WATCHDOG
S  */
S
Stypedef struct
S{
S  __IO uint32_t CR;   /*!< WWDG Control register,       Address offset: 0x00 */
S  __IO uint32_t CFR;  /*!< WWDG Configuration register, Address offset: 0x04 */
S  __IO uint32_t SR;   /*!< WWDG Status register,        Address offset: 0x08 */
S} WWDG_TypeDef;
S
S/** 
S  * @brief Crypto Processor
S  */
S
Stypedef struct
S{
S  __IO uint32_t CR;         /*!< CRYP control register,                                    Address offset: 0x00 */
S  __IO uint32_t SR;         /*!< CRYP status register,                                     Address offset: 0x04 */
S  __IO uint32_t DR;         /*!< CRYP data input register,                                 Address offset: 0x08 */
S  __IO uint32_t DOUT;       /*!< CRYP data output register,                                Address offset: 0x0C */
S  __IO uint32_t DMACR;      /*!< CRYP DMA control register,                                Address offset: 0x10 */
S  __IO uint32_t IMSCR;      /*!< CRYP interrupt mask set/clear register,                   Address offset: 0x14 */
S  __IO uint32_t RISR;       /*!< CRYP raw interrupt status register,                       Address offset: 0x18 */
S  __IO uint32_t MISR;       /*!< CRYP masked interrupt status register,                    Address offset: 0x1C */
S  __IO uint32_t K0LR;       /*!< CRYP key left  register 0,                                Address offset: 0x20 */
S  __IO uint32_t K0RR;       /*!< CRYP key right register 0,                                Address offset: 0x24 */
S  __IO uint32_t K1LR;       /*!< CRYP key left  register 1,                                Address offset: 0x28 */
S  __IO uint32_t K1RR;       /*!< CRYP key right register 1,                                Address offset: 0x2C */
S  __IO uint32_t K2LR;       /*!< CRYP key left  register 2,                                Address offset: 0x30 */
S  __IO uint32_t K2RR;       /*!< CRYP key right register 2,                                Address offset: 0x34 */
S  __IO uint32_t K3LR;       /*!< CRYP key left  register 3,                                Address offset: 0x38 */
S  __IO uint32_t K3RR;       /*!< CRYP key right register 3,                                Address offset: 0x3C */
S  __IO uint32_t IV0LR;      /*!< CRYP initialization vector left-word  register 0,         Address offset: 0x40 */
S  __IO uint32_t IV0RR;      /*!< CRYP initialization vector right-word register 0,         Address offset: 0x44 */
S  __IO uint32_t IV1LR;      /*!< CRYP initialization vector left-word  register 1,         Address offset: 0x48 */
S  __IO uint32_t IV1RR;      /*!< CRYP initialization vector right-word register 1,         Address offset: 0x4C */
S  __IO uint32_t CSGCMCCM0R; /*!< CRYP GCM/GMAC or CCM/CMAC context swap register 0,        Address offset: 0x50 */
S  __IO uint32_t CSGCMCCM1R; /*!< CRYP GCM/GMAC or CCM/CMAC context swap register 1,        Address offset: 0x54 */
S  __IO uint32_t CSGCMCCM2R; /*!< CRYP GCM/GMAC or CCM/CMAC context swap register 2,        Address offset: 0x58 */
S  __IO uint32_t CSGCMCCM3R; /*!< CRYP GCM/GMAC or CCM/CMAC context swap register 3,        Address offset: 0x5C */
S  __IO uint32_t CSGCMCCM4R; /*!< CRYP GCM/GMAC or CCM/CMAC context swap register 4,        Address offset: 0x60 */
S  __IO uint32_t CSGCMCCM5R; /*!< CRYP GCM/GMAC or CCM/CMAC context swap register 5,        Address offset: 0x64 */
S  __IO uint32_t CSGCMCCM6R; /*!< CRYP GCM/GMAC or CCM/CMAC context swap register 6,        Address offset: 0x68 */
S  __IO uint32_t CSGCMCCM7R; /*!< CRYP GCM/GMAC or CCM/CMAC context swap register 7,        Address offset: 0x6C */
S  __IO uint32_t CSGCM0R;    /*!< CRYP GCM/GMAC context swap register 0,                    Address offset: 0x70 */
S  __IO uint32_t CSGCM1R;    /*!< CRYP GCM/GMAC context swap register 1,                    Address offset: 0x74 */
S  __IO uint32_t CSGCM2R;    /*!< CRYP GCM/GMAC context swap register 2,                    Address offset: 0x78 */
S  __IO uint32_t CSGCM3R;    /*!< CRYP GCM/GMAC context swap register 3,                    Address offset: 0x7C */
S  __IO uint32_t CSGCM4R;    /*!< CRYP GCM/GMAC context swap register 4,                    Address offset: 0x80 */
S  __IO uint32_t CSGCM5R;    /*!< CRYP GCM/GMAC context swap register 5,                    Address offset: 0x84 */
S  __IO uint32_t CSGCM6R;    /*!< CRYP GCM/GMAC context swap register 6,                    Address offset: 0x88 */
S  __IO uint32_t CSGCM7R;    /*!< CRYP GCM/GMAC context swap register 7,                    Address offset: 0x8C */
S} CRYP_TypeDef;
S
S/** 
S  * @brief HASH
S  */
S  
Stypedef struct 
S{
S  __IO uint32_t CR;               /*!< HASH control register,          Address offset: 0x00        */
S  __IO uint32_t DIN;              /*!< HASH data input register,       Address offset: 0x04        */
S  __IO uint32_t STR;              /*!< HASH start register,            Address offset: 0x08        */
S  __IO uint32_t HR[5];            /*!< HASH digest registers,          Address offset: 0x0C-0x1C   */
S  __IO uint32_t IMR;              /*!< HASH interrupt enable register, Address offset: 0x20        */
S  __IO uint32_t SR;               /*!< HASH status register,           Address offset: 0x24        */
S       uint32_t RESERVED[52];     /*!< Reserved, 0x28-0xF4                                         */
S  __IO uint32_t CSR[54];          /*!< HASH context swap registers,    Address offset: 0x0F8-0x1CC */
S} HASH_TypeDef;
S
S/** 
S  * @brief HASH_DIGEST
S  */
S  
Stypedef struct 
S{
S  __IO uint32_t HR[8];     /*!< HASH digest registers,          Address offset: 0x310-0x32C */ 
S} HASH_DIGEST_TypeDef;
S
S/** 
S  * @brief RNG
S  */
S  
Stypedef struct 
S{
S  __IO uint32_t CR;  /*!< RNG control register, Address offset: 0x00 */
S  __IO uint32_t SR;  /*!< RNG status register,  Address offset: 0x04 */
S  __IO uint32_t DR;  /*!< RNG data register,    Address offset: 0x08 */
S} RNG_TypeDef;
S
S#if defined(STM32F410xx) || defined(STM32F413_423xx)
S/**
S  * @brief LPTIMER
S  */
Stypedef struct
S{
S  __IO uint32_t ISR;         /*!< LPTIM Interrupt and Status register,                Address offset: 0x00 */
S  __IO uint32_t ICR;         /*!< LPTIM Interrupt Clear register,                     Address offset: 0x04 */
S  __IO uint32_t IER;         /*!< LPTIM Interrupt Enable register,                    Address offset: 0x08 */
S  __IO uint32_t CFGR;        /*!< LPTIM Configuration register,                       Address offset: 0x0C */
S  __IO uint32_t CR;          /*!< LPTIM Control register,                             Address offset: 0x10 */
S  __IO uint32_t CMP;         /*!< LPTIM Compare register,                             Address offset: 0x14 */
S  __IO uint32_t ARR;         /*!< LPTIM Autoreload register,                          Address offset: 0x18 */
S  __IO uint32_t CNT;         /*!< LPTIM Counter register,                             Address offset: 0x1C */
S  __IO uint32_t OR;          /*!< LPTIM Option register,                              Address offset: 0x20 */
S} LPTIM_TypeDef;
S#endif /* STM32F410xx || STM32F413_423xx */
S/**
S  * @}
S  */
S  
S/** @addtogroup Peripheral_memory_map
S  * @{
S  */
S
S#define FLASH_BASE            ((uint32_t)0x08000000) /*!< FLASH(up to 1 MB) base address in the alias region                         */
S#define CCMDATARAM_BASE       ((uint32_t)0x10000000) /*!< CCM(core coupled memory) data RAM(64 KB) base address in the alias region  */
S#define SRAM1_BASE            ((uint32_t)0x20000000) /*!< SRAM1(112 KB) base address in the alias region                             */
S#if defined(STM32F40_41xxx) || defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F446xx) 
S#define SRAM2_BASE            ((uint32_t)0x2001C000) /*!< SRAM2(16 KB) base address in the alias region                              */
S#define SRAM3_BASE            ((uint32_t)0x20020000) /*!< SRAM3(64 KB) base address in the alias region                              */
S#elif defined(STM32F469_479xx)
S#define SRAM2_BASE            ((uint32_t)0x20028000) /*!< SRAM2(16 KB) base address in the alias region                              */
S#define SRAM3_BASE            ((uint32_t)0x20030000) /*!< SRAM3(64 KB) base address in the alias region                              */
S#elif defined(STM32F413_423xx)
S#define SRAM2_BASE            ((uint32_t)0x20040000) /*!< SRAM2(16 KB) base address in the alias region                              */
S#else /* STM32F411xE || STM32F410xx || STM32F412xG */
S#endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx ||  STM32F446xx */
S#define PERIPH_BASE           ((uint32_t)0x40000000) /*!< Peripheral base address in the alias region                                */
S#define BKPSRAM_BASE          ((uint32_t)0x40024000) /*!< Backup SRAM(4 KB) base address in the alias region                         */
S      
S#if defined(STM32F40_41xxx) || defined(STM32F412xG) || defined(STM32F413_423xx)
S#define FSMC_R_BASE           ((uint32_t)0xA0000000) /*!< FSMC registers base address                                                */
S#endif /* STM32F40_41xxx || STM32F412xG || STM32F413_423xx */
S
S#if defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
S#define FMC_R_BASE            ((uint32_t)0xA0000000) /*!< FMC registers base address                                                 */
S#endif /* STM32F427_437xx ||  STM32F429_439xx || STM32F446xx || STM32F469_479xx */
S
S#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
S#define QSPI_R_BASE           ((uint32_t)0xA0001000) /*!< QuadSPI registers base address                                            */
S#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx || STM32F469_479xx */
S
S#define CCMDATARAM_BB_BASE    ((uint32_t)0x12000000) /*!< CCM(core coupled memory) data RAM(64 KB) base address in the bit-band region  */
S#define SRAM1_BB_BASE         ((uint32_t)0x22000000) /*!< SRAM1(112 KB) base address in the bit-band region                             */
S#if defined(STM32F40_41xxx) || defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F446xx)
S#define SRAM2_BB_BASE         ((uint32_t)0x22380000) /*!< SRAM2(16 KB) base address in the bit-band region                              */
S#define SRAM3_BB_BASE         ((uint32_t)0x22400000) /*!< SRAM3(64 KB) base address in the bit-band region                              */
S#elif defined(STM32F469_479xx)
S#define SRAM2_BB_BASE         ((uint32_t)0x22500000) /*!< SRAM2(16 KB) base address in the bit-band region                              */
S#define SRAM3_BB_BASE         ((uint32_t)0x22600000) /*!< SRAM3(64 KB) base address in the bit-band region                              */
S#elif defined(STM32F413_423xx)
S#define SRAM2_BB_BASE         ((uint32_t)0x22800000) /*!< SRAM2(64 KB) base address in the bit-band region                              */   
S#else /* STM32F411xE || STM32F410xx || STM32F412xG */
S#endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx ||  STM32F446xx */
S#define PERIPH_BB_BASE        ((uint32_t)0x42000000) /*!< Peripheral base address in the bit-band region                                */
S#define BKPSRAM_BB_BASE       ((uint32_t)0x42480000) /*!< Backup SRAM(4 KB) base address in the bit-band region                         */
S
S/* Legacy defines */
S#define SRAM_BASE             SRAM1_BASE
S#define SRAM_BB_BASE          SRAM1_BB_BASE
S
S
S/*!< Peripheral memory map */
S#define APB1PERIPH_BASE       PERIPH_BASE
S#define APB2PERIPH_BASE       (PERIPH_BASE + 0x00010000)
S#define AHB1PERIPH_BASE       (PERIPH_BASE + 0x00020000)
S#define AHB2PERIPH_BASE       (PERIPH_BASE + 0x10000000)
S
S/*!< APB1 peripherals */
S#define TIM2_BASE             (APB1PERIPH_BASE + 0x0000)
S#define TIM3_BASE             (APB1PERIPH_BASE + 0x0400)
S#define TIM4_BASE             (APB1PERIPH_BASE + 0x0800)
S#define TIM5_BASE             (APB1PERIPH_BASE + 0x0C00)
S#define TIM6_BASE             (APB1PERIPH_BASE + 0x1000)
S#define TIM7_BASE             (APB1PERIPH_BASE + 0x1400)
S#if defined(STM32F410xx) || defined(STM32F413_423xx)
S#define LPTIM1_BASE           (APB1PERIPH_BASE + 0x2400)
S#endif /* STM32F410xx || STM32F413_423xx */
S#define TIM12_BASE            (APB1PERIPH_BASE + 0x1800)
S#define TIM13_BASE            (APB1PERIPH_BASE + 0x1C00)
S#define TIM14_BASE            (APB1PERIPH_BASE + 0x2000)
S#define RTC_BASE              (APB1PERIPH_BASE + 0x2800)
S#define WWDG_BASE             (APB1PERIPH_BASE + 0x2C00)
S#define IWDG_BASE             (APB1PERIPH_BASE + 0x3000)
S#define I2S2ext_BASE          (APB1PERIPH_BASE + 0x3400)
S#define SPI2_BASE             (APB1PERIPH_BASE + 0x3800)
S#define SPI3_BASE             (APB1PERIPH_BASE + 0x3C00)
S#if defined(STM32F446xx)                              
S#define SPDIFRX_BASE          (APB1PERIPH_BASE + 0x4000)
S#endif /* STM32F446xx */
S#define I2S3ext_BASE          (APB1PERIPH_BASE + 0x4000)
S#define USART2_BASE           (APB1PERIPH_BASE + 0x4400)
S#define USART3_BASE           (APB1PERIPH_BASE + 0x4800)
S#define UART4_BASE            (APB1PERIPH_BASE + 0x4C00)
S#define UART5_BASE            (APB1PERIPH_BASE + 0x5000)
S#define I2C1_BASE             (APB1PERIPH_BASE + 0x5400)
S#define I2C2_BASE             (APB1PERIPH_BASE + 0x5800)
S#define I2C3_BASE             (APB1PERIPH_BASE + 0x5C00)
S#if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
S#define FMPI2C1_BASE          (APB1PERIPH_BASE + 0x6000)
S#endif /* STM32F410xx || STM32F412xG || STM32F413_423xx || STM32F446xx */
S#define CAN1_BASE             (APB1PERIPH_BASE + 0x6400)
S#define CAN2_BASE             (APB1PERIPH_BASE + 0x6800)
S#if defined(STM32F413_423xx)
S#define CAN3_BASE             (APB1PERIPH_BASE + 0x6C00)
S#endif /* STM32F413_423xx */
S#if defined(STM32F446xx)
S#define CEC_BASE              (APB1PERIPH_BASE + 0x6C00)
S#endif /* STM32F446xx */
S#define PWR_BASE              (APB1PERIPH_BASE + 0x7000)
S#define DAC_BASE              (APB1PERIPH_BASE + 0x7400)
S#define UART7_BASE            (APB1PERIPH_BASE + 0x7800)
S#define UART8_BASE            (APB1PERIPH_BASE + 0x7C00)
S
S/*!< APB2 peripherals */
S#define TIM1_BASE             (APB2PERIPH_BASE + 0x0000)
S#define TIM8_BASE             (APB2PERIPH_BASE + 0x0400)
S#define USART1_BASE           (APB2PERIPH_BASE + 0x1000)
S#define USART6_BASE           (APB2PERIPH_BASE + 0x1400)
S#define UART9_BASE            (APB2PERIPH_BASE + 0x1800U)
S#define UART10_BASE           (APB2PERIPH_BASE + 0x1C00U)
S#define ADC1_BASE             (APB2PERIPH_BASE + 0x2000)
S#define ADC2_BASE             (APB2PERIPH_BASE + 0x2100)
S#define ADC3_BASE             (APB2PERIPH_BASE + 0x2200)
S#define ADC_BASE              (APB2PERIPH_BASE + 0x2300)
S#define SDIO_BASE             (APB2PERIPH_BASE + 0x2C00)
S#define SPI1_BASE             (APB2PERIPH_BASE + 0x3000)
S#define SPI4_BASE             (APB2PERIPH_BASE + 0x3400)
S#define SYSCFG_BASE           (APB2PERIPH_BASE + 0x3800)
S#define EXTI_BASE             (APB2PERIPH_BASE + 0x3C00)
S#define TIM9_BASE             (APB2PERIPH_BASE + 0x4000)
S#define TIM10_BASE            (APB2PERIPH_BASE + 0x4400)
S#define TIM11_BASE            (APB2PERIPH_BASE + 0x4800)
S#define SPI5_BASE             (APB2PERIPH_BASE + 0x5000)
S#define SPI6_BASE             (APB2PERIPH_BASE + 0x5400)
S#define SAI1_BASE             (APB2PERIPH_BASE + 0x5800)
S#define SAI1_Block_A_BASE     (SAI1_BASE + 0x004)
S#define SAI1_Block_B_BASE     (SAI1_BASE + 0x024)
S#if defined(STM32F446xx)
S#define SAI2_BASE             (APB2PERIPH_BASE + 0x5C00)
S#define SAI2_Block_A_BASE     (SAI2_BASE + 0x004)
S#define SAI2_Block_B_BASE     (SAI2_BASE + 0x024)
S#endif /* STM32F446xx */
S#define LTDC_BASE             (APB2PERIPH_BASE + 0x6800)
S#define LTDC_Layer1_BASE      (LTDC_BASE + 0x84)
S#define LTDC_Layer2_BASE      (LTDC_BASE + 0x104)
S#if defined(STM32F469_479xx)
S#define DSI_BASE              (APB2PERIPH_BASE + 0x6C00)
S#endif /* STM32F469_479xx */
S#if defined(STM32F412xG) || defined(STM32F413_423xx)
S#define DFSDM1_BASE           (APB2PERIPH_BASE + 0x6000)
S#define DFSDM1_Channel0_BASE  (DFSDM1_BASE + 0x00)
S#define DFSDM1_Channel1_BASE  (DFSDM1_BASE + 0x20)
S#define DFSDM1_Channel2_BASE  (DFSDM1_BASE + 0x40)
S#define DFSDM1_Channel3_BASE  (DFSDM1_BASE + 0x60)
S#define DFSDM1_Filter0_BASE   (DFSDM1_BASE + 0x100)
S#define DFSDM1_Filter1_BASE   (DFSDM1_BASE + 0x180)
S#define DFSDM1_0              ((DFSDM_TypeDef *) DFSDM1_Filter0_BASE)
S#define DFSDM1_1              ((DFSDM_TypeDef *) DFSDM1_Filter1_BASE)
S/* Legacy Defines */
S#define DFSDM0                DFSDM1_0              
S#define DFSDM1                DFSDM1_1              
S#if defined(STM32F413_423xx)
S#define DFSDM2_BASE           (APB2PERIPH_BASE + 0x6400U)
S#define DFSDM2_Channel0_BASE  (DFSDM2_BASE + 0x00U)
S#define DFSDM2_Channel1_BASE  (DFSDM2_BASE + 0x20U)
S#define DFSDM2_Channel2_BASE  (DFSDM2_BASE + 0x40U)
S#define DFSDM2_Channel3_BASE  (DFSDM2_BASE + 0x60U)
S#define DFSDM2_Channel4_BASE  (DFSDM2_BASE + 0x80U)
S#define DFSDM2_Channel5_BASE  (DFSDM2_BASE + 0xA0U)
S#define DFSDM2_Channel6_BASE  (DFSDM2_BASE + 0xC0U)
S#define DFSDM2_Channel7_BASE  (DFSDM2_BASE + 0xE0U)
S#define DFSDM2_Filter0_BASE   (DFSDM2_BASE + 0x100U)
S#define DFSDM2_Filter1_BASE   (DFSDM2_BASE + 0x180U)
S#define DFSDM2_Filter2_BASE   (DFSDM2_BASE + 0x200U)
S#define DFSDM2_Filter3_BASE   (DFSDM2_BASE + 0x280U)
S#define DFSDM2_0              ((DFSDM_TypeDef *) DFSDM2_Filter0_BASE)
S#define DFSDM2_1              ((DFSDM_TypeDef *) DFSDM2_Filter1_BASE)
S#define DFSDM2_2              ((DFSDM_TypeDef *) DFSDM2_Filter2_BASE)
S#define DFSDM2_3              ((DFSDM_TypeDef *) DFSDM2_Filter3_BASE)
S#endif /* STM32F413_423xx */
S#endif /* STM32F412xG ||  STM32F413_423xx */
S
S/*!< AHB1 peripherals */
S#define GPIOA_BASE            (AHB1PERIPH_BASE + 0x0000)
S#define GPIOB_BASE            (AHB1PERIPH_BASE + 0x0400)
S#define GPIOC_BASE            (AHB1PERIPH_BASE + 0x0800)
S#define GPIOD_BASE            (AHB1PERIPH_BASE + 0x0C00)
S#define GPIOE_BASE            (AHB1PERIPH_BASE + 0x1000)
S#define GPIOF_BASE            (AHB1PERIPH_BASE + 0x1400)
S#define GPIOG_BASE            (AHB1PERIPH_BASE + 0x1800)
S#define GPIOH_BASE            (AHB1PERIPH_BASE + 0x1C00)
S#define GPIOI_BASE            (AHB1PERIPH_BASE + 0x2000)
S#define GPIOJ_BASE            (AHB1PERIPH_BASE + 0x2400)
S#define GPIOK_BASE            (AHB1PERIPH_BASE + 0x2800)
S#define CRC_BASE              (AHB1PERIPH_BASE + 0x3000)
S#define RCC_BASE              (AHB1PERIPH_BASE + 0x3800)
S#define FLASH_R_BASE          (AHB1PERIPH_BASE + 0x3C00)
S#define DMA1_BASE             (AHB1PERIPH_BASE + 0x6000)
S#define DMA1_Stream0_BASE     (DMA1_BASE + 0x010)
S#define DMA1_Stream1_BASE     (DMA1_BASE + 0x028)
S#define DMA1_Stream2_BASE     (DMA1_BASE + 0x040)
S#define DMA1_Stream3_BASE     (DMA1_BASE + 0x058)
S#define DMA1_Stream4_BASE     (DMA1_BASE + 0x070)
S#define DMA1_Stream5_BASE     (DMA1_BASE + 0x088)
S#define DMA1_Stream6_BASE     (DMA1_BASE + 0x0A0)
S#define DMA1_Stream7_BASE     (DMA1_BASE + 0x0B8)
S#define DMA2_BASE             (AHB1PERIPH_BASE + 0x6400)
S#define DMA2_Stream0_BASE     (DMA2_BASE + 0x010)
S#define DMA2_Stream1_BASE     (DMA2_BASE + 0x028)
S#define DMA2_Stream2_BASE     (DMA2_BASE + 0x040)
S#define DMA2_Stream3_BASE     (DMA2_BASE + 0x058)
S#define DMA2_Stream4_BASE     (DMA2_BASE + 0x070)
S#define DMA2_Stream5_BASE     (DMA2_BASE + 0x088)
S#define DMA2_Stream6_BASE     (DMA2_BASE + 0x0A0)
S#define DMA2_Stream7_BASE     (DMA2_BASE + 0x0B8)
S#define ETH_BASE              (AHB1PERIPH_BASE + 0x8000)
S#define ETH_MAC_BASE          (ETH_BASE)
S#define ETH_MMC_BASE          (ETH_BASE + 0x0100)
S#define ETH_PTP_BASE          (ETH_BASE + 0x0700)
S#define ETH_DMA_BASE          (ETH_BASE + 0x1000)
S#define DMA2D_BASE            (AHB1PERIPH_BASE + 0xB000)
S
S/*!< AHB2 peripherals */
S#define DCMI_BASE             (AHB2PERIPH_BASE + 0x50000)
S#define CRYP_BASE             (AHB2PERIPH_BASE + 0x60000)
S#define HASH_BASE             (AHB2PERIPH_BASE + 0x60400)
S#define HASH_DIGEST_BASE      (AHB2PERIPH_BASE + 0x60710)
S#define RNG_BASE              (AHB2PERIPH_BASE + 0x60800)
S
S#if defined(STM32F40_41xxx) || defined(STM32F412xG) || defined(STM32F413_423xx)
S/*!< FSMC Bankx registers base address */
S#define FSMC_Bank1_R_BASE     (FSMC_R_BASE + 0x0000)
S#define FSMC_Bank1E_R_BASE    (FSMC_R_BASE + 0x0104)
S#define FSMC_Bank2_R_BASE     (FSMC_R_BASE + 0x0060)
S#define FSMC_Bank3_R_BASE     (FSMC_R_BASE + 0x0080)
S#define FSMC_Bank4_R_BASE     (FSMC_R_BASE + 0x00A0)
S#endif /* STM32F40_41xxx || STM32F412xG || STM32F413_423xx */
S
S#if defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
S/*!< FMC Bankx registers base address */
S#define FMC_Bank1_R_BASE      (FMC_R_BASE + 0x0000)
S#define FMC_Bank1E_R_BASE     (FMC_R_BASE + 0x0104)
S#define FMC_Bank2_R_BASE      (FMC_R_BASE + 0x0060)
S#define FMC_Bank3_R_BASE      (FMC_R_BASE + 0x0080)
S#define FMC_Bank4_R_BASE      (FMC_R_BASE + 0x00A0)
S#define FMC_Bank5_6_R_BASE    (FMC_R_BASE + 0x0140)
S#endif /* STM32F427_437xx ||  STM32F429_439xx || STM32F446xx || STM32F469_479xx */
S
S/* Debug MCU registers base address */
S#define DBGMCU_BASE           ((uint32_t )0xE0042000)
S
S/**
S  * @}
S  */
S  
S/** @addtogroup Peripheral_declaration
S  * @{
S  */
S#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
S#define QUADSPI             ((QUADSPI_TypeDef *) QSPI_R_BASE)
S#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx || STM32F469_479xx */
S#define TIM2                ((TIM_TypeDef *) TIM2_BASE)
S#define TIM3                ((TIM_TypeDef *) TIM3_BASE)
S#define TIM4                ((TIM_TypeDef *) TIM4_BASE)
S#define TIM5                ((TIM_TypeDef *) TIM5_BASE)
S#define TIM6                ((TIM_TypeDef *) TIM6_BASE)
S#define TIM7                ((TIM_TypeDef *) TIM7_BASE)
S#define TIM12               ((TIM_TypeDef *) TIM12_BASE)
S#define TIM13               ((TIM_TypeDef *) TIM13_BASE)
S#define TIM14               ((TIM_TypeDef *) TIM14_BASE)
S#define RTC                 ((RTC_TypeDef *) RTC_BASE)
S#define WWDG                ((WWDG_TypeDef *) WWDG_BASE)
S#define IWDG                ((IWDG_TypeDef *) IWDG_BASE)
S#define I2S2ext             ((SPI_TypeDef *) I2S2ext_BASE)
S#define SPI2                ((SPI_TypeDef *) SPI2_BASE)
S#define SPI3                ((SPI_TypeDef *) SPI3_BASE)
S#if defined(STM32F446xx)
S#define SPDIFRX             ((SPDIFRX_TypeDef *) SPDIFRX_BASE)
S#endif /* STM32F446xx */
S#define I2S3ext             ((SPI_TypeDef *) I2S3ext_BASE)
S#define USART2              ((USART_TypeDef *) USART2_BASE)
S#define USART3              ((USART_TypeDef *) USART3_BASE)
S#define UART4               ((USART_TypeDef *) UART4_BASE)
S#define UART5               ((USART_TypeDef *) UART5_BASE)
S#define I2C1                ((I2C_TypeDef *) I2C1_BASE)
S#define I2C2                ((I2C_TypeDef *) I2C2_BASE)
S#define I2C3                ((I2C_TypeDef *) I2C3_BASE)
S#if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
S#define FMPI2C1             ((FMPI2C_TypeDef *) FMPI2C1_BASE)
S#endif /* STM32F410xx || STM32F412xG || STM32F413_423xx || STM32F446xx */
S#if defined(STM32F410xx) || defined(STM32F413_423xx)
S#define LPTIM1              ((LPTIM_TypeDef *) LPTIM1_BASE)
S#endif /* STM32F410xx || STM32F413_423xx */
S#define CAN1                ((CAN_TypeDef *) CAN1_BASE)
S#define CAN2                ((CAN_TypeDef *) CAN2_BASE)
S#if defined(STM32F413_423xx)
S#define CAN3                ((CAN_TypeDef *) CAN3_BASE)
S#endif /* STM32F413_423xx */
S#if defined(STM32F446xx)
S#define CEC                 ((CEC_TypeDef *) CEC_BASE)
S#endif /* STM32F446xx */
S#define PWR                 ((PWR_TypeDef *) PWR_BASE)
S#define DAC                 ((DAC_TypeDef *) DAC_BASE)
S#define UART7               ((USART_TypeDef *) UART7_BASE)
S#define UART8               ((USART_TypeDef *) UART8_BASE)
S#define UART9               ((USART_TypeDef *) UART9_BASE)
S#define UART10              ((USART_TypeDef *) UART10_BASE)
S#define TIM1                ((TIM_TypeDef *) TIM1_BASE)
S#define TIM8                ((TIM_TypeDef *) TIM8_BASE)
S#define USART1              ((USART_TypeDef *) USART1_BASE)
S#define USART6              ((USART_TypeDef *) USART6_BASE)
S#define ADC                 ((ADC_Common_TypeDef *) ADC_BASE)
S#define ADC1                ((ADC_TypeDef *) ADC1_BASE)
S#define ADC2                ((ADC_TypeDef *) ADC2_BASE)
S#define ADC3                ((ADC_TypeDef *) ADC3_BASE)
S#define SDIO                ((SDIO_TypeDef *) SDIO_BASE)
S#define SPI1                ((SPI_TypeDef *) SPI1_BASE) 
S#define SPI4                ((SPI_TypeDef *) SPI4_BASE)
S#define SYSCFG              ((SYSCFG_TypeDef *) SYSCFG_BASE)
S#define EXTI                ((EXTI_TypeDef *) EXTI_BASE)
S#define TIM9                ((TIM_TypeDef *) TIM9_BASE)
S#define TIM10               ((TIM_TypeDef *) TIM10_BASE)
S#define TIM11               ((TIM_TypeDef *) TIM11_BASE)
S#define SPI5                ((SPI_TypeDef *) SPI5_BASE)
S#define SPI6                ((SPI_TypeDef *) SPI6_BASE)
S#define SAI1                ((SAI_TypeDef *) SAI1_BASE)
S#define SAI1_Block_A        ((SAI_Block_TypeDef *)SAI1_Block_A_BASE)
S#define SAI1_Block_B        ((SAI_Block_TypeDef *)SAI1_Block_B_BASE)
S#if defined(STM32F446xx)
S#define SAI2                ((SAI_TypeDef *) SAI2_BASE)
S#define SAI2_Block_A        ((SAI_Block_TypeDef *)SAI2_Block_A_BASE)
S#define SAI2_Block_B        ((SAI_Block_TypeDef *)SAI2_Block_B_BASE)
S#endif /* STM32F446xx */
S#define LTDC                ((LTDC_TypeDef *)LTDC_BASE)
S#define LTDC_Layer1         ((LTDC_Layer_TypeDef *)LTDC_Layer1_BASE)
S#define LTDC_Layer2         ((LTDC_Layer_TypeDef *)LTDC_Layer2_BASE)
S#if defined(STM32F469_479xx)
S#define DSI                 ((DSI_TypeDef *)DSI_BASE)
S#endif /* STM32F469_479xx */
S#if defined(STM32F412xG) || defined(STM32F413_423xx)
S#define DFSDM1_Channel0     ((DFSDM_Channel_TypeDef *) DFSDM1_Channel0_BASE)
S#define DFSDM1_Channel1     ((DFSDM_Channel_TypeDef *) DFSDM1_Channel1_BASE)
S#define DFSDM1_Channel2     ((DFSDM_Channel_TypeDef *) DFSDM1_Channel2_BASE)
S#define DFSDM1_Channel3     ((DFSDM_Channel_TypeDef *) DFSDM1_Channel3_BASE)
S#define DFSDM1_Filter0      ((DFSDM_TypeDef *) DFSDM_Filter0_BASE)
S#define DFSDM1_Filter1      ((DFSDM_TypeDef *) DFSDM_Filter1_BASE)
S#if defined(STM32F413_423xx)
S#define DFSDM2_Channel0     ((DFSDM_Channel_TypeDef *) DFSDM2_Channel0_BASE)
S#define DFSDM2_Channel1     ((DFSDM_Channel_TypeDef *) DFSDM2_Channel1_BASE)
S#define DFSDM2_Channel2     ((DFSDM_Channel_TypeDef *) DFSDM2_Channel2_BASE)
S#define DFSDM2_Channel3     ((DFSDM_Channel_TypeDef *) DFSDM2_Channel3_BASE)
S#define DFSDM2_Channel4     ((DFSDM_Channel_TypeDef *) DFSDM2_Channel4_BASE)
S#define DFSDM2_Channel5     ((DFSDM_Channel_TypeDef *) DFSDM2_Channel5_BASE)
S#define DFSDM2_Channel6     ((DFSDM_Channel_TypeDef *) DFSDM2_Channel6_BASE)
S#define DFSDM2_Channel7     ((DFSDM_Channel_TypeDef *) DFSDM2_Channel7_BASE)
S#define DFSDM2_Filter0      ((DFSDM_Filter_TypeDef *) DFSDM2_Filter0_BASE)
S#define DFSDM2_Filter1      ((DFSDM_Filter_TypeDef *) DFSDM2_Filter1_BASE)
S#define DFSDM2_Filter2      ((DFSDM_Filter_TypeDef *) DFSDM2_Filter2_BASE)
S#define DFSDM2_Filter3      ((DFSDM_Filter_TypeDef *) DFSDM2_Filter3_BASE)
S#endif /* STM32F413_423xx */
S#endif /* STM32F412xG || STM32F413_423xx */
S#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
S#define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
S#define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
S#define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)
S#define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)
S#define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)
S#define GPIOG               ((GPIO_TypeDef *) GPIOG_BASE)
S#define GPIOH               ((GPIO_TypeDef *) GPIOH_BASE)
S#define GPIOI               ((GPIO_TypeDef *) GPIOI_BASE)
S#define GPIOJ               ((GPIO_TypeDef *) GPIOJ_BASE)
S#define GPIOK               ((GPIO_TypeDef *) GPIOK_BASE)
S#define CRC                 ((CRC_TypeDef *) CRC_BASE)
S#define RCC                 ((RCC_TypeDef *) RCC_BASE)
S#define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)
S#define DMA1                ((DMA_TypeDef *) DMA1_BASE)
S#define DMA1_Stream0        ((DMA_Stream_TypeDef *) DMA1_Stream0_BASE)
S#define DMA1_Stream1        ((DMA_Stream_TypeDef *) DMA1_Stream1_BASE)
S#define DMA1_Stream2        ((DMA_Stream_TypeDef *) DMA1_Stream2_BASE)
S#define DMA1_Stream3        ((DMA_Stream_TypeDef *) DMA1_Stream3_BASE)
S#define DMA1_Stream4        ((DMA_Stream_TypeDef *) DMA1_Stream4_BASE)
S#define DMA1_Stream5        ((DMA_Stream_TypeDef *) DMA1_Stream5_BASE)
S#define DMA1_Stream6        ((DMA_Stream_TypeDef *) DMA1_Stream6_BASE)
S#define DMA1_Stream7        ((DMA_Stream_TypeDef *) DMA1_Stream7_BASE)
S#define DMA2                ((DMA_TypeDef *) DMA2_BASE)
S#define DMA2_Stream0        ((DMA_Stream_TypeDef *) DMA2_Stream0_BASE)
S#define DMA2_Stream1        ((DMA_Stream_TypeDef *) DMA2_Stream1_BASE)
S#define DMA2_Stream2        ((DMA_Stream_TypeDef *) DMA2_Stream2_BASE)
S#define DMA2_Stream3        ((DMA_Stream_TypeDef *) DMA2_Stream3_BASE)
S#define DMA2_Stream4        ((DMA_Stream_TypeDef *) DMA2_Stream4_BASE)
S#define DMA2_Stream5        ((DMA_Stream_TypeDef *) DMA2_Stream5_BASE)
S#define DMA2_Stream6        ((DMA_Stream_TypeDef *) DMA2_Stream6_BASE)
S#define DMA2_Stream7        ((DMA_Stream_TypeDef *) DMA2_Stream7_BASE)
S#define ETH                 ((ETH_TypeDef *) ETH_BASE)  
S#define DMA2D               ((DMA2D_TypeDef *)DMA2D_BASE)
S#define DCMI                ((DCMI_TypeDef *) DCMI_BASE)
S#define CRYP                ((CRYP_TypeDef *) CRYP_BASE)
S#define HASH                ((HASH_TypeDef *) HASH_BASE)
S#define HASH_DIGEST         ((HASH_DIGEST_TypeDef *) HASH_DIGEST_BASE)
S#define RNG                 ((RNG_TypeDef *) RNG_BASE)
S
S#if defined(STM32F40_41xxx) || defined(STM32F412xG) || defined(STM32F413_423xx)
S#define FSMC_Bank1          ((FSMC_Bank1_TypeDef *) FSMC_Bank1_R_BASE)
S#define FSMC_Bank1E         ((FSMC_Bank1E_TypeDef *) FSMC_Bank1E_R_BASE)
S#define FSMC_Bank2          ((FSMC_Bank2_TypeDef *) FSMC_Bank2_R_BASE)
S#define FSMC_Bank3          ((FSMC_Bank3_TypeDef *) FSMC_Bank3_R_BASE)
S#define FSMC_Bank4          ((FSMC_Bank4_TypeDef *) FSMC_Bank4_R_BASE)
S#endif /* STM32F40_41xxx || STM32F412xG || STM32F413_423xx */
S
S#if defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
S#define FMC_Bank1           ((FMC_Bank1_TypeDef *) FMC_Bank1_R_BASE)
S#define FMC_Bank1E          ((FMC_Bank1E_TypeDef *) FMC_Bank1E_R_BASE)
S#define FMC_Bank2           ((FMC_Bank2_TypeDef *) FMC_Bank2_R_BASE)
S#define FMC_Bank3           ((FMC_Bank3_TypeDef *) FMC_Bank3_R_BASE)
S#define FMC_Bank4           ((FMC_Bank4_TypeDef *) FMC_Bank4_R_BASE)
S#define FMC_Bank5_6         ((FMC_Bank5_6_TypeDef *) FMC_Bank5_6_R_BASE)
S#endif /* STM32F427_437xx ||  STM32F429_439xx || STM32F446xx || STM32F469_479xx */
S
S#define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)
S
S/**
S  * @}
S  */
S
S/** @addtogroup Exported_constants
S  * @{
S  */
S  
S  /** @addtogroup Peripheral_Registers_Bits_Definition
S  * @{
S  */
S    
S/******************************************************************************/
S/*                         Peripheral Registers_Bits_Definition               */
S/******************************************************************************/
S
S/******************************************************************************/
S/*                                                                            */
S/*                        Analog to Digital Converter                         */
S/*                                                                            */
S/******************************************************************************/
S/********************  Bit definition for ADC_SR register  ********************/
S#define  ADC_SR_AWD                          ((uint8_t)0x01)               /*!<Analog watchdog flag               */
S#define  ADC_SR_EOC                          ((uint8_t)0x02)               /*!<End of conversion                  */
S#define  ADC_SR_JEOC                         ((uint8_t)0x04)               /*!<Injected channel end of conversion */
S#define  ADC_SR_JSTRT                        ((uint8_t)0x08)               /*!<Injected channel Start flag        */
S#define  ADC_SR_STRT                         ((uint8_t)0x10)               /*!<Regular channel Start flag         */
S#define  ADC_SR_OVR                          ((uint8_t)0x20)               /*!<Overrun flag                       */
S
S/*******************  Bit definition for ADC_CR1 register  ********************/
S#define  ADC_CR1_AWDCH                       ((uint32_t)0x0000001F)        /*!<AWDCH[4:0] bits (Analog watchdog channel select bits) */
S#define  ADC_CR1_AWDCH_0                     ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  ADC_CR1_AWDCH_1                     ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  ADC_CR1_AWDCH_2                     ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  ADC_CR1_AWDCH_3                     ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  ADC_CR1_AWDCH_4                     ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  ADC_CR1_EOCIE                       ((uint32_t)0x00000020)        /*!<Interrupt enable for EOC                              */
S#define  ADC_CR1_AWDIE                       ((uint32_t)0x00000040)        /*!<AAnalog Watchdog interrupt enable                     */
S#define  ADC_CR1_JEOCIE                      ((uint32_t)0x00000080)        /*!<Interrupt enable for injected channels                */
S#define  ADC_CR1_SCAN                        ((uint32_t)0x00000100)        /*!<Scan mode                                             */
S#define  ADC_CR1_AWDSGL                      ((uint32_t)0x00000200)        /*!<Enable the watchdog on a single channel in scan mode  */
S#define  ADC_CR1_JAUTO                       ((uint32_t)0x00000400)        /*!<Automatic injected group conversion                   */
S#define  ADC_CR1_DISCEN                      ((uint32_t)0x00000800)        /*!<Discontinuous mode on regular channels                */
S#define  ADC_CR1_JDISCEN                     ((uint32_t)0x00001000)        /*!<Discontinuous mode on injected channels               */
S#define  ADC_CR1_DISCNUM                     ((uint32_t)0x0000E000)        /*!<DISCNUM[2:0] bits (Discontinuous mode channel count)  */
S#define  ADC_CR1_DISCNUM_0                   ((uint32_t)0x00002000)        /*!<Bit 0 */
S#define  ADC_CR1_DISCNUM_1                   ((uint32_t)0x00004000)        /*!<Bit 1 */
S#define  ADC_CR1_DISCNUM_2                   ((uint32_t)0x00008000)        /*!<Bit 2 */
S#define  ADC_CR1_JAWDEN                      ((uint32_t)0x00400000)        /*!<Analog watchdog enable on injected channels           */
S#define  ADC_CR1_AWDEN                       ((uint32_t)0x00800000)        /*!<Analog watchdog enable on regular channels            */
S#define  ADC_CR1_RES                         ((uint32_t)0x03000000)        /*!<RES[2:0] bits (Resolution)                            */
S#define  ADC_CR1_RES_0                       ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  ADC_CR1_RES_1                       ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  ADC_CR1_OVRIE                       ((uint32_t)0x04000000)         /*!<overrun interrupt enable                              */
S  
S/*******************  Bit definition for ADC_CR2 register  ********************/
S#define  ADC_CR2_ADON                        ((uint32_t)0x00000001)        /*!<A/D Converter ON / OFF             */
S#define  ADC_CR2_CONT                        ((uint32_t)0x00000002)        /*!<Continuous Conversion              */
S#define  ADC_CR2_DMA                         ((uint32_t)0x00000100)        /*!<Direct Memory access mode          */
S#define  ADC_CR2_DDS                         ((uint32_t)0x00000200)        /*!<DMA disable selection (Single ADC) */
S#define  ADC_CR2_EOCS                        ((uint32_t)0x00000400)        /*!<End of conversion selection        */
S#define  ADC_CR2_ALIGN                       ((uint32_t)0x00000800)        /*!<Data Alignment                     */
S#define  ADC_CR2_JEXTSEL                     ((uint32_t)0x000F0000)        /*!<JEXTSEL[3:0] bits (External event select for injected group) */
S#define  ADC_CR2_JEXTSEL_0                   ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  ADC_CR2_JEXTSEL_1                   ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  ADC_CR2_JEXTSEL_2                   ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  ADC_CR2_JEXTSEL_3                   ((uint32_t)0x00080000)        /*!<Bit 3 */
S#define  ADC_CR2_JEXTEN                      ((uint32_t)0x00300000)        /*!<JEXTEN[1:0] bits (External Trigger Conversion mode for injected channelsp) */
S#define  ADC_CR2_JEXTEN_0                    ((uint32_t)0x00100000)        /*!<Bit 0 */
S#define  ADC_CR2_JEXTEN_1                    ((uint32_t)0x00200000)        /*!<Bit 1 */
S#define  ADC_CR2_JSWSTART                    ((uint32_t)0x00400000)        /*!<Start Conversion of injected channels */
S#define  ADC_CR2_EXTSEL                      ((uint32_t)0x0F000000)        /*!<EXTSEL[3:0] bits (External Event Select for regular group) */
S#define  ADC_CR2_EXTSEL_0                    ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  ADC_CR2_EXTSEL_1                    ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  ADC_CR2_EXTSEL_2                    ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  ADC_CR2_EXTSEL_3                    ((uint32_t)0x08000000)        /*!<Bit 3 */
S#define  ADC_CR2_EXTEN                       ((uint32_t)0x30000000)        /*!<EXTEN[1:0] bits (External Trigger Conversion mode for regular channelsp) */
S#define  ADC_CR2_EXTEN_0                     ((uint32_t)0x10000000)        /*!<Bit 0 */
S#define  ADC_CR2_EXTEN_1                     ((uint32_t)0x20000000)        /*!<Bit 1 */
S#define  ADC_CR2_SWSTART                     ((uint32_t)0x40000000)        /*!<Start Conversion of regular channels */
S
S/******************  Bit definition for ADC_SMPR1 register  *******************/
S#define  ADC_SMPR1_SMP10                     ((uint32_t)0x00000007)        /*!<SMP10[2:0] bits (Channel 10 Sample time selection) */
S#define  ADC_SMPR1_SMP10_0                   ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  ADC_SMPR1_SMP10_1                   ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  ADC_SMPR1_SMP10_2                   ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  ADC_SMPR1_SMP11                     ((uint32_t)0x00000038)        /*!<SMP11[2:0] bits (Channel 11 Sample time selection) */
S#define  ADC_SMPR1_SMP11_0                   ((uint32_t)0x00000008)        /*!<Bit 0 */
S#define  ADC_SMPR1_SMP11_1                   ((uint32_t)0x00000010)        /*!<Bit 1 */
S#define  ADC_SMPR1_SMP11_2                   ((uint32_t)0x00000020)        /*!<Bit 2 */
S#define  ADC_SMPR1_SMP12                     ((uint32_t)0x000001C0)        /*!<SMP12[2:0] bits (Channel 12 Sample time selection) */
S#define  ADC_SMPR1_SMP12_0                   ((uint32_t)0x00000040)        /*!<Bit 0 */
S#define  ADC_SMPR1_SMP12_1                   ((uint32_t)0x00000080)        /*!<Bit 1 */
S#define  ADC_SMPR1_SMP12_2                   ((uint32_t)0x00000100)        /*!<Bit 2 */
S#define  ADC_SMPR1_SMP13                     ((uint32_t)0x00000E00)        /*!<SMP13[2:0] bits (Channel 13 Sample time selection) */
S#define  ADC_SMPR1_SMP13_0                   ((uint32_t)0x00000200)        /*!<Bit 0 */
S#define  ADC_SMPR1_SMP13_1                   ((uint32_t)0x00000400)        /*!<Bit 1 */
S#define  ADC_SMPR1_SMP13_2                   ((uint32_t)0x00000800)        /*!<Bit 2 */
S#define  ADC_SMPR1_SMP14                     ((uint32_t)0x00007000)        /*!<SMP14[2:0] bits (Channel 14 Sample time selection) */
S#define  ADC_SMPR1_SMP14_0                   ((uint32_t)0x00001000)        /*!<Bit 0 */
S#define  ADC_SMPR1_SMP14_1                   ((uint32_t)0x00002000)        /*!<Bit 1 */
S#define  ADC_SMPR1_SMP14_2                   ((uint32_t)0x00004000)        /*!<Bit 2 */
S#define  ADC_SMPR1_SMP15                     ((uint32_t)0x00038000)        /*!<SMP15[2:0] bits (Channel 15 Sample time selection) */
S#define  ADC_SMPR1_SMP15_0                   ((uint32_t)0x00008000)        /*!<Bit 0 */
S#define  ADC_SMPR1_SMP15_1                   ((uint32_t)0x00010000)        /*!<Bit 1 */
S#define  ADC_SMPR1_SMP15_2                   ((uint32_t)0x00020000)        /*!<Bit 2 */
S#define  ADC_SMPR1_SMP16                     ((uint32_t)0x001C0000)        /*!<SMP16[2:0] bits (Channel 16 Sample time selection) */
S#define  ADC_SMPR1_SMP16_0                   ((uint32_t)0x00040000)        /*!<Bit 0 */
S#define  ADC_SMPR1_SMP16_1                   ((uint32_t)0x00080000)        /*!<Bit 1 */
S#define  ADC_SMPR1_SMP16_2                   ((uint32_t)0x00100000)        /*!<Bit 2 */
S#define  ADC_SMPR1_SMP17                     ((uint32_t)0x00E00000)        /*!<SMP17[2:0] bits (Channel 17 Sample time selection) */
S#define  ADC_SMPR1_SMP17_0                   ((uint32_t)0x00200000)        /*!<Bit 0 */
S#define  ADC_SMPR1_SMP17_1                   ((uint32_t)0x00400000)        /*!<Bit 1 */
S#define  ADC_SMPR1_SMP17_2                   ((uint32_t)0x00800000)        /*!<Bit 2 */
S#define  ADC_SMPR1_SMP18                     ((uint32_t)0x07000000)        /*!<SMP18[2:0] bits (Channel 18 Sample time selection) */
S#define  ADC_SMPR1_SMP18_0                   ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  ADC_SMPR1_SMP18_1                   ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  ADC_SMPR1_SMP18_2                   ((uint32_t)0x04000000)        /*!<Bit 2 */
S
S/******************  Bit definition for ADC_SMPR2 register  *******************/
S#define  ADC_SMPR2_SMP0                      ((uint32_t)0x00000007)        /*!<SMP0[2:0] bits (Channel 0 Sample time selection) */
S#define  ADC_SMPR2_SMP0_0                    ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  ADC_SMPR2_SMP0_1                    ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  ADC_SMPR2_SMP0_2                    ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  ADC_SMPR2_SMP1                      ((uint32_t)0x00000038)        /*!<SMP1[2:0] bits (Channel 1 Sample time selection) */
S#define  ADC_SMPR2_SMP1_0                    ((uint32_t)0x00000008)        /*!<Bit 0 */
S#define  ADC_SMPR2_SMP1_1                    ((uint32_t)0x00000010)        /*!<Bit 1 */
S#define  ADC_SMPR2_SMP1_2                    ((uint32_t)0x00000020)        /*!<Bit 2 */
S#define  ADC_SMPR2_SMP2                      ((uint32_t)0x000001C0)        /*!<SMP2[2:0] bits (Channel 2 Sample time selection) */
S#define  ADC_SMPR2_SMP2_0                    ((uint32_t)0x00000040)        /*!<Bit 0 */
S#define  ADC_SMPR2_SMP2_1                    ((uint32_t)0x00000080)        /*!<Bit 1 */
S#define  ADC_SMPR2_SMP2_2                    ((uint32_t)0x00000100)        /*!<Bit 2 */
S#define  ADC_SMPR2_SMP3                      ((uint32_t)0x00000E00)        /*!<SMP3[2:0] bits (Channel 3 Sample time selection) */
S#define  ADC_SMPR2_SMP3_0                    ((uint32_t)0x00000200)        /*!<Bit 0 */
S#define  ADC_SMPR2_SMP3_1                    ((uint32_t)0x00000400)        /*!<Bit 1 */
S#define  ADC_SMPR2_SMP3_2                    ((uint32_t)0x00000800)        /*!<Bit 2 */
S#define  ADC_SMPR2_SMP4                      ((uint32_t)0x00007000)        /*!<SMP4[2:0] bits (Channel 4 Sample time selection) */
S#define  ADC_SMPR2_SMP4_0                    ((uint32_t)0x00001000)        /*!<Bit 0 */
S#define  ADC_SMPR2_SMP4_1                    ((uint32_t)0x00002000)        /*!<Bit 1 */
S#define  ADC_SMPR2_SMP4_2                    ((uint32_t)0x00004000)        /*!<Bit 2 */
S#define  ADC_SMPR2_SMP5                      ((uint32_t)0x00038000)        /*!<SMP5[2:0] bits (Channel 5 Sample time selection) */
S#define  ADC_SMPR2_SMP5_0                    ((uint32_t)0x00008000)        /*!<Bit 0 */
S#define  ADC_SMPR2_SMP5_1                    ((uint32_t)0x00010000)        /*!<Bit 1 */
S#define  ADC_SMPR2_SMP5_2                    ((uint32_t)0x00020000)        /*!<Bit 2 */
S#define  ADC_SMPR2_SMP6                      ((uint32_t)0x001C0000)        /*!<SMP6[2:0] bits (Channel 6 Sample time selection) */
S#define  ADC_SMPR2_SMP6_0                    ((uint32_t)0x00040000)        /*!<Bit 0 */
S#define  ADC_SMPR2_SMP6_1                    ((uint32_t)0x00080000)        /*!<Bit 1 */
S#define  ADC_SMPR2_SMP6_2                    ((uint32_t)0x00100000)        /*!<Bit 2 */
S#define  ADC_SMPR2_SMP7                      ((uint32_t)0x00E00000)        /*!<SMP7[2:0] bits (Channel 7 Sample time selection) */
S#define  ADC_SMPR2_SMP7_0                    ((uint32_t)0x00200000)        /*!<Bit 0 */
S#define  ADC_SMPR2_SMP7_1                    ((uint32_t)0x00400000)        /*!<Bit 1 */
S#define  ADC_SMPR2_SMP7_2                    ((uint32_t)0x00800000)        /*!<Bit 2 */
S#define  ADC_SMPR2_SMP8                      ((uint32_t)0x07000000)        /*!<SMP8[2:0] bits (Channel 8 Sample time selection) */
S#define  ADC_SMPR2_SMP8_0                    ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  ADC_SMPR2_SMP8_1                    ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  ADC_SMPR2_SMP8_2                    ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  ADC_SMPR2_SMP9                      ((uint32_t)0x38000000)        /*!<SMP9[2:0] bits (Channel 9 Sample time selection) */
S#define  ADC_SMPR2_SMP9_0                    ((uint32_t)0x08000000)        /*!<Bit 0 */
S#define  ADC_SMPR2_SMP9_1                    ((uint32_t)0x10000000)        /*!<Bit 1 */
S#define  ADC_SMPR2_SMP9_2                    ((uint32_t)0x20000000)        /*!<Bit 2 */
S
S/******************  Bit definition for ADC_JOFR1 register  *******************/
S#define  ADC_JOFR1_JOFFSET1                  ((uint16_t)0x0FFF)            /*!<Data offset for injected channel 1 */
S
S/******************  Bit definition for ADC_JOFR2 register  *******************/
S#define  ADC_JOFR2_JOFFSET2                  ((uint16_t)0x0FFF)            /*!<Data offset for injected channel 2 */
S
S/******************  Bit definition for ADC_JOFR3 register  *******************/
S#define  ADC_JOFR3_JOFFSET3                  ((uint16_t)0x0FFF)            /*!<Data offset for injected channel 3 */
S
S/******************  Bit definition for ADC_JOFR4 register  *******************/
S#define  ADC_JOFR4_JOFFSET4                  ((uint16_t)0x0FFF)            /*!<Data offset for injected channel 4 */
S
S/*******************  Bit definition for ADC_HTR register  ********************/
S#define  ADC_HTR_HT                          ((uint16_t)0x0FFF)            /*!<Analog watchdog high threshold */
S
S/*******************  Bit definition for ADC_LTR register  ********************/
S#define  ADC_LTR_LT                          ((uint16_t)0x0FFF)            /*!<Analog watchdog low threshold */
S
S/*******************  Bit definition for ADC_SQR1 register  *******************/
S#define  ADC_SQR1_SQ13                       ((uint32_t)0x0000001F)        /*!<SQ13[4:0] bits (13th conversion in regular sequence) */
S#define  ADC_SQR1_SQ13_0                     ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  ADC_SQR1_SQ13_1                     ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  ADC_SQR1_SQ13_2                     ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  ADC_SQR1_SQ13_3                     ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  ADC_SQR1_SQ13_4                     ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  ADC_SQR1_SQ14                       ((uint32_t)0x000003E0)        /*!<SQ14[4:0] bits (14th conversion in regular sequence) */
S#define  ADC_SQR1_SQ14_0                     ((uint32_t)0x00000020)        /*!<Bit 0 */
S#define  ADC_SQR1_SQ14_1                     ((uint32_t)0x00000040)        /*!<Bit 1 */
S#define  ADC_SQR1_SQ14_2                     ((uint32_t)0x00000080)        /*!<Bit 2 */
S#define  ADC_SQR1_SQ14_3                     ((uint32_t)0x00000100)        /*!<Bit 3 */
S#define  ADC_SQR1_SQ14_4                     ((uint32_t)0x00000200)        /*!<Bit 4 */
S#define  ADC_SQR1_SQ15                       ((uint32_t)0x00007C00)        /*!<SQ15[4:0] bits (15th conversion in regular sequence) */
S#define  ADC_SQR1_SQ15_0                     ((uint32_t)0x00000400)        /*!<Bit 0 */
S#define  ADC_SQR1_SQ15_1                     ((uint32_t)0x00000800)        /*!<Bit 1 */
S#define  ADC_SQR1_SQ15_2                     ((uint32_t)0x00001000)        /*!<Bit 2 */
S#define  ADC_SQR1_SQ15_3                     ((uint32_t)0x00002000)        /*!<Bit 3 */
S#define  ADC_SQR1_SQ15_4                     ((uint32_t)0x00004000)        /*!<Bit 4 */
S#define  ADC_SQR1_SQ16                       ((uint32_t)0x000F8000)        /*!<SQ16[4:0] bits (16th conversion in regular sequence) */
S#define  ADC_SQR1_SQ16_0                     ((uint32_t)0x00008000)        /*!<Bit 0 */
S#define  ADC_SQR1_SQ16_1                     ((uint32_t)0x00010000)        /*!<Bit 1 */
S#define  ADC_SQR1_SQ16_2                     ((uint32_t)0x00020000)        /*!<Bit 2 */
S#define  ADC_SQR1_SQ16_3                     ((uint32_t)0x00040000)        /*!<Bit 3 */
S#define  ADC_SQR1_SQ16_4                     ((uint32_t)0x00080000)        /*!<Bit 4 */
S#define  ADC_SQR1_L                          ((uint32_t)0x00F00000)        /*!<L[3:0] bits (Regular channel sequence length) */
S#define  ADC_SQR1_L_0                        ((uint32_t)0x00100000)        /*!<Bit 0 */
S#define  ADC_SQR1_L_1                        ((uint32_t)0x00200000)        /*!<Bit 1 */
S#define  ADC_SQR1_L_2                        ((uint32_t)0x00400000)        /*!<Bit 2 */
S#define  ADC_SQR1_L_3                        ((uint32_t)0x00800000)        /*!<Bit 3 */
S
S/*******************  Bit definition for ADC_SQR2 register  *******************/
S#define  ADC_SQR2_SQ7                        ((uint32_t)0x0000001F)        /*!<SQ7[4:0] bits (7th conversion in regular sequence) */
S#define  ADC_SQR2_SQ7_0                      ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  ADC_SQR2_SQ7_1                      ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  ADC_SQR2_SQ7_2                      ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  ADC_SQR2_SQ7_3                      ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  ADC_SQR2_SQ7_4                      ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  ADC_SQR2_SQ8                        ((uint32_t)0x000003E0)        /*!<SQ8[4:0] bits (8th conversion in regular sequence) */
S#define  ADC_SQR2_SQ8_0                      ((uint32_t)0x00000020)        /*!<Bit 0 */
S#define  ADC_SQR2_SQ8_1                      ((uint32_t)0x00000040)        /*!<Bit 1 */
S#define  ADC_SQR2_SQ8_2                      ((uint32_t)0x00000080)        /*!<Bit 2 */
S#define  ADC_SQR2_SQ8_3                      ((uint32_t)0x00000100)        /*!<Bit 3 */
S#define  ADC_SQR2_SQ8_4                      ((uint32_t)0x00000200)        /*!<Bit 4 */
S#define  ADC_SQR2_SQ9                        ((uint32_t)0x00007C00)        /*!<SQ9[4:0] bits (9th conversion in regular sequence) */
S#define  ADC_SQR2_SQ9_0                      ((uint32_t)0x00000400)        /*!<Bit 0 */
S#define  ADC_SQR2_SQ9_1                      ((uint32_t)0x00000800)        /*!<Bit 1 */
S#define  ADC_SQR2_SQ9_2                      ((uint32_t)0x00001000)        /*!<Bit 2 */
S#define  ADC_SQR2_SQ9_3                      ((uint32_t)0x00002000)        /*!<Bit 3 */
S#define  ADC_SQR2_SQ9_4                      ((uint32_t)0x00004000)        /*!<Bit 4 */
S#define  ADC_SQR2_SQ10                       ((uint32_t)0x000F8000)        /*!<SQ10[4:0] bits (10th conversion in regular sequence) */
S#define  ADC_SQR2_SQ10_0                     ((uint32_t)0x00008000)        /*!<Bit 0 */
S#define  ADC_SQR2_SQ10_1                     ((uint32_t)0x00010000)        /*!<Bit 1 */
S#define  ADC_SQR2_SQ10_2                     ((uint32_t)0x00020000)        /*!<Bit 2 */
S#define  ADC_SQR2_SQ10_3                     ((uint32_t)0x00040000)        /*!<Bit 3 */
S#define  ADC_SQR2_SQ10_4                     ((uint32_t)0x00080000)        /*!<Bit 4 */
S#define  ADC_SQR2_SQ11                       ((uint32_t)0x01F00000)        /*!<SQ11[4:0] bits (11th conversion in regular sequence) */
S#define  ADC_SQR2_SQ11_0                     ((uint32_t)0x00100000)        /*!<Bit 0 */
S#define  ADC_SQR2_SQ11_1                     ((uint32_t)0x00200000)        /*!<Bit 1 */
S#define  ADC_SQR2_SQ11_2                     ((uint32_t)0x00400000)        /*!<Bit 2 */
S#define  ADC_SQR2_SQ11_3                     ((uint32_t)0x00800000)        /*!<Bit 3 */
S#define  ADC_SQR2_SQ11_4                     ((uint32_t)0x01000000)        /*!<Bit 4 */
S#define  ADC_SQR2_SQ12                       ((uint32_t)0x3E000000)        /*!<SQ12[4:0] bits (12th conversion in regular sequence) */
S#define  ADC_SQR2_SQ12_0                     ((uint32_t)0x02000000)        /*!<Bit 0 */
S#define  ADC_SQR2_SQ12_1                     ((uint32_t)0x04000000)        /*!<Bit 1 */
S#define  ADC_SQR2_SQ12_2                     ((uint32_t)0x08000000)        /*!<Bit 2 */
S#define  ADC_SQR2_SQ12_3                     ((uint32_t)0x10000000)        /*!<Bit 3 */
S#define  ADC_SQR2_SQ12_4                     ((uint32_t)0x20000000)        /*!<Bit 4 */
S
S/*******************  Bit definition for ADC_SQR3 register  *******************/
S#define  ADC_SQR3_SQ1                        ((uint32_t)0x0000001F)        /*!<SQ1[4:0] bits (1st conversion in regular sequence) */
S#define  ADC_SQR3_SQ1_0                      ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  ADC_SQR3_SQ1_1                      ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  ADC_SQR3_SQ1_2                      ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  ADC_SQR3_SQ1_3                      ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  ADC_SQR3_SQ1_4                      ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  ADC_SQR3_SQ2                        ((uint32_t)0x000003E0)        /*!<SQ2[4:0] bits (2nd conversion in regular sequence) */
S#define  ADC_SQR3_SQ2_0                      ((uint32_t)0x00000020)        /*!<Bit 0 */
S#define  ADC_SQR3_SQ2_1                      ((uint32_t)0x00000040)        /*!<Bit 1 */
S#define  ADC_SQR3_SQ2_2                      ((uint32_t)0x00000080)        /*!<Bit 2 */
S#define  ADC_SQR3_SQ2_3                      ((uint32_t)0x00000100)        /*!<Bit 3 */
S#define  ADC_SQR3_SQ2_4                      ((uint32_t)0x00000200)        /*!<Bit 4 */
S#define  ADC_SQR3_SQ3                        ((uint32_t)0x00007C00)        /*!<SQ3[4:0] bits (3rd conversion in regular sequence) */
S#define  ADC_SQR3_SQ3_0                      ((uint32_t)0x00000400)        /*!<Bit 0 */
S#define  ADC_SQR3_SQ3_1                      ((uint32_t)0x00000800)        /*!<Bit 1 */
S#define  ADC_SQR3_SQ3_2                      ((uint32_t)0x00001000)        /*!<Bit 2 */
S#define  ADC_SQR3_SQ3_3                      ((uint32_t)0x00002000)        /*!<Bit 3 */
S#define  ADC_SQR3_SQ3_4                      ((uint32_t)0x00004000)        /*!<Bit 4 */
S#define  ADC_SQR3_SQ4                        ((uint32_t)0x000F8000)        /*!<SQ4[4:0] bits (4th conversion in regular sequence) */
S#define  ADC_SQR3_SQ4_0                      ((uint32_t)0x00008000)        /*!<Bit 0 */
S#define  ADC_SQR3_SQ4_1                      ((uint32_t)0x00010000)        /*!<Bit 1 */
S#define  ADC_SQR3_SQ4_2                      ((uint32_t)0x00020000)        /*!<Bit 2 */
S#define  ADC_SQR3_SQ4_3                      ((uint32_t)0x00040000)        /*!<Bit 3 */
S#define  ADC_SQR3_SQ4_4                      ((uint32_t)0x00080000)        /*!<Bit 4 */
S#define  ADC_SQR3_SQ5                        ((uint32_t)0x01F00000)        /*!<SQ5[4:0] bits (5th conversion in regular sequence) */
S#define  ADC_SQR3_SQ5_0                      ((uint32_t)0x00100000)        /*!<Bit 0 */
S#define  ADC_SQR3_SQ5_1                      ((uint32_t)0x00200000)        /*!<Bit 1 */
S#define  ADC_SQR3_SQ5_2                      ((uint32_t)0x00400000)        /*!<Bit 2 */
S#define  ADC_SQR3_SQ5_3                      ((uint32_t)0x00800000)        /*!<Bit 3 */
S#define  ADC_SQR3_SQ5_4                      ((uint32_t)0x01000000)        /*!<Bit 4 */
S#define  ADC_SQR3_SQ6                        ((uint32_t)0x3E000000)        /*!<SQ6[4:0] bits (6th conversion in regular sequence) */
S#define  ADC_SQR3_SQ6_0                      ((uint32_t)0x02000000)        /*!<Bit 0 */
S#define  ADC_SQR3_SQ6_1                      ((uint32_t)0x04000000)        /*!<Bit 1 */
S#define  ADC_SQR3_SQ6_2                      ((uint32_t)0x08000000)        /*!<Bit 2 */
S#define  ADC_SQR3_SQ6_3                      ((uint32_t)0x10000000)        /*!<Bit 3 */
S#define  ADC_SQR3_SQ6_4                      ((uint32_t)0x20000000)        /*!<Bit 4 */
S
S/*******************  Bit definition for ADC_JSQR register  *******************/
S#define  ADC_JSQR_JSQ1                       ((uint32_t)0x0000001F)        /*!<JSQ1[4:0] bits (1st conversion in injected sequence) */  
S#define  ADC_JSQR_JSQ1_0                     ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  ADC_JSQR_JSQ1_1                     ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  ADC_JSQR_JSQ1_2                     ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  ADC_JSQR_JSQ1_3                     ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  ADC_JSQR_JSQ1_4                     ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  ADC_JSQR_JSQ2                       ((uint32_t)0x000003E0)        /*!<JSQ2[4:0] bits (2nd conversion in injected sequence) */
S#define  ADC_JSQR_JSQ2_0                     ((uint32_t)0x00000020)        /*!<Bit 0 */
S#define  ADC_JSQR_JSQ2_1                     ((uint32_t)0x00000040)        /*!<Bit 1 */
S#define  ADC_JSQR_JSQ2_2                     ((uint32_t)0x00000080)        /*!<Bit 2 */
S#define  ADC_JSQR_JSQ2_3                     ((uint32_t)0x00000100)        /*!<Bit 3 */
S#define  ADC_JSQR_JSQ2_4                     ((uint32_t)0x00000200)        /*!<Bit 4 */
S#define  ADC_JSQR_JSQ3                       ((uint32_t)0x00007C00)        /*!<JSQ3[4:0] bits (3rd conversion in injected sequence) */
S#define  ADC_JSQR_JSQ3_0                     ((uint32_t)0x00000400)        /*!<Bit 0 */
S#define  ADC_JSQR_JSQ3_1                     ((uint32_t)0x00000800)        /*!<Bit 1 */
S#define  ADC_JSQR_JSQ3_2                     ((uint32_t)0x00001000)        /*!<Bit 2 */
S#define  ADC_JSQR_JSQ3_3                     ((uint32_t)0x00002000)        /*!<Bit 3 */
S#define  ADC_JSQR_JSQ3_4                     ((uint32_t)0x00004000)        /*!<Bit 4 */
S#define  ADC_JSQR_JSQ4                       ((uint32_t)0x000F8000)        /*!<JSQ4[4:0] bits (4th conversion in injected sequence) */
S#define  ADC_JSQR_JSQ4_0                     ((uint32_t)0x00008000)        /*!<Bit 0 */
S#define  ADC_JSQR_JSQ4_1                     ((uint32_t)0x00010000)        /*!<Bit 1 */
S#define  ADC_JSQR_JSQ4_2                     ((uint32_t)0x00020000)        /*!<Bit 2 */
S#define  ADC_JSQR_JSQ4_3                     ((uint32_t)0x00040000)        /*!<Bit 3 */
S#define  ADC_JSQR_JSQ4_4                     ((uint32_t)0x00080000)        /*!<Bit 4 */
S#define  ADC_JSQR_JL                         ((uint32_t)0x00300000)        /*!<JL[1:0] bits (Injected Sequence length) */
S#define  ADC_JSQR_JL_0                       ((uint32_t)0x00100000)        /*!<Bit 0 */
S#define  ADC_JSQR_JL_1                       ((uint32_t)0x00200000)        /*!<Bit 1 */
S
S/*******************  Bit definition for ADC_JDR1 register  *******************/
S#define  ADC_JDR1_JDATA                      ((uint16_t)0xFFFF)            /*!<Injected data */
S
S/*******************  Bit definition for ADC_JDR2 register  *******************/
S#define  ADC_JDR2_JDATA                      ((uint16_t)0xFFFF)            /*!<Injected data */
S
S/*******************  Bit definition for ADC_JDR3 register  *******************/
S#define  ADC_JDR3_JDATA                      ((uint16_t)0xFFFF)            /*!<Injected data */
S
S/*******************  Bit definition for ADC_JDR4 register  *******************/
S#define  ADC_JDR4_JDATA                      ((uint16_t)0xFFFF)            /*!<Injected data */
S
S/********************  Bit definition for ADC_DR register  ********************/
S#define  ADC_DR_DATA                         ((uint32_t)0x0000FFFF)        /*!<Regular data */
S#define  ADC_DR_ADC2DATA                     ((uint32_t)0xFFFF0000)        /*!<ADC2 data */
S
S/*******************  Bit definition for ADC_CSR register  ********************/
S#define  ADC_CSR_AWD1                        ((uint32_t)0x00000001)        /*!<ADC1 Analog watchdog flag */
S#define  ADC_CSR_EOC1                        ((uint32_t)0x00000002)        /*!<ADC1 End of conversion */
S#define  ADC_CSR_JEOC1                       ((uint32_t)0x00000004)        /*!<ADC1 Injected channel end of conversion */
S#define  ADC_CSR_JSTRT1                      ((uint32_t)0x00000008)        /*!<ADC1 Injected channel Start flag */
S#define  ADC_CSR_STRT1                       ((uint32_t)0x00000010)        /*!<ADC1 Regular channel Start flag */
S#define  ADC_CSR_OVR1                        ((uint32_t)0x00000020)        /*!<ADC1 DMA overrun  flag */
S#define  ADC_CSR_AWD2                        ((uint32_t)0x00000100)        /*!<ADC2 Analog watchdog flag */
S#define  ADC_CSR_EOC2                        ((uint32_t)0x00000200)        /*!<ADC2 End of conversion */
S#define  ADC_CSR_JEOC2                       ((uint32_t)0x00000400)        /*!<ADC2 Injected channel end of conversion */
S#define  ADC_CSR_JSTRT2                      ((uint32_t)0x00000800)        /*!<ADC2 Injected channel Start flag */
S#define  ADC_CSR_STRT2                       ((uint32_t)0x00001000)        /*!<ADC2 Regular channel Start flag */
S#define  ADC_CSR_OVR2                        ((uint32_t)0x00002000)        /*!<ADC2 DMA overrun  flag */
S#define  ADC_CSR_AWD3                        ((uint32_t)0x00010000)        /*!<ADC3 Analog watchdog flag */
S#define  ADC_CSR_EOC3                        ((uint32_t)0x00020000)        /*!<ADC3 End of conversion */
S#define  ADC_CSR_JEOC3                       ((uint32_t)0x00040000)        /*!<ADC3 Injected channel end of conversion */
S#define  ADC_CSR_JSTRT3                      ((uint32_t)0x00080000)        /*!<ADC3 Injected channel Start flag */
S#define  ADC_CSR_STRT3                       ((uint32_t)0x00100000)        /*!<ADC3 Regular channel Start flag */
S#define  ADC_CSR_OVR3                        ((uint32_t)0x00200000)        /*!<ADC3 DMA overrun  flag */
S
S/* Legacy defines */
S#define  ADC_CSR_DOVR1                        ADC_CSR_OVR1
S#define  ADC_CSR_DOVR2                        ADC_CSR_OVR2
S#define  ADC_CSR_DOVR3                        ADC_CSR_OVR3
S
S/*******************  Bit definition for ADC_CCR register  ********************/
S#define  ADC_CCR_MULTI                       ((uint32_t)0x0000001F)        /*!<MULTI[4:0] bits (Multi-ADC mode selection) */  
S#define  ADC_CCR_MULTI_0                     ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  ADC_CCR_MULTI_1                     ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  ADC_CCR_MULTI_2                     ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  ADC_CCR_MULTI_3                     ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  ADC_CCR_MULTI_4                     ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  ADC_CCR_DELAY                       ((uint32_t)0x00000F00)        /*!<DELAY[3:0] bits (Delay between 2 sampling phases) */  
S#define  ADC_CCR_DELAY_0                     ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  ADC_CCR_DELAY_1                     ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  ADC_CCR_DELAY_2                     ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  ADC_CCR_DELAY_3                     ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  ADC_CCR_DDS                         ((uint32_t)0x00002000)        /*!<DMA disable selection (Multi-ADC mode) */
S#define  ADC_CCR_DMA                         ((uint32_t)0x0000C000)        /*!<DMA[1:0] bits (Direct Memory Access mode for multimode) */  
S#define  ADC_CCR_DMA_0                       ((uint32_t)0x00004000)        /*!<Bit 0 */
S#define  ADC_CCR_DMA_1                       ((uint32_t)0x00008000)        /*!<Bit 1 */
S#define  ADC_CCR_ADCPRE                      ((uint32_t)0x00030000)        /*!<ADCPRE[1:0] bits (ADC prescaler) */  
S#define  ADC_CCR_ADCPRE_0                    ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  ADC_CCR_ADCPRE_1                    ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  ADC_CCR_VBATE                       ((uint32_t)0x00400000)        /*!<VBAT Enable */
S#define  ADC_CCR_TSVREFE                     ((uint32_t)0x00800000)        /*!<Temperature Sensor and VREFINT Enable */
S
S/*******************  Bit definition for ADC_CDR register  ********************/
S#define  ADC_CDR_DATA1                      ((uint32_t)0x0000FFFF)         /*!<1st data of a pair of regular conversions */
S#define  ADC_CDR_DATA2                      ((uint32_t)0xFFFF0000)         /*!<2nd data of a pair of regular conversions */
S
S/******************************************************************************/
S/*                                                                            */
S/*                         Controller Area Network                            */
S/*                                                                            */
S/******************************************************************************/
S/*!<CAN control and status registers */
S/*******************  Bit definition for CAN_MCR register  ********************/
S#define  CAN_MCR_INRQ                        ((uint16_t)0x0001)            /*!<Initialization Request */
S#define  CAN_MCR_SLEEP                       ((uint16_t)0x0002)            /*!<Sleep Mode Request */
S#define  CAN_MCR_TXFP                        ((uint16_t)0x0004)            /*!<Transmit FIFO Priority */
S#define  CAN_MCR_RFLM                        ((uint16_t)0x0008)            /*!<Receive FIFO Locked Mode */
S#define  CAN_MCR_NART                        ((uint16_t)0x0010)            /*!<No Automatic Retransmission */
S#define  CAN_MCR_AWUM                        ((uint16_t)0x0020)            /*!<Automatic Wakeup Mode */
S#define  CAN_MCR_ABOM                        ((uint16_t)0x0040)            /*!<Automatic Bus-Off Management */
S#define  CAN_MCR_TTCM                        ((uint16_t)0x0080)            /*!<Time Triggered Communication Mode */
S#define  CAN_MCR_RESET                       ((uint16_t)0x8000)            /*!<bxCAN software master reset */
S
S/*******************  Bit definition for CAN_MSR register  ********************/
S#define  CAN_MSR_INAK                        ((uint16_t)0x0001)            /*!<Initialization Acknowledge */
S#define  CAN_MSR_SLAK                        ((uint16_t)0x0002)            /*!<Sleep Acknowledge */
S#define  CAN_MSR_ERRI                        ((uint16_t)0x0004)            /*!<Error Interrupt */
S#define  CAN_MSR_WKUI                        ((uint16_t)0x0008)            /*!<Wakeup Interrupt */
S#define  CAN_MSR_SLAKI                       ((uint16_t)0x0010)            /*!<Sleep Acknowledge Interrupt */
S#define  CAN_MSR_TXM                         ((uint16_t)0x0100)            /*!<Transmit Mode */
S#define  CAN_MSR_RXM                         ((uint16_t)0x0200)            /*!<Receive Mode */
S#define  CAN_MSR_SAMP                        ((uint16_t)0x0400)            /*!<Last Sample Point */
S#define  CAN_MSR_RX                          ((uint16_t)0x0800)            /*!<CAN Rx Signal */
S
S/*******************  Bit definition for CAN_TSR register  ********************/
S#define  CAN_TSR_RQCP0                       ((uint32_t)0x00000001)        /*!<Request Completed Mailbox0 */
S#define  CAN_TSR_TXOK0                       ((uint32_t)0x00000002)        /*!<Transmission OK of Mailbox0 */
S#define  CAN_TSR_ALST0                       ((uint32_t)0x00000004)        /*!<Arbitration Lost for Mailbox0 */
S#define  CAN_TSR_TERR0                       ((uint32_t)0x00000008)        /*!<Transmission Error of Mailbox0 */
S#define  CAN_TSR_ABRQ0                       ((uint32_t)0x00000080)        /*!<Abort Request for Mailbox0 */
S#define  CAN_TSR_RQCP1                       ((uint32_t)0x00000100)        /*!<Request Completed Mailbox1 */
S#define  CAN_TSR_TXOK1                       ((uint32_t)0x00000200)        /*!<Transmission OK of Mailbox1 */
S#define  CAN_TSR_ALST1                       ((uint32_t)0x00000400)        /*!<Arbitration Lost for Mailbox1 */
S#define  CAN_TSR_TERR1                       ((uint32_t)0x00000800)        /*!<Transmission Error of Mailbox1 */
S#define  CAN_TSR_ABRQ1                       ((uint32_t)0x00008000)        /*!<Abort Request for Mailbox 1 */
S#define  CAN_TSR_RQCP2                       ((uint32_t)0x00010000)        /*!<Request Completed Mailbox2 */
S#define  CAN_TSR_TXOK2                       ((uint32_t)0x00020000)        /*!<Transmission OK of Mailbox 2 */
S#define  CAN_TSR_ALST2                       ((uint32_t)0x00040000)        /*!<Arbitration Lost for mailbox 2 */
S#define  CAN_TSR_TERR2                       ((uint32_t)0x00080000)        /*!<Transmission Error of Mailbox 2 */
S#define  CAN_TSR_ABRQ2                       ((uint32_t)0x00800000)        /*!<Abort Request for Mailbox 2 */
S#define  CAN_TSR_CODE                        ((uint32_t)0x03000000)        /*!<Mailbox Code */
S
S#define  CAN_TSR_TME                         ((uint32_t)0x1C000000)        /*!<TME[2:0] bits */
S#define  CAN_TSR_TME0                        ((uint32_t)0x04000000)        /*!<Transmit Mailbox 0 Empty */
S#define  CAN_TSR_TME1                        ((uint32_t)0x08000000)        /*!<Transmit Mailbox 1 Empty */
S#define  CAN_TSR_TME2                        ((uint32_t)0x10000000)        /*!<Transmit Mailbox 2 Empty */
S
S#define  CAN_TSR_LOW                         ((uint32_t)0xE0000000)        /*!<LOW[2:0] bits */
S#define  CAN_TSR_LOW0                        ((uint32_t)0x20000000)        /*!<Lowest Priority Flag for Mailbox 0 */
S#define  CAN_TSR_LOW1                        ((uint32_t)0x40000000)        /*!<Lowest Priority Flag for Mailbox 1 */
S#define  CAN_TSR_LOW2                        ((uint32_t)0x80000000)        /*!<Lowest Priority Flag for Mailbox 2 */
S
S/*******************  Bit definition for CAN_RF0R register  *******************/
S#define  CAN_RF0R_FMP0                       ((uint8_t)0x03)               /*!<FIFO 0 Message Pending */
S#define  CAN_RF0R_FULL0                      ((uint8_t)0x08)               /*!<FIFO 0 Full */
S#define  CAN_RF0R_FOVR0                      ((uint8_t)0x10)               /*!<FIFO 0 Overrun */
S#define  CAN_RF0R_RFOM0                      ((uint8_t)0x20)               /*!<Release FIFO 0 Output Mailbox */
S
S/*******************  Bit definition for CAN_RF1R register  *******************/
S#define  CAN_RF1R_FMP1                       ((uint8_t)0x03)               /*!<FIFO 1 Message Pending */
S#define  CAN_RF1R_FULL1                      ((uint8_t)0x08)               /*!<FIFO 1 Full */
S#define  CAN_RF1R_FOVR1                      ((uint8_t)0x10)               /*!<FIFO 1 Overrun */
S#define  CAN_RF1R_RFOM1                      ((uint8_t)0x20)               /*!<Release FIFO 1 Output Mailbox */
S
S/********************  Bit definition for CAN_IER register  *******************/
S#define  CAN_IER_TMEIE                       ((uint32_t)0x00000001)        /*!<Transmit Mailbox Empty Interrupt Enable */
S#define  CAN_IER_FMPIE0                      ((uint32_t)0x00000002)        /*!<FIFO Message Pending Interrupt Enable */
S#define  CAN_IER_FFIE0                       ((uint32_t)0x00000004)        /*!<FIFO Full Interrupt Enable */
S#define  CAN_IER_FOVIE0                      ((uint32_t)0x00000008)        /*!<FIFO Overrun Interrupt Enable */
S#define  CAN_IER_FMPIE1                      ((uint32_t)0x00000010)        /*!<FIFO Message Pending Interrupt Enable */
S#define  CAN_IER_FFIE1                       ((uint32_t)0x00000020)        /*!<FIFO Full Interrupt Enable */
S#define  CAN_IER_FOVIE1                      ((uint32_t)0x00000040)        /*!<FIFO Overrun Interrupt Enable */
S#define  CAN_IER_EWGIE                       ((uint32_t)0x00000100)        /*!<Error Warning Interrupt Enable */
S#define  CAN_IER_EPVIE                       ((uint32_t)0x00000200)        /*!<Error Passive Interrupt Enable */
S#define  CAN_IER_BOFIE                       ((uint32_t)0x00000400)        /*!<Bus-Off Interrupt Enable */
S#define  CAN_IER_LECIE                       ((uint32_t)0x00000800)        /*!<Last Error Code Interrupt Enable */
S#define  CAN_IER_ERRIE                       ((uint32_t)0x00008000)        /*!<Error Interrupt Enable */
S#define  CAN_IER_WKUIE                       ((uint32_t)0x00010000)        /*!<Wakeup Interrupt Enable */
S#define  CAN_IER_SLKIE                       ((uint32_t)0x00020000)        /*!<Sleep Interrupt Enable */
S
S/********************  Bit definition for CAN_ESR register  *******************/
S#define  CAN_ESR_EWGF                        ((uint32_t)0x00000001)        /*!<Error Warning Flag */
S#define  CAN_ESR_EPVF                        ((uint32_t)0x00000002)        /*!<Error Passive Flag */
S#define  CAN_ESR_BOFF                        ((uint32_t)0x00000004)        /*!<Bus-Off Flag */
S
S#define  CAN_ESR_LEC                         ((uint32_t)0x00000070)        /*!<LEC[2:0] bits (Last Error Code) */
S#define  CAN_ESR_LEC_0                       ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  CAN_ESR_LEC_1                       ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  CAN_ESR_LEC_2                       ((uint32_t)0x00000040)        /*!<Bit 2 */
S
S#define  CAN_ESR_TEC                         ((uint32_t)0x00FF0000)        /*!<Least significant byte of the 9-bit Transmit Error Counter */
S#define  CAN_ESR_REC                         ((uint32_t)0xFF000000)        /*!<Receive Error Counter */
S
S/*******************  Bit definition for CAN_BTR register  ********************/
S#define  CAN_BTR_BRP                         ((uint32_t)0x000003FF)        /*!<Baud Rate Prescaler */
S#define  CAN_BTR_TS1                         ((uint32_t)0x000F0000)        /*!<Time Segment 1 */
S#define  CAN_BTR_TS2                         ((uint32_t)0x00700000)        /*!<Time Segment 2 */
S#define  CAN_BTR_SJW                         ((uint32_t)0x03000000)        /*!<Resynchronization Jump Width */
S#define  CAN_BTR_LBKM                        ((uint32_t)0x40000000)        /*!<Loop Back Mode (Debug) */
S#define  CAN_BTR_SILM                        ((uint32_t)0x80000000)        /*!<Silent Mode */
S
S/*!<Mailbox registers */
S/******************  Bit definition for CAN_TI0R register  ********************/
S#define  CAN_TI0R_TXRQ                       ((uint32_t)0x00000001)        /*!<Transmit Mailbox Request */
S#define  CAN_TI0R_RTR                        ((uint32_t)0x00000002)        /*!<Remote Transmission Request */
S#define  CAN_TI0R_IDE                        ((uint32_t)0x00000004)        /*!<Identifier Extension */
S#define  CAN_TI0R_EXID                       ((uint32_t)0x001FFFF8)        /*!<Extended Identifier */
S#define  CAN_TI0R_STID                       ((uint32_t)0xFFE00000)        /*!<Standard Identifier or Extended Identifier */
S
S/******************  Bit definition for CAN_TDT0R register  *******************/
S#define  CAN_TDT0R_DLC                       ((uint32_t)0x0000000F)        /*!<Data Length Code */
S#define  CAN_TDT0R_TGT                       ((uint32_t)0x00000100)        /*!<Transmit Global Time */
S#define  CAN_TDT0R_TIME                      ((uint32_t)0xFFFF0000)        /*!<Message Time Stamp */
S
S/******************  Bit definition for CAN_TDL0R register  *******************/
S#define  CAN_TDL0R_DATA0                     ((uint32_t)0x000000FF)        /*!<Data byte 0 */
S#define  CAN_TDL0R_DATA1                     ((uint32_t)0x0000FF00)        /*!<Data byte 1 */
S#define  CAN_TDL0R_DATA2                     ((uint32_t)0x00FF0000)        /*!<Data byte 2 */
S#define  CAN_TDL0R_DATA3                     ((uint32_t)0xFF000000)        /*!<Data byte 3 */
S
S/******************  Bit definition for CAN_TDH0R register  *******************/
S#define  CAN_TDH0R_DATA4                     ((uint32_t)0x000000FF)        /*!<Data byte 4 */
S#define  CAN_TDH0R_DATA5                     ((uint32_t)0x0000FF00)        /*!<Data byte 5 */
S#define  CAN_TDH0R_DATA6                     ((uint32_t)0x00FF0000)        /*!<Data byte 6 */
S#define  CAN_TDH0R_DATA7                     ((uint32_t)0xFF000000)        /*!<Data byte 7 */
S
S/*******************  Bit definition for CAN_TI1R register  *******************/
S#define  CAN_TI1R_TXRQ                       ((uint32_t)0x00000001)        /*!<Transmit Mailbox Request */
S#define  CAN_TI1R_RTR                        ((uint32_t)0x00000002)        /*!<Remote Transmission Request */
S#define  CAN_TI1R_IDE                        ((uint32_t)0x00000004)        /*!<Identifier Extension */
S#define  CAN_TI1R_EXID                       ((uint32_t)0x001FFFF8)        /*!<Extended Identifier */
S#define  CAN_TI1R_STID                       ((uint32_t)0xFFE00000)        /*!<Standard Identifier or Extended Identifier */
S
S/*******************  Bit definition for CAN_TDT1R register  ******************/
S#define  CAN_TDT1R_DLC                       ((uint32_t)0x0000000F)        /*!<Data Length Code */
S#define  CAN_TDT1R_TGT                       ((uint32_t)0x00000100)        /*!<Transmit Global Time */
S#define  CAN_TDT1R_TIME                      ((uint32_t)0xFFFF0000)        /*!<Message Time Stamp */
S
S/*******************  Bit definition for CAN_TDL1R register  ******************/
S#define  CAN_TDL1R_DATA0                     ((uint32_t)0x000000FF)        /*!<Data byte 0 */
S#define  CAN_TDL1R_DATA1                     ((uint32_t)0x0000FF00)        /*!<Data byte 1 */
S#define  CAN_TDL1R_DATA2                     ((uint32_t)0x00FF0000)        /*!<Data byte 2 */
S#define  CAN_TDL1R_DATA3                     ((uint32_t)0xFF000000)        /*!<Data byte 3 */
S
S/*******************  Bit definition for CAN_TDH1R register  ******************/
S#define  CAN_TDH1R_DATA4                     ((uint32_t)0x000000FF)        /*!<Data byte 4 */
S#define  CAN_TDH1R_DATA5                     ((uint32_t)0x0000FF00)        /*!<Data byte 5 */
S#define  CAN_TDH1R_DATA6                     ((uint32_t)0x00FF0000)        /*!<Data byte 6 */
S#define  CAN_TDH1R_DATA7                     ((uint32_t)0xFF000000)        /*!<Data byte 7 */
S
S/*******************  Bit definition for CAN_TI2R register  *******************/
S#define  CAN_TI2R_TXRQ                       ((uint32_t)0x00000001)        /*!<Transmit Mailbox Request */
S#define  CAN_TI2R_RTR                        ((uint32_t)0x00000002)        /*!<Remote Transmission Request */
S#define  CAN_TI2R_IDE                        ((uint32_t)0x00000004)        /*!<Identifier Extension */
S#define  CAN_TI2R_EXID                       ((uint32_t)0x001FFFF8)        /*!<Extended identifier */
S#define  CAN_TI2R_STID                       ((uint32_t)0xFFE00000)        /*!<Standard Identifier or Extended Identifier */
S
S/*******************  Bit definition for CAN_TDT2R register  ******************/  
S#define  CAN_TDT2R_DLC                       ((uint32_t)0x0000000F)        /*!<Data Length Code */
S#define  CAN_TDT2R_TGT                       ((uint32_t)0x00000100)        /*!<Transmit Global Time */
S#define  CAN_TDT2R_TIME                      ((uint32_t)0xFFFF0000)        /*!<Message Time Stamp */
S
S/*******************  Bit definition for CAN_TDL2R register  ******************/
S#define  CAN_TDL2R_DATA0                     ((uint32_t)0x000000FF)        /*!<Data byte 0 */
S#define  CAN_TDL2R_DATA1                     ((uint32_t)0x0000FF00)        /*!<Data byte 1 */
S#define  CAN_TDL2R_DATA2                     ((uint32_t)0x00FF0000)        /*!<Data byte 2 */
S#define  CAN_TDL2R_DATA3                     ((uint32_t)0xFF000000)        /*!<Data byte 3 */
S
S/*******************  Bit definition for CAN_TDH2R register  ******************/
S#define  CAN_TDH2R_DATA4                     ((uint32_t)0x000000FF)        /*!<Data byte 4 */
S#define  CAN_TDH2R_DATA5                     ((uint32_t)0x0000FF00)        /*!<Data byte 5 */
S#define  CAN_TDH2R_DATA6                     ((uint32_t)0x00FF0000)        /*!<Data byte 6 */
S#define  CAN_TDH2R_DATA7                     ((uint32_t)0xFF000000)        /*!<Data byte 7 */
S
S/*******************  Bit definition for CAN_RI0R register  *******************/
S#define  CAN_RI0R_RTR                        ((uint32_t)0x00000002)        /*!<Remote Transmission Request */
S#define  CAN_RI0R_IDE                        ((uint32_t)0x00000004)        /*!<Identifier Extension */
S#define  CAN_RI0R_EXID                       ((uint32_t)0x001FFFF8)        /*!<Extended Identifier */
S#define  CAN_RI0R_STID                       ((uint32_t)0xFFE00000)        /*!<Standard Identifier or Extended Identifier */
S
S/*******************  Bit definition for CAN_RDT0R register  ******************/
S#define  CAN_RDT0R_DLC                       ((uint32_t)0x0000000F)        /*!<Data Length Code */
S#define  CAN_RDT0R_FMI                       ((uint32_t)0x0000FF00)        /*!<Filter Match Index */
S#define  CAN_RDT0R_TIME                      ((uint32_t)0xFFFF0000)        /*!<Message Time Stamp */
S
S/*******************  Bit definition for CAN_RDL0R register  ******************/
S#define  CAN_RDL0R_DATA0                     ((uint32_t)0x000000FF)        /*!<Data byte 0 */
S#define  CAN_RDL0R_DATA1                     ((uint32_t)0x0000FF00)        /*!<Data byte 1 */
S#define  CAN_RDL0R_DATA2                     ((uint32_t)0x00FF0000)        /*!<Data byte 2 */
S#define  CAN_RDL0R_DATA3                     ((uint32_t)0xFF000000)        /*!<Data byte 3 */
S
S/*******************  Bit definition for CAN_RDH0R register  ******************/
S#define  CAN_RDH0R_DATA4                     ((uint32_t)0x000000FF)        /*!<Data byte 4 */
S#define  CAN_RDH0R_DATA5                     ((uint32_t)0x0000FF00)        /*!<Data byte 5 */
S#define  CAN_RDH0R_DATA6                     ((uint32_t)0x00FF0000)        /*!<Data byte 6 */
S#define  CAN_RDH0R_DATA7                     ((uint32_t)0xFF000000)        /*!<Data byte 7 */
S
S/*******************  Bit definition for CAN_RI1R register  *******************/
S#define  CAN_RI1R_RTR                        ((uint32_t)0x00000002)        /*!<Remote Transmission Request */
S#define  CAN_RI1R_IDE                        ((uint32_t)0x00000004)        /*!<Identifier Extension */
S#define  CAN_RI1R_EXID                       ((uint32_t)0x001FFFF8)        /*!<Extended identifier */
S#define  CAN_RI1R_STID                       ((uint32_t)0xFFE00000)        /*!<Standard Identifier or Extended Identifier */
S
S/*******************  Bit definition for CAN_RDT1R register  ******************/
S#define  CAN_RDT1R_DLC                       ((uint32_t)0x0000000F)        /*!<Data Length Code */
S#define  CAN_RDT1R_FMI                       ((uint32_t)0x0000FF00)        /*!<Filter Match Index */
S#define  CAN_RDT1R_TIME                      ((uint32_t)0xFFFF0000)        /*!<Message Time Stamp */
S
S/*******************  Bit definition for CAN_RDL1R register  ******************/
S#define  CAN_RDL1R_DATA0                     ((uint32_t)0x000000FF)        /*!<Data byte 0 */
S#define  CAN_RDL1R_DATA1                     ((uint32_t)0x0000FF00)        /*!<Data byte 1 */
S#define  CAN_RDL1R_DATA2                     ((uint32_t)0x00FF0000)        /*!<Data byte 2 */
S#define  CAN_RDL1R_DATA3                     ((uint32_t)0xFF000000)        /*!<Data byte 3 */
S
S/*******************  Bit definition for CAN_RDH1R register  ******************/
S#define  CAN_RDH1R_DATA4                     ((uint32_t)0x000000FF)        /*!<Data byte 4 */
S#define  CAN_RDH1R_DATA5                     ((uint32_t)0x0000FF00)        /*!<Data byte 5 */
S#define  CAN_RDH1R_DATA6                     ((uint32_t)0x00FF0000)        /*!<Data byte 6 */
S#define  CAN_RDH1R_DATA7                     ((uint32_t)0xFF000000)        /*!<Data byte 7 */
S
S/*!<CAN filter registers */
S/*******************  Bit definition for CAN_FMR register  ********************/
S#define  CAN_FMR_FINIT                       ((uint8_t)0x01)               /*!<Filter Init Mode */
S
S/*******************  Bit definition for CAN_FM1R register  *******************/
S#define  CAN_FM1R_FBM                        ((uint16_t)0x3FFF)            /*!<Filter Mode */
S#define  CAN_FM1R_FBM0                       ((uint16_t)0x0001)            /*!<Filter Init Mode bit 0 */
S#define  CAN_FM1R_FBM1                       ((uint16_t)0x0002)            /*!<Filter Init Mode bit 1 */
S#define  CAN_FM1R_FBM2                       ((uint16_t)0x0004)            /*!<Filter Init Mode bit 2 */
S#define  CAN_FM1R_FBM3                       ((uint16_t)0x0008)            /*!<Filter Init Mode bit 3 */
S#define  CAN_FM1R_FBM4                       ((uint16_t)0x0010)            /*!<Filter Init Mode bit 4 */
S#define  CAN_FM1R_FBM5                       ((uint16_t)0x0020)            /*!<Filter Init Mode bit 5 */
S#define  CAN_FM1R_FBM6                       ((uint16_t)0x0040)            /*!<Filter Init Mode bit 6 */
S#define  CAN_FM1R_FBM7                       ((uint16_t)0x0080)            /*!<Filter Init Mode bit 7 */
S#define  CAN_FM1R_FBM8                       ((uint16_t)0x0100)            /*!<Filter Init Mode bit 8 */
S#define  CAN_FM1R_FBM9                       ((uint16_t)0x0200)            /*!<Filter Init Mode bit 9 */
S#define  CAN_FM1R_FBM10                      ((uint16_t)0x0400)            /*!<Filter Init Mode bit 10 */
S#define  CAN_FM1R_FBM11                      ((uint16_t)0x0800)            /*!<Filter Init Mode bit 11 */
S#define  CAN_FM1R_FBM12                      ((uint16_t)0x1000)            /*!<Filter Init Mode bit 12 */
S#define  CAN_FM1R_FBM13                      ((uint16_t)0x2000)            /*!<Filter Init Mode bit 13 */
S
S/*******************  Bit definition for CAN_FS1R register  *******************/
S#define  CAN_FS1R_FSC                        ((uint16_t)0x3FFF)            /*!<Filter Scale Configuration */
S#define  CAN_FS1R_FSC0                       ((uint16_t)0x0001)            /*!<Filter Scale Configuration bit 0 */
S#define  CAN_FS1R_FSC1                       ((uint16_t)0x0002)            /*!<Filter Scale Configuration bit 1 */
S#define  CAN_FS1R_FSC2                       ((uint16_t)0x0004)            /*!<Filter Scale Configuration bit 2 */
S#define  CAN_FS1R_FSC3                       ((uint16_t)0x0008)            /*!<Filter Scale Configuration bit 3 */
S#define  CAN_FS1R_FSC4                       ((uint16_t)0x0010)            /*!<Filter Scale Configuration bit 4 */
S#define  CAN_FS1R_FSC5                       ((uint16_t)0x0020)            /*!<Filter Scale Configuration bit 5 */
S#define  CAN_FS1R_FSC6                       ((uint16_t)0x0040)            /*!<Filter Scale Configuration bit 6 */
S#define  CAN_FS1R_FSC7                       ((uint16_t)0x0080)            /*!<Filter Scale Configuration bit 7 */
S#define  CAN_FS1R_FSC8                       ((uint16_t)0x0100)            /*!<Filter Scale Configuration bit 8 */
S#define  CAN_FS1R_FSC9                       ((uint16_t)0x0200)            /*!<Filter Scale Configuration bit 9 */
S#define  CAN_FS1R_FSC10                      ((uint16_t)0x0400)            /*!<Filter Scale Configuration bit 10 */
S#define  CAN_FS1R_FSC11                      ((uint16_t)0x0800)            /*!<Filter Scale Configuration bit 11 */
S#define  CAN_FS1R_FSC12                      ((uint16_t)0x1000)            /*!<Filter Scale Configuration bit 12 */
S#define  CAN_FS1R_FSC13                      ((uint16_t)0x2000)            /*!<Filter Scale Configuration bit 13 */
S
S/******************  Bit definition for CAN_FFA1R register  *******************/
S#define  CAN_FFA1R_FFA                       ((uint16_t)0x3FFF)            /*!<Filter FIFO Assignment */
S#define  CAN_FFA1R_FFA0                      ((uint16_t)0x0001)            /*!<Filter FIFO Assignment for Filter 0 */
S#define  CAN_FFA1R_FFA1                      ((uint16_t)0x0002)            /*!<Filter FIFO Assignment for Filter 1 */
S#define  CAN_FFA1R_FFA2                      ((uint16_t)0x0004)            /*!<Filter FIFO Assignment for Filter 2 */
S#define  CAN_FFA1R_FFA3                      ((uint16_t)0x0008)            /*!<Filter FIFO Assignment for Filter 3 */
S#define  CAN_FFA1R_FFA4                      ((uint16_t)0x0010)            /*!<Filter FIFO Assignment for Filter 4 */
S#define  CAN_FFA1R_FFA5                      ((uint16_t)0x0020)            /*!<Filter FIFO Assignment for Filter 5 */
S#define  CAN_FFA1R_FFA6                      ((uint16_t)0x0040)            /*!<Filter FIFO Assignment for Filter 6 */
S#define  CAN_FFA1R_FFA7                      ((uint16_t)0x0080)            /*!<Filter FIFO Assignment for Filter 7 */
S#define  CAN_FFA1R_FFA8                      ((uint16_t)0x0100)            /*!<Filter FIFO Assignment for Filter 8 */
S#define  CAN_FFA1R_FFA9                      ((uint16_t)0x0200)            /*!<Filter FIFO Assignment for Filter 9 */
S#define  CAN_FFA1R_FFA10                     ((uint16_t)0x0400)            /*!<Filter FIFO Assignment for Filter 10 */
S#define  CAN_FFA1R_FFA11                     ((uint16_t)0x0800)            /*!<Filter FIFO Assignment for Filter 11 */
S#define  CAN_FFA1R_FFA12                     ((uint16_t)0x1000)            /*!<Filter FIFO Assignment for Filter 12 */
S#define  CAN_FFA1R_FFA13                     ((uint16_t)0x2000)            /*!<Filter FIFO Assignment for Filter 13 */
S
S/*******************  Bit definition for CAN_FA1R register  *******************/
S#define  CAN_FA1R_FACT                       ((uint16_t)0x3FFF)            /*!<Filter Active */
S#define  CAN_FA1R_FACT0                      ((uint16_t)0x0001)            /*!<Filter 0 Active */
S#define  CAN_FA1R_FACT1                      ((uint16_t)0x0002)            /*!<Filter 1 Active */
S#define  CAN_FA1R_FACT2                      ((uint16_t)0x0004)            /*!<Filter 2 Active */
S#define  CAN_FA1R_FACT3                      ((uint16_t)0x0008)            /*!<Filter 3 Active */
S#define  CAN_FA1R_FACT4                      ((uint16_t)0x0010)            /*!<Filter 4 Active */
S#define  CAN_FA1R_FACT5                      ((uint16_t)0x0020)            /*!<Filter 5 Active */
S#define  CAN_FA1R_FACT6                      ((uint16_t)0x0040)            /*!<Filter 6 Active */
S#define  CAN_FA1R_FACT7                      ((uint16_t)0x0080)            /*!<Filter 7 Active */
S#define  CAN_FA1R_FACT8                      ((uint16_t)0x0100)            /*!<Filter 8 Active */
S#define  CAN_FA1R_FACT9                      ((uint16_t)0x0200)            /*!<Filter 9 Active */
S#define  CAN_FA1R_FACT10                     ((uint16_t)0x0400)            /*!<Filter 10 Active */
S#define  CAN_FA1R_FACT11                     ((uint16_t)0x0800)            /*!<Filter 11 Active */
S#define  CAN_FA1R_FACT12                     ((uint16_t)0x1000)            /*!<Filter 12 Active */
S#define  CAN_FA1R_FACT13                     ((uint16_t)0x2000)            /*!<Filter 13 Active */
S
S/*******************  Bit definition for CAN_F0R1 register  *******************/
S#define  CAN_F0R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F0R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F0R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F0R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F0R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F0R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F0R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F0R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F0R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F0R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F0R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F0R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F0R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F0R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F0R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F0R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F0R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F0R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F0R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F0R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F0R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F0R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F0R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F0R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F0R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F0R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F0R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F0R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F0R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F0R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F0R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F0R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F1R1 register  *******************/
S#define  CAN_F1R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F1R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F1R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F1R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F1R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F1R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F1R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F1R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F1R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F1R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F1R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F1R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F1R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F1R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F1R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F1R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F1R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F1R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F1R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F1R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F1R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F1R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F1R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F1R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F1R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F1R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F1R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F1R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F1R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F1R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F1R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F1R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F2R1 register  *******************/
S#define  CAN_F2R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F2R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F2R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F2R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F2R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F2R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F2R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F2R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F2R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F2R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F2R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F2R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F2R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F2R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F2R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F2R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F2R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F2R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F2R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F2R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F2R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F2R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F2R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F2R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F2R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F2R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F2R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F2R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F2R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F2R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F2R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F2R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F3R1 register  *******************/
S#define  CAN_F3R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F3R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F3R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F3R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F3R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F3R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F3R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F3R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F3R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F3R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F3R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F3R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F3R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F3R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F3R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F3R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F3R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F3R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F3R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F3R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F3R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F3R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F3R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F3R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F3R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F3R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F3R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F3R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F3R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F3R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F3R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F3R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F4R1 register  *******************/
S#define  CAN_F4R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F4R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F4R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F4R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F4R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F4R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F4R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F4R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F4R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F4R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F4R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F4R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F4R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F4R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F4R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F4R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F4R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F4R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F4R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F4R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F4R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F4R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F4R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F4R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F4R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F4R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F4R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F4R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F4R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F4R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F4R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F4R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F5R1 register  *******************/
S#define  CAN_F5R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F5R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F5R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F5R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F5R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F5R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F5R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F5R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F5R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F5R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F5R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F5R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F5R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F5R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F5R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F5R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F5R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F5R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F5R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F5R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F5R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F5R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F5R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F5R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F5R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F5R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F5R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F5R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F5R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F5R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F5R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F5R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F6R1 register  *******************/
S#define  CAN_F6R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F6R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F6R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F6R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F6R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F6R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F6R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F6R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F6R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F6R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F6R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F6R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F6R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F6R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F6R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F6R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F6R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F6R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F6R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F6R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F6R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F6R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F6R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F6R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F6R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F6R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F6R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F6R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F6R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F6R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F6R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F6R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F7R1 register  *******************/
S#define  CAN_F7R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F7R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F7R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F7R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F7R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F7R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F7R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F7R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F7R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F7R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F7R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F7R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F7R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F7R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F7R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F7R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F7R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F7R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F7R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F7R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F7R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F7R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F7R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F7R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F7R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F7R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F7R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F7R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F7R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F7R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F7R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F7R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F8R1 register  *******************/
S#define  CAN_F8R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F8R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F8R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F8R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F8R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F8R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F8R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F8R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F8R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F8R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F8R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F8R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F8R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F8R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F8R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F8R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F8R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F8R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F8R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F8R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F8R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F8R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F8R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F8R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F8R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F8R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F8R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F8R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F8R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F8R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F8R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F8R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F9R1 register  *******************/
S#define  CAN_F9R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F9R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F9R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F9R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F9R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F9R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F9R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F9R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F9R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F9R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F9R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F9R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F9R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F9R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F9R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F9R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F9R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F9R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F9R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F9R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F9R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F9R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F9R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F9R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F9R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F9R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F9R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F9R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F9R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F9R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F9R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F9R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F10R1 register  ******************/
S#define  CAN_F10R1_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F10R1_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F10R1_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F10R1_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F10R1_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F10R1_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F10R1_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F10R1_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F10R1_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F10R1_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F10R1_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F10R1_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F10R1_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F10R1_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F10R1_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F10R1_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F10R1_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F10R1_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F10R1_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F10R1_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F10R1_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F10R1_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F10R1_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F10R1_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F10R1_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F10R1_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F10R1_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F10R1_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F10R1_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F10R1_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F10R1_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F10R1_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F11R1 register  ******************/
S#define  CAN_F11R1_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F11R1_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F11R1_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F11R1_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F11R1_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F11R1_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F11R1_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F11R1_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F11R1_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F11R1_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F11R1_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F11R1_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F11R1_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F11R1_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F11R1_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F11R1_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F11R1_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F11R1_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F11R1_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F11R1_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F11R1_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F11R1_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F11R1_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F11R1_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F11R1_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F11R1_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F11R1_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F11R1_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F11R1_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F11R1_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F11R1_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F11R1_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F12R1 register  ******************/
S#define  CAN_F12R1_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F12R1_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F12R1_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F12R1_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F12R1_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F12R1_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F12R1_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F12R1_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F12R1_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F12R1_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F12R1_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F12R1_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F12R1_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F12R1_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F12R1_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F12R1_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F12R1_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F12R1_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F12R1_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F12R1_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F12R1_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F12R1_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F12R1_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F12R1_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F12R1_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F12R1_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F12R1_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F12R1_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F12R1_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F12R1_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F12R1_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F12R1_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F13R1 register  ******************/
S#define  CAN_F13R1_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F13R1_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F13R1_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F13R1_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F13R1_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F13R1_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F13R1_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F13R1_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F13R1_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F13R1_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F13R1_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F13R1_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F13R1_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F13R1_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F13R1_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F13R1_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F13R1_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F13R1_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F13R1_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F13R1_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F13R1_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F13R1_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F13R1_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F13R1_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F13R1_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F13R1_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F13R1_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F13R1_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F13R1_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F13R1_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F13R1_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F13R1_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F0R2 register  *******************/
S#define  CAN_F0R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F0R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F0R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F0R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F0R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F0R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F0R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F0R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F0R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F0R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F0R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F0R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F0R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F0R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F0R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F0R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F0R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F0R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F0R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F0R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F0R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F0R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F0R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F0R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F0R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F0R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F0R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F0R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F0R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F0R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F0R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F0R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F1R2 register  *******************/
S#define  CAN_F1R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F1R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F1R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F1R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F1R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F1R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F1R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F1R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F1R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F1R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F1R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F1R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F1R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F1R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F1R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F1R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F1R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F1R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F1R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F1R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F1R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F1R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F1R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F1R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F1R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F1R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F1R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F1R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F1R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F1R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F1R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F1R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F2R2 register  *******************/
S#define  CAN_F2R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F2R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F2R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F2R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F2R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F2R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F2R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F2R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F2R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F2R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F2R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F2R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F2R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F2R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F2R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F2R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F2R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F2R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F2R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F2R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F2R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F2R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F2R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F2R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F2R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F2R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F2R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F2R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F2R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F2R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F2R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F2R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F3R2 register  *******************/
S#define  CAN_F3R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F3R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F3R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F3R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F3R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F3R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F3R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F3R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F3R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F3R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F3R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F3R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F3R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F3R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F3R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F3R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F3R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F3R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F3R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F3R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F3R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F3R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F3R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F3R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F3R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F3R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F3R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F3R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F3R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F3R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F3R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F3R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F4R2 register  *******************/
S#define  CAN_F4R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F4R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F4R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F4R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F4R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F4R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F4R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F4R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F4R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F4R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F4R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F4R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F4R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F4R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F4R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F4R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F4R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F4R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F4R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F4R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F4R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F4R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F4R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F4R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F4R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F4R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F4R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F4R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F4R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F4R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F4R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F4R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F5R2 register  *******************/
S#define  CAN_F5R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F5R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F5R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F5R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F5R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F5R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F5R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F5R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F5R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F5R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F5R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F5R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F5R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F5R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F5R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F5R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F5R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F5R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F5R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F5R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F5R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F5R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F5R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F5R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F5R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F5R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F5R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F5R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F5R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F5R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F5R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F5R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F6R2 register  *******************/
S#define  CAN_F6R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F6R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F6R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F6R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F6R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F6R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F6R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F6R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F6R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F6R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F6R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F6R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F6R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F6R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F6R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F6R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F6R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F6R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F6R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F6R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F6R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F6R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F6R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F6R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F6R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F6R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F6R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F6R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F6R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F6R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F6R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F6R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F7R2 register  *******************/
S#define  CAN_F7R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F7R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F7R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F7R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F7R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F7R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F7R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F7R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F7R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F7R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F7R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F7R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F7R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F7R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F7R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F7R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F7R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F7R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F7R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F7R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F7R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F7R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F7R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F7R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F7R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F7R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F7R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F7R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F7R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F7R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F7R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F7R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F8R2 register  *******************/
S#define  CAN_F8R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F8R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F8R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F8R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F8R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F8R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F8R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F8R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F8R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F8R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F8R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F8R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F8R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F8R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F8R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F8R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F8R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F8R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F8R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F8R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F8R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F8R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F8R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F8R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F8R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F8R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F8R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F8R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F8R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F8R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F8R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F8R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F9R2 register  *******************/
S#define  CAN_F9R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F9R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F9R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F9R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F9R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F9R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F9R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F9R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F9R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F9R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F9R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F9R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F9R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F9R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F9R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F9R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F9R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F9R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F9R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F9R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F9R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F9R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F9R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F9R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F9R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F9R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F9R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F9R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F9R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F9R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F9R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F9R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F10R2 register  ******************/
S#define  CAN_F10R2_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F10R2_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F10R2_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F10R2_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F10R2_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F10R2_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F10R2_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F10R2_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F10R2_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F10R2_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F10R2_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F10R2_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F10R2_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F10R2_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F10R2_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F10R2_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F10R2_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F10R2_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F10R2_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F10R2_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F10R2_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F10R2_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F10R2_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F10R2_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F10R2_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F10R2_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F10R2_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F10R2_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F10R2_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F10R2_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F10R2_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F10R2_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F11R2 register  ******************/
S#define  CAN_F11R2_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F11R2_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F11R2_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F11R2_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F11R2_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F11R2_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F11R2_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F11R2_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F11R2_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F11R2_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F11R2_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F11R2_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F11R2_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F11R2_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F11R2_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F11R2_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F11R2_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F11R2_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F11R2_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F11R2_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F11R2_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F11R2_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F11R2_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F11R2_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F11R2_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F11R2_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F11R2_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F11R2_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F11R2_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F11R2_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F11R2_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F11R2_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F12R2 register  ******************/
S#define  CAN_F12R2_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F12R2_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F12R2_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F12R2_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F12R2_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F12R2_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F12R2_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F12R2_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F12R2_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F12R2_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F12R2_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F12R2_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F12R2_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F12R2_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F12R2_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F12R2_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F12R2_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F12R2_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F12R2_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F12R2_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F12R2_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F12R2_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F12R2_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F12R2_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F12R2_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F12R2_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F12R2_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F12R2_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F12R2_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F12R2_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F12R2_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F12R2_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F13R2 register  ******************/
S#define  CAN_F13R2_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F13R2_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F13R2_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F13R2_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F13R2_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F13R2_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F13R2_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F13R2_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F13R2_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F13R2_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F13R2_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F13R2_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F13R2_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F13R2_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F13R2_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F13R2_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F13R2_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F13R2_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F13R2_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F13R2_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F13R2_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F13R2_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F13R2_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F13R2_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F13R2_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F13R2_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F13R2_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F13R2_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F13R2_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F13R2_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F13R2_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F13R2_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S#if defined(STM32F446xx)
S/******************************************************************************/
S/*                                                                            */
S/*                          HDMI-CEC (CEC)                                    */
S/*                                                                            */
S/******************************************************************************/
S
S/*******************  Bit definition for CEC_CR register  *********************/
S#define  CEC_CR_CECEN                        ((uint32_t)0x00000001)       /*!< CEC Enable                              */
S#define  CEC_CR_TXSOM                        ((uint32_t)0x00000002)       /*!< CEC Tx Start Of Message                 */
S#define  CEC_CR_TXEOM                        ((uint32_t)0x00000004)       /*!< CEC Tx End Of Message                   */
S
S/*******************  Bit definition for CEC_CFGR register  *******************/
S#define  CEC_CFGR_SFT                        ((uint32_t)0x00000007)       /*!< CEC Signal Free Time                    */
S#define  CEC_CFGR_RXTOL                      ((uint32_t)0x00000008)       /*!< CEC Tolerance                           */
S#define  CEC_CFGR_BRESTP                     ((uint32_t)0x00000010)       /*!< CEC Rx Stop                             */
S#define  CEC_CFGR_BREGEN                     ((uint32_t)0x00000020)       /*!< CEC Bit Rising Error generation         */
S#define  CEC_CFGR_LREGEN                     ((uint32_t)0x00000040)       /*!< CEC Long Period Error generation        */
S#define  CEC_CFGR_SFTOPT                     ((uint32_t)0x00000100)       /*!< CEC Signal Free Time optional           */
S#define  CEC_CFGR_BRDNOGEN                   ((uint32_t)0x00000080)       /*!< CEC Broadcast No error generation       */
S#define  CEC_CFGR_OAR                        ((uint32_t)0x7FFF0000)       /*!< CEC Own Address                         */
S#define  CEC_CFGR_LSTN                       ((uint32_t)0x80000000)       /*!< CEC Listen mode                         */
S
S/*******************  Bit definition for CEC_TXDR register  *******************/
S#define  CEC_TXDR_TXD                        ((uint32_t)0x000000FF)       /*!< CEC Tx Data                              */
S
S/*******************  Bit definition for CEC_RXDR register  *******************/
S#define  CEC_TXDR_RXD                        ((uint32_t)0x000000FF)       /*!< CEC Rx Data                              */
S
S/*******************  Bit definition for CEC_ISR register  ********************/
S#define  CEC_ISR_RXBR                        ((uint32_t)0x00000001)       /*!< CEC Rx-Byte Received                      */
S#define  CEC_ISR_RXEND                       ((uint32_t)0x00000002)       /*!< CEC End Of Reception                      */
S#define  CEC_ISR_RXOVR                       ((uint32_t)0x00000004)       /*!< CEC Rx-Overrun                            */
S#define  CEC_ISR_BRE                         ((uint32_t)0x00000008)       /*!< CEC Rx Bit Rising Error                   */
S#define  CEC_ISR_SBPE                        ((uint32_t)0x00000010)       /*!< CEC Rx Short Bit period Error             */
S#define  CEC_ISR_LBPE                        ((uint32_t)0x00000020)       /*!< CEC Rx Long Bit period Error              */
S#define  CEC_ISR_RXACKE                      ((uint32_t)0x00000040)       /*!< CEC Rx Missing Acknowledge                */
S#define  CEC_ISR_ARBLST                      ((uint32_t)0x00000080)       /*!< CEC Arbitration Lost                      */
S#define  CEC_ISR_TXBR                        ((uint32_t)0x00000100)       /*!< CEC Tx Byte Request                       */
S#define  CEC_ISR_TXEND                       ((uint32_t)0x00000200)       /*!< CEC End of Transmission                   */
S#define  CEC_ISR_TXUDR                       ((uint32_t)0x00000400)       /*!< CEC Tx-Buffer Underrun                    */
S#define  CEC_ISR_TXERR                       ((uint32_t)0x00000800)       /*!< CEC Tx-Error                              */
S#define  CEC_ISR_TXACKE                      ((uint32_t)0x00001000)       /*!< CEC Tx Missing Acknowledge                */
S
S/*******************  Bit definition for CEC_IER register  ********************/
S#define  CEC_IER_RXBRIE                      ((uint32_t)0x00000001)       /*!< CEC Rx-Byte Received IT Enable            */
S#define  CEC_IER_RXENDIE                     ((uint32_t)0x00000002)       /*!< CEC End Of Reception IT Enable            */
S#define  CEC_IER_RXOVRIE                     ((uint32_t)0x00000004)       /*!< CEC Rx-Overrun IT Enable                  */
S#define  CEC_IER_BREIEIE                     ((uint32_t)0x00000008)       /*!< CEC Rx Bit Rising Error IT Enable         */
S#define  CEC_IER_SBPEIE                      ((uint32_t)0x00000010)       /*!< CEC Rx Short Bit period Error IT Enable   */
S#define  CEC_IER_LBPEIE                      ((uint32_t)0x00000020)       /*!< CEC Rx Long Bit period Error IT Enable    */
S#define  CEC_IER_RXACKEIE                    ((uint32_t)0x00000040)       /*!< CEC Rx Missing Acknowledge IT Enable      */
S#define  CEC_IER_ARBLSTIE                    ((uint32_t)0x00000080)       /*!< CEC Arbitration Lost IT Enable            */
S#define  CEC_IER_TXBRIE                      ((uint32_t)0x00000100)       /*!< CEC Tx Byte Request  IT Enable            */
S#define  CEC_IER_TXENDIE                     ((uint32_t)0x00000200)       /*!< CEC End of Transmission IT Enable         */
S#define  CEC_IER_TXUDRIE                     ((uint32_t)0x00000400)       /*!< CEC Tx-Buffer Underrun IT Enable          */
S#define  CEC_IER_TXERRIE                     ((uint32_t)0x00000800)       /*!< CEC Tx-Error IT Enable                    */
S#define  CEC_IER_TXACKEIE                    ((uint32_t)0x00001000)       /*!< CEC Tx Missing Acknowledge IT Enable      */
S#endif /* STM32F446xx */
S
S/******************************************************************************/
S/*                                                                            */
S/*                          CRC calculation unit                              */
S/*                                                                            */
S/******************************************************************************/
S/*******************  Bit definition for CRC_DR register  *********************/
S#define  CRC_DR_DR                           ((uint32_t)0xFFFFFFFF) /*!< Data register bits */
S
S
S/*******************  Bit definition for CRC_IDR register  ********************/
S#define  CRC_IDR_IDR                         ((uint8_t)0xFF)        /*!< General-purpose 8-bit data register bits */
S
S
S/********************  Bit definition for CRC_CR register  ********************/
S#define  CRC_CR_RESET                        ((uint8_t)0x01)        /*!< RESET bit */
S
S/******************************************************************************/
S/*                                                                            */
S/*                            Crypto Processor                                */
S/*                                                                            */
S/******************************************************************************/
S/******************* Bits definition for CRYP_CR register  ********************/
S#define CRYP_CR_ALGODIR                      ((uint32_t)0x00000004)
S
S#define CRYP_CR_ALGOMODE                     ((uint32_t)0x00080038)
S#define CRYP_CR_ALGOMODE_0                   ((uint32_t)0x00000008)
S#define CRYP_CR_ALGOMODE_1                   ((uint32_t)0x00000010)
S#define CRYP_CR_ALGOMODE_2                   ((uint32_t)0x00000020)
S#define CRYP_CR_ALGOMODE_TDES_ECB            ((uint32_t)0x00000000)
S#define CRYP_CR_ALGOMODE_TDES_CBC            ((uint32_t)0x00000008)
S#define CRYP_CR_ALGOMODE_DES_ECB             ((uint32_t)0x00000010)
S#define CRYP_CR_ALGOMODE_DES_CBC             ((uint32_t)0x00000018)
S#define CRYP_CR_ALGOMODE_AES_ECB             ((uint32_t)0x00000020)
S#define CRYP_CR_ALGOMODE_AES_CBC             ((uint32_t)0x00000028)
S#define CRYP_CR_ALGOMODE_AES_CTR             ((uint32_t)0x00000030)
S#define CRYP_CR_ALGOMODE_AES_KEY             ((uint32_t)0x00000038)
S
S#define CRYP_CR_DATATYPE                     ((uint32_t)0x000000C0)
S#define CRYP_CR_DATATYPE_0                   ((uint32_t)0x00000040)
S#define CRYP_CR_DATATYPE_1                   ((uint32_t)0x00000080)
S#define CRYP_CR_KEYSIZE                      ((uint32_t)0x00000300)
S#define CRYP_CR_KEYSIZE_0                    ((uint32_t)0x00000100)
S#define CRYP_CR_KEYSIZE_1                    ((uint32_t)0x00000200)
S#define CRYP_CR_FFLUSH                       ((uint32_t)0x00004000)
S#define CRYP_CR_CRYPEN                       ((uint32_t)0x00008000)
S
S#define CRYP_CR_GCM_CCMPH                    ((uint32_t)0x00030000)
S#define CRYP_CR_GCM_CCMPH_0                  ((uint32_t)0x00010000)
S#define CRYP_CR_GCM_CCMPH_1                  ((uint32_t)0x00020000)
S#define CRYP_CR_ALGOMODE_3                   ((uint32_t)0x00080000) 
S
S/****************** Bits definition for CRYP_SR register  *********************/
S#define CRYP_SR_IFEM                         ((uint32_t)0x00000001)
S#define CRYP_SR_IFNF                         ((uint32_t)0x00000002)
S#define CRYP_SR_OFNE                         ((uint32_t)0x00000004)
S#define CRYP_SR_OFFU                         ((uint32_t)0x00000008)
S#define CRYP_SR_BUSY                         ((uint32_t)0x00000010)
S/****************** Bits definition for CRYP_DMACR register  ******************/
S#define CRYP_DMACR_DIEN                      ((uint32_t)0x00000001)
S#define CRYP_DMACR_DOEN                      ((uint32_t)0x00000002)
S/*****************  Bits definition for CRYP_IMSCR register  ******************/
S#define CRYP_IMSCR_INIM                      ((uint32_t)0x00000001)
S#define CRYP_IMSCR_OUTIM                     ((uint32_t)0x00000002)
S/****************** Bits definition for CRYP_RISR register  *******************/
S#define CRYP_RISR_OUTRIS                     ((uint32_t)0x00000001)
S#define CRYP_RISR_INRIS                      ((uint32_t)0x00000002)
S/****************** Bits definition for CRYP_MISR register  *******************/
S#define CRYP_MISR_INMIS                      ((uint32_t)0x00000001)
S#define CRYP_MISR_OUTMIS                     ((uint32_t)0x00000002)
S
S/******************************************************************************/
S/*                                                                            */
S/*                      Digital to Analog Converter                           */
S/*                                                                            */
S/******************************************************************************/
S/********************  Bit definition for DAC_CR register  ********************/
S#define  DAC_CR_EN1                          ((uint32_t)0x00000001)        /*!<DAC channel1 enable */
S#define  DAC_CR_BOFF1                        ((uint32_t)0x00000002)        /*!<DAC channel1 output buffer disable */
S#define  DAC_CR_TEN1                         ((uint32_t)0x00000004)        /*!<DAC channel1 Trigger enable */
S
S#define  DAC_CR_TSEL1                        ((uint32_t)0x00000038)        /*!<TSEL1[2:0] (DAC channel1 Trigger selection) */
S#define  DAC_CR_TSEL1_0                      ((uint32_t)0x00000008)        /*!<Bit 0 */
S#define  DAC_CR_TSEL1_1                      ((uint32_t)0x00000010)        /*!<Bit 1 */
S#define  DAC_CR_TSEL1_2                      ((uint32_t)0x00000020)        /*!<Bit 2 */
S
S#define  DAC_CR_WAVE1                        ((uint32_t)0x000000C0)        /*!<WAVE1[1:0] (DAC channel1 noise/triangle wave generation enable) */
S#define  DAC_CR_WAVE1_0                      ((uint32_t)0x00000040)        /*!<Bit 0 */
S#define  DAC_CR_WAVE1_1                      ((uint32_t)0x00000080)        /*!<Bit 1 */
S
S#define  DAC_CR_MAMP1                        ((uint32_t)0x00000F00)        /*!<MAMP1[3:0] (DAC channel1 Mask/Amplitude selector) */
S#define  DAC_CR_MAMP1_0                      ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  DAC_CR_MAMP1_1                      ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  DAC_CR_MAMP1_2                      ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  DAC_CR_MAMP1_3                      ((uint32_t)0x00000800)        /*!<Bit 3 */
S
S#define  DAC_CR_DMAEN1                       ((uint32_t)0x00001000)        /*!<DAC channel1 DMA enable */
S#define  DAC_CR_DMAUDRIE1                    ((uint32_t)0x00002000)        /*!<DAC channel1 DMA underrun interrupt enable*/
S#define  DAC_CR_EN2                          ((uint32_t)0x00010000)        /*!<DAC channel2 enable */
S#define  DAC_CR_BOFF2                        ((uint32_t)0x00020000)        /*!<DAC channel2 output buffer disable */
S#define  DAC_CR_TEN2                         ((uint32_t)0x00040000)        /*!<DAC channel2 Trigger enable */
S
S#define  DAC_CR_TSEL2                        ((uint32_t)0x00380000)        /*!<TSEL2[2:0] (DAC channel2 Trigger selection) */
S#define  DAC_CR_TSEL2_0                      ((uint32_t)0x00080000)        /*!<Bit 0 */
S#define  DAC_CR_TSEL2_1                      ((uint32_t)0x00100000)        /*!<Bit 1 */
S#define  DAC_CR_TSEL2_2                      ((uint32_t)0x00200000)        /*!<Bit 2 */
S
S#define  DAC_CR_WAVE2                        ((uint32_t)0x00C00000)        /*!<WAVE2[1:0] (DAC channel2 noise/triangle wave generation enable) */
S#define  DAC_CR_WAVE2_0                      ((uint32_t)0x00400000)        /*!<Bit 0 */
S#define  DAC_CR_WAVE2_1                      ((uint32_t)0x00800000)        /*!<Bit 1 */
S
S#define  DAC_CR_MAMP2                        ((uint32_t)0x0F000000)        /*!<MAMP2[3:0] (DAC channel2 Mask/Amplitude selector) */
S#define  DAC_CR_MAMP2_0                      ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  DAC_CR_MAMP2_1                      ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  DAC_CR_MAMP2_2                      ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  DAC_CR_MAMP2_3                      ((uint32_t)0x08000000)        /*!<Bit 3 */
S
S#define  DAC_CR_DMAEN2                       ((uint32_t)0x10000000)        /*!<DAC channel2 DMA enabled */
S#define  DAC_CR_DMAUDRIE2                    ((uint32_t)0x20000000U)        /*!<DAC channel2 DMA underrun interrupt enable*/
S
S/*****************  Bit definition for DAC_SWTRIGR register  ******************/
S#define  DAC_SWTRIGR_SWTRIG1                 ((uint8_t)0x01)               /*!<DAC channel1 software trigger */
S#define  DAC_SWTRIGR_SWTRIG2                 ((uint8_t)0x02)               /*!<DAC channel2 software trigger */
S
S/*****************  Bit definition for DAC_DHR12R1 register  ******************/
S#define  DAC_DHR12R1_DACC1DHR                ((uint16_t)0x0FFF)            /*!<DAC channel1 12-bit Right aligned data */
S
S/*****************  Bit definition for DAC_DHR12L1 register  ******************/
S#define  DAC_DHR12L1_DACC1DHR                ((uint16_t)0xFFF0)            /*!<DAC channel1 12-bit Left aligned data */
S
S/******************  Bit definition for DAC_DHR8R1 register  ******************/
S#define  DAC_DHR8R1_DACC1DHR                 ((uint8_t)0xFF)               /*!<DAC channel1 8-bit Right aligned data */
S
S/*****************  Bit definition for DAC_DHR12R2 register  ******************/
S#define  DAC_DHR12R2_DACC2DHR                ((uint16_t)0x0FFF)            /*!<DAC channel2 12-bit Right aligned data */
S
S/*****************  Bit definition for DAC_DHR12L2 register  ******************/
S#define  DAC_DHR12L2_DACC2DHR                ((uint16_t)0xFFF0)            /*!<DAC channel2 12-bit Left aligned data */
S
S/******************  Bit definition for DAC_DHR8R2 register  ******************/
S#define  DAC_DHR8R2_DACC2DHR                 ((uint8_t)0xFF)               /*!<DAC channel2 8-bit Right aligned data */
S
S/*****************  Bit definition for DAC_DHR12RD register  ******************/
S#define  DAC_DHR12RD_DACC1DHR                ((uint32_t)0x00000FFF)        /*!<DAC channel1 12-bit Right aligned data */
S#define  DAC_DHR12RD_DACC2DHR                ((uint32_t)0x0FFF0000)        /*!<DAC channel2 12-bit Right aligned data */
S
S/*****************  Bit definition for DAC_DHR12LD register  ******************/
S#define  DAC_DHR12LD_DACC1DHR                ((uint32_t)0x0000FFF0)        /*!<DAC channel1 12-bit Left aligned data */
S#define  DAC_DHR12LD_DACC2DHR                ((uint32_t)0xFFF00000)        /*!<DAC channel2 12-bit Left aligned data */
S
S/******************  Bit definition for DAC_DHR8RD register  ******************/
S#define  DAC_DHR8RD_DACC1DHR                 ((uint16_t)0x00FF)            /*!<DAC channel1 8-bit Right aligned data */
S#define  DAC_DHR8RD_DACC2DHR                 ((uint16_t)0xFF00)            /*!<DAC channel2 8-bit Right aligned data */
S
S/*******************  Bit definition for DAC_DOR1 register  *******************/
S#define  DAC_DOR1_DACC1DOR                   ((uint16_t)0x0FFF)            /*!<DAC channel1 data output */
S
S/*******************  Bit definition for DAC_DOR2 register  *******************/
S#define  DAC_DOR2_DACC2DOR                   ((uint16_t)0x0FFF)            /*!<DAC channel2 data output */
S
S/********************  Bit definition for DAC_SR register  ********************/
S#define  DAC_SR_DMAUDR1                      ((uint32_t)0x00002000)        /*!<DAC channel1 DMA underrun flag */
S#define  DAC_SR_DMAUDR2                      ((uint32_t)0x20000000)        /*!<DAC channel2 DMA underrun flag */
S
S/******************************************************************************/
S/*                                                                            */
S/*                                 Debug MCU                                  */
S/*                                                                            */
S/******************************************************************************/
S
S/******************************************************************************/
S/*                                                                            */
S/*                                    DCMI                                    */
S/*                                                                            */
S/******************************************************************************/
S/********************  Bits definition for DCMI_CR register  ******************/
S#define DCMI_CR_CAPTURE                      ((uint32_t)0x00000001)
S#define DCMI_CR_CM                           ((uint32_t)0x00000002)
S#define DCMI_CR_CROP                         ((uint32_t)0x00000004)
S#define DCMI_CR_JPEG                         ((uint32_t)0x00000008)
S#define DCMI_CR_ESS                          ((uint32_t)0x00000010)
S#define DCMI_CR_PCKPOL                       ((uint32_t)0x00000020)
S#define DCMI_CR_HSPOL                        ((uint32_t)0x00000040)
S#define DCMI_CR_VSPOL                        ((uint32_t)0x00000080)
S#define DCMI_CR_FCRC_0                       ((uint32_t)0x00000100)
S#define DCMI_CR_FCRC_1                       ((uint32_t)0x00000200)
S#define DCMI_CR_EDM_0                        ((uint32_t)0x00000400)
S#define DCMI_CR_EDM_1                        ((uint32_t)0x00000800)
S#define DCMI_CR_CRE                          ((uint32_t)0x00001000)
S#define DCMI_CR_ENABLE                       ((uint32_t)0x00004000)
S
S/********************  Bits definition for DCMI_SR register  ******************/
S#define DCMI_SR_HSYNC                        ((uint32_t)0x00000001)
S#define DCMI_SR_VSYNC                        ((uint32_t)0x00000002)
S#define DCMI_SR_FNE                          ((uint32_t)0x00000004)
S
S/********************  Bits definition for DCMI_RIS register  *****************/
S#define DCMI_RIS_FRAME_RIS                   ((uint32_t)0x00000001)
S#define DCMI_RIS_OVR_RIS                     ((uint32_t)0x00000002)
S#define DCMI_RIS_ERR_RIS                     ((uint32_t)0x00000004)
S#define DCMI_RIS_VSYNC_RIS                   ((uint32_t)0x00000008)
S#define DCMI_RIS_LINE_RIS                     ((uint32_t)0x00000010)
S/* Legacy defines */
S#define DCMI_RISR_FRAME_RIS                  DCMI_RIS_FRAME_RIS
S#define DCMI_RISR_OVR_RIS                    DCMI_RIS_OVR_RIS
S#define DCMI_RISR_ERR_RIS                    DCMI_RIS_ERR_RIS
S#define DCMI_RISR_VSYNC_RIS                  DCMI_RIS_VSYNC_RIS
S#define DCMI_RISR_LINE_RIS                   DCMI_RIS_LINE_RIS
S#define DCMI_RISR_OVF_RIS                    DCMI_RIS_OVR_RIS
S
S/********************  Bits definition for DCMI_IER register  *****************/
S#define DCMI_IER_FRAME_IE                    ((uint32_t)0x00000001)
S#define DCMI_IER_OVR_IE                      ((uint32_t)0x00000002)
S#define DCMI_IER_ERR_IE                      ((uint32_t)0x00000004)
S#define DCMI_IER_VSYNC_IE                    ((uint32_t)0x00000008)
S#define DCMI_IER_LINE_IE                     ((uint32_t)0x00000010)
S
S/* Legacy defines */
S#define DCMI_IER_OVF_IE                      DCMI_IER_OVR_IE
S
S/********************  Bits definition for DCMI_MIS register  ****************/
S#define DCMI_MIS_FRAME_MIS                   ((uint32_t)0x00000001)
S#define DCMI_MIS_OVR_MIS                     ((uint32_t)0x00000002)
S#define DCMI_MIS_ERR_MIS                     ((uint32_t)0x00000004)
S#define DCMI_MIS_VSYNC_MIS                   ((uint32_t)0x00000008)
S#define DCMI_MIS_LINE_MIS                    ((uint32_t)0x00000010)
S
S/* Legacy defines */
S#define DCMI_MISR_FRAME_MIS                  DCMI_MIS_FRAME_MIS
S#define DCMI_MISR_OVF_MIS                    DCMI_MIS_OVR_MIS
S#define DCMI_MISR_ERR_MIS                    DCMI_MIS_ERR_MIS
S#define DCMI_MISR_VSYNC_MIS                  DCMI_MIS_VSYNC_MIS
S#define DCMI_MISR_LINE_MIS                   DCMI_MIS_LINE_MIS
S
S/********************  Bits definition for DCMI_ICR register  *****************/
S#define DCMI_ICR_FRAME_ISC                   ((uint32_t)0x00000001)
S#define DCMI_ICR_OVR_ISC                     ((uint32_t)0x00000002)
S#define DCMI_ICR_ERR_ISC                     ((uint32_t)0x00000004)
S#define DCMI_ICR_VSYNC_ISC                   ((uint32_t)0x00000008)
S#define DCMI_ICR_LINE_ISC                    ((uint32_t)0x00000010)
S
S/* Legacy defines */
S#define DCMI_ICR_OVF_ISC                     DCMI_ICR_OVR_ISC
S
S/********************  Bits definition for DCMI_ESCR register  ******************/
S#define DCMI_ESCR_FSC                        ((uint32_t)0x000000FF)
S#define DCMI_ESCR_LSC                        ((uint32_t)0x0000FF00)
S#define DCMI_ESCR_LEC                        ((uint32_t)0x00FF0000)
S#define DCMI_ESCR_FEC                        ((uint32_t)0xFF000000)
S
S/********************  Bits definition for DCMI_ESUR register  ******************/
S#define DCMI_ESUR_FSU                        ((uint32_t)0x000000FF)
S#define DCMI_ESUR_LSU                        ((uint32_t)0x0000FF00)
S#define DCMI_ESUR_LEU                        ((uint32_t)0x00FF0000)
S#define DCMI_ESUR_FEU                        ((uint32_t)0xFF000000)
S
S/********************  Bits definition for DCMI_CWSTRT register  ******************/
S#define DCMI_CWSTRT_HOFFCNT                  ((uint32_t)0x00003FFF)
S#define DCMI_CWSTRT_VST                      ((uint32_t)0x1FFF0000)
S
S/********************  Bits definition for DCMI_CWSIZE register  ******************/
S#define DCMI_CWSIZE_CAPCNT                   ((uint32_t)0x00003FFF)
S#define DCMI_CWSIZE_VLINE                    ((uint32_t)0x3FFF0000)
S
S/********************  Bits definition for DCMI_DR register  ******************/
S#define DCMI_DR_BYTE0                        ((uint32_t)0x000000FF)
S#define DCMI_DR_BYTE1                        ((uint32_t)0x0000FF00)
S#define DCMI_DR_BYTE2                        ((uint32_t)0x00FF0000)
S#define DCMI_DR_BYTE3                        ((uint32_t)0xFF000000)
S
S/******************************************************************************/
S/*                                                                            */
S/*                 Digital Filter for Sigma Delta Modulators                  */
S/*                                                                            */
S/******************************************************************************/
S
S/****************   DFSDM channel configuration registers  ********************/
S
S/***************  Bit definition for DFSDM_CHCFGR1 register  ******************/
S#define  DFSDM_CHCFGR1_DFSDMEN                ((uint32_t)0x80000000)            /*!< Global enable for DFSDM interface */
S#define  DFSDM_CHCFGR1_CKOUTSRC               ((uint32_t)0x40000000)            /*!< Output serial clock source selection */
S#define  DFSDM_CHCFGR1_CKOUTDIV               ((uint32_t)0x00FF0000)            /*!< CKOUTDIV[7:0] output serial clock divider */
S#define  DFSDM_CHCFGR1_DATPACK                ((uint32_t)0x0000C000)            /*!< DATPACK[1:0] Data packing mode */
S#define  DFSDM_CHCFGR1_DATPACK_1              ((uint32_t)0x00008000)            /*!< Data packing mode, Bit 1 */
S#define  DFSDM_CHCFGR1_DATPACK_0              ((uint32_t)0x00004000)            /*!< Data packing mode, Bit 0 */
S#define  DFSDM_CHCFGR1_DATMPX                 ((uint32_t)0x00003000)            /*!< DATMPX[1:0] Input data multiplexer for channel y */
S#define  DFSDM_CHCFGR1_DATMPX_1               ((uint32_t)0x00002000)            /*!< Input data multiplexer for channel y, Bit 1 */
S#define  DFSDM_CHCFGR1_DATMPX_0               ((uint32_t)0x00001000)            /*!< Input data multiplexer for channel y, Bit 0 */
S#define  DFSDM_CHCFGR1_CHINSEL                ((uint32_t)0x00000100)            /*!< Serial inputs selection for channel y */
S#define  DFSDM_CHCFGR1_CHEN                   ((uint32_t)0x00000080)            /*!< Channel y enable */
S#define  DFSDM_CHCFGR1_CKABEN                 ((uint32_t)0x00000040)            /*!< Clock absence detector enable on channel y */
S#define  DFSDM_CHCFGR1_SCDEN                  ((uint32_t)0x00000020)            /*!< Short circuit detector enable on channel y */
S#define  DFSDM_CHCFGR1_SPICKSEL               ((uint32_t)0x0000000C)            /*!< SPICKSEL[1:0] SPI clock select for channel y */
S#define  DFSDM_CHCFGR1_SPICKSEL_1             ((uint32_t)0x00000008)            /*!< SPI clock select for channel y, Bit 1 */
S#define  DFSDM_CHCFGR1_SPICKSEL_0             ((uint32_t)0x00000004)            /*!< SPI clock select for channel y, Bit 0 */
S#define  DFSDM_CHCFGR1_SITP                   ((uint32_t)0x00000003)            /*!< SITP[1:0] Serial interface type for channel y */
S#define  DFSDM_CHCFGR1_SITP_1                 ((uint32_t)0x00000002)            /*!< Serial interface type for channel y, Bit 1 */
S#define  DFSDM_CHCFGR1_SITP_0                 ((uint32_t)0x00000001)            /*!< Serial interface type for channel y, Bit 0 */
S
S/***************  Bit definition for DFSDM_CHCFGR2 register  ******************/
S#define  DFSDM_CHCFGR2_OFFSET                 ((uint32_t)0xFFFFFF00)            /*!< OFFSET[23:0] 24-bit calibration offset for channel y */
S#define  DFSDM_CHCFGR2_DTRBS                  ((uint32_t)0x000000F8)            /*!< DTRBS[4:0] Data right bit-shift for channel y */
S
S/******************  Bit definition for DFSDM_CHAWSCDR register ***************/
S#define  DFSDM_CHAWSCDR_AWFORD                ((uint32_t)0x00C00000)            /*!< AWFORD[1:0] Analog watchdog Sinc filter order on channel y */
S#define  DFSDM_CHAWSCDR_AWFORD_1              ((uint32_t)0x00800000)            /*!< Analog watchdog Sinc filter order on channel y, Bit 1 */
S#define  DFSDM_CHAWSCDR_AWFORD_0              ((uint32_t)0x00400000)            /*!< Analog watchdog Sinc filter order on channel y, Bit 0 */
S#define  DFSDM_CHAWSCDR_AWFOSR                ((uint32_t)0x001F0000)            /*!< AWFOSR[4:0] Analog watchdog filter oversampling ratio on channel y */
S#define  DFSDM_CHAWSCDR_BKSCD                 ((uint32_t)0x0000F000)            /*!< BKSCD[3:0] Break signal assignment for short circuit detector on channel y */
S#define  DFSDM_CHAWSCDR_SCDT                  ((uint32_t)0x000000FF)            /*!< SCDT[7:0] Short circuit detector threshold for channel y */
S
S/****************  Bit definition for DFSDM_CHWDATR register *******************/
S#define  DFSDM_CHWDATR_WDATA                  ((uint32_t)0x0000FFFF)            /*!< WDATA[15:0] Input channel y watchdog data */
S
S/****************  Bit definition for DFSDM_CHDATINR register *****************/
S#define  DFSDM_CHDATINR_INDAT0                ((uint32_t)0x0000FFFF)            /*!< INDAT0[31:16] Input data for channel y or channel (y+1) */
S#define  DFSDM_CHDATINR_INDAT1                ((uint32_t)0xFFFF0000)            /*!< INDAT0[15:0] Input data for channel y */
S
S/************************   DFSDM module registers  ****************************/
S
S/*****************  Bit definition for DFSDM_FLTCR1 register *******************/
S#define  DFSDM_FLTCR1_AWFSEL                  ((uint32_t)0x40000000)            /*!< Analog watchdog fast mode select */
S#define  DFSDM_FLTCR1_FAST                    ((uint32_t)0x20000000)            /*!< Fast conversion mode selection */
S#define  DFSDM_FLTCR1_RCH                     ((uint32_t)0x07000000)            /*!< RCH[2:0] Regular channel selection */
S#define  DFSDM_FLTCR1_RDMAEN                  ((uint32_t)0x00200000)            /*!< DMA channel enabled to read data for the regular conversion */
S#define  DFSDM_FLTCR1_RSYNC                   ((uint32_t)0x00080000)            /*!< Launch regular conversion synchronously with DFSDMx */
S#define  DFSDM_FLTCR1_RCONT                   ((uint32_t)0x00040000)            /*!< Continuous mode selection for regular conversions */
S#define  DFSDM_FLTCR1_RSWSTART                ((uint32_t)0x00020000)            /*!< Software start of a conversion on the regular channel */
S#define  DFSDM_FLTCR1_JEXTEN                  ((uint32_t)0x00006000)            /*!< JEXTEN[1:0] Trigger enable and trigger edge selection for injected conversions */
S#define  DFSDM_FLTCR1_JEXTEN_1                ((uint32_t)0x00004000)            /*!< Trigger enable and trigger edge selection for injected conversions, Bit 1 */
S#define  DFSDM_FLTCR1_JEXTEN_0                ((uint32_t)0x00002000)            /*!< Trigger enable and trigger edge selection for injected conversions, Bit 0 */
S#define  DFSDM_FLTCR1_JEXTSEL                 ((uint32_t)0x00000700)            /*!< JEXTSEL[2:0]Trigger signal selection for launching injected conversions */
S#define  DFSDM_FLTCR1_JEXTSEL_2               ((uint32_t)0x00000400)            /*!< Trigger signal selection for launching injected conversions, Bit 2 */
S#define  DFSDM_FLTCR1_JEXTSEL_1               ((uint32_t)0x00000200)            /*!< Trigger signal selection for launching injected conversions, Bit 1 */
S#define  DFSDM_FLTCR1_JEXTSEL_0               ((uint32_t)0x00000100)            /*!< Trigger signal selection for launching injected conversions, Bit 0 */
S#define  DFSDM_FLTCR1_JDMAEN                  ((uint32_t)0x00000020)            /*!< DMA channel enabled to read data for the injected channel group */
S#define  DFSDM_FLTCR1_JSCAN                   ((uint32_t)0x00000010)            /*!< Scanning conversion in continuous mode selection for injected conversions */
S#define  DFSDM_FLTCR1_JSYNC                   ((uint32_t)0x00000008)            /*!< Launch an injected conversion synchronously with DFSDMx JSWSTART trigger  */
S#define  DFSDM_FLTCR1_JSWSTART                ((uint32_t)0x00000002)            /*!< Start the conversion of the injected group of channels */
S#define  DFSDM_FLTCR1_DFEN                    ((uint32_t)0x00000001)            /*!< DFSDM enable */
S
S/********************  Bit definition for DFSDM_FLTCR2 register ***************/
S#define  DFSDM_FLTCR2_AWDCH                   ((uint32_t)0x000F0000)            /*!< AWDCH[7:0] Analog watchdog channel selection */
S#define  DFSDM_FLTCR2_EXCH                    ((uint32_t)0x00000F00)            /*!< EXCH[7:0] Extreme detector channel selection */
S#define  DFSDM_FLTCR2_CKABIE                  ((uint32_t)0x00000040)            /*!< Clock absence interrupt enable */
S#define  DFSDM_FLTCR2_SCDIE                   ((uint32_t)0x00000020)            /*!< Short circuit detector interrupt enable */
S#define  DFSDM_FLTCR2_AWDIE                   ((uint32_t)0x00000010)            /*!< Analog watchdog interrupt enable */
S#define  DFSDM_FLTCR2_ROVRIE                  ((uint32_t)0x00000008)            /*!< Regular data overrun interrupt enable */
S#define  DFSDM_FLTCR2_JOVRIE                  ((uint32_t)0x00000004)            /*!< Injected data overrun interrupt enable */
S#define  DFSDM_FLTCR2_REOCIE                  ((uint32_t)0x00000002)            /*!< Regular end of conversion interrupt enable */
S#define  DFSDM_FLTCR2_JEOCIE                  ((uint32_t)0x00000001)            /*!< Injected end of conversion interrupt enable */
S
S/*****************  Bit definition for DFSDM_FLTISR register *******************/
S#define  DFSDM_FLTISR_SCDF                    ((uint32_t)0x0F000000)            /*!< SCDF[7:0] Short circuit detector flag */
S#define  DFSDM_FLTISR_CKABF                   ((uint32_t)0x000F0000)            /*!< CKABF[7:0] Clock absence flag */
S#define  DFSDM_FLTISR_RCIP                    ((uint32_t)0x00004000)            /*!< Regular conversion in progress status */
S#define  DFSDM_FLTISR_JCIP                    ((uint32_t)0x00002000)            /*!< Injected conversion in progress status */
S#define  DFSDM_FLTISR_AWDF                    ((uint32_t)0x00000010)            /*!< Analog watchdog */
S#define  DFSDM_FLTISR_ROVRF                   ((uint32_t)0x00000008)            /*!< Regular conversion overrun flag */
S#define  DFSDM_FLTISR_JOVRF                   ((uint32_t)0x00000004)            /*!< Injected conversion overrun flag */
S#define  DFSDM_FLTISR_REOCF                   ((uint32_t)0x00000002)            /*!< End of regular conversion flag */
S#define  DFSDM_FLTISR_JEOCF                   ((uint32_t)0x00000001)            /*!< End of injected conversion flag */
S
S/*****************  Bit definition for DFSDM_FLTICR register *******************/
S#define  DFSDM_FLTICR_CLRSCSDF                ((uint32_t)0x0F000000)            /*!< CLRSCSDF[7:0] Clear the short circuit detector flag */
S#define  DFSDM_FLTICR_CLRCKABF                ((uint32_t)0x000F0000)            /*!< CLRCKABF[7:0] Clear the clock absence flag */
S#define  DFSDM_FLTICR_CLRROVRF                ((uint32_t)0x00000008)            /*!< Clear the regular conversion overrun flag */
S#define  DFSDM_FLTICR_CLRJOVRF                ((uint32_t)0x00000004)            /*!< Clear the injected conversion overrun flag */
S
S/****************  Bit definition for DFSDM_FLTJCHGR register ******************/
S#define  DFSDM_FLTJCHGR_JCHG                  ((uint32_t)0x000000FF)            /*!< JCHG[7:0] Injected channel group selection */
S
S/*****************  Bit definition for DFSDM_FLTFCR register *******************/
S#define  DFSDM_FLTFCR_FORD                    ((uint32_t)0xE0000000)            /*!< FORD[2:0] Sinc filter order */
S#define  DFSDM_FLTFCR_FORD_2                  ((uint32_t)0x80000000)            /*!< Sinc filter order, Bit 2 */
S#define  DFSDM_FLTFCR_FORD_1                  ((uint32_t)0x40000000)            /*!< Sinc filter order, Bit 1 */
S#define  DFSDM_FLTFCR_FORD_0                  ((uint32_t)0x20000000)            /*!< Sinc filter order, Bit 0 */
S#define  DFSDM_FLTFCR_FOSR                    ((uint32_t)0x03FF0000)            /*!< FOSR[9:0] Sinc filter oversampling ratio (decimation rate) */
S#define  DFSDM_FLTFCR_IOSR                    ((uint32_t)0x000000FF)            /*!< IOSR[7:0] Integrator oversampling ratio (averaging length) */
S
S/***************  Bit definition for DFSDM_FLTJDATAR register *****************/
S#define  DFSDM_FLTJDATAR_JDATA                ((uint32_t)0xFFFFFF00)            /*!< JDATA[23:0] Injected group conversion data */
S#define  DFSDM_FLTJDATAR_JDATACH              ((uint32_t)0x00000007)            /*!< JDATACH[2:0] Injected channel most recently converted */
S
S/***************  Bit definition for DFSDM_FLTRDATAR register *****************/
S#define  DFSDM_FLTRDATAR_RDATA                ((uint32_t)0xFFFFFF00)            /*!< RDATA[23:0] Regular channel conversion data */
S#define  DFSDM_FLTRDATAR_RPEND                ((uint32_t)0x00000010)            /*!< RPEND Regular channel pending data */
S#define  DFSDM_FLTRDATAR_RDATACH              ((uint32_t)0x00000007)            /*!< RDATACH[2:0] Regular channel most recently converted */
S
S/***************  Bit definition for DFSDM_FLTAWHTR register ******************/
S#define  DFSDM_FLTAWHTR_AWHT                 ((uint32_t)0xFFFFFF00)             /*!< AWHT[23:0] Analog watchdog high threshold */
S#define  DFSDM_FLTAWHTR_BKAWH                ((uint32_t)0x0000000F)             /*!< BKAWH[3:0] Break signal assignment to analog watchdog high threshold event */
S
S/***************  Bit definition for DFSDM_FLTAWLTR register ******************/
S#define  DFSDM_FLTAWLTR_AWLT                 ((uint32_t)0xFFFFFF00)             /*!< AWLT[23:0] Analog watchdog low threshold */
S#define  DFSDM_FLTAWLTR_BKAWL                ((uint32_t)0x0000000F)             /*!< BKAWL[3:0] Break signal assignment to analog watchdog low threshold event */
S
S/***************  Bit definition for DFSDM_FLTAWSR register *******************/
S#define  DFSDM_FLTAWSR_AWHTF                 ((uint32_t)0x00000F00)             /*!< AWHTF[15:8] Analog watchdog high threshold error on given channels */
S#define  DFSDM_FLTAWSR_AWLTF                 ((uint32_t)0x0000000F)             /*!< AWLTF[7:0] Analog watchdog low threshold error on given channels */
S
S/***************  Bit definition for DFSDM_FLTAWCFR register ******************/
S#define  DFSDM_FLTAWCFR_CLRAWHTF             ((uint32_t)0x00000F00)             /*!< CLRAWHTF[15:8] Clear the Analog watchdog high threshold flag */
S#define  DFSDM_FLTAWCFR_CLRAWLTF             ((uint32_t)0x0000000F)             /*!< CLRAWLTF[7:0] Clear the Analog watchdog low threshold flag */
S
S/***************  Bit definition for DFSDM_FLTEXMAX register ******************/
S#define  DFSDM_FLTEXMAX_EXMAX                ((uint32_t)0xFFFFFF00)             /*!< EXMAX[23:0] Extreme detector maximum value */
S#define  DFSDM_FLTEXMAX_EXMAXCH              ((uint32_t)0x00000007)             /*!< EXMAXCH[2:0] Extreme detector maximum data channel */
S
S/***************  Bit definition for DFSDM_FLTEXMIN register ******************/
S#define  DFSDM_FLTEXMIN_EXMIN                ((uint32_t)0xFFFFFF00)             /*!< EXMIN[23:0] Extreme detector minimum value */
S#define  DFSDM_FLTEXMIN_EXMINCH              ((uint32_t)0x00000007)             /*!< EXMINCH[2:0] Extreme detector minimum data channel */
S
S/***************  Bit definition for DFSDM_FLTCNVTIMR register ****************/
S#define  DFSDM_FLTCNVTIMR_CNVCNT             ((uint32_t)0xFFFFFFF0)             /*!< CNVCNT[27:0]: 28-bit timer counting conversion time */
S
S/******************************************************************************/
S/*                                                                            */
S/*                             DMA Controller                                 */
S/*                                                                            */
S/******************************************************************************/
S/********************  Bits definition for DMA_SxCR register  *****************/ 
S#define DMA_SxCR_CHSEL                       ((uint32_t)0x0E000000)
S#define DMA_SxCR_CHSEL_0                     ((uint32_t)0x02000000)
S#define DMA_SxCR_CHSEL_1                     ((uint32_t)0x04000000)
S#define DMA_SxCR_CHSEL_2                     ((uint32_t)0x08000000) 
S#define DMA_SxCR_MBURST                      ((uint32_t)0x01800000)
S#define DMA_SxCR_MBURST_0                    ((uint32_t)0x00800000)
S#define DMA_SxCR_MBURST_1                    ((uint32_t)0x01000000)
S#define DMA_SxCR_PBURST                      ((uint32_t)0x00600000)
S#define DMA_SxCR_PBURST_0                    ((uint32_t)0x00200000)
S#define DMA_SxCR_PBURST_1                    ((uint32_t)0x00400000)
S#define DMA_SxCR_ACK                         ((uint32_t)0x00100000)
S#define DMA_SxCR_CT                          ((uint32_t)0x00080000)  
S#define DMA_SxCR_DBM                         ((uint32_t)0x00040000)
S#define DMA_SxCR_PL                          ((uint32_t)0x00030000)
S#define DMA_SxCR_PL_0                        ((uint32_t)0x00010000)
S#define DMA_SxCR_PL_1                        ((uint32_t)0x00020000)
S#define DMA_SxCR_PINCOS                      ((uint32_t)0x00008000)
S#define DMA_SxCR_MSIZE                       ((uint32_t)0x00006000)
S#define DMA_SxCR_MSIZE_0                     ((uint32_t)0x00002000)
S#define DMA_SxCR_MSIZE_1                     ((uint32_t)0x00004000)
S#define DMA_SxCR_PSIZE                       ((uint32_t)0x00001800)
S#define DMA_SxCR_PSIZE_0                     ((uint32_t)0x00000800)
S#define DMA_SxCR_PSIZE_1                     ((uint32_t)0x00001000)
S#define DMA_SxCR_MINC                        ((uint32_t)0x00000400)
S#define DMA_SxCR_PINC                        ((uint32_t)0x00000200)
S#define DMA_SxCR_CIRC                        ((uint32_t)0x00000100)
S#define DMA_SxCR_DIR                         ((uint32_t)0x000000C0)
S#define DMA_SxCR_DIR_0                       ((uint32_t)0x00000040)
S#define DMA_SxCR_DIR_1                       ((uint32_t)0x00000080)
S#define DMA_SxCR_PFCTRL                      ((uint32_t)0x00000020)
S#define DMA_SxCR_TCIE                        ((uint32_t)0x00000010)
S#define DMA_SxCR_HTIE                        ((uint32_t)0x00000008)
S#define DMA_SxCR_TEIE                        ((uint32_t)0x00000004)
S#define DMA_SxCR_DMEIE                       ((uint32_t)0x00000002)
S#define DMA_SxCR_EN                          ((uint32_t)0x00000001)
S
S/********************  Bits definition for DMA_SxCNDTR register  **************/
S#define DMA_SxNDT                            ((uint32_t)0x0000FFFF)
S#define DMA_SxNDT_0                          ((uint32_t)0x00000001)
S#define DMA_SxNDT_1                          ((uint32_t)0x00000002)
S#define DMA_SxNDT_2                          ((uint32_t)0x00000004)
S#define DMA_SxNDT_3                          ((uint32_t)0x00000008)
S#define DMA_SxNDT_4                          ((uint32_t)0x00000010)
S#define DMA_SxNDT_5                          ((uint32_t)0x00000020)
S#define DMA_SxNDT_6                          ((uint32_t)0x00000040)
S#define DMA_SxNDT_7                          ((uint32_t)0x00000080)
S#define DMA_SxNDT_8                          ((uint32_t)0x00000100)
S#define DMA_SxNDT_9                          ((uint32_t)0x00000200)
S#define DMA_SxNDT_10                         ((uint32_t)0x00000400)
S#define DMA_SxNDT_11                         ((uint32_t)0x00000800)
S#define DMA_SxNDT_12                         ((uint32_t)0x00001000)
S#define DMA_SxNDT_13                         ((uint32_t)0x00002000)
S#define DMA_SxNDT_14                         ((uint32_t)0x00004000)
S#define DMA_SxNDT_15                         ((uint32_t)0x00008000)
S
S/********************  Bits definition for DMA_SxFCR register  ****************/ 
S#define DMA_SxFCR_FEIE                       ((uint32_t)0x00000080)
S#define DMA_SxFCR_FS                         ((uint32_t)0x00000038)
S#define DMA_SxFCR_FS_0                       ((uint32_t)0x00000008)
S#define DMA_SxFCR_FS_1                       ((uint32_t)0x00000010)
S#define DMA_SxFCR_FS_2                       ((uint32_t)0x00000020)
S#define DMA_SxFCR_DMDIS                      ((uint32_t)0x00000004)
S#define DMA_SxFCR_FTH                        ((uint32_t)0x00000003)
S#define DMA_SxFCR_FTH_0                      ((uint32_t)0x00000001)
S#define DMA_SxFCR_FTH_1                      ((uint32_t)0x00000002)
S
S/********************  Bits definition for DMA_LISR register  *****************/ 
S#define DMA_LISR_TCIF3                       ((uint32_t)0x08000000)
S#define DMA_LISR_HTIF3                       ((uint32_t)0x04000000)
S#define DMA_LISR_TEIF3                       ((uint32_t)0x02000000)
S#define DMA_LISR_DMEIF3                      ((uint32_t)0x01000000)
S#define DMA_LISR_FEIF3                       ((uint32_t)0x00400000)
S#define DMA_LISR_TCIF2                       ((uint32_t)0x00200000)
S#define DMA_LISR_HTIF2                       ((uint32_t)0x00100000)
S#define DMA_LISR_TEIF2                       ((uint32_t)0x00080000)
S#define DMA_LISR_DMEIF2                      ((uint32_t)0x00040000)
S#define DMA_LISR_FEIF2                       ((uint32_t)0x00010000)
S#define DMA_LISR_TCIF1                       ((uint32_t)0x00000800)
S#define DMA_LISR_HTIF1                       ((uint32_t)0x00000400)
S#define DMA_LISR_TEIF1                       ((uint32_t)0x00000200)
S#define DMA_LISR_DMEIF1                      ((uint32_t)0x00000100)
S#define DMA_LISR_FEIF1                       ((uint32_t)0x00000040)
S#define DMA_LISR_TCIF0                       ((uint32_t)0x00000020)
S#define DMA_LISR_HTIF0                       ((uint32_t)0x00000010)
S#define DMA_LISR_TEIF0                       ((uint32_t)0x00000008)
S#define DMA_LISR_DMEIF0                      ((uint32_t)0x00000004)
S#define DMA_LISR_FEIF0                       ((uint32_t)0x00000001)
S
S/********************  Bits definition for DMA_HISR register  *****************/ 
S#define DMA_HISR_TCIF7                       ((uint32_t)0x08000000)
S#define DMA_HISR_HTIF7                       ((uint32_t)0x04000000)
S#define DMA_HISR_TEIF7                       ((uint32_t)0x02000000)
S#define DMA_HISR_DMEIF7                      ((uint32_t)0x01000000)
S#define DMA_HISR_FEIF7                       ((uint32_t)0x00400000)
S#define DMA_HISR_TCIF6                       ((uint32_t)0x00200000)
S#define DMA_HISR_HTIF6                       ((uint32_t)0x00100000)
S#define DMA_HISR_TEIF6                       ((uint32_t)0x00080000)
S#define DMA_HISR_DMEIF6                      ((uint32_t)0x00040000)
S#define DMA_HISR_FEIF6                       ((uint32_t)0x00010000)
S#define DMA_HISR_TCIF5                       ((uint32_t)0x00000800)
S#define DMA_HISR_HTIF5                       ((uint32_t)0x00000400)
S#define DMA_HISR_TEIF5                       ((uint32_t)0x00000200)
S#define DMA_HISR_DMEIF5                      ((uint32_t)0x00000100)
S#define DMA_HISR_FEIF5                       ((uint32_t)0x00000040)
S#define DMA_HISR_TCIF4                       ((uint32_t)0x00000020)
S#define DMA_HISR_HTIF4                       ((uint32_t)0x00000010)
S#define DMA_HISR_TEIF4                       ((uint32_t)0x00000008)
S#define DMA_HISR_DMEIF4                      ((uint32_t)0x00000004)
S#define DMA_HISR_FEIF4                       ((uint32_t)0x00000001)
S
S/********************  Bits definition for DMA_LIFCR register  ****************/ 
S#define DMA_LIFCR_CTCIF3                     ((uint32_t)0x08000000)
S#define DMA_LIFCR_CHTIF3                     ((uint32_t)0x04000000)
S#define DMA_LIFCR_CTEIF3                     ((uint32_t)0x02000000)
S#define DMA_LIFCR_CDMEIF3                    ((uint32_t)0x01000000)
S#define DMA_LIFCR_CFEIF3                     ((uint32_t)0x00400000)
S#define DMA_LIFCR_CTCIF2                     ((uint32_t)0x00200000)
S#define DMA_LIFCR_CHTIF2                     ((uint32_t)0x00100000)
S#define DMA_LIFCR_CTEIF2                     ((uint32_t)0x00080000)
S#define DMA_LIFCR_CDMEIF2                    ((uint32_t)0x00040000)
S#define DMA_LIFCR_CFEIF2                     ((uint32_t)0x00010000)
S#define DMA_LIFCR_CTCIF1                     ((uint32_t)0x00000800)
S#define DMA_LIFCR_CHTIF1                     ((uint32_t)0x00000400)
S#define DMA_LIFCR_CTEIF1                     ((uint32_t)0x00000200)
S#define DMA_LIFCR_CDMEIF1                    ((uint32_t)0x00000100)
S#define DMA_LIFCR_CFEIF1                     ((uint32_t)0x00000040)
S#define DMA_LIFCR_CTCIF0                     ((uint32_t)0x00000020)
S#define DMA_LIFCR_CHTIF0                     ((uint32_t)0x00000010)
S#define DMA_LIFCR_CTEIF0                     ((uint32_t)0x00000008)
S#define DMA_LIFCR_CDMEIF0                    ((uint32_t)0x00000004)
S#define DMA_LIFCR_CFEIF0                     ((uint32_t)0x00000001)
S
S/********************  Bits definition for DMA_HIFCR  register  ****************/ 
S#define DMA_HIFCR_CTCIF7                     ((uint32_t)0x08000000)
S#define DMA_HIFCR_CHTIF7                     ((uint32_t)0x04000000)
S#define DMA_HIFCR_CTEIF7                     ((uint32_t)0x02000000)
S#define DMA_HIFCR_CDMEIF7                    ((uint32_t)0x01000000)
S#define DMA_HIFCR_CFEIF7                     ((uint32_t)0x00400000)
S#define DMA_HIFCR_CTCIF6                     ((uint32_t)0x00200000)
S#define DMA_HIFCR_CHTIF6                     ((uint32_t)0x00100000)
S#define DMA_HIFCR_CTEIF6                     ((uint32_t)0x00080000)
S#define DMA_HIFCR_CDMEIF6                    ((uint32_t)0x00040000)
S#define DMA_HIFCR_CFEIF6                     ((uint32_t)0x00010000)
S#define DMA_HIFCR_CTCIF5                     ((uint32_t)0x00000800)
S#define DMA_HIFCR_CHTIF5                     ((uint32_t)0x00000400)
S#define DMA_HIFCR_CTEIF5                     ((uint32_t)0x00000200)
S#define DMA_HIFCR_CDMEIF5                    ((uint32_t)0x00000100)
S#define DMA_HIFCR_CFEIF5                     ((uint32_t)0x00000040)
S#define DMA_HIFCR_CTCIF4                     ((uint32_t)0x00000020)
S#define DMA_HIFCR_CHTIF4                     ((uint32_t)0x00000010)
S#define DMA_HIFCR_CTEIF4                     ((uint32_t)0x00000008)
S#define DMA_HIFCR_CDMEIF4                    ((uint32_t)0x00000004)
S#define DMA_HIFCR_CFEIF4                     ((uint32_t)0x00000001)
S
S/******************************************************************************/
S/*                                                                            */
S/*                         AHB Master DMA2D Controller (DMA2D)                */
S/*                                                                            */
S/******************************************************************************/
S
S/********************  Bit definition for DMA2D_CR register  ******************/
S
S#define DMA2D_CR_START                     ((uint32_t)0x00000001)               /*!< Start transfer */
S#define DMA2D_CR_SUSP                      ((uint32_t)0x00000002)               /*!< Suspend transfer */
S#define DMA2D_CR_ABORT                     ((uint32_t)0x00000004)               /*!< Abort transfer */
S#define DMA2D_CR_TEIE                      ((uint32_t)0x00000100)               /*!< Transfer Error Interrupt Enable */
S#define DMA2D_CR_TCIE                      ((uint32_t)0x00000200)               /*!< Transfer Complete Interrupt Enable */
S#define DMA2D_CR_TWIE                      ((uint32_t)0x00000400)               /*!< Transfer Watermark Interrupt Enable */
S#define DMA2D_CR_CAEIE                     ((uint32_t)0x00000800)               /*!< CLUT Access Error Interrupt Enable */
S#define DMA2D_CR_CTCIE                     ((uint32_t)0x00001000)               /*!< CLUT Transfer Complete Interrupt Enable */
S#define DMA2D_CR_CEIE                      ((uint32_t)0x00002000)               /*!< Configuration Error Interrupt Enable */
S#define DMA2D_CR_MODE                      ((uint32_t)0x00030000)               /*!< DMA2D Mode */
S
S/********************  Bit definition for DMA2D_ISR register  *****************/
S
S#define DMA2D_ISR_TEIF                     ((uint32_t)0x00000001)               /*!< Transfer Error Interrupt Flag */
S#define DMA2D_ISR_TCIF                     ((uint32_t)0x00000002)               /*!< Transfer Complete Interrupt Flag */
S#define DMA2D_ISR_TWIF                     ((uint32_t)0x00000004)               /*!< Transfer Watermark Interrupt Flag */
S#define DMA2D_ISR_CAEIF                    ((uint32_t)0x00000008)               /*!< CLUT Access Error Interrupt Flag */
S#define DMA2D_ISR_CTCIF                    ((uint32_t)0x00000010)               /*!< CLUT Transfer Complete Interrupt Flag */
S#define DMA2D_ISR_CEIF                     ((uint32_t)0x00000020)               /*!< Configuration Error Interrupt Flag */
S
S/********************  Bit definition for DMA2D_IFCR register  ****************/
S
S#define DMA2D_IFCR_CTEIF                   ((uint32_t)0x00000001)               /*!< Clears Transfer Error Interrupt Flag         */
S#define DMA2D_IFCR_CTCIF                   ((uint32_t)0x00000002)               /*!< Clears Transfer Complete Interrupt Flag      */
S#define DMA2D_IFCR_CTWIF                   ((uint32_t)0x00000004)               /*!< Clears Transfer Watermark Interrupt Flag     */
S#define DMA2D_IFCR_CAECIF                  ((uint32_t)0x00000008)               /*!< Clears CLUT Access Error Interrupt Flag      */
S#define DMA2D_IFCR_CCTCIF                  ((uint32_t)0x00000010)               /*!< Clears CLUT Transfer Complete Interrupt Flag */
S#define DMA2D_IFCR_CCEIF                   ((uint32_t)0x00000020)               /*!< Clears Configuration Error Interrupt Flag    */
S
S/* Legacy defines */
S#define DMA2D_IFSR_CTEIF                   DMA2D_IFCR_CTEIF                     /*!< Clears Transfer Error Interrupt Flag         */
S#define DMA2D_IFSR_CTCIF                   DMA2D_IFCR_CTCIF                     /*!< Clears Transfer Complete Interrupt Flag      */
S#define DMA2D_IFSR_CTWIF                   DMA2D_IFCR_CTWIF                     /*!< Clears Transfer Watermark Interrupt Flag     */
S#define DMA2D_IFSR_CCAEIF                  DMA2D_IFCR_CAECIF                    /*!< Clears CLUT Access Error Interrupt Flag      */
S#define DMA2D_IFSR_CCTCIF                  DMA2D_IFCR_CCTCIF                    /*!< Clears CLUT Transfer Complete Interrupt Flag */
S#define DMA2D_IFSR_CCEIF                   DMA2D_IFCR_CCEIF                     /*!< Clears Configuration Error Interrupt Flag    */
S
S/********************  Bit definition for DMA2D_FGMAR register  ***************/
S
S#define DMA2D_FGMAR_MA                     ((uint32_t)0xFFFFFFFF)               /*!< Memory Address */
S
S/********************  Bit definition for DMA2D_FGOR register  ****************/
S
S#define DMA2D_FGOR_LO                      ((uint32_t)0x00003FFF)               /*!< Line Offset */
S
S/********************  Bit definition for DMA2D_BGMAR register  ***************/
S
S#define DMA2D_BGMAR_MA                     ((uint32_t)0xFFFFFFFF)               /*!< Memory Address */
S
S/********************  Bit definition for DMA2D_BGOR register  ****************/
S
S#define DMA2D_BGOR_LO                      ((uint32_t)0x00003FFF)               /*!< Line Offset */
S
S/********************  Bit definition for DMA2D_FGPFCCR register  *************/
S
S#define DMA2D_FGPFCCR_CM                   ((uint32_t)0x0000000F)               /*!< Input color mode CM[3:0] */
S#define DMA2D_FGPFCCR_CM_0                 ((uint32_t)0x00000001)               /*!< Input color mode CM bit 0 */
S#define DMA2D_FGPFCCR_CM_1                 ((uint32_t)0x00000002)               /*!< Input color mode CM bit 1 */
S#define DMA2D_FGPFCCR_CM_2                 ((uint32_t)0x00000004)               /*!< Input color mode CM bit 2 */
S#define DMA2D_FGPFCCR_CM_3                 ((uint32_t)0x00000008)               /*!< Input color mode CM bit 3 */
S#define DMA2D_FGPFCCR_CCM                  ((uint32_t)0x00000010)               /*!< CLUT Color mode */
S#define DMA2D_FGPFCCR_START                ((uint32_t)0x00000020)               /*!< Start */
S#define DMA2D_FGPFCCR_CS                   ((uint32_t)0x0000FF00)               /*!< CLUT size */
S#define DMA2D_FGPFCCR_AM                   ((uint32_t)0x00030000)               /*!< Alpha mode AM[1:0] */
S#define DMA2D_FGPFCCR_AM_0                 ((uint32_t)0x00010000)               /*!< Alpha mode AM bit 0 */
S#define DMA2D_FGPFCCR_AM_1                 ((uint32_t)0x00020000)               /*!< Alpha mode AM bit 1 */
S#define DMA2D_FGPFCCR_ALPHA                ((uint32_t)0xFF000000)               /*!< Alpha value */
S
S/********************  Bit definition for DMA2D_FGCOLR register  **************/
S
S#define DMA2D_FGCOLR_BLUE                  ((uint32_t)0x000000FF)               /*!< Blue Value */
S#define DMA2D_FGCOLR_GREEN                 ((uint32_t)0x0000FF00)               /*!< Green Value */
S#define DMA2D_FGCOLR_RED                   ((uint32_t)0x00FF0000)               /*!< Red Value */   
S
S/********************  Bit definition for DMA2D_BGPFCCR register  *************/
S
S#define DMA2D_BGPFCCR_CM                   ((uint32_t)0x0000000F)               /*!< Input color mode CM[3:0] */
S#define DMA2D_BGPFCCR_CM_0                 ((uint32_t)0x00000001)               /*!< Input color mode CM bit 0 */
S#define DMA2D_BGPFCCR_CM_1                 ((uint32_t)0x00000002)               /*!< Input color mode CM bit 1 */
S#define DMA2D_BGPFCCR_CM_2                 ((uint32_t)0x00000004)               /*!< Input color mode CM bit 2 */
S#define DMA2D_FGPFCCR_CM_3                 ((uint32_t)0x00000008)               /*!< Input color mode CM bit 3 */
S#define DMA2D_BGPFCCR_CCM                  ((uint32_t)0x00000010)               /*!< CLUT Color mode */
S#define DMA2D_BGPFCCR_START                ((uint32_t)0x00000020)               /*!< Start */
S#define DMA2D_BGPFCCR_CS                   ((uint32_t)0x0000FF00)               /*!< CLUT size */
S#define DMA2D_BGPFCCR_AM                   ((uint32_t)0x00030000)               /*!< Alpha mode AM[1:0] */
S#define DMA2D_BGPFCCR_AM_0                 ((uint32_t)0x00010000)               /*!< Alpha mode AM bit 0 */
S#define DMA2D_BGPFCCR_AM_1                 ((uint32_t)0x00020000)               /*!< Alpha mode AM bit 1 */
S#define DMA2D_BGPFCCR_ALPHA                ((uint32_t)0xFF000000)               /*!< Alpha value */
S
S/********************  Bit definition for DMA2D_BGCOLR register  **************/
S
S#define DMA2D_BGCOLR_BLUE                  ((uint32_t)0x000000FF)               /*!< Blue Value */
S#define DMA2D_BGCOLR_GREEN                 ((uint32_t)0x0000FF00)               /*!< Green Value */
S#define DMA2D_BGCOLR_RED                   ((uint32_t)0x00FF0000)               /*!< Red Value */
S
S/********************  Bit definition for DMA2D_FGCMAR register  **************/
S
S#define DMA2D_FGCMAR_MA                    ((uint32_t)0xFFFFFFFF)               /*!< Memory Address */
S
S/********************  Bit definition for DMA2D_BGCMAR register  **************/
S
S#define DMA2D_BGCMAR_MA                    ((uint32_t)0xFFFFFFFF)               /*!< Memory Address */
S
S/********************  Bit definition for DMA2D_OPFCCR register  **************/
S
S#define DMA2D_OPFCCR_CM                    ((uint32_t)0x00000007)               /*!< Color mode CM[2:0] */
S#define DMA2D_OPFCCR_CM_0                  ((uint32_t)0x00000001)               /*!< Color mode CM bit 0 */
S#define DMA2D_OPFCCR_CM_1                  ((uint32_t)0x00000002)               /*!< Color mode CM bit 1 */
S#define DMA2D_OPFCCR_CM_2                  ((uint32_t)0x00000004)               /*!< Color mode CM bit 2 */
S
S/********************  Bit definition for DMA2D_OCOLR register  ***************/
S
S/*!<Mode_ARGB8888/RGB888 */
S
S#define DMA2D_OCOLR_BLUE_1                 ((uint32_t)0x000000FF)               /*!< BLUE Value */
S#define DMA2D_OCOLR_GREEN_1                ((uint32_t)0x0000FF00)               /*!< GREEN Value  */
S#define DMA2D_OCOLR_RED_1                  ((uint32_t)0x00FF0000)               /*!< Red Value */
S#define DMA2D_OCOLR_ALPHA_1                ((uint32_t)0xFF000000)               /*!< Alpha Channel Value */
S
S/*!<Mode_RGB565 */
S#define DMA2D_OCOLR_BLUE_2                 ((uint32_t)0x0000001F)               /*!< BLUE Value */
S#define DMA2D_OCOLR_GREEN_2                ((uint32_t)0x000007E0)               /*!< GREEN Value  */
S#define DMA2D_OCOLR_RED_2                  ((uint32_t)0x0000F800)               /*!< Red Value */
S
S/*!<Mode_ARGB1555 */
S#define DMA2D_OCOLR_BLUE_3                 ((uint32_t)0x0000001F)               /*!< BLUE Value */
S#define DMA2D_OCOLR_GREEN_3                ((uint32_t)0x000003E0)               /*!< GREEN Value  */
S#define DMA2D_OCOLR_RED_3                  ((uint32_t)0x00007C00)               /*!< Red Value */
S#define DMA2D_OCOLR_ALPHA_3                ((uint32_t)0x00008000)               /*!< Alpha Channel Value */
S
S/*!<Mode_ARGB4444 */
S#define DMA2D_OCOLR_BLUE_4                 ((uint32_t)0x0000000F)               /*!< BLUE Value */
S#define DMA2D_OCOLR_GREEN_4                ((uint32_t)0x000000F0)               /*!< GREEN Value  */
S#define DMA2D_OCOLR_RED_4                  ((uint32_t)0x00000F00)               /*!< Red Value */
S#define DMA2D_OCOLR_ALPHA_4                ((uint32_t)0x0000F000)               /*!< Alpha Channel Value */
S
S/********************  Bit definition for DMA2D_OMAR register  ****************/
S
S#define DMA2D_OMAR_MA                      ((uint32_t)0xFFFFFFFF)               /*!< Memory Address */
S
S/********************  Bit definition for DMA2D_OOR register  *****************/
S
S#define DMA2D_OOR_LO                       ((uint32_t)0x00003FFF)               /*!< Line Offset */
S
S/********************  Bit definition for DMA2D_NLR register  *****************/
S
S#define DMA2D_NLR_NL                       ((uint32_t)0x0000FFFF)               /*!< Number of Lines */
S#define DMA2D_NLR_PL                       ((uint32_t)0x3FFF0000)               /*!< Pixel per Lines */
S
S/********************  Bit definition for DMA2D_LWR register  *****************/
S
S#define DMA2D_LWR_LW                       ((uint32_t)0x0000FFFF)               /*!< Line Watermark */
S
S/********************  Bit definition for DMA2D_AMTCR register  ***************/
S
S#define DMA2D_AMTCR_EN                     ((uint32_t)0x00000001)               /*!< Enable */
S#define DMA2D_AMTCR_DT                     ((uint32_t)0x0000FF00)               /*!< Dead Time */
S
S
S
S/********************  Bit definition for DMA2D_FGCLUT register  **************/
S                                                                     
S/********************  Bit definition for DMA2D_BGCLUT register  **************/
S
S
S/******************************************************************************/
S/*                                                                            */
S/*                    External Interrupt/Event Controller                     */
S/*                                                                            */
S/******************************************************************************/
S/*******************  Bit definition for EXTI_IMR register  *******************/
S#define  EXTI_IMR_MR0                        ((uint32_t)0x00000001)        /*!< Interrupt Mask on line 0 */
S#define  EXTI_IMR_MR1                        ((uint32_t)0x00000002)        /*!< Interrupt Mask on line 1 */
S#define  EXTI_IMR_MR2                        ((uint32_t)0x00000004)        /*!< Interrupt Mask on line 2 */
S#define  EXTI_IMR_MR3                        ((uint32_t)0x00000008)        /*!< Interrupt Mask on line 3 */
S#define  EXTI_IMR_MR4                        ((uint32_t)0x00000010)        /*!< Interrupt Mask on line 4 */
S#define  EXTI_IMR_MR5                        ((uint32_t)0x00000020)        /*!< Interrupt Mask on line 5 */
S#define  EXTI_IMR_MR6                        ((uint32_t)0x00000040)        /*!< Interrupt Mask on line 6 */
S#define  EXTI_IMR_MR7                        ((uint32_t)0x00000080)        /*!< Interrupt Mask on line 7 */
S#define  EXTI_IMR_MR8                        ((uint32_t)0x00000100)        /*!< Interrupt Mask on line 8 */
S#define  EXTI_IMR_MR9                        ((uint32_t)0x00000200)        /*!< Interrupt Mask on line 9 */
S#define  EXTI_IMR_MR10                       ((uint32_t)0x00000400)        /*!< Interrupt Mask on line 10 */
S#define  EXTI_IMR_MR11                       ((uint32_t)0x00000800)        /*!< Interrupt Mask on line 11 */
S#define  EXTI_IMR_MR12                       ((uint32_t)0x00001000)        /*!< Interrupt Mask on line 12 */
S#define  EXTI_IMR_MR13                       ((uint32_t)0x00002000)        /*!< Interrupt Mask on line 13 */
S#define  EXTI_IMR_MR14                       ((uint32_t)0x00004000)        /*!< Interrupt Mask on line 14 */
S#define  EXTI_IMR_MR15                       ((uint32_t)0x00008000)        /*!< Interrupt Mask on line 15 */
S#define  EXTI_IMR_MR16                       ((uint32_t)0x00010000)        /*!< Interrupt Mask on line 16 */
S#define  EXTI_IMR_MR17                       ((uint32_t)0x00020000)        /*!< Interrupt Mask on line 17 */
S#define  EXTI_IMR_MR18                       ((uint32_t)0x00040000)        /*!< Interrupt Mask on line 18 */
S#define  EXTI_IMR_MR19                       ((uint32_t)0x00080000)        /*!< Interrupt Mask on line 19 */
S#define  EXTI_IMR_MR23                       ((uint32_t)0x00800000)        /*!< Interrupt Mask on line 23 */
S
S/*******************  Bit definition for EXTI_EMR register  *******************/
S#define  EXTI_EMR_MR0                        ((uint32_t)0x00000001)        /*!< Event Mask on line 0 */
S#define  EXTI_EMR_MR1                        ((uint32_t)0x00000002)        /*!< Event Mask on line 1 */
S#define  EXTI_EMR_MR2                        ((uint32_t)0x00000004)        /*!< Event Mask on line 2 */
S#define  EXTI_EMR_MR3                        ((uint32_t)0x00000008)        /*!< Event Mask on line 3 */
S#define  EXTI_EMR_MR4                        ((uint32_t)0x00000010)        /*!< Event Mask on line 4 */
S#define  EXTI_EMR_MR5                        ((uint32_t)0x00000020)        /*!< Event Mask on line 5 */
S#define  EXTI_EMR_MR6                        ((uint32_t)0x00000040)        /*!< Event Mask on line 6 */
S#define  EXTI_EMR_MR7                        ((uint32_t)0x00000080)        /*!< Event Mask on line 7 */
S#define  EXTI_EMR_MR8                        ((uint32_t)0x00000100)        /*!< Event Mask on line 8 */
S#define  EXTI_EMR_MR9                        ((uint32_t)0x00000200)        /*!< Event Mask on line 9 */
S#define  EXTI_EMR_MR10                       ((uint32_t)0x00000400)        /*!< Event Mask on line 10 */
S#define  EXTI_EMR_MR11                       ((uint32_t)0x00000800)        /*!< Event Mask on line 11 */
S#define  EXTI_EMR_MR12                       ((uint32_t)0x00001000)        /*!< Event Mask on line 12 */
S#define  EXTI_EMR_MR13                       ((uint32_t)0x00002000)        /*!< Event Mask on line 13 */
S#define  EXTI_EMR_MR14                       ((uint32_t)0x00004000)        /*!< Event Mask on line 14 */
S#define  EXTI_EMR_MR15                       ((uint32_t)0x00008000)        /*!< Event Mask on line 15 */
S#define  EXTI_EMR_MR16                       ((uint32_t)0x00010000)        /*!< Event Mask on line 16 */
S#define  EXTI_EMR_MR17                       ((uint32_t)0x00020000)        /*!< Event Mask on line 17 */
S#define  EXTI_EMR_MR18                       ((uint32_t)0x00040000)        /*!< Event Mask on line 18 */
S#define  EXTI_EMR_MR19                       ((uint32_t)0x00080000)        /*!< Event Mask on line 19 */
S#define  EXTI_EMR_MR23                       ((uint32_t)0x00800000)        /*!< Event Mask on line 19 */
S
S/******************  Bit definition for EXTI_RTSR register  *******************/
S#define  EXTI_RTSR_TR0                       ((uint32_t)0x00000001)        /*!< Rising trigger event configuration bit of line 0 */
S#define  EXTI_RTSR_TR1                       ((uint32_t)0x00000002)        /*!< Rising trigger event configuration bit of line 1 */
S#define  EXTI_RTSR_TR2                       ((uint32_t)0x00000004)        /*!< Rising trigger event configuration bit of line 2 */
S#define  EXTI_RTSR_TR3                       ((uint32_t)0x00000008)        /*!< Rising trigger event configuration bit of line 3 */
S#define  EXTI_RTSR_TR4                       ((uint32_t)0x00000010)        /*!< Rising trigger event configuration bit of line 4 */
S#define  EXTI_RTSR_TR5                       ((uint32_t)0x00000020)        /*!< Rising trigger event configuration bit of line 5 */
S#define  EXTI_RTSR_TR6                       ((uint32_t)0x00000040)        /*!< Rising trigger event configuration bit of line 6 */
S#define  EXTI_RTSR_TR7                       ((uint32_t)0x00000080)        /*!< Rising trigger event configuration bit of line 7 */
S#define  EXTI_RTSR_TR8                       ((uint32_t)0x00000100)        /*!< Rising trigger event configuration bit of line 8 */
S#define  EXTI_RTSR_TR9                       ((uint32_t)0x00000200)        /*!< Rising trigger event configuration bit of line 9 */
S#define  EXTI_RTSR_TR10                      ((uint32_t)0x00000400)        /*!< Rising trigger event configuration bit of line 10 */
S#define  EXTI_RTSR_TR11                      ((uint32_t)0x00000800)        /*!< Rising trigger event configuration bit of line 11 */
S#define  EXTI_RTSR_TR12                      ((uint32_t)0x00001000)        /*!< Rising trigger event configuration bit of line 12 */
S#define  EXTI_RTSR_TR13                      ((uint32_t)0x00002000)        /*!< Rising trigger event configuration bit of line 13 */
S#define  EXTI_RTSR_TR14                      ((uint32_t)0x00004000)        /*!< Rising trigger event configuration bit of line 14 */
S#define  EXTI_RTSR_TR15                      ((uint32_t)0x00008000)        /*!< Rising trigger event configuration bit of line 15 */
S#define  EXTI_RTSR_TR16                      ((uint32_t)0x00010000)        /*!< Rising trigger event configuration bit of line 16 */
S#define  EXTI_RTSR_TR17                      ((uint32_t)0x00020000)        /*!< Rising trigger event configuration bit of line 17 */
S#define  EXTI_RTSR_TR18                      ((uint32_t)0x00040000)        /*!< Rising trigger event configuration bit of line 18 */
S#define  EXTI_RTSR_TR19                      ((uint32_t)0x00080000)        /*!< Rising trigger event configuration bit of line 19 */
S#define  EXTI_RTSR_TR23                      ((uint32_t)0x00800000)        /*!< Rising trigger event configuration bit of line 23 */
S
S/******************  Bit definition for EXTI_FTSR register  *******************/
S#define  EXTI_FTSR_TR0                       ((uint32_t)0x00000001)        /*!< Falling trigger event configuration bit of line 0 */
S#define  EXTI_FTSR_TR1                       ((uint32_t)0x00000002)        /*!< Falling trigger event configuration bit of line 1 */
S#define  EXTI_FTSR_TR2                       ((uint32_t)0x00000004)        /*!< Falling trigger event configuration bit of line 2 */
S#define  EXTI_FTSR_TR3                       ((uint32_t)0x00000008)        /*!< Falling trigger event configuration bit of line 3 */
S#define  EXTI_FTSR_TR4                       ((uint32_t)0x00000010)        /*!< Falling trigger event configuration bit of line 4 */
S#define  EXTI_FTSR_TR5                       ((uint32_t)0x00000020)        /*!< Falling trigger event configuration bit of line 5 */
S#define  EXTI_FTSR_TR6                       ((uint32_t)0x00000040)        /*!< Falling trigger event configuration bit of line 6 */
S#define  EXTI_FTSR_TR7                       ((uint32_t)0x00000080)        /*!< Falling trigger event configuration bit of line 7 */
S#define  EXTI_FTSR_TR8                       ((uint32_t)0x00000100)        /*!< Falling trigger event configuration bit of line 8 */
S#define  EXTI_FTSR_TR9                       ((uint32_t)0x00000200)        /*!< Falling trigger event configuration bit of line 9 */
S#define  EXTI_FTSR_TR10                      ((uint32_t)0x00000400)        /*!< Falling trigger event configuration bit of line 10 */
S#define  EXTI_FTSR_TR11                      ((uint32_t)0x00000800)        /*!< Falling trigger event configuration bit of line 11 */
S#define  EXTI_FTSR_TR12                      ((uint32_t)0x00001000)        /*!< Falling trigger event configuration bit of line 12 */
S#define  EXTI_FTSR_TR13                      ((uint32_t)0x00002000)        /*!< Falling trigger event configuration bit of line 13 */
S#define  EXTI_FTSR_TR14                      ((uint32_t)0x00004000)        /*!< Falling trigger event configuration bit of line 14 */
S#define  EXTI_FTSR_TR15                      ((uint32_t)0x00008000)        /*!< Falling trigger event configuration bit of line 15 */
S#define  EXTI_FTSR_TR16                      ((uint32_t)0x00010000)        /*!< Falling trigger event configuration bit of line 16 */
S#define  EXTI_FTSR_TR17                      ((uint32_t)0x00020000)        /*!< Falling trigger event configuration bit of line 17 */
S#define  EXTI_FTSR_TR18                      ((uint32_t)0x00040000)        /*!< Falling trigger event configuration bit of line 18 */
S#define  EXTI_FTSR_TR19                      ((uint32_t)0x00080000)        /*!< Falling trigger event configuration bit of line 19 */
S#define  EXTI_FTSR_TR23                      ((uint32_t)0x00800000)        /*!< Falling trigger event configuration bit of line 23 */
S
S/******************  Bit definition for EXTI_SWIER register  ******************/
S#define  EXTI_SWIER_SWIER0                   ((uint32_t)0x00000001)        /*!< Software Interrupt on line 0 */
S#define  EXTI_SWIER_SWIER1                   ((uint32_t)0x00000002)        /*!< Software Interrupt on line 1 */
S#define  EXTI_SWIER_SWIER2                   ((uint32_t)0x00000004)        /*!< Software Interrupt on line 2 */
S#define  EXTI_SWIER_SWIER3                   ((uint32_t)0x00000008)        /*!< Software Interrupt on line 3 */
S#define  EXTI_SWIER_SWIER4                   ((uint32_t)0x00000010)        /*!< Software Interrupt on line 4 */
S#define  EXTI_SWIER_SWIER5                   ((uint32_t)0x00000020)        /*!< Software Interrupt on line 5 */
S#define  EXTI_SWIER_SWIER6                   ((uint32_t)0x00000040)        /*!< Software Interrupt on line 6 */
S#define  EXTI_SWIER_SWIER7                   ((uint32_t)0x00000080)        /*!< Software Interrupt on line 7 */
S#define  EXTI_SWIER_SWIER8                   ((uint32_t)0x00000100)        /*!< Software Interrupt on line 8 */
S#define  EXTI_SWIER_SWIER9                   ((uint32_t)0x00000200)        /*!< Software Interrupt on line 9 */
S#define  EXTI_SWIER_SWIER10                  ((uint32_t)0x00000400)        /*!< Software Interrupt on line 10 */
S#define  EXTI_SWIER_SWIER11                  ((uint32_t)0x00000800)        /*!< Software Interrupt on line 11 */
S#define  EXTI_SWIER_SWIER12                  ((uint32_t)0x00001000)        /*!< Software Interrupt on line 12 */
S#define  EXTI_SWIER_SWIER13                  ((uint32_t)0x00002000)        /*!< Software Interrupt on line 13 */
S#define  EXTI_SWIER_SWIER14                  ((uint32_t)0x00004000)        /*!< Software Interrupt on line 14 */
S#define  EXTI_SWIER_SWIER15                  ((uint32_t)0x00008000)        /*!< Software Interrupt on line 15 */
S#define  EXTI_SWIER_SWIER16                  ((uint32_t)0x00010000)        /*!< Software Interrupt on line 16 */
S#define  EXTI_SWIER_SWIER17                  ((uint32_t)0x00020000)        /*!< Software Interrupt on line 17 */
S#define  EXTI_SWIER_SWIER18                  ((uint32_t)0x00040000)        /*!< Software Interrupt on line 18 */
S#define  EXTI_SWIER_SWIER19                  ((uint32_t)0x00080000)        /*!< Software Interrupt on line 19 */
S#define  EXTI_SWIER_SWIER23                  ((uint32_t)0x00800000)        /*!< Software Interrupt on line 23 */
S
S/*******************  Bit definition for EXTI_PR register  ********************/
S#define  EXTI_PR_PR0                         ((uint32_t)0x00000001)        /*!< Pending bit for line 0 */
S#define  EXTI_PR_PR1                         ((uint32_t)0x00000002)        /*!< Pending bit for line 1 */
S#define  EXTI_PR_PR2                         ((uint32_t)0x00000004)        /*!< Pending bit for line 2 */
S#define  EXTI_PR_PR3                         ((uint32_t)0x00000008)        /*!< Pending bit for line 3 */
S#define  EXTI_PR_PR4                         ((uint32_t)0x00000010)        /*!< Pending bit for line 4 */
S#define  EXTI_PR_PR5                         ((uint32_t)0x00000020)        /*!< Pending bit for line 5 */
S#define  EXTI_PR_PR6                         ((uint32_t)0x00000040)        /*!< Pending bit for line 6 */
S#define  EXTI_PR_PR7                         ((uint32_t)0x00000080)        /*!< Pending bit for line 7 */
S#define  EXTI_PR_PR8                         ((uint32_t)0x00000100)        /*!< Pending bit for line 8 */
S#define  EXTI_PR_PR9                         ((uint32_t)0x00000200)        /*!< Pending bit for line 9 */
S#define  EXTI_PR_PR10                        ((uint32_t)0x00000400)        /*!< Pending bit for line 10 */
S#define  EXTI_PR_PR11                        ((uint32_t)0x00000800)        /*!< Pending bit for line 11 */
S#define  EXTI_PR_PR12                        ((uint32_t)0x00001000)        /*!< Pending bit for line 12 */
S#define  EXTI_PR_PR13                        ((uint32_t)0x00002000)        /*!< Pending bit for line 13 */
S#define  EXTI_PR_PR14                        ((uint32_t)0x00004000)        /*!< Pending bit for line 14 */
S#define  EXTI_PR_PR15                        ((uint32_t)0x00008000)        /*!< Pending bit for line 15 */
S#define  EXTI_PR_PR16                        ((uint32_t)0x00010000)        /*!< Pending bit for line 16 */
S#define  EXTI_PR_PR17                        ((uint32_t)0x00020000)        /*!< Pending bit for line 17 */
S#define  EXTI_PR_PR18                        ((uint32_t)0x00040000)        /*!< Pending bit for line 18 */
S#define  EXTI_PR_PR19                        ((uint32_t)0x00080000)        /*!< Pending bit for line 19 */
S#define  EXTI_PR_PR23                        ((uint32_t)0x00800000)        /*!< Pending bit for line 23 */
S
S/******************************************************************************/
S/*                                                                            */
S/*                                    FLASH                                   */
S/*                                                                            */
S/******************************************************************************/
S/*******************  Bits definition for FLASH_ACR register  *****************/
S#define FLASH_ACR_LATENCY                    ((uint32_t)0x0000000F)
S#define FLASH_ACR_LATENCY_0WS                ((uint32_t)0x00000000)
S#define FLASH_ACR_LATENCY_1WS                ((uint32_t)0x00000001)
S#define FLASH_ACR_LATENCY_2WS                ((uint32_t)0x00000002)
S#define FLASH_ACR_LATENCY_3WS                ((uint32_t)0x00000003)
S#define FLASH_ACR_LATENCY_4WS                ((uint32_t)0x00000004)
S#define FLASH_ACR_LATENCY_5WS                ((uint32_t)0x00000005)
S#define FLASH_ACR_LATENCY_6WS                ((uint32_t)0x00000006)
S#define FLASH_ACR_LATENCY_7WS                ((uint32_t)0x00000007)
S#define FLASH_ACR_LATENCY_8WS                ((uint32_t)0x00000008)
S#define FLASH_ACR_LATENCY_9WS                ((uint32_t)0x00000009)
S#define FLASH_ACR_LATENCY_10WS               ((uint32_t)0x0000000A)
S#define FLASH_ACR_LATENCY_11WS               ((uint32_t)0x0000000B)
S#define FLASH_ACR_LATENCY_12WS               ((uint32_t)0x0000000C)
S#define FLASH_ACR_LATENCY_13WS               ((uint32_t)0x0000000D)
S#define FLASH_ACR_LATENCY_14WS               ((uint32_t)0x0000000E)
S#define FLASH_ACR_LATENCY_15WS               ((uint32_t)0x0000000F)
S
S#define FLASH_ACR_PRFTEN                     ((uint32_t)0x00000100)
S#define FLASH_ACR_ICEN                       ((uint32_t)0x00000200)
S#define FLASH_ACR_DCEN                       ((uint32_t)0x00000400)
S#define FLASH_ACR_ICRST                      ((uint32_t)0x00000800)
S#define FLASH_ACR_DCRST                      ((uint32_t)0x00001000)
S#define FLASH_ACR_BYTE0_ADDRESS              ((uint32_t)0x40023C00)
S#define FLASH_ACR_BYTE2_ADDRESS              ((uint32_t)0x40023C03)
S
S/*******************  Bits definition for FLASH_SR register  ******************/
S#define FLASH_SR_EOP                         ((uint32_t)0x00000001)
S#define FLASH_SR_SOP                         ((uint32_t)0x00000002)
S#define FLASH_SR_WRPERR                      ((uint32_t)0x00000010)
S#define FLASH_SR_PGAERR                      ((uint32_t)0x00000020)
S#define FLASH_SR_PGPERR                      ((uint32_t)0x00000040)
S#define FLASH_SR_PGSERR                      ((uint32_t)0x00000080)
S#define FLASH_SR_BSY                         ((uint32_t)0x00010000)
S
S/*******************  Bits definition for FLASH_CR register  ******************/
S#define FLASH_CR_PG                          ((uint32_t)0x00000001)
S#define FLASH_CR_SER                         ((uint32_t)0x00000002)
S#define FLASH_CR_MER                         ((uint32_t)0x00000004)
S#define FLASH_CR_MER1                        FLASH_CR_MER
S#define FLASH_CR_SNB                         ((uint32_t)0x000000F8)
S#define FLASH_CR_SNB_0                       ((uint32_t)0x00000008)
S#define FLASH_CR_SNB_1                       ((uint32_t)0x00000010)
S#define FLASH_CR_SNB_2                       ((uint32_t)0x00000020)
S#define FLASH_CR_SNB_3                       ((uint32_t)0x00000040)
S#define FLASH_CR_SNB_4                       ((uint32_t)0x00000040)
S#define FLASH_CR_PSIZE                       ((uint32_t)0x00000300)
S#define FLASH_CR_PSIZE_0                     ((uint32_t)0x00000100)
S#define FLASH_CR_PSIZE_1                     ((uint32_t)0x00000200)
S#define FLASH_CR_MER2                        ((uint32_t)0x00008000)
S#define FLASH_CR_STRT                        ((uint32_t)0x00010000)
S#define FLASH_CR_EOPIE                       ((uint32_t)0x01000000)
S#define FLASH_CR_LOCK                        ((uint32_t)0x80000000)
S
S/*******************  Bits definition for FLASH_OPTCR register  ***************/
S#define FLASH_OPTCR_OPTLOCK                 ((uint32_t)0x00000001)
S#define FLASH_OPTCR_OPTSTRT                 ((uint32_t)0x00000002)
S#define FLASH_OPTCR_BOR_LEV_0               ((uint32_t)0x00000004)
S#define FLASH_OPTCR_BOR_LEV_1               ((uint32_t)0x00000008)
S#define FLASH_OPTCR_BOR_LEV                 ((uint32_t)0x0000000C)
S#define FLASH_OPTCR_BFB2                    ((uint32_t)0x00000010)
S
S#define FLASH_OPTCR_WDG_SW                  ((uint32_t)0x00000020)
S#define FLASH_OPTCR_nRST_STOP               ((uint32_t)0x00000040)
S#define FLASH_OPTCR_nRST_STDBY              ((uint32_t)0x00000080)
S#define FLASH_OPTCR_RDP                     ((uint32_t)0x0000FF00)
S#define FLASH_OPTCR_RDP_0                   ((uint32_t)0x00000100)
S#define FLASH_OPTCR_RDP_1                   ((uint32_t)0x00000200)
S#define FLASH_OPTCR_RDP_2                   ((uint32_t)0x00000400)
S#define FLASH_OPTCR_RDP_3                   ((uint32_t)0x00000800)
S#define FLASH_OPTCR_RDP_4                   ((uint32_t)0x00001000)
S#define FLASH_OPTCR_RDP_5                   ((uint32_t)0x00002000)
S#define FLASH_OPTCR_RDP_6                   ((uint32_t)0x00004000)
S#define FLASH_OPTCR_RDP_7                   ((uint32_t)0x00008000)
S#define FLASH_OPTCR_nWRP                    ((uint32_t)0x0FFF0000)
S#define FLASH_OPTCR_nWRP_0                  ((uint32_t)0x00010000)
S#define FLASH_OPTCR_nWRP_1                  ((uint32_t)0x00020000)
S#define FLASH_OPTCR_nWRP_2                  ((uint32_t)0x00040000)
S#define FLASH_OPTCR_nWRP_3                  ((uint32_t)0x00080000)
S#define FLASH_OPTCR_nWRP_4                  ((uint32_t)0x00100000)
S#define FLASH_OPTCR_nWRP_5                  ((uint32_t)0x00200000)
S#define FLASH_OPTCR_nWRP_6                  ((uint32_t)0x00400000)
S#define FLASH_OPTCR_nWRP_7                  ((uint32_t)0x00800000)
S#define FLASH_OPTCR_nWRP_8                  ((uint32_t)0x01000000)
S#define FLASH_OPTCR_nWRP_9                  ((uint32_t)0x02000000)
S#define FLASH_OPTCR_nWRP_10                 ((uint32_t)0x04000000)
S#define FLASH_OPTCR_nWRP_11                 ((uint32_t)0x08000000)
S
S#define FLASH_OPTCR_DB1M                    ((uint32_t)0x40000000) 
S#define FLASH_OPTCR_SPRMOD                  ((uint32_t)0x80000000) 
S                                             
S/******************  Bits definition for FLASH_OPTCR1 register  ***************/
S#define FLASH_OPTCR1_nWRP                    ((uint32_t)0x0FFF0000)
S#define FLASH_OPTCR1_nWRP_0                  ((uint32_t)0x00010000)
S#define FLASH_OPTCR1_nWRP_1                  ((uint32_t)0x00020000)
S#define FLASH_OPTCR1_nWRP_2                  ((uint32_t)0x00040000)
S#define FLASH_OPTCR1_nWRP_3                  ((uint32_t)0x00080000)
S#define FLASH_OPTCR1_nWRP_4                  ((uint32_t)0x00100000)
S#define FLASH_OPTCR1_nWRP_5                  ((uint32_t)0x00200000)
S#define FLASH_OPTCR1_nWRP_6                  ((uint32_t)0x00400000)
S#define FLASH_OPTCR1_nWRP_7                  ((uint32_t)0x00800000)
S#define FLASH_OPTCR1_nWRP_8                  ((uint32_t)0x01000000)
S#define FLASH_OPTCR1_nWRP_9                  ((uint32_t)0x02000000)
S#define FLASH_OPTCR1_nWRP_10                 ((uint32_t)0x04000000)
S#define FLASH_OPTCR1_nWRP_11                 ((uint32_t)0x08000000)
S
S#if defined(STM32F40_41xxx) || defined(STM32F412xG) || defined(STM32F413_423xx)
S/******************************************************************************/
S/*                                                                            */
S/*                       Flexible Static Memory Controller                    */
S/*                                                                            */
S/******************************************************************************/
S/******************  Bit definition for FSMC_BCR1 register  *******************/
S#define  FSMC_BCR1_MBKEN                     ((uint32_t)0x00000001)        /*!<Memory bank enable bit                 */
S#define  FSMC_BCR1_MUXEN                     ((uint32_t)0x00000002)        /*!<Address/data multiplexing enable bit   */
S
S#define  FSMC_BCR1_MTYP                      ((uint32_t)0x0000000C)        /*!<MTYP[1:0] bits (Memory type)           */
S#define  FSMC_BCR1_MTYP_0                    ((uint32_t)0x00000004)        /*!<Bit 0 */
S#define  FSMC_BCR1_MTYP_1                    ((uint32_t)0x00000008)        /*!<Bit 1 */
S
S#define  FSMC_BCR1_MWID                      ((uint32_t)0x00000030)        /*!<MWID[1:0] bits (Memory data bus width) */
S#define  FSMC_BCR1_MWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FSMC_BCR1_MWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
S
S#define  FSMC_BCR1_FACCEN                    ((uint32_t)0x00000040)        /*!<Flash access enable                    */
S#define  FSMC_BCR1_BURSTEN                   ((uint32_t)0x00000100)        /*!<Burst enable bit                       */
S#define  FSMC_BCR1_WAITPOL                   ((uint32_t)0x00000200)        /*!<Wait signal polarity bit               */
S#define  FSMC_BCR1_WRAPMOD                   ((uint32_t)0x00000400)        /*!<Wrapped burst mode support             */
S#define  FSMC_BCR1_WAITCFG                   ((uint32_t)0x00000800)        /*!<Wait timing configuration              */
S#define  FSMC_BCR1_WREN                      ((uint32_t)0x00001000)        /*!<Write enable bit                       */
S#define  FSMC_BCR1_WAITEN                    ((uint32_t)0x00002000)        /*!<Wait enable bit                        */
S#define  FSMC_BCR1_EXTMOD                    ((uint32_t)0x00004000)        /*!<Extended mode enable                   */
S#define  FSMC_BCR1_ASYNCWAIT                 ((uint32_t)0x00008000)        /*!<Asynchronous wait                      */
S#define  FSMC_BCR1_CBURSTRW                  ((uint32_t)0x00080000)        /*!<Write burst enable                     */
S
S/******************  Bit definition for FSMC_BCR2 register  *******************/
S#define  FSMC_BCR2_MBKEN                     ((uint32_t)0x00000001)        /*!<Memory bank enable bit                */
S#define  FSMC_BCR2_MUXEN                     ((uint32_t)0x00000002)        /*!<Address/data multiplexing enable bit   */
S
S#define  FSMC_BCR2_MTYP                      ((uint32_t)0x0000000C)        /*!<MTYP[1:0] bits (Memory type)           */
S#define  FSMC_BCR2_MTYP_0                    ((uint32_t)0x00000004)        /*!<Bit 0 */
S#define  FSMC_BCR2_MTYP_1                    ((uint32_t)0x00000008)        /*!<Bit 1 */
S
S#define  FSMC_BCR2_MWID                      ((uint32_t)0x00000030)        /*!<MWID[1:0] bits (Memory data bus width) */
S#define  FSMC_BCR2_MWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FSMC_BCR2_MWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
S
S#define  FSMC_BCR2_FACCEN                    ((uint32_t)0x00000040)        /*!<Flash access enable                    */
S#define  FSMC_BCR2_BURSTEN                   ((uint32_t)0x00000100)        /*!<Burst enable bit                       */
S#define  FSMC_BCR2_WAITPOL                   ((uint32_t)0x00000200)        /*!<Wait signal polarity bit               */
S#define  FSMC_BCR2_WRAPMOD                   ((uint32_t)0x00000400)        /*!<Wrapped burst mode support             */
S#define  FSMC_BCR2_WAITCFG                   ((uint32_t)0x00000800)        /*!<Wait timing configuration              */
S#define  FSMC_BCR2_WREN                      ((uint32_t)0x00001000)        /*!<Write enable bit                       */
S#define  FSMC_BCR2_WAITEN                    ((uint32_t)0x00002000)        /*!<Wait enable bit                        */
S#define  FSMC_BCR2_EXTMOD                    ((uint32_t)0x00004000)        /*!<Extended mode enable                   */
S#define  FSMC_BCR2_ASYNCWAIT                 ((uint32_t)0x00008000)        /*!<Asynchronous wait                      */
S#define  FSMC_BCR2_CBURSTRW                  ((uint32_t)0x00080000)        /*!<Write burst enable                     */
S
S/******************  Bit definition for FSMC_BCR3 register  *******************/
S#define  FSMC_BCR3_MBKEN                     ((uint32_t)0x00000001)        /*!<Memory bank enable bit                 */
S#define  FSMC_BCR3_MUXEN                     ((uint32_t)0x00000002)        /*!<Address/data multiplexing enable bit   */
S
S#define  FSMC_BCR3_MTYP                      ((uint32_t)0x0000000C)        /*!<MTYP[1:0] bits (Memory type)           */
S#define  FSMC_BCR3_MTYP_0                    ((uint32_t)0x00000004)        /*!<Bit 0 */
S#define  FSMC_BCR3_MTYP_1                    ((uint32_t)0x00000008)        /*!<Bit 1 */
S
S#define  FSMC_BCR3_MWID                      ((uint32_t)0x00000030)        /*!<MWID[1:0] bits (Memory data bus width) */
S#define  FSMC_BCR3_MWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FSMC_BCR3_MWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
S
S#define  FSMC_BCR3_FACCEN                    ((uint32_t)0x00000040)        /*!<Flash access enable                    */
S#define  FSMC_BCR3_BURSTEN                   ((uint32_t)0x00000100)        /*!<Burst enable bit                       */
S#define  FSMC_BCR3_WAITPOL                   ((uint32_t)0x00000200)        /*!<Wait signal polarity bit               */
S#define  FSMC_BCR3_WRAPMOD                   ((uint32_t)0x00000400)        /*!<Wrapped burst mode support             */
S#define  FSMC_BCR3_WAITCFG                   ((uint32_t)0x00000800)        /*!<Wait timing configuration              */
S#define  FSMC_BCR3_WREN                      ((uint32_t)0x00001000)        /*!<Write enable bit                       */
S#define  FSMC_BCR3_WAITEN                    ((uint32_t)0x00002000)        /*!<Wait enable bit                        */
S#define  FSMC_BCR3_EXTMOD                    ((uint32_t)0x00004000)        /*!<Extended mode enable                   */
S#define  FSMC_BCR3_ASYNCWAIT                 ((uint32_t)0x00008000)        /*!<Asynchronous wait                      */
S#define  FSMC_BCR3_CBURSTRW                  ((uint32_t)0x00080000)        /*!<Write burst enable                     */
S
S/******************  Bit definition for FSMC_BCR4 register  *******************/
S#define  FSMC_BCR4_MBKEN                     ((uint32_t)0x00000001)        /*!<Memory bank enable bit */
S#define  FSMC_BCR4_MUXEN                     ((uint32_t)0x00000002)        /*!<Address/data multiplexing enable bit   */
S
S#define  FSMC_BCR4_MTYP                      ((uint32_t)0x0000000C)        /*!<MTYP[1:0] bits (Memory type)           */
S#define  FSMC_BCR4_MTYP_0                    ((uint32_t)0x00000004)        /*!<Bit 0 */
S#define  FSMC_BCR4_MTYP_1                    ((uint32_t)0x00000008)        /*!<Bit 1 */
S
S#define  FSMC_BCR4_MWID                      ((uint32_t)0x00000030)        /*!<MWID[1:0] bits (Memory data bus width) */
S#define  FSMC_BCR4_MWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FSMC_BCR4_MWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
S
S#define  FSMC_BCR4_FACCEN                    ((uint32_t)0x00000040)        /*!<Flash access enable                    */
S#define  FSMC_BCR4_BURSTEN                   ((uint32_t)0x00000100)        /*!<Burst enable bit                       */
S#define  FSMC_BCR4_WAITPOL                   ((uint32_t)0x00000200)        /*!<Wait signal polarity bit               */
S#define  FSMC_BCR4_WRAPMOD                   ((uint32_t)0x00000400)        /*!<Wrapped burst mode support             */
S#define  FSMC_BCR4_WAITCFG                   ((uint32_t)0x00000800)        /*!<Wait timing configuration              */
S#define  FSMC_BCR4_WREN                      ((uint32_t)0x00001000)        /*!<Write enable bit                       */
S#define  FSMC_BCR4_WAITEN                    ((uint32_t)0x00002000)        /*!<Wait enable bit                        */
S#define  FSMC_BCR4_EXTMOD                    ((uint32_t)0x00004000)        /*!<Extended mode enable                   */
S#define  FSMC_BCR4_ASYNCWAIT                 ((uint32_t)0x00008000)        /*!<Asynchronous wait                      */
S#define  FSMC_BCR4_CBURSTRW                  ((uint32_t)0x00080000)        /*!<Write burst enable                     */
S
S/******************  Bit definition for FSMC_BTR1 register  ******************/
S#define  FSMC_BTR1_ADDSET                    ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
S#define  FSMC_BTR1_ADDSET_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FSMC_BTR1_ADDSET_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FSMC_BTR1_ADDSET_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FSMC_BTR1_ADDSET_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
S
S#define  FSMC_BTR1_ADDHLD                    ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FSMC_BTR1_ADDHLD_0                  ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FSMC_BTR1_ADDHLD_1                  ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FSMC_BTR1_ADDHLD_2                  ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FSMC_BTR1_ADDHLD_3                  ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FSMC_BTR1_DATAST                    ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
S#define  FSMC_BTR1_DATAST_0                  ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FSMC_BTR1_DATAST_1                  ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FSMC_BTR1_DATAST_2                  ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FSMC_BTR1_DATAST_3                  ((uint32_t)0x00000800)        /*!<Bit 3 */
S
S#define  FSMC_BTR1_BUSTURN                   ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
S#define  FSMC_BTR1_BUSTURN_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FSMC_BTR1_BUSTURN_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FSMC_BTR1_BUSTURN_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FSMC_BTR1_BUSTURN_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
S
S#define  FSMC_BTR1_CLKDIV                    ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FSMC_BTR1_CLKDIV_0                  ((uint32_t)0x00100000)        /*!<Bit 0 */
S#define  FSMC_BTR1_CLKDIV_1                  ((uint32_t)0x00200000)        /*!<Bit 1 */
S#define  FSMC_BTR1_CLKDIV_2                  ((uint32_t)0x00400000)        /*!<Bit 2 */
S#define  FSMC_BTR1_CLKDIV_3                  ((uint32_t)0x00800000)        /*!<Bit 3 */
S
S#define  FSMC_BTR1_DATLAT                    ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
S#define  FSMC_BTR1_DATLAT_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FSMC_BTR1_DATLAT_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FSMC_BTR1_DATLAT_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FSMC_BTR1_DATLAT_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
S
S#define  FSMC_BTR1_ACCMOD                    ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
S#define  FSMC_BTR1_ACCMOD_0                  ((uint32_t)0x10000000)        /*!<Bit 0 */
S#define  FSMC_BTR1_ACCMOD_1                  ((uint32_t)0x20000000)        /*!<Bit 1 */
S
S/******************  Bit definition for FSMC_BTR2 register  *******************/
S#define  FSMC_BTR2_ADDSET                    ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
S#define  FSMC_BTR2_ADDSET_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FSMC_BTR2_ADDSET_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FSMC_BTR2_ADDSET_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FSMC_BTR2_ADDSET_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
S
S#define  FSMC_BTR2_ADDHLD                    ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FSMC_BTR2_ADDHLD_0                  ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FSMC_BTR2_ADDHLD_1                  ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FSMC_BTR2_ADDHLD_2                  ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FSMC_BTR2_ADDHLD_3                  ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FSMC_BTR2_DATAST                    ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
S#define  FSMC_BTR2_DATAST_0                  ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FSMC_BTR2_DATAST_1                  ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FSMC_BTR2_DATAST_2                  ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FSMC_BTR2_DATAST_3                  ((uint32_t)0x00000800)        /*!<Bit 3 */
S
S#define  FSMC_BTR2_BUSTURN                   ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
S#define  FSMC_BTR2_BUSTURN_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FSMC_BTR2_BUSTURN_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FSMC_BTR2_BUSTURN_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FSMC_BTR2_BUSTURN_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
S
S#define  FSMC_BTR2_CLKDIV                    ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FSMC_BTR2_CLKDIV_0                  ((uint32_t)0x00100000)        /*!<Bit 0 */
S#define  FSMC_BTR2_CLKDIV_1                  ((uint32_t)0x00200000)        /*!<Bit 1 */
S#define  FSMC_BTR2_CLKDIV_2                  ((uint32_t)0x00400000)        /*!<Bit 2 */
S#define  FSMC_BTR2_CLKDIV_3                  ((uint32_t)0x00800000)        /*!<Bit 3 */
S
S#define  FSMC_BTR2_DATLAT                    ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
S#define  FSMC_BTR2_DATLAT_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FSMC_BTR2_DATLAT_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FSMC_BTR2_DATLAT_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FSMC_BTR2_DATLAT_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
S
S#define  FSMC_BTR2_ACCMOD                    ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
S#define  FSMC_BTR2_ACCMOD_0                  ((uint32_t)0x10000000)        /*!<Bit 0 */
S#define  FSMC_BTR2_ACCMOD_1                  ((uint32_t)0x20000000)        /*!<Bit 1 */
S
S/*******************  Bit definition for FSMC_BTR3 register  *******************/
S#define  FSMC_BTR3_ADDSET                    ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
S#define  FSMC_BTR3_ADDSET_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FSMC_BTR3_ADDSET_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FSMC_BTR3_ADDSET_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FSMC_BTR3_ADDSET_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
S
S#define  FSMC_BTR3_ADDHLD                    ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FSMC_BTR3_ADDHLD_0                  ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FSMC_BTR3_ADDHLD_1                  ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FSMC_BTR3_ADDHLD_2                  ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FSMC_BTR3_ADDHLD_3                  ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FSMC_BTR3_DATAST                    ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
S#define  FSMC_BTR3_DATAST_0                  ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FSMC_BTR3_DATAST_1                  ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FSMC_BTR3_DATAST_2                  ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FSMC_BTR3_DATAST_3                  ((uint32_t)0x00000800)        /*!<Bit 3 */
S
S#define  FSMC_BTR3_BUSTURN                   ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
S#define  FSMC_BTR3_BUSTURN_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FSMC_BTR3_BUSTURN_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FSMC_BTR3_BUSTURN_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FSMC_BTR3_BUSTURN_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
S
S#define  FSMC_BTR3_CLKDIV                    ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FSMC_BTR3_CLKDIV_0                  ((uint32_t)0x00100000)        /*!<Bit 0 */
S#define  FSMC_BTR3_CLKDIV_1                  ((uint32_t)0x00200000)        /*!<Bit 1 */
S#define  FSMC_BTR3_CLKDIV_2                  ((uint32_t)0x00400000)        /*!<Bit 2 */
S#define  FSMC_BTR3_CLKDIV_3                  ((uint32_t)0x00800000)        /*!<Bit 3 */
S
S#define  FSMC_BTR3_DATLAT                    ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
S#define  FSMC_BTR3_DATLAT_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FSMC_BTR3_DATLAT_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FSMC_BTR3_DATLAT_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FSMC_BTR3_DATLAT_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
S
S#define  FSMC_BTR3_ACCMOD                    ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
S#define  FSMC_BTR3_ACCMOD_0                  ((uint32_t)0x10000000)        /*!<Bit 0 */
S#define  FSMC_BTR3_ACCMOD_1                  ((uint32_t)0x20000000)        /*!<Bit 1 */
S
S/******************  Bit definition for FSMC_BTR4 register  *******************/
S#define  FSMC_BTR4_ADDSET                    ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
S#define  FSMC_BTR4_ADDSET_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FSMC_BTR4_ADDSET_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FSMC_BTR4_ADDSET_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FSMC_BTR4_ADDSET_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
S
S#define  FSMC_BTR4_ADDHLD                    ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FSMC_BTR4_ADDHLD_0                  ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FSMC_BTR4_ADDHLD_1                  ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FSMC_BTR4_ADDHLD_2                  ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FSMC_BTR4_ADDHLD_3                  ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FSMC_BTR4_DATAST                    ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
S#define  FSMC_BTR4_DATAST_0                  ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FSMC_BTR4_DATAST_1                  ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FSMC_BTR4_DATAST_2                  ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FSMC_BTR4_DATAST_3                  ((uint32_t)0x00000800)        /*!<Bit 3 */
S
S#define  FSMC_BTR4_BUSTURN                   ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
S#define  FSMC_BTR4_BUSTURN_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FSMC_BTR4_BUSTURN_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FSMC_BTR4_BUSTURN_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FSMC_BTR4_BUSTURN_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
S
S#define  FSMC_BTR4_CLKDIV                    ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FSMC_BTR4_CLKDIV_0                  ((uint32_t)0x00100000)        /*!<Bit 0 */
S#define  FSMC_BTR4_CLKDIV_1                  ((uint32_t)0x00200000)        /*!<Bit 1 */
S#define  FSMC_BTR4_CLKDIV_2                  ((uint32_t)0x00400000)        /*!<Bit 2 */
S#define  FSMC_BTR4_CLKDIV_3                  ((uint32_t)0x00800000)        /*!<Bit 3 */
S
S#define  FSMC_BTR4_DATLAT                    ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
S#define  FSMC_BTR4_DATLAT_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FSMC_BTR4_DATLAT_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FSMC_BTR4_DATLAT_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FSMC_BTR4_DATLAT_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
S
S#define  FSMC_BTR4_ACCMOD                    ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
S#define  FSMC_BTR4_ACCMOD_0                  ((uint32_t)0x10000000)        /*!<Bit 0 */
S#define  FSMC_BTR4_ACCMOD_1                  ((uint32_t)0x20000000)        /*!<Bit 1 */
S
S/******************  Bit definition for FSMC_BWTR1 register  ******************/
S#define  FSMC_BWTR1_ADDSET                   ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
S#define  FSMC_BWTR1_ADDSET_0                 ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FSMC_BWTR1_ADDSET_1                 ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FSMC_BWTR1_ADDSET_2                 ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FSMC_BWTR1_ADDSET_3                 ((uint32_t)0x00000008)        /*!<Bit 3 */
S
S#define  FSMC_BWTR1_ADDHLD                   ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FSMC_BWTR1_ADDHLD_0                 ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FSMC_BWTR1_ADDHLD_1                 ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FSMC_BWTR1_ADDHLD_2                 ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FSMC_BWTR1_ADDHLD_3                 ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FSMC_BWTR1_DATAST                   ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
S#define  FSMC_BWTR1_DATAST_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FSMC_BWTR1_DATAST_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FSMC_BWTR1_DATAST_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FSMC_BWTR1_DATAST_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
S
S#define  FSMC_BWTR1_BUSTURN                  ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround duration) */
S#define  FSMC_BWTR1_BUSTURN_0                ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FSMC_BWTR1_BUSTURN_1                ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FSMC_BWTR1_BUSTURN_2                ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FSMC_BWTR1_BUSTURN_3                ((uint32_t)0x00080000)        /*!<Bit 3 */
S
S#define  FSMC_BWTR1_ACCMOD                   ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
S#define  FSMC_BWTR1_ACCMOD_0                 ((uint32_t)0x10000000)        /*!<Bit 0 */
S#define  FSMC_BWTR1_ACCMOD_1                 ((uint32_t)0x20000000)        /*!<Bit 1 */
S
S/******************  Bit definition for FSMC_BWTR2 register  ******************/
S#define  FSMC_BWTR2_ADDSET                   ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
S#define  FSMC_BWTR2_ADDSET_0                 ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FSMC_BWTR2_ADDSET_1                 ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FSMC_BWTR2_ADDSET_2                 ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FSMC_BWTR2_ADDSET_3                 ((uint32_t)0x00000008)        /*!<Bit 3 */
S
S#define  FSMC_BWTR2_ADDHLD                   ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FSMC_BWTR2_ADDHLD_0                 ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FSMC_BWTR2_ADDHLD_1                 ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FSMC_BWTR2_ADDHLD_2                 ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FSMC_BWTR2_ADDHLD_3                 ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FSMC_BWTR2_DATAST                   ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
S#define  FSMC_BWTR2_DATAST_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FSMC_BWTR2_DATAST_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FSMC_BWTR2_DATAST_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FSMC_BWTR2_DATAST_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
S
S#define  FSMC_BWTR2_BUSTURN                  ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround duration) */
S#define  FSMC_BWTR2_BUSTURN_0                ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FSMC_BWTR2_BUSTURN_1                ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FSMC_BWTR2_BUSTURN_2                ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FSMC_BWTR2_BUSTURN_3                ((uint32_t)0x00080000)        /*!<Bit 3 */
S
S#define  FSMC_BWTR2_ACCMOD                   ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
S#define  FSMC_BWTR2_ACCMOD_0                 ((uint32_t)0x10000000)        /*!<Bit 0 */
S#define  FSMC_BWTR2_ACCMOD_1                 ((uint32_t)0x20000000)        /*!<Bit 1 */
S
S/******************  Bit definition for FSMC_BWTR3 register  ******************/
S#define  FSMC_BWTR3_ADDSET                   ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
S#define  FSMC_BWTR3_ADDSET_0                 ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FSMC_BWTR3_ADDSET_1                 ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FSMC_BWTR3_ADDSET_2                 ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FSMC_BWTR3_ADDSET_3                 ((uint32_t)0x00000008)        /*!<Bit 3 */
S
S#define  FSMC_BWTR3_ADDHLD                   ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FSMC_BWTR3_ADDHLD_0                 ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FSMC_BWTR3_ADDHLD_1                 ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FSMC_BWTR3_ADDHLD_2                 ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FSMC_BWTR3_ADDHLD_3                 ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FSMC_BWTR3_DATAST                   ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
S#define  FSMC_BWTR3_DATAST_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FSMC_BWTR3_DATAST_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FSMC_BWTR3_DATAST_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FSMC_BWTR3_DATAST_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
S
S#define  FSMC_BWTR3_BUSTURN                  ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround duration) */
S#define  FSMC_BWTR3_BUSTURN_0                ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FSMC_BWTR3_BUSTURN_1                ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FSMC_BWTR3_BUSTURN_2                ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FSMC_BWTR3_BUSTURN_3                ((uint32_t)0x00080000)        /*!<Bit 3 */
S                                                      
S#define  FSMC_BWTR3_ACCMOD                   ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
S#define  FSMC_BWTR3_ACCMOD_0                 ((uint32_t)0x10000000)        /*!<Bit 0 */
S#define  FSMC_BWTR3_ACCMOD_1                 ((uint32_t)0x20000000)        /*!<Bit 1 */
S
S/******************  Bit definition for FSMC_BWTR4 register  ******************/
S#define  FSMC_BWTR4_ADDSET                   ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
S#define  FSMC_BWTR4_ADDSET_0                 ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FSMC_BWTR4_ADDSET_1                 ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FSMC_BWTR4_ADDSET_2                 ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FSMC_BWTR4_ADDSET_3                 ((uint32_t)0x00000008)        /*!<Bit 3 */
S
S#define  FSMC_BWTR4_ADDHLD                   ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FSMC_BWTR4_ADDHLD_0                 ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FSMC_BWTR4_ADDHLD_1                 ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FSMC_BWTR4_ADDHLD_2                 ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FSMC_BWTR4_ADDHLD_3                 ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FSMC_BWTR4_DATAST                   ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
S#define  FSMC_BWTR4_DATAST_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FSMC_BWTR4_DATAST_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FSMC_BWTR4_DATAST_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FSMC_BWTR4_DATAST_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
S
S#define  FSMC_BWTR4_BUSTURN                  ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround duration) */
S#define  FSMC_BWTR4_BUSTURN_0                ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FSMC_BWTR4_BUSTURN_1                ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FSMC_BWTR4_BUSTURN_2                ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FSMC_BWTR4_BUSTURN_3                ((uint32_t)0x00080000)        /*!<Bit 3 */
S
S#define  FSMC_BWTR4_ACCMOD                   ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
S#define  FSMC_BWTR4_ACCMOD_0                 ((uint32_t)0x10000000)        /*!<Bit 0 */
S#define  FSMC_BWTR4_ACCMOD_1                 ((uint32_t)0x20000000)        /*!<Bit 1 */
S
S/******************  Bit definition for FSMC_PCR2 register  *******************/
S#define  FSMC_PCR2_PWAITEN                   ((uint32_t)0x00000002)        /*!<Wait feature enable bit */
S#define  FSMC_PCR2_PBKEN                     ((uint32_t)0x00000004)        /*!<PC Card/NAND Flash memory bank enable bit */
S#define  FSMC_PCR2_PTYP                      ((uint32_t)0x00000008)        /*!<Memory type */
S
S#define  FSMC_PCR2_PWID                      ((uint32_t)0x00000030)        /*!<PWID[1:0] bits (NAND Flash databus width) */
S#define  FSMC_PCR2_PWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FSMC_PCR2_PWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
S
S#define  FSMC_PCR2_ECCEN                     ((uint32_t)0x00000040)        /*!<ECC computation logic enable bit */
S
S#define  FSMC_PCR2_TCLR                      ((uint32_t)0x00001E00)        /*!<TCLR[3:0] bits (CLE to RE delay) */
S#define  FSMC_PCR2_TCLR_0                    ((uint32_t)0x00000200)        /*!<Bit 0 */
S#define  FSMC_PCR2_TCLR_1                    ((uint32_t)0x00000400)        /*!<Bit 1 */
S#define  FSMC_PCR2_TCLR_2                    ((uint32_t)0x00000800)        /*!<Bit 2 */
S#define  FSMC_PCR2_TCLR_3                    ((uint32_t)0x00001000)        /*!<Bit 3 */
S
S#define  FSMC_PCR2_TAR                       ((uint32_t)0x0001E000)        /*!<TAR[3:0] bits (ALE to RE delay) */
S#define  FSMC_PCR2_TAR_0                     ((uint32_t)0x00002000)        /*!<Bit 0 */
S#define  FSMC_PCR2_TAR_1                     ((uint32_t)0x00004000)        /*!<Bit 1 */
S#define  FSMC_PCR2_TAR_2                     ((uint32_t)0x00008000)        /*!<Bit 2 */
S#define  FSMC_PCR2_TAR_3                     ((uint32_t)0x00010000)        /*!<Bit 3 */
S
S#define  FSMC_PCR2_ECCPS                     ((uint32_t)0x000E0000)        /*!<ECCPS[1:0] bits (ECC page size) */
S#define  FSMC_PCR2_ECCPS_0                   ((uint32_t)0x00020000)        /*!<Bit 0 */
S#define  FSMC_PCR2_ECCPS_1                   ((uint32_t)0x00040000)        /*!<Bit 1 */
S#define  FSMC_PCR2_ECCPS_2                   ((uint32_t)0x00080000)        /*!<Bit 2 */
S
S/******************  Bit definition for FSMC_PCR3 register  *******************/
S#define  FSMC_PCR3_PWAITEN                   ((uint32_t)0x00000002)        /*!<Wait feature enable bit */
S#define  FSMC_PCR3_PBKEN                     ((uint32_t)0x00000004)        /*!<PC Card/NAND Flash memory bank enable bit */
S#define  FSMC_PCR3_PTYP                      ((uint32_t)0x00000008)        /*!<Memory type */
S
S#define  FSMC_PCR3_PWID                      ((uint32_t)0x00000030)        /*!<PWID[1:0] bits (NAND Flash databus width) */
S#define  FSMC_PCR3_PWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FSMC_PCR3_PWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
S
S#define  FSMC_PCR3_ECCEN                     ((uint32_t)0x00000040)        /*!<ECC computation logic enable bit */
S
S#define  FSMC_PCR3_TCLR                      ((uint32_t)0x00001E00)        /*!<TCLR[3:0] bits (CLE to RE delay) */
S#define  FSMC_PCR3_TCLR_0                    ((uint32_t)0x00000200)        /*!<Bit 0 */
S#define  FSMC_PCR3_TCLR_1                    ((uint32_t)0x00000400)        /*!<Bit 1 */
S#define  FSMC_PCR3_TCLR_2                    ((uint32_t)0x00000800)        /*!<Bit 2 */
S#define  FSMC_PCR3_TCLR_3                    ((uint32_t)0x00001000)        /*!<Bit 3 */
S
S#define  FSMC_PCR3_TAR                       ((uint32_t)0x0001E000)        /*!<TAR[3:0] bits (ALE to RE delay) */
S#define  FSMC_PCR3_TAR_0                     ((uint32_t)0x00002000)        /*!<Bit 0 */
S#define  FSMC_PCR3_TAR_1                     ((uint32_t)0x00004000)        /*!<Bit 1 */
S#define  FSMC_PCR3_TAR_2                     ((uint32_t)0x00008000)        /*!<Bit 2 */
S#define  FSMC_PCR3_TAR_3                     ((uint32_t)0x00010000)        /*!<Bit 3 */
S
S#define  FSMC_PCR3_ECCPS                     ((uint32_t)0x000E0000)        /*!<ECCPS[2:0] bits (ECC page size) */
S#define  FSMC_PCR3_ECCPS_0                   ((uint32_t)0x00020000)        /*!<Bit 0 */
S#define  FSMC_PCR3_ECCPS_1                   ((uint32_t)0x00040000)        /*!<Bit 1 */
S#define  FSMC_PCR3_ECCPS_2                   ((uint32_t)0x00080000)        /*!<Bit 2 */
S
S/******************  Bit definition for FSMC_PCR4 register  *******************/
S#define  FSMC_PCR4_PWAITEN                   ((uint32_t)0x00000002)        /*!<Wait feature enable bit */
S#define  FSMC_PCR4_PBKEN                     ((uint32_t)0x00000004)        /*!<PC Card/NAND Flash memory bank enable bit */
S#define  FSMC_PCR4_PTYP                      ((uint32_t)0x00000008)        /*!<Memory type */
S
S#define  FSMC_PCR4_PWID                      ((uint32_t)0x00000030)        /*!<PWID[1:0] bits (NAND Flash databus width) */
S#define  FSMC_PCR4_PWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FSMC_PCR4_PWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
S
S#define  FSMC_PCR4_ECCEN                     ((uint32_t)0x00000040)        /*!<ECC computation logic enable bit */
S
S#define  FSMC_PCR4_TCLR                      ((uint32_t)0x00001E00)        /*!<TCLR[3:0] bits (CLE to RE delay) */
S#define  FSMC_PCR4_TCLR_0                    ((uint32_t)0x00000200)        /*!<Bit 0 */
S#define  FSMC_PCR4_TCLR_1                    ((uint32_t)0x00000400)        /*!<Bit 1 */
S#define  FSMC_PCR4_TCLR_2                    ((uint32_t)0x00000800)        /*!<Bit 2 */
S#define  FSMC_PCR4_TCLR_3                    ((uint32_t)0x00001000)        /*!<Bit 3 */
S
S#define  FSMC_PCR4_TAR                       ((uint32_t)0x0001E000)        /*!<TAR[3:0] bits (ALE to RE delay) */
S#define  FSMC_PCR4_TAR_0                     ((uint32_t)0x00002000)        /*!<Bit 0 */
S#define  FSMC_PCR4_TAR_1                     ((uint32_t)0x00004000)        /*!<Bit 1 */
S#define  FSMC_PCR4_TAR_2                     ((uint32_t)0x00008000)        /*!<Bit 2 */
S#define  FSMC_PCR4_TAR_3                     ((uint32_t)0x00010000)        /*!<Bit 3 */
S
S#define  FSMC_PCR4_ECCPS                     ((uint32_t)0x000E0000)        /*!<ECCPS[2:0] bits (ECC page size) */
S#define  FSMC_PCR4_ECCPS_0                   ((uint32_t)0x00020000)        /*!<Bit 0 */
S#define  FSMC_PCR4_ECCPS_1                   ((uint32_t)0x00040000)        /*!<Bit 1 */
S#define  FSMC_PCR4_ECCPS_2                   ((uint32_t)0x00080000)        /*!<Bit 2 */
S
S/*******************  Bit definition for FSMC_SR2 register  *******************/
S#define  FSMC_SR2_IRS                        ((uint8_t)0x01)               /*!<Interrupt Rising Edge status                */
S#define  FSMC_SR2_ILS                        ((uint8_t)0x02)               /*!<Interrupt Level status                      */
S#define  FSMC_SR2_IFS                        ((uint8_t)0x04)               /*!<Interrupt Falling Edge status               */
S#define  FSMC_SR2_IREN                       ((uint8_t)0x08)               /*!<Interrupt Rising Edge detection Enable bit  */
S#define  FSMC_SR2_ILEN                       ((uint8_t)0x10)               /*!<Interrupt Level detection Enable bit        */
S#define  FSMC_SR2_IFEN                       ((uint8_t)0x20)               /*!<Interrupt Falling Edge detection Enable bit */
S#define  FSMC_SR2_FEMPT                      ((uint8_t)0x40)               /*!<FIFO empty */
S
S/*******************  Bit definition for FSMC_SR3 register  *******************/
S#define  FSMC_SR3_IRS                        ((uint8_t)0x01)               /*!<Interrupt Rising Edge status                */
S#define  FSMC_SR3_ILS                        ((uint8_t)0x02)               /*!<Interrupt Level status                      */
S#define  FSMC_SR3_IFS                        ((uint8_t)0x04)               /*!<Interrupt Falling Edge status               */
S#define  FSMC_SR3_IREN                       ((uint8_t)0x08)               /*!<Interrupt Rising Edge detection Enable bit  */
S#define  FSMC_SR3_ILEN                       ((uint8_t)0x10)               /*!<Interrupt Level detection Enable bit        */
S#define  FSMC_SR3_IFEN                       ((uint8_t)0x20)               /*!<Interrupt Falling Edge detection Enable bit */
S#define  FSMC_SR3_FEMPT                      ((uint8_t)0x40)               /*!<FIFO empty */
S
S/*******************  Bit definition for FSMC_SR4 register  *******************/
S#define  FSMC_SR4_IRS                        ((uint8_t)0x01)               /*!<Interrupt Rising Edge status                 */
S#define  FSMC_SR4_ILS                        ((uint8_t)0x02)               /*!<Interrupt Level status                       */
S#define  FSMC_SR4_IFS                        ((uint8_t)0x04)               /*!<Interrupt Falling Edge status                */
S#define  FSMC_SR4_IREN                       ((uint8_t)0x08)               /*!<Interrupt Rising Edge detection Enable bit   */
S#define  FSMC_SR4_ILEN                       ((uint8_t)0x10)               /*!<Interrupt Level detection Enable bit         */
S#define  FSMC_SR4_IFEN                       ((uint8_t)0x20)               /*!<Interrupt Falling Edge detection Enable bit  */
S#define  FSMC_SR4_FEMPT                      ((uint8_t)0x40)               /*!<FIFO empty */
S
S/******************  Bit definition for FSMC_PMEM2 register  ******************/
S#define  FSMC_PMEM2_MEMSET2                  ((uint32_t)0x000000FF)        /*!<MEMSET2[7:0] bits (Common memory 2 setup time) */
S#define  FSMC_PMEM2_MEMSET2_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FSMC_PMEM2_MEMSET2_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FSMC_PMEM2_MEMSET2_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FSMC_PMEM2_MEMSET2_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  FSMC_PMEM2_MEMSET2_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  FSMC_PMEM2_MEMSET2_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
S#define  FSMC_PMEM2_MEMSET2_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
S#define  FSMC_PMEM2_MEMSET2_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
S
S#define  FSMC_PMEM2_MEMWAIT2                 ((uint32_t)0x0000FF00)        /*!<MEMWAIT2[7:0] bits (Common memory 2 wait time) */
S#define  FSMC_PMEM2_MEMWAIT2_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FSMC_PMEM2_MEMWAIT2_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FSMC_PMEM2_MEMWAIT2_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FSMC_PMEM2_MEMWAIT2_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FSMC_PMEM2_MEMWAIT2_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FSMC_PMEM2_MEMWAIT2_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FSMC_PMEM2_MEMWAIT2_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FSMC_PMEM2_MEMWAIT2_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FSMC_PMEM2_MEMHOLD2                 ((uint32_t)0x00FF0000)        /*!<MEMHOLD2[7:0] bits (Common memory 2 hold time) */
S#define  FSMC_PMEM2_MEMHOLD2_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FSMC_PMEM2_MEMHOLD2_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FSMC_PMEM2_MEMHOLD2_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FSMC_PMEM2_MEMHOLD2_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
S#define  FSMC_PMEM2_MEMHOLD2_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
S#define  FSMC_PMEM2_MEMHOLD2_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
S#define  FSMC_PMEM2_MEMHOLD2_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
S#define  FSMC_PMEM2_MEMHOLD2_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
S
S#define  FSMC_PMEM2_MEMHIZ2                  ((uint32_t)0xFF000000)        /*!<MEMHIZ2[7:0] bits (Common memory 2 databus HiZ time) */
S#define  FSMC_PMEM2_MEMHIZ2_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FSMC_PMEM2_MEMHIZ2_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FSMC_PMEM2_MEMHIZ2_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FSMC_PMEM2_MEMHIZ2_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
S#define  FSMC_PMEM2_MEMHIZ2_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
S#define  FSMC_PMEM2_MEMHIZ2_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
S#define  FSMC_PMEM2_MEMHIZ2_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
S#define  FSMC_PMEM2_MEMHIZ2_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
S
S/******************  Bit definition for FSMC_PMEM3 register  ******************/
S#define  FSMC_PMEM3_MEMSET3                  ((uint32_t)0x000000FF)        /*!<MEMSET3[7:0] bits (Common memory 3 setup time) */
S#define  FSMC_PMEM3_MEMSET3_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FSMC_PMEM3_MEMSET3_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FSMC_PMEM3_MEMSET3_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FSMC_PMEM3_MEMSET3_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  FSMC_PMEM3_MEMSET3_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  FSMC_PMEM3_MEMSET3_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
S#define  FSMC_PMEM3_MEMSET3_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
S#define  FSMC_PMEM3_MEMSET3_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
S
S#define  FSMC_PMEM3_MEMWAIT3                 ((uint32_t)0x0000FF00)        /*!<MEMWAIT3[7:0] bits (Common memory 3 wait time) */
S#define  FSMC_PMEM3_MEMWAIT3_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FSMC_PMEM3_MEMWAIT3_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FSMC_PMEM3_MEMWAIT3_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FSMC_PMEM3_MEMWAIT3_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FSMC_PMEM3_MEMWAIT3_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FSMC_PMEM3_MEMWAIT3_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FSMC_PMEM3_MEMWAIT3_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FSMC_PMEM3_MEMWAIT3_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FSMC_PMEM3_MEMHOLD3                 ((uint32_t)0x00FF0000)        /*!<MEMHOLD3[7:0] bits (Common memory 3 hold time) */
S#define  FSMC_PMEM3_MEMHOLD3_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FSMC_PMEM3_MEMHOLD3_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FSMC_PMEM3_MEMHOLD3_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FSMC_PMEM3_MEMHOLD3_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
S#define  FSMC_PMEM3_MEMHOLD3_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
S#define  FSMC_PMEM3_MEMHOLD3_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
S#define  FSMC_PMEM3_MEMHOLD3_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
S#define  FSMC_PMEM3_MEMHOLD3_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
S
S#define  FSMC_PMEM3_MEMHIZ3                  ((uint32_t)0xFF000000)        /*!<MEMHIZ3[7:0] bits (Common memory 3 databus HiZ time) */
S#define  FSMC_PMEM3_MEMHIZ3_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FSMC_PMEM3_MEMHIZ3_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FSMC_PMEM3_MEMHIZ3_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FSMC_PMEM3_MEMHIZ3_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
S#define  FSMC_PMEM3_MEMHIZ3_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
S#define  FSMC_PMEM3_MEMHIZ3_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
S#define  FSMC_PMEM3_MEMHIZ3_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
S#define  FSMC_PMEM3_MEMHIZ3_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
S
S/******************  Bit definition for FSMC_PMEM4 register  ******************/
S#define  FSMC_PMEM4_MEMSET4                  ((uint32_t)0x000000FF)        /*!<MEMSET4[7:0] bits (Common memory 4 setup time) */
S#define  FSMC_PMEM4_MEMSET4_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FSMC_PMEM4_MEMSET4_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FSMC_PMEM4_MEMSET4_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FSMC_PMEM4_MEMSET4_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  FSMC_PMEM4_MEMSET4_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  FSMC_PMEM4_MEMSET4_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
S#define  FSMC_PMEM4_MEMSET4_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
S#define  FSMC_PMEM4_MEMSET4_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
S
S#define  FSMC_PMEM4_MEMWAIT4                 ((uint32_t)0x0000FF00)        /*!<MEMWAIT4[7:0] bits (Common memory 4 wait time) */
S#define  FSMC_PMEM4_MEMWAIT4_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FSMC_PMEM4_MEMWAIT4_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FSMC_PMEM4_MEMWAIT4_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FSMC_PMEM4_MEMWAIT4_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FSMC_PMEM4_MEMWAIT4_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FSMC_PMEM4_MEMWAIT4_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FSMC_PMEM4_MEMWAIT4_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FSMC_PMEM4_MEMWAIT4_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FSMC_PMEM4_MEMHOLD4                 ((uint32_t)0x00FF0000)        /*!<MEMHOLD4[7:0] bits (Common memory 4 hold time) */
S#define  FSMC_PMEM4_MEMHOLD4_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FSMC_PMEM4_MEMHOLD4_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FSMC_PMEM4_MEMHOLD4_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FSMC_PMEM4_MEMHOLD4_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
S#define  FSMC_PMEM4_MEMHOLD4_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
S#define  FSMC_PMEM4_MEMHOLD4_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
S#define  FSMC_PMEM4_MEMHOLD4_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
S#define  FSMC_PMEM4_MEMHOLD4_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
S
S#define  FSMC_PMEM4_MEMHIZ4                  ((uint32_t)0xFF000000)        /*!<MEMHIZ4[7:0] bits (Common memory 4 databus HiZ time) */
S#define  FSMC_PMEM4_MEMHIZ4_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FSMC_PMEM4_MEMHIZ4_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FSMC_PMEM4_MEMHIZ4_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FSMC_PMEM4_MEMHIZ4_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
S#define  FSMC_PMEM4_MEMHIZ4_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
S#define  FSMC_PMEM4_MEMHIZ4_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
S#define  FSMC_PMEM4_MEMHIZ4_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
S#define  FSMC_PMEM4_MEMHIZ4_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
S
S/******************  Bit definition for FSMC_PATT2 register  ******************/
S#define  FSMC_PATT2_ATTSET2                  ((uint32_t)0x000000FF)        /*!<ATTSET2[7:0] bits (Attribute memory 2 setup time) */
S#define  FSMC_PATT2_ATTSET2_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FSMC_PATT2_ATTSET2_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FSMC_PATT2_ATTSET2_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FSMC_PATT2_ATTSET2_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  FSMC_PATT2_ATTSET2_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  FSMC_PATT2_ATTSET2_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
S#define  FSMC_PATT2_ATTSET2_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
S#define  FSMC_PATT2_ATTSET2_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
S
S#define  FSMC_PATT2_ATTWAIT2                 ((uint32_t)0x0000FF00)        /*!<ATTWAIT2[7:0] bits (Attribute memory 2 wait time) */
S#define  FSMC_PATT2_ATTWAIT2_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FSMC_PATT2_ATTWAIT2_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FSMC_PATT2_ATTWAIT2_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FSMC_PATT2_ATTWAIT2_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FSMC_PATT2_ATTWAIT2_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FSMC_PATT2_ATTWAIT2_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FSMC_PATT2_ATTWAIT2_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FSMC_PATT2_ATTWAIT2_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FSMC_PATT2_ATTHOLD2                 ((uint32_t)0x00FF0000)        /*!<ATTHOLD2[7:0] bits (Attribute memory 2 hold time) */
S#define  FSMC_PATT2_ATTHOLD2_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FSMC_PATT2_ATTHOLD2_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FSMC_PATT2_ATTHOLD2_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FSMC_PATT2_ATTHOLD2_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
S#define  FSMC_PATT2_ATTHOLD2_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
S#define  FSMC_PATT2_ATTHOLD2_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
S#define  FSMC_PATT2_ATTHOLD2_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
S#define  FSMC_PATT2_ATTHOLD2_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
S
S#define  FSMC_PATT2_ATTHIZ2                  ((uint32_t)0xFF000000)        /*!<ATTHIZ2[7:0] bits (Attribute memory 2 databus HiZ time) */
S#define  FSMC_PATT2_ATTHIZ2_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FSMC_PATT2_ATTHIZ2_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FSMC_PATT2_ATTHIZ2_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FSMC_PATT2_ATTHIZ2_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
S#define  FSMC_PATT2_ATTHIZ2_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
S#define  FSMC_PATT2_ATTHIZ2_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
S#define  FSMC_PATT2_ATTHIZ2_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
S#define  FSMC_PATT2_ATTHIZ2_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
S
S/******************  Bit definition for FSMC_PATT3 register  ******************/
S#define  FSMC_PATT3_ATTSET3                  ((uint32_t)0x000000FF)        /*!<ATTSET3[7:0] bits (Attribute memory 3 setup time) */
S#define  FSMC_PATT3_ATTSET3_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FSMC_PATT3_ATTSET3_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FSMC_PATT3_ATTSET3_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FSMC_PATT3_ATTSET3_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  FSMC_PATT3_ATTSET3_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  FSMC_PATT3_ATTSET3_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
S#define  FSMC_PATT3_ATTSET3_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
S#define  FSMC_PATT3_ATTSET3_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
S
S#define  FSMC_PATT3_ATTWAIT3                 ((uint32_t)0x0000FF00)        /*!<ATTWAIT3[7:0] bits (Attribute memory 3 wait time) */
S#define  FSMC_PATT3_ATTWAIT3_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FSMC_PATT3_ATTWAIT3_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FSMC_PATT3_ATTWAIT3_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FSMC_PATT3_ATTWAIT3_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FSMC_PATT3_ATTWAIT3_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FSMC_PATT3_ATTWAIT3_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FSMC_PATT3_ATTWAIT3_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FSMC_PATT3_ATTWAIT3_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FSMC_PATT3_ATTHOLD3                 ((uint32_t)0x00FF0000)        /*!<ATTHOLD3[7:0] bits (Attribute memory 3 hold time) */
S#define  FSMC_PATT3_ATTHOLD3_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FSMC_PATT3_ATTHOLD3_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FSMC_PATT3_ATTHOLD3_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FSMC_PATT3_ATTHOLD3_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
S#define  FSMC_PATT3_ATTHOLD3_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
S#define  FSMC_PATT3_ATTHOLD3_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
S#define  FSMC_PATT3_ATTHOLD3_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
S#define  FSMC_PATT3_ATTHOLD3_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
S
S#define  FSMC_PATT3_ATTHIZ3                  ((uint32_t)0xFF000000)        /*!<ATTHIZ3[7:0] bits (Attribute memory 3 databus HiZ time) */
S#define  FSMC_PATT3_ATTHIZ3_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FSMC_PATT3_ATTHIZ3_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FSMC_PATT3_ATTHIZ3_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FSMC_PATT3_ATTHIZ3_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
S#define  FSMC_PATT3_ATTHIZ3_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
S#define  FSMC_PATT3_ATTHIZ3_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
S#define  FSMC_PATT3_ATTHIZ3_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
S#define  FSMC_PATT3_ATTHIZ3_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
S
S/******************  Bit definition for FSMC_PATT4 register  ******************/
S#define  FSMC_PATT4_ATTSET4                  ((uint32_t)0x000000FF)        /*!<ATTSET4[7:0] bits (Attribute memory 4 setup time) */
S#define  FSMC_PATT4_ATTSET4_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FSMC_PATT4_ATTSET4_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FSMC_PATT4_ATTSET4_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FSMC_PATT4_ATTSET4_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  FSMC_PATT4_ATTSET4_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  FSMC_PATT4_ATTSET4_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
S#define  FSMC_PATT4_ATTSET4_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
S#define  FSMC_PATT4_ATTSET4_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
S
S#define  FSMC_PATT4_ATTWAIT4                 ((uint32_t)0x0000FF00)        /*!<ATTWAIT4[7:0] bits (Attribute memory 4 wait time) */
S#define  FSMC_PATT4_ATTWAIT4_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FSMC_PATT4_ATTWAIT4_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FSMC_PATT4_ATTWAIT4_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FSMC_PATT4_ATTWAIT4_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FSMC_PATT4_ATTWAIT4_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FSMC_PATT4_ATTWAIT4_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FSMC_PATT4_ATTWAIT4_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FSMC_PATT4_ATTWAIT4_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FSMC_PATT4_ATTHOLD4                 ((uint32_t)0x00FF0000)        /*!<ATTHOLD4[7:0] bits (Attribute memory 4 hold time) */
S#define  FSMC_PATT4_ATTHOLD4_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FSMC_PATT4_ATTHOLD4_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FSMC_PATT4_ATTHOLD4_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FSMC_PATT4_ATTHOLD4_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
S#define  FSMC_PATT4_ATTHOLD4_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
S#define  FSMC_PATT4_ATTHOLD4_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
S#define  FSMC_PATT4_ATTHOLD4_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
S#define  FSMC_PATT4_ATTHOLD4_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
S
S#define  FSMC_PATT4_ATTHIZ4                  ((uint32_t)0xFF000000)        /*!<ATTHIZ4[7:0] bits (Attribute memory 4 databus HiZ time) */
S#define  FSMC_PATT4_ATTHIZ4_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FSMC_PATT4_ATTHIZ4_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FSMC_PATT4_ATTHIZ4_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FSMC_PATT4_ATTHIZ4_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
S#define  FSMC_PATT4_ATTHIZ4_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
S#define  FSMC_PATT4_ATTHIZ4_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
S#define  FSMC_PATT4_ATTHIZ4_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
S#define  FSMC_PATT4_ATTHIZ4_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
S
S/******************  Bit definition for FSMC_PIO4 register  *******************/
S#define  FSMC_PIO4_IOSET4                    ((uint32_t)0x000000FF)        /*!<IOSET4[7:0] bits (I/O 4 setup time) */
S#define  FSMC_PIO4_IOSET4_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FSMC_PIO4_IOSET4_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FSMC_PIO4_IOSET4_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FSMC_PIO4_IOSET4_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  FSMC_PIO4_IOSET4_4                  ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  FSMC_PIO4_IOSET4_5                  ((uint32_t)0x00000020)        /*!<Bit 5 */
S#define  FSMC_PIO4_IOSET4_6                  ((uint32_t)0x00000040)        /*!<Bit 6 */
S#define  FSMC_PIO4_IOSET4_7                  ((uint32_t)0x00000080)        /*!<Bit 7 */
S
S#define  FSMC_PIO4_IOWAIT4                   ((uint32_t)0x0000FF00)        /*!<IOWAIT4[7:0] bits (I/O 4 wait time) */
S#define  FSMC_PIO4_IOWAIT4_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FSMC_PIO4_IOWAIT4_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FSMC_PIO4_IOWAIT4_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FSMC_PIO4_IOWAIT4_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FSMC_PIO4_IOWAIT4_4                 ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FSMC_PIO4_IOWAIT4_5                 ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FSMC_PIO4_IOWAIT4_6                 ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FSMC_PIO4_IOWAIT4_7                 ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FSMC_PIO4_IOHOLD4                   ((uint32_t)0x00FF0000)        /*!<IOHOLD4[7:0] bits (I/O 4 hold time) */
S#define  FSMC_PIO4_IOHOLD4_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FSMC_PIO4_IOHOLD4_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FSMC_PIO4_IOHOLD4_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FSMC_PIO4_IOHOLD4_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
S#define  FSMC_PIO4_IOHOLD4_4                 ((uint32_t)0x00100000)        /*!<Bit 4 */
S#define  FSMC_PIO4_IOHOLD4_5                 ((uint32_t)0x00200000)        /*!<Bit 5 */
S#define  FSMC_PIO4_IOHOLD4_6                 ((uint32_t)0x00400000)        /*!<Bit 6 */
S#define  FSMC_PIO4_IOHOLD4_7                 ((uint32_t)0x00800000)        /*!<Bit 7 */
S
S#define  FSMC_PIO4_IOHIZ4                    ((uint32_t)0xFF000000)        /*!<IOHIZ4[7:0] bits (I/O 4 databus HiZ time) */
S#define  FSMC_PIO4_IOHIZ4_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FSMC_PIO4_IOHIZ4_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FSMC_PIO4_IOHIZ4_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FSMC_PIO4_IOHIZ4_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
S#define  FSMC_PIO4_IOHIZ4_4                  ((uint32_t)0x10000000)        /*!<Bit 4 */
S#define  FSMC_PIO4_IOHIZ4_5                  ((uint32_t)0x20000000)        /*!<Bit 5 */
S#define  FSMC_PIO4_IOHIZ4_6                  ((uint32_t)0x40000000)        /*!<Bit 6 */
S#define  FSMC_PIO4_IOHIZ4_7                  ((uint32_t)0x80000000)        /*!<Bit 7 */
S
S/******************  Bit definition for FSMC_ECCR2 register  ******************/
S#define  FSMC_ECCR2_ECC2                     ((uint32_t)0xFFFFFFFF)        /*!<ECC result */
S
S/******************  Bit definition for FSMC_ECCR3 register  ******************/
S#define  FSMC_ECCR3_ECC3                     ((uint32_t)0xFFFFFFFF)        /*!<ECC result */
S#endif /* STM32F40_41xxx || STM32F412xG || STM32F413_423xx */
S
S#if defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
S/******************************************************************************/
S/*                                                                            */
S/*                          Flexible Memory Controller                        */
S/*                                                                            */
S/******************************************************************************/
S/******************  Bit definition for FMC_BCR1 register  *******************/
S#define  FMC_BCR1_MBKEN                     ((uint32_t)0x00000001)        /*!<Memory bank enable bit                 */
S#define  FMC_BCR1_MUXEN                     ((uint32_t)0x00000002)        /*!<Address/data multiplexing enable bit   */
S
S#define  FMC_BCR1_MTYP                      ((uint32_t)0x0000000C)        /*!<MTYP[1:0] bits (Memory type)           */
S#define  FMC_BCR1_MTYP_0                    ((uint32_t)0x00000004)        /*!<Bit 0 */
S#define  FMC_BCR1_MTYP_1                    ((uint32_t)0x00000008)        /*!<Bit 1 */
S
S#define  FMC_BCR1_MWID                      ((uint32_t)0x00000030)        /*!<MWID[1:0] bits (Memory data bus width) */
S#define  FMC_BCR1_MWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_BCR1_MWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
S
S#define  FMC_BCR1_FACCEN                    ((uint32_t)0x00000040)        /*!<Flash access enable        */
S#define  FMC_BCR1_BURSTEN                   ((uint32_t)0x00000100)        /*!<Burst enable bit           */
S#define  FMC_BCR1_WAITPOL                   ((uint32_t)0x00000200)        /*!<Wait signal polarity bit   */
S#define  FMC_BCR1_WRAPMOD                   ((uint32_t)0x00000400)        /*!<Wrapped burst mode support */
S#define  FMC_BCR1_WAITCFG                   ((uint32_t)0x00000800)        /*!<Wait timing configuration  */
S#define  FMC_BCR1_WREN                      ((uint32_t)0x00001000)        /*!<Write enable bit           */
S#define  FMC_BCR1_WAITEN                    ((uint32_t)0x00002000)        /*!<Wait enable bit            */
S#define  FMC_BCR1_EXTMOD                    ((uint32_t)0x00004000)        /*!<Extended mode enable       */
S#define  FMC_BCR1_ASYNCWAIT                 ((uint32_t)0x00008000)        /*!<Asynchronous wait          */
S#define  FMC_BCR1_CBURSTRW                  ((uint32_t)0x00080000)        /*!<Write burst enable         */
S#define  FMC_BCR1_CCLKEN                    ((uint32_t)0x00100000)        /*!<Continous clock enable     */
S
S/******************  Bit definition for FMC_BCR2 register  *******************/
S#define  FMC_BCR2_MBKEN                     ((uint32_t)0x00000001)        /*!<Memory bank enable bit                 */
S#define  FMC_BCR2_MUXEN                     ((uint32_t)0x00000002)        /*!<Address/data multiplexing enable bit   */
S
S#define  FMC_BCR2_MTYP                      ((uint32_t)0x0000000C)        /*!<MTYP[1:0] bits (Memory type)           */
S#define  FMC_BCR2_MTYP_0                    ((uint32_t)0x00000004)        /*!<Bit 0 */
S#define  FMC_BCR2_MTYP_1                    ((uint32_t)0x00000008)        /*!<Bit 1 */
S
S#define  FMC_BCR2_MWID                      ((uint32_t)0x00000030)        /*!<MWID[1:0] bits (Memory data bus width) */
S#define  FMC_BCR2_MWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_BCR2_MWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
S
S#define  FMC_BCR2_FACCEN                    ((uint32_t)0x00000040)        /*!<Flash access enable        */
S#define  FMC_BCR2_BURSTEN                   ((uint32_t)0x00000100)        /*!<Burst enable bit           */
S#define  FMC_BCR2_WAITPOL                   ((uint32_t)0x00000200)        /*!<Wait signal polarity bit   */
S#define  FMC_BCR2_WRAPMOD                   ((uint32_t)0x00000400)        /*!<Wrapped burst mode support */
S#define  FMC_BCR2_WAITCFG                   ((uint32_t)0x00000800)        /*!<Wait timing configuration  */
S#define  FMC_BCR2_WREN                      ((uint32_t)0x00001000)        /*!<Write enable bit           */
S#define  FMC_BCR2_WAITEN                    ((uint32_t)0x00002000)        /*!<Wait enable bit            */
S#define  FMC_BCR2_EXTMOD                    ((uint32_t)0x00004000)        /*!<Extended mode enable       */
S#define  FMC_BCR2_ASYNCWAIT                 ((uint32_t)0x00008000)        /*!<Asynchronous wait          */
S#define  FMC_BCR2_CBURSTRW                  ((uint32_t)0x00080000)        /*!<Write burst enable         */
S
S/******************  Bit definition for FMC_BCR3 register  *******************/
S#define  FMC_BCR3_MBKEN                     ((uint32_t)0x00000001)        /*!<Memory bank enable bit                 */
S#define  FMC_BCR3_MUXEN                     ((uint32_t)0x00000002)        /*!<Address/data multiplexing enable bit   */
S
S#define  FMC_BCR3_MTYP                      ((uint32_t)0x0000000C)        /*!<MTYP[1:0] bits (Memory type)           */
S#define  FMC_BCR3_MTYP_0                    ((uint32_t)0x00000004)        /*!<Bit 0 */
S#define  FMC_BCR3_MTYP_1                    ((uint32_t)0x00000008)        /*!<Bit 1 */
S
S#define  FMC_BCR3_MWID                      ((uint32_t)0x00000030)        /*!<MWID[1:0] bits (Memory data bus width) */
S#define  FMC_BCR3_MWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_BCR3_MWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
S
S#define  FMC_BCR3_FACCEN                    ((uint32_t)0x00000040)        /*!<Flash access enable        */
S#define  FMC_BCR3_BURSTEN                   ((uint32_t)0x00000100)        /*!<Burst enable bit           */
S#define  FMC_BCR3_WAITPOL                   ((uint32_t)0x00000200)        /*!<Wait signal polarity bit   */
S#define  FMC_BCR3_WRAPMOD                   ((uint32_t)0x00000400)        /*!<Wrapped burst mode support */
S#define  FMC_BCR3_WAITCFG                   ((uint32_t)0x00000800)        /*!<Wait timing configuration  */
S#define  FMC_BCR3_WREN                      ((uint32_t)0x00001000)        /*!<Write enable bit           */
S#define  FMC_BCR3_WAITEN                    ((uint32_t)0x00002000)        /*!<Wait enable bit            */
S#define  FMC_BCR3_EXTMOD                    ((uint32_t)0x00004000)        /*!<Extended mode enable       */
S#define  FMC_BCR3_ASYNCWAIT                 ((uint32_t)0x00008000)        /*!<Asynchronous wait          */
S#define  FMC_BCR3_CBURSTRW                  ((uint32_t)0x00080000)        /*!<Write burst enable         */
S
S/******************  Bit definition for FMC_BCR4 register  *******************/
S#define  FMC_BCR4_MBKEN                     ((uint32_t)0x00000001)        /*!<Memory bank enable bit                 */
S#define  FMC_BCR4_MUXEN                     ((uint32_t)0x00000002)        /*!<Address/data multiplexing enable bit   */
S
S#define  FMC_BCR4_MTYP                      ((uint32_t)0x0000000C)        /*!<MTYP[1:0] bits (Memory type)           */
S#define  FMC_BCR4_MTYP_0                    ((uint32_t)0x00000004)        /*!<Bit 0 */
S#define  FMC_BCR4_MTYP_1                    ((uint32_t)0x00000008)        /*!<Bit 1 */
S
S#define  FMC_BCR4_MWID                      ((uint32_t)0x00000030)        /*!<MWID[1:0] bits (Memory data bus width) */
S#define  FMC_BCR4_MWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_BCR4_MWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
S
S#define  FMC_BCR4_FACCEN                    ((uint32_t)0x00000040)        /*!<Flash access enable        */
S#define  FMC_BCR4_BURSTEN                   ((uint32_t)0x00000100)        /*!<Burst enable bit           */
S#define  FMC_BCR4_WAITPOL                   ((uint32_t)0x00000200)        /*!<Wait signal polarity bit   */
S#define  FMC_BCR4_WRAPMOD                   ((uint32_t)0x00000400)        /*!<Wrapped burst mode support */
S#define  FMC_BCR4_WAITCFG                   ((uint32_t)0x00000800)        /*!<Wait timing configuration  */
S#define  FMC_BCR4_WREN                      ((uint32_t)0x00001000)        /*!<Write enable bit           */
S#define  FMC_BCR4_WAITEN                    ((uint32_t)0x00002000)        /*!<Wait enable bit            */
S#define  FMC_BCR4_EXTMOD                    ((uint32_t)0x00004000)        /*!<Extended mode enable       */
S#define  FMC_BCR4_ASYNCWAIT                 ((uint32_t)0x00008000)        /*!<Asynchronous wait          */
S#define  FMC_BCR4_CBURSTRW                  ((uint32_t)0x00080000)        /*!<Write burst enable         */
S
S/******************  Bit definition for FMC_BTR1 register  ******************/
S#define  FMC_BTR1_ADDSET                    ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
S#define  FMC_BTR1_ADDSET_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_BTR1_ADDSET_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_BTR1_ADDSET_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_BTR1_ADDSET_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
S
S#define  FMC_BTR1_ADDHLD                    ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration)  */
S#define  FMC_BTR1_ADDHLD_0                  ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_BTR1_ADDHLD_1                  ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FMC_BTR1_ADDHLD_2                  ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FMC_BTR1_ADDHLD_3                  ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FMC_BTR1_DATAST                    ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
S#define  FMC_BTR1_DATAST_0                  ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_BTR1_DATAST_1                  ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_BTR1_DATAST_2                  ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_BTR1_DATAST_3                  ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_BTR1_DATAST_4                  ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_BTR1_DATAST_5                  ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_BTR1_DATAST_6                  ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_BTR1_DATAST_7                  ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_BTR1_BUSTURN                   ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
S#define  FMC_BTR1_BUSTURN_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_BTR1_BUSTURN_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_BTR1_BUSTURN_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_BTR1_BUSTURN_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
S
S#define  FMC_BTR1_CLKDIV                    ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FMC_BTR1_CLKDIV_0                  ((uint32_t)0x00100000)        /*!<Bit 0 */
S#define  FMC_BTR1_CLKDIV_1                  ((uint32_t)0x00200000)        /*!<Bit 1 */
S#define  FMC_BTR1_CLKDIV_2                  ((uint32_t)0x00400000)        /*!<Bit 2 */
S#define  FMC_BTR1_CLKDIV_3                  ((uint32_t)0x00800000)        /*!<Bit 3 */
S
S#define  FMC_BTR1_DATLAT                    ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
S#define  FMC_BTR1_DATLAT_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FMC_BTR1_DATLAT_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FMC_BTR1_DATLAT_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FMC_BTR1_DATLAT_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
S
S#define  FMC_BTR1_ACCMOD                    ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
S#define  FMC_BTR1_ACCMOD_0                  ((uint32_t)0x10000000)        /*!<Bit 0 */
S#define  FMC_BTR1_ACCMOD_1                  ((uint32_t)0x20000000)        /*!<Bit 1 */
S
S/******************  Bit definition for FMC_BTR2 register  *******************/
S#define  FMC_BTR2_ADDSET                    ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
S#define  FMC_BTR2_ADDSET_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_BTR2_ADDSET_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_BTR2_ADDSET_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_BTR2_ADDSET_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
S
S#define  FMC_BTR2_ADDHLD                    ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FMC_BTR2_ADDHLD_0                  ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_BTR2_ADDHLD_1                  ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FMC_BTR2_ADDHLD_2                  ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FMC_BTR2_ADDHLD_3                  ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FMC_BTR2_DATAST                    ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
S#define  FMC_BTR2_DATAST_0                  ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_BTR2_DATAST_1                  ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_BTR2_DATAST_2                  ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_BTR2_DATAST_3                  ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_BTR2_DATAST_4                  ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_BTR2_DATAST_5                  ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_BTR2_DATAST_6                  ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_BTR2_DATAST_7                  ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_BTR2_BUSTURN                   ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
S#define  FMC_BTR2_BUSTURN_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_BTR2_BUSTURN_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_BTR2_BUSTURN_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_BTR2_BUSTURN_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
S
S#define  FMC_BTR2_CLKDIV                    ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FMC_BTR2_CLKDIV_0                  ((uint32_t)0x00100000)        /*!<Bit 0 */
S#define  FMC_BTR2_CLKDIV_1                  ((uint32_t)0x00200000)        /*!<Bit 1 */
S#define  FMC_BTR2_CLKDIV_2                  ((uint32_t)0x00400000)        /*!<Bit 2 */
S#define  FMC_BTR2_CLKDIV_3                  ((uint32_t)0x00800000)        /*!<Bit 3 */
S
S#define  FMC_BTR2_DATLAT                    ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
S#define  FMC_BTR2_DATLAT_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FMC_BTR2_DATLAT_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FMC_BTR2_DATLAT_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FMC_BTR2_DATLAT_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
S
S#define  FMC_BTR2_ACCMOD                    ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
S#define  FMC_BTR2_ACCMOD_0                  ((uint32_t)0x10000000)        /*!<Bit 0 */
S#define  FMC_BTR2_ACCMOD_1                  ((uint32_t)0x20000000)        /*!<Bit 1 */
S
S/*******************  Bit definition for FMC_BTR3 register  *******************/
S#define  FMC_BTR3_ADDSET                    ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
S#define  FMC_BTR3_ADDSET_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_BTR3_ADDSET_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_BTR3_ADDSET_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_BTR3_ADDSET_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
S
S#define  FMC_BTR3_ADDHLD                    ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FMC_BTR3_ADDHLD_0                  ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_BTR3_ADDHLD_1                  ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FMC_BTR3_ADDHLD_2                  ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FMC_BTR3_ADDHLD_3                  ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FMC_BTR3_DATAST                    ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
S#define  FMC_BTR3_DATAST_0                  ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_BTR3_DATAST_1                  ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_BTR3_DATAST_2                  ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_BTR3_DATAST_3                  ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_BTR3_DATAST_4                  ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_BTR3_DATAST_5                  ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_BTR3_DATAST_6                  ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_BTR3_DATAST_7                  ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_BTR3_BUSTURN                   ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
S#define  FMC_BTR3_BUSTURN_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_BTR3_BUSTURN_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_BTR3_BUSTURN_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_BTR3_BUSTURN_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
S
S#define  FMC_BTR3_CLKDIV                    ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FMC_BTR3_CLKDIV_0                  ((uint32_t)0x00100000)        /*!<Bit 0 */
S#define  FMC_BTR3_CLKDIV_1                  ((uint32_t)0x00200000)        /*!<Bit 1 */
S#define  FMC_BTR3_CLKDIV_2                  ((uint32_t)0x00400000)        /*!<Bit 2 */
S#define  FMC_BTR3_CLKDIV_3                  ((uint32_t)0x00800000)        /*!<Bit 3 */
S
S#define  FMC_BTR3_DATLAT                    ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
S#define  FMC_BTR3_DATLAT_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FMC_BTR3_DATLAT_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FMC_BTR3_DATLAT_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FMC_BTR3_DATLAT_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
S
S#define  FMC_BTR3_ACCMOD                    ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
S#define  FMC_BTR3_ACCMOD_0                  ((uint32_t)0x10000000)        /*!<Bit 0 */
S#define  FMC_BTR3_ACCMOD_1                  ((uint32_t)0x20000000)        /*!<Bit 1 */
S
S/******************  Bit definition for FMC_BTR4 register  *******************/
S#define  FMC_BTR4_ADDSET                    ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
S#define  FMC_BTR4_ADDSET_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_BTR4_ADDSET_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_BTR4_ADDSET_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_BTR4_ADDSET_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
S
S#define  FMC_BTR4_ADDHLD                    ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FMC_BTR4_ADDHLD_0                  ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_BTR4_ADDHLD_1                  ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FMC_BTR4_ADDHLD_2                  ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FMC_BTR4_ADDHLD_3                  ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FMC_BTR4_DATAST                    ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
S#define  FMC_BTR4_DATAST_0                  ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_BTR4_DATAST_1                  ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_BTR4_DATAST_2                  ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_BTR4_DATAST_3                  ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_BTR4_DATAST_4                  ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_BTR4_DATAST_5                  ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_BTR4_DATAST_6                  ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_BTR4_DATAST_7                  ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_BTR4_BUSTURN                   ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround phase duration) */
S#define  FMC_BTR4_BUSTURN_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_BTR4_BUSTURN_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_BTR4_BUSTURN_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_BTR4_BUSTURN_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
S
S#define  FMC_BTR4_CLKDIV                    ((uint32_t)0x00F00000)        /*!<CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FMC_BTR4_CLKDIV_0                  ((uint32_t)0x00100000)        /*!<Bit 0 */
S#define  FMC_BTR4_CLKDIV_1                  ((uint32_t)0x00200000)        /*!<Bit 1 */
S#define  FMC_BTR4_CLKDIV_2                  ((uint32_t)0x00400000)        /*!<Bit 2 */
S#define  FMC_BTR4_CLKDIV_3                  ((uint32_t)0x00800000)        /*!<Bit 3 */
S
S#define  FMC_BTR4_DATLAT                    ((uint32_t)0x0F000000)        /*!<DATLA[3:0] bits (Data latency) */
S#define  FMC_BTR4_DATLAT_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FMC_BTR4_DATLAT_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FMC_BTR4_DATLAT_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FMC_BTR4_DATLAT_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
S
S#define  FMC_BTR4_ACCMOD                    ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
S#define  FMC_BTR4_ACCMOD_0                  ((uint32_t)0x10000000)        /*!<Bit 0 */
S#define  FMC_BTR4_ACCMOD_1                  ((uint32_t)0x20000000)        /*!<Bit 1 */
S
S/******************  Bit definition for FMC_BWTR1 register  ******************/
S#define  FMC_BWTR1_ADDSET                   ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
S#define  FMC_BWTR1_ADDSET_0                 ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_BWTR1_ADDSET_1                 ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_BWTR1_ADDSET_2                 ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_BWTR1_ADDSET_3                 ((uint32_t)0x00000008)        /*!<Bit 3 */
S
S#define  FMC_BWTR1_ADDHLD                   ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FMC_BWTR1_ADDHLD_0                 ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_BWTR1_ADDHLD_1                 ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FMC_BWTR1_ADDHLD_2                 ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FMC_BWTR1_ADDHLD_3                 ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FMC_BWTR1_DATAST                   ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
S#define  FMC_BWTR1_DATAST_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_BWTR1_DATAST_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_BWTR1_DATAST_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_BWTR1_DATAST_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_BWTR1_DATAST_4                 ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_BWTR1_DATAST_5                 ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_BWTR1_DATAST_6                 ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_BWTR1_DATAST_7                 ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_BWTR1_BUSTURN                  ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround duration) */
S#define  FMC_BWTR1_BUSTURN_0                ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_BWTR1_BUSTURN_1                ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_BWTR1_BUSTURN_2                ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_BWTR1_BUSTURN_3                ((uint32_t)0x00080000)        /*!<Bit 3 */
S
S#define  FMC_BWTR1_ACCMOD                   ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
S#define  FMC_BWTR1_ACCMOD_0                 ((uint32_t)0x10000000)        /*!<Bit 0 */
S#define  FMC_BWTR1_ACCMOD_1                 ((uint32_t)0x20000000)        /*!<Bit 1 */
S
S/******************  Bit definition for FMC_BWTR2 register  ******************/
S#define  FMC_BWTR2_ADDSET                   ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
S#define  FMC_BWTR2_ADDSET_0                 ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_BWTR2_ADDSET_1                 ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_BWTR2_ADDSET_2                 ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_BWTR2_ADDSET_3                 ((uint32_t)0x00000008)        /*!<Bit 3 */
S
S#define  FMC_BWTR2_ADDHLD                   ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FMC_BWTR2_ADDHLD_0                 ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_BWTR2_ADDHLD_1                 ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FMC_BWTR2_ADDHLD_2                 ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FMC_BWTR2_ADDHLD_3                 ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FMC_BWTR2_DATAST                   ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
S#define  FMC_BWTR2_DATAST_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_BWTR2_DATAST_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_BWTR2_DATAST_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_BWTR2_DATAST_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_BWTR2_DATAST_4                 ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_BWTR2_DATAST_5                 ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_BWTR2_DATAST_6                 ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_BWTR2_DATAST_7                 ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_BWTR2_BUSTURN                  ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround duration) */
S#define  FMC_BWTR2_BUSTURN_0                ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_BWTR2_BUSTURN_1                ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_BWTR2_BUSTURN_2                ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_BWTR2_BUSTURN_3                ((uint32_t)0x00080000)        /*!<Bit 3 */
S
S#define  FMC_BWTR2_ACCMOD                   ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
S#define  FMC_BWTR2_ACCMOD_0                 ((uint32_t)0x10000000)        /*!<Bit 0 */
S#define  FMC_BWTR2_ACCMOD_1                 ((uint32_t)0x20000000)        /*!<Bit 1 */
S
S/******************  Bit definition for FMC_BWTR3 register  ******************/
S#define  FMC_BWTR3_ADDSET                   ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
S#define  FMC_BWTR3_ADDSET_0                 ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_BWTR3_ADDSET_1                 ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_BWTR3_ADDSET_2                 ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_BWTR3_ADDSET_3                 ((uint32_t)0x00000008)        /*!<Bit 3 */
S
S#define  FMC_BWTR3_ADDHLD                   ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FMC_BWTR3_ADDHLD_0                 ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_BWTR3_ADDHLD_1                 ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FMC_BWTR3_ADDHLD_2                 ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FMC_BWTR3_ADDHLD_3                 ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FMC_BWTR3_DATAST                   ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
S#define  FMC_BWTR3_DATAST_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_BWTR3_DATAST_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_BWTR3_DATAST_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_BWTR3_DATAST_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_BWTR3_DATAST_4                 ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_BWTR3_DATAST_5                 ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_BWTR3_DATAST_6                 ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_BWTR3_DATAST_7                 ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_BWTR3_BUSTURN                  ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround duration) */
S#define  FMC_BWTR3_BUSTURN_0                ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_BWTR3_BUSTURN_1                ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_BWTR3_BUSTURN_2                ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_BWTR3_BUSTURN_3                ((uint32_t)0x00080000)        /*!<Bit 3 */
S
S#define  FMC_BWTR3_ACCMOD                   ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
S#define  FMC_BWTR3_ACCMOD_0                 ((uint32_t)0x10000000)        /*!<Bit 0 */
S#define  FMC_BWTR3_ACCMOD_1                 ((uint32_t)0x20000000)        /*!<Bit 1 */
S
S/******************  Bit definition for FMC_BWTR4 register  ******************/
S#define  FMC_BWTR4_ADDSET                   ((uint32_t)0x0000000F)        /*!<ADDSET[3:0] bits (Address setup phase duration) */
S#define  FMC_BWTR4_ADDSET_0                 ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_BWTR4_ADDSET_1                 ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_BWTR4_ADDSET_2                 ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_BWTR4_ADDSET_3                 ((uint32_t)0x00000008)        /*!<Bit 3 */
S
S#define  FMC_BWTR4_ADDHLD                   ((uint32_t)0x000000F0)        /*!<ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FMC_BWTR4_ADDHLD_0                 ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_BWTR4_ADDHLD_1                 ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FMC_BWTR4_ADDHLD_2                 ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FMC_BWTR4_ADDHLD_3                 ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FMC_BWTR4_DATAST                   ((uint32_t)0x0000FF00)        /*!<DATAST [3:0] bits (Data-phase duration) */
S#define  FMC_BWTR4_DATAST_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_BWTR4_DATAST_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_BWTR4_DATAST_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_BWTR4_DATAST_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_BWTR4_DATAST_4                 ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_BWTR4_DATAST_5                 ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_BWTR4_DATAST_6                 ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_BWTR4_DATAST_7                 ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_BWTR4_BUSTURN                  ((uint32_t)0x000F0000)        /*!<BUSTURN[3:0] bits (Bus turnaround duration) */
S#define  FMC_BWTR4_BUSTURN_0                ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_BWTR4_BUSTURN_1                ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_BWTR4_BUSTURN_2                ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_BWTR4_BUSTURN_3                ((uint32_t)0x00080000)        /*!<Bit 3 */
S
S#define  FMC_BWTR4_ACCMOD                   ((uint32_t)0x30000000)        /*!<ACCMOD[1:0] bits (Access mode) */
S#define  FMC_BWTR4_ACCMOD_0                 ((uint32_t)0x10000000)        /*!<Bit 0 */
S#define  FMC_BWTR4_ACCMOD_1                 ((uint32_t)0x20000000)        /*!<Bit 1 */
S
S/******************  Bit definition for FMC_PCR2 register  *******************/
S#define  FMC_PCR2_PWAITEN                   ((uint32_t)0x00000002)        /*!<Wait feature enable bit                   */
S#define  FMC_PCR2_PBKEN                     ((uint32_t)0x00000004)        /*!<PC Card/NAND Flash memory bank enable bit */
S#define  FMC_PCR2_PTYP                      ((uint32_t)0x00000008)        /*!<Memory type                               */
S
S#define  FMC_PCR2_PWID                      ((uint32_t)0x00000030)        /*!<PWID[1:0] bits (NAND Flash databus width) */
S#define  FMC_PCR2_PWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_PCR2_PWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
S
S#define  FMC_PCR2_ECCEN                     ((uint32_t)0x00000040)        /*!<ECC computation logic enable bit          */
S
S#define  FMC_PCR2_TCLR                      ((uint32_t)0x00001E00)        /*!<TCLR[3:0] bits (CLE to RE delay)          */
S#define  FMC_PCR2_TCLR_0                    ((uint32_t)0x00000200)        /*!<Bit 0 */
S#define  FMC_PCR2_TCLR_1                    ((uint32_t)0x00000400)        /*!<Bit 1 */
S#define  FMC_PCR2_TCLR_2                    ((uint32_t)0x00000800)        /*!<Bit 2 */
S#define  FMC_PCR2_TCLR_3                    ((uint32_t)0x00001000)        /*!<Bit 3 */
S
S#define  FMC_PCR2_TAR                       ((uint32_t)0x0001E000)        /*!<TAR[3:0] bits (ALE to RE delay)           */
S#define  FMC_PCR2_TAR_0                     ((uint32_t)0x00002000)        /*!<Bit 0 */
S#define  FMC_PCR2_TAR_1                     ((uint32_t)0x00004000)        /*!<Bit 1 */
S#define  FMC_PCR2_TAR_2                     ((uint32_t)0x00008000)        /*!<Bit 2 */
S#define  FMC_PCR2_TAR_3                     ((uint32_t)0x00010000)        /*!<Bit 3 */
S
S#define  FMC_PCR2_ECCPS                     ((uint32_t)0x000E0000)        /*!<ECCPS[1:0] bits (ECC page size)           */
S#define  FMC_PCR2_ECCPS_0                   ((uint32_t)0x00020000)        /*!<Bit 0 */
S#define  FMC_PCR2_ECCPS_1                   ((uint32_t)0x00040000)        /*!<Bit 1 */
S#define  FMC_PCR2_ECCPS_2                   ((uint32_t)0x00080000)        /*!<Bit 2 */
S
S/******************  Bit definition for FMC_PCR3 register  *******************/
S#define  FMC_PCR3_PWAITEN                   ((uint32_t)0x00000002)        /*!<Wait feature enable bit                   */
S#define  FMC_PCR3_PBKEN                     ((uint32_t)0x00000004)        /*!<PC Card/NAND Flash memory bank enable bit */
S#define  FMC_PCR3_PTYP                      ((uint32_t)0x00000008)        /*!<Memory type                               */
S
S#define  FMC_PCR3_PWID                      ((uint32_t)0x00000030)        /*!<PWID[1:0] bits (NAND Flash databus width) */
S#define  FMC_PCR3_PWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_PCR3_PWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
S
S#define  FMC_PCR3_ECCEN                     ((uint32_t)0x00000040)        /*!<ECC computation logic enable bit          */
S
S#define  FMC_PCR3_TCLR                      ((uint32_t)0x00001E00)        /*!<TCLR[3:0] bits (CLE to RE delay)          */
S#define  FMC_PCR3_TCLR_0                    ((uint32_t)0x00000200)        /*!<Bit 0 */
S#define  FMC_PCR3_TCLR_1                    ((uint32_t)0x00000400)        /*!<Bit 1 */
S#define  FMC_PCR3_TCLR_2                    ((uint32_t)0x00000800)        /*!<Bit 2 */
S#define  FMC_PCR3_TCLR_3                    ((uint32_t)0x00001000)        /*!<Bit 3 */
S
S#define  FMC_PCR3_TAR                       ((uint32_t)0x0001E000)        /*!<TAR[3:0] bits (ALE to RE delay)           */
S#define  FMC_PCR3_TAR_0                     ((uint32_t)0x00002000)        /*!<Bit 0 */
S#define  FMC_PCR3_TAR_1                     ((uint32_t)0x00004000)        /*!<Bit 1 */
S#define  FMC_PCR3_TAR_2                     ((uint32_t)0x00008000)        /*!<Bit 2 */
S#define  FMC_PCR3_TAR_3                     ((uint32_t)0x00010000)        /*!<Bit 3 */
S
S#define  FMC_PCR3_ECCPS                     ((uint32_t)0x000E0000)        /*!<ECCPS[2:0] bits (ECC page size)           */
S#define  FMC_PCR3_ECCPS_0                   ((uint32_t)0x00020000)        /*!<Bit 0 */
S#define  FMC_PCR3_ECCPS_1                   ((uint32_t)0x00040000)        /*!<Bit 1 */
S#define  FMC_PCR3_ECCPS_2                   ((uint32_t)0x00080000)        /*!<Bit 2 */
S
S/******************  Bit definition for FMC_PCR4 register  *******************/
S#define  FMC_PCR4_PWAITEN                   ((uint32_t)0x00000002)        /*!<Wait feature enable bit                   */
S#define  FMC_PCR4_PBKEN                     ((uint32_t)0x00000004)        /*!<PC Card/NAND Flash memory bank enable bit */
S#define  FMC_PCR4_PTYP                      ((uint32_t)0x00000008)        /*!<Memory type                               */
S
S#define  FMC_PCR4_PWID                      ((uint32_t)0x00000030)        /*!<PWID[1:0] bits (NAND Flash databus width) */
S#define  FMC_PCR4_PWID_0                    ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_PCR4_PWID_1                    ((uint32_t)0x00000020)        /*!<Bit 1 */
S
S#define  FMC_PCR4_ECCEN                     ((uint32_t)0x00000040)        /*!<ECC computation logic enable bit          */
S
S#define  FMC_PCR4_TCLR                      ((uint32_t)0x00001E00)        /*!<TCLR[3:0] bits (CLE to RE delay)          */
S#define  FMC_PCR4_TCLR_0                    ((uint32_t)0x00000200)        /*!<Bit 0 */
S#define  FMC_PCR4_TCLR_1                    ((uint32_t)0x00000400)        /*!<Bit 1 */
S#define  FMC_PCR4_TCLR_2                    ((uint32_t)0x00000800)        /*!<Bit 2 */
S#define  FMC_PCR4_TCLR_3                    ((uint32_t)0x00001000)        /*!<Bit 3 */
S
S#define  FMC_PCR4_TAR                       ((uint32_t)0x0001E000)        /*!<TAR[3:0] bits (ALE to RE delay)           */
S#define  FMC_PCR4_TAR_0                     ((uint32_t)0x00002000)        /*!<Bit 0 */
S#define  FMC_PCR4_TAR_1                     ((uint32_t)0x00004000)        /*!<Bit 1 */
S#define  FMC_PCR4_TAR_2                     ((uint32_t)0x00008000)        /*!<Bit 2 */
S#define  FMC_PCR4_TAR_3                     ((uint32_t)0x00010000)        /*!<Bit 3 */
S
S#define  FMC_PCR4_ECCPS                     ((uint32_t)0x000E0000)        /*!<ECCPS[2:0] bits (ECC page size)           */
S#define  FMC_PCR4_ECCPS_0                   ((uint32_t)0x00020000)        /*!<Bit 0 */
S#define  FMC_PCR4_ECCPS_1                   ((uint32_t)0x00040000)        /*!<Bit 1 */
S#define  FMC_PCR4_ECCPS_2                   ((uint32_t)0x00080000)        /*!<Bit 2 */
S
S/*******************  Bit definition for FMC_SR2 register  *******************/
S#define  FMC_SR2_IRS                        ((uint8_t)0x01)               /*!<Interrupt Rising Edge status                */
S#define  FMC_SR2_ILS                        ((uint8_t)0x02)               /*!<Interrupt Level status                      */
S#define  FMC_SR2_IFS                        ((uint8_t)0x04)               /*!<Interrupt Falling Edge status               */
S#define  FMC_SR2_IREN                       ((uint8_t)0x08)               /*!<Interrupt Rising Edge detection Enable bit  */
S#define  FMC_SR2_ILEN                       ((uint8_t)0x10)               /*!<Interrupt Level detection Enable bit        */
S#define  FMC_SR2_IFEN                       ((uint8_t)0x20)               /*!<Interrupt Falling Edge detection Enable bit */
S#define  FMC_SR2_FEMPT                      ((uint8_t)0x40)               /*!<FIFO empty                                  */
S
S/*******************  Bit definition for FMC_SR3 register  *******************/
S#define  FMC_SR3_IRS                        ((uint8_t)0x01)               /*!<Interrupt Rising Edge status                */
S#define  FMC_SR3_ILS                        ((uint8_t)0x02)               /*!<Interrupt Level status                      */
S#define  FMC_SR3_IFS                        ((uint8_t)0x04)               /*!<Interrupt Falling Edge status               */
S#define  FMC_SR3_IREN                       ((uint8_t)0x08)               /*!<Interrupt Rising Edge detection Enable bit  */
S#define  FMC_SR3_ILEN                       ((uint8_t)0x10)               /*!<Interrupt Level detection Enable bit        */
S#define  FMC_SR3_IFEN                       ((uint8_t)0x20)               /*!<Interrupt Falling Edge detection Enable bit */
S#define  FMC_SR3_FEMPT                      ((uint8_t)0x40)               /*!<FIFO empty                                  */
S
S/*******************  Bit definition for FMC_SR4 register  *******************/
S#define  FMC_SR4_IRS                        ((uint8_t)0x01)               /*!<Interrupt Rising Edge status                */
S#define  FMC_SR4_ILS                        ((uint8_t)0x02)               /*!<Interrupt Level status                      */
S#define  FMC_SR4_IFS                        ((uint8_t)0x04)               /*!<Interrupt Falling Edge status               */
S#define  FMC_SR4_IREN                       ((uint8_t)0x08)               /*!<Interrupt Rising Edge detection Enable bit  */
S#define  FMC_SR4_ILEN                       ((uint8_t)0x10)               /*!<Interrupt Level detection Enable bit        */
S#define  FMC_SR4_IFEN                       ((uint8_t)0x20)               /*!<Interrupt Falling Edge detection Enable bit */
S#define  FMC_SR4_FEMPT                      ((uint8_t)0x40)               /*!<FIFO empty                                  */
S
S/******************  Bit definition for FMC_PMEM2 register  ******************/
S#define  FMC_PMEM2_MEMSET2                  ((uint32_t)0x000000FF)        /*!<MEMSET2[7:0] bits (Common memory 2 setup time) */
S#define  FMC_PMEM2_MEMSET2_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_PMEM2_MEMSET2_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_PMEM2_MEMSET2_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_PMEM2_MEMSET2_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  FMC_PMEM2_MEMSET2_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  FMC_PMEM2_MEMSET2_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
S#define  FMC_PMEM2_MEMSET2_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
S#define  FMC_PMEM2_MEMSET2_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
S
S#define  FMC_PMEM2_MEMWAIT2                 ((uint32_t)0x0000FF00)        /*!<MEMWAIT2[7:0] bits (Common memory 2 wait time) */
S#define  FMC_PMEM2_MEMWAIT2_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_PMEM2_MEMWAIT2_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_PMEM2_MEMWAIT2_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_PMEM2_MEMWAIT2_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_PMEM2_MEMWAIT2_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_PMEM2_MEMWAIT2_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_PMEM2_MEMWAIT2_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_PMEM2_MEMWAIT2_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_PMEM2_MEMHOLD2                 ((uint32_t)0x00FF0000)        /*!<MEMHOLD2[7:0] bits (Common memory 2 hold time) */
S#define  FMC_PMEM2_MEMHOLD2_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_PMEM2_MEMHOLD2_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_PMEM2_MEMHOLD2_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_PMEM2_MEMHOLD2_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
S#define  FMC_PMEM2_MEMHOLD2_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
S#define  FMC_PMEM2_MEMHOLD2_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
S#define  FMC_PMEM2_MEMHOLD2_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
S#define  FMC_PMEM2_MEMHOLD2_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
S
S#define  FMC_PMEM2_MEMHIZ2                  ((uint32_t)0xFF000000)        /*!<MEMHIZ2[7:0] bits (Common memory 2 databus HiZ time) */
S#define  FMC_PMEM2_MEMHIZ2_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FMC_PMEM2_MEMHIZ2_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FMC_PMEM2_MEMHIZ2_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FMC_PMEM2_MEMHIZ2_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
S#define  FMC_PMEM2_MEMHIZ2_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
S#define  FMC_PMEM2_MEMHIZ2_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
S#define  FMC_PMEM2_MEMHIZ2_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
S#define  FMC_PMEM2_MEMHIZ2_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
S
S/******************  Bit definition for FMC_PMEM3 register  ******************/
S#define  FMC_PMEM3_MEMSET3                  ((uint32_t)0x000000FF)        /*!<MEMSET3[7:0] bits (Common memory 3 setup time) */
S#define  FMC_PMEM3_MEMSET3_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_PMEM3_MEMSET3_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_PMEM3_MEMSET3_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_PMEM3_MEMSET3_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  FMC_PMEM3_MEMSET3_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  FMC_PMEM3_MEMSET3_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
S#define  FMC_PMEM3_MEMSET3_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
S#define  FMC_PMEM3_MEMSET3_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
S
S#define  FMC_PMEM3_MEMWAIT3                 ((uint32_t)0x0000FF00)        /*!<MEMWAIT3[7:0] bits (Common memory 3 wait time) */
S#define  FMC_PMEM3_MEMWAIT3_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_PMEM3_MEMWAIT3_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_PMEM3_MEMWAIT3_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_PMEM3_MEMWAIT3_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_PMEM3_MEMWAIT3_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_PMEM3_MEMWAIT3_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_PMEM3_MEMWAIT3_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_PMEM3_MEMWAIT3_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_PMEM3_MEMHOLD3                 ((uint32_t)0x00FF0000)        /*!<MEMHOLD3[7:0] bits (Common memory 3 hold time) */
S#define  FMC_PMEM3_MEMHOLD3_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_PMEM3_MEMHOLD3_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_PMEM3_MEMHOLD3_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_PMEM3_MEMHOLD3_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
S#define  FMC_PMEM3_MEMHOLD3_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
S#define  FMC_PMEM3_MEMHOLD3_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
S#define  FMC_PMEM3_MEMHOLD3_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
S#define  FMC_PMEM3_MEMHOLD3_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
S
S#define  FMC_PMEM3_MEMHIZ3                  ((uint32_t)0xFF000000)        /*!<MEMHIZ3[7:0] bits (Common memory 3 databus HiZ time) */
S#define  FMC_PMEM3_MEMHIZ3_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FMC_PMEM3_MEMHIZ3_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FMC_PMEM3_MEMHIZ3_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FMC_PMEM3_MEMHIZ3_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
S#define  FMC_PMEM3_MEMHIZ3_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
S#define  FMC_PMEM3_MEMHIZ3_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
S#define  FMC_PMEM3_MEMHIZ3_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
S#define  FMC_PMEM3_MEMHIZ3_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
S
S/******************  Bit definition for FMC_PMEM4 register  ******************/
S#define  FMC_PMEM4_MEMSET4                  ((uint32_t)0x000000FF)        /*!<MEMSET4[7:0] bits (Common memory 4 setup time) */
S#define  FMC_PMEM4_MEMSET4_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_PMEM4_MEMSET4_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_PMEM4_MEMSET4_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_PMEM4_MEMSET4_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  FMC_PMEM4_MEMSET4_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  FMC_PMEM4_MEMSET4_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
S#define  FMC_PMEM4_MEMSET4_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
S#define  FMC_PMEM4_MEMSET4_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
S
S#define  FMC_PMEM4_MEMWAIT4                 ((uint32_t)0x0000FF00)        /*!<MEMWAIT4[7:0] bits (Common memory 4 wait time) */
S#define  FMC_PMEM4_MEMWAIT4_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_PMEM4_MEMWAIT4_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_PMEM4_MEMWAIT4_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_PMEM4_MEMWAIT4_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_PMEM4_MEMWAIT4_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_PMEM4_MEMWAIT4_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_PMEM4_MEMWAIT4_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_PMEM4_MEMWAIT4_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_PMEM4_MEMHOLD4                 ((uint32_t)0x00FF0000)        /*!<MEMHOLD4[7:0] bits (Common memory 4 hold time) */
S#define  FMC_PMEM4_MEMHOLD4_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_PMEM4_MEMHOLD4_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_PMEM4_MEMHOLD4_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_PMEM4_MEMHOLD4_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
S#define  FMC_PMEM4_MEMHOLD4_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
S#define  FMC_PMEM4_MEMHOLD4_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
S#define  FMC_PMEM4_MEMHOLD4_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
S#define  FMC_PMEM4_MEMHOLD4_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
S
S#define  FMC_PMEM4_MEMHIZ4                  ((uint32_t)0xFF000000)        /*!<MEMHIZ4[7:0] bits (Common memory 4 databus HiZ time) */
S#define  FMC_PMEM4_MEMHIZ4_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FMC_PMEM4_MEMHIZ4_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FMC_PMEM4_MEMHIZ4_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FMC_PMEM4_MEMHIZ4_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
S#define  FMC_PMEM4_MEMHIZ4_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
S#define  FMC_PMEM4_MEMHIZ4_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
S#define  FMC_PMEM4_MEMHIZ4_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
S#define  FMC_PMEM4_MEMHIZ4_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
S
S/******************  Bit definition for FMC_PATT2 register  ******************/
S#define  FMC_PATT2_ATTSET2                  ((uint32_t)0x000000FF)        /*!<ATTSET2[7:0] bits (Attribute memory 2 setup time) */
S#define  FMC_PATT2_ATTSET2_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_PATT2_ATTSET2_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_PATT2_ATTSET2_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_PATT2_ATTSET2_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  FMC_PATT2_ATTSET2_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  FMC_PATT2_ATTSET2_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
S#define  FMC_PATT2_ATTSET2_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
S#define  FMC_PATT2_ATTSET2_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
S
S#define  FMC_PATT2_ATTWAIT2                 ((uint32_t)0x0000FF00)        /*!<ATTWAIT2[7:0] bits (Attribute memory 2 wait time) */
S#define  FMC_PATT2_ATTWAIT2_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_PATT2_ATTWAIT2_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_PATT2_ATTWAIT2_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_PATT2_ATTWAIT2_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_PATT2_ATTWAIT2_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_PATT2_ATTWAIT2_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_PATT2_ATTWAIT2_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_PATT2_ATTWAIT2_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_PATT2_ATTHOLD2                 ((uint32_t)0x00FF0000)        /*!<ATTHOLD2[7:0] bits (Attribute memory 2 hold time) */
S#define  FMC_PATT2_ATTHOLD2_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_PATT2_ATTHOLD2_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_PATT2_ATTHOLD2_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_PATT2_ATTHOLD2_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
S#define  FMC_PATT2_ATTHOLD2_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
S#define  FMC_PATT2_ATTHOLD2_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
S#define  FMC_PATT2_ATTHOLD2_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
S#define  FMC_PATT2_ATTHOLD2_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
S
S#define  FMC_PATT2_ATTHIZ2                  ((uint32_t)0xFF000000)        /*!<ATTHIZ2[7:0] bits (Attribute memory 2 databus HiZ time) */
S#define  FMC_PATT2_ATTHIZ2_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FMC_PATT2_ATTHIZ2_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FMC_PATT2_ATTHIZ2_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FMC_PATT2_ATTHIZ2_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
S#define  FMC_PATT2_ATTHIZ2_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
S#define  FMC_PATT2_ATTHIZ2_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
S#define  FMC_PATT2_ATTHIZ2_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
S#define  FMC_PATT2_ATTHIZ2_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
S
S/******************  Bit definition for FMC_PATT3 register  ******************/
S#define  FMC_PATT3_ATTSET3                  ((uint32_t)0x000000FF)        /*!<ATTSET3[7:0] bits (Attribute memory 3 setup time) */
S#define  FMC_PATT3_ATTSET3_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_PATT3_ATTSET3_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_PATT3_ATTSET3_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_PATT3_ATTSET3_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  FMC_PATT3_ATTSET3_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  FMC_PATT3_ATTSET3_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
S#define  FMC_PATT3_ATTSET3_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
S#define  FMC_PATT3_ATTSET3_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
S
S#define  FMC_PATT3_ATTWAIT3                 ((uint32_t)0x0000FF00)        /*!<ATTWAIT3[7:0] bits (Attribute memory 3 wait time) */
S#define  FMC_PATT3_ATTWAIT3_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_PATT3_ATTWAIT3_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_PATT3_ATTWAIT3_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_PATT3_ATTWAIT3_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_PATT3_ATTWAIT3_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_PATT3_ATTWAIT3_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_PATT3_ATTWAIT3_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_PATT3_ATTWAIT3_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_PATT3_ATTHOLD3                 ((uint32_t)0x00FF0000)        /*!<ATTHOLD3[7:0] bits (Attribute memory 3 hold time) */
S#define  FMC_PATT3_ATTHOLD3_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_PATT3_ATTHOLD3_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_PATT3_ATTHOLD3_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_PATT3_ATTHOLD3_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
S#define  FMC_PATT3_ATTHOLD3_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
S#define  FMC_PATT3_ATTHOLD3_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
S#define  FMC_PATT3_ATTHOLD3_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
S#define  FMC_PATT3_ATTHOLD3_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
S
S#define  FMC_PATT3_ATTHIZ3                  ((uint32_t)0xFF000000)        /*!<ATTHIZ3[7:0] bits (Attribute memory 3 databus HiZ time) */
S#define  FMC_PATT3_ATTHIZ3_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FMC_PATT3_ATTHIZ3_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FMC_PATT3_ATTHIZ3_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FMC_PATT3_ATTHIZ3_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
S#define  FMC_PATT3_ATTHIZ3_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
S#define  FMC_PATT3_ATTHIZ3_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
S#define  FMC_PATT3_ATTHIZ3_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
S#define  FMC_PATT3_ATTHIZ3_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
S
S/******************  Bit definition for FMC_PATT4 register  ******************/
S#define  FMC_PATT4_ATTSET4                  ((uint32_t)0x000000FF)        /*!<ATTSET4[7:0] bits (Attribute memory 4 setup time) */
S#define  FMC_PATT4_ATTSET4_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_PATT4_ATTSET4_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_PATT4_ATTSET4_2                ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_PATT4_ATTSET4_3                ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  FMC_PATT4_ATTSET4_4                ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  FMC_PATT4_ATTSET4_5                ((uint32_t)0x00000020)        /*!<Bit 5 */
S#define  FMC_PATT4_ATTSET4_6                ((uint32_t)0x00000040)        /*!<Bit 6 */
S#define  FMC_PATT4_ATTSET4_7                ((uint32_t)0x00000080)        /*!<Bit 7 */
S
S#define  FMC_PATT4_ATTWAIT4                 ((uint32_t)0x0000FF00)        /*!<ATTWAIT4[7:0] bits (Attribute memory 4 wait time) */
S#define  FMC_PATT4_ATTWAIT4_0               ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_PATT4_ATTWAIT4_1               ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_PATT4_ATTWAIT4_2               ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_PATT4_ATTWAIT4_3               ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_PATT4_ATTWAIT4_4               ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_PATT4_ATTWAIT4_5               ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_PATT4_ATTWAIT4_6               ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_PATT4_ATTWAIT4_7               ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_PATT4_ATTHOLD4                 ((uint32_t)0x00FF0000)        /*!<ATTHOLD4[7:0] bits (Attribute memory 4 hold time) */
S#define  FMC_PATT4_ATTHOLD4_0               ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_PATT4_ATTHOLD4_1               ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_PATT4_ATTHOLD4_2               ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_PATT4_ATTHOLD4_3               ((uint32_t)0x00080000)        /*!<Bit 3 */
S#define  FMC_PATT4_ATTHOLD4_4               ((uint32_t)0x00100000)        /*!<Bit 4 */
S#define  FMC_PATT4_ATTHOLD4_5               ((uint32_t)0x00200000)        /*!<Bit 5 */
S#define  FMC_PATT4_ATTHOLD4_6               ((uint32_t)0x00400000)        /*!<Bit 6 */
S#define  FMC_PATT4_ATTHOLD4_7               ((uint32_t)0x00800000)        /*!<Bit 7 */
S
S#define  FMC_PATT4_ATTHIZ4                  ((uint32_t)0xFF000000)        /*!<ATTHIZ4[7:0] bits (Attribute memory 4 databus HiZ time) */
S#define  FMC_PATT4_ATTHIZ4_0                ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FMC_PATT4_ATTHIZ4_1                ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FMC_PATT4_ATTHIZ4_2                ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FMC_PATT4_ATTHIZ4_3                ((uint32_t)0x08000000)        /*!<Bit 3 */
S#define  FMC_PATT4_ATTHIZ4_4                ((uint32_t)0x10000000)        /*!<Bit 4 */
S#define  FMC_PATT4_ATTHIZ4_5                ((uint32_t)0x20000000)        /*!<Bit 5 */
S#define  FMC_PATT4_ATTHIZ4_6                ((uint32_t)0x40000000)        /*!<Bit 6 */
S#define  FMC_PATT4_ATTHIZ4_7                ((uint32_t)0x80000000)        /*!<Bit 7 */
S
S/******************  Bit definition for FMC_PIO4 register  *******************/
S#define  FMC_PIO4_IOSET4                    ((uint32_t)0x000000FF)        /*!<IOSET4[7:0] bits (I/O 4 setup time) */
S#define  FMC_PIO4_IOSET4_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_PIO4_IOSET4_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_PIO4_IOSET4_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_PIO4_IOSET4_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  FMC_PIO4_IOSET4_4                  ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  FMC_PIO4_IOSET4_5                  ((uint32_t)0x00000020)        /*!<Bit 5 */
S#define  FMC_PIO4_IOSET4_6                  ((uint32_t)0x00000040)        /*!<Bit 6 */
S#define  FMC_PIO4_IOSET4_7                  ((uint32_t)0x00000080)        /*!<Bit 7 */
S
S#define  FMC_PIO4_IOWAIT4                   ((uint32_t)0x0000FF00)        /*!<IOWAIT4[7:0] bits (I/O 4 wait time) */
S#define  FMC_PIO4_IOWAIT4_0                 ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_PIO4_IOWAIT4_1                 ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_PIO4_IOWAIT4_2                 ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_PIO4_IOWAIT4_3                 ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  FMC_PIO4_IOWAIT4_4                 ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  FMC_PIO4_IOWAIT4_5                 ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  FMC_PIO4_IOWAIT4_6                 ((uint32_t)0x00004000)        /*!<Bit 6 */
S#define  FMC_PIO4_IOWAIT4_7                 ((uint32_t)0x00008000)        /*!<Bit 7 */
S
S#define  FMC_PIO4_IOHOLD4                   ((uint32_t)0x00FF0000)        /*!<IOHOLD4[7:0] bits (I/O 4 hold time) */
S#define  FMC_PIO4_IOHOLD4_0                 ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_PIO4_IOHOLD4_1                 ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_PIO4_IOHOLD4_2                 ((uint32_t)0x00040000)        /*!<Bit 2 */
S#define  FMC_PIO4_IOHOLD4_3                 ((uint32_t)0x00080000)        /*!<Bit 3 */
S#define  FMC_PIO4_IOHOLD4_4                 ((uint32_t)0x00100000)        /*!<Bit 4 */
S#define  FMC_PIO4_IOHOLD4_5                 ((uint32_t)0x00200000)        /*!<Bit 5 */
S#define  FMC_PIO4_IOHOLD4_6                 ((uint32_t)0x00400000)        /*!<Bit 6 */
S#define  FMC_PIO4_IOHOLD4_7                 ((uint32_t)0x00800000)        /*!<Bit 7 */
S
S#define  FMC_PIO4_IOHIZ4                    ((uint32_t)0xFF000000)        /*!<IOHIZ4[7:0] bits (I/O 4 databus HiZ time) */
S#define  FMC_PIO4_IOHIZ4_0                  ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FMC_PIO4_IOHIZ4_1                  ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FMC_PIO4_IOHIZ4_2                  ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  FMC_PIO4_IOHIZ4_3                  ((uint32_t)0x08000000)        /*!<Bit 3 */
S#define  FMC_PIO4_IOHIZ4_4                  ((uint32_t)0x10000000)        /*!<Bit 4 */
S#define  FMC_PIO4_IOHIZ4_5                  ((uint32_t)0x20000000)        /*!<Bit 5 */
S#define  FMC_PIO4_IOHIZ4_6                  ((uint32_t)0x40000000)        /*!<Bit 6 */
S#define  FMC_PIO4_IOHIZ4_7                  ((uint32_t)0x80000000)        /*!<Bit 7 */
S
S/******************  Bit definition for FMC_ECCR2 register  ******************/
S#define  FMC_ECCR2_ECC2                     ((uint32_t)0xFFFFFFFF)        /*!<ECC result */
S
S/******************  Bit definition for FMC_ECCR3 register  ******************/
S#define  FMC_ECCR3_ECC3                     ((uint32_t)0xFFFFFFFF)        /*!<ECC result */
S
S/******************  Bit definition for FMC_SDCR1 register  ******************/
S#define  FMC_SDCR1_NC                       ((uint32_t)0x00000003)        /*!<NC[1:0] bits (Number of column bits) */
S#define  FMC_SDCR1_NC_0                     ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_SDCR1_NC_1                     ((uint32_t)0x00000002)        /*!<Bit 1 */
S
S#define  FMC_SDCR1_NR                       ((uint32_t)0x0000000C)        /*!<NR[1:0] bits (Number of row bits) */
S#define  FMC_SDCR1_NR_0                     ((uint32_t)0x00000004)        /*!<Bit 0 */
S#define  FMC_SDCR1_NR_1                     ((uint32_t)0x00000008)        /*!<Bit 1 */
S
S#define  FMC_SDCR1_MWID                     ((uint32_t)0x00000030)        /*!<NR[1:0] bits (Number of row bits) */
S#define  FMC_SDCR1_MWID_0                   ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_SDCR1_MWID_1                   ((uint32_t)0x00000020)        /*!<Bit 1 */
S
S#define  FMC_SDCR1_NB                       ((uint32_t)0x00000040)        /*!<Number of internal bank */
S
S#define  FMC_SDCR1_CAS                      ((uint32_t)0x00000180)        /*!<CAS[1:0] bits (CAS latency) */
S#define  FMC_SDCR1_CAS_0                    ((uint32_t)0x00000080)        /*!<Bit 0 */
S#define  FMC_SDCR1_CAS_1                    ((uint32_t)0x00000100)        /*!<Bit 1 */
S
S#define  FMC_SDCR1_WP                       ((uint32_t)0x00000200)        /*!<Write protection */
S
S#define  FMC_SDCR1_SDCLK                    ((uint32_t)0x00000C00)        /*!<SDRAM clock configuration */
S#define  FMC_SDCR1_SDCLK_0                  ((uint32_t)0x00000400)        /*!<Bit 0 */
S#define  FMC_SDCR1_SDCLK_1                  ((uint32_t)0x00000800)        /*!<Bit 1 */
S
S#define  FMC_SDCR1_RBURST                   ((uint32_t)0x00001000)        /*!<Read burst */
S
S#define  FMC_SDCR1_RPIPE                    ((uint32_t)0x00006000)        /*!<Write protection */
S#define  FMC_SDCR1_RPIPE_0                  ((uint32_t)0x00002000)        /*!<Bit 0 */
S#define  FMC_SDCR1_RPIPE_1                  ((uint32_t)0x00004000)        /*!<Bit 1 */
S
S/******************  Bit definition for FMC_SDCR2 register  ******************/
S#define  FMC_SDCR2_NC                       ((uint32_t)0x00000003)        /*!<NC[1:0] bits (Number of column bits) */
S#define  FMC_SDCR2_NC_0                     ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_SDCR2_NC_1                     ((uint32_t)0x00000002)        /*!<Bit 1 */
S
S#define  FMC_SDCR2_NR                       ((uint32_t)0x0000000C)        /*!<NR[1:0] bits (Number of row bits) */
S#define  FMC_SDCR2_NR_0                     ((uint32_t)0x00000004)        /*!<Bit 0 */
S#define  FMC_SDCR2_NR_1                     ((uint32_t)0x00000008)        /*!<Bit 1 */
S
S#define  FMC_SDCR2_MWID                     ((uint32_t)0x00000030)        /*!<NR[1:0] bits (Number of row bits) */
S#define  FMC_SDCR2_MWID_0                   ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_SDCR2_MWID_1                   ((uint32_t)0x00000020)        /*!<Bit 1 */
S
S#define  FMC_SDCR2_NB                       ((uint32_t)0x00000040)        /*!<Number of internal bank */
S
S#define  FMC_SDCR2_CAS                      ((uint32_t)0x00000180)        /*!<CAS[1:0] bits (CAS latency) */
S#define  FMC_SDCR2_CAS_0                    ((uint32_t)0x00000080)        /*!<Bit 0 */
S#define  FMC_SDCR2_CAS_1                    ((uint32_t)0x00000100)        /*!<Bit 1 */
S
S#define  FMC_SDCR2_WP                       ((uint32_t)0x00000200)        /*!<Write protection */
S
S#define  FMC_SDCR2_SDCLK                    ((uint32_t)0x00000C00)        /*!<SDCLK[1:0] (SDRAM clock configuration) */
S#define  FMC_SDCR2_SDCLK_0                  ((uint32_t)0x00000400)        /*!<Bit 0 */
S#define  FMC_SDCR2_SDCLK_1                  ((uint32_t)0x00000800)        /*!<Bit 1 */
S
S#define  FMC_SDCR2_RBURST                   ((uint32_t)0x00001000)        /*!<Read burst */
S
S#define  FMC_SDCR2_RPIPE                    ((uint32_t)0x00006000)        /*!<RPIPE[1:0](Read pipe) */
S#define  FMC_SDCR2_RPIPE_0                  ((uint32_t)0x00002000)        /*!<Bit 0 */
S#define  FMC_SDCR2_RPIPE_1                  ((uint32_t)0x00004000)        /*!<Bit 1 */
S
S/******************  Bit definition for FMC_SDTR1 register  ******************/
S#define  FMC_SDTR1_TMRD                     ((uint32_t)0x0000000F)        /*!<TMRD[3:0] bits (Load mode register to active) */
S#define  FMC_SDTR1_TMRD_0                   ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_SDTR1_TMRD_1                   ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_SDTR1_TMRD_2                   ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_SDTR1_TMRD_3                   ((uint32_t)0x00000008)        /*!<Bit 3 */
S                                            
S#define  FMC_SDTR1_TXSR                     ((uint32_t)0x000000F0)        /*!<TXSR[3:0] bits (Exit self refresh) */
S#define  FMC_SDTR1_TXSR_0                   ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_SDTR1_TXSR_1                   ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FMC_SDTR1_TXSR_2                   ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FMC_SDTR1_TXSR_3                   ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FMC_SDTR1_TRAS                     ((uint32_t)0x00000F00)        /*!<TRAS[3:0] bits (Self refresh time) */
S#define  FMC_SDTR1_TRAS_0                   ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_SDTR1_TRAS_1                   ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_SDTR1_TRAS_2                   ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_SDTR1_TRAS_3                   ((uint32_t)0x00000800)        /*!<Bit 3 */
S
S#define  FMC_SDTR1_TRC                      ((uint32_t)0x0000F000)        /*!<TRC[2:0] bits (Row cycle delay) */
S#define  FMC_SDTR1_TRC_0                    ((uint32_t)0x00001000)        /*!<Bit 0 */
S#define  FMC_SDTR1_TRC_1                    ((uint32_t)0x00002000)        /*!<Bit 1 */
S#define  FMC_SDTR1_TRC_2                    ((uint32_t)0x00004000)        /*!<Bit 2 */
S
S#define  FMC_SDTR1_TWR                      ((uint32_t)0x000F0000)        /*!<TRC[2:0] bits (Write recovery delay) */
S#define  FMC_SDTR1_TWR_0                    ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_SDTR1_TWR_1                    ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_SDTR1_TWR_2                    ((uint32_t)0x00040000)        /*!<Bit 2 */
S
S#define  FMC_SDTR1_TRP                      ((uint32_t)0x00F00000)        /*!<TRP[2:0] bits (Row precharge delay) */
S#define  FMC_SDTR1_TRP_0                    ((uint32_t)0x00100000)        /*!<Bit 0 */
S#define  FMC_SDTR1_TRP_1                    ((uint32_t)0x00200000)        /*!<Bit 1 */
S#define  FMC_SDTR1_TRP_2                    ((uint32_t)0x00400000)        /*!<Bit 2 */
S
S#define  FMC_SDTR1_TRCD                     ((uint32_t)0x0F000000)        /*!<TRP[2:0] bits (Row to column delay) */
S#define  FMC_SDTR1_TRCD_0                   ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FMC_SDTR1_TRCD_1                   ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FMC_SDTR1_TRCD_2                   ((uint32_t)0x04000000)        /*!<Bit 2 */
S
S/******************  Bit definition for FMC_SDTR2 register  ******************/
S#define  FMC_SDTR2_TMRD                     ((uint32_t)0x0000000F)        /*!<TMRD[3:0] bits (Load mode register to active) */
S#define  FMC_SDTR2_TMRD_0                   ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_SDTR2_TMRD_1                   ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_SDTR2_TMRD_2                   ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  FMC_SDTR2_TMRD_3                   ((uint32_t)0x00000008)        /*!<Bit 3 */
S                                            
S#define  FMC_SDTR2_TXSR                     ((uint32_t)0x000000F0)        /*!<TXSR[3:0] bits (Exit self refresh) */
S#define  FMC_SDTR2_TXSR_0                   ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  FMC_SDTR2_TXSR_1                   ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  FMC_SDTR2_TXSR_2                   ((uint32_t)0x00000040)        /*!<Bit 2 */
S#define  FMC_SDTR2_TXSR_3                   ((uint32_t)0x00000080)        /*!<Bit 3 */
S
S#define  FMC_SDTR2_TRAS                     ((uint32_t)0x00000F00)        /*!<TRAS[3:0] bits (Self refresh time) */
S#define  FMC_SDTR2_TRAS_0                   ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  FMC_SDTR2_TRAS_1                   ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  FMC_SDTR2_TRAS_2                   ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  FMC_SDTR2_TRAS_3                   ((uint32_t)0x00000800)        /*!<Bit 3 */
S
S#define  FMC_SDTR2_TRC                      ((uint32_t)0x0000F000)        /*!<TRC[2:0] bits (Row cycle delay) */
S#define  FMC_SDTR2_TRC_0                    ((uint32_t)0x00001000)        /*!<Bit 0 */
S#define  FMC_SDTR2_TRC_1                    ((uint32_t)0x00002000)        /*!<Bit 1 */
S#define  FMC_SDTR2_TRC_2                    ((uint32_t)0x00004000)        /*!<Bit 2 */
S
S#define  FMC_SDTR2_TWR                      ((uint32_t)0x000F0000)        /*!<TRC[2:0] bits (Write recovery delay) */
S#define  FMC_SDTR2_TWR_0                    ((uint32_t)0x00010000)        /*!<Bit 0 */
S#define  FMC_SDTR2_TWR_1                    ((uint32_t)0x00020000)        /*!<Bit 1 */
S#define  FMC_SDTR2_TWR_2                    ((uint32_t)0x00040000)        /*!<Bit 2 */
S
S#define  FMC_SDTR2_TRP                      ((uint32_t)0x00F00000)        /*!<TRP[2:0] bits (Row precharge delay) */
S#define  FMC_SDTR2_TRP_0                    ((uint32_t)0x00100000)        /*!<Bit 0 */
S#define  FMC_SDTR2_TRP_1                    ((uint32_t)0x00200000)        /*!<Bit 1 */
S#define  FMC_SDTR2_TRP_2                    ((uint32_t)0x00400000)        /*!<Bit 2 */
S
S#define  FMC_SDTR2_TRCD                     ((uint32_t)0x0F000000)        /*!<TRP[2:0] bits (Row to column delay) */
S#define  FMC_SDTR2_TRCD_0                   ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  FMC_SDTR2_TRCD_1                   ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  FMC_SDTR2_TRCD_2                   ((uint32_t)0x04000000)        /*!<Bit 2 */
S
S/******************  Bit definition for FMC_SDCMR register  ******************/
S#define  FMC_SDCMR_MODE                     ((uint32_t)0x00000007)        /*!<MODE[2:0] bits (Command mode) */
S#define  FMC_SDCMR_MODE_0                   ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  FMC_SDCMR_MODE_1                   ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  FMC_SDCMR_MODE_2                   ((uint32_t)0x00000003)        /*!<Bit 2 */
S                                            
S#define  FMC_SDCMR_CTB2                     ((uint32_t)0x00000008)        /*!<Command target 2 */
S
S#define  FMC_SDCMR_CTB1                     ((uint32_t)0x00000010)        /*!<Command target 1 */
S
S#define  FMC_SDCMR_NRFS                     ((uint32_t)0x000001E0)        /*!<NRFS[3:0] bits (Number of auto-refresh) */
S#define  FMC_SDCMR_NRFS_0                   ((uint32_t)0x00000020)        /*!<Bit 0 */
S#define  FMC_SDCMR_NRFS_1                   ((uint32_t)0x00000040)        /*!<Bit 1 */
S#define  FMC_SDCMR_NRFS_2                   ((uint32_t)0x00000080)        /*!<Bit 2 */
S#define  FMC_SDCMR_NRFS_3                   ((uint32_t)0x00000100)        /*!<Bit 3 */
S
S#define  FMC_SDCMR_MRD                      ((uint32_t)0x003FFE00)        /*!<MRD[12:0] bits (Mode register definition) */
S
S/******************  Bit definition for FMC_SDRTR register  ******************/
S#define  FMC_SDRTR_CRE                      ((uint32_t)0x00000001)        /*!<Clear refresh error flag */
S
S#define  FMC_SDRTR_COUNT                    ((uint32_t)0x00003FFE)        /*!<COUNT[12:0] bits (Refresh timer count) */
S
S#define  FMC_SDRTR_REIE                     ((uint32_t)0x00004000)        /*!<RES interupt enable */
S
S/******************  Bit definition for FMC_SDSR register  ******************/
S#define  FMC_SDSR_RE                        ((uint32_t)0x00000001)        /*!<Refresh error flag */
S
S#define  FMC_SDSR_MODES1                    ((uint32_t)0x00000006)        /*!<MODES1[1:0]bits (Status mode for bank 1) */
S#define  FMC_SDSR_MODES1_0                  ((uint32_t)0x00000002)        /*!<Bit 0 */
S#define  FMC_SDSR_MODES1_1                  ((uint32_t)0x00000004)        /*!<Bit 1 */
S
S#define  FMC_SDSR_MODES2                    ((uint32_t)0x00000018)        /*!<MODES2[1:0]bits (Status mode for bank 2) */
S#define  FMC_SDSR_MODES2_0                  ((uint32_t)0x00000008)        /*!<Bit 0 */
S#define  FMC_SDSR_MODES2_1                  ((uint32_t)0x00000010)        /*!<Bit 1 */
S
S#define  FMC_SDSR_BUSY                      ((uint32_t)0x00000020)        /*!<Busy status */
S
S#endif /* STM32F427_437xx ||  STM32F429_439xx || STM32F446xx || STM32F469_479xx */
S
S/******************************************************************************/
S/*                                                                            */
S/*                            General Purpose I/O                             */
S/*                                                                            */
S/******************************************************************************/
S/******************  Bits definition for GPIO_MODER register  *****************/
S#define GPIO_MODER_MODER0                    ((uint32_t)0x00000003)
S#define GPIO_MODER_MODER0_0                  ((uint32_t)0x00000001)
S#define GPIO_MODER_MODER0_1                  ((uint32_t)0x00000002)
S
S#define GPIO_MODER_MODER1                    ((uint32_t)0x0000000C)
S#define GPIO_MODER_MODER1_0                  ((uint32_t)0x00000004)
S#define GPIO_MODER_MODER1_1                  ((uint32_t)0x00000008)
S
S#define GPIO_MODER_MODER2                    ((uint32_t)0x00000030)
S#define GPIO_MODER_MODER2_0                  ((uint32_t)0x00000010)
S#define GPIO_MODER_MODER2_1                  ((uint32_t)0x00000020)
S
S#define GPIO_MODER_MODER3                    ((uint32_t)0x000000C0)
S#define GPIO_MODER_MODER3_0                  ((uint32_t)0x00000040)
S#define GPIO_MODER_MODER3_1                  ((uint32_t)0x00000080)
S
S#define GPIO_MODER_MODER4                    ((uint32_t)0x00000300)
S#define GPIO_MODER_MODER4_0                  ((uint32_t)0x00000100)
S#define GPIO_MODER_MODER4_1                  ((uint32_t)0x00000200)
S
S#define GPIO_MODER_MODER5                    ((uint32_t)0x00000C00)
S#define GPIO_MODER_MODER5_0                  ((uint32_t)0x00000400)
S#define GPIO_MODER_MODER5_1                  ((uint32_t)0x00000800)
S
S#define GPIO_MODER_MODER6                    ((uint32_t)0x00003000)
S#define GPIO_MODER_MODER6_0                  ((uint32_t)0x00001000)
S#define GPIO_MODER_MODER6_1                  ((uint32_t)0x00002000)
S
S#define GPIO_MODER_MODER7                    ((uint32_t)0x0000C000)
S#define GPIO_MODER_MODER7_0                  ((uint32_t)0x00004000)
S#define GPIO_MODER_MODER7_1                  ((uint32_t)0x00008000)
S
S#define GPIO_MODER_MODER8                    ((uint32_t)0x00030000)
S#define GPIO_MODER_MODER8_0                  ((uint32_t)0x00010000)
S#define GPIO_MODER_MODER8_1                  ((uint32_t)0x00020000)
S
S#define GPIO_MODER_MODER9                    ((uint32_t)0x000C0000)
S#define GPIO_MODER_MODER9_0                  ((uint32_t)0x00040000)
S#define GPIO_MODER_MODER9_1                  ((uint32_t)0x00080000)
S
S#define GPIO_MODER_MODER10                   ((uint32_t)0x00300000)
S#define GPIO_MODER_MODER10_0                 ((uint32_t)0x00100000)
S#define GPIO_MODER_MODER10_1                 ((uint32_t)0x00200000)
S
S#define GPIO_MODER_MODER11                   ((uint32_t)0x00C00000)
S#define GPIO_MODER_MODER11_0                 ((uint32_t)0x00400000)
S#define GPIO_MODER_MODER11_1                 ((uint32_t)0x00800000)
S
S#define GPIO_MODER_MODER12                   ((uint32_t)0x03000000)
S#define GPIO_MODER_MODER12_0                 ((uint32_t)0x01000000)
S#define GPIO_MODER_MODER12_1                 ((uint32_t)0x02000000)
S
S#define GPIO_MODER_MODER13                   ((uint32_t)0x0C000000)
S#define GPIO_MODER_MODER13_0                 ((uint32_t)0x04000000)
S#define GPIO_MODER_MODER13_1                 ((uint32_t)0x08000000)
S
S#define GPIO_MODER_MODER14                   ((uint32_t)0x30000000)
S#define GPIO_MODER_MODER14_0                 ((uint32_t)0x10000000)
S#define GPIO_MODER_MODER14_1                 ((uint32_t)0x20000000)
S
S#define GPIO_MODER_MODER15                   ((uint32_t)0xC0000000)
S#define GPIO_MODER_MODER15_0                 ((uint32_t)0x40000000)
S#define GPIO_MODER_MODER15_1                 ((uint32_t)0x80000000)
S
S/******************  Bits definition for GPIO_OTYPER register  ****************/
S#define GPIO_OTYPER_OT_0                     ((uint32_t)0x00000001)
S#define GPIO_OTYPER_OT_1                     ((uint32_t)0x00000002)
S#define GPIO_OTYPER_OT_2                     ((uint32_t)0x00000004)
S#define GPIO_OTYPER_OT_3                     ((uint32_t)0x00000008)
S#define GPIO_OTYPER_OT_4                     ((uint32_t)0x00000010)
S#define GPIO_OTYPER_OT_5                     ((uint32_t)0x00000020)
S#define GPIO_OTYPER_OT_6                     ((uint32_t)0x00000040)
S#define GPIO_OTYPER_OT_7                     ((uint32_t)0x00000080)
S#define GPIO_OTYPER_OT_8                     ((uint32_t)0x00000100)
S#define GPIO_OTYPER_OT_9                     ((uint32_t)0x00000200)
S#define GPIO_OTYPER_OT_10                    ((uint32_t)0x00000400)
S#define GPIO_OTYPER_OT_11                    ((uint32_t)0x00000800)
S#define GPIO_OTYPER_OT_12                    ((uint32_t)0x00001000)
S#define GPIO_OTYPER_OT_13                    ((uint32_t)0x00002000)
S#define GPIO_OTYPER_OT_14                    ((uint32_t)0x00004000)
S#define GPIO_OTYPER_OT_15                    ((uint32_t)0x00008000)
S
S/******************  Bits definition for GPIO_OSPEEDR register  ***************/
S#define GPIO_OSPEEDER_OSPEEDR0               ((uint32_t)0x00000003)
S#define GPIO_OSPEEDER_OSPEEDR0_0             ((uint32_t)0x00000001)
S#define GPIO_OSPEEDER_OSPEEDR0_1             ((uint32_t)0x00000002)
S
S#define GPIO_OSPEEDER_OSPEEDR1               ((uint32_t)0x0000000C)
S#define GPIO_OSPEEDER_OSPEEDR1_0             ((uint32_t)0x00000004)
S#define GPIO_OSPEEDER_OSPEEDR1_1             ((uint32_t)0x00000008)
S
S#define GPIO_OSPEEDER_OSPEEDR2               ((uint32_t)0x00000030)
S#define GPIO_OSPEEDER_OSPEEDR2_0             ((uint32_t)0x00000010)
S#define GPIO_OSPEEDER_OSPEEDR2_1             ((uint32_t)0x00000020)
S
S#define GPIO_OSPEEDER_OSPEEDR3               ((uint32_t)0x000000C0)
S#define GPIO_OSPEEDER_OSPEEDR3_0             ((uint32_t)0x00000040)
S#define GPIO_OSPEEDER_OSPEEDR3_1             ((uint32_t)0x00000080)
S
S#define GPIO_OSPEEDER_OSPEEDR4               ((uint32_t)0x00000300)
S#define GPIO_OSPEEDER_OSPEEDR4_0             ((uint32_t)0x00000100)
S#define GPIO_OSPEEDER_OSPEEDR4_1             ((uint32_t)0x00000200)
S
S#define GPIO_OSPEEDER_OSPEEDR5               ((uint32_t)0x00000C00)
S#define GPIO_OSPEEDER_OSPEEDR5_0             ((uint32_t)0x00000400)
S#define GPIO_OSPEEDER_OSPEEDR5_1             ((uint32_t)0x00000800)
S
S#define GPIO_OSPEEDER_OSPEEDR6               ((uint32_t)0x00003000)
S#define GPIO_OSPEEDER_OSPEEDR6_0             ((uint32_t)0x00001000)
S#define GPIO_OSPEEDER_OSPEEDR6_1             ((uint32_t)0x00002000)
S
S#define GPIO_OSPEEDER_OSPEEDR7               ((uint32_t)0x0000C000)
S#define GPIO_OSPEEDER_OSPEEDR7_0             ((uint32_t)0x00004000)
S#define GPIO_OSPEEDER_OSPEEDR7_1             ((uint32_t)0x00008000)
S
S#define GPIO_OSPEEDER_OSPEEDR8               ((uint32_t)0x00030000)
S#define GPIO_OSPEEDER_OSPEEDR8_0             ((uint32_t)0x00010000)
S#define GPIO_OSPEEDER_OSPEEDR8_1             ((uint32_t)0x00020000)
S
S#define GPIO_OSPEEDER_OSPEEDR9               ((uint32_t)0x000C0000)
S#define GPIO_OSPEEDER_OSPEEDR9_0             ((uint32_t)0x00040000)
S#define GPIO_OSPEEDER_OSPEEDR9_1             ((uint32_t)0x00080000)
S
S#define GPIO_OSPEEDER_OSPEEDR10              ((uint32_t)0x00300000)
S#define GPIO_OSPEEDER_OSPEEDR10_0            ((uint32_t)0x00100000)
S#define GPIO_OSPEEDER_OSPEEDR10_1            ((uint32_t)0x00200000)
S
S#define GPIO_OSPEEDER_OSPEEDR11              ((uint32_t)0x00C00000)
S#define GPIO_OSPEEDER_OSPEEDR11_0            ((uint32_t)0x00400000)
S#define GPIO_OSPEEDER_OSPEEDR11_1            ((uint32_t)0x00800000)
S
S#define GPIO_OSPEEDER_OSPEEDR12              ((uint32_t)0x03000000)
S#define GPIO_OSPEEDER_OSPEEDR12_0            ((uint32_t)0x01000000)
S#define GPIO_OSPEEDER_OSPEEDR12_1            ((uint32_t)0x02000000)
S
S#define GPIO_OSPEEDER_OSPEEDR13              ((uint32_t)0x0C000000)
S#define GPIO_OSPEEDER_OSPEEDR13_0            ((uint32_t)0x04000000)
S#define GPIO_OSPEEDER_OSPEEDR13_1            ((uint32_t)0x08000000)
S
S#define GPIO_OSPEEDER_OSPEEDR14              ((uint32_t)0x30000000)
S#define GPIO_OSPEEDER_OSPEEDR14_0            ((uint32_t)0x10000000)
S#define GPIO_OSPEEDER_OSPEEDR14_1            ((uint32_t)0x20000000)
S
S#define GPIO_OSPEEDER_OSPEEDR15              ((uint32_t)0xC0000000)
S#define GPIO_OSPEEDER_OSPEEDR15_0            ((uint32_t)0x40000000)
S#define GPIO_OSPEEDER_OSPEEDR15_1            ((uint32_t)0x80000000)
S
S/******************  Bits definition for GPIO_PUPDR register  *****************/
S#define GPIO_PUPDR_PUPDR0                    ((uint32_t)0x00000003)
S#define GPIO_PUPDR_PUPDR0_0                  ((uint32_t)0x00000001)
S#define GPIO_PUPDR_PUPDR0_1                  ((uint32_t)0x00000002)
S
S#define GPIO_PUPDR_PUPDR1                    ((uint32_t)0x0000000C)
S#define GPIO_PUPDR_PUPDR1_0                  ((uint32_t)0x00000004)
S#define GPIO_PUPDR_PUPDR1_1                  ((uint32_t)0x00000008)
S
S#define GPIO_PUPDR_PUPDR2                    ((uint32_t)0x00000030)
S#define GPIO_PUPDR_PUPDR2_0                  ((uint32_t)0x00000010)
S#define GPIO_PUPDR_PUPDR2_1                  ((uint32_t)0x00000020)
S
S#define GPIO_PUPDR_PUPDR3                    ((uint32_t)0x000000C0)
S#define GPIO_PUPDR_PUPDR3_0                  ((uint32_t)0x00000040)
S#define GPIO_PUPDR_PUPDR3_1                  ((uint32_t)0x00000080)
S
S#define GPIO_PUPDR_PUPDR4                    ((uint32_t)0x00000300)
S#define GPIO_PUPDR_PUPDR4_0                  ((uint32_t)0x00000100)
S#define GPIO_PUPDR_PUPDR4_1                  ((uint32_t)0x00000200)
S
S#define GPIO_PUPDR_PUPDR5                    ((uint32_t)0x00000C00)
S#define GPIO_PUPDR_PUPDR5_0                  ((uint32_t)0x00000400)
S#define GPIO_PUPDR_PUPDR5_1                  ((uint32_t)0x00000800)
S
S#define GPIO_PUPDR_PUPDR6                    ((uint32_t)0x00003000)
S#define GPIO_PUPDR_PUPDR6_0                  ((uint32_t)0x00001000)
S#define GPIO_PUPDR_PUPDR6_1                  ((uint32_t)0x00002000)
S
S#define GPIO_PUPDR_PUPDR7                    ((uint32_t)0x0000C000)
S#define GPIO_PUPDR_PUPDR7_0                  ((uint32_t)0x00004000)
S#define GPIO_PUPDR_PUPDR7_1                  ((uint32_t)0x00008000)
S
S#define GPIO_PUPDR_PUPDR8                    ((uint32_t)0x00030000)
S#define GPIO_PUPDR_PUPDR8_0                  ((uint32_t)0x00010000)
S#define GPIO_PUPDR_PUPDR8_1                  ((uint32_t)0x00020000)
S
S#define GPIO_PUPDR_PUPDR9                    ((uint32_t)0x000C0000)
S#define GPIO_PUPDR_PUPDR9_0                  ((uint32_t)0x00040000)
S#define GPIO_PUPDR_PUPDR9_1                  ((uint32_t)0x00080000)
S
S#define GPIO_PUPDR_PUPDR10                   ((uint32_t)0x00300000)
S#define GPIO_PUPDR_PUPDR10_0                 ((uint32_t)0x00100000)
S#define GPIO_PUPDR_PUPDR10_1                 ((uint32_t)0x00200000)
S
S#define GPIO_PUPDR_PUPDR11                   ((uint32_t)0x00C00000)
S#define GPIO_PUPDR_PUPDR11_0                 ((uint32_t)0x00400000)
S#define GPIO_PUPDR_PUPDR11_1                 ((uint32_t)0x00800000)
S
S#define GPIO_PUPDR_PUPDR12                   ((uint32_t)0x03000000)
S#define GPIO_PUPDR_PUPDR12_0                 ((uint32_t)0x01000000)
S#define GPIO_PUPDR_PUPDR12_1                 ((uint32_t)0x02000000)
S
S#define GPIO_PUPDR_PUPDR13                   ((uint32_t)0x0C000000)
S#define GPIO_PUPDR_PUPDR13_0                 ((uint32_t)0x04000000)
S#define GPIO_PUPDR_PUPDR13_1                 ((uint32_t)0x08000000)
S
S#define GPIO_PUPDR_PUPDR14                   ((uint32_t)0x30000000)
S#define GPIO_PUPDR_PUPDR14_0                 ((uint32_t)0x10000000)
S#define GPIO_PUPDR_PUPDR14_1                 ((uint32_t)0x20000000)
S
S#define GPIO_PUPDR_PUPDR15                   ((uint32_t)0xC0000000)
S#define GPIO_PUPDR_PUPDR15_0                 ((uint32_t)0x40000000)
S#define GPIO_PUPDR_PUPDR15_1                 ((uint32_t)0x80000000)
S
S/******************  Bits definition for GPIO_IDR register  *******************/
S#define GPIO_IDR_IDR_0                       ((uint32_t)0x00000001)
S#define GPIO_IDR_IDR_1                       ((uint32_t)0x00000002)
S#define GPIO_IDR_IDR_2                       ((uint32_t)0x00000004)
S#define GPIO_IDR_IDR_3                       ((uint32_t)0x00000008)
S#define GPIO_IDR_IDR_4                       ((uint32_t)0x00000010)
S#define GPIO_IDR_IDR_5                       ((uint32_t)0x00000020)
S#define GPIO_IDR_IDR_6                       ((uint32_t)0x00000040)
S#define GPIO_IDR_IDR_7                       ((uint32_t)0x00000080)
S#define GPIO_IDR_IDR_8                       ((uint32_t)0x00000100)
S#define GPIO_IDR_IDR_9                       ((uint32_t)0x00000200)
S#define GPIO_IDR_IDR_10                      ((uint32_t)0x00000400)
S#define GPIO_IDR_IDR_11                      ((uint32_t)0x00000800)
S#define GPIO_IDR_IDR_12                      ((uint32_t)0x00001000)
S#define GPIO_IDR_IDR_13                      ((uint32_t)0x00002000)
S#define GPIO_IDR_IDR_14                      ((uint32_t)0x00004000)
S#define GPIO_IDR_IDR_15                      ((uint32_t)0x00008000)
S/* Old GPIO_IDR register bits definition, maintained for legacy purpose */
S#define GPIO_OTYPER_IDR_0                    GPIO_IDR_IDR_0
S#define GPIO_OTYPER_IDR_1                    GPIO_IDR_IDR_1
S#define GPIO_OTYPER_IDR_2                    GPIO_IDR_IDR_2
S#define GPIO_OTYPER_IDR_3                    GPIO_IDR_IDR_3
S#define GPIO_OTYPER_IDR_4                    GPIO_IDR_IDR_4
S#define GPIO_OTYPER_IDR_5                    GPIO_IDR_IDR_5
S#define GPIO_OTYPER_IDR_6                    GPIO_IDR_IDR_6
S#define GPIO_OTYPER_IDR_7                    GPIO_IDR_IDR_7
S#define GPIO_OTYPER_IDR_8                    GPIO_IDR_IDR_8
S#define GPIO_OTYPER_IDR_9                    GPIO_IDR_IDR_9
S#define GPIO_OTYPER_IDR_10                   GPIO_IDR_IDR_10
S#define GPIO_OTYPER_IDR_11                   GPIO_IDR_IDR_11
S#define GPIO_OTYPER_IDR_12                   GPIO_IDR_IDR_12
S#define GPIO_OTYPER_IDR_13                   GPIO_IDR_IDR_13
S#define GPIO_OTYPER_IDR_14                   GPIO_IDR_IDR_14
S#define GPIO_OTYPER_IDR_15                   GPIO_IDR_IDR_15
S
S/******************  Bits definition for GPIO_ODR register  *******************/
S#define GPIO_ODR_ODR_0                       ((uint32_t)0x00000001)
S#define GPIO_ODR_ODR_1                       ((uint32_t)0x00000002)
S#define GPIO_ODR_ODR_2                       ((uint32_t)0x00000004)
S#define GPIO_ODR_ODR_3                       ((uint32_t)0x00000008)
S#define GPIO_ODR_ODR_4                       ((uint32_t)0x00000010)
S#define GPIO_ODR_ODR_5                       ((uint32_t)0x00000020)
S#define GPIO_ODR_ODR_6                       ((uint32_t)0x00000040)
S#define GPIO_ODR_ODR_7                       ((uint32_t)0x00000080)
S#define GPIO_ODR_ODR_8                       ((uint32_t)0x00000100)
S#define GPIO_ODR_ODR_9                       ((uint32_t)0x00000200)
S#define GPIO_ODR_ODR_10                      ((uint32_t)0x00000400)
S#define GPIO_ODR_ODR_11                      ((uint32_t)0x00000800)
S#define GPIO_ODR_ODR_12                      ((uint32_t)0x00001000)
S#define GPIO_ODR_ODR_13                      ((uint32_t)0x00002000)
S#define GPIO_ODR_ODR_14                      ((uint32_t)0x00004000)
S#define GPIO_ODR_ODR_15                      ((uint32_t)0x00008000)
S/* Old GPIO_ODR register bits definition, maintained for legacy purpose */
S#define GPIO_OTYPER_ODR_0                    GPIO_ODR_ODR_0
S#define GPIO_OTYPER_ODR_1                    GPIO_ODR_ODR_1
S#define GPIO_OTYPER_ODR_2                    GPIO_ODR_ODR_2
S#define GPIO_OTYPER_ODR_3                    GPIO_ODR_ODR_3
S#define GPIO_OTYPER_ODR_4                    GPIO_ODR_ODR_4
S#define GPIO_OTYPER_ODR_5                    GPIO_ODR_ODR_5
S#define GPIO_OTYPER_ODR_6                    GPIO_ODR_ODR_6
S#define GPIO_OTYPER_ODR_7                    GPIO_ODR_ODR_7
S#define GPIO_OTYPER_ODR_8                    GPIO_ODR_ODR_8
S#define GPIO_OTYPER_ODR_9                    GPIO_ODR_ODR_9
S#define GPIO_OTYPER_ODR_10                   GPIO_ODR_ODR_10
S#define GPIO_OTYPER_ODR_11                   GPIO_ODR_ODR_11
S#define GPIO_OTYPER_ODR_12                   GPIO_ODR_ODR_12
S#define GPIO_OTYPER_ODR_13                   GPIO_ODR_ODR_13
S#define GPIO_OTYPER_ODR_14                   GPIO_ODR_ODR_14
S#define GPIO_OTYPER_ODR_15                   GPIO_ODR_ODR_15
S
S/******************  Bits definition for GPIO_BSRR register  ******************/
S#define GPIO_BSRR_BS_0                       ((uint32_t)0x00000001)
S#define GPIO_BSRR_BS_1                       ((uint32_t)0x00000002)
S#define GPIO_BSRR_BS_2                       ((uint32_t)0x00000004)
S#define GPIO_BSRR_BS_3                       ((uint32_t)0x00000008)
S#define GPIO_BSRR_BS_4                       ((uint32_t)0x00000010)
S#define GPIO_BSRR_BS_5                       ((uint32_t)0x00000020)
S#define GPIO_BSRR_BS_6                       ((uint32_t)0x00000040)
S#define GPIO_BSRR_BS_7                       ((uint32_t)0x00000080)
S#define GPIO_BSRR_BS_8                       ((uint32_t)0x00000100)
S#define GPIO_BSRR_BS_9                       ((uint32_t)0x00000200)
S#define GPIO_BSRR_BS_10                      ((uint32_t)0x00000400)
S#define GPIO_BSRR_BS_11                      ((uint32_t)0x00000800)
S#define GPIO_BSRR_BS_12                      ((uint32_t)0x00001000)
S#define GPIO_BSRR_BS_13                      ((uint32_t)0x00002000)
S#define GPIO_BSRR_BS_14                      ((uint32_t)0x00004000)
S#define GPIO_BSRR_BS_15                      ((uint32_t)0x00008000)
S#define GPIO_BSRR_BR_0                       ((uint32_t)0x00010000)
S#define GPIO_BSRR_BR_1                       ((uint32_t)0x00020000)
S#define GPIO_BSRR_BR_2                       ((uint32_t)0x00040000)
S#define GPIO_BSRR_BR_3                       ((uint32_t)0x00080000)
S#define GPIO_BSRR_BR_4                       ((uint32_t)0x00100000)
S#define GPIO_BSRR_BR_5                       ((uint32_t)0x00200000)
S#define GPIO_BSRR_BR_6                       ((uint32_t)0x00400000)
S#define GPIO_BSRR_BR_7                       ((uint32_t)0x00800000)
S#define GPIO_BSRR_BR_8                       ((uint32_t)0x01000000)
S#define GPIO_BSRR_BR_9                       ((uint32_t)0x02000000)
S#define GPIO_BSRR_BR_10                      ((uint32_t)0x04000000)
S#define GPIO_BSRR_BR_11                      ((uint32_t)0x08000000)
S#define GPIO_BSRR_BR_12                      ((uint32_t)0x10000000)
S#define GPIO_BSRR_BR_13                      ((uint32_t)0x20000000)
S#define GPIO_BSRR_BR_14                      ((uint32_t)0x40000000)
S#define GPIO_BSRR_BR_15                      ((uint32_t)0x80000000)
S
S/******************************************************************************/
S/*                                                                            */
S/*                                    HASH                                    */
S/*                                                                            */
S/******************************************************************************/
S/******************  Bits definition for HASH_CR register  ********************/
S#define HASH_CR_INIT                         ((uint32_t)0x00000004)
S#define HASH_CR_DMAE                         ((uint32_t)0x00000008)
S#define HASH_CR_DATATYPE                     ((uint32_t)0x00000030)
S#define HASH_CR_DATATYPE_0                   ((uint32_t)0x00000010)
S#define HASH_CR_DATATYPE_1                   ((uint32_t)0x00000020)
S#define HASH_CR_MODE                         ((uint32_t)0x00000040)
S#define HASH_CR_ALGO                         ((uint32_t)0x00040080)
S#define HASH_CR_ALGO_0                       ((uint32_t)0x00000080)
S#define HASH_CR_ALGO_1                       ((uint32_t)0x00040000)
S#define HASH_CR_NBW                          ((uint32_t)0x00000F00)
S#define HASH_CR_NBW_0                        ((uint32_t)0x00000100)
S#define HASH_CR_NBW_1                        ((uint32_t)0x00000200)
S#define HASH_CR_NBW_2                        ((uint32_t)0x00000400)
S#define HASH_CR_NBW_3                        ((uint32_t)0x00000800)
S#define HASH_CR_DINNE                        ((uint32_t)0x00001000)
S#define HASH_CR_MDMAT                        ((uint32_t)0x00002000)
S#define HASH_CR_LKEY                         ((uint32_t)0x00010000)
S
S/******************  Bits definition for HASH_STR register  *******************/
S#define HASH_STR_NBW                         ((uint32_t)0x0000001F)
S#define HASH_STR_NBW_0                       ((uint32_t)0x00000001)
S#define HASH_STR_NBW_1                       ((uint32_t)0x00000002)
S#define HASH_STR_NBW_2                       ((uint32_t)0x00000004)
S#define HASH_STR_NBW_3                       ((uint32_t)0x00000008)
S#define HASH_STR_NBW_4                       ((uint32_t)0x00000010)
S#define HASH_STR_DCAL                        ((uint32_t)0x00000100)
S
S/******************  Bits definition for HASH_IMR register  *******************/
S#define HASH_IMR_DINIM                       ((uint32_t)0x00000001)
S#define HASH_IMR_DCIM                        ((uint32_t)0x00000002)
S
S/******************  Bits definition for HASH_SR register  ********************/
S#define HASH_SR_DINIS                        ((uint32_t)0x00000001)
S#define HASH_SR_DCIS                         ((uint32_t)0x00000002)
S#define HASH_SR_DMAS                         ((uint32_t)0x00000004)
S#define HASH_SR_BUSY                         ((uint32_t)0x00000008)
S
S/******************************************************************************/
S/*                                                                            */
S/*                      Inter-integrated Circuit Interface                    */
S/*                                                                            */
S/******************************************************************************/
S/*******************  Bit definition for I2C_CR1 register  ********************/
S#define  I2C_CR1_PE                          ((uint16_t)0x0001)            /*!<Peripheral Enable                             */
S#define  I2C_CR1_SMBUS                       ((uint16_t)0x0002)            /*!<SMBus Mode                                    */
S#define  I2C_CR1_SMBTYPE                     ((uint16_t)0x0008)            /*!<SMBus Type                                    */
S#define  I2C_CR1_ENARP                       ((uint16_t)0x0010)            /*!<ARP Enable                                    */
S#define  I2C_CR1_ENPEC                       ((uint16_t)0x0020)            /*!<PEC Enable                                    */
S#define  I2C_CR1_ENGC                        ((uint16_t)0x0040)            /*!<General Call Enable                           */
S#define  I2C_CR1_NOSTRETCH                   ((uint16_t)0x0080)            /*!<Clock Stretching Disable (Slave mode)         */
S#define  I2C_CR1_START                       ((uint16_t)0x0100)            /*!<Start Generation                              */
S#define  I2C_CR1_STOP                        ((uint16_t)0x0200)            /*!<Stop Generation                               */
S#define  I2C_CR1_ACK                         ((uint16_t)0x0400)            /*!<Acknowledge Enable                            */
S#define  I2C_CR1_POS                         ((uint16_t)0x0800)            /*!<Acknowledge/PEC Position (for data reception) */
S#define  I2C_CR1_PEC                         ((uint16_t)0x1000)            /*!<Packet Error Checking                         */
S#define  I2C_CR1_ALERT                       ((uint16_t)0x2000)            /*!<SMBus Alert                                   */
S#define  I2C_CR1_SWRST                       ((uint16_t)0x8000)            /*!<Software Reset                                */
S
S/*******************  Bit definition for I2C_CR2 register  ********************/
S#define  I2C_CR2_FREQ                        ((uint16_t)0x003F)            /*!<FREQ[5:0] bits (Peripheral Clock Frequency)   */
S#define  I2C_CR2_FREQ_0                      ((uint16_t)0x0001)            /*!<Bit 0 */
S#define  I2C_CR2_FREQ_1                      ((uint16_t)0x0002)            /*!<Bit 1 */
S#define  I2C_CR2_FREQ_2                      ((uint16_t)0x0004)            /*!<Bit 2 */
S#define  I2C_CR2_FREQ_3                      ((uint16_t)0x0008)            /*!<Bit 3 */
S#define  I2C_CR2_FREQ_4                      ((uint16_t)0x0010)            /*!<Bit 4 */
S#define  I2C_CR2_FREQ_5                      ((uint16_t)0x0020)            /*!<Bit 5 */
S
S#define  I2C_CR2_ITERREN                     ((uint16_t)0x0100)            /*!<Error Interrupt Enable  */
S#define  I2C_CR2_ITEVTEN                     ((uint16_t)0x0200)            /*!<Event Interrupt Enable  */
S#define  I2C_CR2_ITBUFEN                     ((uint16_t)0x0400)            /*!<Buffer Interrupt Enable */
S#define  I2C_CR2_DMAEN                       ((uint16_t)0x0800)            /*!<DMA Requests Enable     */
S#define  I2C_CR2_LAST                        ((uint16_t)0x1000)            /*!<DMA Last Transfer       */
S
S/*******************  Bit definition for I2C_OAR1 register  *******************/
S#define  I2C_OAR1_ADD1_7                     ((uint16_t)0x00FE)            /*!<Interface Address */
S#define  I2C_OAR1_ADD8_9                     ((uint16_t)0x0300)            /*!<Interface Address */
S
S#define  I2C_OAR1_ADD0                       ((uint16_t)0x0001)            /*!<Bit 0 */
S#define  I2C_OAR1_ADD1                       ((uint16_t)0x0002)            /*!<Bit 1 */
S#define  I2C_OAR1_ADD2                       ((uint16_t)0x0004)            /*!<Bit 2 */
S#define  I2C_OAR1_ADD3                       ((uint16_t)0x0008)            /*!<Bit 3 */
S#define  I2C_OAR1_ADD4                       ((uint16_t)0x0010)            /*!<Bit 4 */
S#define  I2C_OAR1_ADD5                       ((uint16_t)0x0020)            /*!<Bit 5 */
S#define  I2C_OAR1_ADD6                       ((uint16_t)0x0040)            /*!<Bit 6 */
S#define  I2C_OAR1_ADD7                       ((uint16_t)0x0080)            /*!<Bit 7 */
S#define  I2C_OAR1_ADD8                       ((uint16_t)0x0100)            /*!<Bit 8 */
S#define  I2C_OAR1_ADD9                       ((uint16_t)0x0200)            /*!<Bit 9 */
S
S#define  I2C_OAR1_ADDMODE                    ((uint16_t)0x8000)            /*!<Addressing Mode (Slave mode) */
S
S/*******************  Bit definition for I2C_OAR2 register  *******************/
S#define  I2C_OAR2_ENDUAL                     ((uint8_t)0x01)               /*!<Dual addressing mode enable */
S#define  I2C_OAR2_ADD2                       ((uint8_t)0xFE)               /*!<Interface address           */
S
S/********************  Bit definition for I2C_DR register  ********************/
S#define  I2C_DR_DR                           ((uint8_t)0xFF)               /*!<8-bit Data Register         */
S
S/*******************  Bit definition for I2C_SR1 register  ********************/
S#define  I2C_SR1_SB                          ((uint16_t)0x0001)            /*!<Start Bit (Master mode)                         */
S#define  I2C_SR1_ADDR                        ((uint16_t)0x0002)            /*!<Address sent (master mode)/matched (slave mode) */
S#define  I2C_SR1_BTF                         ((uint16_t)0x0004)            /*!<Byte Transfer Finished                          */
S#define  I2C_SR1_ADD10                       ((uint16_t)0x0008)            /*!<10-bit header sent (Master mode)                */
S#define  I2C_SR1_STOPF                       ((uint16_t)0x0010)            /*!<Stop detection (Slave mode)                     */
S#define  I2C_SR1_RXNE                        ((uint16_t)0x0040)            /*!<Data Register not Empty (receivers)             */
S#define  I2C_SR1_TXE                         ((uint16_t)0x0080)            /*!<Data Register Empty (transmitters)              */
S#define  I2C_SR1_BERR                        ((uint16_t)0x0100)            /*!<Bus Error                                       */
S#define  I2C_SR1_ARLO                        ((uint16_t)0x0200)            /*!<Arbitration Lost (master mode)                  */
S#define  I2C_SR1_AF                          ((uint16_t)0x0400)            /*!<Acknowledge Failure                             */
S#define  I2C_SR1_OVR                         ((uint16_t)0x0800)            /*!<Overrun/Underrun                                */
S#define  I2C_SR1_PECERR                      ((uint16_t)0x1000)            /*!<PEC Error in reception                          */
S#define  I2C_SR1_TIMEOUT                     ((uint16_t)0x4000)            /*!<Timeout or Tlow Error                           */
S#define  I2C_SR1_SMBALERT                    ((uint16_t)0x8000)            /*!<SMBus Alert                                     */
S
S/*******************  Bit definition for I2C_SR2 register  ********************/
S#define  I2C_SR2_MSL                         ((uint16_t)0x0001)            /*!<Master/Slave                              */
S#define  I2C_SR2_BUSY                        ((uint16_t)0x0002)            /*!<Bus Busy                                  */
S#define  I2C_SR2_TRA                         ((uint16_t)0x0004)            /*!<Transmitter/Receiver                      */
S#define  I2C_SR2_GENCALL                     ((uint16_t)0x0010)            /*!<General Call Address (Slave mode)         */
S#define  I2C_SR2_SMBDEFAULT                  ((uint16_t)0x0020)            /*!<SMBus Device Default Address (Slave mode) */
S#define  I2C_SR2_SMBHOST                     ((uint16_t)0x0040)            /*!<SMBus Host Header (Slave mode)            */
S#define  I2C_SR2_DUALF                       ((uint16_t)0x0080)            /*!<Dual Flag (Slave mode)                    */
S#define  I2C_SR2_PEC                         ((uint16_t)0xFF00)            /*!<Packet Error Checking Register            */
S
S/*******************  Bit definition for I2C_CCR register  ********************/
S#define  I2C_CCR_CCR                         ((uint16_t)0x0FFF)            /*!<Clock Control Register in Fast/Standard mode (Master mode) */
S#define  I2C_CCR_DUTY                        ((uint16_t)0x4000)            /*!<Fast Mode Duty Cycle                                       */
S#define  I2C_CCR_FS                          ((uint16_t)0x8000)            /*!<I2C Master Mode Selection                                  */
S
S/******************  Bit definition for I2C_TRISE register  *******************/
S#define  I2C_TRISE_TRISE                     ((uint8_t)0x3F)               /*!<Maximum Rise Time in Fast/Standard mode (Master mode) */
S
S/******************  Bit definition for I2C_FLTR register  *******************/
S#define  I2C_FLTR_DNF                     ((uint8_t)0x0F)                  /*!<Digital Noise Filter */
S#define  I2C_FLTR_ANOFF                   ((uint8_t)0x10)                  /*!<Analog Noise Filter OFF */
S
S#if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
S/******************************************************************************/
S/*                                                                            */
S/*              Fast-mode Plus Inter-integrated circuit (FMPI2C)              */
S/*                                                                            */
S/******************************************************************************/
S/*******************  Bit definition for I2C_CR1 register  *******************/
S#define  FMPI2C_CR1_PE                          ((uint32_t)0x00000001)        /*!< Peripheral enable                   */
S#define  FMPI2C_CR1_TXIE                        ((uint32_t)0x00000002)        /*!< TX interrupt enable                 */
S#define  FMPI2C_CR1_RXIE                        ((uint32_t)0x00000004)        /*!< RX interrupt enable                 */
S#define  FMPI2C_CR1_ADDRIE                      ((uint32_t)0x00000008)        /*!< Address match interrupt enable      */
S#define  FMPI2C_CR1_NACKIE                      ((uint32_t)0x00000010)        /*!< NACK received interrupt enable      */
S#define  FMPI2C_CR1_STOPIE                      ((uint32_t)0x00000020)        /*!< STOP detection interrupt enable     */
S#define  FMPI2C_CR1_TCIE                        ((uint32_t)0x00000040)        /*!< Transfer complete interrupt enable  */
S#define  FMPI2C_CR1_ERRIE                       ((uint32_t)0x00000080)        /*!< Errors interrupt enable             */
S#define  FMPI2C_CR1_DFN                         ((uint32_t)0x00000F00)        /*!< Digital noise filter                */
S#define  FMPI2C_CR1_ANFOFF                      ((uint32_t)0x00001000)        /*!< Analog noise filter OFF             */
S#define  FMPI2C_CR1_TXDMAEN                     ((uint32_t)0x00004000)        /*!< DMA transmission requests enable    */
S#define  FMPI2C_CR1_RXDMAEN                     ((uint32_t)0x00008000)        /*!< DMA reception requests enable       */
S#define  FMPI2C_CR1_SBC                         ((uint32_t)0x00010000)        /*!< Slave byte control                  */
S#define  FMPI2C_CR1_NOSTRETCH                   ((uint32_t)0x00020000)        /*!< Clock stretching disable            */
S#define  FMPI2C_CR1_GCEN                        ((uint32_t)0x00080000)        /*!< General call enable                 */
S#define  FMPI2C_CR1_SMBHEN                      ((uint32_t)0x00100000)        /*!< SMBus host address enable           */
S#define  FMPI2C_CR1_SMBDEN                      ((uint32_t)0x00200000)        /*!< SMBus device default address enable */
S#define  FMPI2C_CR1_ALERTEN                     ((uint32_t)0x00400000)        /*!< SMBus alert enable                  */
S#define  FMPI2C_CR1_PECEN                       ((uint32_t)0x00800000)        /*!< PEC enable                          */
S
S/******************  Bit definition for I2C_CR2 register  ********************/
S#define  FMPI2C_CR2_SADD                        ((uint32_t)0x000003FF)        /*!< Slave address (master mode)                             */
S#define  FMPI2C_CR2_RD_WRN                      ((uint32_t)0x00000400)        /*!< Transfer direction (master mode)                        */
S#define  FMPI2C_CR2_ADD10                       ((uint32_t)0x00000800)        /*!< 10-bit addressing mode (master mode)                    */
S#define  FMPI2C_CR2_HEAD10R                     ((uint32_t)0x00001000)        /*!< 10-bit address header only read direction (master mode) */
S#define  FMPI2C_CR2_START                       ((uint32_t)0x00002000)        /*!< START generation                                        */
S#define  FMPI2C_CR2_STOP                        ((uint32_t)0x00004000)        /*!< STOP generation (master mode)                           */
S#define  FMPI2C_CR2_NACK                        ((uint32_t)0x00008000)        /*!< NACK generation (slave mode)                            */
S#define  FMPI2C_CR2_NBYTES                      ((uint32_t)0x00FF0000)        /*!< Number of bytes                                         */
S#define  FMPI2C_CR2_RELOAD                      ((uint32_t)0x01000000)        /*!< NBYTES reload mode                                      */
S#define  FMPI2C_CR2_AUTOEND                     ((uint32_t)0x02000000)        /*!< Automatic end mode (master mode)                        */
S#define  FMPI2C_CR2_PECBYTE                     ((uint32_t)0x04000000)        /*!< Packet error checking byte                              */
S
S/*******************  Bit definition for I2C_OAR1 register  ******************/
S#define  FMPI2C_OAR1_OA1                        ((uint32_t)0x000003FF)        /*!< Interface own address 1   */
S#define  FMPI2C_OAR1_OA1MODE                    ((uint32_t)0x00000400)        /*!< Own address 1 10-bit mode */
S#define  FMPI2C_OAR1_OA1EN                      ((uint32_t)0x00008000)        /*!< Own address 1 enable     */
S
S/*******************  Bit definition for I2C_OAR2 register  *******************/
S#define  FMPI2C_OAR2_OA2                        ((uint32_t)0x000000FE)        /*!< Interface own address 2 */
S#define  FMPI2C_OAR2_OA2MSK                     ((uint32_t)0x00000700)        /*!< Own address 2 masks     */
S#define  FMPI2C_OAR2_OA2EN                      ((uint32_t)0x00008000)        /*!< Own address 2 enable    */
S
S/*******************  Bit definition for I2C_TIMINGR register *****************/
S#define  FMPI2C_TIMINGR_SCLL                    ((uint32_t)0x000000FF)        /*!< SCL low period (master mode)  */
S#define  FMPI2C_TIMINGR_SCLH                    ((uint32_t)0x0000FF00)        /*!< SCL high period (master mode) */
S#define  FMPI2C_TIMINGR_SDADEL                  ((uint32_t)0x000F0000)        /*!< Data hold time                */
S#define  FMPI2C_TIMINGR_SCLDEL                  ((uint32_t)0x00F00000)        /*!< Data setup time               */
S#define  FMPI2C_TIMINGR_PRESC                   ((uint32_t)0xF0000000)        /*!< Timings prescaler             */
S
S/******************* Bit definition for I2C_TIMEOUTR register *****************/
S#define  FMPI2C_TIMEOUTR_TIMEOUTA               ((uint32_t)0x00000FFF)        /*!< Bus timeout A                 */
S#define  FMPI2C_TIMEOUTR_TIDLE                  ((uint32_t)0x00001000)        /*!< Idle clock timeout detection  */
S#define  FMPI2C_TIMEOUTR_TIMOUTEN               ((uint32_t)0x00008000)        /*!< Clock timeout enable          */
S#define  FMPI2C_TIMEOUTR_TIMEOUTB               ((uint32_t)0x0FFF0000)        /*!< Bus timeout B                 */
S#define  FMPI2C_TIMEOUTR_TEXTEN                 ((uint32_t)0x80000000)        /*!< Extended clock timeout enable */
S
S/******************  Bit definition for I2C_ISR register  *********************/
S#define  FMPI2C_ISR_TXE                         ((uint32_t)0x00000001)        /*!< Transmit data register empty    */
S#define  FMPI2C_ISR_TXIS                        ((uint32_t)0x00000002)        /*!< Transmit interrupt status       */
S#define  FMPI2C_ISR_RXNE                        ((uint32_t)0x00000004)        /*!< Receive data register not empty */
S#define  FMPI2C_ISR_ADDR                        ((uint32_t)0x00000008)        /*!< Address matched (slave mode)    */
S#define  FMPI2C_ISR_NACKF                       ((uint32_t)0x00000010)        /*!< NACK received flag              */
S#define  FMPI2C_ISR_STOPF                       ((uint32_t)0x00000020)        /*!< STOP detection flag             */
S#define  FMPI2C_ISR_TC                          ((uint32_t)0x00000040)        /*!< Transfer complete (master mode) */
S#define  FMPI2C_ISR_TCR                         ((uint32_t)0x00000080)        /*!< Transfer complete reload        */
S#define  FMPI2C_ISR_BERR                        ((uint32_t)0x00000100)        /*!< Bus error                       */
S#define  FMPI2C_ISR_ARLO                        ((uint32_t)0x00000200)        /*!< Arbitration lost                */
S#define  FMPI2C_ISR_OVR                         ((uint32_t)0x00000400)        /*!< Overrun/Underrun                */
S#define  FMPI2C_ISR_PECERR                      ((uint32_t)0x00000800)        /*!< PEC error in reception          */
S#define  FMPI2C_ISR_TIMEOUT                     ((uint32_t)0x00001000)        /*!< Timeout or Tlow detection flag  */
S#define  FMPI2C_ISR_ALERT                       ((uint32_t)0x00002000)        /*!< SMBus alert                     */
S#define  FMPI2C_ISR_BUSY                        ((uint32_t)0x00008000)        /*!< Bus busy                        */
S#define  FMPI2C_ISR_DIR                         ((uint32_t)0x00010000)        /*!< Transfer direction (slave mode) */
S#define  FMPI2C_ISR_ADDCODE                     ((uint32_t)0x00FE0000)        /*!< Address match code (slave mode) */
S
S/******************  Bit definition for I2C_ICR register  *********************/
S#define  FMPI2C_ICR_ADDRCF                      ((uint32_t)0x00000008)        /*!< Address matched clear flag  */
S#define  FMPI2C_ICR_NACKCF                      ((uint32_t)0x00000010)        /*!< NACK clear flag             */
S#define  FMPI2C_ICR_STOPCF                      ((uint32_t)0x00000020)        /*!< STOP detection clear flag   */
S#define  FMPI2C_ICR_BERRCF                      ((uint32_t)0x00000100)        /*!< Bus error clear flag */
S#define  FMPI2C_ICR_ARLOCF                      ((uint32_t)0x00000200)        /*!< Arbitration lost clear flag */
S#define  FMPI2C_ICR_OVRCF                       ((uint32_t)0x00000400)        /*!< Overrun/Underrun clear flag */
S#define  FMPI2C_ICR_PECCF                       ((uint32_t)0x00000800)        /*!< PAC error clear flag        */
S#define  FMPI2C_ICR_TIMOUTCF                    ((uint32_t)0x00001000)        /*!< Timeout clear flag          */
S#define  FMPI2C_ICR_ALERTCF                     ((uint32_t)0x00002000)        /*!< Alert clear flag            */
S
S/******************  Bit definition for I2C_PECR register  ********************/
S#define  FMPI2C_PECR_PEC                        ((uint32_t)0x000000FF)        /*!< PEC register */
S
S/******************  Bit definition for I2C_RXDR register  *********************/
S#define  FMPI2C_RXDR_RXDATA                     ((uint32_t)0x000000FF)        /*!< 8-bit receive data */
S
S/******************  Bit definition for I2C_TXDR register  *********************/
S#define  FMPI2C_TXDR_TXDATA                     ((uint32_t)0x000000FF)        /*!< 8-bit transmit data */
S#endif /* STM32F410xx || STM32F412xG || STM32F413_423xx || STM32F446xx */
S/******************************************************************************/
S/*                                                                            */
S/*                           Independent WATCHDOG                             */
S/*                                                                            */
S/******************************************************************************/
S/*******************  Bit definition for IWDG_KR register  ********************/
S#define  IWDG_KR_KEY                         ((uint16_t)0xFFFF)            /*!<Key value (write only, read 0000h)  */
S
S/*******************  Bit definition for IWDG_PR register  ********************/
S#define  IWDG_PR_PR                          ((uint8_t)0x07)               /*!<PR[2:0] (Prescaler divider)         */
S#define  IWDG_PR_PR_0                        ((uint8_t)0x01)               /*!<Bit 0 */
S#define  IWDG_PR_PR_1                        ((uint8_t)0x02)               /*!<Bit 1 */
S#define  IWDG_PR_PR_2                        ((uint8_t)0x04)               /*!<Bit 2 */
S
S/*******************  Bit definition for IWDG_RLR register  *******************/
S#define  IWDG_RLR_RL                         ((uint16_t)0x0FFF)            /*!<Watchdog counter reload value        */
S
S/*******************  Bit definition for IWDG_SR register  ********************/
S#define  IWDG_SR_PVU                         ((uint8_t)0x01)               /*!<Watchdog prescaler value update      */
S#define  IWDG_SR_RVU                         ((uint8_t)0x02)               /*!<Watchdog counter reload value update */
S
S/******************************************************************************/
S/*                                                                            */
S/*                      LCD-TFT Display Controller (LTDC)                     */
S/*                                                                            */
S/******************************************************************************/
S
S/********************  Bit definition for LTDC_SSCR register  *****************/
S
S#define LTDC_SSCR_VSH                       ((uint32_t)0x000007FF)              /*!< Vertical Synchronization Height */
S#define LTDC_SSCR_HSW                       ((uint32_t)0x0FFF0000)              /*!< Horizontal Synchronization Width */
S
S/********************  Bit definition for LTDC_BPCR register  *****************/
S
S#define LTDC_BPCR_AVBP                      ((uint32_t)0x000007FF)              /*!< Accumulated Vertical Back Porch */
S#define LTDC_BPCR_AHBP                      ((uint32_t)0x0FFF0000)              /*!< Accumulated Horizontal Back Porch */
S
S/********************  Bit definition for LTDC_AWCR register  *****************/
S
S#define LTDC_AWCR_AAH                       ((uint32_t)0x000007FF)              /*!< Accumulated Active heigh */
S#define LTDC_AWCR_AAW                       ((uint32_t)0x0FFF0000)              /*!< Accumulated Active Width */
S
S/********************  Bit definition for LTDC_TWCR register  *****************/
S
S#define LTDC_TWCR_TOTALH                    ((uint32_t)0x000007FF)              /*!< Total Heigh */
S#define LTDC_TWCR_TOTALW                    ((uint32_t)0x0FFF0000)              /*!< Total Width */
S
S/********************  Bit definition for LTDC_GCR register  ******************/
S
S#define LTDC_GCR_LTDCEN                     ((uint32_t)0x00000001)              /*!< LCD-TFT controller enable bit */
S#define LTDC_GCR_DBW                        ((uint32_t)0x00000070)              /*!< Dither Blue Width */
S#define LTDC_GCR_DGW                        ((uint32_t)0x00000700)              /*!< Dither Green Width */
S#define LTDC_GCR_DRW                        ((uint32_t)0x00007000)              /*!< Dither Red Width */
S#define LTDC_GCR_DEN                        ((uint32_t)0x00010000)              /*!< Dither Enable */
S#define LTDC_GCR_PCPOL                      ((uint32_t)0x10000000)              /*!< Pixel Clock Polarity */
S#define LTDC_GCR_DEPOL                      ((uint32_t)0x20000000)              /*!< Data Enable Polarity */
S#define LTDC_GCR_VSPOL                      ((uint32_t)0x40000000)              /*!< Vertical Synchronization Polarity */
S#define LTDC_GCR_HSPOL                      ((uint32_t)0x80000000)              /*!< Horizontal Synchronization Polarity */
S
S/* Legacy defines */
S#define LTDC_GCR_DTEN                       LTDC_GCR_DEN
S
S/********************  Bit definition for LTDC_SRCR register  *****************/
S
S#define LTDC_SRCR_IMR                      ((uint32_t)0x00000001)               /*!< Immediate Reload */
S#define LTDC_SRCR_VBR                      ((uint32_t)0x00000002)               /*!< Vertical Blanking Reload */
S
S/********************  Bit definition for LTDC_BCCR register  *****************/
S
S#define LTDC_BCCR_BCBLUE                    ((uint32_t)0x000000FF)              /*!< Background Blue value */
S#define LTDC_BCCR_BCGREEN                   ((uint32_t)0x0000FF00)              /*!< Background Green value */
S#define LTDC_BCCR_BCRED                     ((uint32_t)0x00FF0000)              /*!< Background Red value */
S
S/********************  Bit definition for LTDC_IER register  ******************/
S
S#define LTDC_IER_LIE                        ((uint32_t)0x00000001)              /*!< Line Interrupt Enable */
S#define LTDC_IER_FUIE                       ((uint32_t)0x00000002)              /*!< FIFO Underrun Interrupt Enable */
S#define LTDC_IER_TERRIE                     ((uint32_t)0x00000004)              /*!< Transfer Error Interrupt Enable */
S#define LTDC_IER_RRIE                       ((uint32_t)0x00000008)              /*!< Register Reload interrupt enable */
S
S/********************  Bit definition for LTDC_ISR register  ******************/
S
S#define LTDC_ISR_LIF                        ((uint32_t)0x00000001)              /*!< Line Interrupt Flag */
S#define LTDC_ISR_FUIF                       ((uint32_t)0x00000002)              /*!< FIFO Underrun Interrupt Flag */
S#define LTDC_ISR_TERRIF                     ((uint32_t)0x00000004)              /*!< Transfer Error Interrupt Flag */
S#define LTDC_ISR_RRIF                       ((uint32_t)0x00000008)              /*!< Register Reload interrupt Flag */
S
S/********************  Bit definition for LTDC_ICR register  ******************/
S
S#define LTDC_ICR_CLIF                       ((uint32_t)0x00000001)              /*!< Clears the Line Interrupt Flag */
S#define LTDC_ICR_CFUIF                      ((uint32_t)0x00000002)              /*!< Clears the FIFO Underrun Interrupt Flag */
S#define LTDC_ICR_CTERRIF                    ((uint32_t)0x00000004)              /*!< Clears the Transfer Error Interrupt Flag */
S#define LTDC_ICR_CRRIF                      ((uint32_t)0x00000008)              /*!< Clears Register Reload interrupt Flag */
S
S/********************  Bit definition for LTDC_LIPCR register  ****************/
S
S#define LTDC_LIPCR_LIPOS                    ((uint32_t)0x000007FF)              /*!< Line Interrupt Position */
S
S/********************  Bit definition for LTDC_CPSR register  *****************/
S
S#define LTDC_CPSR_CYPOS                     ((uint32_t)0x0000FFFF)              /*!< Current Y Position */
S#define LTDC_CPSR_CXPOS                     ((uint32_t)0xFFFF0000)              /*!< Current X Position */
S
S/********************  Bit definition for LTDC_CDSR register  *****************/
S
S#define LTDC_CDSR_VDES                      ((uint32_t)0x00000001)              /*!< Vertical Data Enable Status */
S#define LTDC_CDSR_HDES                      ((uint32_t)0x00000002)              /*!< Horizontal Data Enable Status */
S#define LTDC_CDSR_VSYNCS                    ((uint32_t)0x00000004)              /*!< Vertical Synchronization Status */
S#define LTDC_CDSR_HSYNCS                    ((uint32_t)0x00000008)              /*!< Horizontal Synchronization Status */
S
S/********************  Bit definition for LTDC_LxCR register  *****************/
S
S#define LTDC_LxCR_LEN                       ((uint32_t)0x00000001)              /*!< Layer Enable */
S#define LTDC_LxCR_COLKEN                    ((uint32_t)0x00000002)              /*!< Color Keying Enable */
S#define LTDC_LxCR_CLUTEN                    ((uint32_t)0x00000010)              /*!< Color Lockup Table Enable */
S
S/********************  Bit definition for LTDC_LxWHPCR register  **************/
S
S#define LTDC_LxWHPCR_WHSTPOS                ((uint32_t)0x00000FFF)              /*!< Window Horizontal Start Position */
S#define LTDC_LxWHPCR_WHSPPOS                ((uint32_t)0xFFFF0000)              /*!< Window Horizontal Stop Position */
S
S/********************  Bit definition for LTDC_LxWVPCR register  **************/
S
S#define LTDC_LxWVPCR_WVSTPOS                ((uint32_t)0x00000FFF)              /*!< Window Vertical Start Position */
S#define LTDC_LxWVPCR_WVSPPOS                ((uint32_t)0xFFFF0000)              /*!< Window Vertical Stop Position */
S
S/********************  Bit definition for LTDC_LxCKCR register  ***************/
S
S#define LTDC_LxCKCR_CKBLUE                  ((uint32_t)0x000000FF)              /*!< Color Key Blue value */
S#define LTDC_LxCKCR_CKGREEN                 ((uint32_t)0x0000FF00)              /*!< Color Key Green value */
S#define LTDC_LxCKCR_CKRED                   ((uint32_t)0x00FF0000)              /*!< Color Key Red value */
S
S/********************  Bit definition for LTDC_LxPFCR register  ***************/
S
S#define LTDC_LxPFCR_PF                      ((uint32_t)0x00000007)              /*!< Pixel Format */
S
S/********************  Bit definition for LTDC_LxCACR register  ***************/
S
S#define LTDC_LxCACR_CONSTA                  ((uint32_t)0x000000FF)              /*!< Constant Alpha */
S
S/********************  Bit definition for LTDC_LxDCCR register  ***************/
S
S#define LTDC_LxDCCR_DCBLUE                  ((uint32_t)0x000000FF)              /*!< Default Color Blue */
S#define LTDC_LxDCCR_DCGREEN                 ((uint32_t)0x0000FF00)              /*!< Default Color Green */
S#define LTDC_LxDCCR_DCRED                   ((uint32_t)0x00FF0000)              /*!< Default Color Red */
S#define LTDC_LxDCCR_DCALPHA                 ((uint32_t)0xFF000000)              /*!< Default Color Alpha */
S                                
S/********************  Bit definition for LTDC_LxBFCR register  ***************/
S
S#define LTDC_LxBFCR_BF2                     ((uint32_t)0x00000007)              /*!< Blending Factor 2 */
S#define LTDC_LxBFCR_BF1                     ((uint32_t)0x00000700)              /*!< Blending Factor 1 */
S
S/********************  Bit definition for LTDC_LxCFBAR register  **************/
S
S#define LTDC_LxCFBAR_CFBADD                 ((uint32_t)0xFFFFFFFF)              /*!< Color Frame Buffer Start Address */
S
S/********************  Bit definition for LTDC_LxCFBLR register  **************/
S
S#define LTDC_LxCFBLR_CFBLL                  ((uint32_t)0x00001FFF)              /*!< Color Frame Buffer Line Length */
S#define LTDC_LxCFBLR_CFBP                   ((uint32_t)0x1FFF0000)              /*!< Color Frame Buffer Pitch in bytes */
S
S/********************  Bit definition for LTDC_LxCFBLNR register  *************/
S
S#define LTDC_LxCFBLNR_CFBLNBR               ((uint32_t)0x000007FF)              /*!< Frame Buffer Line Number */
S
S/********************  Bit definition for LTDC_LxCLUTWR register  *************/
S
S#define LTDC_LxCLUTWR_BLUE                  ((uint32_t)0x000000FF)              /*!< Blue value */
S#define LTDC_LxCLUTWR_GREEN                 ((uint32_t)0x0000FF00)              /*!< Green value */
S#define LTDC_LxCLUTWR_RED                   ((uint32_t)0x00FF0000)              /*!< Red value */
S#define LTDC_LxCLUTWR_CLUTADD               ((uint32_t)0xFF000000)              /*!< CLUT address */
S
S#if defined(STM32F469_479xx)
S/******************************************************************************/
S/*                                                                            */
S/*                                    DSI                                     */
S/*                                                                            */
S/******************************************************************************/
S/*******************  Bit definition for DSI_VR register  *****************/
S#define DSI_VR                         ((uint32_t)0x3133302A)               /*!< DSI Host Version */
S
S/*******************  Bit definition for DSI_CR register  *****************/
S#define DSI_CR_EN                      ((uint32_t)0x00000001)               /*!< DSI Host power up and reset */
S
S/*******************  Bit definition for DSI_CCR register  ****************/
S#define DSI_CCR_TXECKDIV               ((uint32_t)0x000000FF)               /*!< TX Escape Clock Division */
S#define DSI_CCR_TXECKDIV0              ((uint32_t)0x00000001)
S#define DSI_CCR_TXECKDIV1              ((uint32_t)0x00000002)
S#define DSI_CCR_TXECKDIV2              ((uint32_t)0x00000004)
S#define DSI_CCR_TXECKDIV3              ((uint32_t)0x00000008)
S#define DSI_CCR_TXECKDIV4              ((uint32_t)0x00000010)
S#define DSI_CCR_TXECKDIV5              ((uint32_t)0x00000020)
S#define DSI_CCR_TXECKDIV6              ((uint32_t)0x00000040)
S#define DSI_CCR_TXECKDIV7              ((uint32_t)0x00000080)
S
S#define DSI_CCR_TOCKDIV                ((uint32_t)0x0000FF00)               /*!< Timeout Clock Division */
S#define DSI_CCR_TOCKDIV0               ((uint32_t)0x00000100)
S#define DSI_CCR_TOCKDIV1               ((uint32_t)0x00000200)
S#define DSI_CCR_TOCKDIV2               ((uint32_t)0x00000400)
S#define DSI_CCR_TOCKDIV3               ((uint32_t)0x00000800)
S#define DSI_CCR_TOCKDIV4               ((uint32_t)0x00001000)
S#define DSI_CCR_TOCKDIV5               ((uint32_t)0x00002000)
S#define DSI_CCR_TOCKDIV6               ((uint32_t)0x00004000)
S#define DSI_CCR_TOCKDIV7               ((uint32_t)0x00008000)
S
S/*******************  Bit definition for DSI_LVCIDR register  *************/
S#define DSI_LVCIDR_VCID                ((uint32_t)0x00000003)               /*!< Virtual Channel ID */
S#define DSI_LVCIDR_VCID0               ((uint32_t)0x00000001)
S#define DSI_LVCIDR_VCID1               ((uint32_t)0x00000002)
S
S/*******************  Bit definition for DSI_LCOLCR register  *************/
S#define DSI_LCOLCR_COLC                ((uint32_t)0x0000000F)               /*!< Color Coding */
S#define DSI_LCOLCR_COLC0               ((uint32_t)0x00000001)
S#define DSI_LCOLCR_COLC1               ((uint32_t)0x00000020)
S#define DSI_LCOLCR_COLC2               ((uint32_t)0x00000040)
S#define DSI_LCOLCR_COLC3               ((uint32_t)0x00000080)
S
S#define DSI_LCOLCR_LPE                 ((uint32_t)0x00000100)               /*!< Loosly Packet Enable */
S
S/*******************  Bit definition for DSI_LPCR register  ***************/
S#define DSI_LPCR_DEP                   ((uint32_t)0x00000001)               /*!< Data Enable Polarity */
S#define DSI_LPCR_VSP                   ((uint32_t)0x00000002)               /*!< VSYNC Polarity */
S#define DSI_LPCR_HSP                   ((uint32_t)0x00000004)               /*!< HSYNC Polarity */
S
S/*******************  Bit definition for DSI_LPMCR register  **************/
S#define DSI_LPMCR_VLPSIZE              ((uint32_t)0x000000FF)               /*!< VACT Largest Packet Size */
S#define DSI_LPMCR_VLPSIZE0             ((uint32_t)0x00000001)
S#define DSI_LPMCR_VLPSIZE1             ((uint32_t)0x00000002)
S#define DSI_LPMCR_VLPSIZE2             ((uint32_t)0x00000004)
S#define DSI_LPMCR_VLPSIZE3             ((uint32_t)0x00000008)
S#define DSI_LPMCR_VLPSIZE4             ((uint32_t)0x00000010)
S#define DSI_LPMCR_VLPSIZE5             ((uint32_t)0x00000020)
S#define DSI_LPMCR_VLPSIZE6             ((uint32_t)0x00000040)
S#define DSI_LPMCR_VLPSIZE7             ((uint32_t)0x00000080)
S
S#define DSI_LPMCR_LPSIZE               ((uint32_t)0x00FF0000)               /*!< Largest Packet Size */
S#define DSI_LPMCR_LPSIZE0              ((uint32_t)0x00010000)
S#define DSI_LPMCR_LPSIZE1              ((uint32_t)0x00020000)
S#define DSI_LPMCR_LPSIZE2              ((uint32_t)0x00040000)
S#define DSI_LPMCR_LPSIZE3              ((uint32_t)0x00080000)
S#define DSI_LPMCR_LPSIZE4              ((uint32_t)0x00100000)
S#define DSI_LPMCR_LPSIZE5              ((uint32_t)0x00200000)
S#define DSI_LPMCR_LPSIZE6              ((uint32_t)0x00400000)
S#define DSI_LPMCR_LPSIZE7              ((uint32_t)0x00800000)
S
S/*******************  Bit definition for DSI_PCR register  ****************/
S#define DSI_PCR_ETTXE                  ((uint32_t)0x00000001)               /*!< EoTp Transmission Enable */
S#define DSI_PCR_ETRXE                  ((uint32_t)0x00000002)               /*!< EoTp Reception Enable */
S#define DSI_PCR_BTAE                   ((uint32_t)0x00000004)               /*!< Bus Turn Around Enable */
S#define DSI_PCR_ECCRXE                 ((uint32_t)0x00000008)               /*!< ECC Reception Enable */
S#define DSI_PCR_CRCRXE                 ((uint32_t)0x00000010)               /*!< CRC Reception Enable */
S
S/*******************  Bit definition for DSI_GVCIDR register  *************/
S#define DSI_GVCIDR_VCID                ((uint32_t)0x00000003)               /*!< Virtual Channel ID */
S#define DSI_GVCIDR_VCID0               ((uint32_t)0x00000001)
S#define DSI_GVCIDR_VCID1               ((uint32_t)0x00000002)
S
S/*******************  Bit definition for DSI_MCR register  ****************/
S#define DSI_MCR_CMDM                   ((uint32_t)0x00000001)               /*!< Command Mode */
S
S/*******************  Bit definition for DSI_VMCR register  ***************/
S#define DSI_VMCR_VMT                   ((uint32_t)0x00000003)               /*!< Video Mode Type */
S#define DSI_VMCR_VMT0                  ((uint32_t)0x00000001)
S#define DSI_VMCR_VMT1                  ((uint32_t)0x00000002)
S
S#define DSI_VMCR_LPVSAE                ((uint32_t)0x00000100)               /*!< Low-Power Vertical Sync Active Enable */
S#define DSI_VMCR_LPVBPE                ((uint32_t)0x00000200)               /*!< Low-power Vertical Back-Porch Enable */
S#define DSI_VMCR_LPVFPE                ((uint32_t)0x00000400)               /*!< Low-power Vertical Front-porch Enable */
S#define DSI_VMCR_LPVAE                 ((uint32_t)0x00000800)               /*!< Low-Power Vertical Active Enable */
S#define DSI_VMCR_LPHBPE                ((uint32_t)0x00001000)               /*!< Low-Power Horizontal Back-Porch Enable */
S#define DSI_VMCR_LPHFPE                ((uint32_t)0x00002000)               /*!< Low-Power Horizontal Front-Porch Enable */
S#define DSI_VMCR_FBTAAE                ((uint32_t)0x00004000)               /*!< Frame Bus-Turn-Around Acknowledge Enable */
S#define DSI_VMCR_LPCE                  ((uint32_t)0x00008000)               /*!< Low-Power Command Enable */
S#define DSI_VMCR_PGE                   ((uint32_t)0x00010000)               /*!< Pattern Generator Enable */
S#define DSI_VMCR_PGM                   ((uint32_t)0x00100000)               /*!< Pattern Generator Mode */
S#define DSI_VMCR_PGO                   ((uint32_t)0x01000000)               /*!< Pattern Generator Orientation */
S
S/*******************  Bit definition for DSI_VPCR register  ***************/
S#define DSI_VPCR_VPSIZE                ((uint32_t)0x00003FFF)               /*!< Video Packet Size */
S#define DSI_VPCR_VPSIZE0               ((uint32_t)0x00000001)
S#define DSI_VPCR_VPSIZE1               ((uint32_t)0x00000002)
S#define DSI_VPCR_VPSIZE2               ((uint32_t)0x00000004)
S#define DSI_VPCR_VPSIZE3               ((uint32_t)0x00000008)
S#define DSI_VPCR_VPSIZE4               ((uint32_t)0x00000010)
S#define DSI_VPCR_VPSIZE5               ((uint32_t)0x00000020)
S#define DSI_VPCR_VPSIZE6               ((uint32_t)0x00000040)
S#define DSI_VPCR_VPSIZE7               ((uint32_t)0x00000080)
S#define DSI_VPCR_VPSIZE8               ((uint32_t)0x00000100)
S#define DSI_VPCR_VPSIZE9               ((uint32_t)0x00000200)
S#define DSI_VPCR_VPSIZE10              ((uint32_t)0x00000400)
S#define DSI_VPCR_VPSIZE11              ((uint32_t)0x00000800)
S#define DSI_VPCR_VPSIZE12              ((uint32_t)0x00001000)
S#define DSI_VPCR_VPSIZE13              ((uint32_t)0x00002000)
S
S/*******************  Bit definition for DSI_VCCR register  ***************/
S#define DSI_VCCR_NUMC                  ((uint32_t)0x00001FFF)               /*!< Number of Chunks */
S#define DSI_VCCR_NUMC0                 ((uint32_t)0x00000001)
S#define DSI_VCCR_NUMC1                 ((uint32_t)0x00000002)
S#define DSI_VCCR_NUMC2                 ((uint32_t)0x00000004)
S#define DSI_VCCR_NUMC3                 ((uint32_t)0x00000008)
S#define DSI_VCCR_NUMC4                 ((uint32_t)0x00000010)
S#define DSI_VCCR_NUMC5                 ((uint32_t)0x00000020)
S#define DSI_VCCR_NUMC6                 ((uint32_t)0x00000040)
S#define DSI_VCCR_NUMC7                 ((uint32_t)0x00000080)
S#define DSI_VCCR_NUMC8                 ((uint32_t)0x00000100)
S#define DSI_VCCR_NUMC9                 ((uint32_t)0x00000200)
S#define DSI_VCCR_NUMC10                ((uint32_t)0x00000400)
S#define DSI_VCCR_NUMC11                ((uint32_t)0x00000800)
S#define DSI_VCCR_NUMC12                ((uint32_t)0x00001000)
S
S/*******************  Bit definition for DSI_VNPCR register  **************/
S#define DSI_VNPCR_NPSIZE               ((uint32_t)0x00001FFF)               /*!< Null Packet Size */
S#define DSI_VNPCR_NPSIZE0              ((uint32_t)0x00000001)
S#define DSI_VNPCR_NPSIZE1              ((uint32_t)0x00000002)
S#define DSI_VNPCR_NPSIZE2              ((uint32_t)0x00000004)
S#define DSI_VNPCR_NPSIZE3              ((uint32_t)0x00000008)
S#define DSI_VNPCR_NPSIZE4              ((uint32_t)0x00000010)
S#define DSI_VNPCR_NPSIZE5              ((uint32_t)0x00000020)
S#define DSI_VNPCR_NPSIZE6              ((uint32_t)0x00000040)
S#define DSI_VNPCR_NPSIZE7              ((uint32_t)0x00000080)
S#define DSI_VNPCR_NPSIZE8              ((uint32_t)0x00000100)
S#define DSI_VNPCR_NPSIZE9              ((uint32_t)0x00000200)
S#define DSI_VNPCR_NPSIZE10             ((uint32_t)0x00000400)
S#define DSI_VNPCR_NPSIZE11             ((uint32_t)0x00000800)
S#define DSI_VNPCR_NPSIZE12             ((uint32_t)0x00001000)
S
S/*******************  Bit definition for DSI_VHSACR register  *************/
S#define DSI_VHSACR_HSA                 ((uint32_t)0x00000FFF)               /*!< Horizontal Synchronism Active duration */
S#define DSI_VHSACR_HSA0                ((uint32_t)0x00000001)
S#define DSI_VHSACR_HSA1                ((uint32_t)0x00000002)
S#define DSI_VHSACR_HSA2                ((uint32_t)0x00000004)
S#define DSI_VHSACR_HSA3                ((uint32_t)0x00000008)
S#define DSI_VHSACR_HSA4                ((uint32_t)0x00000010)
S#define DSI_VHSACR_HSA5                ((uint32_t)0x00000020)
S#define DSI_VHSACR_HSA6                ((uint32_t)0x00000040)
S#define DSI_VHSACR_HSA7                ((uint32_t)0x00000080)
S#define DSI_VHSACR_HSA8                ((uint32_t)0x00000100)
S#define DSI_VHSACR_HSA9                ((uint32_t)0x00000200)
S#define DSI_VHSACR_HSA10               ((uint32_t)0x00000400)
S#define DSI_VHSACR_HSA11               ((uint32_t)0x00000800)
S
S/*******************  Bit definition for DSI_VHBPCR register  *************/
S#define DSI_VHBPCR_HBP                 ((uint32_t)0x00000FFF)               /*!< Horizontal Back-Porch duration */
S#define DSI_VHBPCR_HBP0                ((uint32_t)0x00000001)
S#define DSI_VHBPCR_HBP1                ((uint32_t)0x00000002)
S#define DSI_VHBPCR_HBP2                ((uint32_t)0x00000004)
S#define DSI_VHBPCR_HBP3                ((uint32_t)0x00000008)
S#define DSI_VHBPCR_HBP4                ((uint32_t)0x00000010)
S#define DSI_VHBPCR_HBP5                ((uint32_t)0x00000020)
S#define DSI_VHBPCR_HBP6                ((uint32_t)0x00000040)
S#define DSI_VHBPCR_HBP7                ((uint32_t)0x00000080)
S#define DSI_VHBPCR_HBP8                ((uint32_t)0x00000100)
S#define DSI_VHBPCR_HBP9                ((uint32_t)0x00000200)
S#define DSI_VHBPCR_HBP10               ((uint32_t)0x00000400)
S#define DSI_VHBPCR_HBP11               ((uint32_t)0x00000800)
S
S/*******************  Bit definition for DSI_VLCR register  ***************/
S#define DSI_VLCR_HLINE                 ((uint32_t)0x00007FFF)               /*!< Horizontal Line duration */
S#define DSI_VLCR_HLINE0                ((uint32_t)0x00000001)
S#define DSI_VLCR_HLINE1                ((uint32_t)0x00000002)
S#define DSI_VLCR_HLINE2                ((uint32_t)0x00000004)
S#define DSI_VLCR_HLINE3                ((uint32_t)0x00000008)
S#define DSI_VLCR_HLINE4                ((uint32_t)0x00000010)
S#define DSI_VLCR_HLINE5                ((uint32_t)0x00000020)
S#define DSI_VLCR_HLINE6                ((uint32_t)0x00000040)
S#define DSI_VLCR_HLINE7                ((uint32_t)0x00000080)
S#define DSI_VLCR_HLINE8                ((uint32_t)0x00000100)
S#define DSI_VLCR_HLINE9                ((uint32_t)0x00000200)
S#define DSI_VLCR_HLINE10               ((uint32_t)0x00000400)
S#define DSI_VLCR_HLINE11               ((uint32_t)0x00000800)
S#define DSI_VLCR_HLINE12               ((uint32_t)0x00001000)
S#define DSI_VLCR_HLINE13               ((uint32_t)0x00002000)
S#define DSI_VLCR_HLINE14               ((uint32_t)0x00004000)
S
S/*******************  Bit definition for DSI_VVSACR register  *************/
S#define DSI_VVSACR_VSA                 ((uint32_t)0x000003FF)               /*!< Vertical Synchronism Active duration */
S#define DSI_VVSACR_VSA0                ((uint32_t)0x00000001)
S#define DSI_VVSACR_VSA1                ((uint32_t)0x00000002)
S#define DSI_VVSACR_VSA2                ((uint32_t)0x00000004)
S#define DSI_VVSACR_VSA3                ((uint32_t)0x00000008)
S#define DSI_VVSACR_VSA4                ((uint32_t)0x00000010)
S#define DSI_VVSACR_VSA5                ((uint32_t)0x00000020)
S#define DSI_VVSACR_VSA6                ((uint32_t)0x00000040)
S#define DSI_VVSACR_VSA7                ((uint32_t)0x00000080)
S#define DSI_VVSACR_VSA8                ((uint32_t)0x00000100)
S#define DSI_VVSACR_VSA9                ((uint32_t)0x00000200)
S
S/*******************  Bit definition for DSI_VVBPCR register  *************/
S#define DSI_VVBPCR_VBP                 ((uint32_t)0x000003FF)               /*!< Vertical Back-Porch duration */
S#define DSI_VVBPCR_VBP0                ((uint32_t)0x00000001)
S#define DSI_VVBPCR_VBP1                ((uint32_t)0x00000002)
S#define DSI_VVBPCR_VBP2                ((uint32_t)0x00000004)
S#define DSI_VVBPCR_VBP3                ((uint32_t)0x00000008)
S#define DSI_VVBPCR_VBP4                ((uint32_t)0x00000010)
S#define DSI_VVBPCR_VBP5                ((uint32_t)0x00000020)
S#define DSI_VVBPCR_VBP6                ((uint32_t)0x00000040)
S#define DSI_VVBPCR_VBP7                ((uint32_t)0x00000080)
S#define DSI_VVBPCR_VBP8                ((uint32_t)0x00000100)
S#define DSI_VVBPCR_VBP9                ((uint32_t)0x00000200)
S
S/*******************  Bit definition for DSI_VVFPCR register  *************/
S#define DSI_VVFPCR_VFP                 ((uint32_t)0x000003FF)               /*!< Vertical Front-Porch duration */
S#define DSI_VVFPCR_VFP0                ((uint32_t)0x00000001)
S#define DSI_VVFPCR_VFP1                ((uint32_t)0x00000002)
S#define DSI_VVFPCR_VFP2                ((uint32_t)0x00000004)
S#define DSI_VVFPCR_VFP3                ((uint32_t)0x00000008)
S#define DSI_VVFPCR_VFP4                ((uint32_t)0x00000010)
S#define DSI_VVFPCR_VFP5                ((uint32_t)0x00000020)
S#define DSI_VVFPCR_VFP6                ((uint32_t)0x00000040)
S#define DSI_VVFPCR_VFP7                ((uint32_t)0x00000080)
S#define DSI_VVFPCR_VFP8                ((uint32_t)0x00000100)
S#define DSI_VVFPCR_VFP9                ((uint32_t)0x00000200)
S
S/*******************  Bit definition for DSI_VVACR register  **************/
S#define DSI_VVACR_VA                   ((uint32_t)0x00003FFF)               /*!< Vertical Active duration */
S#define DSI_VVACR_VA0                  ((uint32_t)0x00000001)
S#define DSI_VVACR_VA1                  ((uint32_t)0x00000002)
S#define DSI_VVACR_VA2                  ((uint32_t)0x00000004)
S#define DSI_VVACR_VA3                  ((uint32_t)0x00000008)
S#define DSI_VVACR_VA4                  ((uint32_t)0x00000010)
S#define DSI_VVACR_VA5                  ((uint32_t)0x00000020)
S#define DSI_VVACR_VA6                  ((uint32_t)0x00000040)
S#define DSI_VVACR_VA7                  ((uint32_t)0x00000080)
S#define DSI_VVACR_VA8                  ((uint32_t)0x00000100)
S#define DSI_VVACR_VA9                  ((uint32_t)0x00000200)
S#define DSI_VVACR_VA10                 ((uint32_t)0x00000400)
S#define DSI_VVACR_VA11                 ((uint32_t)0x00000800)
S#define DSI_VVACR_VA12                 ((uint32_t)0x00001000)
S#define DSI_VVACR_VA13                 ((uint32_t)0x00002000)
S
S/*******************  Bit definition for DSI_LCCR register  ***************/
S#define DSI_LCCR_CMDSIZE               ((uint32_t)0x0000FFFF)               /*!< Command Size */
S#define DSI_LCCR_CMDSIZE0              ((uint32_t)0x00000001)
S#define DSI_LCCR_CMDSIZE1              ((uint32_t)0x00000002)
S#define DSI_LCCR_CMDSIZE2              ((uint32_t)0x00000004)
S#define DSI_LCCR_CMDSIZE3              ((uint32_t)0x00000008)
S#define DSI_LCCR_CMDSIZE4              ((uint32_t)0x00000010)
S#define DSI_LCCR_CMDSIZE5              ((uint32_t)0x00000020)
S#define DSI_LCCR_CMDSIZE6              ((uint32_t)0x00000040)
S#define DSI_LCCR_CMDSIZE7              ((uint32_t)0x00000080)
S#define DSI_LCCR_CMDSIZE8              ((uint32_t)0x00000100)
S#define DSI_LCCR_CMDSIZE9              ((uint32_t)0x00000200)
S#define DSI_LCCR_CMDSIZE10             ((uint32_t)0x00000400)
S#define DSI_LCCR_CMDSIZE11             ((uint32_t)0x00000800)
S#define DSI_LCCR_CMDSIZE12             ((uint32_t)0x00001000)
S#define DSI_LCCR_CMDSIZE13             ((uint32_t)0x00002000)
S#define DSI_LCCR_CMDSIZE14             ((uint32_t)0x00004000)
S#define DSI_LCCR_CMDSIZE15             ((uint32_t)0x00008000)
S
S/*******************  Bit definition for DSI_CMCR register  ***************/
S#define DSI_CMCR_TEARE                 ((uint32_t)0x00000001)               /*!< Tearing Effect Acknowledge Request Enable */
S#define DSI_CMCR_ARE                   ((uint32_t)0x00000002)               /*!< Acknowledge Request Enable */
S#define DSI_CMCR_GSW0TX                ((uint32_t)0x00000100)               /*!< Generic Short Write Zero parameters Transmission */
S#define DSI_CMCR_GSW1TX                ((uint32_t)0x00000200)               /*!< Generic Short Write One parameters Transmission */
S#define DSI_CMCR_GSW2TX                ((uint32_t)0x00000400)               /*!< Generic Short Write Two parameters Transmission */
S#define DSI_CMCR_GSR0TX                ((uint32_t)0x00000800)               /*!< Generic Short Read Zero parameters Transmission */
S#define DSI_CMCR_GSR1TX                ((uint32_t)0x00001000)               /*!< Generic Short Read One parameters Transmission */
S#define DSI_CMCR_GSR2TX                ((uint32_t)0x00002000)               /*!< Generic Short Read Two parameters Transmission */
S#define DSI_CMCR_GLWTX                 ((uint32_t)0x00004000)               /*!< Generic Long Write Transmission */
S#define DSI_CMCR_DSW0TX                ((uint32_t)0x00010000)               /*!< DCS Short Write Zero parameter Transmission */
S#define DSI_CMCR_DSW1TX                ((uint32_t)0x00020000)               /*!< DCS Short Read One parameter Transmission */
S#define DSI_CMCR_DSR0TX                ((uint32_t)0x00040000)               /*!< DCS Short Read Zero parameter Transmission */
S#define DSI_CMCR_DLWTX                 ((uint32_t)0x00080000)               /*!< DCS Long Write Transmission */
S#define DSI_CMCR_MRDPS                 ((uint32_t)0x01000000)               /*!< Maximum Read Packet Size */
S
S/*******************  Bit definition for DSI_GHCR register  ***************/
S#define DSI_GHCR_DT                    ((uint32_t)0x0000003F)               /*!< Type */
S#define DSI_GHCR_DT0                   ((uint32_t)0x00000001)
S#define DSI_GHCR_DT1                   ((uint32_t)0x00000002)
S#define DSI_GHCR_DT2                   ((uint32_t)0x00000004)
S#define DSI_GHCR_DT3                   ((uint32_t)0x00000008)
S#define DSI_GHCR_DT4                   ((uint32_t)0x00000010)
S#define DSI_GHCR_DT5                   ((uint32_t)0x00000020)
S
S#define DSI_GHCR_VCID                  ((uint32_t)0x000000C0)               /*!< Channel */
S#define DSI_GHCR_VCID0                 ((uint32_t)0x00000040)
S#define DSI_GHCR_VCID1                 ((uint32_t)0x00000080)
S
S#define DSI_GHCR_WCLSB                 ((uint32_t)0x0000FF00)               /*!< WordCount LSB */
S#define DSI_GHCR_WCLSB0                ((uint32_t)0x00000100)
S#define DSI_GHCR_WCLSB1                ((uint32_t)0x00000200)
S#define DSI_GHCR_WCLSB2                ((uint32_t)0x00000400)
S#define DSI_GHCR_WCLSB3                ((uint32_t)0x00000800)
S#define DSI_GHCR_WCLSB4                ((uint32_t)0x00001000)
S#define DSI_GHCR_WCLSB5                ((uint32_t)0x00002000)
S#define DSI_GHCR_WCLSB6                ((uint32_t)0x00004000)
S#define DSI_GHCR_WCLSB7                ((uint32_t)0x00008000)
S
S#define DSI_GHCR_WCMSB                 ((uint32_t)0x00FF0000)               /*!< WordCount MSB */
S#define DSI_GHCR_WCMSB0                ((uint32_t)0x00010000)
S#define DSI_GHCR_WCMSB1                ((uint32_t)0x00020000)
S#define DSI_GHCR_WCMSB2                ((uint32_t)0x00040000)
S#define DSI_GHCR_WCMSB3                ((uint32_t)0x00080000)
S#define DSI_GHCR_WCMSB4                ((uint32_t)0x00100000)
S#define DSI_GHCR_WCMSB5                ((uint32_t)0x00200000)
S#define DSI_GHCR_WCMSB6                ((uint32_t)0x00400000)
S#define DSI_GHCR_WCMSB7                ((uint32_t)0x00800000)
S
S/*******************  Bit definition for DSI_GPDR register  ***************/
S#define DSI_GPDR_DATA1                 ((uint32_t)0x000000FF)               /*!< Payload Byte 1 */
S#define DSI_GPDR_DATA1_0               ((uint32_t)0x00000001)
S#define DSI_GPDR_DATA1_1               ((uint32_t)0x00000002)
S#define DSI_GPDR_DATA1_2               ((uint32_t)0x00000004)
S#define DSI_GPDR_DATA1_3               ((uint32_t)0x00000008)
S#define DSI_GPDR_DATA1_4               ((uint32_t)0x00000010)
S#define DSI_GPDR_DATA1_5               ((uint32_t)0x00000020)
S#define DSI_GPDR_DATA1_6               ((uint32_t)0x00000040)
S#define DSI_GPDR_DATA1_7               ((uint32_t)0x00000080)
S
S#define DSI_GPDR_DATA2                 ((uint32_t)0x0000FF00)               /*!< Payload Byte 2 */
S#define DSI_GPDR_DATA2_0               ((uint32_t)0x00000100)
S#define DSI_GPDR_DATA2_1               ((uint32_t)0x00000200)
S#define DSI_GPDR_DATA2_2               ((uint32_t)0x00000400)
S#define DSI_GPDR_DATA2_3               ((uint32_t)0x00000800)
S#define DSI_GPDR_DATA2_4               ((uint32_t)0x00001000)
S#define DSI_GPDR_DATA2_5               ((uint32_t)0x00002000)
S#define DSI_GPDR_DATA2_6               ((uint32_t)0x00004000)
S#define DSI_GPDR_DATA2_7               ((uint32_t)0x00008000)
S
S#define DSI_GPDR_DATA3                 ((uint32_t)0x00FF0000)               /*!< Payload Byte 3 */
S#define DSI_GPDR_DATA3_0               ((uint32_t)0x00010000)
S#define DSI_GPDR_DATA3_1               ((uint32_t)0x00020000)
S#define DSI_GPDR_DATA3_2               ((uint32_t)0x00040000)
S#define DSI_GPDR_DATA3_3               ((uint32_t)0x00080000)
S#define DSI_GPDR_DATA3_4               ((uint32_t)0x00100000)
S#define DSI_GPDR_DATA3_5               ((uint32_t)0x00200000)
S#define DSI_GPDR_DATA3_6               ((uint32_t)0x00400000)
S#define DSI_GPDR_DATA3_7               ((uint32_t)0x00800000)
S
S#define DSI_GPDR_DATA4                 ((uint32_t)0xFF000000)               /*!< Payload Byte 4 */
S#define DSI_GPDR_DATA4_0               ((uint32_t)0x01000000)
S#define DSI_GPDR_DATA4_1               ((uint32_t)0x02000000)
S#define DSI_GPDR_DATA4_2               ((uint32_t)0x04000000)
S#define DSI_GPDR_DATA4_3               ((uint32_t)0x08000000)
S#define DSI_GPDR_DATA4_4               ((uint32_t)0x10000000)
S#define DSI_GPDR_DATA4_5               ((uint32_t)0x20000000)
S#define DSI_GPDR_DATA4_6               ((uint32_t)0x40000000)
S#define DSI_GPDR_DATA4_7               ((uint32_t)0x80000000)
S
S/*******************  Bit definition for DSI_GPSR register  ***************/
S#define DSI_GPSR_CMDFE                 ((uint32_t)0x00000001)               /*!< Command FIFO Empty */
S#define DSI_GPSR_CMDFF                 ((uint32_t)0x00000002)               /*!< Command FIFO Full */
S#define DSI_GPSR_PWRFE                 ((uint32_t)0x00000004)               /*!< Payload Write FIFO Empty */
S#define DSI_GPSR_PWRFF                 ((uint32_t)0x00000008)               /*!< Payload Write FIFO Full */
S#define DSI_GPSR_PRDFE                 ((uint32_t)0x00000010)               /*!< Payload Read FIFO Empty */
S#define DSI_GPSR_PRDFF                 ((uint32_t)0x00000020)               /*!< Payload Read FIFO Full */
S#define DSI_GPSR_RCB                   ((uint32_t)0x00000040)               /*!< Read Command Busy */
S
S/*******************  Bit definition for DSI_TCCR0 register  **************/
S#define DSI_TCCR0_LPRX_TOCNT           ((uint32_t)0x0000FFFF)               /*!< Low-power Reception Timeout Counter */
S#define DSI_TCCR0_LPRX_TOCNT0          ((uint32_t)0x00000001)
S#define DSI_TCCR0_LPRX_TOCNT1          ((uint32_t)0x00000002)
S#define DSI_TCCR0_LPRX_TOCNT2          ((uint32_t)0x00000004)
S#define DSI_TCCR0_LPRX_TOCNT3          ((uint32_t)0x00000008)
S#define DSI_TCCR0_LPRX_TOCNT4          ((uint32_t)0x00000010)
S#define DSI_TCCR0_LPRX_TOCNT5          ((uint32_t)0x00000020)
S#define DSI_TCCR0_LPRX_TOCNT6          ((uint32_t)0x00000040)
S#define DSI_TCCR0_LPRX_TOCNT7          ((uint32_t)0x00000080)
S#define DSI_TCCR0_LPRX_TOCNT8          ((uint32_t)0x00000100)
S#define DSI_TCCR0_LPRX_TOCNT9          ((uint32_t)0x00000200)
S#define DSI_TCCR0_LPRX_TOCNT10         ((uint32_t)0x00000400)
S#define DSI_TCCR0_LPRX_TOCNT11         ((uint32_t)0x00000800)
S#define DSI_TCCR0_LPRX_TOCNT12         ((uint32_t)0x00001000)
S#define DSI_TCCR0_LPRX_TOCNT13         ((uint32_t)0x00002000)
S#define DSI_TCCR0_LPRX_TOCNT14         ((uint32_t)0x00004000)
S#define DSI_TCCR0_LPRX_TOCNT15         ((uint32_t)0x00008000)
S
S#define DSI_TCCR0_HSTX_TOCNT           ((uint32_t)0xFFFF0000)               /*!< High-Speed Transmission Timeout Counter */
S#define DSI_TCCR0_HSTX_TOCNT0          ((uint32_t)0x00010000)
S#define DSI_TCCR0_HSTX_TOCNT1          ((uint32_t)0x00020000)
S#define DSI_TCCR0_HSTX_TOCNT2          ((uint32_t)0x00040000)
S#define DSI_TCCR0_HSTX_TOCNT3          ((uint32_t)0x00080000)
S#define DSI_TCCR0_HSTX_TOCNT4          ((uint32_t)0x00100000)
S#define DSI_TCCR0_HSTX_TOCNT5          ((uint32_t)0x00200000)
S#define DSI_TCCR0_HSTX_TOCNT6          ((uint32_t)0x00400000)
S#define DSI_TCCR0_HSTX_TOCNT7          ((uint32_t)0x00800000)
S#define DSI_TCCR0_HSTX_TOCNT8          ((uint32_t)0x01000000)
S#define DSI_TCCR0_HSTX_TOCNT9          ((uint32_t)0x02000000)
S#define DSI_TCCR0_HSTX_TOCNT10         ((uint32_t)0x04000000)
S#define DSI_TCCR0_HSTX_TOCNT11         ((uint32_t)0x08000000)
S#define DSI_TCCR0_HSTX_TOCNT12         ((uint32_t)0x10000000)
S#define DSI_TCCR0_HSTX_TOCNT13         ((uint32_t)0x20000000)
S#define DSI_TCCR0_HSTX_TOCNT14         ((uint32_t)0x40000000)
S#define DSI_TCCR0_HSTX_TOCNT15         ((uint32_t)0x80000000)
S
S/*******************  Bit definition for DSI_TCCR1 register  **************/
S#define DSI_TCCR1_HSRD_TOCNT           ((uint32_t)0x0000FFFF)               /*!< High-Speed Read Timeout Counter */
S#define DSI_TCCR1_HSRD_TOCNT0          ((uint32_t)0x00000001)
S#define DSI_TCCR1_HSRD_TOCNT1          ((uint32_t)0x00000002)
S#define DSI_TCCR1_HSRD_TOCNT2          ((uint32_t)0x00000004)
S#define DSI_TCCR1_HSRD_TOCNT3          ((uint32_t)0x00000008)
S#define DSI_TCCR1_HSRD_TOCNT4          ((uint32_t)0x00000010)
S#define DSI_TCCR1_HSRD_TOCNT5          ((uint32_t)0x00000020)
S#define DSI_TCCR1_HSRD_TOCNT6          ((uint32_t)0x00000040)
S#define DSI_TCCR1_HSRD_TOCNT7          ((uint32_t)0x00000080)
S#define DSI_TCCR1_HSRD_TOCNT8          ((uint32_t)0x00000100)
S#define DSI_TCCR1_HSRD_TOCNT9          ((uint32_t)0x00000200)
S#define DSI_TCCR1_HSRD_TOCNT10         ((uint32_t)0x00000400)
S#define DSI_TCCR1_HSRD_TOCNT11         ((uint32_t)0x00000800)
S#define DSI_TCCR1_HSRD_TOCNT12         ((uint32_t)0x00001000)
S#define DSI_TCCR1_HSRD_TOCNT13         ((uint32_t)0x00002000)
S#define DSI_TCCR1_HSRD_TOCNT14         ((uint32_t)0x00004000)
S#define DSI_TCCR1_HSRD_TOCNT15         ((uint32_t)0x00008000)
S
S/*******************  Bit definition for DSI_TCCR2 register  **************/
S#define DSI_TCCR2_LPRD_TOCNT           ((uint32_t)0x0000FFFF)               /*!< Low-Power Read Timeout Counter */
S#define DSI_TCCR2_LPRD_TOCNT0          ((uint32_t)0x00000001)
S#define DSI_TCCR2_LPRD_TOCNT1          ((uint32_t)0x00000002)
S#define DSI_TCCR2_LPRD_TOCNT2          ((uint32_t)0x00000004)
S#define DSI_TCCR2_LPRD_TOCNT3          ((uint32_t)0x00000008)
S#define DSI_TCCR2_LPRD_TOCNT4          ((uint32_t)0x00000010)
S#define DSI_TCCR2_LPRD_TOCNT5          ((uint32_t)0x00000020)
S#define DSI_TCCR2_LPRD_TOCNT6          ((uint32_t)0x00000040)
S#define DSI_TCCR2_LPRD_TOCNT7          ((uint32_t)0x00000080)
S#define DSI_TCCR2_LPRD_TOCNT8          ((uint32_t)0x00000100)
S#define DSI_TCCR2_LPRD_TOCNT9          ((uint32_t)0x00000200)
S#define DSI_TCCR2_LPRD_TOCNT10         ((uint32_t)0x00000400)
S#define DSI_TCCR2_LPRD_TOCNT11         ((uint32_t)0x00000800)
S#define DSI_TCCR2_LPRD_TOCNT12         ((uint32_t)0x00001000)
S#define DSI_TCCR2_LPRD_TOCNT13         ((uint32_t)0x00002000)
S#define DSI_TCCR2_LPRD_TOCNT14         ((uint32_t)0x00004000)
S#define DSI_TCCR2_LPRD_TOCNT15         ((uint32_t)0x00008000)
S
S/*******************  Bit definition for DSI_TCCR3 register  **************/
S#define DSI_TCCR3_HSWR_TOCNT           ((uint32_t)0x0000FFFF)               /*!< High-Speed Write Timeout Counter */
S#define DSI_TCCR3_HSWR_TOCNT0          ((uint32_t)0x00000001)
S#define DSI_TCCR3_HSWR_TOCNT1          ((uint32_t)0x00000002)
S#define DSI_TCCR3_HSWR_TOCNT2          ((uint32_t)0x00000004)
S#define DSI_TCCR3_HSWR_TOCNT3          ((uint32_t)0x00000008)
S#define DSI_TCCR3_HSWR_TOCNT4          ((uint32_t)0x00000010)
S#define DSI_TCCR3_HSWR_TOCNT5          ((uint32_t)0x00000020)
S#define DSI_TCCR3_HSWR_TOCNT6          ((uint32_t)0x00000040)
S#define DSI_TCCR3_HSWR_TOCNT7          ((uint32_t)0x00000080)
S#define DSI_TCCR3_HSWR_TOCNT8          ((uint32_t)0x00000100)
S#define DSI_TCCR3_HSWR_TOCNT9          ((uint32_t)0x00000200)
S#define DSI_TCCR3_HSWR_TOCNT10         ((uint32_t)0x00000400)
S#define DSI_TCCR3_HSWR_TOCNT11         ((uint32_t)0x00000800)
S#define DSI_TCCR3_HSWR_TOCNT12         ((uint32_t)0x00001000)
S#define DSI_TCCR3_HSWR_TOCNT13         ((uint32_t)0x00002000)
S#define DSI_TCCR3_HSWR_TOCNT14         ((uint32_t)0x00004000)
S#define DSI_TCCR3_HSWR_TOCNT15         ((uint32_t)0x00008000)
S
S#define DSI_TCCR3_PM                   ((uint32_t)0x01000000)               /*!< Presp Mode */
S
S/*******************  Bit definition for DSI_TCCR4 register  **************/
S#define DSI_TCCR4_LPWR_TOCNT           ((uint32_t)0x0000FFFF)               /*!< Low-Power Write Timeout Counter */
S#define DSI_TCCR4_LPWR_TOCNT0          ((uint32_t)0x00000001)
S#define DSI_TCCR4_LPWR_TOCNT1          ((uint32_t)0x00000002)
S#define DSI_TCCR4_LPWR_TOCNT2          ((uint32_t)0x00000004)
S#define DSI_TCCR4_LPWR_TOCNT3          ((uint32_t)0x00000008)
S#define DSI_TCCR4_LPWR_TOCNT4          ((uint32_t)0x00000010)
S#define DSI_TCCR4_LPWR_TOCNT5          ((uint32_t)0x00000020)
S#define DSI_TCCR4_LPWR_TOCNT6          ((uint32_t)0x00000040)
S#define DSI_TCCR4_LPWR_TOCNT7          ((uint32_t)0x00000080)
S#define DSI_TCCR4_LPWR_TOCNT8          ((uint32_t)0x00000100)
S#define DSI_TCCR4_LPWR_TOCNT9          ((uint32_t)0x00000200)
S#define DSI_TCCR4_LPWR_TOCNT10         ((uint32_t)0x00000400)
S#define DSI_TCCR4_LPWR_TOCNT11         ((uint32_t)0x00000800)
S#define DSI_TCCR4_LPWR_TOCNT12         ((uint32_t)0x00001000)
S#define DSI_TCCR4_LPWR_TOCNT13         ((uint32_t)0x00002000)
S#define DSI_TCCR4_LPWR_TOCNT14         ((uint32_t)0x00004000)
S#define DSI_TCCR4_LPWR_TOCNT15         ((uint32_t)0x00008000)
S
S/*******************  Bit definition for DSI_TCCR5 register  **************/
S#define DSI_TCCR5_BTA_TOCNT            ((uint32_t)0x0000FFFF)               /*!< Bus-Turn-Around Timeout Counter */
S#define DSI_TCCR5_BTA_TOCNT0           ((uint32_t)0x00000001)
S#define DSI_TCCR5_BTA_TOCNT1           ((uint32_t)0x00000002)
S#define DSI_TCCR5_BTA_TOCNT2           ((uint32_t)0x00000004)
S#define DSI_TCCR5_BTA_TOCNT3           ((uint32_t)0x00000008)
S#define DSI_TCCR5_BTA_TOCNT4           ((uint32_t)0x00000010)
S#define DSI_TCCR5_BTA_TOCNT5           ((uint32_t)0x00000020)
S#define DSI_TCCR5_BTA_TOCNT6           ((uint32_t)0x00000040)
S#define DSI_TCCR5_BTA_TOCNT7           ((uint32_t)0x00000080)
S#define DSI_TCCR5_BTA_TOCNT8           ((uint32_t)0x00000100)
S#define DSI_TCCR5_BTA_TOCNT9           ((uint32_t)0x00000200)
S#define DSI_TCCR5_BTA_TOCNT10          ((uint32_t)0x00000400)
S#define DSI_TCCR5_BTA_TOCNT11          ((uint32_t)0x00000800)
S#define DSI_TCCR5_BTA_TOCNT12          ((uint32_t)0x00001000)
S#define DSI_TCCR5_BTA_TOCNT13          ((uint32_t)0x00002000)
S#define DSI_TCCR5_BTA_TOCNT14          ((uint32_t)0x00004000)
S#define DSI_TCCR5_BTA_TOCNT15          ((uint32_t)0x00008000)
S
S/*******************  Bit definition for DSI_TDCR register  ***************/
S#define DSI_TDCR_3DM                   ((uint32_t)0x00000003)               /*!< 3D Mode */
S#define DSI_TDCR_3DM0                  ((uint32_t)0x00000001)
S#define DSI_TDCR_3DM1                  ((uint32_t)0x00000002)
S
S#define DSI_TDCR_3DF                   ((uint32_t)0x0000000C)               /*!< 3D Format */
S#define DSI_TDCR_3DF0                  ((uint32_t)0x00000004)
S#define DSI_TDCR_3DF1                  ((uint32_t)0x00000008)
S
S#define DSI_TDCR_SVS                   ((uint32_t)0x00000010)               /*!< Second VSYNC */
S#define DSI_TDCR_RF                    ((uint32_t)0x00000020)               /*!< Right First */
S#define DSI_TDCR_S3DC                  ((uint32_t)0x00010000)               /*!< Send 3D Control */
S
S/*******************  Bit definition for DSI_CLCR register  ***************/
S#define DSI_CLCR_DPCC                  ((uint32_t)0x00000001)               /*!< D-PHY Clock Control */
S#define DSI_CLCR_ACR                   ((uint32_t)0x00000002)               /*!< Automatic Clocklane Control */
S
S/*******************  Bit definition for DSI_CLTCR register  **************/
S#define DSI_CLTCR_LP2HS_TIME           ((uint32_t)0x000003FF)               /*!< Low-Power to High-Speed Time */
S#define DSI_CLTCR_LP2HS_TIME0          ((uint32_t)0x00000001)
S#define DSI_CLTCR_LP2HS_TIME1          ((uint32_t)0x00000002)
S#define DSI_CLTCR_LP2HS_TIME2          ((uint32_t)0x00000004)
S#define DSI_CLTCR_LP2HS_TIME3          ((uint32_t)0x00000008)
S#define DSI_CLTCR_LP2HS_TIME4          ((uint32_t)0x00000010)
S#define DSI_CLTCR_LP2HS_TIME5          ((uint32_t)0x00000020)
S#define DSI_CLTCR_LP2HS_TIME6          ((uint32_t)0x00000040)
S#define DSI_CLTCR_LP2HS_TIME7          ((uint32_t)0x00000080)
S#define DSI_CLTCR_LP2HS_TIME8          ((uint32_t)0x00000100)
S#define DSI_CLTCR_LP2HS_TIME9          ((uint32_t)0x00000200)
S
S#define DSI_CLTCR_HS2LP_TIME           ((uint32_t)0x03FF0000)               /*!< High-Speed to Low-Power Time */
S#define DSI_CLTCR_HS2LP_TIME0          ((uint32_t)0x00010000)
S#define DSI_CLTCR_HS2LP_TIME1          ((uint32_t)0x00020000)
S#define DSI_CLTCR_HS2LP_TIME2          ((uint32_t)0x00040000)
S#define DSI_CLTCR_HS2LP_TIME3          ((uint32_t)0x00080000)
S#define DSI_CLTCR_HS2LP_TIME4          ((uint32_t)0x00100000)
S#define DSI_CLTCR_HS2LP_TIME5          ((uint32_t)0x00200000)
S#define DSI_CLTCR_HS2LP_TIME6          ((uint32_t)0x00400000)
S#define DSI_CLTCR_HS2LP_TIME7          ((uint32_t)0x00800000)
S#define DSI_CLTCR_HS2LP_TIME8          ((uint32_t)0x01000000)
S#define DSI_CLTCR_HS2LP_TIME9          ((uint32_t)0x02000000)
S
S/*******************  Bit definition for DSI_DLTCR register  **************/
S#define DSI_DLTCR_MRD_TIME             ((uint32_t)0x00007FFF)               /*!< Maximum Read Time */
S#define DSI_DLTCR_MRD_TIME0            ((uint32_t)0x00000001)
S#define DSI_DLTCR_MRD_TIME1            ((uint32_t)0x00000002)
S#define DSI_DLTCR_MRD_TIME2            ((uint32_t)0x00000004)
S#define DSI_DLTCR_MRD_TIME3            ((uint32_t)0x00000008)
S#define DSI_DLTCR_MRD_TIME4            ((uint32_t)0x00000010)
S#define DSI_DLTCR_MRD_TIME5            ((uint32_t)0x00000020)
S#define DSI_DLTCR_MRD_TIME6            ((uint32_t)0x00000040)
S#define DSI_DLTCR_MRD_TIME7            ((uint32_t)0x00000080)
S#define DSI_DLTCR_MRD_TIME8            ((uint32_t)0x00000100)
S#define DSI_DLTCR_MRD_TIME9            ((uint32_t)0x00000200)
S#define DSI_DLTCR_MRD_TIME10           ((uint32_t)0x00000400)
S#define DSI_DLTCR_MRD_TIME11           ((uint32_t)0x00000800)
S#define DSI_DLTCR_MRD_TIME12           ((uint32_t)0x00001000)
S#define DSI_DLTCR_MRD_TIME13           ((uint32_t)0x00002000)
S#define DSI_DLTCR_MRD_TIME14           ((uint32_t)0x00004000)
S
S#define DSI_DLTCR_LP2HS_TIME           ((uint32_t)0x00FF0000)               /*!< Low-Power To High-Speed Time */
S#define DSI_DLTCR_LP2HS_TIME0          ((uint32_t)0x00010000)
S#define DSI_DLTCR_LP2HS_TIME1          ((uint32_t)0x00020000)
S#define DSI_DLTCR_LP2HS_TIME2          ((uint32_t)0x00040000)
S#define DSI_DLTCR_LP2HS_TIME3          ((uint32_t)0x00080000)
S#define DSI_DLTCR_LP2HS_TIME4          ((uint32_t)0x00100000)
S#define DSI_DLTCR_LP2HS_TIME5          ((uint32_t)0x00200000)
S#define DSI_DLTCR_LP2HS_TIME6          ((uint32_t)0x00400000)
S#define DSI_DLTCR_LP2HS_TIME7          ((uint32_t)0x00800000)
S
S#define DSI_DLTCR_HS2LP_TIME           ((uint32_t)0xFF000000)               /*!< High-Speed To Low-Power Time */
S#define DSI_DLTCR_HS2LP_TIME0          ((uint32_t)0x01000000)
S#define DSI_DLTCR_HS2LP_TIME1          ((uint32_t)0x02000000)
S#define DSI_DLTCR_HS2LP_TIME2          ((uint32_t)0x04000000)
S#define DSI_DLTCR_HS2LP_TIME3          ((uint32_t)0x08000000)
S#define DSI_DLTCR_HS2LP_TIME4          ((uint32_t)0x10000000)
S#define DSI_DLTCR_HS2LP_TIME5          ((uint32_t)0x20000000)
S#define DSI_DLTCR_HS2LP_TIME6          ((uint32_t)0x40000000)
S#define DSI_DLTCR_HS2LP_TIME7          ((uint32_t)0x80000000)
S
S/*******************  Bit definition for DSI_PCTLR register  **************/
S#define DSI_PCTLR_DEN                  ((uint32_t)0x00000002)               /*!< Digital Enable */
S#define DSI_PCTLR_CKE                  ((uint32_t)0x00000004)               /*!< Clock Enable */
S
S/*******************  Bit definition for DSI_PCONFR register  *************/
S#define DSI_PCONFR_NL                  ((uint32_t)0x00000003)               /*!< Number of Lanes */
S#define DSI_PCONFR_NL0                 ((uint32_t)0x00000001)
S#define DSI_PCONFR_NL1                 ((uint32_t)0x00000002)
S                                     
S#define DSI_PCONFR_SW_TIME             ((uint32_t)0x0000FF00)               /*!< Stop Wait Time */
S#define DSI_PCONFR_SW_TIME0            ((uint32_t)0x00000100)
S#define DSI_PCONFR_SW_TIME1            ((uint32_t)0x00000200)
S#define DSI_PCONFR_SW_TIME2            ((uint32_t)0x00000400)
S#define DSI_PCONFR_SW_TIME3            ((uint32_t)0x00000800)
S#define DSI_PCONFR_SW_TIME4            ((uint32_t)0x00001000)
S#define DSI_PCONFR_SW_TIME5            ((uint32_t)0x00002000)
S#define DSI_PCONFR_SW_TIME6            ((uint32_t)0x00004000)
S#define DSI_PCONFR_SW_TIME7            ((uint32_t)0x00008000)
S
S/*******************  Bit definition for DSI_PUCR register  ***************/
S#define DSI_PUCR_URCL                  ((uint32_t)0x00000001)               /*!< ULPS Request on Clock Lane */
S#define DSI_PUCR_UECL                  ((uint32_t)0x00000002)               /*!< ULPS Exit on Clock Lane */
S#define DSI_PUCR_URDL                  ((uint32_t)0x00000004)               /*!< ULPS Request on Data Lane */
S#define DSI_PUCR_UEDL                  ((uint32_t)0x00000008)               /*!< ULPS Exit on Data Lane */
S
S/*******************  Bit definition for DSI_PTTCR register  **************/
S#define DSI_PTTCR_TX_TRIG              ((uint32_t)0x0000000F)               /*!< Transmission Trigger */
S#define DSI_PTTCR_TX_TRIG0             ((uint32_t)0x00000001)
S#define DSI_PTTCR_TX_TRIG1             ((uint32_t)0x00000002)
S#define DSI_PTTCR_TX_TRIG2             ((uint32_t)0x00000004)
S#define DSI_PTTCR_TX_TRIG3             ((uint32_t)0x00000008)
S
S/*******************  Bit definition for DSI_PSR register  ****************/
S#define DSI_PSR_PD                     ((uint32_t)0x00000002)               /*!< PHY Direction */
S#define DSI_PSR_PSSC                   ((uint32_t)0x00000004)               /*!< PHY Stop State Clock lane */
S#define DSI_PSR_UANC                   ((uint32_t)0x00000008)               /*!< ULPS Active Not Clock lane */
S#define DSI_PSR_PSS0                   ((uint32_t)0x00000010)               /*!< PHY Stop State lane 0 */
S#define DSI_PSR_UAN0                   ((uint32_t)0x00000020)               /*!< ULPS Active Not lane 0 */
S#define DSI_PSR_RUE0                   ((uint32_t)0x00000040)               /*!< RX ULPS Escape lane 0 */
S#define DSI_PSR_PSS1                   ((uint32_t)0x00000080)               /*!< PHY Stop State lane 1 */
S#define DSI_PSR_UAN1                   ((uint32_t)0x00000100)               /*!< ULPS Active Not lane 1 */
S
S/*******************  Bit definition for DSI_ISR0 register  ***************/
S#define DSI_ISR0_AE0                   ((uint32_t)0x00000001)               /*!< Acknowledge Error 0 */
S#define DSI_ISR0_AE1                   ((uint32_t)0x00000002)               /*!< Acknowledge Error 1 */
S#define DSI_ISR0_AE2                   ((uint32_t)0x00000004)               /*!< Acknowledge Error 2 */
S#define DSI_ISR0_AE3                   ((uint32_t)0x00000008)               /*!< Acknowledge Error 3 */
S#define DSI_ISR0_AE4                   ((uint32_t)0x00000010)               /*!< Acknowledge Error 4 */
S#define DSI_ISR0_AE5                   ((uint32_t)0x00000020)               /*!< Acknowledge Error 5 */
S#define DSI_ISR0_AE6                   ((uint32_t)0x00000040)               /*!< Acknowledge Error 6 */
S#define DSI_ISR0_AE7                   ((uint32_t)0x00000080)               /*!< Acknowledge Error 7 */
S#define DSI_ISR0_AE8                   ((uint32_t)0x00000100)               /*!< Acknowledge Error 8 */
S#define DSI_ISR0_AE9                   ((uint32_t)0x00000200)               /*!< Acknowledge Error 9 */
S#define DSI_ISR0_AE10                  ((uint32_t)0x00000400)               /*!< Acknowledge Error 10 */
S#define DSI_ISR0_AE11                  ((uint32_t)0x00000800)               /*!< Acknowledge Error 11 */
S#define DSI_ISR0_AE12                  ((uint32_t)0x00001000)               /*!< Acknowledge Error 12 */
S#define DSI_ISR0_AE13                  ((uint32_t)0x00002000)               /*!< Acknowledge Error 13 */
S#define DSI_ISR0_AE14                  ((uint32_t)0x00004000)               /*!< Acknowledge Error 14 */
S#define DSI_ISR0_AE15                  ((uint32_t)0x00008000)               /*!< Acknowledge Error 15 */
S#define DSI_ISR0_PE0                   ((uint32_t)0x00010000)               /*!< PHY Error 0 */
S#define DSI_ISR0_PE1                   ((uint32_t)0x00020000)               /*!< PHY Error 1 */
S#define DSI_ISR0_PE2                   ((uint32_t)0x00040000)               /*!< PHY Error 2 */
S#define DSI_ISR0_PE3                   ((uint32_t)0x00080000)               /*!< PHY Error 3 */
S#define DSI_ISR0_PE4                   ((uint32_t)0x00100000)               /*!< PHY Error 4 */
S
S/*******************  Bit definition for DSI_ISR1 register  ***************/
S#define DSI_ISR1_TOHSTX                ((uint32_t)0x00000001)               /*!< Timeout High-Speed Transmission */
S#define DSI_ISR1_TOLPRX                ((uint32_t)0x00000002)               /*!< Timeout Low-Power Reception */
S#define DSI_ISR1_ECCSE                 ((uint32_t)0x00000004)               /*!< ECC Single-bit Error */
S#define DSI_ISR1_ECCME                 ((uint32_t)0x00000008)               /*!< ECC Multi-bit Error */
S#define DSI_ISR1_CRCE                  ((uint32_t)0x00000010)               /*!< CRC Error */
S#define DSI_ISR1_PSE                   ((uint32_t)0x00000020)               /*!< Packet Size Error */
S#define DSI_ISR1_EOTPE                 ((uint32_t)0x00000040)               /*!< EoTp Error */
S#define DSI_ISR1_LPWRE                 ((uint32_t)0x00000080)               /*!< LTDC Payload Write Error */
S#define DSI_ISR1_GCWRE                 ((uint32_t)0x00000100)               /*!< Generic Command Write Error */
S#define DSI_ISR1_GPWRE                 ((uint32_t)0x00000200)               /*!< Generic Payload Write Error */
S#define DSI_ISR1_GPTXE                 ((uint32_t)0x00000400)               /*!< Generic Payload Transmit Error */
S#define DSI_ISR1_GPRDE                 ((uint32_t)0x00000800)               /*!< Generic Payload Read Error */
S#define DSI_ISR1_GPRXE                 ((uint32_t)0x00001000)               /*!< Generic Payload Receive Error */
S
S/*******************  Bit definition for DSI_IER0 register  ***************/
S#define DSI_IER0_AE0IE                 ((uint32_t)0x00000001)               /*!< Acknowledge Error 0 Interrupt Enable */
S#define DSI_IER0_AE1IE                 ((uint32_t)0x00000002)               /*!< Acknowledge Error 1 Interrupt Enable */
S#define DSI_IER0_AE2IE                 ((uint32_t)0x00000004)               /*!< Acknowledge Error 2 Interrupt Enable */
S#define DSI_IER0_AE3IE                 ((uint32_t)0x00000008)               /*!< Acknowledge Error 3 Interrupt Enable */
S#define DSI_IER0_AE4IE                 ((uint32_t)0x00000010)               /*!< Acknowledge Error 4 Interrupt Enable */
S#define DSI_IER0_AE5IE                 ((uint32_t)0x00000020)               /*!< Acknowledge Error 5 Interrupt Enable */
S#define DSI_IER0_AE6IE                 ((uint32_t)0x00000040)               /*!< Acknowledge Error 6 Interrupt Enable */
S#define DSI_IER0_AE7IE                 ((uint32_t)0x00000080)               /*!< Acknowledge Error 7 Interrupt Enable */
S#define DSI_IER0_AE8IE                 ((uint32_t)0x00000100)               /*!< Acknowledge Error 8 Interrupt Enable */
S#define DSI_IER0_AE9IE                 ((uint32_t)0x00000200)               /*!< Acknowledge Error 9 Interrupt Enable */
S#define DSI_IER0_AE10IE                ((uint32_t)0x00000400)               /*!< Acknowledge Error 10 Interrupt Enable */
S#define DSI_IER0_AE11IE                ((uint32_t)0x00000800)               /*!< Acknowledge Error 11 Interrupt Enable */
S#define DSI_IER0_AE12IE                ((uint32_t)0x00001000)               /*!< Acknowledge Error 12 Interrupt Enable */
S#define DSI_IER0_AE13IE                ((uint32_t)0x00002000)               /*!< Acknowledge Error 13 Interrupt Enable */
S#define DSI_IER0_AE14IE                ((uint32_t)0x00004000)               /*!< Acknowledge Error 14 Interrupt Enable */
S#define DSI_IER0_AE15IE                ((uint32_t)0x00008000)               /*!< Acknowledge Error 15 Interrupt Enable */
S#define DSI_IER0_PE0IE                 ((uint32_t)0x00010000)               /*!< PHY Error 0 Interrupt Enable */
S#define DSI_IER0_PE1IE                 ((uint32_t)0x00020000)               /*!< PHY Error 1 Interrupt Enable */
S#define DSI_IER0_PE2IE                 ((uint32_t)0x00040000)               /*!< PHY Error 2 Interrupt Enable */
S#define DSI_IER0_PE3IE                 ((uint32_t)0x00080000)               /*!< PHY Error 3 Interrupt Enable */
S#define DSI_IER0_PE4IE                 ((uint32_t)0x00100000)               /*!< PHY Error 4 Interrupt Enable */
S
S/*******************  Bit definition for DSI_IER1 register  ***************/
S#define DSI_IER1_TOHSTXIE              ((uint32_t)0x00000001)               /*!< Timeout High-Speed Transmission Interrupt Enable */
S#define DSI_IER1_TOLPRXIE              ((uint32_t)0x00000002)               /*!< Timeout Low-Power Reception Interrupt Enable */
S#define DSI_IER1_ECCSEIE               ((uint32_t)0x00000004)               /*!< ECC Single-bit Error Interrupt Enable */
S#define DSI_IER1_ECCMEIE               ((uint32_t)0x00000008)               /*!< ECC Multi-bit Error Interrupt Enable */
S#define DSI_IER1_CRCEIE                ((uint32_t)0x00000010)               /*!< CRC Error Interrupt Enable */
S#define DSI_IER1_PSEIE                 ((uint32_t)0x00000020)               /*!< Packet Size Error Interrupt Enable */
S#define DSI_IER1_EOTPEIE               ((uint32_t)0x00000040)               /*!< EoTp Error Interrupt Enable */
S#define DSI_IER1_LPWREIE               ((uint32_t)0x00000080)               /*!< LTDC Payload Write Error Interrupt Enable */
S#define DSI_IER1_GCWREIE               ((uint32_t)0x00000100)               /*!< Generic Command Write Error Interrupt Enable */
S#define DSI_IER1_GPWREIE               ((uint32_t)0x00000200)               /*!< Generic Payload Write Error Interrupt Enable */
S#define DSI_IER1_GPTXEIE               ((uint32_t)0x00000400)               /*!< Generic Payload Transmit Error Interrupt Enable */
S#define DSI_IER1_GPRDEIE               ((uint32_t)0x00000800)               /*!< Generic Payload Read Error Interrupt Enable */
S#define DSI_IER1_GPRXEIE               ((uint32_t)0x00001000)               /*!< Generic Payload Receive Error Interrupt Enable */
S
S/*******************  Bit definition for DSI_FIR0 register  ***************/
S#define DSI_FIR0_FAE0                  ((uint32_t)0x00000001)               /*!< Force Acknowledge Error 0 */
S#define DSI_FIR0_FAE1                  ((uint32_t)0x00000002)               /*!< Force Acknowledge Error 1 */
S#define DSI_FIR0_FAE2                  ((uint32_t)0x00000004)               /*!< Force Acknowledge Error 2 */
S#define DSI_FIR0_FAE3                  ((uint32_t)0x00000008)               /*!< Force Acknowledge Error 3 */
S#define DSI_FIR0_FAE4                  ((uint32_t)0x00000010)               /*!< Force Acknowledge Error 4 */
S#define DSI_FIR0_FAE5                  ((uint32_t)0x00000020)               /*!< Force Acknowledge Error 5 */
S#define DSI_FIR0_FAE6                  ((uint32_t)0x00000040)               /*!< Force Acknowledge Error 6 */
S#define DSI_FIR0_FAE7                  ((uint32_t)0x00000080)               /*!< Force Acknowledge Error 7 */
S#define DSI_FIR0_FAE8                  ((uint32_t)0x00000100)               /*!< Force Acknowledge Error 8 */
S#define DSI_FIR0_FAE9                  ((uint32_t)0x00000200)               /*!< Force Acknowledge Error 9 */
S#define DSI_FIR0_FAE10                 ((uint32_t)0x00000400)               /*!< Force Acknowledge Error 10 */
S#define DSI_FIR0_FAE11                 ((uint32_t)0x00000800)               /*!< Force Acknowledge Error 11 */
S#define DSI_FIR0_FAE12                 ((uint32_t)0x00001000)               /*!< Force Acknowledge Error 12 */
S#define DSI_FIR0_FAE13                 ((uint32_t)0x00002000)               /*!< Force Acknowledge Error 13 */
S#define DSI_FIR0_FAE14                 ((uint32_t)0x00004000)               /*!< Force Acknowledge Error 14 */
S#define DSI_FIR0_FAE15                 ((uint32_t)0x00008000)               /*!< Force Acknowledge Error 15 */
S#define DSI_FIR0_FPE0                  ((uint32_t)0x00010000)               /*!< Force PHY Error 0 */
S#define DSI_FIR0_FPE1                  ((uint32_t)0x00020000)               /*!< Force PHY Error 1 */
S#define DSI_FIR0_FPE2                  ((uint32_t)0x00040000)               /*!< Force PHY Error 2 */
S#define DSI_FIR0_FPE3                  ((uint32_t)0x00080000)               /*!< Force PHY Error 3 */
S#define DSI_FIR0_FPE4                  ((uint32_t)0x00100000)               /*!< Force PHY Error 4 */
S
S/*******************  Bit definition for DSI_FIR1 register  ***************/
S#define DSI_FIR1_FTOHSTX               ((uint32_t)0x00000001)               /*!< Force Timeout High-Speed Transmission */
S#define DSI_FIR1_FTOLPRX               ((uint32_t)0x00000002)               /*!< Force Timeout Low-Power Reception */
S#define DSI_FIR1_FECCSE                ((uint32_t)0x00000004)               /*!< Force ECC Single-bit Error */
S#define DSI_FIR1_FECCME                ((uint32_t)0x00000008)               /*!< Force ECC Multi-bit Error */
S#define DSI_FIR1_FCRCE                 ((uint32_t)0x00000010)               /*!< Force CRC Error */
S#define DSI_FIR1_FPSE                  ((uint32_t)0x00000020)               /*!< Force Packet Size Error */
S#define DSI_FIR1_FEOTPE                ((uint32_t)0x00000040)               /*!< Force EoTp Error */
S#define DSI_FIR1_FLPWRE                ((uint32_t)0x00000080)               /*!< Force LTDC Payload Write Error */
S#define DSI_FIR1_FGCWRE                ((uint32_t)0x00000100)               /*!< Force Generic Command Write Error */
S#define DSI_FIR1_FGPWRE                ((uint32_t)0x00000200)               /*!< Force Generic Payload Write Error */
S#define DSI_FIR1_FGPTXE                ((uint32_t)0x00000400)               /*!< Force Generic Payload Transmit Error */
S#define DSI_FIR1_FGPRDE                ((uint32_t)0x00000800)               /*!< Force Generic Payload Read Error */
S#define DSI_FIR1_FGPRXE                ((uint32_t)0x00001000)               /*!< Force Generic Payload Receive Error */
S
S/*******************  Bit definition for DSI_VSCR register  ***************/
S#define DSI_VSCR_EN                    ((uint32_t)0x00000001)               /*!< Enable */
S#define DSI_VSCR_UR                    ((uint32_t)0x00000100)               /*!< Update Register */
S
S/*******************  Bit definition for DSI_LCVCIDR register  ************/
S#define DSI_LCVCIDR_VCID               ((uint32_t)0x00000003)               /*!< Virtual Channel ID */
S#define DSI_LCVCIDR_VCID0              ((uint32_t)0x00000001)
S#define DSI_LCVCIDR_VCID1              ((uint32_t)0x00000002)
S
S/*******************  Bit definition for DSI_LCCCR register  **************/
S#define DSI_LCCCR_COLC                 ((uint32_t)0x0000000F)               /*!< Color Coding */
S#define DSI_LCCCR_COLC0                ((uint32_t)0x00000001)
S#define DSI_LCCCR_COLC1                ((uint32_t)0x00000002)
S#define DSI_LCCCR_COLC2                ((uint32_t)0x00000004)
S#define DSI_LCCCR_COLC3                ((uint32_t)0x00000008)
S
S#define DSI_LCCCR_LPE                  ((uint32_t)0x00000100)               /*!< Loosely Packed Enable */
S
S/*******************  Bit definition for DSI_LPMCCR register  *************/
S#define DSI_LPMCCR_VLPSIZE             ((uint32_t)0x000000FF)               /*!< VACT Largest Packet Size */
S#define DSI_LPMCCR_VLPSIZE0            ((uint32_t)0x00000001)
S#define DSI_LPMCCR_VLPSIZE1            ((uint32_t)0x00000002)
S#define DSI_LPMCCR_VLPSIZE2            ((uint32_t)0x00000004)
S#define DSI_LPMCCR_VLPSIZE3            ((uint32_t)0x00000008)
S#define DSI_LPMCCR_VLPSIZE4            ((uint32_t)0x00000010)
S#define DSI_LPMCCR_VLPSIZE5            ((uint32_t)0x00000020)
S#define DSI_LPMCCR_VLPSIZE6            ((uint32_t)0x00000040)
S#define DSI_LPMCCR_VLPSIZE7            ((uint32_t)0x00000080)
S
S#define DSI_LPMCCR_LPSIZE              ((uint32_t)0x00FF0000)               /*!< Largest Packet Size */
S#define DSI_LPMCCR_LPSIZE0             ((uint32_t)0x00010000)
S#define DSI_LPMCCR_LPSIZE1             ((uint32_t)0x00020000)
S#define DSI_LPMCCR_LPSIZE2             ((uint32_t)0x00040000)
S#define DSI_LPMCCR_LPSIZE3             ((uint32_t)0x00080000)
S#define DSI_LPMCCR_LPSIZE4             ((uint32_t)0x00100000)
S#define DSI_LPMCCR_LPSIZE5             ((uint32_t)0x00200000)
S#define DSI_LPMCCR_LPSIZE6             ((uint32_t)0x00400000)
S#define DSI_LPMCCR_LPSIZE7             ((uint32_t)0x00800000)
S
S/*******************  Bit definition for DSI_VMCCR register  **************/
S#define DSI_VMCCR_VMT                  ((uint32_t)0x00000003)               /*!< Video Mode Type */
S#define DSI_VMCCR_VMT0                 ((uint32_t)0x00000001)
S#define DSI_VMCCR_VMT1                 ((uint32_t)0x00000002)
S
S#define DSI_VMCCR_LPVSAE               ((uint32_t)0x00000100)               /*!< Low-power Vertical Sync time Enable */
S#define DSI_VMCCR_LPVBPE               ((uint32_t)0x00000200)               /*!< Low-power Vertical Back-porch Enable */
S#define DSI_VMCCR_LPVFPE               ((uint32_t)0x00000400)               /*!< Low-power Vertical Front-porch Enable */
S#define DSI_VMCCR_LPVAE                ((uint32_t)0x00000800)               /*!< Low-power Vertical Active Enable */
S#define DSI_VMCCR_LPHBPE               ((uint32_t)0x00001000)               /*!< Low-power Horizontal Back-porch Enable */
S#define DSI_VMCCR_LPHFE                ((uint32_t)0x00002000)               /*!< Low-power Horizontal Front-porch Enable */
S#define DSI_VMCCR_FBTAAE               ((uint32_t)0x00004000)               /*!< Frame BTA Acknowledge Enable */
S#define DSI_VMCCR_LPCE                 ((uint32_t)0x00008000)               /*!< Low-power Command Enable */
S
S/*******************  Bit definition for DSI_VPCCR register  **************/
S#define DSI_VPCCR_VPSIZE               ((uint32_t)0x00003FFF)               /*!< Video Packet Size */
S#define DSI_VPCCR_VPSIZE0              ((uint32_t)0x00000001)
S#define DSI_VPCCR_VPSIZE1              ((uint32_t)0x00000002)
S#define DSI_VPCCR_VPSIZE2              ((uint32_t)0x00000004)
S#define DSI_VPCCR_VPSIZE3              ((uint32_t)0x00000008)
S#define DSI_VPCCR_VPSIZE4              ((uint32_t)0x00000010)
S#define DSI_VPCCR_VPSIZE5              ((uint32_t)0x00000020)
S#define DSI_VPCCR_VPSIZE6              ((uint32_t)0x00000040)
S#define DSI_VPCCR_VPSIZE7              ((uint32_t)0x00000080)
S#define DSI_VPCCR_VPSIZE8              ((uint32_t)0x00000100)
S#define DSI_VPCCR_VPSIZE9              ((uint32_t)0x00000200)
S#define DSI_VPCCR_VPSIZE10             ((uint32_t)0x00000400)
S#define DSI_VPCCR_VPSIZE11             ((uint32_t)0x00000800)
S#define DSI_VPCCR_VPSIZE12             ((uint32_t)0x00001000)
S#define DSI_VPCCR_VPSIZE13             ((uint32_t)0x00002000)
S
S/*******************  Bit definition for DSI_VCCCR register  **************/
S#define DSI_VCCCR_NUMC                 ((uint32_t)0x00001FFF)               /*!< Number of Chunks */
S#define DSI_VCCCR_NUMC0                ((uint32_t)0x00000001)
S#define DSI_VCCCR_NUMC1                ((uint32_t)0x00000002)
S#define DSI_VCCCR_NUMC2                ((uint32_t)0x00000004)
S#define DSI_VCCCR_NUMC3                ((uint32_t)0x00000008)
S#define DSI_VCCCR_NUMC4                ((uint32_t)0x00000010)
S#define DSI_VCCCR_NUMC5                ((uint32_t)0x00000020)
S#define DSI_VCCCR_NUMC6                ((uint32_t)0x00000040)
S#define DSI_VCCCR_NUMC7                ((uint32_t)0x00000080)
S#define DSI_VCCCR_NUMC8                ((uint32_t)0x00000100)
S#define DSI_VCCCR_NUMC9                ((uint32_t)0x00000200)
S#define DSI_VCCCR_NUMC10               ((uint32_t)0x00000400)
S#define DSI_VCCCR_NUMC11               ((uint32_t)0x00000800)
S#define DSI_VCCCR_NUMC12               ((uint32_t)0x00001000)
S
S/*******************  Bit definition for DSI_VNPCCR register  *************/
S#define DSI_VNPCCR_NPSIZE              ((uint32_t)0x00001FFF)               /*!< Number of Chunks */
S#define DSI_VNPCCR_NPSIZE0             ((uint32_t)0x00000001)
S#define DSI_VNPCCR_NPSIZE1             ((uint32_t)0x00000002)
S#define DSI_VNPCCR_NPSIZE2             ((uint32_t)0x00000004)
S#define DSI_VNPCCR_NPSIZE3             ((uint32_t)0x00000008)
S#define DSI_VNPCCR_NPSIZE4             ((uint32_t)0x00000010)
S#define DSI_VNPCCR_NPSIZE5             ((uint32_t)0x00000020)
S#define DSI_VNPCCR_NPSIZE6             ((uint32_t)0x00000040)
S#define DSI_VNPCCR_NPSIZE7             ((uint32_t)0x00000080)
S#define DSI_VNPCCR_NPSIZE8             ((uint32_t)0x00000100)
S#define DSI_VNPCCR_NPSIZE9             ((uint32_t)0x00000200)
S#define DSI_VNPCCR_NPSIZE10            ((uint32_t)0x00000400)
S#define DSI_VNPCCR_NPSIZE11            ((uint32_t)0x00000800)
S#define DSI_VNPCCR_NPSIZE12            ((uint32_t)0x00001000)
S
S/*******************  Bit definition for DSI_VHSACCR register  ************/
S#define DSI_VHSACCR_HSA                ((uint32_t)0x00000FFF)               /*!< Horizontal Synchronism Active duration */
S#define DSI_VHSACCR_HSA0               ((uint32_t)0x00000001)
S#define DSI_VHSACCR_HSA1               ((uint32_t)0x00000002)
S#define DSI_VHSACCR_HSA2               ((uint32_t)0x00000004)
S#define DSI_VHSACCR_HSA3               ((uint32_t)0x00000008)
S#define DSI_VHSACCR_HSA4               ((uint32_t)0x00000010)
S#define DSI_VHSACCR_HSA5               ((uint32_t)0x00000020)
S#define DSI_VHSACCR_HSA6               ((uint32_t)0x00000040)
S#define DSI_VHSACCR_HSA7               ((uint32_t)0x00000080)
S#define DSI_VHSACCR_HSA8               ((uint32_t)0x00000100)
S#define DSI_VHSACCR_HSA9               ((uint32_t)0x00000200)
S#define DSI_VHSACCR_HSA10              ((uint32_t)0x00000400)
S#define DSI_VHSACCR_HSA11              ((uint32_t)0x00000800)
S
S/*******************  Bit definition for DSI_VHBPCCR register  ************/
S#define DSI_VHBPCCR_HBP                ((uint32_t)0x00000FFF)               /*!< Horizontal Back-Porch duration */
S#define DSI_VHBPCCR_HBP0               ((uint32_t)0x00000001)
S#define DSI_VHBPCCR_HBP1               ((uint32_t)0x00000002)
S#define DSI_VHBPCCR_HBP2               ((uint32_t)0x00000004)
S#define DSI_VHBPCCR_HBP3               ((uint32_t)0x00000008)
S#define DSI_VHBPCCR_HBP4               ((uint32_t)0x00000010)
S#define DSI_VHBPCCR_HBP5               ((uint32_t)0x00000020)
S#define DSI_VHBPCCR_HBP6               ((uint32_t)0x00000040)
S#define DSI_VHBPCCR_HBP7               ((uint32_t)0x00000080)
S#define DSI_VHBPCCR_HBP8               ((uint32_t)0x00000100)
S#define DSI_VHBPCCR_HBP9               ((uint32_t)0x00000200)
S#define DSI_VHBPCCR_HBP10              ((uint32_t)0x00000400)
S#define DSI_VHBPCCR_HBP11              ((uint32_t)0x00000800)
S
S/*******************  Bit definition for DSI_VLCCR register  **************/
S#define DSI_VLCCR_HLINE                ((uint32_t)0x00007FFF)               /*!< Horizontal Line duration */
S#define DSI_VLCCR_HLINE0               ((uint32_t)0x00000001)
S#define DSI_VLCCR_HLINE1               ((uint32_t)0x00000002)
S#define DSI_VLCCR_HLINE2               ((uint32_t)0x00000004)
S#define DSI_VLCCR_HLINE3               ((uint32_t)0x00000008)
S#define DSI_VLCCR_HLINE4               ((uint32_t)0x00000010)
S#define DSI_VLCCR_HLINE5               ((uint32_t)0x00000020)
S#define DSI_VLCCR_HLINE6               ((uint32_t)0x00000040)
S#define DSI_VLCCR_HLINE7               ((uint32_t)0x00000080)
S#define DSI_VLCCR_HLINE8               ((uint32_t)0x00000100)
S#define DSI_VLCCR_HLINE9               ((uint32_t)0x00000200)
S#define DSI_VLCCR_HLINE10              ((uint32_t)0x00000400)
S#define DSI_VLCCR_HLINE11              ((uint32_t)0x00000800)
S#define DSI_VLCCR_HLINE12              ((uint32_t)0x00001000)
S#define DSI_VLCCR_HLINE13              ((uint32_t)0x00002000)
S#define DSI_VLCCR_HLINE14              ((uint32_t)0x00004000)
S
S/*******************  Bit definition for DSI_VVSACCR register  ***************/
S#define DSI_VVSACCR_VSA                   ((uint32_t)0x000003FF)               /*!< Vertical Synchronism Active duration */
S#define DSI_VVSACCR_VSA0                  ((uint32_t)0x00000001)
S#define DSI_VVSACCR_VSA1                  ((uint32_t)0x00000002)
S#define DSI_VVSACCR_VSA2                  ((uint32_t)0x00000004)
S#define DSI_VVSACCR_VSA3                  ((uint32_t)0x00000008)
S#define DSI_VVSACCR_VSA4                  ((uint32_t)0x00000010)
S#define DSI_VVSACCR_VSA5                  ((uint32_t)0x00000020)
S#define DSI_VVSACCR_VSA6                  ((uint32_t)0x00000040)
S#define DSI_VVSACCR_VSA7                  ((uint32_t)0x00000080)
S#define DSI_VVSACCR_VSA8                  ((uint32_t)0x00000100)
S#define DSI_VVSACCR_VSA9                  ((uint32_t)0x00000200)
S
S/*******************  Bit definition for DSI_VVBPCCR register  ************/
S#define DSI_VVBPCCR_VBP                ((uint32_t)0x000003FF)               /*!< Vertical Back-Porch duration */
S#define DSI_VVBPCCR_VBP0               ((uint32_t)0x00000001)
S#define DSI_VVBPCCR_VBP1               ((uint32_t)0x00000002)
S#define DSI_VVBPCCR_VBP2               ((uint32_t)0x00000004)
S#define DSI_VVBPCCR_VBP3               ((uint32_t)0x00000008)
S#define DSI_VVBPCCR_VBP4               ((uint32_t)0x00000010)
S#define DSI_VVBPCCR_VBP5               ((uint32_t)0x00000020)
S#define DSI_VVBPCCR_VBP6               ((uint32_t)0x00000040)
S#define DSI_VVBPCCR_VBP7               ((uint32_t)0x00000080)
S#define DSI_VVBPCCR_VBP8               ((uint32_t)0x00000100)
S#define DSI_VVBPCCR_VBP9               ((uint32_t)0x00000200)
S
S/*******************  Bit definition for DSI_VVFPCCR register  ************/
S#define DSI_VVFPCCR_VFP                ((uint32_t)0x000003FF)               /*!< Vertical Front-Porch duration */
S#define DSI_VVFPCCR_VFP0               ((uint32_t)0x00000001)
S#define DSI_VVFPCCR_VFP1               ((uint32_t)0x00000002)
S#define DSI_VVFPCCR_VFP2               ((uint32_t)0x00000004)
S#define DSI_VVFPCCR_VFP3               ((uint32_t)0x00000008)
S#define DSI_VVFPCCR_VFP4               ((uint32_t)0x00000010)
S#define DSI_VVFPCCR_VFP5               ((uint32_t)0x00000020)
S#define DSI_VVFPCCR_VFP6               ((uint32_t)0x00000040)
S#define DSI_VVFPCCR_VFP7               ((uint32_t)0x00000080)
S#define DSI_VVFPCCR_VFP8               ((uint32_t)0x00000100)
S#define DSI_VVFPCCR_VFP9               ((uint32_t)0x00000200)
S
S/*******************  Bit definition for DSI_VVACCR register  *************/
S#define DSI_VVACCR_VA                  ((uint32_t)0x00003FFF)               /*!< Vertical Active duration */
S#define DSI_VVACCR_VA0                 ((uint32_t)0x00000001)
S#define DSI_VVACCR_VA1                 ((uint32_t)0x00000002)
S#define DSI_VVACCR_VA2                 ((uint32_t)0x00000004)
S#define DSI_VVACCR_VA3                 ((uint32_t)0x00000008)
S#define DSI_VVACCR_VA4                 ((uint32_t)0x00000010)
S#define DSI_VVACCR_VA5                 ((uint32_t)0x00000020)
S#define DSI_VVACCR_VA6                 ((uint32_t)0x00000040)
S#define DSI_VVACCR_VA7                 ((uint32_t)0x00000080)
S#define DSI_VVACCR_VA8                 ((uint32_t)0x00000100)
S#define DSI_VVACCR_VA9                 ((uint32_t)0x00000200)
S#define DSI_VVACCR_VA10                ((uint32_t)0x00000400)
S#define DSI_VVACCR_VA11                ((uint32_t)0x00000800)
S#define DSI_VVACCR_VA12                ((uint32_t)0x00001000)
S#define DSI_VVACCR_VA13                ((uint32_t)0x00002000)
S
S/*******************  Bit definition for DSI_TDCCR register  **************/
S#define DSI_TDCCR_3DM                  ((uint32_t)0x00000003)               /*!< 3D Mode */
S#define DSI_TDCCR_3DM0                 ((uint32_t)0x00000001)
S#define DSI_TDCCR_3DM1                 ((uint32_t)0x00000002)
S
S#define DSI_TDCCR_3DF                  ((uint32_t)0x0000000C)               /*!< 3D Format */
S#define DSI_TDCCR_3DF0                 ((uint32_t)0x00000004)
S#define DSI_TDCCR_3DF1                 ((uint32_t)0x00000008)
S
S#define DSI_TDCCR_SVS                  ((uint32_t)0x00000010)               /*!< Second VSYNC */
S#define DSI_TDCCR_RF                   ((uint32_t)0x00000020)               /*!< Right First */
S#define DSI_TDCCR_S3DC                 ((uint32_t)0x00010000)               /*!< Send 3D Control */
S
S/*******************  Bit definition for DSI_WCFGR register  ***************/
S#define DSI_WCFGR_DSIM                   ((uint32_t)0x00000001)              /*!< DSI Mode */
S#define DSI_WCFGR_COLMUX                 ((uint32_t)0x0000000E)              /*!< Color Multiplexing */
S#define DSI_WCFGR_COLMUX0                ((uint32_t)0x00000002)
S#define DSI_WCFGR_COLMUX1                ((uint32_t)0x00000004)
S#define DSI_WCFGR_COLMUX2                ((uint32_t)0x00000008)
S 
S#define DSI_WCFGR_TESRC                  ((uint32_t)0x00000010)              /*!< Tearing Effect Source */
S#define DSI_WCFGR_TEPOL                  ((uint32_t)0x00000020)              /*!< Tearing Effect Polarity */
S#define DSI_WCFGR_AR                     ((uint32_t)0x00000040)              /*!< Automatic Refresh */
S#define DSI_WCFGR_VSPOL                  ((uint32_t)0x00000080)              /*!< VSync Polarity */
S
S/*******************  Bit definition for DSI_WCR register  *****************/
S#define DSI_WCR_COLM                     ((uint32_t)0x00000001)              /*!< Color Mode */
S#define DSI_WCR_SHTDN                    ((uint32_t)0x00000002)              /*!< Shutdown */
S#define DSI_WCR_LTDCEN                   ((uint32_t)0x00000004)              /*!< LTDC Enable */
S#define DSI_WCR_DSIEN                    ((uint32_t)0x00000008)              /*!< DSI Enable */
S
S/*******************  Bit definition for DSI_WIER register  ****************/
S#define DSI_WIER_TEIE                    ((uint32_t)0x00000001)              /*!< Tearing Effect Interrupt Enable */
S#define DSI_WIER_ERIE                    ((uint32_t)0x00000002)              /*!< End of Refresh Interrupt Enable */
S#define DSI_WIER_PLLLIE                  ((uint32_t)0x00000200)              /*!< PLL Lock Interrupt Enable */
S#define DSI_WIER_PLLUIE                  ((uint32_t)0x00000400)              /*!< PLL Unlock Interrupt Enable */
S#define DSI_WIER_RRIE                    ((uint32_t)0x00002000)              /*!< Regulator Ready Interrupt Enable */
S
S/*******************  Bit definition for DSI_WISR register  ****************/
S#define DSI_WISR_TEIF                    ((uint32_t)0x00000001)              /*!< Tearing Effect Interrupt Flag */
S#define DSI_WISR_ERIF                    ((uint32_t)0x00000002)              /*!< End of Refresh Interrupt Flag */
S#define DSI_WISR_BUSY                    ((uint32_t)0x00000004)              /*!< Busy Flag */
S#define DSI_WISR_PLLLS                   ((uint32_t)0x00000100)              /*!< PLL Lock Status */
S#define DSI_WISR_PLLLIF                  ((uint32_t)0x00000200)              /*!< PLL Lock Interrupt Flag */
S#define DSI_WISR_PLLUIF                  ((uint32_t)0x00000400)              /*!< PLL Unlock Interrupt Flag */
S#define DSI_WISR_RRS                     ((uint32_t)0x00001000)              /*!< Regulator Ready Flag */
S#define DSI_WISR_RRIF                    ((uint32_t)0x00002000)              /*!< Regulator Ready Interrupt Flag */
S
S/*******************  Bit definition for DSI_WIFCR register  ***************/
S#define DSI_WIFCR_CTEIF                  ((uint32_t)0x00000001)              /*!< Clear Tearing Effect Interrupt Flag */
S#define DSI_WIFCR_CERIF                  ((uint32_t)0x00000002)              /*!< Clear End of Refresh Interrupt Flag */
S#define DSI_WIFCR_CPLLLIF                ((uint32_t)0x00000200)              /*!< Clear PLL Lock Interrupt Flag */
S#define DSI_WIFCR_CPLLUIF                ((uint32_t)0x00000400)              /*!< Clear PLL Unlock Interrupt Flag */
S#define DSI_WIFCR_CRRIF                  ((uint32_t)0x00002000)              /*!< Clear Regulator Ready Interrupt Flag */
S
S/*******************  Bit definition for DSI_WPCR0 register  ***************/
S#define DSI_WPCR0_UIX4                   ((uint32_t)0x0000003F)              /*!< Unit Interval multiplied by 4 */
S#define DSI_WPCR0_UIX4_0                 ((uint32_t)0x00000001)
S#define DSI_WPCR0_UIX4_1                 ((uint32_t)0x00000002)
S#define DSI_WPCR0_UIX4_2                 ((uint32_t)0x00000004)
S#define DSI_WPCR0_UIX4_3                 ((uint32_t)0x00000008)
S#define DSI_WPCR0_UIX4_4                 ((uint32_t)0x00000010)
S#define DSI_WPCR0_UIX4_5                 ((uint32_t)0x00000020)
S
S#define DSI_WPCR0_SWCL                   ((uint32_t)0x00000040)              /*!< Swap pins on clock lane */
S#define DSI_WPCR0_SWDL0                  ((uint32_t)0x00000080)              /*!< Swap pins on data lane 1 */
S#define DSI_WPCR0_SWDL1                  ((uint32_t)0x00000100)              /*!< Swap pins on data lane 2 */
S#define DSI_WPCR0_HSICL                  ((uint32_t)0x00000200)              /*!< Invert the high-speed data signal on clock lane */
S#define DSI_WPCR0_HSIDL0                 ((uint32_t)0x00000400)              /*!< Invert the high-speed data signal on lane 1 */
S#define DSI_WPCR0_HSIDL1                 ((uint32_t)0x00000800)              /*!< Invert the high-speed data signal on lane 2 */
S#define DSI_WPCR0_FTXSMCL                ((uint32_t)0x00001000)              /*!< Force clock lane in TX stop mode */
S#define DSI_WPCR0_FTXSMDL                ((uint32_t)0x00002000)              /*!< Force data lanes in TX stop mode */
S#define DSI_WPCR0_CDOFFDL                ((uint32_t)0x00004000)              /*!< Contention detection OFF */
S#define DSI_WPCR0_TDDL                   ((uint32_t)0x00010000)              /*!< Turn Disable Data Lanes */
S#define DSI_WPCR0_PDEN                   ((uint32_t)0x00040000)              /*!< Pull-Down Enable */
S#define DSI_WPCR0_TCLKPREPEN             ((uint32_t)0x00080000)              /*!< Timer for t-CLKPREP Enable */
S#define DSI_WPCR0_TCLKZEROEN             ((uint32_t)0x00100000)              /*!< Timer for t-CLKZERO Enable */
S#define DSI_WPCR0_THSPREPEN              ((uint32_t)0x00200000)              /*!< Timer for t-HSPREP Enable */
S#define DSI_WPCR0_THSTRAILEN             ((uint32_t)0x00400000)              /*!< Timer for t-HSTRAIL Enable */
S#define DSI_WPCR0_THSZEROEN              ((uint32_t)0x00800000)              /*!< Timer for t-HSZERO Enable */
S#define DSI_WPCR0_TLPXDEN                ((uint32_t)0x01000000)              /*!< Timer for t-LPXD Enable */
S#define DSI_WPCR0_THSEXITEN              ((uint32_t)0x02000000)              /*!< Timer for t-HSEXIT Enable */
S#define DSI_WPCR0_TLPXCEN                ((uint32_t)0x04000000)              /*!< Timer for t-LPXC Enable */
S#define DSI_WPCR0_TCLKPOSTEN             ((uint32_t)0x08000000)              /*!< Timer for t-CLKPOST Enable */
S
S/*******************  Bit definition for DSI_WPCR1 register  ***************/
S#define DSI_WPCR1_HSTXDCL                ((uint32_t)0x00000003)              /*!< High-Speed Transmission Delay on Clock Lane */
S#define DSI_WPCR1_HSTXDCL0               ((uint32_t)0x00000001)
S#define DSI_WPCR1_HSTXDCL1               ((uint32_t)0x00000002)
S
S#define DSI_WPCR1_HSTXDDL                ((uint32_t)0x0000000C)              /*!< High-Speed Transmission Delay on Data Lane */
S#define DSI_WPCR1_HSTXDDL0               ((uint32_t)0x00000004)
S#define DSI_WPCR1_HSTXDDL1               ((uint32_t)0x00000008)
S
S#define DSI_WPCR1_LPSRCCL                ((uint32_t)0x000000C0)              /*!< Low-Power transmission Slew Rate Compensation on Clock Lane */
S#define DSI_WPCR1_LPSRCCL0               ((uint32_t)0x00000040)
S#define DSI_WPCR1_LPSRCCL1               ((uint32_t)0x00000080)
S
S#define DSI_WPCR1_LPSRCDL                ((uint32_t)0x00000300)              /*!< Low-Power transmission Slew Rate Compensation on Data Lane */
S#define DSI_WPCR1_LPSRCDL0               ((uint32_t)0x00000100)
S#define DSI_WPCR1_LPSRCDL1               ((uint32_t)0x00000200)
S
S#define DSI_WPCR1_SDDC                   ((uint32_t)0x00001000)              /*!< SDD Control */
S
S#define DSI_WPCR1_LPRXVCDL               ((uint32_t)0x0000C000)              /*!< Low-Power Reception V-IL Compensation on Data Lanes */
S#define DSI_WPCR1_LPRXVCDL0              ((uint32_t)0x00004000)
S#define DSI_WPCR1_LPRXVCDL1              ((uint32_t)0x00008000)
S
S#define DSI_WPCR1_HSTXSRCCL              ((uint32_t)0x00030000)              /*!< High-Speed Transmission Delay on Clock Lane */
S#define DSI_WPCR1_HSTXSRCCL0             ((uint32_t)0x00010000)
S#define DSI_WPCR1_HSTXSRCCL1             ((uint32_t)0x00020000)
S
S#define DSI_WPCR1_HSTXSRCDL              ((uint32_t)0x000C0000)              /*!< High-Speed Transmission Delay on Data Lane */
S#define DSI_WPCR1_HSTXSRCDL0             ((uint32_t)0x00040000)
S#define DSI_WPCR1_HSTXSRCDL1             ((uint32_t)0x00080000)
S
S#define DSI_WPCR1_FLPRXLPM               ((uint32_t)0x00400000)              /*!< Forces LP Receiver in Low-Power Mode */
S
S#define DSI_WPCR1_LPRXFT                 ((uint32_t)0x06000000)              /*!< Low-Power RX low-pass Filtering Tuning */
S#define DSI_WPCR1_LPRXFT0                ((uint32_t)0x02000000)
S#define DSI_WPCR1_LPRXFT1                ((uint32_t)0x04000000)
S
S/*******************  Bit definition for DSI_WPCR2 register  ***************/
S#define DSI_WPCR2_TCLKPREP               ((uint32_t)0x000000FF)              /*!< t-CLKPREP */
S#define DSI_WPCR2_TCLKPREP0              ((uint32_t)0x00000001)
S#define DSI_WPCR2_TCLKPREP1              ((uint32_t)0x00000002)
S#define DSI_WPCR2_TCLKPREP2              ((uint32_t)0x00000004)
S#define DSI_WPCR2_TCLKPREP3              ((uint32_t)0x00000008)
S#define DSI_WPCR2_TCLKPREP4              ((uint32_t)0x00000010)
S#define DSI_WPCR2_TCLKPREP5              ((uint32_t)0x00000020)
S#define DSI_WPCR2_TCLKPREP6              ((uint32_t)0x00000040)
S#define DSI_WPCR2_TCLKPREP7              ((uint32_t)0x00000080)
S
S#define DSI_WPCR2_TCLKZERO               ((uint32_t)0x0000FF00)              /*!< t-CLKZERO */
S#define DSI_WPCR2_TCLKZERO0              ((uint32_t)0x00000100)
S#define DSI_WPCR2_TCLKZERO1              ((uint32_t)0x00000200)
S#define DSI_WPCR2_TCLKZERO2              ((uint32_t)0x00000400)
S#define DSI_WPCR2_TCLKZERO3              ((uint32_t)0x00000800)
S#define DSI_WPCR2_TCLKZERO4              ((uint32_t)0x00001000)
S#define DSI_WPCR2_TCLKZERO5              ((uint32_t)0x00002000)
S#define DSI_WPCR2_TCLKZERO6              ((uint32_t)0x00004000)
S#define DSI_WPCR2_TCLKZERO7              ((uint32_t)0x00008000)
S
S#define DSI_WPCR2_THSPREP                ((uint32_t)0x00FF0000)              /*!< t-HSPREP */
S#define DSI_WPCR2_THSPREP0               ((uint32_t)0x00010000)
S#define DSI_WPCR2_THSPREP1               ((uint32_t)0x00020000)
S#define DSI_WPCR2_THSPREP2               ((uint32_t)0x00040000)
S#define DSI_WPCR2_THSPREP3               ((uint32_t)0x00080000)
S#define DSI_WPCR2_THSPREP4               ((uint32_t)0x00100000)
S#define DSI_WPCR2_THSPREP5               ((uint32_t)0x00200000)
S#define DSI_WPCR2_THSPREP6               ((uint32_t)0x00400000)
S#define DSI_WPCR2_THSPREP7               ((uint32_t)0x00800000)
S
S#define DSI_WPCR2_THSTRAIL               ((uint32_t)0xFF000000)              /*!< t-HSTRAIL */
S#define DSI_WPCR2_THSTRAIL0              ((uint32_t)0x01000000)
S#define DSI_WPCR2_THSTRAIL1              ((uint32_t)0x02000000)
S#define DSI_WPCR2_THSTRAIL2              ((uint32_t)0x04000000)
S#define DSI_WPCR2_THSTRAIL3              ((uint32_t)0x08000000)
S#define DSI_WPCR2_THSTRAIL4              ((uint32_t)0x10000000)
S#define DSI_WPCR2_THSTRAIL5              ((uint32_t)0x20000000)
S#define DSI_WPCR2_THSTRAIL6              ((uint32_t)0x40000000)
S#define DSI_WPCR2_THSTRAIL7              ((uint32_t)0x80000000)
S
S/*******************  Bit definition for DSI_WPCR3 register  ***************/
S#define DSI_WPCR3_THSZERO                ((uint32_t)0x000000FF)              /*!< t-HSZERO */
S#define DSI_WPCR3_THSZERO0               ((uint32_t)0x00000001)
S#define DSI_WPCR3_THSZERO1               ((uint32_t)0x00000002)
S#define DSI_WPCR3_THSZERO2               ((uint32_t)0x00000004)
S#define DSI_WPCR3_THSZERO3               ((uint32_t)0x00000008)
S#define DSI_WPCR3_THSZERO4               ((uint32_t)0x00000010)
S#define DSI_WPCR3_THSZERO5               ((uint32_t)0x00000020)
S#define DSI_WPCR3_THSZERO6               ((uint32_t)0x00000040)
S#define DSI_WPCR3_THSZERO7               ((uint32_t)0x00000080)
S
S#define DSI_WPCR3_TLPXD                  ((uint32_t)0x0000FF00)              /*!< t-LPXD */
S#define DSI_WPCR3_TLPXD0                 ((uint32_t)0x00000100)
S#define DSI_WPCR3_TLPXD1                 ((uint32_t)0x00000200)
S#define DSI_WPCR3_TLPXD2                 ((uint32_t)0x00000400)
S#define DSI_WPCR3_TLPXD3                 ((uint32_t)0x00000800)
S#define DSI_WPCR3_TLPXD4                 ((uint32_t)0x00001000)
S#define DSI_WPCR3_TLPXD5                 ((uint32_t)0x00002000)
S#define DSI_WPCR3_TLPXD6                 ((uint32_t)0x00004000)
S#define DSI_WPCR3_TLPXD7                 ((uint32_t)0x00008000)
S
S#define DSI_WPCR3_THSEXIT                ((uint32_t)0x00FF0000)              /*!< t-HSEXIT */
S#define DSI_WPCR3_THSEXIT0               ((uint32_t)0x00010000)
S#define DSI_WPCR3_THSEXIT1               ((uint32_t)0x00020000)
S#define DSI_WPCR3_THSEXIT2               ((uint32_t)0x00040000)
S#define DSI_WPCR3_THSEXIT3               ((uint32_t)0x00080000)
S#define DSI_WPCR3_THSEXIT4               ((uint32_t)0x00100000)
S#define DSI_WPCR3_THSEXIT5               ((uint32_t)0x00200000)
S#define DSI_WPCR3_THSEXIT6               ((uint32_t)0x00400000)
S#define DSI_WPCR3_THSEXIT7               ((uint32_t)0x00800000)
S
S#define DSI_WPCR3_TLPXC                  ((uint32_t)0xFF000000)              /*!< t-LPXC */
S#define DSI_WPCR3_TLPXC0                 ((uint32_t)0x01000000)
S#define DSI_WPCR3_TLPXC1                 ((uint32_t)0x02000000)
S#define DSI_WPCR3_TLPXC2                 ((uint32_t)0x04000000)
S#define DSI_WPCR3_TLPXC3                 ((uint32_t)0x08000000)
S#define DSI_WPCR3_TLPXC4                 ((uint32_t)0x10000000)
S#define DSI_WPCR3_TLPXC5                 ((uint32_t)0x20000000)
S#define DSI_WPCR3_TLPXC6                 ((uint32_t)0x40000000)
S#define DSI_WPCR3_TLPXC7                 ((uint32_t)0x80000000)
S
S/*******************  Bit definition for DSI_WPCR4 register  ***************/
S#define DSI_WPCR4_TCLKPOST               ((uint32_t)0x000000FF)              /*!< t-CLKPOST */
S#define DSI_WPCR4_TCLKPOST0              ((uint32_t)0x00000001)
S#define DSI_WPCR4_TCLKPOST1              ((uint32_t)0x00000002)
S#define DSI_WPCR4_TCLKPOST2              ((uint32_t)0x00000004)
S#define DSI_WPCR4_TCLKPOST3              ((uint32_t)0x00000008)
S#define DSI_WPCR4_TCLKPOST4              ((uint32_t)0x00000010)
S#define DSI_WPCR4_TCLKPOST5              ((uint32_t)0x00000020)
S#define DSI_WPCR4_TCLKPOST6              ((uint32_t)0x00000040)
S#define DSI_WPCR4_TCLKPOST7              ((uint32_t)0x00000080)
S
S/*******************  Bit definition for DSI_WRPCR register  ***************/
S#define DSI_WRPCR_PLLEN                  ((uint32_t)0x00000001)              /*!< PLL Enable */
S#define DSI_WRPCR_PLL_NDIV               ((uint32_t)0x000001FC)              /*!< PLL Loop Division Factor */
S#define DSI_WRPCR_PLL_NDIV0              ((uint32_t)0x00000004)
S#define DSI_WRPCR_PLL_NDIV1              ((uint32_t)0x00000008)
S#define DSI_WRPCR_PLL_NDIV2              ((uint32_t)0x00000010)
S#define DSI_WRPCR_PLL_NDIV3              ((uint32_t)0x00000020)
S#define DSI_WRPCR_PLL_NDIV4              ((uint32_t)0x00000040)
S#define DSI_WRPCR_PLL_NDIV5              ((uint32_t)0x00000080)
S#define DSI_WRPCR_PLL_NDIV6              ((uint32_t)0x00000100)
S
S#define DSI_WRPCR_PLL_IDF                ((uint32_t)0x00007800)              /*!< PLL Input Division Factor */
S#define DSI_WRPCR_PLL_IDF0               ((uint32_t)0x00000800)
S#define DSI_WRPCR_PLL_IDF1               ((uint32_t)0x00001000)
S#define DSI_WRPCR_PLL_IDF2               ((uint32_t)0x00002000)
S#define DSI_WRPCR_PLL_IDF3               ((uint32_t)0x00004000)
S
S#define DSI_WRPCR_PLL_ODF                ((uint32_t)0x00030000)              /*!< PLL Output Division Factor */
S#define DSI_WRPCR_PLL_ODF0               ((uint32_t)0x00010000)
S#define DSI_WRPCR_PLL_ODF1               ((uint32_t)0x00020000)
S
S#define DSI_WRPCR_REGEN                  ((uint32_t)0x01000000)              /*!< Regulator Enable */
S#endif /* STM32F469_479xx */
S
S/******************************************************************************/
S/*                                                                            */
S/*                             Power Control                                  */
S/*                                                                            */
S/******************************************************************************/
S/********************  Bit definition for PWR_CR register  ********************/
S#define  PWR_CR_LPDS                         ((uint32_t)0x00000001)     /*!< Low-Power Deepsleep                 */
S#define  PWR_CR_PDDS                         ((uint32_t)0x00000002)     /*!< Power Down Deepsleep                */
S#define  PWR_CR_CWUF                         ((uint32_t)0x00000004)     /*!< Clear Wakeup Flag                   */
S#define  PWR_CR_CSBF                         ((uint32_t)0x00000008)     /*!< Clear Standby Flag                  */
S#define  PWR_CR_PVDE                         ((uint32_t)0x00000010)     /*!< Power Voltage Detector Enable       */
S
S#define  PWR_CR_PLS                          ((uint32_t)0x000000E0)     /*!< PLS[2:0] bits (PVD Level Selection) */
S#define  PWR_CR_PLS_0                        ((uint32_t)0x00000020)     /*!< Bit 0 */
S#define  PWR_CR_PLS_1                        ((uint32_t)0x00000040)     /*!< Bit 1 */
S#define  PWR_CR_PLS_2                        ((uint32_t)0x00000080)     /*!< Bit 2 */
S
S/*!< PVD level configuration */
S#define  PWR_CR_PLS_LEV0                     ((uint32_t)0x00000000)     /*!< PVD level 0 */
S#define  PWR_CR_PLS_LEV1                     ((uint32_t)0x00000020)     /*!< PVD level 1 */
S#define  PWR_CR_PLS_LEV2                     ((uint32_t)0x00000040)     /*!< PVD level 2 */
S#define  PWR_CR_PLS_LEV3                     ((uint32_t)0x00000060)     /*!< PVD level 3 */
S#define  PWR_CR_PLS_LEV4                     ((uint32_t)0x00000080)     /*!< PVD level 4 */
S#define  PWR_CR_PLS_LEV5                     ((uint32_t)0x000000A0)     /*!< PVD level 5 */
S#define  PWR_CR_PLS_LEV6                     ((uint32_t)0x000000C0)     /*!< PVD level 6 */
S#define  PWR_CR_PLS_LEV7                     ((uint32_t)0x000000E0)     /*!< PVD level 7 */
S
S#define  PWR_CR_DBP                          ((uint32_t)0x00000100)     /*!< Disable Backup Domain write protection                     */
S#define  PWR_CR_FPDS                         ((uint32_t)0x00000200)     /*!< Flash power down in Stop mode                              */
S#define  PWR_CR_LPUDS                        ((uint32_t)0x00000400)     /*!< Low-Power Regulator in Stop under-drive mode               */
S#define  PWR_CR_MRUDS                        ((uint32_t)0x00000800)     /*!< Main regulator in Stop under-drive mode                    */
S
S#define  PWR_CR_LPLVDS                       ((uint32_t)0x00000400)     /*!< Low-power regulator Low Voltage in Deep Sleep mode         */
S#define  PWR_CR_MRLVDS                       ((uint32_t)0x00000800)     /*!< Main regulator Low Voltage in Deep Sleep mode              */
S
S#define  PWR_CR_ADCDC1                       ((uint32_t)0x00002000)     /*!< Refer to AN4073 on how to use this bit */ 
S
S#define  PWR_CR_VOS                          ((uint32_t)0x0000C000)     /*!< VOS[1:0] bits (Regulator voltage scaling output selection) */
S#define  PWR_CR_VOS_0                        ((uint32_t)0x00004000)     /*!< Bit 0 */
S#define  PWR_CR_VOS_1                        ((uint32_t)0x00008000)     /*!< Bit 1 */
S
S#define  PWR_CR_ODEN                         ((uint32_t)0x00010000)     /*!< Over Drive enable                   */
S#define  PWR_CR_ODSWEN                       ((uint32_t)0x00020000)     /*!< Over Drive switch enabled           */
S#define  PWR_CR_UDEN                         ((uint32_t)0x000C0000)     /*!< Under Drive enable in stop mode     */
S#define  PWR_CR_UDEN_0                       ((uint32_t)0x00040000)     /*!< Bit 0                               */
S#define  PWR_CR_UDEN_1                       ((uint32_t)0x00080000)     /*!< Bit 1                               */
S
S#define  PWR_CR_FMSSR                        ((uint32_t)0x00100000)     /*!< Flash Memory Sleep System Run        */
S#define  PWR_CR_FISSR                        ((uint32_t)0x00200000)     /*!< Flash Interface Stop while System Run */
S
S/* Legacy define */
S#define  PWR_CR_PMODE                        PWR_CR_VOS
S
S/*******************  Bit definition for PWR_CSR register  ********************/
S#define  PWR_CSR_WUF                         ((uint32_t)0x00000001)     /*!< Wakeup Flag                                      */
S#define  PWR_CSR_SBF                         ((uint32_t)0x00000002)     /*!< Standby Flag                                     */
S#define  PWR_CSR_PVDO                        ((uint32_t)0x00000004)     /*!< PVD Output                                       */
S#define  PWR_CSR_BRR                         ((uint32_t)0x00000008)     /*!< Backup regulator ready                           */
S#define  PWR_CSR_WUPP                        ((uint32_t)0x00000080)     /*!< WKUP pin Polarity                                */
S#define  PWR_CSR_EWUP                        ((uint32_t)0x00000100)     /*!< Enable WKUP pin                                  */
S#define  PWR_CSR_BRE                         ((uint32_t)0x00000200)     /*!< Backup regulator enable                          */
S#define  PWR_CSR_VOSRDY                      ((uint32_t)0x00004000)     /*!< Regulator voltage scaling output selection ready */
S#define  PWR_CSR_ODRDY                       ((uint32_t)0x00010000)     /*!< Over Drive generator ready                       */
S#define  PWR_CSR_ODSWRDY                     ((uint32_t)0x00020000)     /*!< Over Drive Switch ready                          */
S#define  PWR_CSR_UDSWRDY                     ((uint32_t)0x000C0000)     /*!< Under Drive ready                                */
S
S/* Legacy define */
S#define  PWR_CSR_REGRDY                      PWR_CSR_VOSRDY
S
S#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
S/******************************************************************************/
S/*                                                                            */
S/*                                    QUADSPI                                 */
S/*                                                                            */
S/******************************************************************************/
S/*****************  Bit definition for QUADSPI_CR register  *******************/
S#define  QUADSPI_CR_EN                           ((uint32_t)0x00000001)            /*!< Enable                             */
S#define  QUADSPI_CR_ABORT                        ((uint32_t)0x00000002)            /*!< Abort request                      */
S#define  QUADSPI_CR_DMAEN                        ((uint32_t)0x00000004)            /*!< DMA Enable                         */
S#define  QUADSPI_CR_TCEN                         ((uint32_t)0x00000008)            /*!< Timeout Counter Enable             */
S#define  QUADSPI_CR_SSHIFT                       ((uint32_t)0x00000010)            /*!< SSHIFT Sample Shift                */
S#define  QUADSPI_CR_DFM                          ((uint32_t)0x00000040)            /*!< Dual Flash Mode                    */
S#define  QUADSPI_CR_FSEL                         ((uint32_t)0x00000080)            /*!< Flash Select                       */
S#define  QUADSPI_CR_FTHRES                       ((uint32_t)0x00001F00)            /*!< FTHRES[3:0] FIFO Level             */
S#define  QUADSPI_CR_FTHRES_0                     ((uint32_t)0x00000100)            /*!< Bit 0 */
S#define  QUADSPI_CR_FTHRES_1                     ((uint32_t)0x00000200)            /*!< Bit 1 */
S#define  QUADSPI_CR_FTHRES_2                     ((uint32_t)0x00000400)            /*!< Bit 2 */
S#define  QUADSPI_CR_FTHRES_3                     ((uint32_t)0x00000800)            /*!< Bit 3 */
S#define  QUADSPI_CR_FTHRES_4                     ((uint32_t)0x00001000)            /*!< Bit 4 */
S#define  QUADSPI_CR_TEIE                         ((uint32_t)0x00010000)            /*!< Transfer Error Interrupt Enable    */
S#define  QUADSPI_CR_TCIE                         ((uint32_t)0x00020000)            /*!< Transfer Complete Interrupt Enable */
S#define  QUADSPI_CR_FTIE                         ((uint32_t)0x00040000)            /*!< FIFO Threshold Interrupt Enable    */
S#define  QUADSPI_CR_SMIE                         ((uint32_t)0x00080000)            /*!< Status Match Interrupt Enable      */
S#define  QUADSPI_CR_TOIE                         ((uint32_t)0x00100000)            /*!< TimeOut Interrupt Enable           */
S#define  QUADSPI_CR_APMS                         ((uint32_t)0x00400000)            /*!< Bit 1                              */
S#define  QUADSPI_CR_PMM                          ((uint32_t)0x00800000)            /*!< Polling Match Mode                 */
S#define  QUADSPI_CR_PRESCALER                    ((uint32_t)0xFF000000)            /*!< PRESCALER[7:0] Clock prescaler     */
S#define  QUADSPI_CR_PRESCALER_0                  ((uint32_t)0x01000000)            /*!< Bit 0 */
S#define  QUADSPI_CR_PRESCALER_1                  ((uint32_t)0x02000000)            /*!< Bit 1 */
S#define  QUADSPI_CR_PRESCALER_2                  ((uint32_t)0x04000000)            /*!< Bit 2 */
S#define  QUADSPI_CR_PRESCALER_3                  ((uint32_t)0x08000000)            /*!< Bit 3 */
S#define  QUADSPI_CR_PRESCALER_4                  ((uint32_t)0x10000000)            /*!< Bit 4 */
S#define  QUADSPI_CR_PRESCALER_5                  ((uint32_t)0x20000000)            /*!< Bit 5 */
S#define  QUADSPI_CR_PRESCALER_6                  ((uint32_t)0x40000000)            /*!< Bit 6 */
S#define  QUADSPI_CR_PRESCALER_7                  ((uint32_t)0x80000000)            /*!< Bit 7 */
S
S/*****************  Bit definition for QUADSPI_DCR register  ******************/
S#define  QUADSPI_DCR_CKMODE                      ((uint32_t)0x00000001)            /*!< Mode 0 / Mode 3                 */
S#define  QUADSPI_DCR_CSHT                        ((uint32_t)0x00000700)            /*!< CSHT[2:0]: ChipSelect High Time */
S#define  QUADSPI_DCR_CSHT_0                      ((uint32_t)0x00000100)            /*!< Bit 0 */
S#define  QUADSPI_DCR_CSHT_1                      ((uint32_t)0x00000200)            /*!< Bit 1 */
S#define  QUADSPI_DCR_CSHT_2                      ((uint32_t)0x00000400)            /*!< Bit 2 */
S#define  QUADSPI_DCR_FSIZE                       ((uint32_t)0x001F0000)            /*!< FSIZE[4:0]: Flash Size          */
S#define  QUADSPI_DCR_FSIZE_0                     ((uint32_t)0x00010000)            /*!< Bit 0 */
S#define  QUADSPI_DCR_FSIZE_1                     ((uint32_t)0x00020000)            /*!< Bit 1 */
S#define  QUADSPI_DCR_FSIZE_2                     ((uint32_t)0x00040000)            /*!< Bit 2 */
S#define  QUADSPI_DCR_FSIZE_3                     ((uint32_t)0x00080000)            /*!< Bit 3 */
S#define  QUADSPI_DCR_FSIZE_4                     ((uint32_t)0x00100000)            /*!< Bit 4 */
S
S/******************  Bit definition for QUADSPI_SR register  *******************/
S#define  QUADSPI_SR_TEF                          ((uint32_t)0x00000001)             /*!< Transfer Error Flag     */
S#define  QUADSPI_SR_TCF                          ((uint32_t)0x00000002)             /*!< Transfer Complete Flag  */
S#define  QUADSPI_SR_FTF                          ((uint32_t)0x00000004)             /*!< FIFO Threshlod Flag     */
S#define  QUADSPI_SR_SMF                          ((uint32_t)0x00000008)             /*!< Status Match Flag       */
S#define  QUADSPI_SR_TOF                          ((uint32_t)0x00000010)             /*!< Timeout Flag            */
S#define  QUADSPI_SR_BUSY                         ((uint32_t)0x00000020)             /*!< Busy                    */
S#define  QUADSPI_SR_FLEVEL                       ((uint32_t)0x00003F00)             /*!< FIFO Level              */
S#define  QUADSPI_SR_FLEVEL_0                     ((uint32_t)0x00000100)             /*!< Bit 0 */
S#define  QUADSPI_SR_FLEVEL_1                     ((uint32_t)0x00000200)             /*!< Bit 1 */
S#define  QUADSPI_SR_FLEVEL_2                     ((uint32_t)0x00000400)             /*!< Bit 2 */
S#define  QUADSPI_SR_FLEVEL_3                     ((uint32_t)0x00000800)             /*!< Bit 3 */
S#define  QUADSPI_SR_FLEVEL_4                     ((uint32_t)0x00001000)             /*!< Bit 4 */
S#define  QUADSPI_SR_FLEVEL_5                     ((uint32_t)0x00002000)             /*!< Bit 5 */
S
S/******************  Bit definition for QUADSPI_FCR register  ******************/
S#define  QUADSPI_FCR_CTEF                        ((uint32_t)0x00000001)             /*!< Clear Transfer Error Flag    */
S#define  QUADSPI_FCR_CTCF                        ((uint32_t)0x00000002)             /*!< Clear Transfer Complete Flag */
S#define  QUADSPI_FCR_CSMF                        ((uint32_t)0x00000008)             /*!< Clear Status Match Flag      */
S#define  QUADSPI_FCR_CTOF                        ((uint32_t)0x00000010)             /*!< Clear Timeout Flag           */
S
S/******************  Bit definition for QUADSPI_DLR register  ******************/
S#define  QUADSPI_DLR_DL                        ((uint32_t)0xFFFFFFFF)               /*!< DL[31:0]: Data Length */
S
S/******************  Bit definition for QUADSPI_CCR register  ******************/
S#define  QUADSPI_CCR_INSTRUCTION                  ((uint32_t)0x000000FF)            /*!< INSTRUCTION[7:0]: Instruction */
S#define  QUADSPI_CCR_INSTRUCTION_0                ((uint32_t)0x00000001)            /*!< Bit 0 */
S#define  QUADSPI_CCR_INSTRUCTION_1                ((uint32_t)0x00000002)            /*!< Bit 1 */
S#define  QUADSPI_CCR_INSTRUCTION_2                ((uint32_t)0x00000004)            /*!< Bit 2 */
S#define  QUADSPI_CCR_INSTRUCTION_3                ((uint32_t)0x00000008)            /*!< Bit 3 */
S#define  QUADSPI_CCR_INSTRUCTION_4                ((uint32_t)0x00000010)            /*!< Bit 4 */
S#define  QUADSPI_CCR_INSTRUCTION_5                ((uint32_t)0x00000020)            /*!< Bit 5 */
S#define  QUADSPI_CCR_INSTRUCTION_6                ((uint32_t)0x00000040)            /*!< Bit 6 */
S#define  QUADSPI_CCR_INSTRUCTION_7                ((uint32_t)0x00000080)            /*!< Bit 7 */
S#define  QUADSPI_CCR_IMODE                        ((uint32_t)0x00000300)            /*!< IMODE[1:0]: Instruction Mode */
S#define  QUADSPI_CCR_IMODE_0                      ((uint32_t)0x00000100)            /*!< Bit 0 */
S#define  QUADSPI_CCR_IMODE_1                      ((uint32_t)0x00000200)            /*!< Bit 1 */
S#define  QUADSPI_CCR_ADMODE                       ((uint32_t)0x00000C00)            /*!< ADMODE[1:0]: Address Mode */
S#define  QUADSPI_CCR_ADMODE_0                     ((uint32_t)0x00000400)            /*!< Bit 0 */
S#define  QUADSPI_CCR_ADMODE_1                     ((uint32_t)0x00000800)            /*!< Bit 1 */
S#define  QUADSPI_CCR_ADSIZE                       ((uint32_t)0x00003000)            /*!< ADSIZE[1:0]: Address Size */
S#define  QUADSPI_CCR_ADSIZE_0                     ((uint32_t)0x00001000)            /*!< Bit 0 */
S#define  QUADSPI_CCR_ADSIZE_1                     ((uint32_t)0x00002000)            /*!< Bit 1 */
S#define  QUADSPI_CCR_ABMODE                       ((uint32_t)0x0000C000)            /*!< ABMODE[1:0]: Alternate Bytes Mode */
S#define  QUADSPI_CCR_ABMODE_0                     ((uint32_t)0x00004000)            /*!< Bit 0 */
S#define  QUADSPI_CCR_ABMODE_1                     ((uint32_t)0x00008000)            /*!< Bit 1 */
S#define  QUADSPI_CCR_ABSIZE                       ((uint32_t)0x00030000)            /*!< ABSIZE[1:0]: Instruction Mode */
S#define  QUADSPI_CCR_ABSIZE_0                     ((uint32_t)0x00010000)            /*!< Bit 0 */
S#define  QUADSPI_CCR_ABSIZE_1                     ((uint32_t)0x00020000)            /*!< Bit 1 */
S#define  QUADSPI_CCR_DCYC                         ((uint32_t)0x007C0000)            /*!< DCYC[4:0]: Dummy Cycles */
S#define  QUADSPI_CCR_DCYC_0                       ((uint32_t)0x00040000)            /*!< Bit 0 */
S#define  QUADSPI_CCR_DCYC_1                       ((uint32_t)0x00080000)            /*!< Bit 1 */
S#define  QUADSPI_CCR_DCYC_2                       ((uint32_t)0x00100000)            /*!< Bit 2 */
S#define  QUADSPI_CCR_DCYC_3                       ((uint32_t)0x00200000)            /*!< Bit 3 */
S#define  QUADSPI_CCR_DCYC_4                       ((uint32_t)0x00400000)            /*!< Bit 4 */
S#define  QUADSPI_CCR_DMODE                        ((uint32_t)0x03000000)            /*!< DMODE[1:0]: Data Mode */
S#define  QUADSPI_CCR_DMODE_0                      ((uint32_t)0x01000000)            /*!< Bit 0 */
S#define  QUADSPI_CCR_DMODE_1                      ((uint32_t)0x02000000)            /*!< Bit 1 */
S#define  QUADSPI_CCR_FMODE                        ((uint32_t)0x0C000000)            /*!< FMODE[1:0]: Functional Mode */
S#define  QUADSPI_CCR_FMODE_0                      ((uint32_t)0x04000000)            /*!< Bit 0 */
S#define  QUADSPI_CCR_FMODE_1                      ((uint32_t)0x08000000)            /*!< Bit 1 */
S#define  QUADSPI_CCR_SIOO                         ((uint32_t)0x10000000)            /*!< SIOO: Send Instruction Only Once Mode */
S#define  QUADSPI_CCR_DHHC                         ((uint32_t)0x40000000)            /*!< DHHC: Delay Half Hclk Cycle */
S#define  QUADSPI_CCR_DDRM                         ((uint32_t)0x80000000)            /*!< DDRM: Double Data Rate Mode */ 
S/******************  Bit definition for QUADSPI_AR register  *******************/
S#define  QUADSPI_AR_ADDRESS                       ((uint32_t)0xFFFFFFFF)            /*!< ADDRESS[31:0]: Address */
S
S/******************  Bit definition for QUADSPI_ABR register  ******************/
S#define  QUADSPI_ABR_ALTERNATE                    ((uint32_t)0xFFFFFFFF)            /*!< ALTERNATE[31:0]: Alternate Bytes */
S
S/******************  Bit definition for QUADSPI_DR register  *******************/
S#define  QUADSPI_DR_DATA                          ((uint32_t)0xFFFFFFFF)            /*!< DATA[31:0]: Data */
S
S/******************  Bit definition for QUADSPI_PSMKR register  ****************/
S#define  QUADSPI_PSMKR_MASK                       ((uint32_t)0xFFFFFFFF)            /*!< MASK[31:0]: Status Mask */
S
S/******************  Bit definition for QUADSPI_PSMAR register  ****************/
S#define  QUADSPI_PSMAR_MATCH                      ((uint32_t)0xFFFFFFFF)            /*!< MATCH[31:0]: Status Match */
S
S/******************  Bit definition for QUADSPI_PIR register  *****************/
S#define  QUADSPI_PIR_INTERVAL                     ((uint32_t)0x0000FFFF)            /*!< INTERVAL[15:0]: Polling Interval */
S
S/******************  Bit definition for QUADSPI_LPTR register  *****************/
S#define  QUADSPI_LPTR_TIMEOUT                     ((uint32_t)0x0000FFFF)            /*!< TIMEOUT[15:0]: Timeout period */
S#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx || STM32F469_479xx */
S
S/******************************************************************************/
S/*                                                                            */
S/*                         Reset and Clock Control                            */
S/*                                                                            */
S/******************************************************************************/
S/********************  Bit definition for RCC_CR register  ********************/
S#define  RCC_CR_HSION                        ((uint32_t)0x00000001)
S#define  RCC_CR_HSIRDY                       ((uint32_t)0x00000002)
S
S#define  RCC_CR_HSITRIM                      ((uint32_t)0x000000F8)
S#define  RCC_CR_HSITRIM_0                    ((uint32_t)0x00000008)/*!<Bit 0 */
S#define  RCC_CR_HSITRIM_1                    ((uint32_t)0x00000010)/*!<Bit 1 */
S#define  RCC_CR_HSITRIM_2                    ((uint32_t)0x00000020)/*!<Bit 2 */
S#define  RCC_CR_HSITRIM_3                    ((uint32_t)0x00000040)/*!<Bit 3 */
S#define  RCC_CR_HSITRIM_4                    ((uint32_t)0x00000080)/*!<Bit 4 */
S
S#define  RCC_CR_HSICAL                       ((uint32_t)0x0000FF00)
S#define  RCC_CR_HSICAL_0                     ((uint32_t)0x00000100)/*!<Bit 0 */
S#define  RCC_CR_HSICAL_1                     ((uint32_t)0x00000200)/*!<Bit 1 */
S#define  RCC_CR_HSICAL_2                     ((uint32_t)0x00000400)/*!<Bit 2 */
S#define  RCC_CR_HSICAL_3                     ((uint32_t)0x00000800)/*!<Bit 3 */
S#define  RCC_CR_HSICAL_4                     ((uint32_t)0x00001000)/*!<Bit 4 */
S#define  RCC_CR_HSICAL_5                     ((uint32_t)0x00002000)/*!<Bit 5 */
S#define  RCC_CR_HSICAL_6                     ((uint32_t)0x00004000)/*!<Bit 6 */
S#define  RCC_CR_HSICAL_7                     ((uint32_t)0x00008000)/*!<Bit 7 */
S
S#define  RCC_CR_HSEON                        ((uint32_t)0x00010000)
S#define  RCC_CR_HSERDY                       ((uint32_t)0x00020000)
S#define  RCC_CR_HSEBYP                       ((uint32_t)0x00040000)
S#define  RCC_CR_CSSON                        ((uint32_t)0x00080000)
S#define  RCC_CR_PLLON                        ((uint32_t)0x01000000)
S#define  RCC_CR_PLLRDY                       ((uint32_t)0x02000000)
S#define  RCC_CR_PLLI2SON                     ((uint32_t)0x04000000)
S#define  RCC_CR_PLLI2SRDY                    ((uint32_t)0x08000000)
S#define  RCC_CR_PLLSAION                     ((uint32_t)0x10000000)
S#define  RCC_CR_PLLSAIRDY                    ((uint32_t)0x20000000)
S
S/********************  Bit definition for RCC_PLLCFGR register  ***************/
S#define  RCC_PLLCFGR_PLLM                    ((uint32_t)0x0000003F)
S#define  RCC_PLLCFGR_PLLM_0                  ((uint32_t)0x00000001)
S#define  RCC_PLLCFGR_PLLM_1                  ((uint32_t)0x00000002)
S#define  RCC_PLLCFGR_PLLM_2                  ((uint32_t)0x00000004)
S#define  RCC_PLLCFGR_PLLM_3                  ((uint32_t)0x00000008)
S#define  RCC_PLLCFGR_PLLM_4                  ((uint32_t)0x00000010)
S#define  RCC_PLLCFGR_PLLM_5                  ((uint32_t)0x00000020)
S
S#define  RCC_PLLCFGR_PLLN                     ((uint32_t)0x00007FC0)
S#define  RCC_PLLCFGR_PLLN_0                   ((uint32_t)0x00000040)
S#define  RCC_PLLCFGR_PLLN_1                   ((uint32_t)0x00000080)
S#define  RCC_PLLCFGR_PLLN_2                   ((uint32_t)0x00000100)
S#define  RCC_PLLCFGR_PLLN_3                   ((uint32_t)0x00000200)
S#define  RCC_PLLCFGR_PLLN_4                   ((uint32_t)0x00000400)
S#define  RCC_PLLCFGR_PLLN_5                   ((uint32_t)0x00000800)
S#define  RCC_PLLCFGR_PLLN_6                   ((uint32_t)0x00001000)
S#define  RCC_PLLCFGR_PLLN_7                   ((uint32_t)0x00002000)
S#define  RCC_PLLCFGR_PLLN_8                   ((uint32_t)0x00004000)
S
S#define  RCC_PLLCFGR_PLLP                    ((uint32_t)0x00030000)
S#define  RCC_PLLCFGR_PLLP_0                  ((uint32_t)0x00010000)
S#define  RCC_PLLCFGR_PLLP_1                  ((uint32_t)0x00020000)
S
S#define  RCC_PLLCFGR_PLLSRC                  ((uint32_t)0x00400000)
S#define  RCC_PLLCFGR_PLLSRC_HSE              ((uint32_t)0x00400000)
S#define  RCC_PLLCFGR_PLLSRC_HSI              ((uint32_t)0x00000000)
S
S#define  RCC_PLLCFGR_PLLQ                    ((uint32_t)0x0F000000)
S#define  RCC_PLLCFGR_PLLQ_0                  ((uint32_t)0x01000000)
S#define  RCC_PLLCFGR_PLLQ_1                  ((uint32_t)0x02000000)
S#define  RCC_PLLCFGR_PLLQ_2                  ((uint32_t)0x04000000)
S#define  RCC_PLLCFGR_PLLQ_3                  ((uint32_t)0x08000000)
S
S#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
S#define  RCC_PLLCFGR_PLLR                    ((uint32_t)0x70000000)
S#define  RCC_PLLCFGR_PLLR_0                  ((uint32_t)0x10000000)
S#define  RCC_PLLCFGR_PLLR_1                  ((uint32_t)0x20000000)
S#define  RCC_PLLCFGR_PLLR_2                  ((uint32_t)0x40000000)
S#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx || STM32F469_479xx */
S
S/********************  Bit definition for RCC_CFGR register  ******************/
S/*!< SW configuration */
S#define  RCC_CFGR_SW                         ((uint32_t)0x00000003)        /*!< SW[1:0] bits (System clock Switch) */
S#define  RCC_CFGR_SW_0                       ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  RCC_CFGR_SW_1                       ((uint32_t)0x00000002)        /*!< Bit 1 */
S
S#define  RCC_CFGR_SW_HSI                     ((uint32_t)0x00000000)        /*!< HSI selected as system clock */
S#define  RCC_CFGR_SW_HSE                     ((uint32_t)0x00000001)        /*!< HSE selected as system clock */
S#define  RCC_CFGR_SW_PLL                     ((uint32_t)0x00000002)        /*!< PLL/PLLP selected as system clock */
S#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
S#define  RCC_CFGR_SW_PLLR                    ((uint32_t)0x00000003)        /*!< PLL/PLLR selected as system clock */
S#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx || STM32F469_479xx */
S
S/*!< SWS configuration */
S#define  RCC_CFGR_SWS                        ((uint32_t)0x0000000C)        /*!< SWS[1:0] bits (System Clock Switch Status) */
S#define  RCC_CFGR_SWS_0                      ((uint32_t)0x00000004)        /*!< Bit 0 */
S#define  RCC_CFGR_SWS_1                      ((uint32_t)0x00000008)        /*!< Bit 1 */
S
S#define  RCC_CFGR_SWS_HSI                    ((uint32_t)0x00000000)        /*!< HSI oscillator used as system clock */
S#define  RCC_CFGR_SWS_HSE                    ((uint32_t)0x00000004)        /*!< HSE oscillator used as system clock */
S#define  RCC_CFGR_SWS_PLL                    ((uint32_t)0x00000008)        /*!< PLL/PLLP used as system clock       */
S#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F469_479xx) || defined(STM32F446xx)
S#define  RCC_CFGR_SWS_PLLR                   ((uint32_t)0x0000000C)        /*!< PLL/PLLR used as system clock       */
S#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx || STM32F469_479xx */
S
S/*!< HPRE configuration */
S#define  RCC_CFGR_HPRE                       ((uint32_t)0x000000F0)        /*!< HPRE[3:0] bits (AHB prescaler) */
S#define  RCC_CFGR_HPRE_0                     ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  RCC_CFGR_HPRE_1                     ((uint32_t)0x00000020)        /*!< Bit 1 */
S#define  RCC_CFGR_HPRE_2                     ((uint32_t)0x00000040)        /*!< Bit 2 */
S#define  RCC_CFGR_HPRE_3                     ((uint32_t)0x00000080)        /*!< Bit 3 */
S
S#define  RCC_CFGR_HPRE_DIV1                  ((uint32_t)0x00000000)        /*!< SYSCLK not divided */
S#define  RCC_CFGR_HPRE_DIV2                  ((uint32_t)0x00000080)        /*!< SYSCLK divided by 2 */
S#define  RCC_CFGR_HPRE_DIV4                  ((uint32_t)0x00000090)        /*!< SYSCLK divided by 4 */
S#define  RCC_CFGR_HPRE_DIV8                  ((uint32_t)0x000000A0)        /*!< SYSCLK divided by 8 */
S#define  RCC_CFGR_HPRE_DIV16                 ((uint32_t)0x000000B0)        /*!< SYSCLK divided by 16 */
S#define  RCC_CFGR_HPRE_DIV64                 ((uint32_t)0x000000C0)        /*!< SYSCLK divided by 64 */
S#define  RCC_CFGR_HPRE_DIV128                ((uint32_t)0x000000D0)        /*!< SYSCLK divided by 128 */
S#define  RCC_CFGR_HPRE_DIV256                ((uint32_t)0x000000E0)        /*!< SYSCLK divided by 256 */
S#define  RCC_CFGR_HPRE_DIV512                ((uint32_t)0x000000F0)        /*!< SYSCLK divided by 512 */
S
S#if defined(STM32F410xx)
S/*!< MCO1EN configuration */
S#define  RCC_CFGR_MCO1EN                     ((uint32_t)0x00000100)        /*!< MCO1EN bit */
S/*!< MCO1EN configuration */
S#define  RCC_CFGR_MCO2EN                     ((uint32_t)0x00000200)        /*!< MCO2EN bit */
S#endif /* STM32F410xx */
S/*!< PPRE1 configuration */
S#define  RCC_CFGR_PPRE1                      ((uint32_t)0x00001C00)        /*!< PRE1[2:0] bits (APB1 prescaler) */
S#define  RCC_CFGR_PPRE1_0                    ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  RCC_CFGR_PPRE1_1                    ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  RCC_CFGR_PPRE1_2                    ((uint32_t)0x00001000)        /*!< Bit 2 */
S
S#define  RCC_CFGR_PPRE1_DIV1                 ((uint32_t)0x00000000)        /*!< HCLK not divided */
S#define  RCC_CFGR_PPRE1_DIV2                 ((uint32_t)0x00001000)        /*!< HCLK divided by 2 */
S#define  RCC_CFGR_PPRE1_DIV4                 ((uint32_t)0x00001400)        /*!< HCLK divided by 4 */
S#define  RCC_CFGR_PPRE1_DIV8                 ((uint32_t)0x00001800)        /*!< HCLK divided by 8 */
S#define  RCC_CFGR_PPRE1_DIV16                ((uint32_t)0x00001C00)        /*!< HCLK divided by 16 */
S
S/*!< PPRE2 configuration */
S#define  RCC_CFGR_PPRE2                      ((uint32_t)0x0000E000)        /*!< PRE2[2:0] bits (APB2 prescaler) */
S#define  RCC_CFGR_PPRE2_0                    ((uint32_t)0x00002000)        /*!< Bit 0 */
S#define  RCC_CFGR_PPRE2_1                    ((uint32_t)0x00004000)        /*!< Bit 1 */
S#define  RCC_CFGR_PPRE2_2                    ((uint32_t)0x00008000)        /*!< Bit 2 */
S
S#define  RCC_CFGR_PPRE2_DIV1                 ((uint32_t)0x00000000)        /*!< HCLK not divided */
S#define  RCC_CFGR_PPRE2_DIV2                 ((uint32_t)0x00008000)        /*!< HCLK divided by 2 */
S#define  RCC_CFGR_PPRE2_DIV4                 ((uint32_t)0x0000A000)        /*!< HCLK divided by 4 */
S#define  RCC_CFGR_PPRE2_DIV8                 ((uint32_t)0x0000C000)        /*!< HCLK divided by 8 */
S#define  RCC_CFGR_PPRE2_DIV16                ((uint32_t)0x0000E000)        /*!< HCLK divided by 16 */
S
S/*!< RTCPRE configuration */
S#define  RCC_CFGR_RTCPRE                     ((uint32_t)0x001F0000)
S#define  RCC_CFGR_RTCPRE_0                   ((uint32_t)0x00010000)
S#define  RCC_CFGR_RTCPRE_1                   ((uint32_t)0x00020000)
S#define  RCC_CFGR_RTCPRE_2                   ((uint32_t)0x00040000)
S#define  RCC_CFGR_RTCPRE_3                   ((uint32_t)0x00080000)
S#define  RCC_CFGR_RTCPRE_4                   ((uint32_t)0x00100000)
S
S/*!< MCO1 configuration */
S#define  RCC_CFGR_MCO1                       ((uint32_t)0x00600000)
S#define  RCC_CFGR_MCO1_0                     ((uint32_t)0x00200000)
S#define  RCC_CFGR_MCO1_1                     ((uint32_t)0x00400000)
S
S#define  RCC_CFGR_I2SSRC                     ((uint32_t)0x00800000)
S
S#define  RCC_CFGR_MCO1PRE                    ((uint32_t)0x07000000)
S#define  RCC_CFGR_MCO1PRE_0                  ((uint32_t)0x01000000)
S#define  RCC_CFGR_MCO1PRE_1                  ((uint32_t)0x02000000)
S#define  RCC_CFGR_MCO1PRE_2                  ((uint32_t)0x04000000)
S
S#define  RCC_CFGR_MCO2PRE                    ((uint32_t)0x38000000)
S#define  RCC_CFGR_MCO2PRE_0                  ((uint32_t)0x08000000)
S#define  RCC_CFGR_MCO2PRE_1                  ((uint32_t)0x10000000)
S#define  RCC_CFGR_MCO2PRE_2                  ((uint32_t)0x20000000)
S
S#define  RCC_CFGR_MCO2                       ((uint32_t)0xC0000000)
S#define  RCC_CFGR_MCO2_0                     ((uint32_t)0x40000000)
S#define  RCC_CFGR_MCO2_1                     ((uint32_t)0x80000000)
S
S/********************  Bit definition for RCC_CIR register  *******************/
S#define  RCC_CIR_LSIRDYF                     ((uint32_t)0x00000001)
S#define  RCC_CIR_LSERDYF                     ((uint32_t)0x00000002)
S#define  RCC_CIR_HSIRDYF                     ((uint32_t)0x00000004)
S#define  RCC_CIR_HSERDYF                     ((uint32_t)0x00000008)
S#define  RCC_CIR_PLLRDYF                     ((uint32_t)0x00000010)
S#define  RCC_CIR_PLLI2SRDYF                  ((uint32_t)0x00000020)
S#define  RCC_CIR_PLLSAIRDYF                  ((uint32_t)0x00000040)
S#define  RCC_CIR_CSSF                        ((uint32_t)0x00000080)
S#define  RCC_CIR_LSIRDYIE                    ((uint32_t)0x00000100)
S#define  RCC_CIR_LSERDYIE                    ((uint32_t)0x00000200)
S#define  RCC_CIR_HSIRDYIE                    ((uint32_t)0x00000400)
S#define  RCC_CIR_HSERDYIE                    ((uint32_t)0x00000800)
S#define  RCC_CIR_PLLRDYIE                    ((uint32_t)0x00001000)
S#define  RCC_CIR_PLLI2SRDYIE                 ((uint32_t)0x00002000)
S#define  RCC_CIR_PLLSAIRDYIE                 ((uint32_t)0x00004000)
S#define  RCC_CIR_LSIRDYC                     ((uint32_t)0x00010000)
S#define  RCC_CIR_LSERDYC                     ((uint32_t)0x00020000)
S#define  RCC_CIR_HSIRDYC                     ((uint32_t)0x00040000)
S#define  RCC_CIR_HSERDYC                     ((uint32_t)0x00080000)
S#define  RCC_CIR_PLLRDYC                     ((uint32_t)0x00100000)
S#define  RCC_CIR_PLLI2SRDYC                  ((uint32_t)0x00200000)
S#define  RCC_CIR_PLLSAIRDYC                  ((uint32_t)0x00400000)
S#define  RCC_CIR_CSSC                        ((uint32_t)0x00800000)
S
S/********************  Bit definition for RCC_AHB1RSTR register  **************/
S#define  RCC_AHB1RSTR_GPIOARST               ((uint32_t)0x00000001)
S#define  RCC_AHB1RSTR_GPIOBRST               ((uint32_t)0x00000002)
S#define  RCC_AHB1RSTR_GPIOCRST               ((uint32_t)0x00000004)
S#define  RCC_AHB1RSTR_GPIODRST               ((uint32_t)0x00000008)
S#define  RCC_AHB1RSTR_GPIOERST               ((uint32_t)0x00000010)
S#define  RCC_AHB1RSTR_GPIOFRST               ((uint32_t)0x00000020)
S#define  RCC_AHB1RSTR_GPIOGRST               ((uint32_t)0x00000040)
S#define  RCC_AHB1RSTR_GPIOHRST               ((uint32_t)0x00000080)
S#define  RCC_AHB1RSTR_GPIOIRST               ((uint32_t)0x00000100)
S#define  RCC_AHB1RSTR_GPIOJRST               ((uint32_t)0x00000200)
S#define  RCC_AHB1RSTR_GPIOKRST               ((uint32_t)0x00000400)
S#define  RCC_AHB1RSTR_CRCRST                 ((uint32_t)0x00001000)
S#define  RCC_AHB1RSTR_DMA1RST                ((uint32_t)0x00200000)
S#define  RCC_AHB1RSTR_DMA2RST                ((uint32_t)0x00400000)
S#define  RCC_AHB1RSTR_DMA2DRST               ((uint32_t)0x00800000)
S#define  RCC_AHB1RSTR_ETHMACRST              ((uint32_t)0x02000000)
S#define  RCC_AHB1RSTR_OTGHRST                ((uint32_t)0x10000000)
S
S/********************  Bit definition for RCC_AHB2RSTR register  **************/
S#define  RCC_AHB2RSTR_DCMIRST                ((uint32_t)0x00000001)
S#define  RCC_AHB2RSTR_CRYPRST                ((uint32_t)0x00000010)
S#define  RCC_AHB2RSTR_HASHRST                ((uint32_t)0x00000020)
S /* maintained for legacy purpose */
S#define  RCC_AHB2RSTR_HSAHRST                RCC_AHB2RSTR_HASHRST
S#define  RCC_AHB2RSTR_RNGRST                 ((uint32_t)0x00000040)
S#define  RCC_AHB2RSTR_OTGFSRST               ((uint32_t)0x00000080)
S
S/********************  Bit definition for RCC_AHB3RSTR register  **************/
S#if defined(STM32F40_41xxx) || defined(STM32F412xG) || defined(STM32F413_423xx)
S#define  RCC_AHB3RSTR_FSMCRST                ((uint32_t)0x00000001)
S#endif /* STM32F40_41xxx || STM32F412xG || STM32F413_423xx */
S
S#if defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
S#define  RCC_AHB3RSTR_FMCRST                ((uint32_t)0x00000001)
S#endif /* STM32F427_437xx ||  STM32F429_439xx || STM32F446xx || STM32F469_479xx */
S#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
S#define  RCC_AHB3RSTR_QSPIRST               ((uint32_t)0x00000002)
S#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx || STM32F469_479xx */
S
S/********************  Bit definition for RCC_APB1RSTR register  **************/
S#define  RCC_APB1RSTR_TIM2RST                ((uint32_t)0x00000001)
S#define  RCC_APB1RSTR_TIM3RST                ((uint32_t)0x00000002)
S#define  RCC_APB1RSTR_TIM4RST                ((uint32_t)0x00000004)
S#define  RCC_APB1RSTR_TIM5RST                ((uint32_t)0x00000008)
S#define  RCC_APB1RSTR_TIM6RST                ((uint32_t)0x00000010)
S#define  RCC_APB1RSTR_TIM7RST                ((uint32_t)0x00000020)
S#define  RCC_APB1RSTR_TIM12RST               ((uint32_t)0x00000040)
S#define  RCC_APB1RSTR_TIM13RST               ((uint32_t)0x00000080)
S#define  RCC_APB1RSTR_TIM14RST               ((uint32_t)0x00000100)
S#if defined(STM32F410xx) || defined(STM32F413_423xx)
S#define  RCC_APB1RSTR_LPTIM1RST              ((uint32_t)0x00000200)
S#endif /* STM32F410xx || STM32F413_423xx */
S#define  RCC_APB1RSTR_WWDGRST                ((uint32_t)0x00000800)
S#define  RCC_APB1RSTR_SPI2RST                ((uint32_t)0x00004000)
S#define  RCC_APB1RSTR_SPI3RST                ((uint32_t)0x00008000)
S#if defined(STM32F446xx)
S#define  RCC_APB1RSTR_SPDIFRXRST             ((uint32_t)0x00010000)
S#endif /* STM32F446xx */
S#define  RCC_APB1RSTR_USART2RST              ((uint32_t)0x00020000)
S#define  RCC_APB1RSTR_USART3RST              ((uint32_t)0x00040000)
S#define  RCC_APB1RSTR_UART4RST               ((uint32_t)0x00080000)
S#define  RCC_APB1RSTR_UART5RST               ((uint32_t)0x00100000)
S#define  RCC_APB1RSTR_I2C1RST                ((uint32_t)0x00200000)
S#define  RCC_APB1RSTR_I2C2RST                ((uint32_t)0x00400000)
S#define  RCC_APB1RSTR_I2C3RST                ((uint32_t)0x00800000)
S#if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
S#define  RCC_APB1RSTR_FMPI2C1RST             ((uint32_t)0x01000000)
S#endif /* STM32F410xx || STM32F412xG || STM32F413_423xx || STM32F446xx */
S#define  RCC_APB1RSTR_CAN1RST                ((uint32_t)0x02000000)
S#define  RCC_APB1RSTR_CAN2RST                ((uint32_t)0x04000000)
S#if defined(STM32F446xx)
S#define  RCC_APB1RSTR_CECRST                 ((uint32_t)0x08000000)
S#endif /* STM32F446xx */
S#define  RCC_APB1RSTR_PWRRST                 ((uint32_t)0x10000000)
S#define  RCC_APB1RSTR_DACRST                 ((uint32_t)0x20000000)
S#define  RCC_APB1RSTR_UART7RST               ((uint32_t)0x40000000)
S#define  RCC_APB1RSTR_UART8RST               ((uint32_t)0x80000000)
S
S/********************  Bit definition for RCC_APB2RSTR register  **************/
S#define  RCC_APB2RSTR_TIM1RST                ((uint32_t)0x00000001)
S#define  RCC_APB2RSTR_TIM8RST                ((uint32_t)0x00000002)
S#define  RCC_APB2RSTR_USART1RST              ((uint32_t)0x00000010)
S#define  RCC_APB2RSTR_USART6RST              ((uint32_t)0x00000020)
S#define  RCC_APB2RSTR_UART9RST               ((uint32_t)0x00000040)
S#define  RCC_APB2RSTR_UART10RST              ((uint32_t)0x00000080)
S#define  RCC_APB2RSTR_ADCRST                 ((uint32_t)0x00000100)
S#define  RCC_APB2RSTR_SDIORST                ((uint32_t)0x00000800)
S#define  RCC_APB2RSTR_SPI1RST                ((uint32_t)0x00001000)
S#define  RCC_APB2RSTR_SPI4RST                ((uint32_t)0x00002000)
S#define  RCC_APB2RSTR_SYSCFGRST              ((uint32_t)0x00004000)
S#define  RCC_APB2RSTR_TIM9RST                ((uint32_t)0x00010000)
S#define  RCC_APB2RSTR_TIM10RST               ((uint32_t)0x00020000)
S#define  RCC_APB2RSTR_TIM11RST               ((uint32_t)0x00040000)
S#define  RCC_APB2RSTR_SPI5RST                ((uint32_t)0x00100000)
S#define  RCC_APB2RSTR_SPI6RST                ((uint32_t)0x00200000)
S#define  RCC_APB2RSTR_SAI1RST                ((uint32_t)0x00400000)
S#if defined(STM32F446xx)
S#define  RCC_APB2RSTR_SAI2RST                ((uint32_t)0x00800000)
S#endif /* STM32F446xx */
S#define  RCC_APB2RSTR_LTDCRST                ((uint32_t)0x04000000)
S#if defined(STM32F469_479xx)
S#define  RCC_APB2RSTR_DSIRST                 ((uint32_t)0x08000000)
S#endif /* STM32F469_479xx */
S#if defined(STM32F412xG) || defined(STM32F413_423xx)
S#define  RCC_APB2RSTR_DFSDM1RST              ((uint32_t)0x01000000)
S#endif /* STM32F412xG || STM32F413_423xx */
S
S#if defined(STM32F413_423xx)
S#define  RCC_APB2RSTR_DFSDM2RST              ((uint32_t)0x02000000)
S#endif /* STM32F413_423xx */
S/* Old definitions, maintained for legacy purpose */
S#define  RCC_APB2RSTR_SPI1                   RCC_APB2RSTR_SPI1RST
S#define  RCC_APB2RSTR_DFSDMRST               RCC_APB2RSTR_DFSDM1RST
S
S/********************  Bit definition for RCC_AHB1ENR register  ***************/
S#define  RCC_AHB1ENR_GPIOAEN                 ((uint32_t)0x00000001)
S#define  RCC_AHB1ENR_GPIOBEN                 ((uint32_t)0x00000002)
S#define  RCC_AHB1ENR_GPIOCEN                 ((uint32_t)0x00000004)
S#define  RCC_AHB1ENR_GPIODEN                 ((uint32_t)0x00000008)
S#define  RCC_AHB1ENR_GPIOEEN                 ((uint32_t)0x00000010)
S#define  RCC_AHB1ENR_GPIOFEN                 ((uint32_t)0x00000020)
S#define  RCC_AHB1ENR_GPIOGEN                 ((uint32_t)0x00000040)
S#define  RCC_AHB1ENR_GPIOHEN                 ((uint32_t)0x00000080)
S#define  RCC_AHB1ENR_GPIOIEN                 ((uint32_t)0x00000100)
S#define  RCC_AHB1ENR_GPIOJEN                 ((uint32_t)0x00000200)
S#define  RCC_AHB1ENR_GPIOKEN                 ((uint32_t)0x00000400)
S#define  RCC_AHB1ENR_CRCEN                   ((uint32_t)0x00001000)
S#define  RCC_AHB1ENR_BKPSRAMEN               ((uint32_t)0x00040000)
S#define  RCC_AHB1ENR_CCMDATARAMEN            ((uint32_t)0x00100000)
S#define  RCC_AHB1ENR_DMA1EN                  ((uint32_t)0x00200000)
S#define  RCC_AHB1ENR_DMA2EN                  ((uint32_t)0x00400000)
S#define  RCC_AHB1ENR_DMA2DEN                 ((uint32_t)0x00800000)
S#define  RCC_AHB1ENR_ETHMACEN                ((uint32_t)0x02000000)
S#define  RCC_AHB1ENR_ETHMACTXEN              ((uint32_t)0x04000000)
S#define  RCC_AHB1ENR_ETHMACRXEN              ((uint32_t)0x08000000)
S#define  RCC_AHB1ENR_ETHMACPTPEN             ((uint32_t)0x10000000)
S#define  RCC_AHB1ENR_OTGHSEN                 ((uint32_t)0x20000000)
S#define  RCC_AHB1ENR_OTGHSULPIEN             ((uint32_t)0x40000000)
S
S/********************  Bit definition for RCC_AHB2ENR register  ***************/
S#define  RCC_AHB2ENR_DCMIEN                  ((uint32_t)0x00000001)
S#define  RCC_AHB2ENR_CRYPEN                  ((uint32_t)0x00000010)
S#define  RCC_AHB2ENR_HASHEN                  ((uint32_t)0x00000020)
S#define  RCC_AHB2ENR_RNGEN                   ((uint32_t)0x00000040)
S#define  RCC_AHB2ENR_OTGFSEN                 ((uint32_t)0x00000080)
S
S/********************  Bit definition for RCC_AHB3ENR register  ***************/
S
S#if defined(STM32F40_41xxx) || defined(STM32F412xG) || defined(STM32F413_423xx)
S#define  RCC_AHB3ENR_FSMCEN                  ((uint32_t)0x00000001)
S#endif /* STM32F40_41xxx || STM32F412xG || STM32F413_423xx */
S
S#if defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
S#define  RCC_AHB3ENR_FMCEN                  ((uint32_t)0x00000001)
S#endif /* STM32F427_437xx ||  STM32F429_439xx || STM32F446xx || STM32F469_479xx */
S
S#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
S#define  RCC_AHB3ENR_QSPIEN                 ((uint32_t)0x00000002)
S#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx || STM32F469_479xx */
S
S/********************  Bit definition for RCC_APB1ENR register  ***************/
S#define  RCC_APB1ENR_TIM2EN                  ((uint32_t)0x00000001)
S#define  RCC_APB1ENR_TIM3EN                  ((uint32_t)0x00000002)
S#define  RCC_APB1ENR_TIM4EN                  ((uint32_t)0x00000004)
S#define  RCC_APB1ENR_TIM5EN                  ((uint32_t)0x00000008)
S#define  RCC_APB1ENR_TIM6EN                  ((uint32_t)0x00000010)
S#define  RCC_APB1ENR_TIM7EN                  ((uint32_t)0x00000020)
S#define  RCC_APB1ENR_TIM12EN                 ((uint32_t)0x00000040)
S#define  RCC_APB1ENR_TIM13EN                 ((uint32_t)0x00000080)
S#define  RCC_APB1ENR_TIM14EN                 ((uint32_t)0x00000100)
S#if defined(STM32F410xx) || defined(STM32F413_423xx)
S#define  RCC_APB1ENR_LPTIM1EN                ((uint32_t)0x00000200)
S#endif /* STM32F410xx || STM32F413_423xx */
S#define  RCC_APB1ENR_WWDGEN                  ((uint32_t)0x00000800)
S#define  RCC_APB1ENR_SPI2EN                  ((uint32_t)0x00004000)
S#define  RCC_APB1ENR_SPI3EN                  ((uint32_t)0x00008000)
S#if defined(STM32F446xx)
S#define  RCC_APB1ENR_SPDIFRXEN               ((uint32_t)0x00010000)
S#endif /* STM32F446xx */
S#define  RCC_APB1ENR_USART2EN                ((uint32_t)0x00020000)
S#define  RCC_APB1ENR_USART3EN                ((uint32_t)0x00040000)
S#define  RCC_APB1ENR_UART4EN                 ((uint32_t)0x00080000)
S#define  RCC_APB1ENR_UART5EN                 ((uint32_t)0x00100000)
S#define  RCC_APB1ENR_I2C1EN                  ((uint32_t)0x00200000)
S#define  RCC_APB1ENR_I2C2EN                  ((uint32_t)0x00400000)
S#define  RCC_APB1ENR_I2C3EN                  ((uint32_t)0x00800000)
S#if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
S#define  RCC_APB1ENR_FMPI2C1EN               ((uint32_t)0x01000000)
S#endif /* STM32F410xx || STM32F412xG || STM32F413_423xx || STM32F446xx */
S#define  RCC_APB1ENR_CAN1EN                  ((uint32_t)0x02000000)
S#define  RCC_APB1ENR_CAN2EN                  ((uint32_t)0x04000000)
S#if defined(STM32F446xx)
S#define  RCC_APB1ENR_CECEN                   ((uint32_t)0x08000000)
S#endif /* STM32F446xx */
S#define  RCC_APB1ENR_PWREN                   ((uint32_t)0x10000000)
S#define  RCC_APB1ENR_DACEN                   ((uint32_t)0x20000000)
S#define  RCC_APB1ENR_UART7EN                 ((uint32_t)0x40000000)
S#define  RCC_APB1ENR_UART8EN                 ((uint32_t)0x80000000)
S
S/********************  Bit definition for RCC_APB2ENR register  ***************/
S#define  RCC_APB2ENR_TIM1EN                  ((uint32_t)0x00000001)
S#define  RCC_APB2ENR_TIM8EN                  ((uint32_t)0x00000002)
S#define  RCC_APB2ENR_USART1EN                ((uint32_t)0x00000010)
S#define  RCC_APB2ENR_USART6EN                ((uint32_t)0x00000020)
S#define  RCC_APB2ENR_UART9EN                 ((uint32_t)0x00000040)
S#define  RCC_APB2ENR_UART10EN                ((uint32_t)0x00000080)
S#define  RCC_APB2ENR_ADC1EN                  ((uint32_t)0x00000100)
S#define  RCC_APB2ENR_ADC2EN                  ((uint32_t)0x00000200)
S#define  RCC_APB2ENR_ADC3EN                  ((uint32_t)0x00000400)
S#define  RCC_APB2ENR_SDIOEN                  ((uint32_t)0x00000800)
S#define  RCC_APB2ENR_SPI1EN                  ((uint32_t)0x00001000)
S#define  RCC_APB2ENR_SPI4EN                  ((uint32_t)0x00002000)
S#define  RCC_APB2ENR_SYSCFGEN                ((uint32_t)0x00004000)
S#define  RCC_APB2ENR_EXTIEN                  ((uint32_t)0x00008000)
S#define  RCC_APB2ENR_TIM9EN                  ((uint32_t)0x00010000)
S#define  RCC_APB2ENR_TIM10EN                 ((uint32_t)0x00020000)
S#define  RCC_APB2ENR_TIM11EN                 ((uint32_t)0x00040000)
S#define  RCC_APB2ENR_SPI5EN                  ((uint32_t)0x00100000)
S#define  RCC_APB2ENR_SPI6EN                  ((uint32_t)0x00200000)
S#define  RCC_APB2ENR_SAI1EN                  ((uint32_t)0x00400000)
S#if defined(STM32F446xx)
S#define  RCC_APB2ENR_SAI2EN                  ((uint32_t)0x00800000)
S#endif /* STM32F446xx */
S#define  RCC_APB2ENR_LTDCEN                  ((uint32_t)0x04000000)
S#if defined(STM32F469_479xx)
S#define  RCC_APB2ENR_DSIEN                   ((uint32_t)0x08000000)
S#endif /* STM32F469_479xx */
S#if defined(STM32F412xG) || defined(STM32F413_423xx)
S#define  RCC_APB2ENR_DFSDM1EN                ((uint32_t)0x01000000)
S#endif /* STM32F412xG || STM32F413_423xx */
S#if defined(STM32F413_423xx)
S#define  RCC_APB2ENR_DFSDM2EN                ((uint32_t)0x02000000)
S#endif /* STM32F413_423xx */
S/********************  Bit definition for RCC_AHB1LPENR register  *************/
S#define  RCC_AHB1LPENR_GPIOALPEN             ((uint32_t)0x00000001)
S#define  RCC_AHB1LPENR_GPIOBLPEN             ((uint32_t)0x00000002)
S#define  RCC_AHB1LPENR_GPIOCLPEN             ((uint32_t)0x00000004)
S#define  RCC_AHB1LPENR_GPIODLPEN             ((uint32_t)0x00000008)
S#define  RCC_AHB1LPENR_GPIOELPEN             ((uint32_t)0x00000010)
S#define  RCC_AHB1LPENR_GPIOFLPEN             ((uint32_t)0x00000020)
S#define  RCC_AHB1LPENR_GPIOGLPEN             ((uint32_t)0x00000040)
S#define  RCC_AHB1LPENR_GPIOHLPEN             ((uint32_t)0x00000080)
S#define  RCC_AHB1LPENR_GPIOILPEN             ((uint32_t)0x00000100)
S#define  RCC_AHB1LPENR_GPIOJLPEN             ((uint32_t)0x00000200)
S#define  RCC_AHB1LPENR_GPIOKLPEN             ((uint32_t)0x00000400)
S#define  RCC_AHB1LPENR_CRCLPEN               ((uint32_t)0x00001000)
S#define  RCC_AHB1LPENR_FLITFLPEN             ((uint32_t)0x00008000)
S#define  RCC_AHB1LPENR_SRAM1LPEN             ((uint32_t)0x00010000)
S#define  RCC_AHB1LPENR_SRAM2LPEN             ((uint32_t)0x00020000)
S#define  RCC_AHB1LPENR_BKPSRAMLPEN           ((uint32_t)0x00040000)
S#define  RCC_AHB1LPENR_SRAM3LPEN             ((uint32_t)0x00080000)
S#define  RCC_AHB1LPENR_DMA1LPEN              ((uint32_t)0x00200000)
S#define  RCC_AHB1LPENR_DMA2LPEN              ((uint32_t)0x00400000)
S#define  RCC_AHB1LPENR_DMA2DLPEN             ((uint32_t)0x00800000)
S#define  RCC_AHB1LPENR_ETHMACLPEN            ((uint32_t)0x02000000)
S#define  RCC_AHB1LPENR_ETHMACTXLPEN          ((uint32_t)0x04000000)
S#define  RCC_AHB1LPENR_ETHMACRXLPEN          ((uint32_t)0x08000000)
S#define  RCC_AHB1LPENR_ETHMACPTPLPEN         ((uint32_t)0x10000000)
S#define  RCC_AHB1LPENR_OTGHSLPEN             ((uint32_t)0x20000000)
S#define  RCC_AHB1LPENR_OTGHSULPILPEN         ((uint32_t)0x40000000)
S
S/********************  Bit definition for RCC_AHB2LPENR register  *************/
S#define  RCC_AHB2LPENR_DCMILPEN              ((uint32_t)0x00000001)
S#define  RCC_AHB2LPENR_CRYPLPEN              ((uint32_t)0x00000010)
S#define  RCC_AHB2LPENR_HASHLPEN              ((uint32_t)0x00000020)
S#define  RCC_AHB2LPENR_RNGLPEN               ((uint32_t)0x00000040)
S#define  RCC_AHB2LPENR_OTGFSLPEN             ((uint32_t)0x00000080)
S
S/********************  Bit definition for RCC_AHB3LPENR register  *************/
S#if defined(STM32F40_41xxx) || defined(STM32F412xG) || defined(STM32F413_423xx)
S#define  RCC_AHB3LPENR_FSMCLPEN              ((uint32_t)0x00000001)
S#endif /* STM32F40_41xxx || STM32F412xG || STM32F413_423xx */
S
S#if defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
S#define  RCC_AHB3LPENR_FMCLPEN              ((uint32_t)0x00000001)
S#endif /* STM32F427_437xx ||  STM32F429_439xx  || STM32F446xx || STM32F469_479xx */
S#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
S#define  RCC_AHB3LPENR_QSPILPEN             ((uint32_t)0x00000002)
S#endif /* STM32F412xG || STM32F413_423xx || STM32F469_479xx || STM32F446xx */
S
S/********************  Bit definition for RCC_APB1LPENR register  *************/
S#define  RCC_APB1LPENR_TIM2LPEN              ((uint32_t)0x00000001)
S#define  RCC_APB1LPENR_TIM3LPEN              ((uint32_t)0x00000002)
S#define  RCC_APB1LPENR_TIM4LPEN              ((uint32_t)0x00000004)
S#define  RCC_APB1LPENR_TIM5LPEN              ((uint32_t)0x00000008)
S#define  RCC_APB1LPENR_TIM6LPEN              ((uint32_t)0x00000010)
S#define  RCC_APB1LPENR_TIM7LPEN              ((uint32_t)0x00000020)
S#define  RCC_APB1LPENR_TIM12LPEN             ((uint32_t)0x00000040)
S#define  RCC_APB1LPENR_TIM13LPEN             ((uint32_t)0x00000080)
S#define  RCC_APB1LPENR_TIM14LPEN             ((uint32_t)0x00000100)
S#if defined(STM32F410xx) || defined(STM32F413_423xx)
S#define  RCC_APB1LPENR_LPTIM1LPEN            ((uint32_t)0x00000200)
S#endif /* STM32F410xx || STM32F413_423xx */
S#define  RCC_APB1LPENR_WWDGLPEN              ((uint32_t)0x00000800)
S#define  RCC_APB1LPENR_SPI2LPEN              ((uint32_t)0x00004000)
S#define  RCC_APB1LPENR_SPI3LPEN              ((uint32_t)0x00008000)
S#if defined(STM32F446xx)
S#define  RCC_APB1LPENR_SPDIFRXLPEN           ((uint32_t)0x00010000)
S#endif /* STM32F446xx */
S#define  RCC_APB1LPENR_USART2LPEN            ((uint32_t)0x00020000)
S#define  RCC_APB1LPENR_USART3LPEN            ((uint32_t)0x00040000)
S#define  RCC_APB1LPENR_UART4LPEN             ((uint32_t)0x00080000)
S#define  RCC_APB1LPENR_UART5LPEN             ((uint32_t)0x00100000)
S#define  RCC_APB1LPENR_I2C1LPEN              ((uint32_t)0x00200000)
S#define  RCC_APB1LPENR_I2C2LPEN              ((uint32_t)0x00400000)
S#define  RCC_APB1LPENR_I2C3LPEN              ((uint32_t)0x00800000)
S#if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
S#define  RCC_APB1LPENR_FMPI2C1LPEN           ((uint32_t)0x01000000)
S#endif /* STM32F410xx || STM32F412xG || STM32F413_423xx || STM32F446xx */
S#define  RCC_APB1LPENR_CAN1LPEN              ((uint32_t)0x02000000)
S#define  RCC_APB1LPENR_CAN2LPEN              ((uint32_t)0x04000000)
S#if defined(STM32F446xx)
S#define  RCC_APB1LPENR_CECLPEN               ((uint32_t)0x08000000)
S#endif /* STM32F446xx */
S#define  RCC_APB1LPENR_PWRLPEN               ((uint32_t)0x10000000)
S#define  RCC_APB1LPENR_DACLPEN               ((uint32_t)0x20000000)
S#define  RCC_APB1LPENR_UART7LPEN             ((uint32_t)0x40000000)
S#define  RCC_APB1LPENR_UART8LPEN             ((uint32_t)0x80000000)
S
S/********************  Bit definition for RCC_APB2LPENR register  *************/
S#define  RCC_APB2LPENR_TIM1LPEN              ((uint32_t)0x00000001)
S#define  RCC_APB2LPENR_TIM8LPEN              ((uint32_t)0x00000002)
S#define  RCC_APB2LPENR_USART1LPEN            ((uint32_t)0x00000010)
S#define  RCC_APB2LPENR_USART6LPEN            ((uint32_t)0x00000020)
S#define  RCC_APB2LPENR_UART9LPEN             ((uint32_t)0x00000040)
S#define  RCC_APB2LPENR_UART10LPEN            ((uint32_t)0x00000080)
S#define  RCC_APB2LPENR_ADC1LPEN              ((uint32_t)0x00000100)
S#define  RCC_APB2LPENR_ADC2PEN               ((uint32_t)0x00000200)
S#define  RCC_APB2LPENR_ADC3LPEN              ((uint32_t)0x00000400)
S#define  RCC_APB2LPENR_SDIOLPEN              ((uint32_t)0x00000800)
S#define  RCC_APB2LPENR_SPI1LPEN              ((uint32_t)0x00001000)
S#define  RCC_APB2LPENR_SPI4LPEN              ((uint32_t)0x00002000)
S#define  RCC_APB2LPENR_SYSCFGLPEN            ((uint32_t)0x00004000)
S#define  RCC_APB2LPENR_TIM9LPEN              ((uint32_t)0x00010000)
S#define  RCC_APB2LPENR_TIM10LPEN             ((uint32_t)0x00020000)
S#define  RCC_APB2LPENR_TIM11LPEN             ((uint32_t)0x00040000)
S#define  RCC_APB2LPENR_SPI5LPEN              ((uint32_t)0x00100000)
S#define  RCC_APB2LPENR_SPI6LPEN              ((uint32_t)0x00200000)
S#define  RCC_APB2LPENR_SAI1LPEN              ((uint32_t)0x00400000)
S#if defined(STM32F446xx)
S#define  RCC_APB2LPENR_SAI2LPEN              ((uint32_t)0x00800000)
S#endif /* STM32F446xx */
S#define  RCC_APB2LPENR_LTDCLPEN              ((uint32_t)0x04000000)
S#if defined(STM32F469_479xx)
S#define  RCC_APB2LPENR_DSILPEN               ((uint32_t)0x08000000)
S#endif /* STM32F469_479xx */
S#if defined(STM32F412xG) || defined(STM32F413_423xx)
S#define  RCC_APB2LPENR_DFSDM1LPEN            ((uint32_t)0x01000000)
S#endif /* STM32F412xG || STM32F413_423xx */
S#if defined(STM32F413_423xx)
S#define  RCC_APB2LPENR_DFSDM2LPEN            ((uint32_t)0x02000000)
S#endif /* STM32F413_423xx */
S
S/********************  Bit definition for RCC_BDCR register  ******************/
S#define  RCC_BDCR_LSEON                      ((uint32_t)0x00000001)
S#define  RCC_BDCR_LSERDY                     ((uint32_t)0x00000002)
S#define  RCC_BDCR_LSEBYP                     ((uint32_t)0x00000004)
S#define  RCC_BDCR_LSEMOD                     ((uint32_t)0x00000008)
S
S#define  RCC_BDCR_RTCSEL                    ((uint32_t)0x00000300)
S#define  RCC_BDCR_RTCSEL_0                  ((uint32_t)0x00000100)
S#define  RCC_BDCR_RTCSEL_1                  ((uint32_t)0x00000200)
S
S#define  RCC_BDCR_RTCEN                      ((uint32_t)0x00008000)
S#define  RCC_BDCR_BDRST                      ((uint32_t)0x00010000)
S
S/********************  Bit definition for RCC_CSR register  *******************/
S#define  RCC_CSR_LSION                       ((uint32_t)0x00000001)
S#define  RCC_CSR_LSIRDY                      ((uint32_t)0x00000002)
S#define  RCC_CSR_RMVF                        ((uint32_t)0x01000000)
S#define  RCC_CSR_BORRSTF                     ((uint32_t)0x02000000)
S#define  RCC_CSR_PADRSTF                     ((uint32_t)0x04000000)
S#define  RCC_CSR_PORRSTF                     ((uint32_t)0x08000000)
S#define  RCC_CSR_SFTRSTF                     ((uint32_t)0x10000000)
S#define  RCC_CSR_WDGRSTF                     ((uint32_t)0x20000000)
S#define  RCC_CSR_WWDGRSTF                    ((uint32_t)0x40000000)
S#define  RCC_CSR_LPWRRSTF                    ((uint32_t)0x80000000)
S
S/********************  Bit definition for RCC_SSCGR register  *****************/
S#define  RCC_SSCGR_MODPER                    ((uint32_t)0x00001FFF)
S#define  RCC_SSCGR_INCSTEP                   ((uint32_t)0x0FFFE000)
S#define  RCC_SSCGR_SPREADSEL                 ((uint32_t)0x40000000)
S#define  RCC_SSCGR_SSCGEN                    ((uint32_t)0x80000000)
S
S/********************  Bit definition for RCC_PLLI2SCFGR register  ************/
S#define  RCC_PLLI2SCFGR_PLLI2SM              ((uint32_t)0x0000003F)
S#define  RCC_PLLI2SCFGR_PLLI2SM_0            ((uint32_t)0x00000001)
S#define  RCC_PLLI2SCFGR_PLLI2SM_1            ((uint32_t)0x00000002)
S#define  RCC_PLLI2SCFGR_PLLI2SM_2            ((uint32_t)0x00000004)
S#define  RCC_PLLI2SCFGR_PLLI2SM_3            ((uint32_t)0x00000008)
S#define  RCC_PLLI2SCFGR_PLLI2SM_4            ((uint32_t)0x00000010)
S#define  RCC_PLLI2SCFGR_PLLI2SM_5            ((uint32_t)0x00000020)
S
S#define  RCC_PLLI2SCFGR_PLLI2SN              ((uint32_t)0x00007FC0)
S#define  RCC_PLLI2SCFGR_PLLI2SN_0            ((uint32_t)0x00000040)
S#define  RCC_PLLI2SCFGR_PLLI2SN_1            ((uint32_t)0x00000080)
S#define  RCC_PLLI2SCFGR_PLLI2SN_2            ((uint32_t)0x00000100)
S#define  RCC_PLLI2SCFGR_PLLI2SN_3            ((uint32_t)0x00000200)
S#define  RCC_PLLI2SCFGR_PLLI2SN_4            ((uint32_t)0x00000400)
S#define  RCC_PLLI2SCFGR_PLLI2SN_5            ((uint32_t)0x00000800)
S#define  RCC_PLLI2SCFGR_PLLI2SN_6            ((uint32_t)0x00001000)
S#define  RCC_PLLI2SCFGR_PLLI2SN_7            ((uint32_t)0x00002000)
S#define  RCC_PLLI2SCFGR_PLLI2SN_8            ((uint32_t)0x00004000)
S
S#if defined(STM32F412xG) || defined(STM32F413_423xx)
S#define  RCC_PLLI2SCFGR_PLLI2SSRC            ((uint32_t)0x00400000)
S#endif /* STM32F412xG || STM32F413_423xx */
S
S#if defined(STM32F446xx)
S#define  RCC_PLLI2SCFGR_PLLI2SP              ((uint32_t)0x00030000)
S#define  RCC_PLLI2SCFGR_PLLI2SP_0            ((uint32_t)0x00010000)
S#define  RCC_PLLI2SCFGR_PLLI2SP_1            ((uint32_t)0x00020000)
S#endif /* STM32F446xx */
S
S#define  RCC_PLLI2SCFGR_PLLI2SQ              ((uint32_t)0x0F000000)
S#define  RCC_PLLI2SCFGR_PLLI2SQ_0            ((uint32_t)0x01000000)
S#define  RCC_PLLI2SCFGR_PLLI2SQ_1            ((uint32_t)0x02000000)
S#define  RCC_PLLI2SCFGR_PLLI2SQ_2            ((uint32_t)0x04000000)
S#define  RCC_PLLI2SCFGR_PLLI2SQ_3            ((uint32_t)0x08000000)
S
S#define  RCC_PLLI2SCFGR_PLLI2SR              ((uint32_t)0x70000000)
S#define  RCC_PLLI2SCFGR_PLLI2SR_0            ((uint32_t)0x10000000)
S#define  RCC_PLLI2SCFGR_PLLI2SR_1            ((uint32_t)0x20000000)
S#define  RCC_PLLI2SCFGR_PLLI2SR_2            ((uint32_t)0x40000000)
S
S/********************  Bit definition for RCC_PLLSAICFGR register  ************/
S#if defined(STM32F446xx)
S#define  RCC_PLLSAICFGR_PLLSAIM              ((uint32_t)0x0000003F)
S#define  RCC_PLLSAICFGR_PLLSAIM_0            ((uint32_t)0x00000001)
S#define  RCC_PLLSAICFGR_PLLSAIM_1            ((uint32_t)0x00000002)
S#define  RCC_PLLSAICFGR_PLLSAIM_2            ((uint32_t)0x00000004)
S#define  RCC_PLLSAICFGR_PLLSAIM_3            ((uint32_t)0x00000008)
S#define  RCC_PLLSAICFGR_PLLSAIM_4            ((uint32_t)0x00000010)
S#define  RCC_PLLSAICFGR_PLLSAIM_5            ((uint32_t)0x00000020)
S#endif /* STM32F446xx */
S
S#define  RCC_PLLSAICFGR_PLLSAIN              ((uint32_t)0x00007FC0)
S#define  RCC_PLLSAICFGR_PLLSAIN_0            ((uint32_t)0x00000040)
S#define  RCC_PLLSAICFGR_PLLSAIN_1            ((uint32_t)0x00000080)
S#define  RCC_PLLSAICFGR_PLLSAIN_2            ((uint32_t)0x00000100)
S#define  RCC_PLLSAICFGR_PLLSAIN_3            ((uint32_t)0x00000200)
S#define  RCC_PLLSAICFGR_PLLSAIN_4            ((uint32_t)0x00000400)
S#define  RCC_PLLSAICFGR_PLLSAIN_5            ((uint32_t)0x00000800)
S#define  RCC_PLLSAICFGR_PLLSAIN_6            ((uint32_t)0x00001000)
S#define  RCC_PLLSAICFGR_PLLSAIN_7            ((uint32_t)0x00002000)
S#define  RCC_PLLSAICFGR_PLLSAIN_8            ((uint32_t)0x00004000)
S
S#if defined(STM32F446xx) || defined(STM32F469_479xx)  
S#define  RCC_PLLSAICFGR_PLLSAIP              ((uint32_t)0x00030000)
S#define  RCC_PLLSAICFGR_PLLSAIP_0            ((uint32_t)0x00010000)
S#define  RCC_PLLSAICFGR_PLLSAIP_1            ((uint32_t)0x00020000)
S#endif /* STM32F446xx || STM32F469_479xx */
S
S#define  RCC_PLLSAICFGR_PLLSAIQ              ((uint32_t)0x0F000000)
S#define  RCC_PLLSAICFGR_PLLSAIQ_0            ((uint32_t)0x01000000)
S#define  RCC_PLLSAICFGR_PLLSAIQ_1            ((uint32_t)0x02000000)
S#define  RCC_PLLSAICFGR_PLLSAIQ_2            ((uint32_t)0x04000000)
S#define  RCC_PLLSAICFGR_PLLSAIQ_3            ((uint32_t)0x08000000)
S
S#define  RCC_PLLSAICFGR_PLLSAIR              ((uint32_t)0x70000000)
S#define  RCC_PLLSAICFGR_PLLSAIR_0            ((uint32_t)0x10000000)
S#define  RCC_PLLSAICFGR_PLLSAIR_1            ((uint32_t)0x20000000)
S#define  RCC_PLLSAICFGR_PLLSAIR_2            ((uint32_t)0x40000000)
S
S/********************  Bit definition for RCC_DCKCFGR register  ***************/
S#define  RCC_DCKCFGR_PLLI2SDIVQ              ((uint32_t)0x0000001F)
S#define  RCC_DCKCFGR_PLLSAIDIVQ              ((uint32_t)0x00001F00)
S#define  RCC_DCKCFGR_PLLSAIDIVR              ((uint32_t)0x00030000)
S
S#if defined(STM32F412xG) || defined(STM32F413_423xx)
S#define  RCC_DCKCFGR_CKDFSDM1SEL             ((uint32_t)0x80000000)
S#define  RCC_DCKCFGR_CKDFSDM1ASEL            ((uint32_t)0x00008000)
S#endif /* STM32F412xG || STM32F413_423xx */
S
S#if defined(STM32F413_423xx)
S#define  RCC_DCKCFGR_PLLI2SDIVR              ((uint32_t)0x0000001F)
S#define  RCC_DCKCFGR_PLLI2SDIVR_0            ((uint32_t)0x00000001)
S#define  RCC_DCKCFGR_PLLI2SDIVR_1            ((uint32_t)0x00000002)
S#define  RCC_DCKCFGR_PLLI2SDIVR_2            ((uint32_t)0x00000004)
S#define  RCC_DCKCFGR_PLLI2SDIVR_3            ((uint32_t)0x00000008)
S#define  RCC_DCKCFGR_PLLI2SDIVR_4            ((uint32_t)0x00000010)
S
S#define  RCC_DCKCFGR_PLLDIVR                 ((uint32_t)0x00001F00)
S#define  RCC_DCKCFGR_PLLDIVR_0               ((uint32_t)0x00000100)
S#define  RCC_DCKCFGR_PLLDIVR_1               ((uint32_t)0x00000200)
S#define  RCC_DCKCFGR_PLLDIVR_2               ((uint32_t)0x00000400)
S#define  RCC_DCKCFGR_PLLDIVR_3               ((uint32_t)0x00000800)
S#define  RCC_DCKCFGR_PLLDIVR_4               ((uint32_t)0x00001000)
S#define  RCC_DCKCFGR_CKDFSDM2ASEL            ((uint32_t)0x00004000)
S#endif /* STM32F413_423xx */
S
S#define  RCC_DCKCFGR_SAI1ASRC                ((uint32_t)0x00300000)
S#define  RCC_DCKCFGR_SAI1ASRC_0              ((uint32_t)0x00100000)
S#define  RCC_DCKCFGR_SAI1ASRC_1              ((uint32_t)0x00200000)
S#if defined(STM32F446xx)
S#define  RCC_DCKCFGR_SAI1SRC                 ((uint32_t)0x00300000)
S#define  RCC_DCKCFGR_SAI1SRC_0               ((uint32_t)0x00100000)
S#define  RCC_DCKCFGR_SAI1SRC_1               ((uint32_t)0x00200000)
S#endif /* STM32F446xx */
S
S#define  RCC_DCKCFGR_SAI1BSRC                ((uint32_t)0x00C00000)
S#define  RCC_DCKCFGR_SAI1BSRC_0              ((uint32_t)0x00400000)
S#define  RCC_DCKCFGR_SAI1BSRC_1              ((uint32_t)0x00800000)
S#if defined(STM32F446xx)
S#define  RCC_DCKCFGR_SAI2SRC                 ((uint32_t)0x00C00000)
S#define  RCC_DCKCFGR_SAI2SRC_0               ((uint32_t)0x00400000)
S#define  RCC_DCKCFGR_SAI2SRC_1               ((uint32_t)0x00800000)
S#endif /* STM32F446xx */
S
S#define  RCC_DCKCFGR_TIMPRE                  ((uint32_t)0x01000000)
S#if defined(STM32F469_479xx)
S#define  RCC_DCKCFGR_CK48MSEL                ((uint32_t)0x08000000)
S#define  RCC_DCKCFGR_SDIOSEL                 ((uint32_t)0x10000000)
S#define  RCC_DCKCFGR_DSISEL                  ((uint32_t)0x20000000)
S#endif /* STM32F469_479xx */
S
S#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
S#define  RCC_DCKCFGR_I2S1SRC                 ((uint32_t)0x06000000)
S#define  RCC_DCKCFGR_I2S1SRC_0               ((uint32_t)0x02000000)
S#define  RCC_DCKCFGR_I2S1SRC_1               ((uint32_t)0x04000000)
S#define  RCC_DCKCFGR_I2S2SRC                 ((uint32_t)0x18000000)
S#define  RCC_DCKCFGR_I2S2SRC_0               ((uint32_t)0x08000000)
S#define  RCC_DCKCFGR_I2S2SRC_1               ((uint32_t)0x10000000)
S
S/********************  Bit definition for RCC_CKGATENR register  ***************/
S#define  RCC_CKGATENR_AHB2APB1_CKEN          ((uint32_t)0x00000001)
S#define  RCC_CKGATENR_AHB2APB2_CKEN          ((uint32_t)0x00000002)
S#define  RCC_CKGATENR_CM4DBG_CKEN            ((uint32_t)0x00000004)
S#define  RCC_CKGATENR_SPARE_CKEN             ((uint32_t)0x00000008)
S#define  RCC_CKGATENR_SRAM_CKEN              ((uint32_t)0x00000010)
S#define  RCC_CKGATENR_FLITF_CKEN             ((uint32_t)0x00000020)
S#define  RCC_CKGATENR_RCC_CKEN               ((uint32_t)0x00000040)
S#if defined(STM32F412xG) || defined(STM32F413_423xx)
S#define  RCC_CKGATENR_RCC_EVTCTL             ((uint32_t)0x00000080)
S#endif /* STM32F412xG || STM32F413_423xx */
S
S/********************  Bit definition for RCC_DCKCFGR2 register  ***************/
S#define  RCC_DCKCFGR2_FMPI2C1SEL             ((uint32_t)0x00C00000)
S#define  RCC_DCKCFGR2_FMPI2C1SEL_0           ((uint32_t)0x00400000)
S#define  RCC_DCKCFGR2_FMPI2C1SEL_1           ((uint32_t)0x00800000)
S#define  RCC_DCKCFGR2_CECSEL                 ((uint32_t)0x04000000)
S#define  RCC_DCKCFGR2_CK48MSEL               ((uint32_t)0x08000000)
S#define  RCC_DCKCFGR2_SDIOSEL                ((uint32_t)0x10000000)
S#if defined(STM32F446xx)
S#define  RCC_DCKCFGR2_SPDIFRXSEL             ((uint32_t)0x20000000)
S#endif /* STM32F446xx */
S#if defined(STM32F413_423xx)
S#define  RCC_DCKCFGR2_LPTIM1SEL              ((uint32_t)0xC0000000)
S#define  RCC_DCKCFGR2_LPTIM1SEL_0            ((uint32_t)0x40000000)
S#define  RCC_DCKCFGR2_LPTIM1SEL_1            ((uint32_t)0x80000000)
S#endif /* STM32F413_423xx */
S#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx */
S
S#if defined(STM32F410xx)
S#define  RCC_DCKCFGR_I2SSRC                  ((uint32_t)0x06000000)
S#define  RCC_DCKCFGR_I2SSRC_0                ((uint32_t)0x02000000)
S#define  RCC_DCKCFGR_I2SSRC_1                ((uint32_t)0x04000000)
S#endif /* STM32F410xx */
S
S#if defined(STM32F410xx)
S/********************  Bit definition for RCC_DCKCFGR2 register  **************/
S#define  RCC_DCKCFGR2_FMPI2C1SEL             ((uint32_t)0x00C00000)
S#define  RCC_DCKCFGR2_FMPI2C1SEL_0           ((uint32_t)0x00400000)
S#define  RCC_DCKCFGR2_FMPI2C1SEL_1           ((uint32_t)0x00800000)
S#define  RCC_DCKCFGR2_LPTIM1SEL              ((uint32_t)0xC0000000)
S#define  RCC_DCKCFGR2_LPTIM1SEL_0            ((uint32_t)0x40000000)
S#define  RCC_DCKCFGR2_LPTIM1SEL_1            ((uint32_t)0x80000000)
S#endif /* STM32F410xx */
S/******************************************************************************/
S/*                                                                            */
S/*                                    RNG                                     */
S/*                                                                            */
S/******************************************************************************/
S/********************  Bits definition for RNG_CR register  *******************/
S#define RNG_CR_RNGEN                         ((uint32_t)0x00000004)
S#define RNG_CR_IE                            ((uint32_t)0x00000008)
S
S/********************  Bits definition for RNG_SR register  *******************/
S#define RNG_SR_DRDY                          ((uint32_t)0x00000001)
S#define RNG_SR_CECS                          ((uint32_t)0x00000002)
S#define RNG_SR_SECS                          ((uint32_t)0x00000004)
S#define RNG_SR_CEIS                          ((uint32_t)0x00000020)
S#define RNG_SR_SEIS                          ((uint32_t)0x00000040)
S
S/******************************************************************************/
S/*                                                                            */
S/*                           Real-Time Clock (RTC)                            */
S/*                                                                            */
S/******************************************************************************/
S/********************  Bits definition for RTC_TR register  *******************/
S#define RTC_TR_PM                            ((uint32_t)0x00400000)
S#define RTC_TR_HT                            ((uint32_t)0x00300000)
S#define RTC_TR_HT_0                          ((uint32_t)0x00100000)
S#define RTC_TR_HT_1                          ((uint32_t)0x00200000)
S#define RTC_TR_HU                            ((uint32_t)0x000F0000)
S#define RTC_TR_HU_0                          ((uint32_t)0x00010000)
S#define RTC_TR_HU_1                          ((uint32_t)0x00020000)
S#define RTC_TR_HU_2                          ((uint32_t)0x00040000)
S#define RTC_TR_HU_3                          ((uint32_t)0x00080000)
S#define RTC_TR_MNT                           ((uint32_t)0x00007000)
S#define RTC_TR_MNT_0                         ((uint32_t)0x00001000)
S#define RTC_TR_MNT_1                         ((uint32_t)0x00002000)
S#define RTC_TR_MNT_2                         ((uint32_t)0x00004000)
S#define RTC_TR_MNU                           ((uint32_t)0x00000F00)
S#define RTC_TR_MNU_0                         ((uint32_t)0x00000100)
S#define RTC_TR_MNU_1                         ((uint32_t)0x00000200)
S#define RTC_TR_MNU_2                         ((uint32_t)0x00000400)
S#define RTC_TR_MNU_3                         ((uint32_t)0x00000800)
S#define RTC_TR_ST                            ((uint32_t)0x00000070)
S#define RTC_TR_ST_0                          ((uint32_t)0x00000010)
S#define RTC_TR_ST_1                          ((uint32_t)0x00000020)
S#define RTC_TR_ST_2                          ((uint32_t)0x00000040)
S#define RTC_TR_SU                            ((uint32_t)0x0000000F)
S#define RTC_TR_SU_0                          ((uint32_t)0x00000001)
S#define RTC_TR_SU_1                          ((uint32_t)0x00000002)
S#define RTC_TR_SU_2                          ((uint32_t)0x00000004)
S#define RTC_TR_SU_3                          ((uint32_t)0x00000008)
S
S/********************  Bits definition for RTC_DR register  *******************/
S#define RTC_DR_YT                            ((uint32_t)0x00F00000)
S#define RTC_DR_YT_0                          ((uint32_t)0x00100000)
S#define RTC_DR_YT_1                          ((uint32_t)0x00200000)
S#define RTC_DR_YT_2                          ((uint32_t)0x00400000)
S#define RTC_DR_YT_3                          ((uint32_t)0x00800000)
S#define RTC_DR_YU                            ((uint32_t)0x000F0000)
S#define RTC_DR_YU_0                          ((uint32_t)0x00010000)
S#define RTC_DR_YU_1                          ((uint32_t)0x00020000)
S#define RTC_DR_YU_2                          ((uint32_t)0x00040000)
S#define RTC_DR_YU_3                          ((uint32_t)0x00080000)
S#define RTC_DR_WDU                           ((uint32_t)0x0000E000)
S#define RTC_DR_WDU_0                         ((uint32_t)0x00002000)
S#define RTC_DR_WDU_1                         ((uint32_t)0x00004000)
S#define RTC_DR_WDU_2                         ((uint32_t)0x00008000)
S#define RTC_DR_MT                            ((uint32_t)0x00001000)
S#define RTC_DR_MU                            ((uint32_t)0x00000F00)
S#define RTC_DR_MU_0                          ((uint32_t)0x00000100)
S#define RTC_DR_MU_1                          ((uint32_t)0x00000200)
S#define RTC_DR_MU_2                          ((uint32_t)0x00000400)
S#define RTC_DR_MU_3                          ((uint32_t)0x00000800)
S#define RTC_DR_DT                            ((uint32_t)0x00000030)
S#define RTC_DR_DT_0                          ((uint32_t)0x00000010)
S#define RTC_DR_DT_1                          ((uint32_t)0x00000020)
S#define RTC_DR_DU                            ((uint32_t)0x0000000F)
S#define RTC_DR_DU_0                          ((uint32_t)0x00000001)
S#define RTC_DR_DU_1                          ((uint32_t)0x00000002)
S#define RTC_DR_DU_2                          ((uint32_t)0x00000004)
S#define RTC_DR_DU_3                          ((uint32_t)0x00000008)
S
S/********************  Bits definition for RTC_CR register  *******************/
S#define RTC_CR_COE                           ((uint32_t)0x00800000)
S#define RTC_CR_OSEL                          ((uint32_t)0x00600000)
S#define RTC_CR_OSEL_0                        ((uint32_t)0x00200000)
S#define RTC_CR_OSEL_1                        ((uint32_t)0x00400000)
S#define RTC_CR_POL                           ((uint32_t)0x00100000)
S#define RTC_CR_COSEL                         ((uint32_t)0x00080000)
S#define RTC_CR_BCK                           ((uint32_t)0x00040000)
S#define RTC_CR_SUB1H                         ((uint32_t)0x00020000)
S#define RTC_CR_ADD1H                         ((uint32_t)0x00010000)
S#define RTC_CR_TSIE                          ((uint32_t)0x00008000)
S#define RTC_CR_WUTIE                         ((uint32_t)0x00004000)
S#define RTC_CR_ALRBIE                        ((uint32_t)0x00002000)
S#define RTC_CR_ALRAIE                        ((uint32_t)0x00001000)
S#define RTC_CR_TSE                           ((uint32_t)0x00000800)
S#define RTC_CR_WUTE                          ((uint32_t)0x00000400)
S#define RTC_CR_ALRBE                         ((uint32_t)0x00000200)
S#define RTC_CR_ALRAE                         ((uint32_t)0x00000100)
S#define RTC_CR_DCE                           ((uint32_t)0x00000080)
S#define RTC_CR_FMT                           ((uint32_t)0x00000040)
S#define RTC_CR_BYPSHAD                       ((uint32_t)0x00000020)
S#define RTC_CR_REFCKON                       ((uint32_t)0x00000010)
S#define RTC_CR_TSEDGE                        ((uint32_t)0x00000008)
S#define RTC_CR_WUCKSEL                       ((uint32_t)0x00000007)
S#define RTC_CR_WUCKSEL_0                     ((uint32_t)0x00000001)
S#define RTC_CR_WUCKSEL_1                     ((uint32_t)0x00000002)
S#define RTC_CR_WUCKSEL_2                     ((uint32_t)0x00000004)
S
S/********************  Bits definition for RTC_ISR register  ******************/
S#define RTC_ISR_RECALPF                      ((uint32_t)0x00010000)
S#define RTC_ISR_TAMP1F                       ((uint32_t)0x00002000)
S#define RTC_ISR_TAMP2F                       ((uint32_t)0x00004000)
S#define RTC_ISR_TSOVF                        ((uint32_t)0x00001000)
S#define RTC_ISR_TSF                          ((uint32_t)0x00000800)
S#define RTC_ISR_WUTF                         ((uint32_t)0x00000400)
S#define RTC_ISR_ALRBF                        ((uint32_t)0x00000200)
S#define RTC_ISR_ALRAF                        ((uint32_t)0x00000100)
S#define RTC_ISR_INIT                         ((uint32_t)0x00000080)
S#define RTC_ISR_INITF                        ((uint32_t)0x00000040)
S#define RTC_ISR_RSF                          ((uint32_t)0x00000020)
S#define RTC_ISR_INITS                        ((uint32_t)0x00000010)
S#define RTC_ISR_SHPF                         ((uint32_t)0x00000008)
S#define RTC_ISR_WUTWF                        ((uint32_t)0x00000004)
S#define RTC_ISR_ALRBWF                       ((uint32_t)0x00000002)
S#define RTC_ISR_ALRAWF                       ((uint32_t)0x00000001)
S
S/********************  Bits definition for RTC_PRER register  *****************/
S#define RTC_PRER_PREDIV_A                    ((uint32_t)0x007F0000)
S#define RTC_PRER_PREDIV_S                    ((uint32_t)0x00001FFF)
S
S/********************  Bits definition for RTC_WUTR register  *****************/
S#define RTC_WUTR_WUT                         ((uint32_t)0x0000FFFF)
S
S/********************  Bits definition for RTC_CALIBR register  ***************/
S#define RTC_CALIBR_DCS                       ((uint32_t)0x00000080)
S#define RTC_CALIBR_DC                        ((uint32_t)0x0000001F)
S
S/********************  Bits definition for RTC_ALRMAR register  ***************/
S#define RTC_ALRMAR_MSK4                      ((uint32_t)0x80000000)
S#define RTC_ALRMAR_WDSEL                     ((uint32_t)0x40000000)
S#define RTC_ALRMAR_DT                        ((uint32_t)0x30000000)
S#define RTC_ALRMAR_DT_0                      ((uint32_t)0x10000000)
S#define RTC_ALRMAR_DT_1                      ((uint32_t)0x20000000)
S#define RTC_ALRMAR_DU                        ((uint32_t)0x0F000000)
S#define RTC_ALRMAR_DU_0                      ((uint32_t)0x01000000)
S#define RTC_ALRMAR_DU_1                      ((uint32_t)0x02000000)
S#define RTC_ALRMAR_DU_2                      ((uint32_t)0x04000000)
S#define RTC_ALRMAR_DU_3                      ((uint32_t)0x08000000)
S#define RTC_ALRMAR_MSK3                      ((uint32_t)0x00800000)
S#define RTC_ALRMAR_PM                        ((uint32_t)0x00400000)
S#define RTC_ALRMAR_HT                        ((uint32_t)0x00300000)
S#define RTC_ALRMAR_HT_0                      ((uint32_t)0x00100000)
S#define RTC_ALRMAR_HT_1                      ((uint32_t)0x00200000)
S#define RTC_ALRMAR_HU                        ((uint32_t)0x000F0000)
S#define RTC_ALRMAR_HU_0                      ((uint32_t)0x00010000)
S#define RTC_ALRMAR_HU_1                      ((uint32_t)0x00020000)
S#define RTC_ALRMAR_HU_2                      ((uint32_t)0x00040000)
S#define RTC_ALRMAR_HU_3                      ((uint32_t)0x00080000)
S#define RTC_ALRMAR_MSK2                      ((uint32_t)0x00008000)
S#define RTC_ALRMAR_MNT                       ((uint32_t)0x00007000)
S#define RTC_ALRMAR_MNT_0                     ((uint32_t)0x00001000)
S#define RTC_ALRMAR_MNT_1                     ((uint32_t)0x00002000)
S#define RTC_ALRMAR_MNT_2                     ((uint32_t)0x00004000)
S#define RTC_ALRMAR_MNU                       ((uint32_t)0x00000F00)
S#define RTC_ALRMAR_MNU_0                     ((uint32_t)0x00000100)
S#define RTC_ALRMAR_MNU_1                     ((uint32_t)0x00000200)
S#define RTC_ALRMAR_MNU_2                     ((uint32_t)0x00000400)
S#define RTC_ALRMAR_MNU_3                     ((uint32_t)0x00000800)
S#define RTC_ALRMAR_MSK1                      ((uint32_t)0x00000080)
S#define RTC_ALRMAR_ST                        ((uint32_t)0x00000070)
S#define RTC_ALRMAR_ST_0                      ((uint32_t)0x00000010)
S#define RTC_ALRMAR_ST_1                      ((uint32_t)0x00000020)
S#define RTC_ALRMAR_ST_2                      ((uint32_t)0x00000040)
S#define RTC_ALRMAR_SU                        ((uint32_t)0x0000000F)
S#define RTC_ALRMAR_SU_0                      ((uint32_t)0x00000001)
S#define RTC_ALRMAR_SU_1                      ((uint32_t)0x00000002)
S#define RTC_ALRMAR_SU_2                      ((uint32_t)0x00000004)
S#define RTC_ALRMAR_SU_3                      ((uint32_t)0x00000008)
S
S/********************  Bits definition for RTC_ALRMBR register  ***************/
S#define RTC_ALRMBR_MSK4                      ((uint32_t)0x80000000)
S#define RTC_ALRMBR_WDSEL                     ((uint32_t)0x40000000)
S#define RTC_ALRMBR_DT                        ((uint32_t)0x30000000)
S#define RTC_ALRMBR_DT_0                      ((uint32_t)0x10000000)
S#define RTC_ALRMBR_DT_1                      ((uint32_t)0x20000000)
S#define RTC_ALRMBR_DU                        ((uint32_t)0x0F000000)
S#define RTC_ALRMBR_DU_0                      ((uint32_t)0x01000000)
S#define RTC_ALRMBR_DU_1                      ((uint32_t)0x02000000)
S#define RTC_ALRMBR_DU_2                      ((uint32_t)0x04000000)
S#define RTC_ALRMBR_DU_3                      ((uint32_t)0x08000000)
S#define RTC_ALRMBR_MSK3                      ((uint32_t)0x00800000)
S#define RTC_ALRMBR_PM                        ((uint32_t)0x00400000)
S#define RTC_ALRMBR_HT                        ((uint32_t)0x00300000)
S#define RTC_ALRMBR_HT_0                      ((uint32_t)0x00100000)
S#define RTC_ALRMBR_HT_1                      ((uint32_t)0x00200000)
S#define RTC_ALRMBR_HU                        ((uint32_t)0x000F0000)
S#define RTC_ALRMBR_HU_0                      ((uint32_t)0x00010000)
S#define RTC_ALRMBR_HU_1                      ((uint32_t)0x00020000)
S#define RTC_ALRMBR_HU_2                      ((uint32_t)0x00040000)
S#define RTC_ALRMBR_HU_3                      ((uint32_t)0x00080000)
S#define RTC_ALRMBR_MSK2                      ((uint32_t)0x00008000)
S#define RTC_ALRMBR_MNT                       ((uint32_t)0x00007000)
S#define RTC_ALRMBR_MNT_0                     ((uint32_t)0x00001000)
S#define RTC_ALRMBR_MNT_1                     ((uint32_t)0x00002000)
S#define RTC_ALRMBR_MNT_2                     ((uint32_t)0x00004000)
S#define RTC_ALRMBR_MNU                       ((uint32_t)0x00000F00)
S#define RTC_ALRMBR_MNU_0                     ((uint32_t)0x00000100)
S#define RTC_ALRMBR_MNU_1                     ((uint32_t)0x00000200)
S#define RTC_ALRMBR_MNU_2                     ((uint32_t)0x00000400)
S#define RTC_ALRMBR_MNU_3                     ((uint32_t)0x00000800)
S#define RTC_ALRMBR_MSK1                      ((uint32_t)0x00000080)
S#define RTC_ALRMBR_ST                        ((uint32_t)0x00000070)
S#define RTC_ALRMBR_ST_0                      ((uint32_t)0x00000010)
S#define RTC_ALRMBR_ST_1                      ((uint32_t)0x00000020)
S#define RTC_ALRMBR_ST_2                      ((uint32_t)0x00000040)
S#define RTC_ALRMBR_SU                        ((uint32_t)0x0000000F)
S#define RTC_ALRMBR_SU_0                      ((uint32_t)0x00000001)
S#define RTC_ALRMBR_SU_1                      ((uint32_t)0x00000002)
S#define RTC_ALRMBR_SU_2                      ((uint32_t)0x00000004)
S#define RTC_ALRMBR_SU_3                      ((uint32_t)0x00000008)
S
S/********************  Bits definition for RTC_WPR register  ******************/
S#define RTC_WPR_KEY                          ((uint32_t)0x000000FF)
S
S/********************  Bits definition for RTC_SSR register  ******************/
S#define RTC_SSR_SS                           ((uint32_t)0x0000FFFF)
S
S/********************  Bits definition for RTC_SHIFTR register  ***************/
S#define RTC_SHIFTR_SUBFS                     ((uint32_t)0x00007FFF)
S#define RTC_SHIFTR_ADD1S                     ((uint32_t)0x80000000)
S
S/********************  Bits definition for RTC_TSTR register  *****************/
S#define RTC_TSTR_PM                          ((uint32_t)0x00400000)
S#define RTC_TSTR_HT                          ((uint32_t)0x00300000)
S#define RTC_TSTR_HT_0                        ((uint32_t)0x00100000)
S#define RTC_TSTR_HT_1                        ((uint32_t)0x00200000)
S#define RTC_TSTR_HU                          ((uint32_t)0x000F0000)
S#define RTC_TSTR_HU_0                        ((uint32_t)0x00010000)
S#define RTC_TSTR_HU_1                        ((uint32_t)0x00020000)
S#define RTC_TSTR_HU_2                        ((uint32_t)0x00040000)
S#define RTC_TSTR_HU_3                        ((uint32_t)0x00080000)
S#define RTC_TSTR_MNT                         ((uint32_t)0x00007000)
S#define RTC_TSTR_MNT_0                       ((uint32_t)0x00001000)
S#define RTC_TSTR_MNT_1                       ((uint32_t)0x00002000)
S#define RTC_TSTR_MNT_2                       ((uint32_t)0x00004000)
S#define RTC_TSTR_MNU                         ((uint32_t)0x00000F00)
S#define RTC_TSTR_MNU_0                       ((uint32_t)0x00000100)
S#define RTC_TSTR_MNU_1                       ((uint32_t)0x00000200)
S#define RTC_TSTR_MNU_2                       ((uint32_t)0x00000400)
S#define RTC_TSTR_MNU_3                       ((uint32_t)0x00000800)
S#define RTC_TSTR_ST                          ((uint32_t)0x00000070)
S#define RTC_TSTR_ST_0                        ((uint32_t)0x00000010)
S#define RTC_TSTR_ST_1                        ((uint32_t)0x00000020)
S#define RTC_TSTR_ST_2                        ((uint32_t)0x00000040)
S#define RTC_TSTR_SU                          ((uint32_t)0x0000000F)
S#define RTC_TSTR_SU_0                        ((uint32_t)0x00000001)
S#define RTC_TSTR_SU_1                        ((uint32_t)0x00000002)
S#define RTC_TSTR_SU_2                        ((uint32_t)0x00000004)
S#define RTC_TSTR_SU_3                        ((uint32_t)0x00000008)
S
S/********************  Bits definition for RTC_TSDR register  *****************/
S#define RTC_TSDR_WDU                         ((uint32_t)0x0000E000)
S#define RTC_TSDR_WDU_0                       ((uint32_t)0x00002000)
S#define RTC_TSDR_WDU_1                       ((uint32_t)0x00004000)
S#define RTC_TSDR_WDU_2                       ((uint32_t)0x00008000)
S#define RTC_TSDR_MT                          ((uint32_t)0x00001000)
S#define RTC_TSDR_MU                          ((uint32_t)0x00000F00)
S#define RTC_TSDR_MU_0                        ((uint32_t)0x00000100)
S#define RTC_TSDR_MU_1                        ((uint32_t)0x00000200)
S#define RTC_TSDR_MU_2                        ((uint32_t)0x00000400)
S#define RTC_TSDR_MU_3                        ((uint32_t)0x00000800)
S#define RTC_TSDR_DT                          ((uint32_t)0x00000030)
S#define RTC_TSDR_DT_0                        ((uint32_t)0x00000010)
S#define RTC_TSDR_DT_1                        ((uint32_t)0x00000020)
S#define RTC_TSDR_DU                          ((uint32_t)0x0000000F)
S#define RTC_TSDR_DU_0                        ((uint32_t)0x00000001)
S#define RTC_TSDR_DU_1                        ((uint32_t)0x00000002)
S#define RTC_TSDR_DU_2                        ((uint32_t)0x00000004)
S#define RTC_TSDR_DU_3                        ((uint32_t)0x00000008)
S
S/********************  Bits definition for RTC_TSSSR register  ****************/
S#define RTC_TSSSR_SS                         ((uint32_t)0x0000FFFF)
S
S/********************  Bits definition for RTC_CAL register  *****************/
S#define RTC_CALR_CALP                        ((uint32_t)0x00008000)
S#define RTC_CALR_CALW8                       ((uint32_t)0x00004000)
S#define RTC_CALR_CALW16                      ((uint32_t)0x00002000)
S#define RTC_CALR_CALM                        ((uint32_t)0x000001FF)
S#define RTC_CALR_CALM_0                      ((uint32_t)0x00000001)
S#define RTC_CALR_CALM_1                      ((uint32_t)0x00000002)
S#define RTC_CALR_CALM_2                      ((uint32_t)0x00000004)
S#define RTC_CALR_CALM_3                      ((uint32_t)0x00000008)
S#define RTC_CALR_CALM_4                      ((uint32_t)0x00000010)
S#define RTC_CALR_CALM_5                      ((uint32_t)0x00000020)
S#define RTC_CALR_CALM_6                      ((uint32_t)0x00000040)
S#define RTC_CALR_CALM_7                      ((uint32_t)0x00000080)
S#define RTC_CALR_CALM_8                      ((uint32_t)0x00000100)
S
S/********************  Bits definition for RTC_TAFCR register  ****************/
S#define RTC_TAFCR_ALARMOUTTYPE               ((uint32_t)0x00040000)
S#define RTC_TAFCR_TSINSEL                    ((uint32_t)0x00020000)
S#define RTC_TAFCR_TAMPINSEL                  ((uint32_t)0x00010000)
S#define RTC_TAFCR_TAMPPUDIS                  ((uint32_t)0x00008000)
S#define RTC_TAFCR_TAMPPRCH                   ((uint32_t)0x00006000)
S#define RTC_TAFCR_TAMPPRCH_0                 ((uint32_t)0x00002000)
S#define RTC_TAFCR_TAMPPRCH_1                 ((uint32_t)0x00004000)
S#define RTC_TAFCR_TAMPFLT                    ((uint32_t)0x00001800)
S#define RTC_TAFCR_TAMPFLT_0                  ((uint32_t)0x00000800)
S#define RTC_TAFCR_TAMPFLT_1                  ((uint32_t)0x00001000)
S#define RTC_TAFCR_TAMPFREQ                   ((uint32_t)0x00000700)
S#define RTC_TAFCR_TAMPFREQ_0                 ((uint32_t)0x00000100)
S#define RTC_TAFCR_TAMPFREQ_1                 ((uint32_t)0x00000200)
S#define RTC_TAFCR_TAMPFREQ_2                 ((uint32_t)0x00000400)
S#define RTC_TAFCR_TAMPTS                     ((uint32_t)0x00000080)
S#define RTC_TAFCR_TAMP2TRG                   ((uint32_t)0x00000010)
S#define RTC_TAFCR_TAMP2E                     ((uint32_t)0x00000008) 
S#define RTC_TAFCR_TAMPIE                     ((uint32_t)0x00000004)
S#define RTC_TAFCR_TAMP1TRG                   ((uint32_t)0x00000002)
S#define RTC_TAFCR_TAMP1E                     ((uint32_t)0x00000001)
S
S/********************  Bits definition for RTC_ALRMASSR register  *************/
S#define RTC_ALRMASSR_MASKSS                  ((uint32_t)0x0F000000)
S#define RTC_ALRMASSR_MASKSS_0                ((uint32_t)0x01000000)
S#define RTC_ALRMASSR_MASKSS_1                ((uint32_t)0x02000000)
S#define RTC_ALRMASSR_MASKSS_2                ((uint32_t)0x04000000)
S#define RTC_ALRMASSR_MASKSS_3                ((uint32_t)0x08000000)
S#define RTC_ALRMASSR_SS                      ((uint32_t)0x00007FFF)
S
S/********************  Bits definition for RTC_ALRMBSSR register  *************/
S#define RTC_ALRMBSSR_MASKSS                  ((uint32_t)0x0F000000)
S#define RTC_ALRMBSSR_MASKSS_0                ((uint32_t)0x01000000)
S#define RTC_ALRMBSSR_MASKSS_1                ((uint32_t)0x02000000)
S#define RTC_ALRMBSSR_MASKSS_2                ((uint32_t)0x04000000)
S#define RTC_ALRMBSSR_MASKSS_3                ((uint32_t)0x08000000)
S#define RTC_ALRMBSSR_SS                      ((uint32_t)0x00007FFF)
S
S/********************  Bits definition for RTC_BKP0R register  ****************/
S#define RTC_BKP0R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP1R register  ****************/
S#define RTC_BKP1R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP2R register  ****************/
S#define RTC_BKP2R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP3R register  ****************/
S#define RTC_BKP3R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP4R register  ****************/
S#define RTC_BKP4R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP5R register  ****************/
S#define RTC_BKP5R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP6R register  ****************/
S#define RTC_BKP6R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP7R register  ****************/
S#define RTC_BKP7R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP8R register  ****************/
S#define RTC_BKP8R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP9R register  ****************/
S#define RTC_BKP9R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP10R register  ***************/
S#define RTC_BKP10R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP11R register  ***************/
S#define RTC_BKP11R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP12R register  ***************/
S#define RTC_BKP12R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP13R register  ***************/
S#define RTC_BKP13R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP14R register  ***************/
S#define RTC_BKP14R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP15R register  ***************/
S#define RTC_BKP15R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP16R register  ***************/
S#define RTC_BKP16R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP17R register  ***************/
S#define RTC_BKP17R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP18R register  ***************/
S#define RTC_BKP18R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP19R register  ***************/
S#define RTC_BKP19R                           ((uint32_t)0xFFFFFFFF)
S
S/******************************************************************************/
S/*                                                                            */
S/*                          Serial Audio Interface                            */
S/*                                                                            */
S/******************************************************************************/
S/********************  Bit definition for SAI_GCR register  *******************/
S#define  SAI_GCR_SYNCIN                  ((uint32_t)0x00000003)        /*!<SYNCIN[1:0] bits (Synchronization Inputs)   */
S#define  SAI_GCR_SYNCIN_0                ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  SAI_GCR_SYNCIN_1                ((uint32_t)0x00000002)        /*!<Bit 1 */
S
S#define  SAI_GCR_SYNCOUT                 ((uint32_t)0x00000030)        /*!<SYNCOUT[1:0] bits (Synchronization Outputs) */
S#define  SAI_GCR_SYNCOUT_0               ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  SAI_GCR_SYNCOUT_1               ((uint32_t)0x00000020)        /*!<Bit 1 */
S
S/*******************  Bit definition for SAI_xCR1 register  *******************/
S#define  SAI_xCR1_MODE                    ((uint32_t)0x00000003)        /*!<MODE[1:0] bits (Audio Block Mode)           */
S#define  SAI_xCR1_MODE_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  SAI_xCR1_MODE_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
S
S#define  SAI_xCR1_PRTCFG                  ((uint32_t)0x0000000C)        /*!<PRTCFG[1:0] bits (Protocol Configuration)   */
S#define  SAI_xCR1_PRTCFG_0                ((uint32_t)0x00000004)        /*!<Bit 0 */
S#define  SAI_xCR1_PRTCFG_1                ((uint32_t)0x00000008)        /*!<Bit 1 */
S
S#define  SAI_xCR1_DS                      ((uint32_t)0x000000E0)        /*!<DS[1:0] bits (Data Size) */
S#define  SAI_xCR1_DS_0                    ((uint32_t)0x00000020)        /*!<Bit 0 */
S#define  SAI_xCR1_DS_1                    ((uint32_t)0x00000040)        /*!<Bit 1 */
S#define  SAI_xCR1_DS_2                    ((uint32_t)0x00000080)        /*!<Bit 2 */
S
S#define  SAI_xCR1_LSBFIRST                ((uint32_t)0x00000100)        /*!<LSB First Configuration  */
S#define  SAI_xCR1_CKSTR                   ((uint32_t)0x00000200)        /*!<ClocK STRobing edge      */
S
S#define  SAI_xCR1_SYNCEN                  ((uint32_t)0x00000C00)        /*!<SYNCEN[1:0](SYNChronization ENable) */
S#define  SAI_xCR1_SYNCEN_0                ((uint32_t)0x00000400)        /*!<Bit 0 */
S#define  SAI_xCR1_SYNCEN_1                ((uint32_t)0x00000800)        /*!<Bit 1 */
S
S#define  SAI_xCR1_MONO                    ((uint32_t)0x00001000)        /*!<Mono mode                  */
S#define  SAI_xCR1_OUTDRIV                 ((uint32_t)0x00002000)        /*!<Output Drive               */
S#define  SAI_xCR1_SAIEN                   ((uint32_t)0x00010000)        /*!<Audio Block enable         */
S#define  SAI_xCR1_DMAEN                   ((uint32_t)0x00020000)        /*!<DMA enable                 */
S#define  SAI_xCR1_NODIV                   ((uint32_t)0x00080000)        /*!<No Divider Configuration   */
S
S#define  SAI_xCR1_MCKDIV                  ((uint32_t)0x00780000)        /*!<MCKDIV[3:0] (Master ClocK Divider)  */
S#define  SAI_xCR1_MCKDIV_0                ((uint32_t)0x00080000)        /*!<Bit 0  */
S#define  SAI_xCR1_MCKDIV_1                ((uint32_t)0x00100000)        /*!<Bit 1  */
S#define  SAI_xCR1_MCKDIV_2                ((uint32_t)0x00200000)        /*!<Bit 2  */
S#define  SAI_xCR1_MCKDIV_3                ((uint32_t)0x00400000)        /*!<Bit 3  */
S
S/*******************  Bit definition for SAI_xCR2 register  *******************/
S#define  SAI_xCR2_FTH                     ((uint32_t)0x00000003)        /*!<FTH[1:0](Fifo THreshold)  */
S#define  SAI_xCR2_FTH_0                   ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  SAI_xCR2_FTH_1                   ((uint32_t)0x00000002)        /*!<Bit 1 */
S
S#define  SAI_xCR2_FFLUSH                  ((uint32_t)0x00000008)        /*!<Fifo FLUSH                       */
S#define  SAI_xCR2_TRIS                    ((uint32_t)0x00000010)        /*!<TRIState Management on data line */
S#define  SAI_xCR2_MUTE                    ((uint32_t)0x00000020)        /*!<Mute mode                        */
S#define  SAI_xCR2_MUTEVAL                 ((uint32_t)0x00000040)        /*!<Muate value                      */
S
S#define  SAI_xCR2_MUTECNT                  ((uint32_t)0x00001F80)       /*!<MUTECNT[5:0] (MUTE counter) */
S#define  SAI_xCR2_MUTECNT_0               ((uint32_t)0x00000080)        /*!<Bit 0 */
S#define  SAI_xCR2_MUTECNT_1               ((uint32_t)0x00000100)        /*!<Bit 1 */
S#define  SAI_xCR2_MUTECNT_2               ((uint32_t)0x00000200)        /*!<Bit 2 */
S#define  SAI_xCR2_MUTECNT_3               ((uint32_t)0x00000400)        /*!<Bit 3 */
S#define  SAI_xCR2_MUTECNT_4               ((uint32_t)0x00000800)        /*!<Bit 4 */
S#define  SAI_xCR2_MUTECNT_5               ((uint32_t)0x00001000)        /*!<Bit 5 */
S
S#define  SAI_xCR2_CPL                     ((uint32_t)0x00002000)        /*!< Complement Bit             */
S
S#define  SAI_xCR2_COMP                    ((uint32_t)0x0000C000)        /*!<COMP[1:0] (Companding mode) */
S#define  SAI_xCR2_COMP_0                  ((uint32_t)0x00004000)        /*!<Bit 0 */
S#define  SAI_xCR2_COMP_1                  ((uint32_t)0x00008000)        /*!<Bit 1 */
S
S/******************  Bit definition for SAI_xFRCR register  *******************/
S#define  SAI_xFRCR_FRL                    ((uint32_t)0x000000FF)        /*!<FRL[1:0](Frame length)  */
S#define  SAI_xFRCR_FRL_0                  ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  SAI_xFRCR_FRL_1                  ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  SAI_xFRCR_FRL_2                  ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  SAI_xFRCR_FRL_3                  ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  SAI_xFRCR_FRL_4                  ((uint32_t)0x00000010)        /*!<Bit 4 */
S#define  SAI_xFRCR_FRL_5                  ((uint32_t)0x00000020)        /*!<Bit 5 */
S#define  SAI_xFRCR_FRL_6                  ((uint32_t)0x00000040)        /*!<Bit 6 */
S#define  SAI_xFRCR_FRL_7                  ((uint32_t)0x00000080)        /*!<Bit 7 */
S
S#define  SAI_xFRCR_FSALL                  ((uint32_t)0x00007F00)        /*!<FRL[1:0] (Frame synchronization active level length)  */
S#define  SAI_xFRCR_FSALL_0                ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  SAI_xFRCR_FSALL_1                ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  SAI_xFRCR_FSALL_2                ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  SAI_xFRCR_FSALL_3                ((uint32_t)0x00000800)        /*!<Bit 3 */
S#define  SAI_xFRCR_FSALL_4                ((uint32_t)0x00001000)        /*!<Bit 4 */
S#define  SAI_xFRCR_FSALL_5                ((uint32_t)0x00002000)        /*!<Bit 5 */
S#define  SAI_xFRCR_FSALL_6                ((uint32_t)0x00004000)        /*!<Bit 6 */
S
S#define  SAI_xFRCR_FSDEF                  ((uint32_t)0x00010000)        /*!< Frame Synchronization Definition */
S#define  SAI_xFRCR_FSPOL                  ((uint32_t)0x00020000)        /*!<Frame Synchronization POLarity    */
S#define  SAI_xFRCR_FSOFF                  ((uint32_t)0x00040000)        /*!<Frame Synchronization OFFset      */
S/* Legacy defines */
S#define  SAI_xFRCR_FSPO                   SAI_xFRCR_FSPOL
S
S/******************  Bit definition for SAI_xSLOTR register  *******************/
S#define  SAI_xSLOTR_FBOFF                 ((uint32_t)0x0000001F)        /*!<FRL[4:0](First Bit Offset)  */
S#define  SAI_xSLOTR_FBOFF_0               ((uint32_t)0x00000001)        /*!<Bit 0 */
S#define  SAI_xSLOTR_FBOFF_1               ((uint32_t)0x00000002)        /*!<Bit 1 */
S#define  SAI_xSLOTR_FBOFF_2               ((uint32_t)0x00000004)        /*!<Bit 2 */
S#define  SAI_xSLOTR_FBOFF_3               ((uint32_t)0x00000008)        /*!<Bit 3 */
S#define  SAI_xSLOTR_FBOFF_4               ((uint32_t)0x00000010)        /*!<Bit 4 */
S                                     
S#define  SAI_xSLOTR_SLOTSZ                ((uint32_t)0x000000C0)        /*!<SLOTSZ[1:0] (Slot size)  */
S#define  SAI_xSLOTR_SLOTSZ_0              ((uint32_t)0x00000040)        /*!<Bit 0 */
S#define  SAI_xSLOTR_SLOTSZ_1              ((uint32_t)0x00000080)        /*!<Bit 1 */
S
S#define  SAI_xSLOTR_NBSLOT                ((uint32_t)0x00000F00)        /*!<NBSLOT[3:0] (Number of Slot in audio Frame)  */
S#define  SAI_xSLOTR_NBSLOT_0              ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  SAI_xSLOTR_NBSLOT_1              ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  SAI_xSLOTR_NBSLOT_2              ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  SAI_xSLOTR_NBSLOT_3              ((uint32_t)0x00000800)        /*!<Bit 3 */
S
S#define  SAI_xSLOTR_SLOTEN                ((uint32_t)0xFFFF0000)        /*!<SLOTEN[15:0] (Slot Enable)  */
S
S/*******************  Bit definition for SAI_xIMR register  *******************/
S#define  SAI_xIMR_OVRUDRIE                ((uint32_t)0x00000001)        /*!<Overrun underrun interrupt enable                              */
S#define  SAI_xIMR_MUTEDETIE               ((uint32_t)0x00000002)        /*!<Mute detection interrupt enable                                */
S#define  SAI_xIMR_WCKCFGIE                ((uint32_t)0x00000004)        /*!<Wrong Clock Configuration interrupt enable                     */
S#define  SAI_xIMR_FREQIE                  ((uint32_t)0x00000008)        /*!<FIFO request interrupt enable                                  */
S#define  SAI_xIMR_CNRDYIE                 ((uint32_t)0x00000010)        /*!<Codec not ready interrupt enable                               */
S#define  SAI_xIMR_AFSDETIE                ((uint32_t)0x00000020)        /*!<Anticipated frame synchronization detection interrupt enable   */
S#define  SAI_xIMR_LFSDETIE                ((uint32_t)0x00000040)        /*!<Late frame synchronization detection interrupt enable          */
S
S/********************  Bit definition for SAI_xSR register  *******************/
S#define  SAI_xSR_OVRUDR                   ((uint32_t)0x00000001)         /*!<Overrun underrun                               */
S#define  SAI_xSR_MUTEDET                  ((uint32_t)0x00000002)         /*!<Mute detection                                 */
S#define  SAI_xSR_WCKCFG                   ((uint32_t)0x00000004)         /*!<Wrong Clock Configuration                      */
S#define  SAI_xSR_FREQ                     ((uint32_t)0x00000008)         /*!<FIFO request                                   */
S#define  SAI_xSR_CNRDY                    ((uint32_t)0x00000010)         /*!<Codec not ready                                */
S#define  SAI_xSR_AFSDET                   ((uint32_t)0x00000020)         /*!<Anticipated frame synchronization detection    */
S#define  SAI_xSR_LFSDET                   ((uint32_t)0x00000040)         /*!<Late frame synchronization detection           */
S
S#define  SAI_xSR_FLVL                     ((uint32_t)0x00070000)         /*!<FLVL[2:0] (FIFO Level Threshold)               */
S#define  SAI_xSR_FLVL_0                   ((uint32_t)0x00010000)         /*!<Bit 0 */
S#define  SAI_xSR_FLVL_1                   ((uint32_t)0x00020000)         /*!<Bit 1 */
S#define  SAI_xSR_FLVL_2                   ((uint32_t)0x00030000)         /*!<Bit 2 */
S
S/******************  Bit definition for SAI_xCLRFR register  ******************/
S#define  SAI_xCLRFR_COVRUDR               ((uint32_t)0x00000001)        /*!<Clear Overrun underrun                               */
S#define  SAI_xCLRFR_CMUTEDET              ((uint32_t)0x00000002)        /*!<Clear Mute detection                                 */
S#define  SAI_xCLRFR_CWCKCFG               ((uint32_t)0x00000004)        /*!<Clear Wrong Clock Configuration                      */
S#define  SAI_xCLRFR_CFREQ                 ((uint32_t)0x00000008)        /*!<Clear FIFO request                                   */
S#define  SAI_xCLRFR_CCNRDY                ((uint32_t)0x00000010)        /*!<Clear Codec not ready                                */
S#define  SAI_xCLRFR_CAFSDET               ((uint32_t)0x00000020)        /*!<Clear Anticipated frame synchronization detection    */
S#define  SAI_xCLRFR_CLFSDET               ((uint32_t)0x00000040)        /*!<Clear Late frame synchronization detection           */
S
S/******************  Bit definition for SAI_xDR register  ******************/
S#define  SAI_xDR_DATA                     ((uint32_t)0xFFFFFFFF)        
S
S#if defined(STM32F446xx)
S/******************************************************************************/
S/*                                                                            */
S/*                              SPDIF-RX Interface                            */
S/*                                                                            */
S/******************************************************************************/
S/********************  Bit definition for SPDIFRX_CR register  *******************/
S#define  SPDIFRX_CR_SPDIFEN                  ((uint32_t)0x00000003)        /*!<Peripheral Block Enable                      */
S#define  SPDIFRX_CR_RXDMAEN                  ((uint32_t)0x00000004)        /*!<Receiver DMA Enable for data flow            */
S#define  SPDIFRX_CR_RXSTEO                   ((uint32_t)0x00000008)        /*!<Stereo Mode                                  */
S#define  SPDIFRX_CR_DRFMT                    ((uint32_t)0x00000030)        /*!<RX Data format                               */
S#define  SPDIFRX_CR_PMSK                     ((uint32_t)0x00000040)        /*!<Mask Parity error bit                        */
S#define  SPDIFRX_CR_VMSK                     ((uint32_t)0x00000080)        /*!<Mask of Validity bit                         */
S#define  SPDIFRX_CR_CUMSK                    ((uint32_t)0x00000100)        /*!<Mask of channel status and user bits         */
S#define  SPDIFRX_CR_PTMSK                    ((uint32_t)0x00000200)        /*!<Mask of Preamble Type bits                   */
S#define  SPDIFRX_CR_CBDMAEN                  ((uint32_t)0x00000400)        /*!<Control Buffer DMA ENable for control flow   */
S#define  SPDIFRX_CR_CHSEL                    ((uint32_t)0x00000800)        /*!<Channel Selection                            */
S#define  SPDIFRX_CR_NBTR                     ((uint32_t)0x00003000)        /*!<Maximum allowed re-tries during synchronization phase */
S#define  SPDIFRX_CR_WFA                      ((uint32_t)0x00004000)        /*!<Wait For Activity     */
S#define  SPDIFRX_CR_INSEL                    ((uint32_t)0x00070000)        /*!<SPDIFRX input selection */
S
S/*******************  Bit definition for SPDIFRX_IMR register  *******************/
S#define  SPDIFRX_IMR_RXNEIE                   ((uint32_t)0x00000001)        /*!<RXNE interrupt enable                              */
S#define  SPDIFRX_IMR_CSRNEIE                  ((uint32_t)0x00000002)        /*!<Control Buffer Ready Interrupt Enable              */
S#define  SPDIFRX_IMR_PERRIE                   ((uint32_t)0x00000004)        /*!<Parity error interrupt enable                      */
S#define  SPDIFRX_IMR_OVRIE                    ((uint32_t)0x00000008)        /*!<Overrun error Interrupt Enable                     */
S#define  SPDIFRX_IMR_SBLKIE                   ((uint32_t)0x00000010)        /*!<Synchronization Block Detected Interrupt Enable    */
S#define  SPDIFRX_IMR_SYNCDIE                  ((uint32_t)0x00000020)        /*!<Synchronization Done                               */
S#define  SPDIFRX_IMR_IFEIE                    ((uint32_t)0x00000040)        /*!<Serial Interface Error Interrupt Enable            */
S
S/*******************  Bit definition for SPDIFRX_SR register  *******************/
S#define  SPDIFRX_SR_RXNE                   ((uint32_t)0x00000001)       /*!<Read data register not empty                          */
S#define  SPDIFRX_SR_CSRNE                  ((uint32_t)0x00000002)       /*!<The Control Buffer register is not empty              */
S#define  SPDIFRX_SR_PERR                   ((uint32_t)0x00000004)       /*!<Parity error                                          */
S#define  SPDIFRX_SR_OVR                    ((uint32_t)0x00000008)       /*!<Overrun error                                         */
S#define  SPDIFRX_SR_SBD                    ((uint32_t)0x00000010)       /*!<Synchronization Block Detected                        */
S#define  SPDIFRX_SR_SYNCD                  ((uint32_t)0x00000020)       /*!<Synchronization Done                                  */
S#define  SPDIFRX_SR_FERR                   ((uint32_t)0x00000040)       /*!<Framing error                                         */
S#define  SPDIFRX_SR_SERR                   ((uint32_t)0x00000080)       /*!<Synchronization error                                 */
S#define  SPDIFRX_SR_TERR                   ((uint32_t)0x00000100)       /*!<Time-out error                                        */
S#define  SPDIFRX_SR_WIDTH5                 ((uint32_t)0x7FFF0000)       /*!<Duration of 5 symbols counted with SPDIFRX_clk        */
S
S/*******************  Bit definition for SPDIFRX_IFCR register  *******************/
S#define  SPDIFRX_IFCR_PERRCF               ((uint32_t)0x00000004)       /*!<Clears the Parity error flag                         */
S#define  SPDIFRX_IFCR_OVRCF                ((uint32_t)0x00000008)       /*!<Clears the Overrun error flag                        */
S#define  SPDIFRX_IFCR_SBDCF                ((uint32_t)0x00000010)       /*!<Clears the Synchronization Block Detected flag       */
S#define  SPDIFRX_IFCR_SYNCDCF              ((uint32_t)0x00000020)       /*!<Clears the Synchronization Done flag                 */
S
S/*******************  Bit definition for SPDIFRX_DR register  (DRFMT = 0b00 case) *******************/
S#define  SPDIFRX_DR0_DR                    ((uint32_t)0x00FFFFFF)        /*!<Data value            */
S#define  SPDIFRX_DR0_PE                    ((uint32_t)0x01000000)        /*!<Parity Error bit      */
S#define  SPDIFRX_DR0_V                     ((uint32_t)0x02000000)        /*!<Validity bit          */
S#define  SPDIFRX_DR0_U                     ((uint32_t)0x04000000)        /*!<User bit              */
S#define  SPDIFRX_DR0_C                     ((uint32_t)0x08000000)        /*!<Channel Status bit    */
S#define  SPDIFRX_DR0_PT                    ((uint32_t)0x30000000)        /*!<Preamble Type         */
S
S/*******************  Bit definition for SPDIFRX_DR register  (DRFMT = 0b01 case) *******************/
S#define  SPDIFRX_DR1_DR                    ((uint32_t)0xFFFFFF00)        /*!<Data value            */
S#define  SPDIFRX_DR1_PT                    ((uint32_t)0x00000030)        /*!<Preamble Type         */
S#define  SPDIFRX_DR1_C                     ((uint32_t)0x00000008)        /*!<Channel Status bit    */
S#define  SPDIFRX_DR1_U                     ((uint32_t)0x00000004)        /*!<User bit              */
S#define  SPDIFRX_DR1_V                     ((uint32_t)0x00000002)        /*!<Validity bit          */
S#define  SPDIFRX_DR1_PE                    ((uint32_t)0x00000001)        /*!<Parity Error bit      */
S
S/*******************  Bit definition for SPDIFRX_DR register  (DRFMT = 0b10 case) *******************/
S#define  SPDIFRX_DR1_DRNL1                 ((uint32_t)0xFFFF0000)        /*!<Data value Channel B      */
S#define  SPDIFRX_DR1_DRNL2                 ((uint32_t)0x0000FFFF)        /*!<Data value Channel A      */
S
S/*******************  Bit definition for SPDIFRX_CSR register   *******************/
S#define  SPDIFRX_CSR_USR                     ((uint32_t)0x0000FFFF)        /*!<User data information           */
S#define  SPDIFRX_CSR_CS                      ((uint32_t)0x00FF0000)        /*!<Channel A status information    */
S#define  SPDIFRX_CSR_SOB                     ((uint32_t)0x01000000)        /*!<Start Of Block                  */
S
S/*******************  Bit definition for SPDIFRX_DIR register    *******************/
S#define  SPDIFRX_DIR_THI                 ((uint32_t)0x000013FF)        /*!<Threshold LOW      */
S#define  SPDIFRX_DIR_TLO                 ((uint32_t)0x1FFF0000)        /*!<Threshold HIGH     */
S#endif /* STM32F446xx */
S
S/******************************************************************************/
S/*                                                                            */
S/*                          SD host Interface                                 */
S/*                                                                            */
S/******************************************************************************/
S/******************  Bit definition for SDIO_POWER register  ******************/
S#define  SDIO_POWER_PWRCTRL                  ((uint8_t)0x03)               /*!<PWRCTRL[1:0] bits (Power supply control bits) */
S#define  SDIO_POWER_PWRCTRL_0                ((uint8_t)0x01)               /*!<Bit 0 */
S#define  SDIO_POWER_PWRCTRL_1                ((uint8_t)0x02)               /*!<Bit 1 */
S
S/******************  Bit definition for SDIO_CLKCR register  ******************/
S#define  SDIO_CLKCR_CLKDIV                   ((uint16_t)0x00FF)            /*!<Clock divide factor             */
S#define  SDIO_CLKCR_CLKEN                    ((uint16_t)0x0100)            /*!<Clock enable bit                */
S#define  SDIO_CLKCR_PWRSAV                   ((uint16_t)0x0200)            /*!<Power saving configuration bit  */
S#define  SDIO_CLKCR_BYPASS                   ((uint16_t)0x0400)            /*!<Clock divider bypass enable bit */
S
S#define  SDIO_CLKCR_WIDBUS                   ((uint16_t)0x1800)            /*!<WIDBUS[1:0] bits (Wide bus mode enable bit) */
S#define  SDIO_CLKCR_WIDBUS_0                 ((uint16_t)0x0800)            /*!<Bit 0 */
S#define  SDIO_CLKCR_WIDBUS_1                 ((uint16_t)0x1000)            /*!<Bit 1 */
S
S#define  SDIO_CLKCR_NEGEDGE                  ((uint16_t)0x2000)            /*!<SDIO_CK dephasing selection bit */
S#define  SDIO_CLKCR_HWFC_EN                  ((uint16_t)0x4000)            /*!<HW Flow Control enable          */
S
S/*******************  Bit definition for SDIO_ARG register  *******************/
S#define  SDIO_ARG_CMDARG                     ((uint32_t)0xFFFFFFFF)            /*!<Command argument */
S
S/*******************  Bit definition for SDIO_CMD register  *******************/
S#define  SDIO_CMD_CMDINDEX                   ((uint16_t)0x003F)            /*!<Command Index                               */
S
S#define  SDIO_CMD_WAITRESP                   ((uint16_t)0x00C0)            /*!<WAITRESP[1:0] bits (Wait for response bits) */
S#define  SDIO_CMD_WAITRESP_0                 ((uint16_t)0x0040)            /*!< Bit 0 */
S#define  SDIO_CMD_WAITRESP_1                 ((uint16_t)0x0080)            /*!< Bit 1 */
S
S#define  SDIO_CMD_WAITINT                    ((uint16_t)0x0100)            /*!<CPSM Waits for Interrupt Request                               */
S#define  SDIO_CMD_WAITPEND                   ((uint16_t)0x0200)            /*!<CPSM Waits for ends of data transfer (CmdPend internal signal) */
S#define  SDIO_CMD_CPSMEN                     ((uint16_t)0x0400)            /*!<Command path state machine (CPSM) Enable bit                   */
S#define  SDIO_CMD_SDIOSUSPEND                ((uint16_t)0x0800)            /*!<SD I/O suspend command                                         */
S#define  SDIO_CMD_ENCMDCOMPL                 ((uint16_t)0x1000)            /*!<Enable CMD completion                                          */
S#define  SDIO_CMD_NIEN                       ((uint16_t)0x2000)            /*!<Not Interrupt Enable */
S#define  SDIO_CMD_CEATACMD                   ((uint16_t)0x4000)            /*!<CE-ATA command       */
S
S/*****************  Bit definition for SDIO_RESPCMD register  *****************/
S#define  SDIO_RESPCMD_RESPCMD                ((uint8_t)0x3F)               /*!<Response command index */
S
S/******************  Bit definition for SDIO_RESP0 register  ******************/
S#define  SDIO_RESP0_CARDSTATUS0              ((uint32_t)0xFFFFFFFF)        /*!<Card Status */
S
S/******************  Bit definition for SDIO_RESP1 register  ******************/
S#define  SDIO_RESP1_CARDSTATUS1              ((uint32_t)0xFFFFFFFF)        /*!<Card Status */
S
S/******************  Bit definition for SDIO_RESP2 register  ******************/
S#define  SDIO_RESP2_CARDSTATUS2              ((uint32_t)0xFFFFFFFF)        /*!<Card Status */
S
S/******************  Bit definition for SDIO_RESP3 register  ******************/
S#define  SDIO_RESP3_CARDSTATUS3              ((uint32_t)0xFFFFFFFF)        /*!<Card Status */
S
S/******************  Bit definition for SDIO_RESP4 register  ******************/
S#define  SDIO_RESP4_CARDSTATUS4              ((uint32_t)0xFFFFFFFF)        /*!<Card Status */
S
S/******************  Bit definition for SDIO_DTIMER register  *****************/
S#define  SDIO_DTIMER_DATATIME                ((uint32_t)0xFFFFFFFF)        /*!<Data timeout period. */
S
S/******************  Bit definition for SDIO_DLEN register  *******************/
S#define  SDIO_DLEN_DATALENGTH                ((uint32_t)0x01FFFFFF)        /*!<Data length value    */
S
S/******************  Bit definition for SDIO_DCTRL register  ******************/
S#define  SDIO_DCTRL_DTEN                     ((uint16_t)0x0001)            /*!<Data transfer enabled bit         */
S#define  SDIO_DCTRL_DTDIR                    ((uint16_t)0x0002)            /*!<Data transfer direction selection */
S#define  SDIO_DCTRL_DTMODE                   ((uint16_t)0x0004)            /*!<Data transfer mode selection      */
S#define  SDIO_DCTRL_DMAEN                    ((uint16_t)0x0008)            /*!<DMA enabled bit                   */
S
S#define  SDIO_DCTRL_DBLOCKSIZE               ((uint16_t)0x00F0)            /*!<DBLOCKSIZE[3:0] bits (Data block size) */
S#define  SDIO_DCTRL_DBLOCKSIZE_0             ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  SDIO_DCTRL_DBLOCKSIZE_1             ((uint16_t)0x0020)            /*!<Bit 1 */
S#define  SDIO_DCTRL_DBLOCKSIZE_2             ((uint16_t)0x0040)            /*!<Bit 2 */
S#define  SDIO_DCTRL_DBLOCKSIZE_3             ((uint16_t)0x0080)            /*!<Bit 3 */
S
S#define  SDIO_DCTRL_RWSTART                  ((uint16_t)0x0100)            /*!<Read wait start         */
S#define  SDIO_DCTRL_RWSTOP                   ((uint16_t)0x0200)            /*!<Read wait stop          */
S#define  SDIO_DCTRL_RWMOD                    ((uint16_t)0x0400)            /*!<Read wait mode          */
S#define  SDIO_DCTRL_SDIOEN                   ((uint16_t)0x0800)            /*!<SD I/O enable functions */
S
S/******************  Bit definition for SDIO_DCOUNT register  *****************/
S#define  SDIO_DCOUNT_DATACOUNT               ((uint32_t)0x01FFFFFF)        /*!<Data count value */
S
S/******************  Bit definition for SDIO_STA register  ********************/
S#define  SDIO_STA_CCRCFAIL                   ((uint32_t)0x00000001)        /*!<Command response received (CRC check failed)  */
S#define  SDIO_STA_DCRCFAIL                   ((uint32_t)0x00000002)        /*!<Data block sent/received (CRC check failed)   */
S#define  SDIO_STA_CTIMEOUT                   ((uint32_t)0x00000004)        /*!<Command response timeout                      */
S#define  SDIO_STA_DTIMEOUT                   ((uint32_t)0x00000008)        /*!<Data timeout                                  */
S#define  SDIO_STA_TXUNDERR                   ((uint32_t)0x00000010)        /*!<Transmit FIFO underrun error                  */
S#define  SDIO_STA_RXOVERR                    ((uint32_t)0x00000020)        /*!<Received FIFO overrun error                   */
S#define  SDIO_STA_CMDREND                    ((uint32_t)0x00000040)        /*!<Command response received (CRC check passed)  */
S#define  SDIO_STA_CMDSENT                    ((uint32_t)0x00000080)        /*!<Command sent (no response required)           */
S#define  SDIO_STA_DATAEND                    ((uint32_t)0x00000100)        /*!<Data end (data counter, SDIDCOUNT, is zero)   */
S#define  SDIO_STA_STBITERR                   ((uint32_t)0x00000200)        /*!<Start bit not detected on all data signals in wide bus mode */
S#define  SDIO_STA_DBCKEND                    ((uint32_t)0x00000400)        /*!<Data block sent/received (CRC check passed)   */
S#define  SDIO_STA_CMDACT                     ((uint32_t)0x00000800)        /*!<Command transfer in progress                  */
S#define  SDIO_STA_TXACT                      ((uint32_t)0x00001000)        /*!<Data transmit in progress                     */
S#define  SDIO_STA_RXACT                      ((uint32_t)0x00002000)        /*!<Data receive in progress                      */
S#define  SDIO_STA_TXFIFOHE                   ((uint32_t)0x00004000)        /*!<Transmit FIFO Half Empty: at least 8 words can be written into the FIFO */
S#define  SDIO_STA_RXFIFOHF                   ((uint32_t)0x00008000)        /*!<Receive FIFO Half Full: there are at least 8 words in the FIFO */
S#define  SDIO_STA_TXFIFOF                    ((uint32_t)0x00010000)        /*!<Transmit FIFO full                            */
S#define  SDIO_STA_RXFIFOF                    ((uint32_t)0x00020000)        /*!<Receive FIFO full                             */
S#define  SDIO_STA_TXFIFOE                    ((uint32_t)0x00040000)        /*!<Transmit FIFO empty                           */
S#define  SDIO_STA_RXFIFOE                    ((uint32_t)0x00080000)        /*!<Receive FIFO empty                            */
S#define  SDIO_STA_TXDAVL                     ((uint32_t)0x00100000)        /*!<Data available in transmit FIFO               */
S#define  SDIO_STA_RXDAVL                     ((uint32_t)0x00200000)        /*!<Data available in receive FIFO                */
S#define  SDIO_STA_SDIOIT                     ((uint32_t)0x00400000)        /*!<SDIO interrupt received                       */
S#define  SDIO_STA_CEATAEND                   ((uint32_t)0x00800000)        /*!<CE-ATA command completion signal received for CMD61 */
S
S/*******************  Bit definition for SDIO_ICR register  *******************/
S#define  SDIO_ICR_CCRCFAILC                  ((uint32_t)0x00000001)        /*!<CCRCFAIL flag clear bit */
S#define  SDIO_ICR_DCRCFAILC                  ((uint32_t)0x00000002)        /*!<DCRCFAIL flag clear bit */
S#define  SDIO_ICR_CTIMEOUTC                  ((uint32_t)0x00000004)        /*!<CTIMEOUT flag clear bit */
S#define  SDIO_ICR_DTIMEOUTC                  ((uint32_t)0x00000008)        /*!<DTIMEOUT flag clear bit */
S#define  SDIO_ICR_TXUNDERRC                  ((uint32_t)0x00000010)        /*!<TXUNDERR flag clear bit */
S#define  SDIO_ICR_RXOVERRC                   ((uint32_t)0x00000020)        /*!<RXOVERR flag clear bit  */
S#define  SDIO_ICR_CMDRENDC                   ((uint32_t)0x00000040)        /*!<CMDREND flag clear bit  */
S#define  SDIO_ICR_CMDSENTC                   ((uint32_t)0x00000080)        /*!<CMDSENT flag clear bit  */
S#define  SDIO_ICR_DATAENDC                   ((uint32_t)0x00000100)        /*!<DATAEND flag clear bit  */
S#define  SDIO_ICR_STBITERRC                  ((uint32_t)0x00000200)        /*!<STBITERR flag clear bit */
S#define  SDIO_ICR_DBCKENDC                   ((uint32_t)0x00000400)        /*!<DBCKEND flag clear bit  */
S#define  SDIO_ICR_SDIOITC                    ((uint32_t)0x00400000)        /*!<SDIOIT flag clear bit   */
S#define  SDIO_ICR_CEATAENDC                  ((uint32_t)0x00800000)        /*!<CEATAEND flag clear bit */
S
S/******************  Bit definition for SDIO_MASK register  *******************/
S#define  SDIO_MASK_CCRCFAILIE                ((uint32_t)0x00000001)        /*!<Command CRC Fail Interrupt Enable          */
S#define  SDIO_MASK_DCRCFAILIE                ((uint32_t)0x00000002)        /*!<Data CRC Fail Interrupt Enable             */
S#define  SDIO_MASK_CTIMEOUTIE                ((uint32_t)0x00000004)        /*!<Command TimeOut Interrupt Enable           */
S#define  SDIO_MASK_DTIMEOUTIE                ((uint32_t)0x00000008)        /*!<Data TimeOut Interrupt Enable              */
S#define  SDIO_MASK_TXUNDERRIE                ((uint32_t)0x00000010)        /*!<Tx FIFO UnderRun Error Interrupt Enable    */
S#define  SDIO_MASK_RXOVERRIE                 ((uint32_t)0x00000020)        /*!<Rx FIFO OverRun Error Interrupt Enable     */
S#define  SDIO_MASK_CMDRENDIE                 ((uint32_t)0x00000040)        /*!<Command Response Received Interrupt Enable */
S#define  SDIO_MASK_CMDSENTIE                 ((uint32_t)0x00000080)        /*!<Command Sent Interrupt Enable              */
S#define  SDIO_MASK_DATAENDIE                 ((uint32_t)0x00000100)        /*!<Data End Interrupt Enable                  */
S#define  SDIO_MASK_STBITERRIE                ((uint32_t)0x00000200)        /*!<Start Bit Error Interrupt Enable           */
S#define  SDIO_MASK_DBCKENDIE                 ((uint32_t)0x00000400)        /*!<Data Block End Interrupt Enable            */
S#define  SDIO_MASK_CMDACTIE                  ((uint32_t)0x00000800)        /*!<CCommand Acting Interrupt Enable           */
S#define  SDIO_MASK_TXACTIE                   ((uint32_t)0x00001000)        /*!<Data Transmit Acting Interrupt Enable      */
S#define  SDIO_MASK_RXACTIE                   ((uint32_t)0x00002000)        /*!<Data receive acting interrupt enabled      */
S#define  SDIO_MASK_TXFIFOHEIE                ((uint32_t)0x00004000)        /*!<Tx FIFO Half Empty interrupt Enable        */
S#define  SDIO_MASK_RXFIFOHFIE                ((uint32_t)0x00008000)        /*!<Rx FIFO Half Full interrupt Enable         */
S#define  SDIO_MASK_TXFIFOFIE                 ((uint32_t)0x00010000)        /*!<Tx FIFO Full interrupt Enable              */
S#define  SDIO_MASK_RXFIFOFIE                 ((uint32_t)0x00020000)        /*!<Rx FIFO Full interrupt Enable              */
S#define  SDIO_MASK_TXFIFOEIE                 ((uint32_t)0x00040000)        /*!<Tx FIFO Empty interrupt Enable             */
S#define  SDIO_MASK_RXFIFOEIE                 ((uint32_t)0x00080000)        /*!<Rx FIFO Empty interrupt Enable             */
S#define  SDIO_MASK_TXDAVLIE                  ((uint32_t)0x00100000)        /*!<Data available in Tx FIFO interrupt Enable */
S#define  SDIO_MASK_RXDAVLIE                  ((uint32_t)0x00200000)        /*!<Data available in Rx FIFO interrupt Enable */
S#define  SDIO_MASK_SDIOITIE                  ((uint32_t)0x00400000)        /*!<SDIO Mode Interrupt Received interrupt Enable */
S#define  SDIO_MASK_CEATAENDIE                ((uint32_t)0x00800000)        /*!<CE-ATA command completion signal received Interrupt Enable */
S
S/*****************  Bit definition for SDIO_FIFOCNT register  *****************/
S#define  SDIO_FIFOCNT_FIFOCOUNT              ((uint32_t)0x00FFFFFF)        /*!<Remaining number of words to be written to or read from the FIFO */
S
S/******************  Bit definition for SDIO_FIFO register  *******************/
S#define  SDIO_FIFO_FIFODATA                  ((uint32_t)0xFFFFFFFF)        /*!<Receive and transmit FIFO data */
S
S/******************************************************************************/
S/*                                                                            */
S/*                        Serial Peripheral Interface                         */
S/*                                                                            */
S/******************************************************************************/
S/*******************  Bit definition for SPI_CR1 register  ********************/
S#define  SPI_CR1_CPHA                        ((uint16_t)0x0001)            /*!<Clock Phase      */
S#define  SPI_CR1_CPOL                        ((uint16_t)0x0002)            /*!<Clock Polarity   */
S#define  SPI_CR1_MSTR                        ((uint16_t)0x0004)            /*!<Master Selection */
S
S#define  SPI_CR1_BR                          ((uint16_t)0x0038)            /*!<BR[2:0] bits (Baud Rate Control) */
S#define  SPI_CR1_BR_0                        ((uint16_t)0x0008)            /*!<Bit 0 */
S#define  SPI_CR1_BR_1                        ((uint16_t)0x0010)            /*!<Bit 1 */
S#define  SPI_CR1_BR_2                        ((uint16_t)0x0020)            /*!<Bit 2 */
S
S#define  SPI_CR1_SPE                         ((uint16_t)0x0040)            /*!<SPI Enable                          */
S#define  SPI_CR1_LSBFIRST                    ((uint16_t)0x0080)            /*!<Frame Format                        */
S#define  SPI_CR1_SSI                         ((uint16_t)0x0100)            /*!<Internal slave select               */
S#define  SPI_CR1_SSM                         ((uint16_t)0x0200)            /*!<Software slave management           */
S#define  SPI_CR1_RXONLY                      ((uint16_t)0x0400)            /*!<Receive only                        */
S#define  SPI_CR1_DFF                         ((uint16_t)0x0800)            /*!<Data Frame Format                   */
S#define  SPI_CR1_CRCNEXT                     ((uint16_t)0x1000)            /*!<Transmit CRC next                   */
S#define  SPI_CR1_CRCEN                       ((uint16_t)0x2000)            /*!<Hardware CRC calculation enable     */
S#define  SPI_CR1_BIDIOE                      ((uint16_t)0x4000)            /*!<Output enable in bidirectional mode */
S#define  SPI_CR1_BIDIMODE                    ((uint16_t)0x8000)            /*!<Bidirectional data mode enable      */
S
S/*******************  Bit definition for SPI_CR2 register  ********************/
S#define  SPI_CR2_RXDMAEN                     ((uint8_t)0x01)               /*!<Rx Buffer DMA Enable                 */
S#define  SPI_CR2_TXDMAEN                     ((uint8_t)0x02)               /*!<Tx Buffer DMA Enable                 */
S#define  SPI_CR2_SSOE                        ((uint8_t)0x04)               /*!<SS Output Enable                     */
S#define  SPI_CR2_ERRIE                       ((uint8_t)0x20)               /*!<Error Interrupt Enable               */
S#define  SPI_CR2_RXNEIE                      ((uint8_t)0x40)               /*!<RX buffer Not Empty Interrupt Enable */
S#define  SPI_CR2_TXEIE                       ((uint8_t)0x80)               /*!<Tx buffer Empty Interrupt Enable     */
S
S/********************  Bit definition for SPI_SR register  ********************/
S#define  SPI_SR_RXNE                         ((uint8_t)0x01)               /*!<Receive buffer Not Empty */
S#define  SPI_SR_TXE                          ((uint8_t)0x02)               /*!<Transmit buffer Empty    */
S#define  SPI_SR_CHSIDE                       ((uint8_t)0x04)               /*!<Channel side             */
S#define  SPI_SR_UDR                          ((uint8_t)0x08)               /*!<Underrun flag            */
S#define  SPI_SR_CRCERR                       ((uint8_t)0x10)               /*!<CRC Error flag           */
S#define  SPI_SR_MODF                         ((uint8_t)0x20)               /*!<Mode fault               */
S#define  SPI_SR_OVR                          ((uint8_t)0x40)               /*!<Overrun flag             */
S#define  SPI_SR_BSY                          ((uint8_t)0x80)               /*!<Busy flag                */
S
S/********************  Bit definition for SPI_DR register  ********************/
S#define  SPI_DR_DR                           ((uint16_t)0xFFFF)            /*!<Data Register           */
S
S/*******************  Bit definition for SPI_CRCPR register  ******************/
S#define  SPI_CRCPR_CRCPOLY                   ((uint16_t)0xFFFF)            /*!<CRC polynomial register */
S
S/******************  Bit definition for SPI_RXCRCR register  ******************/
S#define  SPI_RXCRCR_RXCRC                    ((uint16_t)0xFFFF)            /*!<Rx CRC Register         */
S
S/******************  Bit definition for SPI_TXCRCR register  ******************/
S#define  SPI_TXCRCR_TXCRC                    ((uint16_t)0xFFFF)            /*!<Tx CRC Register         */
S
S/******************  Bit definition for SPI_I2SCFGR register  *****************/
S#define  SPI_I2SCFGR_CHLEN                   ((uint16_t)0x0001)            /*!<Channel length (number of bits per audio channel) */
S
S#define  SPI_I2SCFGR_DATLEN                  ((uint16_t)0x0006)            /*!<DATLEN[1:0] bits (Data length to be transferred)  */
S#define  SPI_I2SCFGR_DATLEN_0                ((uint16_t)0x0002)            /*!<Bit 0 */
S#define  SPI_I2SCFGR_DATLEN_1                ((uint16_t)0x0004)            /*!<Bit 1 */
S
S#define  SPI_I2SCFGR_CKPOL                   ((uint16_t)0x0008)            /*!<steady state clock polarity               */
S
S#define  SPI_I2SCFGR_I2SSTD                  ((uint16_t)0x0030)            /*!<I2SSTD[1:0] bits (I2S standard selection) */
S#define  SPI_I2SCFGR_I2SSTD_0                ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  SPI_I2SCFGR_I2SSTD_1                ((uint16_t)0x0020)            /*!<Bit 1 */
S
S#define  SPI_I2SCFGR_PCMSYNC                 ((uint16_t)0x0080)            /*!<PCM frame synchronization                 */
S
S#define  SPI_I2SCFGR_I2SCFG                  ((uint16_t)0x0300)            /*!<I2SCFG[1:0] bits (I2S configuration mode) */
S#define  SPI_I2SCFGR_I2SCFG_0                ((uint16_t)0x0100)            /*!<Bit 0 */
S#define  SPI_I2SCFGR_I2SCFG_1                ((uint16_t)0x0200)            /*!<Bit 1 */
S
S#define  SPI_I2SCFGR_I2SE                    ((uint16_t)0x0400)            /*!<I2S Enable         */
S#define  SPI_I2SCFGR_I2SMOD                  ((uint16_t)0x0800)            /*!<I2S mode selection */
S#if defined(STM32F413_423xx) || defined(STM32F446xx)
S#define  SPI_I2SCFGR_ASTRTEN                 ((uint16_t)0x1000)            /*!<Asynchronous start enable */
S#endif /* STM32F413_423xx */
S
S/******************  Bit definition for SPI_I2SPR register  *******************/
S#define  SPI_I2SPR_I2SDIV                    ((uint16_t)0x00FF)            /*!<I2S Linear prescaler         */
S#define  SPI_I2SPR_ODD                       ((uint16_t)0x0100)            /*!<Odd factor for the prescaler */
S#define  SPI_I2SPR_MCKOE                     ((uint16_t)0x0200)            /*!<Master Clock Output Enable   */
S
S/******************************************************************************/
S/*                                                                            */
S/*                                 SYSCFG                                     */
S/*                                                                            */
S/******************************************************************************/
S/******************  Bit definition for SYSCFG_MEMRMP register  ***************/  
S#define SYSCFG_MEMRMP_MEM_MODE          ((uint32_t)0x00000007) /*!< SYSCFG_Memory Remap Config */
S#define SYSCFG_MEMRMP_MEM_MODE_0        ((uint32_t)0x00000001) /*!<Bit 0 */
S#define SYSCFG_MEMRMP_MEM_MODE_1        ((uint32_t)0x00000002) /*!<Bit 1 */
S#define SYSCFG_MEMRMP_MEM_MODE_2        ((uint32_t)0x00000004) /*!<Bit 2 */
S
S#define SYSCFG_MEMRMP_FB_MODE           ((uint32_t)0x00000100) /*!< User Flash Bank mode */
S
S#define SYSCFG_MEMRMP_SWP_FMC           ((uint32_t)0x00000C00) /*!< FMC memory mapping swap */
S#define SYSCFG_MEMRMP_SWP_FMC_0         ((uint32_t)0x00000400) /*!<Bit 0 */
S#define SYSCFG_MEMRMP_SWP_FMC_1         ((uint32_t)0x00000800) /*!<Bit 1 */
S
S
S/******************  Bit definition for SYSCFG_PMC register  ******************/
S#define SYSCFG_PMC_ADCxDC2              ((uint32_t)0x00070000) /*!< Refer to AN4073 on how to use this bit  */
S#define SYSCFG_PMC_ADC1DC2              ((uint32_t)0x00010000) /*!< Refer to AN4073 on how to use this bit  */
S#define SYSCFG_PMC_ADC2DC2              ((uint32_t)0x00020000) /*!< Refer to AN4073 on how to use this bit  */
S#define SYSCFG_PMC_ADC3DC2              ((uint32_t)0x00040000) /*!< Refer to AN4073 on how to use this bit  */
S
S#define SYSCFG_PMC_MII_RMII_SEL         ((uint32_t)0x00800000) /*!<Ethernet PHY interface selection */
S/* Old MII_RMII_SEL bit definition, maintained for legacy purpose */
S#define SYSCFG_PMC_MII_RMII             SYSCFG_PMC_MII_RMII_SEL
S
S/*****************  Bit definition for SYSCFG_EXTICR1 register  ***************/
S#define SYSCFG_EXTICR1_EXTI0            ((uint16_t)0x000F) /*!<EXTI 0 configuration */
S#define SYSCFG_EXTICR1_EXTI1            ((uint16_t)0x00F0) /*!<EXTI 1 configuration */
S#define SYSCFG_EXTICR1_EXTI2            ((uint16_t)0x0F00) /*!<EXTI 2 configuration */
S#define SYSCFG_EXTICR1_EXTI3            ((uint16_t)0xF000) /*!<EXTI 3 configuration */
S/** 
S  * @brief   EXTI0 configuration  
S  */ 
S#define SYSCFG_EXTICR1_EXTI0_PA         ((uint16_t)0x0000) /*!<PA[0] pin */
S#define SYSCFG_EXTICR1_EXTI0_PB         ((uint16_t)0x0001) /*!<PB[0] pin */
S#define SYSCFG_EXTICR1_EXTI0_PC         ((uint16_t)0x0002) /*!<PC[0] pin */
S#define SYSCFG_EXTICR1_EXTI0_PD         ((uint16_t)0x0003) /*!<PD[0] pin */
S#define SYSCFG_EXTICR1_EXTI0_PE         ((uint16_t)0x0004) /*!<PE[0] pin */
S#define SYSCFG_EXTICR1_EXTI0_PF         ((uint16_t)0x0005) /*!<PF[0] pin */
S#define SYSCFG_EXTICR1_EXTI0_PG         ((uint16_t)0x0006) /*!<PG[0] pin */
S#define SYSCFG_EXTICR1_EXTI0_PH         ((uint16_t)0x0007) /*!<PH[0] pin */
S#define SYSCFG_EXTICR1_EXTI0_PI         ((uint16_t)0x0008) /*!<PI[0] pin */
S#define SYSCFG_EXTICR1_EXTI0_PJ         ((uint16_t)0x0009) /*!<PJ[0] pin */
S#define SYSCFG_EXTICR1_EXTI0_PK         ((uint16_t)0x000A) /*!<PK[0] pin */
S
S/** 
S  * @brief   EXTI1 configuration  
S  */ 
S#define SYSCFG_EXTICR1_EXTI1_PA         ((uint16_t)0x0000) /*!<PA[1] pin */
S#define SYSCFG_EXTICR1_EXTI1_PB         ((uint16_t)0x0010) /*!<PB[1] pin */
S#define SYSCFG_EXTICR1_EXTI1_PC         ((uint16_t)0x0020) /*!<PC[1] pin */
S#define SYSCFG_EXTICR1_EXTI1_PD         ((uint16_t)0x0030) /*!<PD[1] pin */
S#define SYSCFG_EXTICR1_EXTI1_PE         ((uint16_t)0x0040) /*!<PE[1] pin */
S#define SYSCFG_EXTICR1_EXTI1_PF         ((uint16_t)0x0050) /*!<PF[1] pin */
S#define SYSCFG_EXTICR1_EXTI1_PG         ((uint16_t)0x0060) /*!<PG[1] pin */
S#define SYSCFG_EXTICR1_EXTI1_PH         ((uint16_t)0x0070) /*!<PH[1] pin */
S#define SYSCFG_EXTICR1_EXTI1_PI         ((uint16_t)0x0080) /*!<PI[1] pin */
S#define SYSCFG_EXTICR1_EXTI1_PJ         ((uint16_t)0x0090) /*!<PJ[1] pin */
S#define SYSCFG_EXTICR1_EXTI1_PK         ((uint16_t)0x00A0) /*!<PK[1] pin */
S
S/** 
S  * @brief   EXTI2 configuration  
S  */ 
S#define SYSCFG_EXTICR1_EXTI2_PA         ((uint16_t)0x0000) /*!<PA[2] pin */
S#define SYSCFG_EXTICR1_EXTI2_PB         ((uint16_t)0x0100) /*!<PB[2] pin */
S#define SYSCFG_EXTICR1_EXTI2_PC         ((uint16_t)0x0200) /*!<PC[2] pin */
S#define SYSCFG_EXTICR1_EXTI2_PD         ((uint16_t)0x0300) /*!<PD[2] pin */
S#define SYSCFG_EXTICR1_EXTI2_PE         ((uint16_t)0x0400) /*!<PE[2] pin */
S#define SYSCFG_EXTICR1_EXTI2_PF         ((uint16_t)0x0500) /*!<PF[2] pin */
S#define SYSCFG_EXTICR1_EXTI2_PG         ((uint16_t)0x0600) /*!<PG[2] pin */
S#define SYSCFG_EXTICR1_EXTI2_PH         ((uint16_t)0x0700) /*!<PH[2] pin */
S#define SYSCFG_EXTICR1_EXTI2_PI         ((uint16_t)0x0800) /*!<PI[2] pin */
S#define SYSCFG_EXTICR1_EXTI2_PJ         ((uint16_t)0x0900) /*!<PJ[2] pin */
S#define SYSCFG_EXTICR1_EXTI2_PK         ((uint16_t)0x0A00) /*!<PK[2] pin */
S
S/** 
S  * @brief   EXTI3 configuration  
S  */ 
S#define SYSCFG_EXTICR1_EXTI3_PA         ((uint16_t)0x0000) /*!<PA[3] pin */
S#define SYSCFG_EXTICR1_EXTI3_PB         ((uint16_t)0x1000) /*!<PB[3] pin */
S#define SYSCFG_EXTICR1_EXTI3_PC         ((uint16_t)0x2000) /*!<PC[3] pin */
S#define SYSCFG_EXTICR1_EXTI3_PD         ((uint16_t)0x3000) /*!<PD[3] pin */
S#define SYSCFG_EXTICR1_EXTI3_PE         ((uint16_t)0x4000) /*!<PE[3] pin */
S#define SYSCFG_EXTICR1_EXTI3_PF         ((uint16_t)0x5000) /*!<PF[3] pin */
S#define SYSCFG_EXTICR1_EXTI3_PG         ((uint16_t)0x6000) /*!<PG[3] pin */
S#define SYSCFG_EXTICR1_EXTI3_PH         ((uint16_t)0x7000) /*!<PH[3] pin */
S#define SYSCFG_EXTICR1_EXTI3_PI         ((uint16_t)0x8000) /*!<PI[3] pin */
S#define SYSCFG_EXTICR1_EXTI3_PJ         ((uint16_t)0x9000) /*!<PJ[3] pin */
S#define SYSCFG_EXTICR1_EXTI3_PK         ((uint16_t)0xA000) /*!<PK[3] pin */
S
S/*****************  Bit definition for SYSCFG_EXTICR2 register  ***************/
S#define SYSCFG_EXTICR2_EXTI4            ((uint16_t)0x000F) /*!<EXTI 4 configuration */
S#define SYSCFG_EXTICR2_EXTI5            ((uint16_t)0x00F0) /*!<EXTI 5 configuration */
S#define SYSCFG_EXTICR2_EXTI6            ((uint16_t)0x0F00) /*!<EXTI 6 configuration */
S#define SYSCFG_EXTICR2_EXTI7            ((uint16_t)0xF000) /*!<EXTI 7 configuration */
S/** 
S  * @brief   EXTI4 configuration  
S  */ 
S#define SYSCFG_EXTICR2_EXTI4_PA         ((uint16_t)0x0000) /*!<PA[4] pin */
S#define SYSCFG_EXTICR2_EXTI4_PB         ((uint16_t)0x0001) /*!<PB[4] pin */
S#define SYSCFG_EXTICR2_EXTI4_PC         ((uint16_t)0x0002) /*!<PC[4] pin */
S#define SYSCFG_EXTICR2_EXTI4_PD         ((uint16_t)0x0003) /*!<PD[4] pin */
S#define SYSCFG_EXTICR2_EXTI4_PE         ((uint16_t)0x0004) /*!<PE[4] pin */
S#define SYSCFG_EXTICR2_EXTI4_PF         ((uint16_t)0x0005) /*!<PF[4] pin */
S#define SYSCFG_EXTICR2_EXTI4_PG         ((uint16_t)0x0006) /*!<PG[4] pin */
S#define SYSCFG_EXTICR2_EXTI4_PH         ((uint16_t)0x0007) /*!<PH[4] pin */
S#define SYSCFG_EXTICR2_EXTI4_PI         ((uint16_t)0x0008) /*!<PI[4] pin */
S#define SYSCFG_EXTICR2_EXTI4_PJ         ((uint16_t)0x0009) /*!<PJ[4] pin */
S#define SYSCFG_EXTICR2_EXTI4_PK         ((uint16_t)0x000A) /*!<PK[4] pin */
S
S/** 
S  * @brief   EXTI5 configuration  
S  */ 
S#define SYSCFG_EXTICR2_EXTI5_PA         ((uint16_t)0x0000) /*!<PA[5] pin */
S#define SYSCFG_EXTICR2_EXTI5_PB         ((uint16_t)0x0010) /*!<PB[5] pin */
S#define SYSCFG_EXTICR2_EXTI5_PC         ((uint16_t)0x0020) /*!<PC[5] pin */
S#define SYSCFG_EXTICR2_EXTI5_PD         ((uint16_t)0x0030) /*!<PD[5] pin */
S#define SYSCFG_EXTICR2_EXTI5_PE         ((uint16_t)0x0040) /*!<PE[5] pin */
S#define SYSCFG_EXTICR2_EXTI5_PF         ((uint16_t)0x0050) /*!<PF[5] pin */
S#define SYSCFG_EXTICR2_EXTI5_PG         ((uint16_t)0x0060) /*!<PG[5] pin */
S#define SYSCFG_EXTICR2_EXTI5_PH         ((uint16_t)0x0070) /*!<PH[5] pin */
S#define SYSCFG_EXTICR2_EXTI5_PI         ((uint16_t)0x0080) /*!<PI[5] pin */
S#define SYSCFG_EXTICR2_EXTI5_PJ         ((uint16_t)0x0090) /*!<PJ[5] pin */
S#define SYSCFG_EXTICR2_EXTI5_PK         ((uint16_t)0x00A0) /*!<PK[5] pin */
S
S/** 
S  * @brief   EXTI6 configuration  
S  */ 
S#define SYSCFG_EXTICR2_EXTI6_PA         ((uint16_t)0x0000) /*!<PA[6] pin */
S#define SYSCFG_EXTICR2_EXTI6_PB         ((uint16_t)0x0100) /*!<PB[6] pin */
S#define SYSCFG_EXTICR2_EXTI6_PC         ((uint16_t)0x0200) /*!<PC[6] pin */
S#define SYSCFG_EXTICR2_EXTI6_PD         ((uint16_t)0x0300) /*!<PD[6] pin */
S#define SYSCFG_EXTICR2_EXTI6_PE         ((uint16_t)0x0400) /*!<PE[6] pin */
S#define SYSCFG_EXTICR2_EXTI6_PF         ((uint16_t)0x0500) /*!<PF[6] pin */
S#define SYSCFG_EXTICR2_EXTI6_PG         ((uint16_t)0x0600) /*!<PG[6] pin */
S#define SYSCFG_EXTICR2_EXTI6_PH         ((uint16_t)0x0700) /*!<PH[6] pin */
S#define SYSCFG_EXTICR2_EXTI6_PI         ((uint16_t)0x0800) /*!<PI[6] pin */
S#define SYSCFG_EXTICR2_EXTI6_PJ         ((uint16_t)0x0900) /*!<PJ[6] pin */
S#define SYSCFG_EXTICR2_EXTI6_PK         ((uint16_t)0x0A00) /*!<PK[6] pin */
S
S/** 
S  * @brief   EXTI7 configuration  
S  */ 
S#define SYSCFG_EXTICR2_EXTI7_PA         ((uint16_t)0x0000) /*!<PA[7] pin */
S#define SYSCFG_EXTICR2_EXTI7_PB         ((uint16_t)0x1000) /*!<PB[7] pin */
S#define SYSCFG_EXTICR2_EXTI7_PC         ((uint16_t)0x2000) /*!<PC[7] pin */
S#define SYSCFG_EXTICR2_EXTI7_PD         ((uint16_t)0x3000) /*!<PD[7] pin */
S#define SYSCFG_EXTICR2_EXTI7_PE         ((uint16_t)0x4000) /*!<PE[7] pin */
S#define SYSCFG_EXTICR2_EXTI7_PF         ((uint16_t)0x5000) /*!<PF[7] pin */
S#define SYSCFG_EXTICR2_EXTI7_PG         ((uint16_t)0x6000) /*!<PG[7] pin */
S#define SYSCFG_EXTICR2_EXTI7_PH         ((uint16_t)0x7000) /*!<PH[7] pin */
S#define SYSCFG_EXTICR2_EXTI7_PI         ((uint16_t)0x8000) /*!<PI[7] pin */
S#define SYSCFG_EXTICR2_EXTI7_PJ         ((uint16_t)0x9000) /*!<PJ[7] pin */
S#define SYSCFG_EXTICR2_EXTI7_PK         ((uint16_t)0xA000) /*!<PK[7] pin */
S
S/*****************  Bit definition for SYSCFG_EXTICR3 register  ***************/
S#define SYSCFG_EXTICR3_EXTI8            ((uint16_t)0x000F) /*!<EXTI 8 configuration */
S#define SYSCFG_EXTICR3_EXTI9            ((uint16_t)0x00F0) /*!<EXTI 9 configuration */
S#define SYSCFG_EXTICR3_EXTI10           ((uint16_t)0x0F00) /*!<EXTI 10 configuration */
S#define SYSCFG_EXTICR3_EXTI11           ((uint16_t)0xF000) /*!<EXTI 11 configuration */
S           
S/** 
S  * @brief   EXTI8 configuration  
S  */ 
S#define SYSCFG_EXTICR3_EXTI8_PA         ((uint16_t)0x0000) /*!<PA[8] pin */
S#define SYSCFG_EXTICR3_EXTI8_PB         ((uint16_t)0x0001) /*!<PB[8] pin */
S#define SYSCFG_EXTICR3_EXTI8_PC         ((uint16_t)0x0002) /*!<PC[8] pin */
S#define SYSCFG_EXTICR3_EXTI8_PD         ((uint16_t)0x0003) /*!<PD[8] pin */
S#define SYSCFG_EXTICR3_EXTI8_PE         ((uint16_t)0x0004) /*!<PE[8] pin */
S#define SYSCFG_EXTICR3_EXTI8_PF         ((uint16_t)0x0005) /*!<PF[8] pin */
S#define SYSCFG_EXTICR3_EXTI8_PG         ((uint16_t)0x0006) /*!<PG[8] pin */
S#define SYSCFG_EXTICR3_EXTI8_PH         ((uint16_t)0x0007) /*!<PH[8] pin */
S#define SYSCFG_EXTICR3_EXTI8_PI         ((uint16_t)0x0008) /*!<PI[8] pin */
S#define SYSCFG_EXTICR3_EXTI8_PJ         ((uint16_t)0x0009) /*!<PJ[8] pin */
S
S/** 
S  * @brief   EXTI9 configuration  
S  */ 
S#define SYSCFG_EXTICR3_EXTI9_PA         ((uint16_t)0x0000) /*!<PA[9] pin */
S#define SYSCFG_EXTICR3_EXTI9_PB         ((uint16_t)0x0010) /*!<PB[9] pin */
S#define SYSCFG_EXTICR3_EXTI9_PC         ((uint16_t)0x0020) /*!<PC[9] pin */
S#define SYSCFG_EXTICR3_EXTI9_PD         ((uint16_t)0x0030) /*!<PD[9] pin */
S#define SYSCFG_EXTICR3_EXTI9_PE         ((uint16_t)0x0040) /*!<PE[9] pin */
S#define SYSCFG_EXTICR3_EXTI9_PF         ((uint16_t)0x0050) /*!<PF[9] pin */
S#define SYSCFG_EXTICR3_EXTI9_PG         ((uint16_t)0x0060) /*!<PG[9] pin */
S#define SYSCFG_EXTICR3_EXTI9_PH         ((uint16_t)0x0070) /*!<PH[9] pin */
S#define SYSCFG_EXTICR3_EXTI9_PI         ((uint16_t)0x0080) /*!<PI[9] pin */
S#define SYSCFG_EXTICR3_EXTI9_PJ         ((uint16_t)0x0090) /*!<PJ[9] pin */
S
S/** 
S  * @brief   EXTI10 configuration  
S  */ 
S#define SYSCFG_EXTICR3_EXTI10_PA        ((uint16_t)0x0000) /*!<PA[10] pin */
S#define SYSCFG_EXTICR3_EXTI10_PB        ((uint16_t)0x0100) /*!<PB[10] pin */
S#define SYSCFG_EXTICR3_EXTI10_PC        ((uint16_t)0x0200) /*!<PC[10] pin */
S#define SYSCFG_EXTICR3_EXTI10_PD        ((uint16_t)0x0300) /*!<PD[10] pin */
S#define SYSCFG_EXTICR3_EXTI10_PE        ((uint16_t)0x0400) /*!<PE[10] pin */
S#define SYSCFG_EXTICR3_EXTI10_PF        ((uint16_t)0x0500) /*!<PF[10] pin */
S#define SYSCFG_EXTICR3_EXTI10_PG        ((uint16_t)0x0600) /*!<PG[10] pin */
S#define SYSCFG_EXTICR3_EXTI10_PH        ((uint16_t)0x0700) /*!<PH[10] pin */
S#define SYSCFG_EXTICR3_EXTI10_PI        ((uint16_t)0x0800) /*!<PI[10] pin */
S#define SYSCFG_EXTICR3_EXTI10_PJ        ((uint16_t)0x0900) /*!<PJ[10] pin */
S
S/** 
S  * @brief   EXTI11 configuration  
S  */ 
S#define SYSCFG_EXTICR3_EXTI11_PA        ((uint16_t)0x0000) /*!<PA[11] pin */
S#define SYSCFG_EXTICR3_EXTI11_PB        ((uint16_t)0x1000) /*!<PB[11] pin */
S#define SYSCFG_EXTICR3_EXTI11_PC        ((uint16_t)0x2000) /*!<PC[11] pin */
S#define SYSCFG_EXTICR3_EXTI11_PD        ((uint16_t)0x3000) /*!<PD[11] pin */
S#define SYSCFG_EXTICR3_EXTI11_PE        ((uint16_t)0x4000) /*!<PE[11] pin */
S#define SYSCFG_EXTICR3_EXTI11_PF        ((uint16_t)0x5000) /*!<PF[11] pin */
S#define SYSCFG_EXTICR3_EXTI11_PG        ((uint16_t)0x6000) /*!<PG[11] pin */
S#define SYSCFG_EXTICR3_EXTI11_PH        ((uint16_t)0x7000) /*!<PH[11] pin */
S#define SYSCFG_EXTICR3_EXTI11_PI        ((uint16_t)0x8000) /*!<PI[11] pin */
S#define SYSCFG_EXTICR3_EXTI11_PJ        ((uint16_t)0x9000) /*!<PJ[11] pin */
S
S/*****************  Bit definition for SYSCFG_EXTICR4 register  ***************/
S#define SYSCFG_EXTICR4_EXTI12           ((uint16_t)0x000F) /*!<EXTI 12 configuration */
S#define SYSCFG_EXTICR4_EXTI13           ((uint16_t)0x00F0) /*!<EXTI 13 configuration */
S#define SYSCFG_EXTICR4_EXTI14           ((uint16_t)0x0F00) /*!<EXTI 14 configuration */
S#define SYSCFG_EXTICR4_EXTI15           ((uint16_t)0xF000) /*!<EXTI 15 configuration */
S/** 
S  * @brief   EXTI12 configuration  
S  */ 
S#define SYSCFG_EXTICR4_EXTI12_PA        ((uint16_t)0x0000) /*!<PA[12] pin */
S#define SYSCFG_EXTICR4_EXTI12_PB        ((uint16_t)0x0001) /*!<PB[12] pin */
S#define SYSCFG_EXTICR4_EXTI12_PC        ((uint16_t)0x0002) /*!<PC[12] pin */
S#define SYSCFG_EXTICR4_EXTI12_PD        ((uint16_t)0x0003) /*!<PD[12] pin */
S#define SYSCFG_EXTICR4_EXTI12_PE        ((uint16_t)0x0004) /*!<PE[12] pin */
S#define SYSCFG_EXTICR4_EXTI12_PF        ((uint16_t)0x0005) /*!<PF[12] pin */
S#define SYSCFG_EXTICR4_EXTI12_PG        ((uint16_t)0x0006) /*!<PG[12] pin */
S#define SYSCFG_EXTICR4_EXTI12_PH        ((uint16_t)0x0007) /*!<PH[12] pin */
S#define SYSCFG_EXTICR4_EXTI12_PI        ((uint16_t)0x0008) /*!<PI[12] pin */
S#define SYSCFG_EXTICR4_EXTI12_PJ        ((uint16_t)0x0009) /*!<PJ[12] pin */
S
S/** 
S  * @brief   EXTI13 configuration  
S  */ 
S#define SYSCFG_EXTICR4_EXTI13_PA        ((uint16_t)0x0000) /*!<PA[13] pin */
S#define SYSCFG_EXTICR4_EXTI13_PB        ((uint16_t)0x0010) /*!<PB[13] pin */
S#define SYSCFG_EXTICR4_EXTI13_PC        ((uint16_t)0x0020) /*!<PC[13] pin */
S#define SYSCFG_EXTICR4_EXTI13_PD        ((uint16_t)0x0030) /*!<PD[13] pin */
S#define SYSCFG_EXTICR4_EXTI13_PE        ((uint16_t)0x0040) /*!<PE[13] pin */
S#define SYSCFG_EXTICR4_EXTI13_PF        ((uint16_t)0x0050) /*!<PF[13] pin */
S#define SYSCFG_EXTICR4_EXTI13_PG        ((uint16_t)0x0060) /*!<PG[13] pin */
S#define SYSCFG_EXTICR4_EXTI13_PH        ((uint16_t)0x0070) /*!<PH[13] pin */
S#define SYSCFG_EXTICR4_EXTI13_PI        ((uint16_t)0x0008) /*!<PI[13] pin */
S#define SYSCFG_EXTICR4_EXTI13_PJ        ((uint16_t)0x0009) /*!<PJ[13] pin */
S
S/** 
S  * @brief   EXTI14 configuration  
S  */ 
S#define SYSCFG_EXTICR4_EXTI14_PA        ((uint16_t)0x0000) /*!<PA[14] pin */
S#define SYSCFG_EXTICR4_EXTI14_PB        ((uint16_t)0x0100) /*!<PB[14] pin */
S#define SYSCFG_EXTICR4_EXTI14_PC        ((uint16_t)0x0200) /*!<PC[14] pin */
S#define SYSCFG_EXTICR4_EXTI14_PD        ((uint16_t)0x0300) /*!<PD[14] pin */
S#define SYSCFG_EXTICR4_EXTI14_PE        ((uint16_t)0x0400) /*!<PE[14] pin */
S#define SYSCFG_EXTICR4_EXTI14_PF        ((uint16_t)0x0500) /*!<PF[14] pin */
S#define SYSCFG_EXTICR4_EXTI14_PG        ((uint16_t)0x0600) /*!<PG[14] pin */
S#define SYSCFG_EXTICR4_EXTI14_PH        ((uint16_t)0x0700) /*!<PH[14] pin */
S#define SYSCFG_EXTICR4_EXTI14_PI        ((uint16_t)0x0800) /*!<PI[14] pin */
S#define SYSCFG_EXTICR4_EXTI14_PJ        ((uint16_t)0x0900) /*!<PJ[14] pin */
S
S/** 
S  * @brief   EXTI15 configuration  
S  */ 
S#define SYSCFG_EXTICR4_EXTI15_PA        ((uint16_t)0x0000) /*!<PA[15] pin */
S#define SYSCFG_EXTICR4_EXTI15_PB        ((uint16_t)0x1000) /*!<PB[15] pin */
S#define SYSCFG_EXTICR4_EXTI15_PC        ((uint16_t)0x2000) /*!<PC[15] pin */
S#define SYSCFG_EXTICR4_EXTI15_PD        ((uint16_t)0x3000) /*!<PD[15] pin */
S#define SYSCFG_EXTICR4_EXTI15_PE        ((uint16_t)0x4000) /*!<PE[15] pin */
S#define SYSCFG_EXTICR4_EXTI15_PF        ((uint16_t)0x5000) /*!<PF[15] pin */
S#define SYSCFG_EXTICR4_EXTI15_PG        ((uint16_t)0x6000) /*!<PG[15] pin */
S#define SYSCFG_EXTICR4_EXTI15_PH        ((uint16_t)0x7000) /*!<PH[15] pin */
S#define SYSCFG_EXTICR4_EXTI15_PI        ((uint16_t)0x8000) /*!<PI[15] pin */
S#define SYSCFG_EXTICR4_EXTI15_PJ        ((uint16_t)0x9000) /*!<PJ[15] pin */
S
S#if defined(STM32F412xG) || defined(STM32F413_423xx)
S/******************  Bit definition for SYSCFG_CFGR register  *****************/
S#define SYSCFG_CFGR_FMPI2C1_SCL         ((uint32_t)0x00000001) /*!<FM+ drive capability for FMPI2C1_SCL pin */
S#define SYSCFG_CFGR_FMPI2C1_SDA         ((uint32_t)0x00000002) /*!<FM+ drive capability for FMPI2C1_SDA pin */
S#endif /* STM32F412xG || STM32413_423xx */
S
S#if defined (STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx)
S/******************  Bit definition for SYSCFG_CFGR2 register  ****************/
S#define SYSCFG_CFGR2_CLL                ((uint32_t)0x00000001) /*!< Core Lockup Lock */
S#define SYSCFG_CFGR2_PVDL               ((uint32_t)0x00000004) /*!<  PVD Lock */
S#endif /* STM32F410xx || STM32F412xG || STM32F413_423xx */
S/******************  Bit definition for SYSCFG_CMPCR register  ****************/  
S#define SYSCFG_CMPCR_CMP_PD             ((uint32_t)0x00000001) /*!<Compensation cell ready flag */
S#define SYSCFG_CMPCR_READY              ((uint32_t)0x00000100) /*!<Compensation cell power-down */
S
S#if defined(STM32F413_423xx)
S/******************  Bit definition for SYSCFG_MCHDLYCR register  *****************/
S#define SYSCFG_MCHDLYCR_BSCKSEL         ((uint32_t)0x00000001) /*!<Bitstream clock source selection                     */
S#define SYSCFG_MCHDLYCR_MCHDLY1EN       ((uint32_t)0x00000002) /*!<MCHDLY clock enable for DFSDM1                       */
S#define SYSCFG_MCHDLYCR_DFSDM1D0SEL     ((uint32_t)0x00000004) /*!<Source selection for DatIn0 for DFSDM1               */
S#define SYSCFG_MCHDLYCR_DFSDM1D2SEL     ((uint32_t)0x00000008) /*!<Source selection for DatIn2 for DFSDM1               */
S#define SYSCFG_MCHDLYCR_DFSDM1CK02SEL   ((uint32_t)0x00000010) /*!<Distribution of the bitstreamclock gated by TIM4 OC2 */
S#define SYSCFG_MCHDLYCR_DFSDM1CK13SEL   ((uint32_t)0x00000020) /*!<Distribution of the bitstreamclock gated by TIM4 OC1 */
S#define SYSCFG_MCHDLYCR_DFSDM1CFG       ((uint32_t)0x00000040) /*!<Source selection for DFSDM1                          */
S#define SYSCFG_MCHDLYCR_DFSDM1CKOSEL    ((uint32_t)0x00000080) /*!<Source selection for 1_CKOUT                         */
S#define SYSCFG_MCHDLYCR_MCHDLY2EN       ((uint32_t)0x00000100) /*!<MCHDLY clock enable for DFSDM2                       */
S#define SYSCFG_MCHDLYCR_DFSDM2D0SEL     ((uint32_t)0x00000200) /*!<Source selection for DatIn0 for DFSDM2               */
S#define SYSCFG_MCHDLYCR_DFSDM2D2SEL     ((uint32_t)0x00000400) /*!<Source selection for DatIn2 for DFSDM2               */
S#define SYSCFG_MCHDLYCR_DFSDM2D4SEL     ((uint32_t)0x00000800) /*!<Source selection for DatIn4 for DFSDM2               */
S#define SYSCFG_MCHDLYCR_DFSDM2D6SEL     ((uint32_t)0x00001000) /*!<Source selection for DatIn6 for DFSDM2               */
S#define SYSCFG_MCHDLYCR_DFSDM2CK04SEL   ((uint32_t)0x00002000) /*!<Distribution of the bitstreamclock gated by TIM3 OC4 */
S#define SYSCFG_MCHDLYCR_DFSDM2CK15SEL   ((uint32_t)0x00004000) /*!<Distribution of the bitstreamclock gated by TIM3 OC3 */
S#define SYSCFG_MCHDLYCR_DFSDM2CK26SEL   ((uint32_t)0x00008000) /*!Distribution of the bitstreamclock gated by TIM3 OC2  */
S#define SYSCFG_MCHDLYCR_DFSDM2CK37SEL   ((uint32_t)0x00010000) /*!<Distribution of the bitstreamclock gated by TIM3 OC1 */
S#define SYSCFG_MCHDLYCR_DFSDM2CFG       ((uint32_t)0x00020000) /*!<Source selection for DFSDM2                          */
S#define SYSCFG_MCHDLYCR_DFSDM2CKOSEL    ((uint32_t)0x00040000) /*!<Source selection for 2_CKOUT                         */
S#endif /* STM32F413_423xx */
S
S/******************************************************************************/
S/*                                                                            */
S/*                                    TIM                                     */
S/*                                                                            */
S/******************************************************************************/
S/*******************  Bit definition for TIM_CR1 register  ********************/
S#define  TIM_CR1_CEN                         ((uint16_t)0x0001)            /*!<Counter enable        */
S#define  TIM_CR1_UDIS                        ((uint16_t)0x0002)            /*!<Update disable        */
S#define  TIM_CR1_URS                         ((uint16_t)0x0004)            /*!<Update request source */
S#define  TIM_CR1_OPM                         ((uint16_t)0x0008)            /*!<One pulse mode        */
S#define  TIM_CR1_DIR                         ((uint16_t)0x0010)            /*!<Direction             */
S
S#define  TIM_CR1_CMS                         ((uint16_t)0x0060)            /*!<CMS[1:0] bits (Center-aligned mode selection) */
S#define  TIM_CR1_CMS_0                       ((uint16_t)0x0020)            /*!<Bit 0 */
S#define  TIM_CR1_CMS_1                       ((uint16_t)0x0040)            /*!<Bit 1 */
S
S#define  TIM_CR1_ARPE                        ((uint16_t)0x0080)            /*!<Auto-reload preload enable     */
S
S#define  TIM_CR1_CKD                         ((uint16_t)0x0300)            /*!<CKD[1:0] bits (clock division) */
S#define  TIM_CR1_CKD_0                       ((uint16_t)0x0100)            /*!<Bit 0 */
S#define  TIM_CR1_CKD_1                       ((uint16_t)0x0200)            /*!<Bit 1 */
S
S/*******************  Bit definition for TIM_CR2 register  ********************/
S#define  TIM_CR2_CCPC                        ((uint16_t)0x0001)            /*!<Capture/Compare Preloaded Control        */
S#define  TIM_CR2_CCUS                        ((uint16_t)0x0004)            /*!<Capture/Compare Control Update Selection */
S#define  TIM_CR2_CCDS                        ((uint16_t)0x0008)            /*!<Capture/Compare DMA Selection            */
S
S#define  TIM_CR2_MMS                         ((uint16_t)0x0070)            /*!<MMS[2:0] bits (Master Mode Selection) */
S#define  TIM_CR2_MMS_0                       ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  TIM_CR2_MMS_1                       ((uint16_t)0x0020)            /*!<Bit 1 */
S#define  TIM_CR2_MMS_2                       ((uint16_t)0x0040)            /*!<Bit 2 */
S
S#define  TIM_CR2_TI1S                        ((uint16_t)0x0080)            /*!<TI1 Selection */
S#define  TIM_CR2_OIS1                        ((uint16_t)0x0100)            /*!<Output Idle state 1 (OC1 output)  */
S#define  TIM_CR2_OIS1N                       ((uint16_t)0x0200)            /*!<Output Idle state 1 (OC1N output) */
S#define  TIM_CR2_OIS2                        ((uint16_t)0x0400)            /*!<Output Idle state 2 (OC2 output)  */
S#define  TIM_CR2_OIS2N                       ((uint16_t)0x0800)            /*!<Output Idle state 2 (OC2N output) */
S#define  TIM_CR2_OIS3                        ((uint16_t)0x1000)            /*!<Output Idle state 3 (OC3 output)  */
S#define  TIM_CR2_OIS3N                       ((uint16_t)0x2000)            /*!<Output Idle state 3 (OC3N output) */
S#define  TIM_CR2_OIS4                        ((uint16_t)0x4000)            /*!<Output Idle state 4 (OC4 output)  */
S
S/*******************  Bit definition for TIM_SMCR register  *******************/
S#define  TIM_SMCR_SMS                        ((uint16_t)0x0007)            /*!<SMS[2:0] bits (Slave mode selection)    */
S#define  TIM_SMCR_SMS_0                      ((uint16_t)0x0001)            /*!<Bit 0 */
S#define  TIM_SMCR_SMS_1                      ((uint16_t)0x0002)            /*!<Bit 1 */
S#define  TIM_SMCR_SMS_2                      ((uint16_t)0x0004)            /*!<Bit 2 */
S
S#define  TIM_SMCR_TS                         ((uint16_t)0x0070)            /*!<TS[2:0] bits (Trigger selection)        */
S#define  TIM_SMCR_TS_0                       ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  TIM_SMCR_TS_1                       ((uint16_t)0x0020)            /*!<Bit 1 */
S#define  TIM_SMCR_TS_2                       ((uint16_t)0x0040)            /*!<Bit 2 */
S
S#define  TIM_SMCR_MSM                        ((uint16_t)0x0080)            /*!<Master/slave mode                       */
S
S#define  TIM_SMCR_ETF                        ((uint16_t)0x0F00)            /*!<ETF[3:0] bits (External trigger filter) */
S#define  TIM_SMCR_ETF_0                      ((uint16_t)0x0100)            /*!<Bit 0 */
S#define  TIM_SMCR_ETF_1                      ((uint16_t)0x0200)            /*!<Bit 1 */
S#define  TIM_SMCR_ETF_2                      ((uint16_t)0x0400)            /*!<Bit 2 */
S#define  TIM_SMCR_ETF_3                      ((uint16_t)0x0800)            /*!<Bit 3 */
S
S#define  TIM_SMCR_ETPS                       ((uint16_t)0x3000)            /*!<ETPS[1:0] bits (External trigger prescaler) */
S#define  TIM_SMCR_ETPS_0                     ((uint16_t)0x1000)            /*!<Bit 0 */
S#define  TIM_SMCR_ETPS_1                     ((uint16_t)0x2000)            /*!<Bit 1 */
S
S#define  TIM_SMCR_ECE                        ((uint16_t)0x4000)            /*!<External clock enable     */
S#define  TIM_SMCR_ETP                        ((uint16_t)0x8000)            /*!<External trigger polarity */
S
S/*******************  Bit definition for TIM_DIER register  *******************/
S#define  TIM_DIER_UIE                        ((uint16_t)0x0001)            /*!<Update interrupt enable */
S#define  TIM_DIER_CC1IE                      ((uint16_t)0x0002)            /*!<Capture/Compare 1 interrupt enable   */
S#define  TIM_DIER_CC2IE                      ((uint16_t)0x0004)            /*!<Capture/Compare 2 interrupt enable   */
S#define  TIM_DIER_CC3IE                      ((uint16_t)0x0008)            /*!<Capture/Compare 3 interrupt enable   */
S#define  TIM_DIER_CC4IE                      ((uint16_t)0x0010)            /*!<Capture/Compare 4 interrupt enable   */
S#define  TIM_DIER_COMIE                      ((uint16_t)0x0020)            /*!<COM interrupt enable                 */
S#define  TIM_DIER_TIE                        ((uint16_t)0x0040)            /*!<Trigger interrupt enable             */
S#define  TIM_DIER_BIE                        ((uint16_t)0x0080)            /*!<Break interrupt enable               */
S#define  TIM_DIER_UDE                        ((uint16_t)0x0100)            /*!<Update DMA request enable            */
S#define  TIM_DIER_CC1DE                      ((uint16_t)0x0200)            /*!<Capture/Compare 1 DMA request enable */
S#define  TIM_DIER_CC2DE                      ((uint16_t)0x0400)            /*!<Capture/Compare 2 DMA request enable */
S#define  TIM_DIER_CC3DE                      ((uint16_t)0x0800)            /*!<Capture/Compare 3 DMA request enable */
S#define  TIM_DIER_CC4DE                      ((uint16_t)0x1000)            /*!<Capture/Compare 4 DMA request enable */
S#define  TIM_DIER_COMDE                      ((uint16_t)0x2000)            /*!<COM DMA request enable               */
S#define  TIM_DIER_TDE                        ((uint16_t)0x4000)            /*!<Trigger DMA request enable           */
S
S/********************  Bit definition for TIM_SR register  ********************/
S#define  TIM_SR_UIF                          ((uint16_t)0x0001)            /*!<Update interrupt Flag              */
S#define  TIM_SR_CC1IF                        ((uint16_t)0x0002)            /*!<Capture/Compare 1 interrupt Flag   */
S#define  TIM_SR_CC2IF                        ((uint16_t)0x0004)            /*!<Capture/Compare 2 interrupt Flag   */
S#define  TIM_SR_CC3IF                        ((uint16_t)0x0008)            /*!<Capture/Compare 3 interrupt Flag   */
S#define  TIM_SR_CC4IF                        ((uint16_t)0x0010)            /*!<Capture/Compare 4 interrupt Flag   */
S#define  TIM_SR_COMIF                        ((uint16_t)0x0020)            /*!<COM interrupt Flag                 */
S#define  TIM_SR_TIF                          ((uint16_t)0x0040)            /*!<Trigger interrupt Flag             */
S#define  TIM_SR_BIF                          ((uint16_t)0x0080)            /*!<Break interrupt Flag               */
S#define  TIM_SR_CC1OF                        ((uint16_t)0x0200)            /*!<Capture/Compare 1 Overcapture Flag */
S#define  TIM_SR_CC2OF                        ((uint16_t)0x0400)            /*!<Capture/Compare 2 Overcapture Flag */
S#define  TIM_SR_CC3OF                        ((uint16_t)0x0800)            /*!<Capture/Compare 3 Overcapture Flag */
S#define  TIM_SR_CC4OF                        ((uint16_t)0x1000)            /*!<Capture/Compare 4 Overcapture Flag */
S
S/*******************  Bit definition for TIM_EGR register  ********************/
S#define  TIM_EGR_UG                          ((uint8_t)0x01)               /*!<Update Generation                         */
S#define  TIM_EGR_CC1G                        ((uint8_t)0x02)               /*!<Capture/Compare 1 Generation              */
S#define  TIM_EGR_CC2G                        ((uint8_t)0x04)               /*!<Capture/Compare 2 Generation              */
S#define  TIM_EGR_CC3G                        ((uint8_t)0x08)               /*!<Capture/Compare 3 Generation              */
S#define  TIM_EGR_CC4G                        ((uint8_t)0x10)               /*!<Capture/Compare 4 Generation              */
S#define  TIM_EGR_COMG                        ((uint8_t)0x20)               /*!<Capture/Compare Control Update Generation */
S#define  TIM_EGR_TG                          ((uint8_t)0x40)               /*!<Trigger Generation                        */
S#define  TIM_EGR_BG                          ((uint8_t)0x80)               /*!<Break Generation                          */
S
S/******************  Bit definition for TIM_CCMR1 register  *******************/
S#define  TIM_CCMR1_CC1S                      ((uint16_t)0x0003)            /*!<CC1S[1:0] bits (Capture/Compare 1 Selection) */
S#define  TIM_CCMR1_CC1S_0                    ((uint16_t)0x0001)            /*!<Bit 0 */
S#define  TIM_CCMR1_CC1S_1                    ((uint16_t)0x0002)            /*!<Bit 1 */
S
S#define  TIM_CCMR1_OC1FE                     ((uint16_t)0x0004)            /*!<Output Compare 1 Fast enable                 */
S#define  TIM_CCMR1_OC1PE                     ((uint16_t)0x0008)            /*!<Output Compare 1 Preload enable              */
S
S#define  TIM_CCMR1_OC1M                      ((uint16_t)0x0070)            /*!<OC1M[2:0] bits (Output Compare 1 Mode)       */
S#define  TIM_CCMR1_OC1M_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  TIM_CCMR1_OC1M_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
S#define  TIM_CCMR1_OC1M_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
S
S#define  TIM_CCMR1_OC1CE                     ((uint16_t)0x0080)            /*!<Output Compare 1Clear Enable                 */
S
S#define  TIM_CCMR1_CC2S                      ((uint16_t)0x0300)            /*!<CC2S[1:0] bits (Capture/Compare 2 Selection) */
S#define  TIM_CCMR1_CC2S_0                    ((uint16_t)0x0100)            /*!<Bit 0 */
S#define  TIM_CCMR1_CC2S_1                    ((uint16_t)0x0200)            /*!<Bit 1 */
S
S#define  TIM_CCMR1_OC2FE                     ((uint16_t)0x0400)            /*!<Output Compare 2 Fast enable                 */
S#define  TIM_CCMR1_OC2PE                     ((uint16_t)0x0800)            /*!<Output Compare 2 Preload enable              */
S
S#define  TIM_CCMR1_OC2M                      ((uint16_t)0x7000)            /*!<OC2M[2:0] bits (Output Compare 2 Mode)       */
S#define  TIM_CCMR1_OC2M_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
S#define  TIM_CCMR1_OC2M_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
S#define  TIM_CCMR1_OC2M_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
S
S#define  TIM_CCMR1_OC2CE                     ((uint16_t)0x8000)            /*!<Output Compare 2 Clear Enable */
S
S/*----------------------------------------------------------------------------*/
S
S#define  TIM_CCMR1_IC1PSC                    ((uint16_t)0x000C)            /*!<IC1PSC[1:0] bits (Input Capture 1 Prescaler) */
S#define  TIM_CCMR1_IC1PSC_0                  ((uint16_t)0x0004)            /*!<Bit 0 */
S#define  TIM_CCMR1_IC1PSC_1                  ((uint16_t)0x0008)            /*!<Bit 1 */
S
S#define  TIM_CCMR1_IC1F                      ((uint16_t)0x00F0)            /*!<IC1F[3:0] bits (Input Capture 1 Filter)      */
S#define  TIM_CCMR1_IC1F_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  TIM_CCMR1_IC1F_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
S#define  TIM_CCMR1_IC1F_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
S#define  TIM_CCMR1_IC1F_3                    ((uint16_t)0x0080)            /*!<Bit 3 */
S
S#define  TIM_CCMR1_IC2PSC                    ((uint16_t)0x0C00)            /*!<IC2PSC[1:0] bits (Input Capture 2 Prescaler)  */
S#define  TIM_CCMR1_IC2PSC_0                  ((uint16_t)0x0400)            /*!<Bit 0 */
S#define  TIM_CCMR1_IC2PSC_1                  ((uint16_t)0x0800)            /*!<Bit 1 */
S
S#define  TIM_CCMR1_IC2F                      ((uint16_t)0xF000)            /*!<IC2F[3:0] bits (Input Capture 2 Filter)       */
S#define  TIM_CCMR1_IC2F_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
S#define  TIM_CCMR1_IC2F_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
S#define  TIM_CCMR1_IC2F_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
S#define  TIM_CCMR1_IC2F_3                    ((uint16_t)0x8000)            /*!<Bit 3 */
S
S/******************  Bit definition for TIM_CCMR2 register  *******************/
S#define  TIM_CCMR2_CC3S                      ((uint16_t)0x0003)            /*!<CC3S[1:0] bits (Capture/Compare 3 Selection)  */
S#define  TIM_CCMR2_CC3S_0                    ((uint16_t)0x0001)            /*!<Bit 0 */
S#define  TIM_CCMR2_CC3S_1                    ((uint16_t)0x0002)            /*!<Bit 1 */
S
S#define  TIM_CCMR2_OC3FE                     ((uint16_t)0x0004)            /*!<Output Compare 3 Fast enable           */
S#define  TIM_CCMR2_OC3PE                     ((uint16_t)0x0008)            /*!<Output Compare 3 Preload enable        */
S
S#define  TIM_CCMR2_OC3M                      ((uint16_t)0x0070)            /*!<OC3M[2:0] bits (Output Compare 3 Mode) */
S#define  TIM_CCMR2_OC3M_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  TIM_CCMR2_OC3M_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
S#define  TIM_CCMR2_OC3M_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
S
S#define  TIM_CCMR2_OC3CE                     ((uint16_t)0x0080)            /*!<Output Compare 3 Clear Enable */
S
S#define  TIM_CCMR2_CC4S                      ((uint16_t)0x0300)            /*!<CC4S[1:0] bits (Capture/Compare 4 Selection) */
S#define  TIM_CCMR2_CC4S_0                    ((uint16_t)0x0100)            /*!<Bit 0 */
S#define  TIM_CCMR2_CC4S_1                    ((uint16_t)0x0200)            /*!<Bit 1 */
S
S#define  TIM_CCMR2_OC4FE                     ((uint16_t)0x0400)            /*!<Output Compare 4 Fast enable    */
S#define  TIM_CCMR2_OC4PE                     ((uint16_t)0x0800)            /*!<Output Compare 4 Preload enable */
S
S#define  TIM_CCMR2_OC4M                      ((uint16_t)0x7000)            /*!<OC4M[2:0] bits (Output Compare 4 Mode) */
S#define  TIM_CCMR2_OC4M_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
S#define  TIM_CCMR2_OC4M_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
S#define  TIM_CCMR2_OC4M_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
S
S#define  TIM_CCMR2_OC4CE                     ((uint16_t)0x8000)            /*!<Output Compare 4 Clear Enable */
S
S/*----------------------------------------------------------------------------*/
S
S#define  TIM_CCMR2_IC3PSC                    ((uint16_t)0x000C)            /*!<IC3PSC[1:0] bits (Input Capture 3 Prescaler) */
S#define  TIM_CCMR2_IC3PSC_0                  ((uint16_t)0x0004)            /*!<Bit 0 */
S#define  TIM_CCMR2_IC3PSC_1                  ((uint16_t)0x0008)            /*!<Bit 1 */
S
S#define  TIM_CCMR2_IC3F                      ((uint16_t)0x00F0)            /*!<IC3F[3:0] bits (Input Capture 3 Filter) */
S#define  TIM_CCMR2_IC3F_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  TIM_CCMR2_IC3F_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
S#define  TIM_CCMR2_IC3F_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
S#define  TIM_CCMR2_IC3F_3                    ((uint16_t)0x0080)            /*!<Bit 3 */
S
S#define  TIM_CCMR2_IC4PSC                    ((uint16_t)0x0C00)            /*!<IC4PSC[1:0] bits (Input Capture 4 Prescaler) */
S#define  TIM_CCMR2_IC4PSC_0                  ((uint16_t)0x0400)            /*!<Bit 0 */
S#define  TIM_CCMR2_IC4PSC_1                  ((uint16_t)0x0800)            /*!<Bit 1 */
S
S#define  TIM_CCMR2_IC4F                      ((uint16_t)0xF000)            /*!<IC4F[3:0] bits (Input Capture 4 Filter) */
S#define  TIM_CCMR2_IC4F_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
S#define  TIM_CCMR2_IC4F_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
S#define  TIM_CCMR2_IC4F_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
S#define  TIM_CCMR2_IC4F_3                    ((uint16_t)0x8000)            /*!<Bit 3 */
S
S/*******************  Bit definition for TIM_CCER register  *******************/
S#define  TIM_CCER_CC1E                       ((uint16_t)0x0001)            /*!<Capture/Compare 1 output enable                 */
S#define  TIM_CCER_CC1P                       ((uint16_t)0x0002)            /*!<Capture/Compare 1 output Polarity               */
S#define  TIM_CCER_CC1NE                      ((uint16_t)0x0004)            /*!<Capture/Compare 1 Complementary output enable   */
S#define  TIM_CCER_CC1NP                      ((uint16_t)0x0008)            /*!<Capture/Compare 1 Complementary output Polarity */
S#define  TIM_CCER_CC2E                       ((uint16_t)0x0010)            /*!<Capture/Compare 2 output enable                 */
S#define  TIM_CCER_CC2P                       ((uint16_t)0x0020)            /*!<Capture/Compare 2 output Polarity               */
S#define  TIM_CCER_CC2NE                      ((uint16_t)0x0040)            /*!<Capture/Compare 2 Complementary output enable   */
S#define  TIM_CCER_CC2NP                      ((uint16_t)0x0080)            /*!<Capture/Compare 2 Complementary output Polarity */
S#define  TIM_CCER_CC3E                       ((uint16_t)0x0100)            /*!<Capture/Compare 3 output enable                 */
S#define  TIM_CCER_CC3P                       ((uint16_t)0x0200)            /*!<Capture/Compare 3 output Polarity               */
S#define  TIM_CCER_CC3NE                      ((uint16_t)0x0400)            /*!<Capture/Compare 3 Complementary output enable   */
S#define  TIM_CCER_CC3NP                      ((uint16_t)0x0800)            /*!<Capture/Compare 3 Complementary output Polarity */
S#define  TIM_CCER_CC4E                       ((uint16_t)0x1000)            /*!<Capture/Compare 4 output enable                 */
S#define  TIM_CCER_CC4P                       ((uint16_t)0x2000)            /*!<Capture/Compare 4 output Polarity               */
S#define  TIM_CCER_CC4NP                      ((uint16_t)0x8000)            /*!<Capture/Compare 4 Complementary output Polarity */
S
S/*******************  Bit definition for TIM_CNT register  ********************/
S#define  TIM_CNT_CNT                         ((uint16_t)0xFFFF)            /*!<Counter Value            */
S
S/*******************  Bit definition for TIM_PSC register  ********************/
S#define  TIM_PSC_PSC                         ((uint16_t)0xFFFF)            /*!<Prescaler Value          */
S
S/*******************  Bit definition for TIM_ARR register  ********************/
S#define  TIM_ARR_ARR                         ((uint16_t)0xFFFF)            /*!<actual auto-reload Value */
S
S/*******************  Bit definition for TIM_RCR register  ********************/
S#define  TIM_RCR_REP                         ((uint8_t)0xFF)               /*!<Repetition Counter Value */
S
S/*******************  Bit definition for TIM_CCR1 register  *******************/
S#define  TIM_CCR1_CCR1                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 1 Value  */
S
S/*******************  Bit definition for TIM_CCR2 register  *******************/
S#define  TIM_CCR2_CCR2                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 2 Value  */
S
S/*******************  Bit definition for TIM_CCR3 register  *******************/
S#define  TIM_CCR3_CCR3                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 3 Value  */
S
S/*******************  Bit definition for TIM_CCR4 register  *******************/
S#define  TIM_CCR4_CCR4                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 4 Value  */
S
S/*******************  Bit definition for TIM_BDTR register  *******************/
S#define  TIM_BDTR_DTG                        ((uint16_t)0x00FF)            /*!<DTG[0:7] bits (Dead-Time Generator set-up) */
S#define  TIM_BDTR_DTG_0                      ((uint16_t)0x0001)            /*!<Bit 0 */
S#define  TIM_BDTR_DTG_1                      ((uint16_t)0x0002)            /*!<Bit 1 */
S#define  TIM_BDTR_DTG_2                      ((uint16_t)0x0004)            /*!<Bit 2 */
S#define  TIM_BDTR_DTG_3                      ((uint16_t)0x0008)            /*!<Bit 3 */
S#define  TIM_BDTR_DTG_4                      ((uint16_t)0x0010)            /*!<Bit 4 */
S#define  TIM_BDTR_DTG_5                      ((uint16_t)0x0020)            /*!<Bit 5 */
S#define  TIM_BDTR_DTG_6                      ((uint16_t)0x0040)            /*!<Bit 6 */
S#define  TIM_BDTR_DTG_7                      ((uint16_t)0x0080)            /*!<Bit 7 */
S
S#define  TIM_BDTR_LOCK                       ((uint16_t)0x0300)            /*!<LOCK[1:0] bits (Lock Configuration) */
S#define  TIM_BDTR_LOCK_0                     ((uint16_t)0x0100)            /*!<Bit 0 */
S#define  TIM_BDTR_LOCK_1                     ((uint16_t)0x0200)            /*!<Bit 1 */
S
S#define  TIM_BDTR_OSSI                       ((uint16_t)0x0400)            /*!<Off-State Selection for Idle mode */
S#define  TIM_BDTR_OSSR                       ((uint16_t)0x0800)            /*!<Off-State Selection for Run mode  */
S#define  TIM_BDTR_BKE                        ((uint16_t)0x1000)            /*!<Break enable                      */
S#define  TIM_BDTR_BKP                        ((uint16_t)0x2000)            /*!<Break Polarity                    */
S#define  TIM_BDTR_AOE                        ((uint16_t)0x4000)            /*!<Automatic Output enable           */
S#define  TIM_BDTR_MOE                        ((uint16_t)0x8000)            /*!<Main Output enable                */
S
S/*******************  Bit definition for TIM_DCR register  ********************/
S#define  TIM_DCR_DBA                         ((uint16_t)0x001F)            /*!<DBA[4:0] bits (DMA Base Address) */
S#define  TIM_DCR_DBA_0                       ((uint16_t)0x0001)            /*!<Bit 0 */
S#define  TIM_DCR_DBA_1                       ((uint16_t)0x0002)            /*!<Bit 1 */
S#define  TIM_DCR_DBA_2                       ((uint16_t)0x0004)            /*!<Bit 2 */
S#define  TIM_DCR_DBA_3                       ((uint16_t)0x0008)            /*!<Bit 3 */
S#define  TIM_DCR_DBA_4                       ((uint16_t)0x0010)            /*!<Bit 4 */
S
S#define  TIM_DCR_DBL                         ((uint16_t)0x1F00)            /*!<DBL[4:0] bits (DMA Burst Length) */
S#define  TIM_DCR_DBL_0                       ((uint16_t)0x0100)            /*!<Bit 0 */
S#define  TIM_DCR_DBL_1                       ((uint16_t)0x0200)            /*!<Bit 1 */
S#define  TIM_DCR_DBL_2                       ((uint16_t)0x0400)            /*!<Bit 2 */
S#define  TIM_DCR_DBL_3                       ((uint16_t)0x0800)            /*!<Bit 3 */
S#define  TIM_DCR_DBL_4                       ((uint16_t)0x1000)            /*!<Bit 4 */
S
S/*******************  Bit definition for TIM_DMAR register  *******************/
S#define  TIM_DMAR_DMAB                       ((uint16_t)0xFFFF)            /*!<DMA register for burst accesses                    */
S
S/*******************  Bit definition for TIM_OR register  *********************/
S#define TIM_OR_TI4_RMP                       ((uint16_t)0x00C0)            /*!<TI4_RMP[1:0] bits (TIM5 Input 4 remap)             */
S#define TIM_OR_TI4_RMP_0                     ((uint16_t)0x0040)            /*!<Bit 0 */
S#define TIM_OR_TI4_RMP_1                     ((uint16_t)0x0080)            /*!<Bit 1 */
S#define TIM_OR_ITR1_RMP                      ((uint16_t)0x0C00)            /*!<ITR1_RMP[1:0] bits (TIM2 Internal trigger 1 remap) */
S#define TIM_OR_ITR1_RMP_0                    ((uint16_t)0x0400)            /*!<Bit 0 */
S#define TIM_OR_ITR1_RMP_1                    ((uint16_t)0x0800)            /*!<Bit 1 */
S
S#if defined(STM32F410xx) || defined(STM32F413_423xx)
S/******************************************************************************/
S/*                                                                            */
S/*                         Low Power Timer (LPTIM)                            */
S/*                                                                            */
S/******************************************************************************/
S/******************  Bit definition for LPTIM_ISR register  *******************/
S#define  LPTIM_ISR_CMPM                         ((uint32_t)0x00000001)            /*!< Compare match                       */
S#define  LPTIM_ISR_ARRM                         ((uint32_t)0x00000002)            /*!< Autoreload match                    */
S#define  LPTIM_ISR_EXTTRIG                      ((uint32_t)0x00000004)            /*!< External trigger edge event         */
S#define  LPTIM_ISR_CMPOK                        ((uint32_t)0x00000008)            /*!< Compare register update OK          */
S#define  LPTIM_ISR_ARROK                        ((uint32_t)0x00000010)            /*!< Autoreload register update OK       */
S#define  LPTIM_ISR_UP                           ((uint32_t)0x00000020)            /*!< Counter direction change down to up */
S#define  LPTIM_ISR_DOWN                         ((uint32_t)0x00000040)            /*!< Counter direction change up to down */
S
S/******************  Bit definition for LPTIM_ICR register  *******************/
S#define  LPTIM_ICR_CMPMCF                       ((uint32_t)0x00000001)            /*!< Compare match Clear Flag                       */
S#define  LPTIM_ICR_ARRMCF                       ((uint32_t)0x00000002)            /*!< Autoreload match Clear Flag                    */
S#define  LPTIM_ICR_EXTTRIGCF                    ((uint32_t)0x00000004)            /*!< External trigger edge event Clear Flag         */
S#define  LPTIM_ICR_CMPOKCF                      ((uint32_t)0x00000008)            /*!< Compare register update OK Clear Flag          */
S#define  LPTIM_ICR_ARROKCF                      ((uint32_t)0x00000010)            /*!< Autoreload register update OK Clear Flag       */
S#define  LPTIM_ICR_UPCF                         ((uint32_t)0x00000020)            /*!< Counter direction change down to up Clear Flag */
S#define  LPTIM_ICR_DOWNCF                       ((uint32_t)0x00000040)            /*!< Counter direction change up to down Clear Flag */
S
S/******************  Bit definition for LPTIM_IER register ********************/
S#define  LPTIM_IER_CMPMIE                       ((uint32_t)0x00000001)            /*!< Compare match Interrupt Enable                       */
S#define  LPTIM_IER_ARRMIE                       ((uint32_t)0x00000002)            /*!< Autoreload match Interrupt Enable                    */
S#define  LPTIM_IER_EXTTRIGIE                    ((uint32_t)0x00000004)            /*!< External trigger edge event Interrupt Enable         */
S#define  LPTIM_IER_CMPOKIE                      ((uint32_t)0x00000008)            /*!< Compare register update OK Interrupt Enable          */
S#define  LPTIM_IER_ARROKIE                      ((uint32_t)0x00000010)            /*!< Autoreload register update OK Interrupt Enable       */
S#define  LPTIM_IER_UPIE                         ((uint32_t)0x00000020)            /*!< Counter direction change down to up Interrupt Enable */
S#define  LPTIM_IER_DOWNIE                       ((uint32_t)0x00000040)            /*!< Counter direction change up to down Interrupt Enable */
S
S/******************  Bit definition for LPTIM_CFGR register *******************/
S#define  LPTIM_CFGR_CKSEL                       ((uint32_t)0x00000001)             /*!< Clock selector */
S
S#define  LPTIM_CFGR_CKPOL                       ((uint32_t)0x00000006)             /*!< CKPOL[1:0] bits (Clock polarity) */
S#define  LPTIM_CFGR_CKPOL_0                     ((uint32_t)0x00000002)             /*!< Bit 0 */
S#define  LPTIM_CFGR_CKPOL_1                     ((uint32_t)0x00000004)             /*!< Bit 1 */
S
S#define  LPTIM_CFGR_CKFLT                       ((uint32_t)0x00000018)             /*!< CKFLT[1:0] bits (Configurable digital filter for external clock) */
S#define  LPTIM_CFGR_CKFLT_0                     ((uint32_t)0x00000008)             /*!< Bit 0 */
S#define  LPTIM_CFGR_CKFLT_1                     ((uint32_t)0x00000010)             /*!< Bit 1 */
S
S#define  LPTIM_CFGR_TRGFLT                      ((uint32_t)0x000000C0)             /*!< TRGFLT[1:0] bits (Configurable digital filter for trigger) */
S#define  LPTIM_CFGR_TRGFLT_0                    ((uint32_t)0x00000040)             /*!< Bit 0 */
S#define  LPTIM_CFGR_TRGFLT_1                    ((uint32_t)0x00000080)             /*!< Bit 1 */
S
S#define  LPTIM_CFGR_PRESC                       ((uint32_t)0x00000E00)             /*!< PRESC[2:0] bits (Clock prescaler) */
S#define  LPTIM_CFGR_PRESC_0                     ((uint32_t)0x00000200)             /*!< Bit 0 */
S#define  LPTIM_CFGR_PRESC_1                     ((uint32_t)0x00000400)             /*!< Bit 1 */
S#define  LPTIM_CFGR_PRESC_2                     ((uint32_t)0x00000800)             /*!< Bit 2 */
S
S#define  LPTIM_CFGR_TRIGSEL                     ((uint32_t)0x0000E000)             /*!< TRIGSEL[2:0]] bits (Trigger selector) */
S#define  LPTIM_CFGR_TRIGSEL_0                   ((uint32_t)0x00002000)             /*!< Bit 0 */
S#define  LPTIM_CFGR_TRIGSEL_1                   ((uint32_t)0x00004000)             /*!< Bit 1 */
S#define  LPTIM_CFGR_TRIGSEL_2                   ((uint32_t)0x00008000)             /*!< Bit 2 */
S
S#define  LPTIM_CFGR_TRIGEN                      ((uint32_t)0x00060000)             /*!< TRIGEN[1:0] bits (Trigger enable and polarity) */
S#define  LPTIM_CFGR_TRIGEN_0                    ((uint32_t)0x00020000)             /*!< Bit 0 */
S#define  LPTIM_CFGR_TRIGEN_1                    ((uint32_t)0x00040000)             /*!< Bit 1 */
S
S#define  LPTIM_CFGR_TIMOUT                      ((uint32_t)0x00080000)             /*!< Timout enable           */
S#define  LPTIM_CFGR_WAVE                        ((uint32_t)0x00100000)             /*!< Waveform shape          */
S#define  LPTIM_CFGR_WAVPOL                      ((uint32_t)0x00200000)             /*!< Waveform shape polarity */
S#define  LPTIM_CFGR_PRELOAD                     ((uint32_t)0x00400000)             /*!< Reg update mode         */
S#define  LPTIM_CFGR_COUNTMODE                   ((uint32_t)0x00800000)             /*!< Counter mode enable     */     
S#define  LPTIM_CFGR_ENC                         ((uint32_t)0x01000000)             /*!< Encoder mode enable     */          
S
S/******************  Bit definition for LPTIM_CR register  ********************/
S#define  LPTIM_CR_ENABLE                        ((uint32_t)0x00000001)             /*!< LPTIMer enable                 */
S#define  LPTIM_CR_SNGSTRT                       ((uint32_t)0x00000002)             /*!< Timer start in single mode     */
S#define  LPTIM_CR_CNTSTRT                       ((uint32_t)0x00000004)             /*!< Timer start in continuous mode */
S
S/******************  Bit definition for LPTIM_CMP register  *******************/
S#define  LPTIM_CMP_CMP                          ((uint32_t)0x0000FFFF)             /*!< Compare register     */
S
S/******************  Bit definition for LPTIM_ARR register  *******************/
S#define  LPTIM_ARR_ARR                          ((uint32_t)0x0000FFFF)             /*!< Auto reload register */
S
S/******************  Bit definition for LPTIM_CNT register  *******************/
S#define  LPTIM_CNT_CNT                          ((uint32_t)0x0000FFFF)             /*!< Counter register     */
S
S/******************  Bit definition for LPTIM_OR register  *******************/
S#define  LPTIM_OR_OR                           ((uint32_t)0x00000003)               /*!< LPTIMER[1:0] bits (Remap selection) */
S#define  LPTIM_OR_OR_0                         ((uint32_t)0x00000001)               /*!< Bit 0 */
S#define  LPTIM_OR_OR_1                         ((uint32_t)0x00000002)               /*!< Bit 1 */
S#endif /* STM32F410xx || STM32F413_423xx */
S
S/******************************************************************************/
S/*                                                                            */
S/*         Universal Synchronous Asynchronous Receiver Transmitter            */
S/*                                                                            */
S/******************************************************************************/
S/*******************  Bit definition for USART_SR register  *******************/
S#define  USART_SR_PE                         ((uint16_t)0x0001)            /*!<Parity Error                 */
S#define  USART_SR_FE                         ((uint16_t)0x0002)            /*!<Framing Error                */
S#define  USART_SR_NE                         ((uint16_t)0x0004)            /*!<Noise Error Flag             */
S#define  USART_SR_ORE                        ((uint16_t)0x0008)            /*!<OverRun Error                */
S#define  USART_SR_IDLE                       ((uint16_t)0x0010)            /*!<IDLE line detected           */
S#define  USART_SR_RXNE                       ((uint16_t)0x0020)            /*!<Read Data Register Not Empty */
S#define  USART_SR_TC                         ((uint16_t)0x0040)            /*!<Transmission Complete        */
S#define  USART_SR_TXE                        ((uint16_t)0x0080)            /*!<Transmit Data Register Empty */
S#define  USART_SR_LBD                        ((uint16_t)0x0100)            /*!<LIN Break Detection Flag     */
S#define  USART_SR_CTS                        ((uint16_t)0x0200)            /*!<CTS Flag                     */
S
S/*******************  Bit definition for USART_DR register  *******************/
S#define  USART_DR_DR                         ((uint16_t)0x01FF)            /*!<Data value */
S
S/******************  Bit definition for USART_BRR register  *******************/
S#define  USART_BRR_DIV_Fraction              ((uint16_t)0x000F)            /*!<Fraction of USARTDIV */
S#define  USART_BRR_DIV_Mantissa              ((uint16_t)0xFFF0)            /*!<Mantissa of USARTDIV */
S
S/******************  Bit definition for USART_CR1 register  *******************/
S#define  USART_CR1_SBK                       ((uint16_t)0x0001)            /*!<Send Break                             */
S#define  USART_CR1_RWU                       ((uint16_t)0x0002)            /*!<Receiver wakeup                        */
S#define  USART_CR1_RE                        ((uint16_t)0x0004)            /*!<Receiver Enable                        */
S#define  USART_CR1_TE                        ((uint16_t)0x0008)            /*!<Transmitter Enable                     */
S#define  USART_CR1_IDLEIE                    ((uint16_t)0x0010)            /*!<IDLE Interrupt Enable                  */
S#define  USART_CR1_RXNEIE                    ((uint16_t)0x0020)            /*!<RXNE Interrupt Enable                  */
S#define  USART_CR1_TCIE                      ((uint16_t)0x0040)            /*!<Transmission Complete Interrupt Enable */
S#define  USART_CR1_TXEIE                     ((uint16_t)0x0080)            /*!<PE Interrupt Enable                    */
S#define  USART_CR1_PEIE                      ((uint16_t)0x0100)            /*!<PE Interrupt Enable                    */
S#define  USART_CR1_PS                        ((uint16_t)0x0200)            /*!<Parity Selection                       */
S#define  USART_CR1_PCE                       ((uint16_t)0x0400)            /*!<Parity Control Enable                  */
S#define  USART_CR1_WAKE                      ((uint16_t)0x0800)            /*!<Wakeup method                          */
S#define  USART_CR1_M                         ((uint16_t)0x1000)            /*!<Word length                            */
S#define  USART_CR1_UE                        ((uint16_t)0x2000)            /*!<USART Enable                           */
S#define  USART_CR1_OVER8                     ((uint16_t)0x8000)            /*!<USART Oversampling by 8 enable         */
S
S/******************  Bit definition for USART_CR2 register  *******************/
S#define  USART_CR2_ADD                       ((uint16_t)0x000F)            /*!<Address of the USART node            */
S#define  USART_CR2_LBDL                      ((uint16_t)0x0020)            /*!<LIN Break Detection Length           */
S#define  USART_CR2_LBDIE                     ((uint16_t)0x0040)            /*!<LIN Break Detection Interrupt Enable */
S#define  USART_CR2_LBCL                      ((uint16_t)0x0100)            /*!<Last Bit Clock pulse                 */
S#define  USART_CR2_CPHA                      ((uint16_t)0x0200)            /*!<Clock Phase                          */
S#define  USART_CR2_CPOL                      ((uint16_t)0x0400)            /*!<Clock Polarity                       */
S#define  USART_CR2_CLKEN                     ((uint16_t)0x0800)            /*!<Clock Enable                         */
S
S#define  USART_CR2_STOP                      ((uint16_t)0x3000)            /*!<STOP[1:0] bits (STOP bits) */
S#define  USART_CR2_STOP_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
S#define  USART_CR2_STOP_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
S
S#define  USART_CR2_LINEN                     ((uint16_t)0x4000)            /*!<LIN mode enable */
S
S/******************  Bit definition for USART_CR3 register  *******************/
S#define  USART_CR3_EIE                       ((uint16_t)0x0001)            /*!<Error Interrupt Enable      */
S#define  USART_CR3_IREN                      ((uint16_t)0x0002)            /*!<IrDA mode Enable            */
S#define  USART_CR3_IRLP                      ((uint16_t)0x0004)            /*!<IrDA Low-Power              */
S#define  USART_CR3_HDSEL                     ((uint16_t)0x0008)            /*!<Half-Duplex Selection       */
S#define  USART_CR3_NACK                      ((uint16_t)0x0010)            /*!<Smartcard NACK enable       */
S#define  USART_CR3_SCEN                      ((uint16_t)0x0020)            /*!<Smartcard mode enable       */
S#define  USART_CR3_DMAR                      ((uint16_t)0x0040)            /*!<DMA Enable Receiver         */
S#define  USART_CR3_DMAT                      ((uint16_t)0x0080)            /*!<DMA Enable Transmitter      */
S#define  USART_CR3_RTSE                      ((uint16_t)0x0100)            /*!<RTS Enable                  */
S#define  USART_CR3_CTSE                      ((uint16_t)0x0200)            /*!<CTS Enable                  */
S#define  USART_CR3_CTSIE                     ((uint16_t)0x0400)            /*!<CTS Interrupt Enable        */
S#define  USART_CR3_ONEBIT                    ((uint16_t)0x0800)            /*!<USART One bit method enable */
S
S/******************  Bit definition for USART_GTPR register  ******************/
S#define  USART_GTPR_PSC                      ((uint16_t)0x00FF)            /*!<PSC[7:0] bits (Prescaler value) */
S#define  USART_GTPR_PSC_0                    ((uint16_t)0x0001)            /*!<Bit 0 */
S#define  USART_GTPR_PSC_1                    ((uint16_t)0x0002)            /*!<Bit 1 */
S#define  USART_GTPR_PSC_2                    ((uint16_t)0x0004)            /*!<Bit 2 */
S#define  USART_GTPR_PSC_3                    ((uint16_t)0x0008)            /*!<Bit 3 */
S#define  USART_GTPR_PSC_4                    ((uint16_t)0x0010)            /*!<Bit 4 */
S#define  USART_GTPR_PSC_5                    ((uint16_t)0x0020)            /*!<Bit 5 */
S#define  USART_GTPR_PSC_6                    ((uint16_t)0x0040)            /*!<Bit 6 */
S#define  USART_GTPR_PSC_7                    ((uint16_t)0x0080)            /*!<Bit 7 */
S
S#define  USART_GTPR_GT                       ((uint16_t)0xFF00)            /*!<Guard time value */
S
S/******************************************************************************/
S/*                                                                            */
S/*                            Window WATCHDOG                                 */
S/*                                                                            */
S/******************************************************************************/
S/*******************  Bit definition for WWDG_CR register  ********************/
S#define  WWDG_CR_T                           ((uint8_t)0x7F)               /*!<T[6:0] bits (7-Bit counter (MSB to LSB)) */
S#define  WWDG_CR_T_0                         ((uint8_t)0x01)               /*!<Bit 0 */
S#define  WWDG_CR_T_1                         ((uint8_t)0x02)               /*!<Bit 1 */
S#define  WWDG_CR_T_2                         ((uint8_t)0x04)               /*!<Bit 2 */
S#define  WWDG_CR_T_3                         ((uint8_t)0x08)               /*!<Bit 3 */
S#define  WWDG_CR_T_4                         ((uint8_t)0x10)               /*!<Bit 4 */
S#define  WWDG_CR_T_5                         ((uint8_t)0x20)               /*!<Bit 5 */
S#define  WWDG_CR_T_6                         ((uint8_t)0x40)               /*!<Bit 6 */
S/* Legacy defines */
S#define  WWDG_CR_T0                          WWDG_CR_T_0
S#define  WWDG_CR_T1                          WWDG_CR_T_1
S#define  WWDG_CR_T2                          WWDG_CR_T_2
S#define  WWDG_CR_T3                          WWDG_CR_T_3
S#define  WWDG_CR_T4                          WWDG_CR_T_4
S#define  WWDG_CR_T5                          WWDG_CR_T_5
S#define  WWDG_CR_T6                          WWDG_CR_T_6
S
S#define  WWDG_CR_WDGA                        ((uint8_t)0x80)               /*!<Activation bit */
S
S/*******************  Bit definition for WWDG_CFR register  *******************/
S#define  WWDG_CFR_W                          ((uint16_t)0x007F)            /*!<W[6:0] bits (7-bit window value) */
S#define  WWDG_CFR_W_0                        ((uint16_t)0x0001)            /*!<Bit 0 */
S#define  WWDG_CFR_W_1                        ((uint16_t)0x0002)            /*!<Bit 1 */
S#define  WWDG_CFR_W_2                        ((uint16_t)0x0004)            /*!<Bit 2 */
S#define  WWDG_CFR_W_3                        ((uint16_t)0x0008)            /*!<Bit 3 */
S#define  WWDG_CFR_W_4                        ((uint16_t)0x0010)            /*!<Bit 4 */
S#define  WWDG_CFR_W_5                        ((uint16_t)0x0020)            /*!<Bit 5 */
S#define  WWDG_CFR_W_6                        ((uint16_t)0x0040)            /*!<Bit 6 */
S/* Legacy defines */
S#define  WWDG_CFR_W0                         WWDG_CFR_W_0
S#define  WWDG_CFR_W1                         WWDG_CFR_W_1
S#define  WWDG_CFR_W2                         WWDG_CFR_W_2
S#define  WWDG_CFR_W3                         WWDG_CFR_W_3
S#define  WWDG_CFR_W4                         WWDG_CFR_W_4
S#define  WWDG_CFR_W5                         WWDG_CFR_W_5
S#define  WWDG_CFR_W6                         WWDG_CFR_W_6
S
S#define  WWDG_CFR_WDGTB                      ((uint16_t)0x0180)            /*!<WDGTB[1:0] bits (Timer Base) */
S#define  WWDG_CFR_WDGTB_0                    ((uint16_t)0x0080)            /*!<Bit 0 */
S#define  WWDG_CFR_WDGTB_1                    ((uint16_t)0x0100)            /*!<Bit 1 */
S/* Legacy defines */
S#define  WWDG_CFR_WDGTB0                     WWDG_CFR_WDGTB_0
S#define  WWDG_CFR_WDGTB1                     WWDG_CFR_WDGTB_1
S
S#define  WWDG_CFR_EWI                        ((uint16_t)0x0200)            /*!<Early Wakeup Interrupt */
S
S/*******************  Bit definition for WWDG_SR register  ********************/
S#define  WWDG_SR_EWIF                        ((uint8_t)0x01)               /*!<Early Wakeup Interrupt Flag */
S
S
S/******************************************************************************/
S/*                                                                            */
S/*                                DBG                                         */
S/*                                                                            */
S/******************************************************************************/
S/********************  Bit definition for DBGMCU_IDCODE register  *************/
S#define  DBGMCU_IDCODE_DEV_ID                ((uint32_t)0x00000FFF)
S#define  DBGMCU_IDCODE_REV_ID                ((uint32_t)0xFFFF0000)
S
S/********************  Bit definition for DBGMCU_CR register  *****************/
S#define  DBGMCU_CR_DBG_SLEEP                 ((uint32_t)0x00000001)
S#define  DBGMCU_CR_DBG_STOP                  ((uint32_t)0x00000002)
S#define  DBGMCU_CR_DBG_STANDBY               ((uint32_t)0x00000004)
S#define  DBGMCU_CR_TRACE_IOEN                ((uint32_t)0x00000020)
S
S#define  DBGMCU_CR_TRACE_MODE                ((uint32_t)0x000000C0)
S#define  DBGMCU_CR_TRACE_MODE_0              ((uint32_t)0x00000040)/*!<Bit 0 */
S#define  DBGMCU_CR_TRACE_MODE_1              ((uint32_t)0x00000080)/*!<Bit 1 */
S
S/********************  Bit definition for DBGMCU_APB1_FZ register  ************/
S#define  DBGMCU_APB1_FZ_DBG_TIM2_STOP            ((uint32_t)0x00000001)
S#define  DBGMCU_APB1_FZ_DBG_TIM3_STOP            ((uint32_t)0x00000002)
S#define  DBGMCU_APB1_FZ_DBG_TIM4_STOP            ((uint32_t)0x00000004)
S#define  DBGMCU_APB1_FZ_DBG_TIM5_STOP            ((uint32_t)0x00000008)
S#define  DBGMCU_APB1_FZ_DBG_TIM6_STOP            ((uint32_t)0x00000010)
S#define  DBGMCU_APB1_FZ_DBG_TIM7_STOP            ((uint32_t)0x00000020)
S#define  DBGMCU_APB1_FZ_DBG_TIM12_STOP           ((uint32_t)0x00000040)
S#define  DBGMCU_APB1_FZ_DBG_TIM13_STOP           ((uint32_t)0x00000080)
S#define  DBGMCU_APB1_FZ_DBG_TIM14_STOP           ((uint32_t)0x00000100)
S#define  DBGMCU_APB1_FZ_DBG_RTC_STOP             ((uint32_t)0x00000400)
S#define  DBGMCU_APB1_FZ_DBG_WWDG_STOP            ((uint32_t)0x00000800)
S#define  DBGMCU_APB1_FZ_DBG_IWDG_STOP            ((uint32_t)0x00001000)
S#define  DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT   ((uint32_t)0x00200000)
S#define  DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT   ((uint32_t)0x00400000)
S#define  DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT   ((uint32_t)0x00800000)
S#define  DBGMCU_APB1_FZ_DBG_CAN1_STOP            ((uint32_t)0x02000000)
S#define  DBGMCU_APB1_FZ_DBG_CAN2_STOP            ((uint32_t)0x04000000)
S/* Old IWDGSTOP bit definition, maintained for legacy purpose */
S#define  DBGMCU_APB1_FZ_DBG_IWDEG_STOP           DBGMCU_APB1_FZ_DBG_IWDG_STOP
S
S/********************  Bit definition for DBGMCU_APB1_FZ register  ************/
S#define  DBGMCU_APB1_FZ_DBG_TIM1_STOP        ((uint32_t)0x00000001)
S#define  DBGMCU_APB1_FZ_DBG_TIM8_STOP        ((uint32_t)0x00000002)
S#define  DBGMCU_APB1_FZ_DBG_TIM9_STOP        ((uint32_t)0x00010000)
S#define  DBGMCU_APB1_FZ_DBG_TIM10_STOP       ((uint32_t)0x00020000)
S#define  DBGMCU_APB1_FZ_DBG_TIM11_STOP       ((uint32_t)0x00040000)
S
S/******************************************************************************/
S/*                                                                            */
S/*                Ethernet MAC Registers bits definitions                     */
S/*                                                                            */
S/******************************************************************************/
S/* Bit definition for Ethernet MAC Control Register register */
S#define ETH_MACCR_WD      ((uint32_t)0x00800000)  /* Watchdog disable */
S#define ETH_MACCR_JD      ((uint32_t)0x00400000)  /* Jabber disable */
S#define ETH_MACCR_IFG     ((uint32_t)0x000E0000)  /* Inter-frame gap */
S#define ETH_MACCR_IFG_96Bit     ((uint32_t)0x00000000)  /* Minimum IFG between frames during transmission is 96Bit */
S  #define ETH_MACCR_IFG_88Bit     ((uint32_t)0x00020000)  /* Minimum IFG between frames during transmission is 88Bit */
S  #define ETH_MACCR_IFG_80Bit     ((uint32_t)0x00040000)  /* Minimum IFG between frames during transmission is 80Bit */
S  #define ETH_MACCR_IFG_72Bit     ((uint32_t)0x00060000)  /* Minimum IFG between frames during transmission is 72Bit */
S  #define ETH_MACCR_IFG_64Bit     ((uint32_t)0x00080000)  /* Minimum IFG between frames during transmission is 64Bit */        
S  #define ETH_MACCR_IFG_56Bit     ((uint32_t)0x000A0000)  /* Minimum IFG between frames during transmission is 56Bit */
S  #define ETH_MACCR_IFG_48Bit     ((uint32_t)0x000C0000)  /* Minimum IFG between frames during transmission is 48Bit */
S  #define ETH_MACCR_IFG_40Bit     ((uint32_t)0x000E0000)  /* Minimum IFG between frames during transmission is 40Bit */              
S#define ETH_MACCR_CSD     ((uint32_t)0x00010000)  /* Carrier sense disable (during transmission) */
S#define ETH_MACCR_FES     ((uint32_t)0x00004000)  /* Fast ethernet speed */
S#define ETH_MACCR_ROD     ((uint32_t)0x00002000)  /* Receive own disable */
S#define ETH_MACCR_LM      ((uint32_t)0x00001000)  /* loopback mode */
S#define ETH_MACCR_DM      ((uint32_t)0x00000800)  /* Duplex mode */
S#define ETH_MACCR_IPCO    ((uint32_t)0x00000400)  /* IP Checksum offload */
S#define ETH_MACCR_RD      ((uint32_t)0x00000200)  /* Retry disable */
S#define ETH_MACCR_APCS    ((uint32_t)0x00000080)  /* Automatic Pad/CRC stripping */
S#define ETH_MACCR_BL      ((uint32_t)0x00000060)  /* Back-off limit: random integer number (r) of slot time delays before rescheduling
S                                                       a transmission attempt during retries after a collision: 0 =< r <2^k */
S  #define ETH_MACCR_BL_10    ((uint32_t)0x00000000)  /* k = min (n, 10) */
S  #define ETH_MACCR_BL_8     ((uint32_t)0x00000020)  /* k = min (n, 8) */
S  #define ETH_MACCR_BL_4     ((uint32_t)0x00000040)  /* k = min (n, 4) */
S  #define ETH_MACCR_BL_1     ((uint32_t)0x00000060)  /* k = min (n, 1) */ 
S#define ETH_MACCR_DC      ((uint32_t)0x00000010)  /* Defferal check */
S#define ETH_MACCR_TE      ((uint32_t)0x00000008)  /* Transmitter enable */
S#define ETH_MACCR_RE      ((uint32_t)0x00000004)  /* Receiver enable */
S
S/* Bit definition for Ethernet MAC Frame Filter Register */
S#define ETH_MACFFR_RA     ((uint32_t)0x80000000)  /* Receive all */ 
S#define ETH_MACFFR_HPF    ((uint32_t)0x00000400)  /* Hash or perfect filter */ 
S#define ETH_MACFFR_SAF    ((uint32_t)0x00000200)  /* Source address filter enable */ 
S#define ETH_MACFFR_SAIF   ((uint32_t)0x00000100)  /* SA inverse filtering */ 
S#define ETH_MACFFR_PCF    ((uint32_t)0x000000C0)  /* Pass control frames: 3 cases */
S  #define ETH_MACFFR_PCF_BlockAll                ((uint32_t)0x00000040)  /* MAC filters all control frames from reaching the application */
S  #define ETH_MACFFR_PCF_ForwardAll              ((uint32_t)0x00000080)  /* MAC forwards all control frames to application even if they fail the Address Filter */
S  #define ETH_MACFFR_PCF_ForwardPassedAddrFilter ((uint32_t)0x000000C0)  /* MAC forwards control frames that pass the Address Filter. */ 
S#define ETH_MACFFR_BFD    ((uint32_t)0x00000020)  /* Broadcast frame disable */ 
S#define ETH_MACFFR_PAM    ((uint32_t)0x00000010)  /* Pass all mutlicast */ 
S#define ETH_MACFFR_DAIF   ((uint32_t)0x00000008)  /* DA Inverse filtering */ 
S#define ETH_MACFFR_HM     ((uint32_t)0x00000004)  /* Hash multicast */ 
S#define ETH_MACFFR_HU     ((uint32_t)0x00000002)  /* Hash unicast */
S#define ETH_MACFFR_PM     ((uint32_t)0x00000001)  /* Promiscuous mode */
S
S/* Bit definition for Ethernet MAC Hash Table High Register */
S#define ETH_MACHTHR_HTH   ((uint32_t)0xFFFFFFFF)  /* Hash table high */
S
S/* Bit definition for Ethernet MAC Hash Table Low Register */
S#define ETH_MACHTLR_HTL   ((uint32_t)0xFFFFFFFF)  /* Hash table low */
S
S/* Bit definition for Ethernet MAC MII Address Register */
S#define ETH_MACMIIAR_PA   ((uint32_t)0x0000F800)  /* Physical layer address */ 
S#define ETH_MACMIIAR_MR   ((uint32_t)0x000007C0)  /* MII register in the selected PHY */ 
S#define ETH_MACMIIAR_CR   ((uint32_t)0x0000001C)  /* CR clock range: 6 cases */ 
S  #define ETH_MACMIIAR_CR_Div42   ((uint32_t)0x00000000)  /* HCLK:60-100 MHz; MDC clock= HCLK/42 */
S  #define ETH_MACMIIAR_CR_Div62   ((uint32_t)0x00000004)  /* HCLK:100-150 MHz; MDC clock= HCLK/62 */
S  #define ETH_MACMIIAR_CR_Div16   ((uint32_t)0x00000008)  /* HCLK:20-35 MHz; MDC clock= HCLK/16 */
S  #define ETH_MACMIIAR_CR_Div26   ((uint32_t)0x0000000C)  /* HCLK:35-60 MHz; MDC clock= HCLK/26 */
S  #define ETH_MACMIIAR_CR_Div102  ((uint32_t)0x00000010)  /* HCLK:150-168 MHz; MDC clock= HCLK/102 */  
S#define ETH_MACMIIAR_MW   ((uint32_t)0x00000002)  /* MII write */ 
S#define ETH_MACMIIAR_MB   ((uint32_t)0x00000001)  /* MII busy */ 
S  
S/* Bit definition for Ethernet MAC MII Data Register */
S#define ETH_MACMIIDR_MD   ((uint32_t)0x0000FFFF)  /* MII data: read/write data from/to PHY */
S
S/* Bit definition for Ethernet MAC Flow Control Register */
S#define ETH_MACFCR_PT     ((uint32_t)0xFFFF0000)  /* Pause time */
S#define ETH_MACFCR_ZQPD   ((uint32_t)0x00000080)  /* Zero-quanta pause disable */
S#define ETH_MACFCR_PLT    ((uint32_t)0x00000030)  /* Pause low threshold: 4 cases */
S  #define ETH_MACFCR_PLT_Minus4   ((uint32_t)0x00000000)  /* Pause time minus 4 slot times */
S  #define ETH_MACFCR_PLT_Minus28  ((uint32_t)0x00000010)  /* Pause time minus 28 slot times */
S  #define ETH_MACFCR_PLT_Minus144 ((uint32_t)0x00000020)  /* Pause time minus 144 slot times */
S  #define ETH_MACFCR_PLT_Minus256 ((uint32_t)0x00000030)  /* Pause time minus 256 slot times */      
S#define ETH_MACFCR_UPFD   ((uint32_t)0x00000008)  /* Unicast pause frame detect */
S#define ETH_MACFCR_RFCE   ((uint32_t)0x00000004)  /* Receive flow control enable */
S#define ETH_MACFCR_TFCE   ((uint32_t)0x00000002)  /* Transmit flow control enable */
S#define ETH_MACFCR_FCBBPA ((uint32_t)0x00000001)  /* Flow control busy/backpressure activate */
S
S/* Bit definition for Ethernet MAC VLAN Tag Register */
S#define ETH_MACVLANTR_VLANTC ((uint32_t)0x00010000)  /* 12-bit VLAN tag comparison */
S#define ETH_MACVLANTR_VLANTI ((uint32_t)0x0000FFFF)  /* VLAN tag identifier (for receive frames) */
S
S/* Bit definition for Ethernet MAC Remote Wake-UpFrame Filter Register */ 
S#define ETH_MACRWUFFR_D   ((uint32_t)0xFFFFFFFF)  /* Wake-up frame filter register data */
S/* Eight sequential Writes to this address (offset 0x28) will write all Wake-UpFrame Filter Registers.
S   Eight sequential Reads from this address (offset 0x28) will read all Wake-UpFrame Filter Registers. */
S/* Wake-UpFrame Filter Reg0 : Filter 0 Byte Mask
S   Wake-UpFrame Filter Reg1 : Filter 1 Byte Mask
S   Wake-UpFrame Filter Reg2 : Filter 2 Byte Mask
S   Wake-UpFrame Filter Reg3 : Filter 3 Byte Mask
S   Wake-UpFrame Filter Reg4 : RSVD - Filter3 Command - RSVD - Filter2 Command - 
S                              RSVD - Filter1 Command - RSVD - Filter0 Command
S   Wake-UpFrame Filter Re5 : Filter3 Offset - Filter2 Offset - Filter1 Offset - Filter0 Offset
S   Wake-UpFrame Filter Re6 : Filter1 CRC16 - Filter0 CRC16
S   Wake-UpFrame Filter Re7 : Filter3 CRC16 - Filter2 CRC16 */
S
S/* Bit definition for Ethernet MAC PMT Control and Status Register */ 
S#define ETH_MACPMTCSR_WFFRPR ((uint32_t)0x80000000)  /* Wake-Up Frame Filter Register Pointer Reset */
S#define ETH_MACPMTCSR_GU     ((uint32_t)0x00000200)  /* Global Unicast */
S#define ETH_MACPMTCSR_WFR    ((uint32_t)0x00000040)  /* Wake-Up Frame Received */
S#define ETH_MACPMTCSR_MPR    ((uint32_t)0x00000020)  /* Magic Packet Received */
S#define ETH_MACPMTCSR_WFE    ((uint32_t)0x00000004)  /* Wake-Up Frame Enable */
S#define ETH_MACPMTCSR_MPE    ((uint32_t)0x00000002)  /* Magic Packet Enable */
S#define ETH_MACPMTCSR_PD     ((uint32_t)0x00000001)  /* Power Down */
S
S/* Bit definition for Ethernet MAC Status Register */
S#define ETH_MACSR_TSTS      ((uint32_t)0x00000200)  /* Time stamp trigger status */
S#define ETH_MACSR_MMCTS     ((uint32_t)0x00000040)  /* MMC transmit status */
S#define ETH_MACSR_MMMCRS    ((uint32_t)0x00000020)  /* MMC receive status */
S#define ETH_MACSR_MMCS      ((uint32_t)0x00000010)  /* MMC status */
S#define ETH_MACSR_PMTS      ((uint32_t)0x00000008)  /* PMT status */
S
S/* Bit definition for Ethernet MAC Interrupt Mask Register */
S#define ETH_MACIMR_TSTIM     ((uint32_t)0x00000200)  /* Time stamp trigger interrupt mask */
S#define ETH_MACIMR_PMTIM     ((uint32_t)0x00000008)  /* PMT interrupt mask */
S
S/* Bit definition for Ethernet MAC Address0 High Register */
S#define ETH_MACA0HR_MACA0H   ((uint32_t)0x0000FFFF)  /* MAC address0 high */
S
S/* Bit definition for Ethernet MAC Address0 Low Register */
S#define ETH_MACA0LR_MACA0L   ((uint32_t)0xFFFFFFFF)  /* MAC address0 low */
S
S/* Bit definition for Ethernet MAC Address1 High Register */
S#define ETH_MACA1HR_AE       ((uint32_t)0x80000000)  /* Address enable */
S#define ETH_MACA1HR_SA       ((uint32_t)0x40000000)  /* Source address */
S#define ETH_MACA1HR_MBC      ((uint32_t)0x3F000000)  /* Mask byte control: bits to mask for comparison of the MAC Address bytes */
S  #define ETH_MACA1HR_MBC_HBits15_8    ((uint32_t)0x20000000)  /* Mask MAC Address high reg bits [15:8] */
S  #define ETH_MACA1HR_MBC_HBits7_0     ((uint32_t)0x10000000)  /* Mask MAC Address high reg bits [7:0] */
S  #define ETH_MACA1HR_MBC_LBits31_24   ((uint32_t)0x08000000)  /* Mask MAC Address low reg bits [31:24] */
S  #define ETH_MACA1HR_MBC_LBits23_16   ((uint32_t)0x04000000)  /* Mask MAC Address low reg bits [23:16] */
S  #define ETH_MACA1HR_MBC_LBits15_8    ((uint32_t)0x02000000)  /* Mask MAC Address low reg bits [15:8] */
S  #define ETH_MACA1HR_MBC_LBits7_0     ((uint32_t)0x01000000)  /* Mask MAC Address low reg bits [7:0] */ 
S#define ETH_MACA1HR_MACA1H   ((uint32_t)0x0000FFFF)  /* MAC address1 high */
S
S/* Bit definition for Ethernet MAC Address1 Low Register */
S#define ETH_MACA1LR_MACA1L   ((uint32_t)0xFFFFFFFF)  /* MAC address1 low */
S
S/* Bit definition for Ethernet MAC Address2 High Register */
S#define ETH_MACA2HR_AE       ((uint32_t)0x80000000)  /* Address enable */
S#define ETH_MACA2HR_SA       ((uint32_t)0x40000000)  /* Source address */
S#define ETH_MACA2HR_MBC      ((uint32_t)0x3F000000)  /* Mask byte control */
S  #define ETH_MACA2HR_MBC_HBits15_8    ((uint32_t)0x20000000)  /* Mask MAC Address high reg bits [15:8] */
S  #define ETH_MACA2HR_MBC_HBits7_0     ((uint32_t)0x10000000)  /* Mask MAC Address high reg bits [7:0] */
S  #define ETH_MACA2HR_MBC_LBits31_24   ((uint32_t)0x08000000)  /* Mask MAC Address low reg bits [31:24] */
S  #define ETH_MACA2HR_MBC_LBits23_16   ((uint32_t)0x04000000)  /* Mask MAC Address low reg bits [23:16] */
S  #define ETH_MACA2HR_MBC_LBits15_8    ((uint32_t)0x02000000)  /* Mask MAC Address low reg bits [15:8] */
S  #define ETH_MACA2HR_MBC_LBits7_0     ((uint32_t)0x01000000)  /* Mask MAC Address low reg bits [70] */
S#define ETH_MACA2HR_MACA2H   ((uint32_t)0x0000FFFF)  /* MAC address1 high */
S
S/* Bit definition for Ethernet MAC Address2 Low Register */
S#define ETH_MACA2LR_MACA2L   ((uint32_t)0xFFFFFFFF)  /* MAC address2 low */
S
S/* Bit definition for Ethernet MAC Address3 High Register */
S#define ETH_MACA3HR_AE       ((uint32_t)0x80000000)  /* Address enable */
S#define ETH_MACA3HR_SA       ((uint32_t)0x40000000)  /* Source address */
S#define ETH_MACA3HR_MBC      ((uint32_t)0x3F000000)  /* Mask byte control */
S  #define ETH_MACA3HR_MBC_HBits15_8    ((uint32_t)0x20000000)  /* Mask MAC Address high reg bits [15:8] */
S  #define ETH_MACA3HR_MBC_HBits7_0     ((uint32_t)0x10000000)  /* Mask MAC Address high reg bits [7:0] */
S  #define ETH_MACA3HR_MBC_LBits31_24   ((uint32_t)0x08000000)  /* Mask MAC Address low reg bits [31:24] */
S  #define ETH_MACA3HR_MBC_LBits23_16   ((uint32_t)0x04000000)  /* Mask MAC Address low reg bits [23:16] */
S  #define ETH_MACA3HR_MBC_LBits15_8    ((uint32_t)0x02000000)  /* Mask MAC Address low reg bits [15:8] */
S  #define ETH_MACA3HR_MBC_LBits7_0     ((uint32_t)0x01000000)  /* Mask MAC Address low reg bits [70] */
S#define ETH_MACA3HR_MACA3H   ((uint32_t)0x0000FFFF)  /* MAC address3 high */
S
S/* Bit definition for Ethernet MAC Address3 Low Register */
S#define ETH_MACA3LR_MACA3L   ((uint32_t)0xFFFFFFFF)  /* MAC address3 low */
S
S/******************************************************************************/
S/*                Ethernet MMC Registers bits definition                      */
S/******************************************************************************/
S
S/* Bit definition for Ethernet MMC Contol Register */
S#define ETH_MMCCR_MCFHP      ((uint32_t)0x00000020)  /* MMC counter Full-Half preset */
S#define ETH_MMCCR_MCP        ((uint32_t)0x00000010)  /* MMC counter preset */
S#define ETH_MMCCR_MCF        ((uint32_t)0x00000008)  /* MMC Counter Freeze */
S#define ETH_MMCCR_ROR        ((uint32_t)0x00000004)  /* Reset on Read */
S#define ETH_MMCCR_CSR        ((uint32_t)0x00000002)  /* Counter Stop Rollover */
S#define ETH_MMCCR_CR         ((uint32_t)0x00000001)  /* Counters Reset */
S
S/* Bit definition for Ethernet MMC Receive Interrupt Register */
S#define ETH_MMCRIR_RGUFS     ((uint32_t)0x00020000)  /* Set when Rx good unicast frames counter reaches half the maximum value */
S#define ETH_MMCRIR_RFAES     ((uint32_t)0x00000040)  /* Set when Rx alignment error counter reaches half the maximum value */
S#define ETH_MMCRIR_RFCES     ((uint32_t)0x00000020)  /* Set when Rx crc error counter reaches half the maximum value */
S
S/* Bit definition for Ethernet MMC Transmit Interrupt Register */
S#define ETH_MMCTIR_TGFS      ((uint32_t)0x00200000)  /* Set when Tx good frame count counter reaches half the maximum value */
S#define ETH_MMCTIR_TGFMSCS   ((uint32_t)0x00008000)  /* Set when Tx good multi col counter reaches half the maximum value */
S#define ETH_MMCTIR_TGFSCS    ((uint32_t)0x00004000)  /* Set when Tx good single col counter reaches half the maximum value */
S
S/* Bit definition for Ethernet MMC Receive Interrupt Mask Register */
S#define ETH_MMCRIMR_RGUFM    ((uint32_t)0x00020000)  /* Mask the interrupt when Rx good unicast frames counter reaches half the maximum value */
S#define ETH_MMCRIMR_RFAEM    ((uint32_t)0x00000040)  /* Mask the interrupt when when Rx alignment error counter reaches half the maximum value */
S#define ETH_MMCRIMR_RFCEM    ((uint32_t)0x00000020)  /* Mask the interrupt when Rx crc error counter reaches half the maximum value */
S
S/* Bit definition for Ethernet MMC Transmit Interrupt Mask Register */
S#define ETH_MMCTIMR_TGFM     ((uint32_t)0x00200000)  /* Mask the interrupt when Tx good frame count counter reaches half the maximum value */
S#define ETH_MMCTIMR_TGFMSCM  ((uint32_t)0x00008000)  /* Mask the interrupt when Tx good multi col counter reaches half the maximum value */
S#define ETH_MMCTIMR_TGFSCM   ((uint32_t)0x00004000)  /* Mask the interrupt when Tx good single col counter reaches half the maximum value */
S
S/* Bit definition for Ethernet MMC Transmitted Good Frames after Single Collision Counter Register */
S#define ETH_MMCTGFSCCR_TGFSCC     ((uint32_t)0xFFFFFFFF)  /* Number of successfully transmitted frames after a single collision in Half-duplex mode. */
S
S/* Bit definition for Ethernet MMC Transmitted Good Frames after More than a Single Collision Counter Register */
S#define ETH_MMCTGFMSCCR_TGFMSCC   ((uint32_t)0xFFFFFFFF)  /* Number of successfully transmitted frames after more than a single collision in Half-duplex mode. */
S
S/* Bit definition for Ethernet MMC Transmitted Good Frames Counter Register */
S#define ETH_MMCTGFCR_TGFC    ((uint32_t)0xFFFFFFFF)  /* Number of good frames transmitted. */
S
S/* Bit definition for Ethernet MMC Received Frames with CRC Error Counter Register */
S#define ETH_MMCRFCECR_RFCEC  ((uint32_t)0xFFFFFFFF)  /* Number of frames received with CRC error. */
S
S/* Bit definition for Ethernet MMC Received Frames with Alignement Error Counter Register */
S#define ETH_MMCRFAECR_RFAEC  ((uint32_t)0xFFFFFFFF)  /* Number of frames received with alignment (dribble) error */
S
S/* Bit definition for Ethernet MMC Received Good Unicast Frames Counter Register */
S#define ETH_MMCRGUFCR_RGUFC  ((uint32_t)0xFFFFFFFF)  /* Number of good unicast frames received. */
S
S/******************************************************************************/
S/*               Ethernet PTP Registers bits definition                       */
S/******************************************************************************/
S
S/* Bit definition for Ethernet PTP Time Stamp Contol Register */
S#define ETH_PTPTSCR_TSCNT       ((uint32_t)0x00030000)  /* Time stamp clock node type */
S#define ETH_PTPTSSR_TSSMRME     ((uint32_t)0x00008000)  /* Time stamp snapshot for message relevant to master enable */
S#define ETH_PTPTSSR_TSSEME      ((uint32_t)0x00004000)  /* Time stamp snapshot for event message enable */
S#define ETH_PTPTSSR_TSSIPV4FE   ((uint32_t)0x00002000)  /* Time stamp snapshot for IPv4 frames enable */
S#define ETH_PTPTSSR_TSSIPV6FE   ((uint32_t)0x00001000)  /* Time stamp snapshot for IPv6 frames enable */
S#define ETH_PTPTSSR_TSSPTPOEFE  ((uint32_t)0x00000800)  /* Time stamp snapshot for PTP over ethernet frames enable */
S#define ETH_PTPTSSR_TSPTPPSV2E  ((uint32_t)0x00000400)  /* Time stamp PTP packet snooping for version2 format enable */
S#define ETH_PTPTSSR_TSSSR       ((uint32_t)0x00000200)  /* Time stamp Sub-seconds rollover */
S#define ETH_PTPTSSR_TSSARFE     ((uint32_t)0x00000100)  /* Time stamp snapshot for all received frames enable */
S
S#define ETH_PTPTSCR_TSARU    ((uint32_t)0x00000020)  /* Addend register update */
S#define ETH_PTPTSCR_TSITE    ((uint32_t)0x00000010)  /* Time stamp interrupt trigger enable */
S#define ETH_PTPTSCR_TSSTU    ((uint32_t)0x00000008)  /* Time stamp update */
S#define ETH_PTPTSCR_TSSTI    ((uint32_t)0x00000004)  /* Time stamp initialize */
S#define ETH_PTPTSCR_TSFCU    ((uint32_t)0x00000002)  /* Time stamp fine or coarse update */
S#define ETH_PTPTSCR_TSE      ((uint32_t)0x00000001)  /* Time stamp enable */
S
S/* Bit definition for Ethernet PTP Sub-Second Increment Register */
S#define ETH_PTPSSIR_STSSI    ((uint32_t)0x000000FF)  /* System time Sub-second increment value */
S
S/* Bit definition for Ethernet PTP Time Stamp High Register */
S#define ETH_PTPTSHR_STS      ((uint32_t)0xFFFFFFFF)  /* System Time second */
S
S/* Bit definition for Ethernet PTP Time Stamp Low Register */
S#define ETH_PTPTSLR_STPNS    ((uint32_t)0x80000000)  /* System Time Positive or negative time */
S#define ETH_PTPTSLR_STSS     ((uint32_t)0x7FFFFFFF)  /* System Time sub-seconds */
S
S/* Bit definition for Ethernet PTP Time Stamp High Update Register */
S#define ETH_PTPTSHUR_TSUS    ((uint32_t)0xFFFFFFFF)  /* Time stamp update seconds */
S
S/* Bit definition for Ethernet PTP Time Stamp Low Update Register */
S#define ETH_PTPTSLUR_TSUPNS  ((uint32_t)0x80000000)  /* Time stamp update Positive or negative time */
S#define ETH_PTPTSLUR_TSUSS   ((uint32_t)0x7FFFFFFF)  /* Time stamp update sub-seconds */
S
S/* Bit definition for Ethernet PTP Time Stamp Addend Register */
S#define ETH_PTPTSAR_TSA      ((uint32_t)0xFFFFFFFF)  /* Time stamp addend */
S
S/* Bit definition for Ethernet PTP Target Time High Register */
S#define ETH_PTPTTHR_TTSH     ((uint32_t)0xFFFFFFFF)  /* Target time stamp high */
S
S/* Bit definition for Ethernet PTP Target Time Low Register */
S#define ETH_PTPTTLR_TTSL     ((uint32_t)0xFFFFFFFF)  /* Target time stamp low */
S
S/* Bit definition for Ethernet PTP Time Stamp Status Register */
S#define ETH_PTPTSSR_TSTTR    ((uint32_t)0x00000020)  /* Time stamp target time reached */
S#define ETH_PTPTSSR_TSSO     ((uint32_t)0x00000010)  /* Time stamp seconds overflow */
S
S/******************************************************************************/
S/*                 Ethernet DMA Registers bits definition                     */
S/******************************************************************************/
S
S/* Bit definition for Ethernet DMA Bus Mode Register */
S#define ETH_DMABMR_AAB       ((uint32_t)0x02000000)  /* Address-Aligned beats */
S#define ETH_DMABMR_FPM        ((uint32_t)0x01000000)  /* 4xPBL mode */
S#define ETH_DMABMR_USP       ((uint32_t)0x00800000)  /* Use separate PBL */
S#define ETH_DMABMR_RDP       ((uint32_t)0x007E0000)  /* RxDMA PBL */
S  #define ETH_DMABMR_RDP_1Beat    ((uint32_t)0x00020000)  /* maximum number of beats to be transferred in one RxDMA transaction is 1 */
S  #define ETH_DMABMR_RDP_2Beat    ((uint32_t)0x00040000)  /* maximum number of beats to be transferred in one RxDMA transaction is 2 */
S  #define ETH_DMABMR_RDP_4Beat    ((uint32_t)0x00080000)  /* maximum number of beats to be transferred in one RxDMA transaction is 4 */
S  #define ETH_DMABMR_RDP_8Beat    ((uint32_t)0x00100000)  /* maximum number of beats to be transferred in one RxDMA transaction is 8 */
S  #define ETH_DMABMR_RDP_16Beat   ((uint32_t)0x00200000)  /* maximum number of beats to be transferred in one RxDMA transaction is 16 */
S  #define ETH_DMABMR_RDP_32Beat   ((uint32_t)0x00400000)  /* maximum number of beats to be transferred in one RxDMA transaction is 32 */                
S  #define ETH_DMABMR_RDP_4xPBL_4Beat   ((uint32_t)0x01020000)  /* maximum number of beats to be transferred in one RxDMA transaction is 4 */
S  #define ETH_DMABMR_RDP_4xPBL_8Beat   ((uint32_t)0x01040000)  /* maximum number of beats to be transferred in one RxDMA transaction is 8 */
S  #define ETH_DMABMR_RDP_4xPBL_16Beat  ((uint32_t)0x01080000)  /* maximum number of beats to be transferred in one RxDMA transaction is 16 */
S  #define ETH_DMABMR_RDP_4xPBL_32Beat  ((uint32_t)0x01100000)  /* maximum number of beats to be transferred in one RxDMA transaction is 32 */
S  #define ETH_DMABMR_RDP_4xPBL_64Beat  ((uint32_t)0x01200000)  /* maximum number of beats to be transferred in one RxDMA transaction is 64 */
S  #define ETH_DMABMR_RDP_4xPBL_128Beat ((uint32_t)0x01400000)  /* maximum number of beats to be transferred in one RxDMA transaction is 128 */  
S#define ETH_DMABMR_FB        ((uint32_t)0x00010000)  /* Fixed Burst */
S#define ETH_DMABMR_RTPR      ((uint32_t)0x0000C000)  /* Rx Tx priority ratio */
S  #define ETH_DMABMR_RTPR_1_1     ((uint32_t)0x00000000)  /* Rx Tx priority ratio */
S  #define ETH_DMABMR_RTPR_2_1     ((uint32_t)0x00004000)  /* Rx Tx priority ratio */
S  #define ETH_DMABMR_RTPR_3_1     ((uint32_t)0x00008000)  /* Rx Tx priority ratio */
S  #define ETH_DMABMR_RTPR_4_1     ((uint32_t)0x0000C000)  /* Rx Tx priority ratio */  
S#define ETH_DMABMR_PBL    ((uint32_t)0x00003F00)  /* Programmable burst length */
S  #define ETH_DMABMR_PBL_1Beat    ((uint32_t)0x00000100)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 1 */
S  #define ETH_DMABMR_PBL_2Beat    ((uint32_t)0x00000200)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 2 */
S  #define ETH_DMABMR_PBL_4Beat    ((uint32_t)0x00000400)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */
S  #define ETH_DMABMR_PBL_8Beat    ((uint32_t)0x00000800)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */
S  #define ETH_DMABMR_PBL_16Beat   ((uint32_t)0x00001000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */
S  #define ETH_DMABMR_PBL_32Beat   ((uint32_t)0x00002000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */                
S  #define ETH_DMABMR_PBL_4xPBL_4Beat   ((uint32_t)0x01000100)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */
S  #define ETH_DMABMR_PBL_4xPBL_8Beat   ((uint32_t)0x01000200)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */
S  #define ETH_DMABMR_PBL_4xPBL_16Beat  ((uint32_t)0x01000400)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */
S  #define ETH_DMABMR_PBL_4xPBL_32Beat  ((uint32_t)0x01000800)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */
S  #define ETH_DMABMR_PBL_4xPBL_64Beat  ((uint32_t)0x01001000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 64 */
S  #define ETH_DMABMR_PBL_4xPBL_128Beat ((uint32_t)0x01002000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 128 */
S#define ETH_DMABMR_EDE       ((uint32_t)0x00000080)  /* Enhanced Descriptor Enable */
S#define ETH_DMABMR_DSL       ((uint32_t)0x0000007C)  /* Descriptor Skip Length */
S#define ETH_DMABMR_DA        ((uint32_t)0x00000002)  /* DMA arbitration scheme */
S#define ETH_DMABMR_SR        ((uint32_t)0x00000001)  /* Software reset */
S
S/* Bit definition for Ethernet DMA Transmit Poll Demand Register */
S#define ETH_DMATPDR_TPD      ((uint32_t)0xFFFFFFFF)  /* Transmit poll demand */
S
S/* Bit definition for Ethernet DMA Receive Poll Demand Register */
S#define ETH_DMARPDR_RPD      ((uint32_t)0xFFFFFFFF)  /* Receive poll demand  */
S
S/* Bit definition for Ethernet DMA Receive Descriptor List Address Register */
S#define ETH_DMARDLAR_SRL     ((uint32_t)0xFFFFFFFF)  /* Start of receive list */
S
S/* Bit definition for Ethernet DMA Transmit Descriptor List Address Register */
S#define ETH_DMATDLAR_STL     ((uint32_t)0xFFFFFFFF)  /* Start of transmit list */
S
S/* Bit definition for Ethernet DMA Status Register */
S#define ETH_DMASR_TSTS       ((uint32_t)0x20000000)  /* Time-stamp trigger status */
S#define ETH_DMASR_PMTS       ((uint32_t)0x10000000)  /* PMT status */
S#define ETH_DMASR_MMCS       ((uint32_t)0x08000000)  /* MMC status */
S#define ETH_DMASR_EBS        ((uint32_t)0x03800000)  /* Error bits status */
S  /* combination with EBS[2:0] for GetFlagStatus function */
S  #define ETH_DMASR_EBS_DescAccess      ((uint32_t)0x02000000)  /* Error bits 0-data buffer, 1-desc. access */
S  #define ETH_DMASR_EBS_ReadTransf      ((uint32_t)0x01000000)  /* Error bits 0-write trnsf, 1-read transfr */
S  #define ETH_DMASR_EBS_DataTransfTx    ((uint32_t)0x00800000)  /* Error bits 0-Rx DMA, 1-Tx DMA */
S#define ETH_DMASR_TPS         ((uint32_t)0x00700000)  /* Transmit process state */
S  #define ETH_DMASR_TPS_Stopped         ((uint32_t)0x00000000)  /* Stopped - Reset or Stop Tx Command issued  */
S  #define ETH_DMASR_TPS_Fetching        ((uint32_t)0x00100000)  /* Running - fetching the Tx descriptor */
S  #define ETH_DMASR_TPS_Waiting         ((uint32_t)0x00200000)  /* Running - waiting for status */
S  #define ETH_DMASR_TPS_Reading         ((uint32_t)0x00300000)  /* Running - reading the data from host memory */
S  #define ETH_DMASR_TPS_Suspended       ((uint32_t)0x00600000)  /* Suspended - Tx Descriptor unavailabe */
S  #define ETH_DMASR_TPS_Closing         ((uint32_t)0x00700000)  /* Running - closing Rx descriptor */
S#define ETH_DMASR_RPS         ((uint32_t)0x000E0000)  /* Receive process state */
S  #define ETH_DMASR_RPS_Stopped         ((uint32_t)0x00000000)  /* Stopped - Reset or Stop Rx Command issued */
S  #define ETH_DMASR_RPS_Fetching        ((uint32_t)0x00020000)  /* Running - fetching the Rx descriptor */
S  #define ETH_DMASR_RPS_Waiting         ((uint32_t)0x00060000)  /* Running - waiting for packet */
S  #define ETH_DMASR_RPS_Suspended       ((uint32_t)0x00080000)  /* Suspended - Rx Descriptor unavailable */
S  #define ETH_DMASR_RPS_Closing         ((uint32_t)0x000A0000)  /* Running - closing descriptor */
S  #define ETH_DMASR_RPS_Queuing         ((uint32_t)0x000E0000)  /* Running - queuing the recieve frame into host memory */
S#define ETH_DMASR_NIS        ((uint32_t)0x00010000)  /* Normal interrupt summary */
S#define ETH_DMASR_AIS        ((uint32_t)0x00008000)  /* Abnormal interrupt summary */
S#define ETH_DMASR_ERS        ((uint32_t)0x00004000)  /* Early receive status */
S#define ETH_DMASR_FBES       ((uint32_t)0x00002000)  /* Fatal bus error status */
S#define ETH_DMASR_ETS        ((uint32_t)0x00000400)  /* Early transmit status */
S#define ETH_DMASR_RWTS       ((uint32_t)0x00000200)  /* Receive watchdog timeout status */
S#define ETH_DMASR_RPSS       ((uint32_t)0x00000100)  /* Receive process stopped status */
S#define ETH_DMASR_RBUS       ((uint32_t)0x00000080)  /* Receive buffer unavailable status */
S#define ETH_DMASR_RS         ((uint32_t)0x00000040)  /* Receive status */
S#define ETH_DMASR_TUS        ((uint32_t)0x00000020)  /* Transmit underflow status */
S#define ETH_DMASR_ROS        ((uint32_t)0x00000010)  /* Receive overflow status */
S#define ETH_DMASR_TJTS       ((uint32_t)0x00000008)  /* Transmit jabber timeout status */
S#define ETH_DMASR_TBUS       ((uint32_t)0x00000004)  /* Transmit buffer unavailable status */
S#define ETH_DMASR_TPSS       ((uint32_t)0x00000002)  /* Transmit process stopped status */
S#define ETH_DMASR_TS         ((uint32_t)0x00000001)  /* Transmit status */
S
S/* Bit definition for Ethernet DMA Operation Mode Register */
S#define ETH_DMAOMR_DTCEFD    ((uint32_t)0x04000000)  /* Disable Dropping of TCP/IP checksum error frames */
S#define ETH_DMAOMR_RSF       ((uint32_t)0x02000000)  /* Receive store and forward */
S#define ETH_DMAOMR_DFRF      ((uint32_t)0x01000000)  /* Disable flushing of received frames */
S#define ETH_DMAOMR_TSF       ((uint32_t)0x00200000)  /* Transmit store and forward */
S#define ETH_DMAOMR_FTF       ((uint32_t)0x00100000)  /* Flush transmit FIFO */
S#define ETH_DMAOMR_TTC       ((uint32_t)0x0001C000)  /* Transmit threshold control */
S  #define ETH_DMAOMR_TTC_64Bytes       ((uint32_t)0x00000000)  /* threshold level of the MTL Transmit FIFO is 64 Bytes */
S  #define ETH_DMAOMR_TTC_128Bytes      ((uint32_t)0x00004000)  /* threshold level of the MTL Transmit FIFO is 128 Bytes */
S  #define ETH_DMAOMR_TTC_192Bytes      ((uint32_t)0x00008000)  /* threshold level of the MTL Transmit FIFO is 192 Bytes */
S  #define ETH_DMAOMR_TTC_256Bytes      ((uint32_t)0x0000C000)  /* threshold level of the MTL Transmit FIFO is 256 Bytes */
S  #define ETH_DMAOMR_TTC_40Bytes       ((uint32_t)0x00010000)  /* threshold level of the MTL Transmit FIFO is 40 Bytes */
S  #define ETH_DMAOMR_TTC_32Bytes       ((uint32_t)0x00014000)  /* threshold level of the MTL Transmit FIFO is 32 Bytes */
S  #define ETH_DMAOMR_TTC_24Bytes       ((uint32_t)0x00018000)  /* threshold level of the MTL Transmit FIFO is 24 Bytes */
S  #define ETH_DMAOMR_TTC_16Bytes       ((uint32_t)0x0001C000)  /* threshold level of the MTL Transmit FIFO is 16 Bytes */
S#define ETH_DMAOMR_ST        ((uint32_t)0x00002000)  /* Start/stop transmission command */
S#define ETH_DMAOMR_FEF       ((uint32_t)0x00000080)  /* Forward error frames */
S#define ETH_DMAOMR_FUGF      ((uint32_t)0x00000040)  /* Forward undersized good frames */
S#define ETH_DMAOMR_RTC       ((uint32_t)0x00000018)  /* receive threshold control */
S  #define ETH_DMAOMR_RTC_64Bytes       ((uint32_t)0x00000000)  /* threshold level of the MTL Receive FIFO is 64 Bytes */
S  #define ETH_DMAOMR_RTC_32Bytes       ((uint32_t)0x00000008)  /* threshold level of the MTL Receive FIFO is 32 Bytes */
S  #define ETH_DMAOMR_RTC_96Bytes       ((uint32_t)0x00000010)  /* threshold level of the MTL Receive FIFO is 96 Bytes */
S  #define ETH_DMAOMR_RTC_128Bytes      ((uint32_t)0x00000018)  /* threshold level of the MTL Receive FIFO is 128 Bytes */
S#define ETH_DMAOMR_OSF       ((uint32_t)0x00000004)  /* operate on second frame */
S#define ETH_DMAOMR_SR        ((uint32_t)0x00000002)  /* Start/stop receive */
S
S/* Bit definition for Ethernet DMA Interrupt Enable Register */
S#define ETH_DMAIER_NISE      ((uint32_t)0x00010000)  /* Normal interrupt summary enable */
S#define ETH_DMAIER_AISE      ((uint32_t)0x00008000)  /* Abnormal interrupt summary enable */
S#define ETH_DMAIER_ERIE      ((uint32_t)0x00004000)  /* Early receive interrupt enable */
S#define ETH_DMAIER_FBEIE     ((uint32_t)0x00002000)  /* Fatal bus error interrupt enable */
S#define ETH_DMAIER_ETIE      ((uint32_t)0x00000400)  /* Early transmit interrupt enable */
S#define ETH_DMAIER_RWTIE     ((uint32_t)0x00000200)  /* Receive watchdog timeout interrupt enable */
S#define ETH_DMAIER_RPSIE     ((uint32_t)0x00000100)  /* Receive process stopped interrupt enable */
S#define ETH_DMAIER_RBUIE     ((uint32_t)0x00000080)  /* Receive buffer unavailable interrupt enable */
S#define ETH_DMAIER_RIE       ((uint32_t)0x00000040)  /* Receive interrupt enable */
S#define ETH_DMAIER_TUIE      ((uint32_t)0x00000020)  /* Transmit Underflow interrupt enable */
S#define ETH_DMAIER_ROIE      ((uint32_t)0x00000010)  /* Receive Overflow interrupt enable */
S#define ETH_DMAIER_TJTIE     ((uint32_t)0x00000008)  /* Transmit jabber timeout interrupt enable */
S#define ETH_DMAIER_TBUIE     ((uint32_t)0x00000004)  /* Transmit buffer unavailable interrupt enable */
S#define ETH_DMAIER_TPSIE     ((uint32_t)0x00000002)  /* Transmit process stopped interrupt enable */
S#define ETH_DMAIER_TIE       ((uint32_t)0x00000001)  /* Transmit interrupt enable */
S
S/* Bit definition for Ethernet DMA Missed Frame and Buffer Overflow Counter Register */
S#define ETH_DMAMFBOCR_OFOC   ((uint32_t)0x10000000)  /* Overflow bit for FIFO overflow counter */
S#define ETH_DMAMFBOCR_MFA    ((uint32_t)0x0FFE0000)  /* Number of frames missed by the application */
S#define ETH_DMAMFBOCR_OMFC   ((uint32_t)0x00010000)  /* Overflow bit for missed frame counter */
S#define ETH_DMAMFBOCR_MFC    ((uint32_t)0x0000FFFF)  /* Number of frames missed by the controller */
S
S/* Bit definition for Ethernet DMA Current Host Transmit Descriptor Register */
S#define ETH_DMACHTDR_HTDAP   ((uint32_t)0xFFFFFFFF)  /* Host transmit descriptor address pointer */
S
S/* Bit definition for Ethernet DMA Current Host Receive Descriptor Register */
S#define ETH_DMACHRDR_HRDAP   ((uint32_t)0xFFFFFFFF)  /* Host receive descriptor address pointer */
S
S/* Bit definition for Ethernet DMA Current Host Transmit Buffer Address Register */
S#define ETH_DMACHTBAR_HTBAP  ((uint32_t)0xFFFFFFFF)  /* Host transmit buffer address pointer */
S
S/* Bit definition for Ethernet DMA Current Host Receive Buffer Address Register */
S#define ETH_DMACHRBAR_HRBAP  ((uint32_t)0xFFFFFFFF)  /* Host receive buffer address pointer */
S
S/**
S  *
S  */
S
S /**
S  * @}
S  */ 
S
S#ifdef USE_STDPERIPH_DRIVER
S  #include "stm32f4xx_conf.h"
S#endif /* USE_STDPERIPH_DRIVER */
S
S/** @addtogroup Exported_macro
S  * @{
S  */
S
S#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
S
S#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
S
S#define READ_BIT(REG, BIT)    ((REG) & (BIT))
S
S#define CLEAR_REG(REG)        ((REG) = (0x0))
S
S#define WRITE_REG(REG, VAL)   ((REG) = (VAL))
S
S#define READ_REG(REG)         ((REG))
S
S#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
S
S/**
S  * @}
S  */
S
S#ifdef __cplusplus
S}
S#endif /* __cplusplus */
S
N#endif /* __STM32F4xx_H */
N
N/**
N  * @}
N  */
N
N  /**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 39 "..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\stm32f4xx_adc.h" 2
N
N/** @addtogroup STM32F4xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup ADC
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief   ADC Init structure definition  
N  */ 
Ntypedef struct
N{
N  uint32_t ADC_Resolution;                /*!< Configures the ADC resolution dual mode. 
N                                               This parameter can be a value of @ref ADC_resolution */                                   
N  FunctionalState ADC_ScanConvMode;       /*!< Specifies whether the conversion 
N                                               is performed in Scan (multichannels) 
N                                               or Single (one channel) mode.
N                                               This parameter can be set to ENABLE or DISABLE */ 
N  FunctionalState ADC_ContinuousConvMode; /*!< Specifies whether the conversion 
N                                               is performed in Continuous or Single mode.
N                                               This parameter can be set to ENABLE or DISABLE. */
N  uint32_t ADC_ExternalTrigConvEdge;      /*!< Select the external trigger edge and
N                                               enable the trigger of a regular group. 
N                                               This parameter can be a value of 
N                                               @ref ADC_external_trigger_edge_for_regular_channels_conversion */
N  uint32_t ADC_ExternalTrigConv;          /*!< Select the external event used to trigger 
N                                               the start of conversion of a regular group.
N                                               This parameter can be a value of 
N                                               @ref ADC_extrenal_trigger_sources_for_regular_channels_conversion */
N  uint32_t ADC_DataAlign;                 /*!< Specifies whether the ADC data  alignment
N                                               is left or right. This parameter can be 
N                                               a value of @ref ADC_data_align */
N  uint8_t  ADC_NbrOfConversion;           /*!< Specifies the number of ADC conversions
N                                               that will be done using the sequencer for
N                                               regular channel group.
N                                               This parameter must range from 1 to 16. */
N}ADC_InitTypeDef;
N  
N/** 
N  * @brief   ADC Common Init structure definition  
N  */ 
Ntypedef struct 
N{
N  uint32_t ADC_Mode;                      /*!< Configures the ADC to operate in 
N                                               independent or multi mode. 
N                                               This parameter can be a value of @ref ADC_Common_mode */                                              
N  uint32_t ADC_Prescaler;                 /*!< Select the frequency of the clock 
N                                               to the ADC. The clock is common for all the ADCs.
N                                               This parameter can be a value of @ref ADC_Prescaler */
N  uint32_t ADC_DMAAccessMode;             /*!< Configures the Direct memory access 
N                                              mode for multi ADC mode.
N                                               This parameter can be a value of 
N                                               @ref ADC_Direct_memory_access_mode_for_multi_mode */
N  uint32_t ADC_TwoSamplingDelay;          /*!< Configures the Delay between 2 sampling phases.
N                                               This parameter can be a value of 
N                                               @ref ADC_delay_between_2_sampling_phases */
N  
N}ADC_CommonInitTypeDef;
N
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup ADC_Exported_Constants
N  * @{
N  */ 
N#define IS_ADC_ALL_PERIPH(PERIPH) (((PERIPH) == ADC1) || \
N                                   ((PERIPH) == ADC2) || \
N                                   ((PERIPH) == ADC3))  
X#define IS_ADC_ALL_PERIPH(PERIPH) (((PERIPH) == ADC1) ||                                    ((PERIPH) == ADC2) ||                                    ((PERIPH) == ADC3))  
N
N/** @defgroup ADC_Common_mode 
N  * @{
N  */ 
N#define ADC_Mode_Independent                       ((uint32_t)0x00000000)       
N#define ADC_DualMode_RegSimult_InjecSimult         ((uint32_t)0x00000001)
N#define ADC_DualMode_RegSimult_AlterTrig           ((uint32_t)0x00000002)
N#define ADC_DualMode_InjecSimult                   ((uint32_t)0x00000005)
N#define ADC_DualMode_RegSimult                     ((uint32_t)0x00000006)
N#define ADC_DualMode_Interl                        ((uint32_t)0x00000007)
N#define ADC_DualMode_AlterTrig                     ((uint32_t)0x00000009)
N#define ADC_TripleMode_RegSimult_InjecSimult       ((uint32_t)0x00000011)
N#define ADC_TripleMode_RegSimult_AlterTrig         ((uint32_t)0x00000012)
N#define ADC_TripleMode_InjecSimult                 ((uint32_t)0x00000015)
N#define ADC_TripleMode_RegSimult                   ((uint32_t)0x00000016)
N#define ADC_TripleMode_Interl                      ((uint32_t)0x00000017)
N#define ADC_TripleMode_AlterTrig                   ((uint32_t)0x00000019)
N#define IS_ADC_MODE(MODE) (((MODE) == ADC_Mode_Independent) || \
N                           ((MODE) == ADC_DualMode_RegSimult_InjecSimult) || \
N                           ((MODE) == ADC_DualMode_RegSimult_AlterTrig) || \
N                           ((MODE) == ADC_DualMode_InjecSimult) || \
N                           ((MODE) == ADC_DualMode_RegSimult) || \
N                           ((MODE) == ADC_DualMode_Interl) || \
N                           ((MODE) == ADC_DualMode_AlterTrig) || \
N                           ((MODE) == ADC_TripleMode_RegSimult_InjecSimult) || \
N                           ((MODE) == ADC_TripleMode_RegSimult_AlterTrig) || \
N                           ((MODE) == ADC_TripleMode_InjecSimult) || \
N                           ((MODE) == ADC_TripleMode_RegSimult) || \
N                           ((MODE) == ADC_TripleMode_Interl) || \
N                           ((MODE) == ADC_TripleMode_AlterTrig))
X#define IS_ADC_MODE(MODE) (((MODE) == ADC_Mode_Independent) ||                            ((MODE) == ADC_DualMode_RegSimult_InjecSimult) ||                            ((MODE) == ADC_DualMode_RegSimult_AlterTrig) ||                            ((MODE) == ADC_DualMode_InjecSimult) ||                            ((MODE) == ADC_DualMode_RegSimult) ||                            ((MODE) == ADC_DualMode_Interl) ||                            ((MODE) == ADC_DualMode_AlterTrig) ||                            ((MODE) == ADC_TripleMode_RegSimult_InjecSimult) ||                            ((MODE) == ADC_TripleMode_RegSimult_AlterTrig) ||                            ((MODE) == ADC_TripleMode_InjecSimult) ||                            ((MODE) == ADC_TripleMode_RegSimult) ||                            ((MODE) == ADC_TripleMode_Interl) ||                            ((MODE) == ADC_TripleMode_AlterTrig))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ADC_Prescaler 
N  * @{
N  */ 
N#define ADC_Prescaler_Div2                         ((uint32_t)0x00000000)
N#define ADC_Prescaler_Div4                         ((uint32_t)0x00010000)
N#define ADC_Prescaler_Div6                         ((uint32_t)0x00020000)
N#define ADC_Prescaler_Div8                         ((uint32_t)0x00030000)
N#define IS_ADC_PRESCALER(PRESCALER) (((PRESCALER) == ADC_Prescaler_Div2) || \
N                                     ((PRESCALER) == ADC_Prescaler_Div4) || \
N                                     ((PRESCALER) == ADC_Prescaler_Div6) || \
N                                     ((PRESCALER) == ADC_Prescaler_Div8))
X#define IS_ADC_PRESCALER(PRESCALER) (((PRESCALER) == ADC_Prescaler_Div2) ||                                      ((PRESCALER) == ADC_Prescaler_Div4) ||                                      ((PRESCALER) == ADC_Prescaler_Div6) ||                                      ((PRESCALER) == ADC_Prescaler_Div8))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ADC_Direct_memory_access_mode_for_multi_mode 
N  * @{
N  */ 
N#define ADC_DMAAccessMode_Disabled      ((uint32_t)0x00000000)     /* DMA mode disabled */
N#define ADC_DMAAccessMode_1             ((uint32_t)0x00004000)     /* DMA mode 1 enabled (2 / 3 half-words one by one - 1 then 2 then 3)*/
N#define ADC_DMAAccessMode_2             ((uint32_t)0x00008000)     /* DMA mode 2 enabled (2 / 3 half-words by pairs - 2&1 then 1&3 then 3&2)*/
N#define ADC_DMAAccessMode_3             ((uint32_t)0x0000C000)     /* DMA mode 3 enabled (2 / 3 bytes by pairs - 2&1 then 1&3 then 3&2) */
N#define IS_ADC_DMA_ACCESS_MODE(MODE) (((MODE) == ADC_DMAAccessMode_Disabled) || \
N                                      ((MODE) == ADC_DMAAccessMode_1) || \
N                                      ((MODE) == ADC_DMAAccessMode_2) || \
N                                      ((MODE) == ADC_DMAAccessMode_3))
X#define IS_ADC_DMA_ACCESS_MODE(MODE) (((MODE) == ADC_DMAAccessMode_Disabled) ||                                       ((MODE) == ADC_DMAAccessMode_1) ||                                       ((MODE) == ADC_DMAAccessMode_2) ||                                       ((MODE) == ADC_DMAAccessMode_3))
N                                     
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ADC_delay_between_2_sampling_phases 
N  * @{
N  */ 
N#define ADC_TwoSamplingDelay_5Cycles               ((uint32_t)0x00000000)
N#define ADC_TwoSamplingDelay_6Cycles               ((uint32_t)0x00000100)
N#define ADC_TwoSamplingDelay_7Cycles               ((uint32_t)0x00000200)
N#define ADC_TwoSamplingDelay_8Cycles               ((uint32_t)0x00000300)
N#define ADC_TwoSamplingDelay_9Cycles               ((uint32_t)0x00000400)
N#define ADC_TwoSamplingDelay_10Cycles              ((uint32_t)0x00000500)
N#define ADC_TwoSamplingDelay_11Cycles              ((uint32_t)0x00000600)
N#define ADC_TwoSamplingDelay_12Cycles              ((uint32_t)0x00000700)
N#define ADC_TwoSamplingDelay_13Cycles              ((uint32_t)0x00000800)
N#define ADC_TwoSamplingDelay_14Cycles              ((uint32_t)0x00000900)
N#define ADC_TwoSamplingDelay_15Cycles              ((uint32_t)0x00000A00)
N#define ADC_TwoSamplingDelay_16Cycles              ((uint32_t)0x00000B00)
N#define ADC_TwoSamplingDelay_17Cycles              ((uint32_t)0x00000C00)
N#define ADC_TwoSamplingDelay_18Cycles              ((uint32_t)0x00000D00)
N#define ADC_TwoSamplingDelay_19Cycles              ((uint32_t)0x00000E00)
N#define ADC_TwoSamplingDelay_20Cycles              ((uint32_t)0x00000F00)
N#define IS_ADC_SAMPLING_DELAY(DELAY) (((DELAY) == ADC_TwoSamplingDelay_5Cycles) || \
N                                      ((DELAY) == ADC_TwoSamplingDelay_6Cycles) || \
N                                      ((DELAY) == ADC_TwoSamplingDelay_7Cycles) || \
N                                      ((DELAY) == ADC_TwoSamplingDelay_8Cycles) || \
N                                      ((DELAY) == ADC_TwoSamplingDelay_9Cycles) || \
N                                      ((DELAY) == ADC_TwoSamplingDelay_10Cycles) || \
N                                      ((DELAY) == ADC_TwoSamplingDelay_11Cycles) || \
N                                      ((DELAY) == ADC_TwoSamplingDelay_12Cycles) || \
N                                      ((DELAY) == ADC_TwoSamplingDelay_13Cycles) || \
N                                      ((DELAY) == ADC_TwoSamplingDelay_14Cycles) || \
N                                      ((DELAY) == ADC_TwoSamplingDelay_15Cycles) || \
N                                      ((DELAY) == ADC_TwoSamplingDelay_16Cycles) || \
N                                      ((DELAY) == ADC_TwoSamplingDelay_17Cycles) || \
N                                      ((DELAY) == ADC_TwoSamplingDelay_18Cycles) || \
N                                      ((DELAY) == ADC_TwoSamplingDelay_19Cycles) || \
N                                      ((DELAY) == ADC_TwoSamplingDelay_20Cycles))
X#define IS_ADC_SAMPLING_DELAY(DELAY) (((DELAY) == ADC_TwoSamplingDelay_5Cycles) ||                                       ((DELAY) == ADC_TwoSamplingDelay_6Cycles) ||                                       ((DELAY) == ADC_TwoSamplingDelay_7Cycles) ||                                       ((DELAY) == ADC_TwoSamplingDelay_8Cycles) ||                                       ((DELAY) == ADC_TwoSamplingDelay_9Cycles) ||                                       ((DELAY) == ADC_TwoSamplingDelay_10Cycles) ||                                       ((DELAY) == ADC_TwoSamplingDelay_11Cycles) ||                                       ((DELAY) == ADC_TwoSamplingDelay_12Cycles) ||                                       ((DELAY) == ADC_TwoSamplingDelay_13Cycles) ||                                       ((DELAY) == ADC_TwoSamplingDelay_14Cycles) ||                                       ((DELAY) == ADC_TwoSamplingDelay_15Cycles) ||                                       ((DELAY) == ADC_TwoSamplingDelay_16Cycles) ||                                       ((DELAY) == ADC_TwoSamplingDelay_17Cycles) ||                                       ((DELAY) == ADC_TwoSamplingDelay_18Cycles) ||                                       ((DELAY) == ADC_TwoSamplingDelay_19Cycles) ||                                       ((DELAY) == ADC_TwoSamplingDelay_20Cycles))
N                                     
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ADC_resolution 
N  * @{
N  */ 
N#define ADC_Resolution_12b                         ((uint32_t)0x00000000)
N#define ADC_Resolution_10b                         ((uint32_t)0x01000000)
N#define ADC_Resolution_8b                          ((uint32_t)0x02000000)
N#define ADC_Resolution_6b                          ((uint32_t)0x03000000)
N#define IS_ADC_RESOLUTION(RESOLUTION) (((RESOLUTION) == ADC_Resolution_12b) || \
N                                       ((RESOLUTION) == ADC_Resolution_10b) || \
N                                       ((RESOLUTION) == ADC_Resolution_8b) || \
N                                       ((RESOLUTION) == ADC_Resolution_6b))
X#define IS_ADC_RESOLUTION(RESOLUTION) (((RESOLUTION) == ADC_Resolution_12b) ||                                        ((RESOLUTION) == ADC_Resolution_10b) ||                                        ((RESOLUTION) == ADC_Resolution_8b) ||                                        ((RESOLUTION) == ADC_Resolution_6b))
N                                      
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ADC_external_trigger_edge_for_regular_channels_conversion 
N  * @{
N  */ 
N#define ADC_ExternalTrigConvEdge_None          ((uint32_t)0x00000000)
N#define ADC_ExternalTrigConvEdge_Rising        ((uint32_t)0x10000000)
N#define ADC_ExternalTrigConvEdge_Falling       ((uint32_t)0x20000000)
N#define ADC_ExternalTrigConvEdge_RisingFalling ((uint32_t)0x30000000)
N#define IS_ADC_EXT_TRIG_EDGE(EDGE) (((EDGE) == ADC_ExternalTrigConvEdge_None) || \
N                             ((EDGE) == ADC_ExternalTrigConvEdge_Rising) || \
N                             ((EDGE) == ADC_ExternalTrigConvEdge_Falling) || \
N                             ((EDGE) == ADC_ExternalTrigConvEdge_RisingFalling))
X#define IS_ADC_EXT_TRIG_EDGE(EDGE) (((EDGE) == ADC_ExternalTrigConvEdge_None) ||                              ((EDGE) == ADC_ExternalTrigConvEdge_Rising) ||                              ((EDGE) == ADC_ExternalTrigConvEdge_Falling) ||                              ((EDGE) == ADC_ExternalTrigConvEdge_RisingFalling))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ADC_extrenal_trigger_sources_for_regular_channels_conversion 
N  * @{
N  */ 
N#define ADC_ExternalTrigConv_T1_CC1                ((uint32_t)0x00000000)
N#define ADC_ExternalTrigConv_T1_CC2                ((uint32_t)0x01000000)
N#define ADC_ExternalTrigConv_T1_CC3                ((uint32_t)0x02000000)
N#define ADC_ExternalTrigConv_T2_CC2                ((uint32_t)0x03000000)
N#define ADC_ExternalTrigConv_T2_CC3                ((uint32_t)0x04000000)
N#define ADC_ExternalTrigConv_T2_CC4                ((uint32_t)0x05000000)
N#define ADC_ExternalTrigConv_T2_TRGO               ((uint32_t)0x06000000)
N#define ADC_ExternalTrigConv_T3_CC1                ((uint32_t)0x07000000)
N#define ADC_ExternalTrigConv_T3_TRGO               ((uint32_t)0x08000000)
N#define ADC_ExternalTrigConv_T4_CC4                ((uint32_t)0x09000000)
N#define ADC_ExternalTrigConv_T5_CC1                ((uint32_t)0x0A000000)
N#define ADC_ExternalTrigConv_T5_CC2                ((uint32_t)0x0B000000)
N#define ADC_ExternalTrigConv_T5_CC3                ((uint32_t)0x0C000000)
N#define ADC_ExternalTrigConv_T8_CC1                ((uint32_t)0x0D000000)
N#define ADC_ExternalTrigConv_T8_TRGO               ((uint32_t)0x0E000000)
N#define ADC_ExternalTrigConv_Ext_IT11              ((uint32_t)0x0F000000)
N#define IS_ADC_EXT_TRIG(REGTRIG) (((REGTRIG) == ADC_ExternalTrigConv_T1_CC1) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T1_CC2) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T1_CC3) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_CC2) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_CC3) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_CC4) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_TRGO) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T3_CC1) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T3_TRGO) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T4_CC4) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T5_CC1) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T5_CC2) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T5_CC3) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T8_CC1) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T8_TRGO) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_Ext_IT11))
X#define IS_ADC_EXT_TRIG(REGTRIG) (((REGTRIG) == ADC_ExternalTrigConv_T1_CC1) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T1_CC2) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T1_CC3) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T2_CC2) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T2_CC3) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T2_CC4) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T2_TRGO) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T3_CC1) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T3_TRGO) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T4_CC4) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T5_CC1) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T5_CC2) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T5_CC3) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T8_CC1) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T8_TRGO) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_Ext_IT11))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ADC_data_align 
N  * @{
N  */ 
N#define ADC_DataAlign_Right                        ((uint32_t)0x00000000)
N#define ADC_DataAlign_Left                         ((uint32_t)0x00000800)
N#define IS_ADC_DATA_ALIGN(ALIGN) (((ALIGN) == ADC_DataAlign_Right) || \
N                                  ((ALIGN) == ADC_DataAlign_Left))
X#define IS_ADC_DATA_ALIGN(ALIGN) (((ALIGN) == ADC_DataAlign_Right) ||                                   ((ALIGN) == ADC_DataAlign_Left))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ADC_channels 
N  * @{
N  */ 
N#define ADC_Channel_0                               ((uint8_t)0x00)
N#define ADC_Channel_1                               ((uint8_t)0x01)
N#define ADC_Channel_2                               ((uint8_t)0x02)
N#define ADC_Channel_3                               ((uint8_t)0x03)
N#define ADC_Channel_4                               ((uint8_t)0x04)
N#define ADC_Channel_5                               ((uint8_t)0x05)
N#define ADC_Channel_6                               ((uint8_t)0x06)
N#define ADC_Channel_7                               ((uint8_t)0x07)
N#define ADC_Channel_8                               ((uint8_t)0x08)
N#define ADC_Channel_9                               ((uint8_t)0x09)
N#define ADC_Channel_10                              ((uint8_t)0x0A)
N#define ADC_Channel_11                              ((uint8_t)0x0B)
N#define ADC_Channel_12                              ((uint8_t)0x0C)
N#define ADC_Channel_13                              ((uint8_t)0x0D)
N#define ADC_Channel_14                              ((uint8_t)0x0E)
N#define ADC_Channel_15                              ((uint8_t)0x0F)
N#define ADC_Channel_16                              ((uint8_t)0x10)
N#define ADC_Channel_17                              ((uint8_t)0x11)
N#define ADC_Channel_18                              ((uint8_t)0x12)
N
N#if defined (STM32F40_41xxx) || defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 1L || 0L || 0L
N#define ADC_Channel_TempSensor                      ((uint8_t)ADC_Channel_16)
N#endif /* STM32F40_41xxx || STM32F412xG || STM32F413_423xx */
N
N#if defined (STM32F427_437xx) || defined (STM32F429_439xx) || defined (STM32F401xx) || defined (STM32F410xx) || defined (STM32F411xE)
X#if 0L || 0L || 0L || 0L || 0L
S#define ADC_Channel_TempSensor                      ((uint8_t)ADC_Channel_18)
N#endif /* STM32F427_437xx || STM32F429_439xx || STM32F401xx || STM32F410xx || STM32F411xE */
N
N#define ADC_Channel_Vrefint                         ((uint8_t)ADC_Channel_17)
N#define ADC_Channel_Vbat                            ((uint8_t)ADC_Channel_18)
N
N#define IS_ADC_CHANNEL(CHANNEL) (((CHANNEL) == ADC_Channel_0) || \
N                                 ((CHANNEL) == ADC_Channel_1) || \
N                                 ((CHANNEL) == ADC_Channel_2) || \
N                                 ((CHANNEL) == ADC_Channel_3) || \
N                                 ((CHANNEL) == ADC_Channel_4) || \
N                                 ((CHANNEL) == ADC_Channel_5) || \
N                                 ((CHANNEL) == ADC_Channel_6) || \
N                                 ((CHANNEL) == ADC_Channel_7) || \
N                                 ((CHANNEL) == ADC_Channel_8) || \
N                                 ((CHANNEL) == ADC_Channel_9) || \
N                                 ((CHANNEL) == ADC_Channel_10) || \
N                                 ((CHANNEL) == ADC_Channel_11) || \
N                                 ((CHANNEL) == ADC_Channel_12) || \
N                                 ((CHANNEL) == ADC_Channel_13) || \
N                                 ((CHANNEL) == ADC_Channel_14) || \
N                                 ((CHANNEL) == ADC_Channel_15) || \
N                                 ((CHANNEL) == ADC_Channel_16) || \
N                                 ((CHANNEL) == ADC_Channel_17) || \
N                                 ((CHANNEL) == ADC_Channel_18))
X#define IS_ADC_CHANNEL(CHANNEL) (((CHANNEL) == ADC_Channel_0) ||                                  ((CHANNEL) == ADC_Channel_1) ||                                  ((CHANNEL) == ADC_Channel_2) ||                                  ((CHANNEL) == ADC_Channel_3) ||                                  ((CHANNEL) == ADC_Channel_4) ||                                  ((CHANNEL) == ADC_Channel_5) ||                                  ((CHANNEL) == ADC_Channel_6) ||                                  ((CHANNEL) == ADC_Channel_7) ||                                  ((CHANNEL) == ADC_Channel_8) ||                                  ((CHANNEL) == ADC_Channel_9) ||                                  ((CHANNEL) == ADC_Channel_10) ||                                  ((CHANNEL) == ADC_Channel_11) ||                                  ((CHANNEL) == ADC_Channel_12) ||                                  ((CHANNEL) == ADC_Channel_13) ||                                  ((CHANNEL) == ADC_Channel_14) ||                                  ((CHANNEL) == ADC_Channel_15) ||                                  ((CHANNEL) == ADC_Channel_16) ||                                  ((CHANNEL) == ADC_Channel_17) ||                                  ((CHANNEL) == ADC_Channel_18))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ADC_sampling_times 
N  * @{
N  */ 
N#define ADC_SampleTime_3Cycles                    ((uint8_t)0x00)
N#define ADC_SampleTime_15Cycles                   ((uint8_t)0x01)
N#define ADC_SampleTime_28Cycles                   ((uint8_t)0x02)
N#define ADC_SampleTime_56Cycles                   ((uint8_t)0x03)
N#define ADC_SampleTime_84Cycles                   ((uint8_t)0x04)
N#define ADC_SampleTime_112Cycles                  ((uint8_t)0x05)
N#define ADC_SampleTime_144Cycles                  ((uint8_t)0x06)
N#define ADC_SampleTime_480Cycles                  ((uint8_t)0x07)
N#define IS_ADC_SAMPLE_TIME(TIME) (((TIME) == ADC_SampleTime_3Cycles) || \
N                                  ((TIME) == ADC_SampleTime_15Cycles) || \
N                                  ((TIME) == ADC_SampleTime_28Cycles) || \
N                                  ((TIME) == ADC_SampleTime_56Cycles) || \
N                                  ((TIME) == ADC_SampleTime_84Cycles) || \
N                                  ((TIME) == ADC_SampleTime_112Cycles) || \
N                                  ((TIME) == ADC_SampleTime_144Cycles) || \
N                                  ((TIME) == ADC_SampleTime_480Cycles))
X#define IS_ADC_SAMPLE_TIME(TIME) (((TIME) == ADC_SampleTime_3Cycles) ||                                   ((TIME) == ADC_SampleTime_15Cycles) ||                                   ((TIME) == ADC_SampleTime_28Cycles) ||                                   ((TIME) == ADC_SampleTime_56Cycles) ||                                   ((TIME) == ADC_SampleTime_84Cycles) ||                                   ((TIME) == ADC_SampleTime_112Cycles) ||                                   ((TIME) == ADC_SampleTime_144Cycles) ||                                   ((TIME) == ADC_SampleTime_480Cycles))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ADC_external_trigger_edge_for_injected_channels_conversion 
N  * @{
N  */ 
N#define ADC_ExternalTrigInjecConvEdge_None          ((uint32_t)0x00000000)
N#define ADC_ExternalTrigInjecConvEdge_Rising        ((uint32_t)0x00100000)
N#define ADC_ExternalTrigInjecConvEdge_Falling       ((uint32_t)0x00200000)
N#define ADC_ExternalTrigInjecConvEdge_RisingFalling ((uint32_t)0x00300000)
N#define IS_ADC_EXT_INJEC_TRIG_EDGE(EDGE) (((EDGE) == ADC_ExternalTrigInjecConvEdge_None) || \
N                                          ((EDGE) == ADC_ExternalTrigInjecConvEdge_Rising) || \
N                                          ((EDGE) == ADC_ExternalTrigInjecConvEdge_Falling) || \
N                                          ((EDGE) == ADC_ExternalTrigInjecConvEdge_RisingFalling))
X#define IS_ADC_EXT_INJEC_TRIG_EDGE(EDGE) (((EDGE) == ADC_ExternalTrigInjecConvEdge_None) ||                                           ((EDGE) == ADC_ExternalTrigInjecConvEdge_Rising) ||                                           ((EDGE) == ADC_ExternalTrigInjecConvEdge_Falling) ||                                           ((EDGE) == ADC_ExternalTrigInjecConvEdge_RisingFalling))
N                                            
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ADC_extrenal_trigger_sources_for_injected_channels_conversion 
N  * @{
N  */ 
N#define ADC_ExternalTrigInjecConv_T1_CC4            ((uint32_t)0x00000000)
N#define ADC_ExternalTrigInjecConv_T1_TRGO           ((uint32_t)0x00010000)
N#define ADC_ExternalTrigInjecConv_T2_CC1            ((uint32_t)0x00020000)
N#define ADC_ExternalTrigInjecConv_T2_TRGO           ((uint32_t)0x00030000)
N#define ADC_ExternalTrigInjecConv_T3_CC2            ((uint32_t)0x00040000)
N#define ADC_ExternalTrigInjecConv_T3_CC4            ((uint32_t)0x00050000)
N#define ADC_ExternalTrigInjecConv_T4_CC1            ((uint32_t)0x00060000)
N#define ADC_ExternalTrigInjecConv_T4_CC2            ((uint32_t)0x00070000)
N#define ADC_ExternalTrigInjecConv_T4_CC3            ((uint32_t)0x00080000)
N#define ADC_ExternalTrigInjecConv_T4_TRGO           ((uint32_t)0x00090000)
N#define ADC_ExternalTrigInjecConv_T5_CC4            ((uint32_t)0x000A0000)
N#define ADC_ExternalTrigInjecConv_T5_TRGO           ((uint32_t)0x000B0000)
N#define ADC_ExternalTrigInjecConv_T8_CC2            ((uint32_t)0x000C0000)
N#define ADC_ExternalTrigInjecConv_T8_CC3            ((uint32_t)0x000D0000)
N#define ADC_ExternalTrigInjecConv_T8_CC4            ((uint32_t)0x000E0000)
N#define ADC_ExternalTrigInjecConv_Ext_IT15          ((uint32_t)0x000F0000)
N#define IS_ADC_EXT_INJEC_TRIG(INJTRIG) (((INJTRIG) == ADC_ExternalTrigInjecConv_T1_CC4) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T1_TRGO) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_CC1) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_TRGO) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T3_CC2) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T3_CC4) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC1) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC2) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC3) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_TRGO) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_CC4) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_TRGO) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC2) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC3) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC4) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_Ext_IT15))
X#define IS_ADC_EXT_INJEC_TRIG(INJTRIG) (((INJTRIG) == ADC_ExternalTrigInjecConv_T1_CC4) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T1_TRGO) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_CC1) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_TRGO) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T3_CC2) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T3_CC4) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC1) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC2) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC3) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_TRGO) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_CC4) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_TRGO) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC2) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC3) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC4) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_Ext_IT15))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ADC_injected_channel_selection 
N  * @{
N  */ 
N#define ADC_InjectedChannel_1                       ((uint8_t)0x14)
N#define ADC_InjectedChannel_2                       ((uint8_t)0x18)
N#define ADC_InjectedChannel_3                       ((uint8_t)0x1C)
N#define ADC_InjectedChannel_4                       ((uint8_t)0x20)
N#define IS_ADC_INJECTED_CHANNEL(CHANNEL) (((CHANNEL) == ADC_InjectedChannel_1) || \
N                                          ((CHANNEL) == ADC_InjectedChannel_2) || \
N                                          ((CHANNEL) == ADC_InjectedChannel_3) || \
N                                          ((CHANNEL) == ADC_InjectedChannel_4))
X#define IS_ADC_INJECTED_CHANNEL(CHANNEL) (((CHANNEL) == ADC_InjectedChannel_1) ||                                           ((CHANNEL) == ADC_InjectedChannel_2) ||                                           ((CHANNEL) == ADC_InjectedChannel_3) ||                                           ((CHANNEL) == ADC_InjectedChannel_4))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ADC_analog_watchdog_selection 
N  * @{
N  */ 
N#define ADC_AnalogWatchdog_SingleRegEnable         ((uint32_t)0x00800200)
N#define ADC_AnalogWatchdog_SingleInjecEnable       ((uint32_t)0x00400200)
N#define ADC_AnalogWatchdog_SingleRegOrInjecEnable  ((uint32_t)0x00C00200)
N#define ADC_AnalogWatchdog_AllRegEnable            ((uint32_t)0x00800000)
N#define ADC_AnalogWatchdog_AllInjecEnable          ((uint32_t)0x00400000)
N#define ADC_AnalogWatchdog_AllRegAllInjecEnable    ((uint32_t)0x00C00000)
N#define ADC_AnalogWatchdog_None                    ((uint32_t)0x00000000)
N#define IS_ADC_ANALOG_WATCHDOG(WATCHDOG) (((WATCHDOG) == ADC_AnalogWatchdog_SingleRegEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_SingleInjecEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_SingleRegOrInjecEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllRegEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllInjecEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllRegAllInjecEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_None))
X#define IS_ADC_ANALOG_WATCHDOG(WATCHDOG) (((WATCHDOG) == ADC_AnalogWatchdog_SingleRegEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_SingleInjecEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_SingleRegOrInjecEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_AllRegEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_AllInjecEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_AllRegAllInjecEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_None))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ADC_interrupts_definition 
N  * @{
N  */ 
N#define ADC_IT_EOC                                 ((uint16_t)0x0205)  
N#define ADC_IT_AWD                                 ((uint16_t)0x0106)  
N#define ADC_IT_JEOC                                ((uint16_t)0x0407)  
N#define ADC_IT_OVR                                 ((uint16_t)0x201A)  
N#define IS_ADC_IT(IT) (((IT) == ADC_IT_EOC) || ((IT) == ADC_IT_AWD) || \
N                       ((IT) == ADC_IT_JEOC)|| ((IT) == ADC_IT_OVR)) 
X#define IS_ADC_IT(IT) (((IT) == ADC_IT_EOC) || ((IT) == ADC_IT_AWD) ||                        ((IT) == ADC_IT_JEOC)|| ((IT) == ADC_IT_OVR)) 
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ADC_flags_definition 
N  * @{
N  */ 
N#define ADC_FLAG_AWD                               ((uint8_t)0x01)
N#define ADC_FLAG_EOC                               ((uint8_t)0x02)
N#define ADC_FLAG_JEOC                              ((uint8_t)0x04)
N#define ADC_FLAG_JSTRT                             ((uint8_t)0x08)
N#define ADC_FLAG_STRT                              ((uint8_t)0x10)
N#define ADC_FLAG_OVR                               ((uint8_t)0x20)   
N  
N#define IS_ADC_CLEAR_FLAG(FLAG) ((((FLAG) & (uint8_t)0xC0) == 0x00) && ((FLAG) != 0x00))   
N#define IS_ADC_GET_FLAG(FLAG) (((FLAG) == ADC_FLAG_AWD) || \
N                               ((FLAG) == ADC_FLAG_EOC) || \
N                               ((FLAG) == ADC_FLAG_JEOC) || \
N                               ((FLAG)== ADC_FLAG_JSTRT) || \
N                               ((FLAG) == ADC_FLAG_STRT) || \
N                               ((FLAG)== ADC_FLAG_OVR))     
X#define IS_ADC_GET_FLAG(FLAG) (((FLAG) == ADC_FLAG_AWD) ||                                ((FLAG) == ADC_FLAG_EOC) ||                                ((FLAG) == ADC_FLAG_JEOC) ||                                ((FLAG)== ADC_FLAG_JSTRT) ||                                ((FLAG) == ADC_FLAG_STRT) ||                                ((FLAG)== ADC_FLAG_OVR))     
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ADC_thresholds 
N  * @{
N  */ 
N#define IS_ADC_THRESHOLD(THRESHOLD) ((THRESHOLD) <= 0xFFF)
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ADC_injected_offset 
N  * @{
N  */ 
N#define IS_ADC_OFFSET(OFFSET) ((OFFSET) <= 0xFFF)
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ADC_injected_length 
N  * @{
N  */ 
N#define IS_ADC_INJECTED_LENGTH(LENGTH) (((LENGTH) >= 0x1) && ((LENGTH) <= 0x4))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ADC_injected_rank 
N  * @{
N  */ 
N#define IS_ADC_INJECTED_RANK(RANK) (((RANK) >= 0x1) && ((RANK) <= 0x4))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ADC_regular_length 
N  * @{
N  */ 
N#define IS_ADC_REGULAR_LENGTH(LENGTH) (((LENGTH) >= 0x1) && ((LENGTH) <= 0x10))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ADC_regular_rank 
N  * @{
N  */ 
N#define IS_ADC_REGULAR_RANK(RANK) (((RANK) >= 0x1) && ((RANK) <= 0x10))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ADC_regular_discontinuous_mode_number 
N  * @{
N  */ 
N#define IS_ADC_REGULAR_DISC_NUMBER(NUMBER) (((NUMBER) >= 0x1) && ((NUMBER) <= 0x8))
N/**
N  * @}
N  */ 
N
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/  
N
N/*  Function used to set the ADC configuration to the default reset state *****/  
Nvoid ADC_DeInit(void);
N
N/* Initialization and Configuration functions *********************************/
Nvoid ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct);
Nvoid ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct);
Nvoid ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct);
Nvoid ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct);
Nvoid ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState);
N
N/* Analog Watchdog configuration functions ************************************/
Nvoid ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog);
Nvoid ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,uint16_t LowThreshold);
Nvoid ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel);
N
N/* Temperature Sensor, Vrefint and VBAT management functions ******************/
Nvoid ADC_TempSensorVrefintCmd(FunctionalState NewState);
Nvoid ADC_VBATCmd(FunctionalState NewState);
N
N/* Regular Channels Configuration functions ***********************************/
Nvoid ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);
Nvoid ADC_SoftwareStartConv(ADC_TypeDef* ADCx);
NFlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx);
Nvoid ADC_EOCOnEachRegularChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number);
Nvoid ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nuint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx);
Nuint32_t ADC_GetMultiModeConversionValue(void);
N
N/* Regular Channels DMA Configuration functions *******************************/
Nvoid ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_MultiModeDMARequestAfterLastTransferCmd(FunctionalState NewState);
N
N/* Injected channels Configuration functions **********************************/
Nvoid ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);
Nvoid ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length);
Nvoid ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset);
Nvoid ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv);
Nvoid ADC_ExternalTrigInjectedConvEdgeConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConvEdge);
Nvoid ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx);
NFlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx);
Nvoid ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nuint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel);
N
N/* Interrupts and flags management functions **********************************/
Nvoid ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState);
NFlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG);
Nvoid ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG);
NITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT);
Nvoid ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F4xx_ADC_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 35 "..\..\Service\stm32f4xx_conf.h" 2
N#include "stm32f4xx_crc.h"
L 1 "..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\stm32f4xx_crc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_crc.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    04-November-2016
N  * @brief   This file contains all the functions prototypes for the CRC firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_CRC_H
N#define __STM32F4xx_CRC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
N
N/** @addtogroup STM32F4xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup CRC
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup CRC_Exported_Constants
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/  
N
Nvoid CRC_ResetDR(void);
Nuint32_t CRC_CalcCRC(uint32_t Data);
Nuint32_t CRC_CalcBlockCRC(uint32_t pBuffer[], uint32_t BufferLength);
Nuint32_t CRC_GetCRC(void);
Nvoid CRC_SetIDRegister(uint8_t IDValue);
Nuint8_t CRC_GetIDRegister(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_CRC_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 36 "..\..\Service\stm32f4xx_conf.h" 2
N#include "stm32f4xx_dbgmcu.h"
L 1 "..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\stm32f4xx_dbgmcu.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_dbgmcu.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    04-November-2016
N  * @brief   This file contains all the functions prototypes for the DBGMCU firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_DBGMCU_H
N#define __STM32F4xx_DBGMCU_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
N
N/** @addtogroup STM32F4xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup DBGMCU
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup DBGMCU_Exported_Constants
N  * @{
N  */ 
N#define DBGMCU_SLEEP                 ((uint32_t)0x00000001)
N#define DBGMCU_STOP                  ((uint32_t)0x00000002)
N#define DBGMCU_STANDBY               ((uint32_t)0x00000004)
N#define IS_DBGMCU_PERIPH(PERIPH) ((((PERIPH) & 0xFFFFFFF8) == 0x00) && ((PERIPH) != 0x00))
N
N#define DBGMCU_TIM2_STOP             ((uint32_t)0x00000001)
N#define DBGMCU_TIM3_STOP             ((uint32_t)0x00000002)
N#define DBGMCU_TIM4_STOP             ((uint32_t)0x00000004)
N#define DBGMCU_TIM5_STOP             ((uint32_t)0x00000008)
N#define DBGMCU_TIM6_STOP             ((uint32_t)0x00000010)
N#define DBGMCU_TIM7_STOP             ((uint32_t)0x00000020)
N#define DBGMCU_TIM12_STOP            ((uint32_t)0x00000040)
N#define DBGMCU_TIM13_STOP            ((uint32_t)0x00000080)
N#define DBGMCU_TIM14_STOP            ((uint32_t)0x00000100)
N#define DBGMCU_RTC_STOP              ((uint32_t)0x00000400)
N#define DBGMCU_WWDG_STOP             ((uint32_t)0x00000800)
N#define DBGMCU_IWDG_STOP             ((uint32_t)0x00001000)
N#define DBGMCU_I2C1_SMBUS_TIMEOUT    ((uint32_t)0x00200000)
N#define DBGMCU_I2C2_SMBUS_TIMEOUT    ((uint32_t)0x00400000)
N#define DBGMCU_I2C3_SMBUS_TIMEOUT    ((uint32_t)0x00800000)
N#define DBGMCU_CAN1_STOP             ((uint32_t)0x02000000)
N#define DBGMCU_CAN2_STOP             ((uint32_t)0x04000000)
N#define IS_DBGMCU_APB1PERIPH(PERIPH) ((((PERIPH) & 0xF91FE200) == 0x00) && ((PERIPH) != 0x00))
N
N#define DBGMCU_TIM1_STOP             ((uint32_t)0x00000001)
N#define DBGMCU_TIM8_STOP             ((uint32_t)0x00000002)
N#define DBGMCU_TIM9_STOP             ((uint32_t)0x00010000)
N#define DBGMCU_TIM10_STOP            ((uint32_t)0x00020000)
N#define DBGMCU_TIM11_STOP            ((uint32_t)0x00040000)
N#define IS_DBGMCU_APB2PERIPH(PERIPH) ((((PERIPH) & 0xFFF8FFFC) == 0x00) && ((PERIPH) != 0x00))
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/ 
Nuint32_t DBGMCU_GetREVID(void);
Nuint32_t DBGMCU_GetDEVID(void);
Nvoid DBGMCU_Config(uint32_t DBGMCU_Periph, FunctionalState NewState);
Nvoid DBGMCU_APB1PeriphConfig(uint32_t DBGMCU_Periph, FunctionalState NewState);
Nvoid DBGMCU_APB2PeriphConfig(uint32_t DBGMCU_Periph, FunctionalState NewState);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_DBGMCU_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 37 "..\..\Service\stm32f4xx_conf.h" 2
N#include "stm32f4xx_dma.h"
L 1 "..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\stm32f4xx_dma.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_dma.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    04-November-2016
N  * @brief   This file contains all the functions prototypes for the DMA firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************  
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_DMA_H
N#define __STM32F4xx_DMA_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
N
N/** @addtogroup STM32F4xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup DMA
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  DMA Init structure definition
N  */
N
Ntypedef struct
N{
N  uint32_t DMA_Channel;            /*!< Specifies the channel used for the specified stream. 
N                                        This parameter can be a value of @ref DMA_channel */
N 
N  uint32_t DMA_PeripheralBaseAddr; /*!< Specifies the peripheral base address for DMAy Streamx. */
N
N  uint32_t DMA_Memory0BaseAddr;    /*!< Specifies the memory 0 base address for DMAy Streamx. 
N                                        This memory is the default memory used when double buffer mode is
N                                        not enabled. */
N
N  uint32_t DMA_DIR;                /*!< Specifies if the data will be transferred from memory to peripheral, 
N                                        from memory to memory or from peripheral to memory.
N                                        This parameter can be a value of @ref DMA_data_transfer_direction */
N
N  uint32_t DMA_BufferSize;         /*!< Specifies the buffer size, in data unit, of the specified Stream. 
N                                        The data unit is equal to the configuration set in DMA_PeripheralDataSize
N                                        or DMA_MemoryDataSize members depending in the transfer direction. */
N
N  uint32_t DMA_PeripheralInc;      /*!< Specifies whether the Peripheral address register should be incremented or not.
N                                        This parameter can be a value of @ref DMA_peripheral_incremented_mode */
N
N  uint32_t DMA_MemoryInc;          /*!< Specifies whether the memory address register should be incremented or not.
N                                        This parameter can be a value of @ref DMA_memory_incremented_mode */
N
N  uint32_t DMA_PeripheralDataSize; /*!< Specifies the Peripheral data width.
N                                        This parameter can be a value of @ref DMA_peripheral_data_size */
N
N  uint32_t DMA_MemoryDataSize;     /*!< Specifies the Memory data width.
N                                        This parameter can be a value of @ref DMA_memory_data_size */
N
N  uint32_t DMA_Mode;               /*!< Specifies the operation mode of the DMAy Streamx.
N                                        This parameter can be a value of @ref DMA_circular_normal_mode
N                                        @note The circular buffer mode cannot be used if the memory-to-memory
N                                              data transfer is configured on the selected Stream */
N
N  uint32_t DMA_Priority;           /*!< Specifies the software priority for the DMAy Streamx.
N                                        This parameter can be a value of @ref DMA_priority_level */
N
N  uint32_t DMA_FIFOMode;          /*!< Specifies if the FIFO mode or Direct mode will be used for the specified Stream.
N                                        This parameter can be a value of @ref DMA_fifo_direct_mode
N                                        @note The Direct mode (FIFO mode disabled) cannot be used if the 
N                                               memory-to-memory data transfer is configured on the selected Stream */
N
N  uint32_t DMA_FIFOThreshold;      /*!< Specifies the FIFO threshold level.
N                                        This parameter can be a value of @ref DMA_fifo_threshold_level */
N
N  uint32_t DMA_MemoryBurst;        /*!< Specifies the Burst transfer configuration for the memory transfers. 
N                                        It specifies the amount of data to be transferred in a single non interruptable 
N                                        transaction. This parameter can be a value of @ref DMA_memory_burst 
N                                        @note The burst mode is possible only if the address Increment mode is enabled. */
N
N  uint32_t DMA_PeripheralBurst;    /*!< Specifies the Burst transfer configuration for the peripheral transfers. 
N                                        It specifies the amount of data to be transferred in a single non interruptable 
N                                        transaction. This parameter can be a value of @ref DMA_peripheral_burst
N                                        @note The burst mode is possible only if the address Increment mode is enabled. */  
N}DMA_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup DMA_Exported_Constants
N  * @{
N  */
N
N#define IS_DMA_ALL_PERIPH(PERIPH) (((PERIPH) == DMA1_Stream0) || \
N                                   ((PERIPH) == DMA1_Stream1) || \
N                                   ((PERIPH) == DMA1_Stream2) || \
N                                   ((PERIPH) == DMA1_Stream3) || \
N                                   ((PERIPH) == DMA1_Stream4) || \
N                                   ((PERIPH) == DMA1_Stream5) || \
N                                   ((PERIPH) == DMA1_Stream6) || \
N                                   ((PERIPH) == DMA1_Stream7) || \
N                                   ((PERIPH) == DMA2_Stream0) || \
N                                   ((PERIPH) == DMA2_Stream1) || \
N                                   ((PERIPH) == DMA2_Stream2) || \
N                                   ((PERIPH) == DMA2_Stream3) || \
N                                   ((PERIPH) == DMA2_Stream4) || \
N                                   ((PERIPH) == DMA2_Stream5) || \
N                                   ((PERIPH) == DMA2_Stream6) || \
N                                   ((PERIPH) == DMA2_Stream7))
X#define IS_DMA_ALL_PERIPH(PERIPH) (((PERIPH) == DMA1_Stream0) ||                                    ((PERIPH) == DMA1_Stream1) ||                                    ((PERIPH) == DMA1_Stream2) ||                                    ((PERIPH) == DMA1_Stream3) ||                                    ((PERIPH) == DMA1_Stream4) ||                                    ((PERIPH) == DMA1_Stream5) ||                                    ((PERIPH) == DMA1_Stream6) ||                                    ((PERIPH) == DMA1_Stream7) ||                                    ((PERIPH) == DMA2_Stream0) ||                                    ((PERIPH) == DMA2_Stream1) ||                                    ((PERIPH) == DMA2_Stream2) ||                                    ((PERIPH) == DMA2_Stream3) ||                                    ((PERIPH) == DMA2_Stream4) ||                                    ((PERIPH) == DMA2_Stream5) ||                                    ((PERIPH) == DMA2_Stream6) ||                                    ((PERIPH) == DMA2_Stream7))
N
N#define IS_DMA_ALL_CONTROLLER(CONTROLLER) (((CONTROLLER) == DMA1) || \
N                                           ((CONTROLLER) == DMA2))
X#define IS_DMA_ALL_CONTROLLER(CONTROLLER) (((CONTROLLER) == DMA1) ||                                            ((CONTROLLER) == DMA2))
N
N/** @defgroup DMA_channel 
N  * @{
N  */ 
N#define DMA_Channel_0                     ((uint32_t)0x00000000)
N#define DMA_Channel_1                     ((uint32_t)0x02000000)
N#define DMA_Channel_2                     ((uint32_t)0x04000000)
N#define DMA_Channel_3                     ((uint32_t)0x06000000)
N#define DMA_Channel_4                     ((uint32_t)0x08000000)
N#define DMA_Channel_5                     ((uint32_t)0x0A000000)
N#define DMA_Channel_6                     ((uint32_t)0x0C000000)
N#define DMA_Channel_7                     ((uint32_t)0x0E000000)
N
N#define IS_DMA_CHANNEL(CHANNEL) (((CHANNEL) == DMA_Channel_0) || \
N                                 ((CHANNEL) == DMA_Channel_1) || \
N                                 ((CHANNEL) == DMA_Channel_2) || \
N                                 ((CHANNEL) == DMA_Channel_3) || \
N                                 ((CHANNEL) == DMA_Channel_4) || \
N                                 ((CHANNEL) == DMA_Channel_5) || \
N                                 ((CHANNEL) == DMA_Channel_6) || \
N                                 ((CHANNEL) == DMA_Channel_7))
X#define IS_DMA_CHANNEL(CHANNEL) (((CHANNEL) == DMA_Channel_0) ||                                  ((CHANNEL) == DMA_Channel_1) ||                                  ((CHANNEL) == DMA_Channel_2) ||                                  ((CHANNEL) == DMA_Channel_3) ||                                  ((CHANNEL) == DMA_Channel_4) ||                                  ((CHANNEL) == DMA_Channel_5) ||                                  ((CHANNEL) == DMA_Channel_6) ||                                  ((CHANNEL) == DMA_Channel_7))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DMA_data_transfer_direction 
N  * @{
N  */ 
N#define DMA_DIR_PeripheralToMemory        ((uint32_t)0x00000000)
N#define DMA_DIR_MemoryToPeripheral        ((uint32_t)0x00000040) 
N#define DMA_DIR_MemoryToMemory            ((uint32_t)0x00000080)
N
N#define IS_DMA_DIRECTION(DIRECTION) (((DIRECTION) == DMA_DIR_PeripheralToMemory ) || \
N                                     ((DIRECTION) == DMA_DIR_MemoryToPeripheral)  || \
N                                     ((DIRECTION) == DMA_DIR_MemoryToMemory)) 
X#define IS_DMA_DIRECTION(DIRECTION) (((DIRECTION) == DMA_DIR_PeripheralToMemory ) ||                                      ((DIRECTION) == DMA_DIR_MemoryToPeripheral)  ||                                      ((DIRECTION) == DMA_DIR_MemoryToMemory)) 
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DMA_data_buffer_size 
N  * @{
N  */ 
N#define IS_DMA_BUFFER_SIZE(SIZE) (((SIZE) >= 0x1) && ((SIZE) < 0x10000))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DMA_peripheral_incremented_mode 
N  * @{
N  */ 
N#define DMA_PeripheralInc_Enable          ((uint32_t)0x00000200)
N#define DMA_PeripheralInc_Disable         ((uint32_t)0x00000000)
N
N#define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PeripheralInc_Enable) || \
N                                            ((STATE) == DMA_PeripheralInc_Disable))
X#define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PeripheralInc_Enable) ||                                             ((STATE) == DMA_PeripheralInc_Disable))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DMA_memory_incremented_mode 
N  * @{
N  */ 
N#define DMA_MemoryInc_Enable              ((uint32_t)0x00000400)
N#define DMA_MemoryInc_Disable             ((uint32_t)0x00000000)
N
N#define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MemoryInc_Enable) || \
N                                        ((STATE) == DMA_MemoryInc_Disable))
X#define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MemoryInc_Enable) ||                                         ((STATE) == DMA_MemoryInc_Disable))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DMA_peripheral_data_size 
N  * @{
N  */ 
N#define DMA_PeripheralDataSize_Byte       ((uint32_t)0x00000000) 
N#define DMA_PeripheralDataSize_HalfWord   ((uint32_t)0x00000800) 
N#define DMA_PeripheralDataSize_Word       ((uint32_t)0x00001000)
N
N#define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PeripheralDataSize_Byte)  || \
N                                           ((SIZE) == DMA_PeripheralDataSize_HalfWord) || \
N                                           ((SIZE) == DMA_PeripheralDataSize_Word))
X#define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PeripheralDataSize_Byte)  ||                                            ((SIZE) == DMA_PeripheralDataSize_HalfWord) ||                                            ((SIZE) == DMA_PeripheralDataSize_Word))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DMA_memory_data_size 
N  * @{
N  */ 
N#define DMA_MemoryDataSize_Byte           ((uint32_t)0x00000000) 
N#define DMA_MemoryDataSize_HalfWord       ((uint32_t)0x00002000) 
N#define DMA_MemoryDataSize_Word           ((uint32_t)0x00004000)
N
N#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MemoryDataSize_Byte)  || \
N                                       ((SIZE) == DMA_MemoryDataSize_HalfWord) || \
N                                       ((SIZE) == DMA_MemoryDataSize_Word ))
X#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MemoryDataSize_Byte)  ||                                        ((SIZE) == DMA_MemoryDataSize_HalfWord) ||                                        ((SIZE) == DMA_MemoryDataSize_Word ))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DMA_circular_normal_mode 
N  * @{
N  */ 
N#define DMA_Mode_Normal                   ((uint32_t)0x00000000) 
N#define DMA_Mode_Circular                 ((uint32_t)0x00000100)
N
N#define IS_DMA_MODE(MODE) (((MODE) == DMA_Mode_Normal ) || \
N                           ((MODE) == DMA_Mode_Circular)) 
X#define IS_DMA_MODE(MODE) (((MODE) == DMA_Mode_Normal ) ||                            ((MODE) == DMA_Mode_Circular)) 
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DMA_priority_level 
N  * @{
N  */ 
N#define DMA_Priority_Low                  ((uint32_t)0x00000000)
N#define DMA_Priority_Medium               ((uint32_t)0x00010000) 
N#define DMA_Priority_High                 ((uint32_t)0x00020000)
N#define DMA_Priority_VeryHigh             ((uint32_t)0x00030000)
N
N#define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_Priority_Low )   || \
N                                   ((PRIORITY) == DMA_Priority_Medium) || \
N                                   ((PRIORITY) == DMA_Priority_High)   || \
N                                   ((PRIORITY) == DMA_Priority_VeryHigh)) 
X#define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_Priority_Low )   ||                                    ((PRIORITY) == DMA_Priority_Medium) ||                                    ((PRIORITY) == DMA_Priority_High)   ||                                    ((PRIORITY) == DMA_Priority_VeryHigh)) 
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DMA_fifo_direct_mode 
N  * @{
N  */ 
N#define DMA_FIFOMode_Disable              ((uint32_t)0x00000000) 
N#define DMA_FIFOMode_Enable               ((uint32_t)0x00000004)
N
N#define IS_DMA_FIFO_MODE_STATE(STATE) (((STATE) == DMA_FIFOMode_Disable ) || \
N                                       ((STATE) == DMA_FIFOMode_Enable)) 
X#define IS_DMA_FIFO_MODE_STATE(STATE) (((STATE) == DMA_FIFOMode_Disable ) ||                                        ((STATE) == DMA_FIFOMode_Enable)) 
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DMA_fifo_threshold_level 
N  * @{
N  */ 
N#define DMA_FIFOThreshold_1QuarterFull    ((uint32_t)0x00000000)
N#define DMA_FIFOThreshold_HalfFull        ((uint32_t)0x00000001) 
N#define DMA_FIFOThreshold_3QuartersFull   ((uint32_t)0x00000002)
N#define DMA_FIFOThreshold_Full            ((uint32_t)0x00000003)
N
N#define IS_DMA_FIFO_THRESHOLD(THRESHOLD) (((THRESHOLD) == DMA_FIFOThreshold_1QuarterFull ) || \
N                                          ((THRESHOLD) == DMA_FIFOThreshold_HalfFull)      || \
N                                          ((THRESHOLD) == DMA_FIFOThreshold_3QuartersFull) || \
N                                          ((THRESHOLD) == DMA_FIFOThreshold_Full)) 
X#define IS_DMA_FIFO_THRESHOLD(THRESHOLD) (((THRESHOLD) == DMA_FIFOThreshold_1QuarterFull ) ||                                           ((THRESHOLD) == DMA_FIFOThreshold_HalfFull)      ||                                           ((THRESHOLD) == DMA_FIFOThreshold_3QuartersFull) ||                                           ((THRESHOLD) == DMA_FIFOThreshold_Full)) 
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DMA_memory_burst 
N  * @{
N  */ 
N#define DMA_MemoryBurst_Single            ((uint32_t)0x00000000)
N#define DMA_MemoryBurst_INC4              ((uint32_t)0x00800000)  
N#define DMA_MemoryBurst_INC8              ((uint32_t)0x01000000)
N#define DMA_MemoryBurst_INC16             ((uint32_t)0x01800000)
N
N#define IS_DMA_MEMORY_BURST(BURST) (((BURST) == DMA_MemoryBurst_Single) || \
N                                    ((BURST) == DMA_MemoryBurst_INC4)  || \
N                                    ((BURST) == DMA_MemoryBurst_INC8)  || \
N                                    ((BURST) == DMA_MemoryBurst_INC16))
X#define IS_DMA_MEMORY_BURST(BURST) (((BURST) == DMA_MemoryBurst_Single) ||                                     ((BURST) == DMA_MemoryBurst_INC4)  ||                                     ((BURST) == DMA_MemoryBurst_INC8)  ||                                     ((BURST) == DMA_MemoryBurst_INC16))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DMA_peripheral_burst 
N  * @{
N  */ 
N#define DMA_PeripheralBurst_Single        ((uint32_t)0x00000000)
N#define DMA_PeripheralBurst_INC4          ((uint32_t)0x00200000)  
N#define DMA_PeripheralBurst_INC8          ((uint32_t)0x00400000)
N#define DMA_PeripheralBurst_INC16         ((uint32_t)0x00600000)
N
N#define IS_DMA_PERIPHERAL_BURST(BURST) (((BURST) == DMA_PeripheralBurst_Single) || \
N                                        ((BURST) == DMA_PeripheralBurst_INC4)  || \
N                                        ((BURST) == DMA_PeripheralBurst_INC8)  || \
N                                        ((BURST) == DMA_PeripheralBurst_INC16))
X#define IS_DMA_PERIPHERAL_BURST(BURST) (((BURST) == DMA_PeripheralBurst_Single) ||                                         ((BURST) == DMA_PeripheralBurst_INC4)  ||                                         ((BURST) == DMA_PeripheralBurst_INC8)  ||                                         ((BURST) == DMA_PeripheralBurst_INC16))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DMA_fifo_status_level 
N  * @{
N  */
N#define DMA_FIFOStatus_Less1QuarterFull   ((uint32_t)0x00000000 << 3)
N#define DMA_FIFOStatus_1QuarterFull       ((uint32_t)0x00000001 << 3)
N#define DMA_FIFOStatus_HalfFull           ((uint32_t)0x00000002 << 3) 
N#define DMA_FIFOStatus_3QuartersFull      ((uint32_t)0x00000003 << 3)
N#define DMA_FIFOStatus_Empty              ((uint32_t)0x00000004 << 3)
N#define DMA_FIFOStatus_Full               ((uint32_t)0x00000005 << 3)
N
N#define IS_DMA_FIFO_STATUS(STATUS) (((STATUS) == DMA_FIFOStatus_Less1QuarterFull ) || \
N                                    ((STATUS) == DMA_FIFOStatus_HalfFull)          || \
N                                    ((STATUS) == DMA_FIFOStatus_1QuarterFull)      || \
N                                    ((STATUS) == DMA_FIFOStatus_3QuartersFull)     || \
N                                    ((STATUS) == DMA_FIFOStatus_Full)              || \
N                                    ((STATUS) == DMA_FIFOStatus_Empty)) 
X#define IS_DMA_FIFO_STATUS(STATUS) (((STATUS) == DMA_FIFOStatus_Less1QuarterFull ) ||                                     ((STATUS) == DMA_FIFOStatus_HalfFull)          ||                                     ((STATUS) == DMA_FIFOStatus_1QuarterFull)      ||                                     ((STATUS) == DMA_FIFOStatus_3QuartersFull)     ||                                     ((STATUS) == DMA_FIFOStatus_Full)              ||                                     ((STATUS) == DMA_FIFOStatus_Empty)) 
N/**
N  * @}
N  */ 
N
N/** @defgroup DMA_flags_definition 
N  * @{
N  */
N#define DMA_FLAG_FEIF0                    ((uint32_t)0x10800001)
N#define DMA_FLAG_DMEIF0                   ((uint32_t)0x10800004)
N#define DMA_FLAG_TEIF0                    ((uint32_t)0x10000008)
N#define DMA_FLAG_HTIF0                    ((uint32_t)0x10000010)
N#define DMA_FLAG_TCIF0                    ((uint32_t)0x10000020)
N#define DMA_FLAG_FEIF1                    ((uint32_t)0x10000040)
N#define DMA_FLAG_DMEIF1                   ((uint32_t)0x10000100)
N#define DMA_FLAG_TEIF1                    ((uint32_t)0x10000200)
N#define DMA_FLAG_HTIF1                    ((uint32_t)0x10000400)
N#define DMA_FLAG_TCIF1                    ((uint32_t)0x10000800)
N#define DMA_FLAG_FEIF2                    ((uint32_t)0x10010000)
N#define DMA_FLAG_DMEIF2                   ((uint32_t)0x10040000)
N#define DMA_FLAG_TEIF2                    ((uint32_t)0x10080000)
N#define DMA_FLAG_HTIF2                    ((uint32_t)0x10100000)
N#define DMA_FLAG_TCIF2                    ((uint32_t)0x10200000)
N#define DMA_FLAG_FEIF3                    ((uint32_t)0x10400000)
N#define DMA_FLAG_DMEIF3                   ((uint32_t)0x11000000)
N#define DMA_FLAG_TEIF3                    ((uint32_t)0x12000000)
N#define DMA_FLAG_HTIF3                    ((uint32_t)0x14000000)
N#define DMA_FLAG_TCIF3                    ((uint32_t)0x18000000)
N#define DMA_FLAG_FEIF4                    ((uint32_t)0x20000001)
N#define DMA_FLAG_DMEIF4                   ((uint32_t)0x20000004)
N#define DMA_FLAG_TEIF4                    ((uint32_t)0x20000008)
N#define DMA_FLAG_HTIF4                    ((uint32_t)0x20000010)
N#define DMA_FLAG_TCIF4                    ((uint32_t)0x20000020)
N#define DMA_FLAG_FEIF5                    ((uint32_t)0x20000040)
N#define DMA_FLAG_DMEIF5                   ((uint32_t)0x20000100)
N#define DMA_FLAG_TEIF5                    ((uint32_t)0x20000200)
N#define DMA_FLAG_HTIF5                    ((uint32_t)0x20000400)
N#define DMA_FLAG_TCIF5                    ((uint32_t)0x20000800)
N#define DMA_FLAG_FEIF6                    ((uint32_t)0x20010000)
N#define DMA_FLAG_DMEIF6                   ((uint32_t)0x20040000)
N#define DMA_FLAG_TEIF6                    ((uint32_t)0x20080000)
N#define DMA_FLAG_HTIF6                    ((uint32_t)0x20100000)
N#define DMA_FLAG_TCIF6                    ((uint32_t)0x20200000)
N#define DMA_FLAG_FEIF7                    ((uint32_t)0x20400000)
N#define DMA_FLAG_DMEIF7                   ((uint32_t)0x21000000)
N#define DMA_FLAG_TEIF7                    ((uint32_t)0x22000000)
N#define DMA_FLAG_HTIF7                    ((uint32_t)0x24000000)
N#define DMA_FLAG_TCIF7                    ((uint32_t)0x28000000)
N
N#define IS_DMA_CLEAR_FLAG(FLAG) ((((FLAG) & 0x30000000) != 0x30000000) && (((FLAG) & 0x30000000) != 0) && \
N                                 (((FLAG) & 0xC002F082) == 0x00) && ((FLAG) != 0x00))
X#define IS_DMA_CLEAR_FLAG(FLAG) ((((FLAG) & 0x30000000) != 0x30000000) && (((FLAG) & 0x30000000) != 0) &&                                  (((FLAG) & 0xC002F082) == 0x00) && ((FLAG) != 0x00))
N
N#define IS_DMA_GET_FLAG(FLAG) (((FLAG) == DMA_FLAG_TCIF0)  || ((FLAG) == DMA_FLAG_HTIF0)  || \
N                               ((FLAG) == DMA_FLAG_TEIF0)  || ((FLAG) == DMA_FLAG_DMEIF0) || \
N                               ((FLAG) == DMA_FLAG_FEIF0)  || ((FLAG) == DMA_FLAG_TCIF1)  || \
N                               ((FLAG) == DMA_FLAG_HTIF1)  || ((FLAG) == DMA_FLAG_TEIF1)  || \
N                               ((FLAG) == DMA_FLAG_DMEIF1) || ((FLAG) == DMA_FLAG_FEIF1)  || \
N                               ((FLAG) == DMA_FLAG_TCIF2)  || ((FLAG) == DMA_FLAG_HTIF2)  || \
N                               ((FLAG) == DMA_FLAG_TEIF2)  || ((FLAG) == DMA_FLAG_DMEIF2) || \
N                               ((FLAG) == DMA_FLAG_FEIF2)  || ((FLAG) == DMA_FLAG_TCIF3)  || \
N                               ((FLAG) == DMA_FLAG_HTIF3)  || ((FLAG) == DMA_FLAG_TEIF3)  || \
N                               ((FLAG) == DMA_FLAG_DMEIF3) || ((FLAG) == DMA_FLAG_FEIF3)  || \
N                               ((FLAG) == DMA_FLAG_TCIF4)  || ((FLAG) == DMA_FLAG_HTIF4)  || \
N                               ((FLAG) == DMA_FLAG_TEIF4)  || ((FLAG) == DMA_FLAG_DMEIF4) || \
N                               ((FLAG) == DMA_FLAG_FEIF4)  || ((FLAG) == DMA_FLAG_TCIF5)  || \
N                               ((FLAG) == DMA_FLAG_HTIF5)  || ((FLAG) == DMA_FLAG_TEIF5)  || \
N                               ((FLAG) == DMA_FLAG_DMEIF5) || ((FLAG) == DMA_FLAG_FEIF5)  || \
N                               ((FLAG) == DMA_FLAG_TCIF6)  || ((FLAG) == DMA_FLAG_HTIF6)  || \
N                               ((FLAG) == DMA_FLAG_TEIF6)  || ((FLAG) == DMA_FLAG_DMEIF6) || \
N                               ((FLAG) == DMA_FLAG_FEIF6)  || ((FLAG) == DMA_FLAG_TCIF7)  || \
N                               ((FLAG) == DMA_FLAG_HTIF7)  || ((FLAG) == DMA_FLAG_TEIF7)  || \
N                               ((FLAG) == DMA_FLAG_DMEIF7) || ((FLAG) == DMA_FLAG_FEIF7))
X#define IS_DMA_GET_FLAG(FLAG) (((FLAG) == DMA_FLAG_TCIF0)  || ((FLAG) == DMA_FLAG_HTIF0)  ||                                ((FLAG) == DMA_FLAG_TEIF0)  || ((FLAG) == DMA_FLAG_DMEIF0) ||                                ((FLAG) == DMA_FLAG_FEIF0)  || ((FLAG) == DMA_FLAG_TCIF1)  ||                                ((FLAG) == DMA_FLAG_HTIF1)  || ((FLAG) == DMA_FLAG_TEIF1)  ||                                ((FLAG) == DMA_FLAG_DMEIF1) || ((FLAG) == DMA_FLAG_FEIF1)  ||                                ((FLAG) == DMA_FLAG_TCIF2)  || ((FLAG) == DMA_FLAG_HTIF2)  ||                                ((FLAG) == DMA_FLAG_TEIF2)  || ((FLAG) == DMA_FLAG_DMEIF2) ||                                ((FLAG) == DMA_FLAG_FEIF2)  || ((FLAG) == DMA_FLAG_TCIF3)  ||                                ((FLAG) == DMA_FLAG_HTIF3)  || ((FLAG) == DMA_FLAG_TEIF3)  ||                                ((FLAG) == DMA_FLAG_DMEIF3) || ((FLAG) == DMA_FLAG_FEIF3)  ||                                ((FLAG) == DMA_FLAG_TCIF4)  || ((FLAG) == DMA_FLAG_HTIF4)  ||                                ((FLAG) == DMA_FLAG_TEIF4)  || ((FLAG) == DMA_FLAG_DMEIF4) ||                                ((FLAG) == DMA_FLAG_FEIF4)  || ((FLAG) == DMA_FLAG_TCIF5)  ||                                ((FLAG) == DMA_FLAG_HTIF5)  || ((FLAG) == DMA_FLAG_TEIF5)  ||                                ((FLAG) == DMA_FLAG_DMEIF5) || ((FLAG) == DMA_FLAG_FEIF5)  ||                                ((FLAG) == DMA_FLAG_TCIF6)  || ((FLAG) == DMA_FLAG_HTIF6)  ||                                ((FLAG) == DMA_FLAG_TEIF6)  || ((FLAG) == DMA_FLAG_DMEIF6) ||                                ((FLAG) == DMA_FLAG_FEIF6)  || ((FLAG) == DMA_FLAG_TCIF7)  ||                                ((FLAG) == DMA_FLAG_HTIF7)  || ((FLAG) == DMA_FLAG_TEIF7)  ||                                ((FLAG) == DMA_FLAG_DMEIF7) || ((FLAG) == DMA_FLAG_FEIF7))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DMA_interrupt_enable_definitions 
N  * @{
N  */ 
N#define DMA_IT_TC                         ((uint32_t)0x00000010)
N#define DMA_IT_HT                         ((uint32_t)0x00000008)
N#define DMA_IT_TE                         ((uint32_t)0x00000004)
N#define DMA_IT_DME                        ((uint32_t)0x00000002)
N#define DMA_IT_FE                         ((uint32_t)0x00000080)
N
N#define IS_DMA_CONFIG_IT(IT) ((((IT) & 0xFFFFFF61) == 0x00) && ((IT) != 0x00))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DMA_interrupts_definitions 
N  * @{
N  */ 
N#define DMA_IT_FEIF0                      ((uint32_t)0x90000001)
N#define DMA_IT_DMEIF0                     ((uint32_t)0x10001004)
N#define DMA_IT_TEIF0                      ((uint32_t)0x10002008)
N#define DMA_IT_HTIF0                      ((uint32_t)0x10004010)
N#define DMA_IT_TCIF0                      ((uint32_t)0x10008020)
N#define DMA_IT_FEIF1                      ((uint32_t)0x90000040)
N#define DMA_IT_DMEIF1                     ((uint32_t)0x10001100)
N#define DMA_IT_TEIF1                      ((uint32_t)0x10002200)
N#define DMA_IT_HTIF1                      ((uint32_t)0x10004400)
N#define DMA_IT_TCIF1                      ((uint32_t)0x10008800)
N#define DMA_IT_FEIF2                      ((uint32_t)0x90010000)
N#define DMA_IT_DMEIF2                     ((uint32_t)0x10041000)
N#define DMA_IT_TEIF2                      ((uint32_t)0x10082000)
N#define DMA_IT_HTIF2                      ((uint32_t)0x10104000)
N#define DMA_IT_TCIF2                      ((uint32_t)0x10208000)
N#define DMA_IT_FEIF3                      ((uint32_t)0x90400000)
N#define DMA_IT_DMEIF3                     ((uint32_t)0x11001000)
N#define DMA_IT_TEIF3                      ((uint32_t)0x12002000)
N#define DMA_IT_HTIF3                      ((uint32_t)0x14004000)
N#define DMA_IT_TCIF3                      ((uint32_t)0x18008000)
N#define DMA_IT_FEIF4                      ((uint32_t)0xA0000001)
N#define DMA_IT_DMEIF4                     ((uint32_t)0x20001004)
N#define DMA_IT_TEIF4                      ((uint32_t)0x20002008)
N#define DMA_IT_HTIF4                      ((uint32_t)0x20004010)
N#define DMA_IT_TCIF4                      ((uint32_t)0x20008020)
N#define DMA_IT_FEIF5                      ((uint32_t)0xA0000040)
N#define DMA_IT_DMEIF5                     ((uint32_t)0x20001100)
N#define DMA_IT_TEIF5                      ((uint32_t)0x20002200)
N#define DMA_IT_HTIF5                      ((uint32_t)0x20004400)
N#define DMA_IT_TCIF5                      ((uint32_t)0x20008800)
N#define DMA_IT_FEIF6                      ((uint32_t)0xA0010000)
N#define DMA_IT_DMEIF6                     ((uint32_t)0x20041000)
N#define DMA_IT_TEIF6                      ((uint32_t)0x20082000)
N#define DMA_IT_HTIF6                      ((uint32_t)0x20104000)
N#define DMA_IT_TCIF6                      ((uint32_t)0x20208000)
N#define DMA_IT_FEIF7                      ((uint32_t)0xA0400000)
N#define DMA_IT_DMEIF7                     ((uint32_t)0x21001000)
N#define DMA_IT_TEIF7                      ((uint32_t)0x22002000)
N#define DMA_IT_HTIF7                      ((uint32_t)0x24004000)
N#define DMA_IT_TCIF7                      ((uint32_t)0x28008000)
N
N#define IS_DMA_CLEAR_IT(IT) ((((IT) & 0x30000000) != 0x30000000) && \
N                             (((IT) & 0x30000000) != 0) && ((IT) != 0x00) && \
N                             (((IT) & 0x40820082) == 0x00))
X#define IS_DMA_CLEAR_IT(IT) ((((IT) & 0x30000000) != 0x30000000) &&                              (((IT) & 0x30000000) != 0) && ((IT) != 0x00) &&                              (((IT) & 0x40820082) == 0x00))
N
N#define IS_DMA_GET_IT(IT) (((IT) == DMA_IT_TCIF0) || ((IT) == DMA_IT_HTIF0)  || \
N                           ((IT) == DMA_IT_TEIF0) || ((IT) == DMA_IT_DMEIF0) || \
N                           ((IT) == DMA_IT_FEIF0) || ((IT) == DMA_IT_TCIF1)  || \
N                           ((IT) == DMA_IT_HTIF1) || ((IT) == DMA_IT_TEIF1)  || \
N                           ((IT) == DMA_IT_DMEIF1)|| ((IT) == DMA_IT_FEIF1)  || \
N                           ((IT) == DMA_IT_TCIF2) || ((IT) == DMA_IT_HTIF2)  || \
N                           ((IT) == DMA_IT_TEIF2) || ((IT) == DMA_IT_DMEIF2) || \
N                           ((IT) == DMA_IT_FEIF2) || ((IT) == DMA_IT_TCIF3)  || \
N                           ((IT) == DMA_IT_HTIF3) || ((IT) == DMA_IT_TEIF3)  || \
N                           ((IT) == DMA_IT_DMEIF3)|| ((IT) == DMA_IT_FEIF3)  || \
N                           ((IT) == DMA_IT_TCIF4) || ((IT) == DMA_IT_HTIF4)  || \
N                           ((IT) == DMA_IT_TEIF4) || ((IT) == DMA_IT_DMEIF4) || \
N                           ((IT) == DMA_IT_FEIF4) || ((IT) == DMA_IT_TCIF5)  || \
N                           ((IT) == DMA_IT_HTIF5) || ((IT) == DMA_IT_TEIF5)  || \
N                           ((IT) == DMA_IT_DMEIF5)|| ((IT) == DMA_IT_FEIF5)  || \
N                           ((IT) == DMA_IT_TCIF6) || ((IT) == DMA_IT_HTIF6)  || \
N                           ((IT) == DMA_IT_TEIF6) || ((IT) == DMA_IT_DMEIF6) || \
N                           ((IT) == DMA_IT_FEIF6) || ((IT) == DMA_IT_TCIF7)  || \
N                           ((IT) == DMA_IT_HTIF7) || ((IT) == DMA_IT_TEIF7)  || \
N                           ((IT) == DMA_IT_DMEIF7)|| ((IT) == DMA_IT_FEIF7))
X#define IS_DMA_GET_IT(IT) (((IT) == DMA_IT_TCIF0) || ((IT) == DMA_IT_HTIF0)  ||                            ((IT) == DMA_IT_TEIF0) || ((IT) == DMA_IT_DMEIF0) ||                            ((IT) == DMA_IT_FEIF0) || ((IT) == DMA_IT_TCIF1)  ||                            ((IT) == DMA_IT_HTIF1) || ((IT) == DMA_IT_TEIF1)  ||                            ((IT) == DMA_IT_DMEIF1)|| ((IT) == DMA_IT_FEIF1)  ||                            ((IT) == DMA_IT_TCIF2) || ((IT) == DMA_IT_HTIF2)  ||                            ((IT) == DMA_IT_TEIF2) || ((IT) == DMA_IT_DMEIF2) ||                            ((IT) == DMA_IT_FEIF2) || ((IT) == DMA_IT_TCIF3)  ||                            ((IT) == DMA_IT_HTIF3) || ((IT) == DMA_IT_TEIF3)  ||                            ((IT) == DMA_IT_DMEIF3)|| ((IT) == DMA_IT_FEIF3)  ||                            ((IT) == DMA_IT_TCIF4) || ((IT) == DMA_IT_HTIF4)  ||                            ((IT) == DMA_IT_TEIF4) || ((IT) == DMA_IT_DMEIF4) ||                            ((IT) == DMA_IT_FEIF4) || ((IT) == DMA_IT_TCIF5)  ||                            ((IT) == DMA_IT_HTIF5) || ((IT) == DMA_IT_TEIF5)  ||                            ((IT) == DMA_IT_DMEIF5)|| ((IT) == DMA_IT_FEIF5)  ||                            ((IT) == DMA_IT_TCIF6) || ((IT) == DMA_IT_HTIF6)  ||                            ((IT) == DMA_IT_TEIF6) || ((IT) == DMA_IT_DMEIF6) ||                            ((IT) == DMA_IT_FEIF6) || ((IT) == DMA_IT_TCIF7)  ||                            ((IT) == DMA_IT_HTIF7) || ((IT) == DMA_IT_TEIF7)  ||                            ((IT) == DMA_IT_DMEIF7)|| ((IT) == DMA_IT_FEIF7))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DMA_peripheral_increment_offset 
N  * @{
N  */ 
N#define DMA_PINCOS_Psize                  ((uint32_t)0x00000000)
N#define DMA_PINCOS_WordAligned            ((uint32_t)0x00008000)
N
N#define IS_DMA_PINCOS_SIZE(SIZE) (((SIZE) == DMA_PINCOS_Psize) || \
N                                  ((SIZE) == DMA_PINCOS_WordAligned))
X#define IS_DMA_PINCOS_SIZE(SIZE) (((SIZE) == DMA_PINCOS_Psize) ||                                   ((SIZE) == DMA_PINCOS_WordAligned))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DMA_flow_controller_definitions 
N  * @{
N  */ 
N#define DMA_FlowCtrl_Memory               ((uint32_t)0x00000000)
N#define DMA_FlowCtrl_Peripheral           ((uint32_t)0x00000020)
N
N#define IS_DMA_FLOW_CTRL(CTRL) (((CTRL) == DMA_FlowCtrl_Memory) || \
N                                ((CTRL) == DMA_FlowCtrl_Peripheral))
X#define IS_DMA_FLOW_CTRL(CTRL) (((CTRL) == DMA_FlowCtrl_Memory) ||                                 ((CTRL) == DMA_FlowCtrl_Peripheral))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DMA_memory_targets_definitions 
N  * @{
N  */ 
N#define DMA_Memory_0                      ((uint32_t)0x00000000)
N#define DMA_Memory_1                      ((uint32_t)0x00080000)
N
N#define IS_DMA_CURRENT_MEM(MEM) (((MEM) == DMA_Memory_0) || ((MEM) == DMA_Memory_1))
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/ 
N
N/*  Function used to set the DMA configuration to the default reset state *****/ 
Nvoid DMA_DeInit(DMA_Stream_TypeDef* DMAy_Streamx);
N
N/* Initialization and Configuration functions *********************************/
Nvoid DMA_Init(DMA_Stream_TypeDef* DMAy_Streamx, DMA_InitTypeDef* DMA_InitStruct);
Nvoid DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct);
Nvoid DMA_Cmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState);
N
N/* Optional Configuration functions *******************************************/
Nvoid DMA_PeriphIncOffsetSizeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_Pincos);
Nvoid DMA_FlowControllerConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FlowCtrl);
N
N/* Data Counter functions *****************************************************/
Nvoid DMA_SetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx, uint16_t Counter);
Nuint16_t DMA_GetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx);
N
N/* Double Buffer mode functions ***********************************************/
Nvoid DMA_DoubleBufferModeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t Memory1BaseAddr,
N                                uint32_t DMA_CurrentMemory);
Nvoid DMA_DoubleBufferModeCmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState);
Nvoid DMA_MemoryTargetConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t MemoryBaseAddr,
N                            uint32_t DMA_MemoryTarget);
Nuint32_t DMA_GetCurrentMemoryTarget(DMA_Stream_TypeDef* DMAy_Streamx);
N
N/* Interrupts and flags management functions **********************************/
NFunctionalState DMA_GetCmdStatus(DMA_Stream_TypeDef* DMAy_Streamx);
Nuint32_t DMA_GetFIFOStatus(DMA_Stream_TypeDef* DMAy_Streamx);
NFlagStatus DMA_GetFlagStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG);
Nvoid DMA_ClearFlag(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG);
Nvoid DMA_ITConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT, FunctionalState NewState);
NITStatus DMA_GetITStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT);
Nvoid DMA_ClearITPendingBit(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F4xx_DMA_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 38 "..\..\Service\stm32f4xx_conf.h" 2
N#include "stm32f4xx_exti.h"
L 1 "..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\stm32f4xx_exti.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_exti.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    04-November-2016
N  * @brief   This file contains all the functions prototypes for the EXTI firmware
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_EXTI_H
N#define __STM32F4xx_EXTI_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
N
N/** @addtogroup STM32F4xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup EXTI
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  EXTI mode enumeration  
N  */
N
Ntypedef enum
N{
N  EXTI_Mode_Interrupt = 0x00,
N  EXTI_Mode_Event = 0x04
N}EXTIMode_TypeDef;
N
N#define IS_EXTI_MODE(MODE) (((MODE) == EXTI_Mode_Interrupt) || ((MODE) == EXTI_Mode_Event))
N
N/** 
N  * @brief  EXTI Trigger enumeration  
N  */
N
Ntypedef enum
N{
N  EXTI_Trigger_Rising = 0x08,
N  EXTI_Trigger_Falling = 0x0C,  
N  EXTI_Trigger_Rising_Falling = 0x10
N}EXTITrigger_TypeDef;
N
N#define IS_EXTI_TRIGGER(TRIGGER) (((TRIGGER) == EXTI_Trigger_Rising) || \
N                                  ((TRIGGER) == EXTI_Trigger_Falling) || \
N                                  ((TRIGGER) == EXTI_Trigger_Rising_Falling))
X#define IS_EXTI_TRIGGER(TRIGGER) (((TRIGGER) == EXTI_Trigger_Rising) ||                                   ((TRIGGER) == EXTI_Trigger_Falling) ||                                   ((TRIGGER) == EXTI_Trigger_Rising_Falling))
N/** 
N  * @brief  EXTI Init Structure definition  
N  */
N
Ntypedef struct
N{
N  uint32_t EXTI_Line;               /*!< Specifies the EXTI lines to be enabled or disabled.
N                                         This parameter can be any combination value of @ref EXTI_Lines */
N   
N  EXTIMode_TypeDef EXTI_Mode;       /*!< Specifies the mode for the EXTI lines.
N                                         This parameter can be a value of @ref EXTIMode_TypeDef */
N
N  EXTITrigger_TypeDef EXTI_Trigger; /*!< Specifies the trigger signal active edge for the EXTI lines.
N                                         This parameter can be a value of @ref EXTITrigger_TypeDef */
N
N  FunctionalState EXTI_LineCmd;     /*!< Specifies the new state of the selected EXTI lines.
N                                         This parameter can be set either to ENABLE or DISABLE */ 
N}EXTI_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup EXTI_Exported_Constants
N  * @{
N  */
N
N/** @defgroup EXTI_Lines 
N  * @{
N  */
N
N#define EXTI_Line0       ((uint32_t)0x00001)     /*!< External interrupt line 0 */
N#define EXTI_Line1       ((uint32_t)0x00002)     /*!< External interrupt line 1 */
N#define EXTI_Line2       ((uint32_t)0x00004)     /*!< External interrupt line 2 */
N#define EXTI_Line3       ((uint32_t)0x00008)     /*!< External interrupt line 3 */
N#define EXTI_Line4       ((uint32_t)0x00010)     /*!< External interrupt line 4 */
N#define EXTI_Line5       ((uint32_t)0x00020)     /*!< External interrupt line 5 */
N#define EXTI_Line6       ((uint32_t)0x00040)     /*!< External interrupt line 6 */
N#define EXTI_Line7       ((uint32_t)0x00080)     /*!< External interrupt line 7 */
N#define EXTI_Line8       ((uint32_t)0x00100)     /*!< External interrupt line 8 */
N#define EXTI_Line9       ((uint32_t)0x00200)     /*!< External interrupt line 9 */
N#define EXTI_Line10      ((uint32_t)0x00400)     /*!< External interrupt line 10 */
N#define EXTI_Line11      ((uint32_t)0x00800)     /*!< External interrupt line 11 */
N#define EXTI_Line12      ((uint32_t)0x01000)     /*!< External interrupt line 12 */
N#define EXTI_Line13      ((uint32_t)0x02000)     /*!< External interrupt line 13 */
N#define EXTI_Line14      ((uint32_t)0x04000)     /*!< External interrupt line 14 */
N#define EXTI_Line15      ((uint32_t)0x08000)     /*!< External interrupt line 15 */
N#define EXTI_Line16      ((uint32_t)0x10000)     /*!< External interrupt line 16 Connected to the PVD Output */
N#define EXTI_Line17      ((uint32_t)0x20000)     /*!< External interrupt line 17 Connected to the RTC Alarm event */
N#define EXTI_Line18      ((uint32_t)0x40000)     /*!< External interrupt line 18 Connected to the USB OTG FS Wakeup from suspend event */                                    
N#define EXTI_Line19      ((uint32_t)0x80000)     /*!< External interrupt line 19 Connected to the Ethernet Wakeup event */
N#define EXTI_Line20      ((uint32_t)0x00100000)  /*!< External interrupt line 20 Connected to the USB OTG HS (configured in FS) Wakeup event  */
N#define EXTI_Line21      ((uint32_t)0x00200000)  /*!< External interrupt line 21 Connected to the RTC Tamper and Time Stamp events */                                               
N#define EXTI_Line22      ((uint32_t)0x00400000)  /*!< External interrupt line 22 Connected to the RTC Wakeup event */
N#define EXTI_Line23      ((uint32_t)0x00800000)  /*!< External interrupt line 23 Connected to the LPTIM Wakeup event */
N
N                                          
N#define IS_EXTI_LINE(LINE) ((((LINE) & (uint32_t)0xFF800000) == 0x00) && ((LINE) != (uint16_t)0x00))
N
N#define IS_GET_EXTI_LINE(LINE) (((LINE) == EXTI_Line0) || ((LINE) == EXTI_Line1) || \
N                                ((LINE) == EXTI_Line2) || ((LINE) == EXTI_Line3) || \
N                                ((LINE) == EXTI_Line4) || ((LINE) == EXTI_Line5) || \
N                                ((LINE) == EXTI_Line6) || ((LINE) == EXTI_Line7) || \
N                                ((LINE) == EXTI_Line8) || ((LINE) == EXTI_Line9) || \
N                                ((LINE) == EXTI_Line10) || ((LINE) == EXTI_Line11) || \
N                                ((LINE) == EXTI_Line12) || ((LINE) == EXTI_Line13) || \
N                                ((LINE) == EXTI_Line14) || ((LINE) == EXTI_Line15) || \
N                                ((LINE) == EXTI_Line16) || ((LINE) == EXTI_Line17) || \
N                                ((LINE) == EXTI_Line18) || ((LINE) == EXTI_Line19) || \
N                                ((LINE) == EXTI_Line20) || ((LINE) == EXTI_Line21) ||\
N                                ((LINE) == EXTI_Line22) || ((LINE) == EXTI_Line23))
X#define IS_GET_EXTI_LINE(LINE) (((LINE) == EXTI_Line0) || ((LINE) == EXTI_Line1) ||                                 ((LINE) == EXTI_Line2) || ((LINE) == EXTI_Line3) ||                                 ((LINE) == EXTI_Line4) || ((LINE) == EXTI_Line5) ||                                 ((LINE) == EXTI_Line6) || ((LINE) == EXTI_Line7) ||                                 ((LINE) == EXTI_Line8) || ((LINE) == EXTI_Line9) ||                                 ((LINE) == EXTI_Line10) || ((LINE) == EXTI_Line11) ||                                 ((LINE) == EXTI_Line12) || ((LINE) == EXTI_Line13) ||                                 ((LINE) == EXTI_Line14) || ((LINE) == EXTI_Line15) ||                                 ((LINE) == EXTI_Line16) || ((LINE) == EXTI_Line17) ||                                 ((LINE) == EXTI_Line18) || ((LINE) == EXTI_Line19) ||                                 ((LINE) == EXTI_Line20) || ((LINE) == EXTI_Line21) ||                                ((LINE) == EXTI_Line22) || ((LINE) == EXTI_Line23))
N                    
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/
N
N/*  Function used to set the EXTI configuration to the default reset state *****/
Nvoid EXTI_DeInit(void);
N
N/* Initialization and Configuration functions *********************************/
Nvoid EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct);
Nvoid EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct);
Nvoid EXTI_GenerateSWInterrupt(uint32_t EXTI_Line);
N
N/* Interrupts and flags management functions **********************************/
NFlagStatus EXTI_GetFlagStatus(uint32_t EXTI_Line);
Nvoid EXTI_ClearFlag(uint32_t EXTI_Line);
NITStatus EXTI_GetITStatus(uint32_t EXTI_Line);
Nvoid EXTI_ClearITPendingBit(uint32_t EXTI_Line);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_EXTI_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 39 "..\..\Service\stm32f4xx_conf.h" 2
N#include "stm32f4xx_flash.h"
L 1 "..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\stm32f4xx_flash.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_flash.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    04-November-2016
N  * @brief   This file contains all the functions prototypes for the FLASH 
N  *          firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_FLASH_H
N#define __STM32F4xx_FLASH_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
N
N/** @addtogroup STM32F4xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup FLASH
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/** 
N  * @brief FLASH Status  
N  */ 
Ntypedef enum
N{ 
N  FLASH_BUSY = 1,
N  FLASH_ERROR_RD,
N  FLASH_ERROR_PGS,
N  FLASH_ERROR_PGP,
N  FLASH_ERROR_PGA,
N  FLASH_ERROR_WRP,
N  FLASH_ERROR_PROGRAM,
N  FLASH_ERROR_OPERATION,
N  FLASH_COMPLETE
N}FLASH_Status;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup FLASH_Exported_Constants
N  * @{
N  */  
N
N/** @defgroup Flash_Latency 
N  * @{
N  */ 
N#define FLASH_Latency_0                ((uint8_t)0x0000)  /*!< FLASH Zero Latency cycle      */
N#define FLASH_Latency_1                ((uint8_t)0x0001)  /*!< FLASH One Latency cycle       */
N#define FLASH_Latency_2                ((uint8_t)0x0002)  /*!< FLASH Two Latency cycles      */
N#define FLASH_Latency_3                ((uint8_t)0x0003)  /*!< FLASH Three Latency cycles    */
N#define FLASH_Latency_4                ((uint8_t)0x0004)  /*!< FLASH Four Latency cycles     */
N#define FLASH_Latency_5                ((uint8_t)0x0005)  /*!< FLASH Five Latency cycles     */
N#define FLASH_Latency_6                ((uint8_t)0x0006)  /*!< FLASH Six Latency cycles      */
N#define FLASH_Latency_7                ((uint8_t)0x0007)  /*!< FLASH Seven Latency cycles    */
N#define FLASH_Latency_8                ((uint8_t)0x0008)  /*!< FLASH Eight Latency cycles    */
N#define FLASH_Latency_9                ((uint8_t)0x0009)  /*!< FLASH Nine Latency cycles     */
N#define FLASH_Latency_10               ((uint8_t)0x000A)  /*!< FLASH Ten Latency cycles      */
N#define FLASH_Latency_11               ((uint8_t)0x000B)  /*!< FLASH Eleven Latency cycles   */
N#define FLASH_Latency_12               ((uint8_t)0x000C)  /*!< FLASH Twelve Latency cycles   */
N#define FLASH_Latency_13               ((uint8_t)0x000D)  /*!< FLASH Thirteen Latency cycles */
N#define FLASH_Latency_14               ((uint8_t)0x000E)  /*!< FLASH Fourteen Latency cycles */
N#define FLASH_Latency_15               ((uint8_t)0x000F)  /*!< FLASH Fifteen Latency cycles  */
N
N
N#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_Latency_0)  || \
N                                   ((LATENCY) == FLASH_Latency_1)  || \
N                                   ((LATENCY) == FLASH_Latency_2)  || \
N                                   ((LATENCY) == FLASH_Latency_3)  || \
N                                   ((LATENCY) == FLASH_Latency_4)  || \
N                                   ((LATENCY) == FLASH_Latency_5)  || \
N                                   ((LATENCY) == FLASH_Latency_6)  || \
N                                   ((LATENCY) == FLASH_Latency_7)  || \
N                                   ((LATENCY) == FLASH_Latency_8)  || \
N                                   ((LATENCY) == FLASH_Latency_9)  || \
N                                   ((LATENCY) == FLASH_Latency_10) || \
N                                   ((LATENCY) == FLASH_Latency_11) || \
N                                   ((LATENCY) == FLASH_Latency_12) || \
N                                   ((LATENCY) == FLASH_Latency_13) || \
N                                   ((LATENCY) == FLASH_Latency_14) || \
N                                   ((LATENCY) == FLASH_Latency_15))
X#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_Latency_0)  ||                                    ((LATENCY) == FLASH_Latency_1)  ||                                    ((LATENCY) == FLASH_Latency_2)  ||                                    ((LATENCY) == FLASH_Latency_3)  ||                                    ((LATENCY) == FLASH_Latency_4)  ||                                    ((LATENCY) == FLASH_Latency_5)  ||                                    ((LATENCY) == FLASH_Latency_6)  ||                                    ((LATENCY) == FLASH_Latency_7)  ||                                    ((LATENCY) == FLASH_Latency_8)  ||                                    ((LATENCY) == FLASH_Latency_9)  ||                                    ((LATENCY) == FLASH_Latency_10) ||                                    ((LATENCY) == FLASH_Latency_11) ||                                    ((LATENCY) == FLASH_Latency_12) ||                                    ((LATENCY) == FLASH_Latency_13) ||                                    ((LATENCY) == FLASH_Latency_14) ||                                    ((LATENCY) == FLASH_Latency_15))
N/**
N  * @}
N  */ 
N
N/** @defgroup FLASH_Voltage_Range 
N  * @{
N  */ 
N#define VoltageRange_1        ((uint8_t)0x00)  /*!< Device operating range: 1.8V to 2.1V */
N#define VoltageRange_2        ((uint8_t)0x01)  /*!<Device operating range: 2.1V to 2.7V */
N#define VoltageRange_3        ((uint8_t)0x02)  /*!<Device operating range: 2.7V to 3.6V */
N#define VoltageRange_4        ((uint8_t)0x03)  /*!<Device operating range: 2.7V to 3.6V + External Vpp */
N
N#define IS_VOLTAGERANGE(RANGE)(((RANGE) == VoltageRange_1) || \
N                               ((RANGE) == VoltageRange_2) || \
N                               ((RANGE) == VoltageRange_3) || \
N                               ((RANGE) == VoltageRange_4))
X#define IS_VOLTAGERANGE(RANGE)(((RANGE) == VoltageRange_1) ||                                ((RANGE) == VoltageRange_2) ||                                ((RANGE) == VoltageRange_3) ||                                ((RANGE) == VoltageRange_4))
N/**
N  * @}
N  */ 
N
N/** @defgroup FLASH_Sectors
N  * @{
N  */
N#define FLASH_Sector_0     ((uint16_t)0x0000) /*!< Sector Number 0   */
N#define FLASH_Sector_1     ((uint16_t)0x0008) /*!< Sector Number 1   */
N#define FLASH_Sector_2     ((uint16_t)0x0010) /*!< Sector Number 2   */
N#define FLASH_Sector_3     ((uint16_t)0x0018) /*!< Sector Number 3   */
N#define FLASH_Sector_4     ((uint16_t)0x0020) /*!< Sector Number 4   */
N#define FLASH_Sector_5     ((uint16_t)0x0028) /*!< Sector Number 5   */
N#define FLASH_Sector_6     ((uint16_t)0x0030) /*!< Sector Number 6   */
N#define FLASH_Sector_7     ((uint16_t)0x0038) /*!< Sector Number 7   */
N#define FLASH_Sector_8     ((uint16_t)0x0040) /*!< Sector Number 8   */
N#define FLASH_Sector_9     ((uint16_t)0x0048) /*!< Sector Number 9   */
N#define FLASH_Sector_10    ((uint16_t)0x0050) /*!< Sector Number 10  */
N#define FLASH_Sector_11    ((uint16_t)0x0058) /*!< Sector Number 11  */
N#define FLASH_Sector_12    ((uint16_t)0x0080) /*!< Sector Number 12  */
N#define FLASH_Sector_13    ((uint16_t)0x0088) /*!< Sector Number 13  */
N#define FLASH_Sector_14    ((uint16_t)0x0090) /*!< Sector Number 14  */
N#define FLASH_Sector_15    ((uint16_t)0x0098) /*!< Sector Number 15  */
N#define FLASH_Sector_16    ((uint16_t)0x00A0) /*!< Sector Number 16  */
N#define FLASH_Sector_17    ((uint16_t)0x00A8) /*!< Sector Number 17  */
N#define FLASH_Sector_18    ((uint16_t)0x00B0) /*!< Sector Number 18  */
N#define FLASH_Sector_19    ((uint16_t)0x00B8) /*!< Sector Number 19  */
N#define FLASH_Sector_20    ((uint16_t)0x00C0) /*!< Sector Number 20  */
N#define FLASH_Sector_21    ((uint16_t)0x00C8) /*!< Sector Number 21  */
N#define FLASH_Sector_22    ((uint16_t)0x00D0) /*!< Sector Number 22  */
N#define FLASH_Sector_23    ((uint16_t)0x00D8) /*!< Sector Number 23  */
N
N#define IS_FLASH_SECTOR(SECTOR) (((SECTOR) == FLASH_Sector_0)   || ((SECTOR) == FLASH_Sector_1)   ||\
N                                 ((SECTOR) == FLASH_Sector_2)   || ((SECTOR) == FLASH_Sector_3)   ||\
N                                 ((SECTOR) == FLASH_Sector_4)   || ((SECTOR) == FLASH_Sector_5)   ||\
N                                 ((SECTOR) == FLASH_Sector_6)   || ((SECTOR) == FLASH_Sector_7)   ||\
N                                 ((SECTOR) == FLASH_Sector_8)   || ((SECTOR) == FLASH_Sector_9)   ||\
N                                 ((SECTOR) == FLASH_Sector_10)  || ((SECTOR) == FLASH_Sector_11)  ||\
N                                 ((SECTOR) == FLASH_Sector_12)  || ((SECTOR) == FLASH_Sector_13)  ||\
N                                 ((SECTOR) == FLASH_Sector_14)  || ((SECTOR) == FLASH_Sector_15)  ||\
N                                 ((SECTOR) == FLASH_Sector_16)  || ((SECTOR) == FLASH_Sector_17)  ||\
N                                 ((SECTOR) == FLASH_Sector_18)  || ((SECTOR) == FLASH_Sector_19)  ||\
N                                 ((SECTOR) == FLASH_Sector_20)  || ((SECTOR) == FLASH_Sector_21)  ||\
N                                 ((SECTOR) == FLASH_Sector_22)  || ((SECTOR) == FLASH_Sector_23))
X#define IS_FLASH_SECTOR(SECTOR) (((SECTOR) == FLASH_Sector_0)   || ((SECTOR) == FLASH_Sector_1)   ||                                 ((SECTOR) == FLASH_Sector_2)   || ((SECTOR) == FLASH_Sector_3)   ||                                 ((SECTOR) == FLASH_Sector_4)   || ((SECTOR) == FLASH_Sector_5)   ||                                 ((SECTOR) == FLASH_Sector_6)   || ((SECTOR) == FLASH_Sector_7)   ||                                 ((SECTOR) == FLASH_Sector_8)   || ((SECTOR) == FLASH_Sector_9)   ||                                 ((SECTOR) == FLASH_Sector_10)  || ((SECTOR) == FLASH_Sector_11)  ||                                 ((SECTOR) == FLASH_Sector_12)  || ((SECTOR) == FLASH_Sector_13)  ||                                 ((SECTOR) == FLASH_Sector_14)  || ((SECTOR) == FLASH_Sector_15)  ||                                 ((SECTOR) == FLASH_Sector_16)  || ((SECTOR) == FLASH_Sector_17)  ||                                 ((SECTOR) == FLASH_Sector_18)  || ((SECTOR) == FLASH_Sector_19)  ||                                 ((SECTOR) == FLASH_Sector_20)  || ((SECTOR) == FLASH_Sector_21)  ||                                 ((SECTOR) == FLASH_Sector_22)  || ((SECTOR) == FLASH_Sector_23))
N
N#if defined (STM32F427_437xx) || defined (STM32F429_439xx) || defined (STM32F469_479xx)
X#if 0L || 0L || 0L
S#define IS_FLASH_ADDRESS(ADDRESS) ((((ADDRESS) >= 0x08000000) && ((ADDRESS) <= 0x081FFFFF)) ||\
S                                   (((ADDRESS) >= 0x1FFF7800) && ((ADDRESS) <= 0x1FFF7A0F)))  
X#define IS_FLASH_ADDRESS(ADDRESS) ((((ADDRESS) >= 0x08000000) && ((ADDRESS) <= 0x081FFFFF)) ||                                   (((ADDRESS) >= 0x1FFF7800) && ((ADDRESS) <= 0x1FFF7A0F)))  
N#endif /* STM32F427_437xx || STM32F429_439xx || STM32F469_479xx */
N
N#if defined (STM32F40_41xxx) || defined(STM32F412xG)
X#if 1L || 0L
N#define IS_FLASH_ADDRESS(ADDRESS) ((((ADDRESS) >= 0x08000000) && ((ADDRESS) <= 0x080FFFFF)) ||\
N                                   (((ADDRESS) >= 0x1FFF7800) && ((ADDRESS) <= 0x1FFF7A0F))) 
X#define IS_FLASH_ADDRESS(ADDRESS) ((((ADDRESS) >= 0x08000000) && ((ADDRESS) <= 0x080FFFFF)) ||                                   (((ADDRESS) >= 0x1FFF7800) && ((ADDRESS) <= 0x1FFF7A0F))) 
N#endif /* STM32F40_41xxx || STM32F412xG */
N
N#if defined (STM32F401xx)
X#if 0L
S#define IS_FLASH_ADDRESS(ADDRESS) ((((ADDRESS) >= 0x08000000) && ((ADDRESS) <= 0x0803FFFF)) ||\
S                                   (((ADDRESS) >= 0x1FFF7800) && ((ADDRESS) <= 0x1FFF7A0F)))
X#define IS_FLASH_ADDRESS(ADDRESS) ((((ADDRESS) >= 0x08000000) && ((ADDRESS) <= 0x0803FFFF)) ||                                   (((ADDRESS) >= 0x1FFF7800) && ((ADDRESS) <= 0x1FFF7A0F)))
N#endif /* STM32F401xx */
N
N#if defined (STM32F411xE) || defined (STM32F446xx)
X#if 0L || 0L
S#define IS_FLASH_ADDRESS(ADDRESS) ((((ADDRESS) >= 0x08000000) && ((ADDRESS) <= 0x0807FFFF)) ||\
S                                   (((ADDRESS) >= 0x1FFF7800) && ((ADDRESS) <= 0x1FFF7A0F)))
X#define IS_FLASH_ADDRESS(ADDRESS) ((((ADDRESS) >= 0x08000000) && ((ADDRESS) <= 0x0807FFFF)) ||                                   (((ADDRESS) >= 0x1FFF7800) && ((ADDRESS) <= 0x1FFF7A0F)))
N#endif /* STM32F411xE || STM32F446xx */
N
N#if defined (STM32F410xx)
X#if 0L
S#define IS_FLASH_ADDRESS(ADDRESS) ((((ADDRESS) >= 0x08000000) && ((ADDRESS) <= 0x0801FFFF)) ||\
S                                   (((ADDRESS) >= 0x1FFF7800) && ((ADDRESS) <= 0x1FFF7A0F)))
X#define IS_FLASH_ADDRESS(ADDRESS) ((((ADDRESS) >= 0x08000000) && ((ADDRESS) <= 0x0801FFFF)) ||                                   (((ADDRESS) >= 0x1FFF7800) && ((ADDRESS) <= 0x1FFF7A0F)))
N#endif /* STM32F410xx */
N
N#if defined(STM32F413_423xx)
X#if 0L
S#define IS_FLASH_ADDRESS(ADDRESS) ((((ADDRESS) >= 0x08000000) && ((ADDRESS) <= 0x0817FFFF)) ||\
S                                   (((ADDRESS) >= 0x1FFF7800) && ((ADDRESS) <= 0x1FFF7BDF)))
X#define IS_FLASH_ADDRESS(ADDRESS) ((((ADDRESS) >= 0x08000000) && ((ADDRESS) <= 0x0817FFFF)) ||                                   (((ADDRESS) >= 0x1FFF7800) && ((ADDRESS) <= 0x1FFF7BDF)))
N#endif /* STM32F413_423xx */
N/**
N  * @}
N  */ 
N
N/** @defgroup Option_Bytes_Write_Protection 
N  * @{
N  */ 
N#define OB_WRP_Sector_0       ((uint32_t)0x00000001) /*!< Write protection of Sector0     */
N#define OB_WRP_Sector_1       ((uint32_t)0x00000002) /*!< Write protection of Sector1     */
N#define OB_WRP_Sector_2       ((uint32_t)0x00000004) /*!< Write protection of Sector2     */
N#define OB_WRP_Sector_3       ((uint32_t)0x00000008) /*!< Write protection of Sector3     */
N#define OB_WRP_Sector_4       ((uint32_t)0x00000010) /*!< Write protection of Sector4     */
N#define OB_WRP_Sector_5       ((uint32_t)0x00000020) /*!< Write protection of Sector5     */
N#define OB_WRP_Sector_6       ((uint32_t)0x00000040) /*!< Write protection of Sector6     */
N#define OB_WRP_Sector_7       ((uint32_t)0x00000080) /*!< Write protection of Sector7     */
N#define OB_WRP_Sector_8       ((uint32_t)0x00000100) /*!< Write protection of Sector8     */
N#define OB_WRP_Sector_9       ((uint32_t)0x00000200) /*!< Write protection of Sector9     */
N#define OB_WRP_Sector_10      ((uint32_t)0x00000400) /*!< Write protection of Sector10    */
N#define OB_WRP_Sector_11      ((uint32_t)0x00000800) /*!< Write protection of Sector11    */
N#define OB_WRP_Sector_12      ((uint32_t)0x00000001) /*!< Write protection of Sector12    */
N#define OB_WRP_Sector_13      ((uint32_t)0x00000002) /*!< Write protection of Sector13    */
N#define OB_WRP_Sector_14      ((uint32_t)0x00000004) /*!< Write protection of Sector14    */
N#define OB_WRP_Sector_15      ((uint32_t)0x00000008) /*!< Write protection of Sector15    */
N#define OB_WRP_Sector_16      ((uint32_t)0x00000010) /*!< Write protection of Sector16    */
N#define OB_WRP_Sector_17      ((uint32_t)0x00000020) /*!< Write protection of Sector17    */
N#define OB_WRP_Sector_18      ((uint32_t)0x00000040) /*!< Write protection of Sector18    */
N#define OB_WRP_Sector_19      ((uint32_t)0x00000080) /*!< Write protection of Sector19    */
N#define OB_WRP_Sector_20      ((uint32_t)0x00000100) /*!< Write protection of Sector20    */
N#define OB_WRP_Sector_21      ((uint32_t)0x00000200) /*!< Write protection of Sector21    */
N#define OB_WRP_Sector_22      ((uint32_t)0x00000400) /*!< Write protection of Sector22    */
N#define OB_WRP_Sector_23      ((uint32_t)0x00000800) /*!< Write protection of Sector23    */
N#define OB_WRP_Sector_All     ((uint32_t)0x00000FFF) /*!< Write protection of all Sectors */
N
N#define IS_OB_WRP(SECTOR)((((SECTOR) & (uint32_t)0xFFFFF000) == 0x00000000) && ((SECTOR) != 0x00000000))
N/**
N  * @}
N  */
N
N/** @defgroup  Selection_Protection_Mode
N  * @{
N  */
N#define OB_PcROP_Disable   ((uint8_t)0x00) /*!< Disabled PcROP, nWPRi bits used for Write Protection on sector i */
N#define OB_PcROP_Enable    ((uint8_t)0x80) /*!< Enable PcROP, nWPRi bits used for PCRoP Protection on sector i   */
N#define IS_OB_PCROP_SELECT(PCROP) (((PCROP) == OB_PcROP_Disable) || ((PCROP) == OB_PcROP_Enable))
N/**
N  * @}
N  */
N
N/** @defgroup Option_Bytes_PC_ReadWrite_Protection 
N  * @{
N  */ 
N#define OB_PCROP_Sector_0        ((uint32_t)0x00000001) /*!< PC Read/Write protection of Sector0      */
N#define OB_PCROP_Sector_1        ((uint32_t)0x00000002) /*!< PC Read/Write protection of Sector1      */
N#define OB_PCROP_Sector_2        ((uint32_t)0x00000004) /*!< PC Read/Write protection of Sector2      */
N#define OB_PCROP_Sector_3        ((uint32_t)0x00000008) /*!< PC Read/Write protection of Sector3      */
N#define OB_PCROP_Sector_4        ((uint32_t)0x00000010) /*!< PC Read/Write protection of Sector4      */
N#define OB_PCROP_Sector_5        ((uint32_t)0x00000020) /*!< PC Read/Write protection of Sector5      */
N#define OB_PCROP_Sector_6        ((uint32_t)0x00000040) /*!< PC Read/Write protection of Sector6      */
N#define OB_PCROP_Sector_7        ((uint32_t)0x00000080) /*!< PC Read/Write protection of Sector7      */
N#define OB_PCROP_Sector_8        ((uint32_t)0x00000100) /*!< PC Read/Write protection of Sector8      */
N#define OB_PCROP_Sector_9        ((uint32_t)0x00000200) /*!< PC Read/Write protection of Sector9      */
N#define OB_PCROP_Sector_10       ((uint32_t)0x00000400) /*!< PC Read/Write protection of Sector10     */
N#define OB_PCROP_Sector_11       ((uint32_t)0x00000800) /*!< PC Read/Write protection of Sector11     */
N#define OB_PCROP_Sector_12       ((uint32_t)0x00000001) /*!< PC Read/Write protection of Sector12     */
N#define OB_PCROP_Sector_13       ((uint32_t)0x00000002) /*!< PC Read/Write protection of Sector13     */
N#define OB_PCROP_Sector_14       ((uint32_t)0x00000004) /*!< PC Read/Write protection of Sector14     */
N#define OB_PCROP_Sector_15       ((uint32_t)0x00000008) /*!< PC Read/Write protection of Sector15     */
N#define OB_PCROP_Sector_16       ((uint32_t)0x00000010) /*!< PC Read/Write protection of Sector16     */
N#define OB_PCROP_Sector_17       ((uint32_t)0x00000020) /*!< PC Read/Write protection of Sector17     */
N#define OB_PCROP_Sector_18       ((uint32_t)0x00000040) /*!< PC Read/Write protection of Sector18     */
N#define OB_PCROP_Sector_19       ((uint32_t)0x00000080) /*!< PC Read/Write protection of Sector19     */
N#define OB_PCROP_Sector_20       ((uint32_t)0x00000100) /*!< PC Read/Write protection of Sector20     */
N#define OB_PCROP_Sector_21       ((uint32_t)0x00000200) /*!< PC Read/Write protection of Sector21     */
N#define OB_PCROP_Sector_22       ((uint32_t)0x00000400) /*!< PC Read/Write protection of Sector22     */
N#define OB_PCROP_Sector_23       ((uint32_t)0x00000800) /*!< PC Read/Write protection of Sector23     */
N#define OB_PCROP_Sector_All      ((uint32_t)0x00000FFF) /*!< PC Read/Write protection of all Sectors  */
N
N#define IS_OB_PCROP(SECTOR)((((SECTOR) & (uint32_t)0xFFFFF000) == 0x00000000) && ((SECTOR) != 0x00000000))
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Option_Bytes_Read_Protection 
N  * @{
N  */
N#define OB_RDP_Level_0   ((uint8_t)0xAA)
N#define OB_RDP_Level_1   ((uint8_t)0x55)
N/*#define OB_RDP_Level_2   ((uint8_t)0xCC)*/ /*!< Warning: When enabling read protection level 2 
N                                                  it's no more possible to go back to level 1 or 0 */
N#define IS_OB_RDP(LEVEL) (((LEVEL) == OB_RDP_Level_0)||\
N                          ((LEVEL) == OB_RDP_Level_1))/*||\
N                          ((LEVEL) == OB_RDP_Level_2))*/
X#define IS_OB_RDP(LEVEL) (((LEVEL) == OB_RDP_Level_0)||                          ((LEVEL) == OB_RDP_Level_1)) 
N/**
N  * @}
N  */ 
N
N/** @defgroup FLASH_Option_Bytes_IWatchdog 
N  * @{
N  */ 
N#define OB_IWDG_SW                     ((uint8_t)0x20)  /*!< Software IWDG selected */
N#define OB_IWDG_HW                     ((uint8_t)0x00)  /*!< Hardware IWDG selected */
N#define IS_OB_IWDG_SOURCE(SOURCE) (((SOURCE) == OB_IWDG_SW) || ((SOURCE) == OB_IWDG_HW))
N/**
N  * @}
N  */ 
N
N/** @defgroup FLASH_Option_Bytes_nRST_STOP 
N  * @{
N  */ 
N#define OB_STOP_NoRST                  ((uint8_t)0x40) /*!< No reset generated when entering in STOP */
N#define OB_STOP_RST                    ((uint8_t)0x00) /*!< Reset generated when entering in STOP */
N#define IS_OB_STOP_SOURCE(SOURCE) (((SOURCE) == OB_STOP_NoRST) || ((SOURCE) == OB_STOP_RST))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup FLASH_Option_Bytes_nRST_STDBY 
N  * @{
N  */ 
N#define OB_STDBY_NoRST                 ((uint8_t)0x80) /*!< No reset generated when entering in STANDBY */
N#define OB_STDBY_RST                   ((uint8_t)0x00) /*!< Reset generated when entering in STANDBY */
N#define IS_OB_STDBY_SOURCE(SOURCE) (((SOURCE) == OB_STDBY_NoRST) || ((SOURCE) == OB_STDBY_RST))
N/**
N  * @}
N  */
N  
N/** @defgroup FLASH_BOR_Reset_Level 
N  * @{
N  */  
N#define OB_BOR_LEVEL3          ((uint8_t)0x00)  /*!< Supply voltage ranges from 2.70 to 3.60 V */
N#define OB_BOR_LEVEL2          ((uint8_t)0x04)  /*!< Supply voltage ranges from 2.40 to 2.70 V */
N#define OB_BOR_LEVEL1          ((uint8_t)0x08)  /*!< Supply voltage ranges from 2.10 to 2.40 V */
N#define OB_BOR_OFF             ((uint8_t)0x0C)  /*!< Supply voltage ranges from 1.62 to 2.10 V */
N#define IS_OB_BOR(LEVEL) (((LEVEL) == OB_BOR_LEVEL1) || ((LEVEL) == OB_BOR_LEVEL2) ||\
N                          ((LEVEL) == OB_BOR_LEVEL3) || ((LEVEL) == OB_BOR_OFF))
X#define IS_OB_BOR(LEVEL) (((LEVEL) == OB_BOR_LEVEL1) || ((LEVEL) == OB_BOR_LEVEL2) ||                          ((LEVEL) == OB_BOR_LEVEL3) || ((LEVEL) == OB_BOR_OFF))
N/**
N  * @}
N  */
N  
N/** @defgroup FLASH_Dual_Boot
N  * @{
N  */
N#define OB_Dual_BootEnabled   ((uint8_t)0x10) /*!< Dual Bank Boot Enable                             */
N#define OB_Dual_BootDisabled  ((uint8_t)0x00) /*!< Dual Bank Boot Disable, always boot on User Flash */
N#define IS_OB_BOOT(BOOT) (((BOOT) == OB_Dual_BootEnabled) || ((BOOT) == OB_Dual_BootDisabled))
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Interrupts 
N  * @{
N  */ 
N#define FLASH_IT_EOP                   ((uint32_t)0x01000000)  /*!< End of FLASH Operation Interrupt source */
N#define FLASH_IT_ERR                   ((uint32_t)0x02000000)  /*!< Error Interrupt source */
N#define IS_FLASH_IT(IT) ((((IT) & (uint32_t)0xFCFFFFFF) == 0x00000000) && ((IT) != 0x00000000))
N/**
N  * @}
N  */ 
N
N/** @defgroup FLASH_Flags 
N  * @{
N  */ 
N#define FLASH_FLAG_EOP                 ((uint32_t)0x00000001)  /*!< FLASH End of Operation flag               */
N#define FLASH_FLAG_OPERR               ((uint32_t)0x00000002)  /*!< FLASH operation Error flag                */
N#define FLASH_FLAG_WRPERR              ((uint32_t)0x00000010)  /*!< FLASH Write protected error flag          */
N#define FLASH_FLAG_PGAERR              ((uint32_t)0x00000020)  /*!< FLASH Programming Alignment error flag    */
N#define FLASH_FLAG_PGPERR              ((uint32_t)0x00000040)  /*!< FLASH Programming Parallelism error flag  */
N#define FLASH_FLAG_PGSERR              ((uint32_t)0x00000080)  /*!< FLASH Programming Sequence error flag     */
N#define FLASH_FLAG_RDERR               ((uint32_t)0x00000100)  /*!< Read Protection error flag (PCROP)        */
N#define FLASH_FLAG_BSY                 ((uint32_t)0x00010000)  /*!< FLASH Busy flag                           */ 
N#define IS_FLASH_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFFFFFE0C) == 0x00000000) && ((FLAG) != 0x00000000))
N#define IS_FLASH_GET_FLAG(FLAG)  (((FLAG) == FLASH_FLAG_EOP)    || ((FLAG) == FLASH_FLAG_OPERR)  || \
N                                  ((FLAG) == FLASH_FLAG_WRPERR) || ((FLAG) == FLASH_FLAG_PGAERR) || \
N                                  ((FLAG) == FLASH_FLAG_PGPERR) || ((FLAG) == FLASH_FLAG_PGSERR) || \
N                                  ((FLAG) == FLASH_FLAG_BSY)    || ((FLAG) == FLASH_FLAG_RDERR))
X#define IS_FLASH_GET_FLAG(FLAG)  (((FLAG) == FLASH_FLAG_EOP)    || ((FLAG) == FLASH_FLAG_OPERR)  ||                                   ((FLAG) == FLASH_FLAG_WRPERR) || ((FLAG) == FLASH_FLAG_PGAERR) ||                                   ((FLAG) == FLASH_FLAG_PGPERR) || ((FLAG) == FLASH_FLAG_PGSERR) ||                                   ((FLAG) == FLASH_FLAG_BSY)    || ((FLAG) == FLASH_FLAG_RDERR))
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Program_Parallelism   
N  * @{
N  */
N#define FLASH_PSIZE_BYTE           ((uint32_t)0x00000000)
N#define FLASH_PSIZE_HALF_WORD      ((uint32_t)0x00000100)
N#define FLASH_PSIZE_WORD           ((uint32_t)0x00000200)
N#define FLASH_PSIZE_DOUBLE_WORD    ((uint32_t)0x00000300)
N#define CR_PSIZE_MASK              ((uint32_t)0xFFFFFCFF)
N/**
N  * @}
N  */ 
N
N/** @defgroup FLASH_Keys 
N  * @{
N  */ 
N#define RDP_KEY                  ((uint16_t)0x00A5)
N#define FLASH_KEY1               ((uint32_t)0x45670123)
N#define FLASH_KEY2               ((uint32_t)0xCDEF89AB)
N#define FLASH_OPT_KEY1           ((uint32_t)0x08192A3B)
N#define FLASH_OPT_KEY2           ((uint32_t)0x4C5D6E7F)
N/**
N  * @}
N  */ 
N
N/** 
N  * @brief   ACR register byte 0 (Bits[7:0]) base address  
N  */ 
N#define ACR_BYTE0_ADDRESS           ((uint32_t)0x40023C00) 
N/** 
N  * @brief   OPTCR register byte 0 (Bits[7:0]) base address  
N  */ 
N#define OPTCR_BYTE0_ADDRESS         ((uint32_t)0x40023C14)
N/** 
N  * @brief   OPTCR register byte 1 (Bits[15:8]) base address  
N  */ 
N#define OPTCR_BYTE1_ADDRESS         ((uint32_t)0x40023C15)
N/** 
N  * @brief   OPTCR register byte 2 (Bits[23:16]) base address  
N  */ 
N#define OPTCR_BYTE2_ADDRESS         ((uint32_t)0x40023C16)
N/** 
N  * @brief   OPTCR register byte 3 (Bits[31:24]) base address  
N  */ 
N#define OPTCR_BYTE3_ADDRESS         ((uint32_t)0x40023C17)
N
N/** 
N  * @brief   OPTCR1 register byte 0 (Bits[7:0]) base address  
N  */ 
N#define OPTCR1_BYTE2_ADDRESS         ((uint32_t)0x40023C1A)
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/ 
N 
N/* FLASH Interface configuration functions ************************************/
Nvoid FLASH_SetLatency(uint32_t FLASH_Latency);
Nvoid FLASH_PrefetchBufferCmd(FunctionalState NewState);
Nvoid FLASH_InstructionCacheCmd(FunctionalState NewState);
Nvoid FLASH_DataCacheCmd(FunctionalState NewState);
Nvoid FLASH_InstructionCacheReset(void);
Nvoid FLASH_DataCacheReset(void);
N
N/* FLASH Memory Programming functions *****************************************/   
Nvoid         FLASH_Unlock(void);
Nvoid         FLASH_Lock(void);
NFLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange);
NFLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange);
NFLASH_Status FLASH_EraseAllBank1Sectors(uint8_t VoltageRange);
NFLASH_Status FLASH_EraseAllBank2Sectors(uint8_t VoltageRange);
NFLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data);
NFLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data);
NFLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data);
NFLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data);
N
N/* Option Bytes Programming functions *****************************************/ 
Nvoid         FLASH_OB_Unlock(void);
Nvoid         FLASH_OB_Lock(void);
Nvoid         FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState);
Nvoid         FLASH_OB_WRP1Config(uint32_t OB_WRP, FunctionalState NewState);
Nvoid         FLASH_OB_PCROPSelectionConfig(uint8_t OB_PcROP);
Nvoid         FLASH_OB_PCROPConfig(uint32_t OB_PCROP, FunctionalState NewState);
Nvoid         FLASH_OB_PCROP1Config(uint32_t OB_PCROP, FunctionalState NewState);
Nvoid         FLASH_OB_RDPConfig(uint8_t OB_RDP);
Nvoid         FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY);
Nvoid         FLASH_OB_BORConfig(uint8_t OB_BOR);
Nvoid         FLASH_OB_BootConfig(uint8_t OB_BOOT);
NFLASH_Status FLASH_OB_Launch(void);
Nuint8_t      FLASH_OB_GetUser(void);
Nuint16_t     FLASH_OB_GetWRP(void);
Nuint16_t     FLASH_OB_GetWRP1(void);
Nuint16_t     FLASH_OB_GetPCROP(void);
Nuint16_t     FLASH_OB_GetPCROP1(void);
NFlagStatus   FLASH_OB_GetRDP(void);
Nuint8_t      FLASH_OB_GetBOR(void);
N
N/* Interrupts and flags management functions **********************************/
Nvoid         FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState);
NFlagStatus   FLASH_GetFlagStatus(uint32_t FLASH_FLAG);
Nvoid         FLASH_ClearFlag(uint32_t FLASH_FLAG);
NFLASH_Status FLASH_GetStatus(void);
NFLASH_Status FLASH_WaitForLastOperation(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_FLASH_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 40 "..\..\Service\stm32f4xx_conf.h" 2
N#include "stm32f4xx_gpio.h"
L 1 "..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\stm32f4xx_gpio.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_gpio.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    04-November-2016
N  * @brief   This file contains all the functions prototypes for the GPIO firmware
N  *          library.  
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_GPIO_H
N#define __STM32F4xx_GPIO_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
N
N/** @addtogroup STM32F4xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup GPIO
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N
N#define IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) || \
N                                    ((PERIPH) == GPIOB) || \
N                                    ((PERIPH) == GPIOC) || \
N                                    ((PERIPH) == GPIOD) || \
N                                    ((PERIPH) == GPIOE) || \
N                                    ((PERIPH) == GPIOF) || \
N                                    ((PERIPH) == GPIOG) || \
N                                    ((PERIPH) == GPIOH) || \
N                                    ((PERIPH) == GPIOI) || \
N                                    ((PERIPH) == GPIOJ) || \
N                                    ((PERIPH) == GPIOK))
X#define IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) ||                                     ((PERIPH) == GPIOB) ||                                     ((PERIPH) == GPIOC) ||                                     ((PERIPH) == GPIOD) ||                                     ((PERIPH) == GPIOE) ||                                     ((PERIPH) == GPIOF) ||                                     ((PERIPH) == GPIOG) ||                                     ((PERIPH) == GPIOH) ||                                     ((PERIPH) == GPIOI) ||                                     ((PERIPH) == GPIOJ) ||                                     ((PERIPH) == GPIOK))
N
N/** 
N  * @brief  GPIO Configuration Mode enumeration 
N  */   
Ntypedef enum
N{ 
N  GPIO_Mode_IN   = 0x00, /*!< GPIO Input Mode */
N  GPIO_Mode_OUT  = 0x01, /*!< GPIO Output Mode */
N  GPIO_Mode_AF   = 0x02, /*!< GPIO Alternate function Mode */
N  GPIO_Mode_AN   = 0x03  /*!< GPIO Analog Mode */
N}GPIOMode_TypeDef;
N#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_Mode_IN)  || ((MODE) == GPIO_Mode_OUT) || \
N                            ((MODE) == GPIO_Mode_AF)|| ((MODE) == GPIO_Mode_AN))
X#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_Mode_IN)  || ((MODE) == GPIO_Mode_OUT) ||                             ((MODE) == GPIO_Mode_AF)|| ((MODE) == GPIO_Mode_AN))
N
N/** 
N  * @brief  GPIO Output type enumeration 
N  */  
Ntypedef enum
N{ 
N  GPIO_OType_PP = 0x00,
N  GPIO_OType_OD = 0x01
N}GPIOOType_TypeDef;
N#define IS_GPIO_OTYPE(OTYPE) (((OTYPE) == GPIO_OType_PP) || ((OTYPE) == GPIO_OType_OD))
N
N
N/** 
N  * @brief  GPIO Output Maximum frequency enumeration 
N  */  
Ntypedef enum
N{ 
N  GPIO_Low_Speed     = 0x00, /*!< Low speed    */
N  GPIO_Medium_Speed  = 0x01, /*!< Medium speed */
N  GPIO_Fast_Speed    = 0x02, /*!< Fast speed   */
N  GPIO_High_Speed    = 0x03  /*!< High speed   */
N}GPIOSpeed_TypeDef;
N
N/* Add legacy definition */
N#define  GPIO_Speed_2MHz    GPIO_Low_Speed    
N#define  GPIO_Speed_25MHz   GPIO_Medium_Speed 
N#define  GPIO_Speed_50MHz   GPIO_Fast_Speed 
N#define  GPIO_Speed_100MHz  GPIO_High_Speed  
N  
N#define IS_GPIO_SPEED(SPEED) (((SPEED) == GPIO_Low_Speed) || ((SPEED) == GPIO_Medium_Speed) || \
N                              ((SPEED) == GPIO_Fast_Speed)||  ((SPEED) == GPIO_High_Speed)) 
X#define IS_GPIO_SPEED(SPEED) (((SPEED) == GPIO_Low_Speed) || ((SPEED) == GPIO_Medium_Speed) ||                               ((SPEED) == GPIO_Fast_Speed)||  ((SPEED) == GPIO_High_Speed)) 
N
N/** 
N  * @brief  GPIO Configuration PullUp PullDown enumeration 
N  */ 
Ntypedef enum
N{ 
N  GPIO_PuPd_NOPULL = 0x00,
N  GPIO_PuPd_UP     = 0x01,
N  GPIO_PuPd_DOWN   = 0x02
N}GPIOPuPd_TypeDef;
N#define IS_GPIO_PUPD(PUPD) (((PUPD) == GPIO_PuPd_NOPULL) || ((PUPD) == GPIO_PuPd_UP) || \
N                            ((PUPD) == GPIO_PuPd_DOWN))
X#define IS_GPIO_PUPD(PUPD) (((PUPD) == GPIO_PuPd_NOPULL) || ((PUPD) == GPIO_PuPd_UP) ||                             ((PUPD) == GPIO_PuPd_DOWN))
N
N/** 
N  * @brief  GPIO Bit SET and Bit RESET enumeration 
N  */ 
Ntypedef enum
N{ 
N  Bit_RESET = 0,
N  Bit_SET
N}BitAction;
N#define IS_GPIO_BIT_ACTION(ACTION) (((ACTION) == Bit_RESET) || ((ACTION) == Bit_SET))
N
N
N/** 
N  * @brief   GPIO Init structure definition  
N  */ 
Ntypedef struct
N{
N  uint32_t GPIO_Pin;              /*!< Specifies the GPIO pins to be configured.
N                                       This parameter can be any value of @ref GPIO_pins_define */
N
N  GPIOMode_TypeDef GPIO_Mode;     /*!< Specifies the operating mode for the selected pins.
N                                       This parameter can be a value of @ref GPIOMode_TypeDef */
N
N  GPIOSpeed_TypeDef GPIO_Speed;   /*!< Specifies the speed for the selected pins.
N                                       This parameter can be a value of @ref GPIOSpeed_TypeDef */
N
N  GPIOOType_TypeDef GPIO_OType;   /*!< Specifies the operating output type for the selected pins.
N                                       This parameter can be a value of @ref GPIOOType_TypeDef */
N
N  GPIOPuPd_TypeDef GPIO_PuPd;     /*!< Specifies the operating Pull-up/Pull down for the selected pins.
N                                       This parameter can be a value of @ref GPIOPuPd_TypeDef */
N}GPIO_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup GPIO_Exported_Constants
N  * @{
N  */ 
N
N/** @defgroup GPIO_pins_define 
N  * @{
N  */ 
N#define GPIO_Pin_0                 ((uint16_t)0x0001)  /* Pin 0 selected */
N#define GPIO_Pin_1                 ((uint16_t)0x0002)  /* Pin 1 selected */
N#define GPIO_Pin_2                 ((uint16_t)0x0004)  /* Pin 2 selected */
N#define GPIO_Pin_3                 ((uint16_t)0x0008)  /* Pin 3 selected */
N#define GPIO_Pin_4                 ((uint16_t)0x0010)  /* Pin 4 selected */
N#define GPIO_Pin_5                 ((uint16_t)0x0020)  /* Pin 5 selected */
N#define GPIO_Pin_6                 ((uint16_t)0x0040)  /* Pin 6 selected */
N#define GPIO_Pin_7                 ((uint16_t)0x0080)  /* Pin 7 selected */
N#define GPIO_Pin_8                 ((uint16_t)0x0100)  /* Pin 8 selected */
N#define GPIO_Pin_9                 ((uint16_t)0x0200)  /* Pin 9 selected */
N#define GPIO_Pin_10                ((uint16_t)0x0400)  /* Pin 10 selected */
N#define GPIO_Pin_11                ((uint16_t)0x0800)  /* Pin 11 selected */
N#define GPIO_Pin_12                ((uint16_t)0x1000)  /* Pin 12 selected */
N#define GPIO_Pin_13                ((uint16_t)0x2000)  /* Pin 13 selected */
N#define GPIO_Pin_14                ((uint16_t)0x4000)  /* Pin 14 selected */
N#define GPIO_Pin_15                ((uint16_t)0x8000)  /* Pin 15 selected */
N#define GPIO_Pin_All               ((uint16_t)0xFFFF)  /* All pins selected */
N
N#define GPIO_PIN_MASK              ((uint32_t)0x0000FFFF) /* PIN mask for assert test */
N#define IS_GPIO_PIN(PIN)           (((PIN) & GPIO_PIN_MASK ) != (uint32_t)0x00)
N#define IS_GET_GPIO_PIN(PIN) (((PIN) == GPIO_Pin_0) || \
N                              ((PIN) == GPIO_Pin_1) || \
N                              ((PIN) == GPIO_Pin_2) || \
N                              ((PIN) == GPIO_Pin_3) || \
N                              ((PIN) == GPIO_Pin_4) || \
N                              ((PIN) == GPIO_Pin_5) || \
N                              ((PIN) == GPIO_Pin_6) || \
N                              ((PIN) == GPIO_Pin_7) || \
N                              ((PIN) == GPIO_Pin_8) || \
N                              ((PIN) == GPIO_Pin_9) || \
N                              ((PIN) == GPIO_Pin_10) || \
N                              ((PIN) == GPIO_Pin_11) || \
N                              ((PIN) == GPIO_Pin_12) || \
N                              ((PIN) == GPIO_Pin_13) || \
N                              ((PIN) == GPIO_Pin_14) || \
N                              ((PIN) == GPIO_Pin_15))
X#define IS_GET_GPIO_PIN(PIN) (((PIN) == GPIO_Pin_0) ||                               ((PIN) == GPIO_Pin_1) ||                               ((PIN) == GPIO_Pin_2) ||                               ((PIN) == GPIO_Pin_3) ||                               ((PIN) == GPIO_Pin_4) ||                               ((PIN) == GPIO_Pin_5) ||                               ((PIN) == GPIO_Pin_6) ||                               ((PIN) == GPIO_Pin_7) ||                               ((PIN) == GPIO_Pin_8) ||                               ((PIN) == GPIO_Pin_9) ||                               ((PIN) == GPIO_Pin_10) ||                               ((PIN) == GPIO_Pin_11) ||                               ((PIN) == GPIO_Pin_12) ||                               ((PIN) == GPIO_Pin_13) ||                               ((PIN) == GPIO_Pin_14) ||                               ((PIN) == GPIO_Pin_15))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup GPIO_Pin_sources 
N  * @{
N  */ 
N#define GPIO_PinSource0            ((uint8_t)0x00)
N#define GPIO_PinSource1            ((uint8_t)0x01)
N#define GPIO_PinSource2            ((uint8_t)0x02)
N#define GPIO_PinSource3            ((uint8_t)0x03)
N#define GPIO_PinSource4            ((uint8_t)0x04)
N#define GPIO_PinSource5            ((uint8_t)0x05)
N#define GPIO_PinSource6            ((uint8_t)0x06)
N#define GPIO_PinSource7            ((uint8_t)0x07)
N#define GPIO_PinSource8            ((uint8_t)0x08)
N#define GPIO_PinSource9            ((uint8_t)0x09)
N#define GPIO_PinSource10           ((uint8_t)0x0A)
N#define GPIO_PinSource11           ((uint8_t)0x0B)
N#define GPIO_PinSource12           ((uint8_t)0x0C)
N#define GPIO_PinSource13           ((uint8_t)0x0D)
N#define GPIO_PinSource14           ((uint8_t)0x0E)
N#define GPIO_PinSource15           ((uint8_t)0x0F)
N
N#define IS_GPIO_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == GPIO_PinSource0) || \
N                                       ((PINSOURCE) == GPIO_PinSource1) || \
N                                       ((PINSOURCE) == GPIO_PinSource2) || \
N                                       ((PINSOURCE) == GPIO_PinSource3) || \
N                                       ((PINSOURCE) == GPIO_PinSource4) || \
N                                       ((PINSOURCE) == GPIO_PinSource5) || \
N                                       ((PINSOURCE) == GPIO_PinSource6) || \
N                                       ((PINSOURCE) == GPIO_PinSource7) || \
N                                       ((PINSOURCE) == GPIO_PinSource8) || \
N                                       ((PINSOURCE) == GPIO_PinSource9) || \
N                                       ((PINSOURCE) == GPIO_PinSource10) || \
N                                       ((PINSOURCE) == GPIO_PinSource11) || \
N                                       ((PINSOURCE) == GPIO_PinSource12) || \
N                                       ((PINSOURCE) == GPIO_PinSource13) || \
N                                       ((PINSOURCE) == GPIO_PinSource14) || \
N                                       ((PINSOURCE) == GPIO_PinSource15))
X#define IS_GPIO_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == GPIO_PinSource0) ||                                        ((PINSOURCE) == GPIO_PinSource1) ||                                        ((PINSOURCE) == GPIO_PinSource2) ||                                        ((PINSOURCE) == GPIO_PinSource3) ||                                        ((PINSOURCE) == GPIO_PinSource4) ||                                        ((PINSOURCE) == GPIO_PinSource5) ||                                        ((PINSOURCE) == GPIO_PinSource6) ||                                        ((PINSOURCE) == GPIO_PinSource7) ||                                        ((PINSOURCE) == GPIO_PinSource8) ||                                        ((PINSOURCE) == GPIO_PinSource9) ||                                        ((PINSOURCE) == GPIO_PinSource10) ||                                        ((PINSOURCE) == GPIO_PinSource11) ||                                        ((PINSOURCE) == GPIO_PinSource12) ||                                        ((PINSOURCE) == GPIO_PinSource13) ||                                        ((PINSOURCE) == GPIO_PinSource14) ||                                        ((PINSOURCE) == GPIO_PinSource15))
N/**
N  * @}
N  */ 
N
N/** @defgroup GPIO_Alternat_function_selection_define 
N  * @{
N  */ 
N/** 
N  * @brief   AF 0 selection  
N  */ 
N#define GPIO_AF_RTC_50Hz      ((uint8_t)0x00)  /* RTC_50Hz Alternate Function mapping */
N#define GPIO_AF_MCO           ((uint8_t)0x00)  /* MCO (MCO1 and MCO2) Alternate Function mapping */
N#define GPIO_AF_TAMPER        ((uint8_t)0x00)  /* TAMPER (TAMPER_1 and TAMPER_2) Alternate Function mapping */
N#define GPIO_AF_SWJ           ((uint8_t)0x00)  /* SWJ (SWD and JTAG) Alternate Function mapping */
N#define GPIO_AF_TRACE         ((uint8_t)0x00)  /* TRACE Alternate Function mapping */
N#if defined(STM32F446xx)
X#if 0L
S#define GPIO_AF0_TIM2         ((uint8_t)0x00)  /* TIM2 Alternate Function mapping */
N#endif /* STM32F446xx */
N
N/** 
N  * @brief   AF 1 selection  
N  */ 
N#define GPIO_AF_TIM1          ((uint8_t)0x01)  /* TIM1 Alternate Function mapping */
N#define GPIO_AF_TIM2          ((uint8_t)0x01)  /* TIM2 Alternate Function mapping */
N#if defined(STM32F410xx) || defined(STM32F413_423xx)
X#if 0L || 0L
S#define GPIO_AF_LPTIM         ((uint8_t)0x01)  /* LPTIM Alternate Function mapping */
N#endif /* STM32F410xx || STM32F413_423xx */
N/** 
N  * @brief   AF 2 selection  
N  */ 
N#define GPIO_AF_TIM3          ((uint8_t)0x02)  /* TIM3 Alternate Function mapping */
N#define GPIO_AF_TIM4          ((uint8_t)0x02)  /* TIM4 Alternate Function mapping */
N#define GPIO_AF_TIM5          ((uint8_t)0x02)  /* TIM5 Alternate Function mapping */
N
N/** 
N  * @brief   AF 3 selection  
N  */ 
N#define GPIO_AF_TIM8          ((uint8_t)0x03)  /* TIM8 Alternate Function mapping */
N#define GPIO_AF_TIM9          ((uint8_t)0x03)  /* TIM9 Alternate Function mapping */
N#define GPIO_AF_TIM10         ((uint8_t)0x03)  /* TIM10 Alternate Function mapping */
N#define GPIO_AF_TIM11         ((uint8_t)0x03)  /* TIM11 Alternate Function mapping */
N#if defined(STM32F446xx)
X#if 0L
S#define GPIO_AF3_CEC          ((uint8_t)0x03)  /* CEC Alternate Function mapping */
N#endif /* STM32F446xx */
N#if defined(STM32F413_423xx)
X#if 0L
S#define GPIO_AF3_DFSDM2       ((uint8_t)0x03)  /* DFSDM2 Alternate Function mapping */
N#endif /* STM32F413_423xx */
N/** 
N  * @brief   AF 4 selection  
N  */ 
N#define GPIO_AF_I2C1          ((uint8_t)0x04)  /* I2C1 Alternate Function mapping */
N#define GPIO_AF_I2C2          ((uint8_t)0x04)  /* I2C2 Alternate Function mapping */
N#define GPIO_AF_I2C3          ((uint8_t)0x04)  /* I2C3 Alternate Function mapping */
N#if defined(STM32F446xx)
X#if 0L
S#define GPIO_AF4_CEC          ((uint8_t)0x04)  /* CEC Alternate Function mapping */
N#endif /* STM32F446xx */
N#if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
X#if 0L || 0L || 0L || 0L
S#define GPIO_AF_FMPI2C        ((uint8_t)0x04)  /* FMPI2C Alternate Function mapping */
N#endif /* STM32F410xx || STM32F446xx */
N
N/** 
N  * @brief   AF 5 selection  
N  */ 
N#define GPIO_AF_SPI1          ((uint8_t)0x05)  /* SPI1/I2S1 Alternate Function mapping */
N#define GPIO_AF_SPI2          ((uint8_t)0x05)  /* SPI2/I2S2 Alternate Function mapping */
N#define GPIO_AF5_SPI3         ((uint8_t)0x05)  /* SPI3/I2S3 Alternate Function mapping (Only for STM32F411xE and STM32F413_423xx Devices) */
N#define GPIO_AF_SPI4          ((uint8_t)0x05)  /* SPI4/I2S4 Alternate Function mapping */
N#define GPIO_AF_SPI5          ((uint8_t)0x05)  /* SPI5 Alternate Function mapping      */
N#define GPIO_AF_SPI6          ((uint8_t)0x05)  /* SPI6 Alternate Function mapping      */
N
N/** 
N  * @brief   AF 6 selection  
N  */ 
N#define GPIO_AF_SPI3          ((uint8_t)0x06)  /* SPI3/I2S3 Alternate Function mapping */
N#define GPIO_AF6_SPI1         ((uint8_t)0x06)  /* SPI1 Alternate Function mapping (Only for STM32F410xx Devices) */
N#define GPIO_AF6_SPI2         ((uint8_t)0x06)  /* SPI2 Alternate Function mapping (Only for STM32F410xx/STM32F411xE Devices) */
N#define GPIO_AF6_SPI4         ((uint8_t)0x06)  /* SPI4 Alternate Function mapping (Only for STM32F411xE Devices) */
N#define GPIO_AF6_SPI5         ((uint8_t)0x06)  /* SPI5 Alternate Function mapping (Only for STM32F410xx/STM32F411xE Devices) */
N#define GPIO_AF_SAI1          ((uint8_t)0x06)  /* SAI1 Alternate Function mapping      */
N#define GPIO_AF_I2S2ext       ((uint8_t)0x06)  /* I2S2ext_SD Alternate Function mapping (only for STM32F412xG and STM32F413_423xx Devices) */
N#if defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 0L || 0L
S#define GPIO_AF6_DFSDM1       ((uint8_t)0x06)  /* DFSDM1 Alternate Function mapping */
N#endif /* STM32F412xG || STM32F413_423xx */
N#if defined(STM32F413_423xx)
X#if 0L
S#define GPIO_AF6_DFSDM2       ((uint8_t)0x06)  /* DFSDM2 Alternate Function mapping */
N#endif /* STM32F413_423xx */
N
N/** 
N  * @brief   AF 7 selection  
N  */ 
N#define GPIO_AF_USART1         ((uint8_t)0x07)  /* USART1 Alternate Function mapping  */
N#define GPIO_AF_USART2         ((uint8_t)0x07)  /* USART2 Alternate Function mapping  */
N#define GPIO_AF_USART3         ((uint8_t)0x07)  /* USART3 Alternate Function mapping  */
N#define GPIO_AF7_SPI3          ((uint8_t)0x07)  /* SPI3/I2S3ext Alternate Function mapping */
N#if defined(STM32F413_423xx)
X#if 0L
S#define GPIO_AF7_DFSDM2        ((uint8_t)0x07)  /* DFSDM2 Alternate Function mapping     */
S#define GPIO_AF7_SAI1          ((uint8_t)0x07)  /* SAI1 Alternate Function mapping       */
N#endif /* STM32F413_423xx */
N
N/** 
N  * @brief   AF 7 selection Legacy 
N  */ 
N#define GPIO_AF_I2S3ext   GPIO_AF7_SPI3
N
N/** 
N  * @brief   AF 8 selection  
N  */ 
N#define GPIO_AF_UART4         ((uint8_t)0x08)  /* UART4 Alternate Function mapping  */
N#define GPIO_AF_UART5         ((uint8_t)0x08)  /* UART5 Alternate Function mapping  */
N#define GPIO_AF_USART6        ((uint8_t)0x08)  /* USART6 Alternate Function mapping */
N#define GPIO_AF_UART7         ((uint8_t)0x08)  /* UART7 Alternate Function mapping  */
N#define GPIO_AF_UART8         ((uint8_t)0x08)  /* UART8 Alternate Function mapping  */
N#if defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 0L || 0L
S#define GPIO_AF8_USART3        ((uint8_t)0x08)  /* USART3 Alternate Function mapping */
S#define GPIO_AF8_DFSDM1        ((uint8_t)0x08)  /* DFSDM Alternate Function mapping  */
S#define GPIO_AF8_CAN1          ((uint8_t)0x08)  /* CAN1 Alternate Function mapping   */
N#endif /* STM32F412xG || STM32F413_423xx */
N#if defined(STM32F446xx)
X#if 0L
S#define GPIO_AF8_SAI2          ((uint8_t)0x08)  /* SAI2 Alternate Function mapping */
S#define GPIO_AF_SPDIF         ((uint8_t)0x08)   /* SPDIF Alternate Function mapping */
N#endif /* STM32F446xx */
N
N/** 
N  * @brief   AF 9 selection 
N  */ 
N#define GPIO_AF_CAN1          ((uint8_t)0x09)  /* CAN1 Alternate Function mapping  */
N#define GPIO_AF_CAN2          ((uint8_t)0x09)  /* CAN2 Alternate Function mapping  */
N#define GPIO_AF_TIM12         ((uint8_t)0x09)  /* TIM12 Alternate Function mapping */
N#define GPIO_AF_TIM13         ((uint8_t)0x09)  /* TIM13 Alternate Function mapping */
N#define GPIO_AF_TIM14         ((uint8_t)0x09)  /* TIM14 Alternate Function mapping */
N#define GPIO_AF9_I2C2         ((uint8_t)0x09)  /* I2C2 Alternate Function mapping (Only for STM32F401xx/STM32F410xx/STM32F411xE/STM32F412xG/STM32F413_423xx Devices) */
N#define GPIO_AF9_I2C3         ((uint8_t)0x09)  /* I2C3 Alternate Function mapping (Only for STM32F401xx/STM32F411xE/STM32F412xG and STM32F413_423xx Devices) */
N#if defined(STM32F446xx)
X#if 0L
S#define GPIO_AF9_SAI2         ((uint8_t)0x09)  /* SAI2 Alternate Function mapping */
N#endif /* STM32F446xx */
N#define GPIO_AF9_LTDC         ((uint8_t)0x09)  /* LTDC Alternate Function mapping */
N#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
X#if 0L || 0L || 0L || 0L
S#define GPIO_AF9_QUADSPI      ((uint8_t)0x09)  /* QuadSPI Alternate Function mapping */
N#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx || STM32F469_479xx */
N#if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 0L || 0L || 0L
S#define GPIO_AF9_FMPI2C       ((uint8_t)0x09)  /* FMPI2C Alternate Function mapping (Only for STM32F410xx Devices) */
N#endif /* STM32F410xx || STM32F412xG || STM32F413_423xx */
N
N/** 
N  * @brief   AF 10 selection  
N  */ 
N#define GPIO_AF_OTG_FS         ((uint8_t)0xA)  /* OTG_FS Alternate Function mapping */
N#define GPIO_AF_OTG_HS         ((uint8_t)0xA)  /* OTG_HS Alternate Function mapping */
N#if defined(STM32F446xx)
X#if 0L
S#define GPIO_AF10_SAI2         ((uint8_t)0x0A)  /* SAI2 Alternate Function mapping */
N#endif /* STM32F446xx */
N#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
X#if 0L || 0L || 0L || 0L
S#define GPIO_AF10_QUADSPI      ((uint8_t)0x0A)  /* QuadSPI Alternate Function mapping */
N#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx || STM32F469_479xx */
N#if defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 0L || 0L
S#define GPIO_AF10_FMC           ((uint8_t)0xA)  /* FMC Alternate Function mapping    */
S#define GPIO_AF10_DFSDM1         ((uint8_t)0xA) /* DFSDM Alternate Function mapping  */
N#endif /* STM32F412xG || STM32F413_423xx */
N#if defined(STM32F413_423xx)
X#if 0L
S#define GPIO_AF10_DFSDM2        ((uint8_t)0x0A)  /* DFSDM2 Alternate Function mapping */
S#define GPIO_AF10_SAI1          ((uint8_t)0x0A)  /* SAI1 Alternate Function mapping   */
N#endif /* STM32F413_423xx */
N/** 
N  * @brief   AF 11 selection  
N  */ 
N#define GPIO_AF_ETH             ((uint8_t)0x0B)  /* ETHERNET Alternate Function mapping */
N#if defined(STM32F413_423xx)
X#if 0L
S#define GPIO_AF11_UART4         ((uint8_t)0x0B)  /* UART4 Alternate Function mapping  */
S#define GPIO_AF11_UART5         ((uint8_t)0x0B)  /* UART5 Alternate Function mapping  */
S#define GPIO_AF11_UART9         ((uint8_t)0x0B)  /* UART9 Alternate Function mapping  */
S#define GPIO_AF11_UART10        ((uint8_t)0x0B)  /* UART10 Alternate Function mapping */
S#define GPIO_AF11_CAN3          ((uint8_t)0x0B)  /* CAN3 Alternate Function mapping   */
N#endif /* STM32F413_423xx */
N
N/** 
N  * @brief   AF 12 selection  
N  */ 
N#if defined(STM32F40_41xxx) || defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 1L || 0L || 0L
N#define GPIO_AF_FSMC             ((uint8_t)0xC)  /* FSMC Alternate Function mapping                     */
N#endif /* STM32F40_41xxx || STM32F412xG || STM32F413_423xx */
N
N#if defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
X#if 0L || 0L || 0L || 0L
S#define GPIO_AF_FMC              ((uint8_t)0xC)  /* FMC Alternate Function mapping                      */
N#endif /* STM32F427_437xx || STM32F429_439xx || STM32F446xx || STM32F469_479xx */
N
N#define GPIO_AF_OTG_HS_FS        ((uint8_t)0xC)  /* OTG HS configured in FS, Alternate Function mapping */
N#define GPIO_AF_SDIO             ((uint8_t)0xC)  /* SDIO Alternate Function mapping                     */
N
N/** 
N  * @brief   AF 13 selection  
N  */ 
N#define GPIO_AF_DCMI          ((uint8_t)0x0D)  /* DCMI Alternate Function mapping */
N#if defined(STM32F469_479xx)
X#if 0L
S#define GPIO_AF_DSI           ((uint8_t)0x0D)  /* DSI Alternate Function mapping */
N#endif /* STM32F469_479xx */
N/** 
N  * @brief   AF 14 selection  
N  */
N#define GPIO_AF_LTDC          ((uint8_t)0x0E)  /* LCD-TFT Alternate Function mapping */
N#if defined(STM32F413_423xx)
X#if 0L
S#define GPIO_AF14_RNG         ((uint8_t)0x0E)  /* RNG Alternate Function mapping  */
N#endif /* STM32F413_423xx */
N
N/** 
N  * @brief   AF 15 selection  
N  */ 
N#define GPIO_AF_EVENTOUT      ((uint8_t)0x0F)  /* EVENTOUT Alternate Function mapping */
N
N#if defined(STM32F40_41xxx)
X#if 1L
N#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF_RTC_50Hz)  || ((AF) == GPIO_AF_TIM14)     || \
N                          ((AF) == GPIO_AF_MCO)       || ((AF) == GPIO_AF_TAMPER)    || \
N                          ((AF) == GPIO_AF_SWJ)       || ((AF) == GPIO_AF_TRACE)     || \
N                          ((AF) == GPIO_AF_TIM1)      || ((AF) == GPIO_AF_TIM2)      || \
N                          ((AF) == GPIO_AF_TIM3)      || ((AF) == GPIO_AF_TIM4)      || \
N                          ((AF) == GPIO_AF_TIM5)      || ((AF) == GPIO_AF_TIM8)      || \
N                          ((AF) == GPIO_AF_I2C1)      || ((AF) == GPIO_AF_I2C2)      || \
N                          ((AF) == GPIO_AF_I2C3)      || ((AF) == GPIO_AF_SPI1)      || \
N                          ((AF) == GPIO_AF_SPI2)      || ((AF) == GPIO_AF_TIM13)     || \
N                          ((AF) == GPIO_AF_SPI3)      || ((AF) == GPIO_AF_TIM14)     || \
N                          ((AF) == GPIO_AF_USART1)    || ((AF) == GPIO_AF_USART2)    || \
N                          ((AF) == GPIO_AF_USART3)    || ((AF) == GPIO_AF_UART4)     || \
N                          ((AF) == GPIO_AF_UART5)     || ((AF) == GPIO_AF_USART6)    || \
N                          ((AF) == GPIO_AF_CAN1)      || ((AF) == GPIO_AF_CAN2)      || \
N                          ((AF) == GPIO_AF_OTG_FS)    || ((AF) == GPIO_AF_OTG_HS)    || \
N                          ((AF) == GPIO_AF_ETH)       || ((AF) == GPIO_AF_OTG_HS_FS) || \
N                          ((AF) == GPIO_AF_SDIO)      || ((AF) == GPIO_AF_DCMI)      || \
N                          ((AF) == GPIO_AF_EVENTOUT)  || ((AF) == GPIO_AF_FSMC))
X#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF_RTC_50Hz)  || ((AF) == GPIO_AF_TIM14)     ||                           ((AF) == GPIO_AF_MCO)       || ((AF) == GPIO_AF_TAMPER)    ||                           ((AF) == GPIO_AF_SWJ)       || ((AF) == GPIO_AF_TRACE)     ||                           ((AF) == GPIO_AF_TIM1)      || ((AF) == GPIO_AF_TIM2)      ||                           ((AF) == GPIO_AF_TIM3)      || ((AF) == GPIO_AF_TIM4)      ||                           ((AF) == GPIO_AF_TIM5)      || ((AF) == GPIO_AF_TIM8)      ||                           ((AF) == GPIO_AF_I2C1)      || ((AF) == GPIO_AF_I2C2)      ||                           ((AF) == GPIO_AF_I2C3)      || ((AF) == GPIO_AF_SPI1)      ||                           ((AF) == GPIO_AF_SPI2)      || ((AF) == GPIO_AF_TIM13)     ||                           ((AF) == GPIO_AF_SPI3)      || ((AF) == GPIO_AF_TIM14)     ||                           ((AF) == GPIO_AF_USART1)    || ((AF) == GPIO_AF_USART2)    ||                           ((AF) == GPIO_AF_USART3)    || ((AF) == GPIO_AF_UART4)     ||                           ((AF) == GPIO_AF_UART5)     || ((AF) == GPIO_AF_USART6)    ||                           ((AF) == GPIO_AF_CAN1)      || ((AF) == GPIO_AF_CAN2)      ||                           ((AF) == GPIO_AF_OTG_FS)    || ((AF) == GPIO_AF_OTG_HS)    ||                           ((AF) == GPIO_AF_ETH)       || ((AF) == GPIO_AF_OTG_HS_FS) ||                           ((AF) == GPIO_AF_SDIO)      || ((AF) == GPIO_AF_DCMI)      ||                           ((AF) == GPIO_AF_EVENTOUT)  || ((AF) == GPIO_AF_FSMC))
N#endif /* STM32F40_41xxx */
N
N#if defined(STM32F401xx)
X#if 0L
S#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF_RTC_50Hz)  || ((AF) == GPIO_AF_TIM14)     || \
S                          ((AF) == GPIO_AF_MCO)       || ((AF) == GPIO_AF_TAMPER)    || \
S                          ((AF) == GPIO_AF_SWJ)       || ((AF) == GPIO_AF_TRACE)     || \
S                          ((AF) == GPIO_AF_TIM1)      || ((AF) == GPIO_AF_TIM2)      || \
S                          ((AF) == GPIO_AF_TIM3)      || ((AF) == GPIO_AF_TIM4)      || \
S                          ((AF) == GPIO_AF_TIM5)      || ((AF) == GPIO_AF_TIM8)      || \
S                          ((AF) == GPIO_AF_I2C1)      || ((AF) == GPIO_AF_I2C2)      || \
S                          ((AF) == GPIO_AF_I2C3)      || ((AF) == GPIO_AF_SPI1)      || \
S                          ((AF) == GPIO_AF_SPI2)      || ((AF) == GPIO_AF_TIM13)     || \
S                          ((AF) == GPIO_AF_SPI3)      || ((AF) == GPIO_AF_TIM14)     || \
S                          ((AF) == GPIO_AF_USART1)    || ((AF) == GPIO_AF_USART2)    || \
S                          ((AF) == GPIO_AF_SDIO)      || ((AF) == GPIO_AF_USART6)    || \
S                          ((AF) == GPIO_AF_OTG_FS)    || ((AF) == GPIO_AF_OTG_HS)    || \
S                          ((AF) == GPIO_AF_EVENTOUT)  || ((AF) == GPIO_AF_SPI4))
X#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF_RTC_50Hz)  || ((AF) == GPIO_AF_TIM14)     ||                           ((AF) == GPIO_AF_MCO)       || ((AF) == GPIO_AF_TAMPER)    ||                           ((AF) == GPIO_AF_SWJ)       || ((AF) == GPIO_AF_TRACE)     ||                           ((AF) == GPIO_AF_TIM1)      || ((AF) == GPIO_AF_TIM2)      ||                           ((AF) == GPIO_AF_TIM3)      || ((AF) == GPIO_AF_TIM4)      ||                           ((AF) == GPIO_AF_TIM5)      || ((AF) == GPIO_AF_TIM8)      ||                           ((AF) == GPIO_AF_I2C1)      || ((AF) == GPIO_AF_I2C2)      ||                           ((AF) == GPIO_AF_I2C3)      || ((AF) == GPIO_AF_SPI1)      ||                           ((AF) == GPIO_AF_SPI2)      || ((AF) == GPIO_AF_TIM13)     ||                           ((AF) == GPIO_AF_SPI3)      || ((AF) == GPIO_AF_TIM14)     ||                           ((AF) == GPIO_AF_USART1)    || ((AF) == GPIO_AF_USART2)    ||                           ((AF) == GPIO_AF_SDIO)      || ((AF) == GPIO_AF_USART6)    ||                           ((AF) == GPIO_AF_OTG_FS)    || ((AF) == GPIO_AF_OTG_HS)    ||                           ((AF) == GPIO_AF_EVENTOUT)  || ((AF) == GPIO_AF_SPI4))
N#endif /* STM32F401xx */
N
N#if defined(STM32F411xE)
X#if 0L
S#define IS_GPIO_AF(AF)   (((AF) < 16) && ((AF) != 11) && ((AF) != 13) && ((AF) != 14))
N#endif /* STM32F411xE */
N
N#if defined(STM32F410xx)
X#if 0L
S#define IS_GPIO_AF(AF)   (((AF) < 10) || ((AF) == 15))
N#endif /* STM32F410xx */
N
N#if defined(STM32F427_437xx) || defined(STM32F429_439xx)
X#if 0L || 0L
S#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF_RTC_50Hz)  || ((AF) == GPIO_AF_TIM14)     || \
S                          ((AF) == GPIO_AF_MCO)       || ((AF) == GPIO_AF_TAMPER)    || \
S                          ((AF) == GPIO_AF_SWJ)       || ((AF) == GPIO_AF_TRACE)     || \
S                          ((AF) == GPIO_AF_TIM1)      || ((AF) == GPIO_AF_TIM2)      || \
S                          ((AF) == GPIO_AF_TIM3)      || ((AF) == GPIO_AF_TIM4)      || \
S                          ((AF) == GPIO_AF_TIM5)      || ((AF) == GPIO_AF_TIM8)      || \
S                          ((AF) == GPIO_AF_I2C1)      || ((AF) == GPIO_AF_I2C2)      || \
S                          ((AF) == GPIO_AF_I2C3)      || ((AF) == GPIO_AF_SPI1)      || \
S                          ((AF) == GPIO_AF_SPI2)      || ((AF) == GPIO_AF_TIM13)     || \
S                          ((AF) == GPIO_AF_SPI3)      || ((AF) == GPIO_AF_TIM14)     || \
S                          ((AF) == GPIO_AF_USART1)    || ((AF) == GPIO_AF_USART2)    || \
S                          ((AF) == GPIO_AF_USART3)    || ((AF) == GPIO_AF_UART4)     || \
S                          ((AF) == GPIO_AF_UART5)     || ((AF) == GPIO_AF_USART6)    || \
S                          ((AF) == GPIO_AF_CAN1)      || ((AF) == GPIO_AF_CAN2)      || \
S                          ((AF) == GPIO_AF_OTG_FS)    || ((AF) == GPIO_AF_OTG_HS)    || \
S                          ((AF) == GPIO_AF_ETH)       || ((AF) == GPIO_AF_OTG_HS_FS) || \
S                          ((AF) == GPIO_AF_SDIO)      || ((AF) == GPIO_AF_DCMI)      || \
S                          ((AF) == GPIO_AF_EVENTOUT)  || ((AF) == GPIO_AF_SPI4)      || \
S                          ((AF) == GPIO_AF_SPI5)      || ((AF) == GPIO_AF_SPI6)      || \
S                          ((AF) == GPIO_AF_UART7)     || ((AF) == GPIO_AF_UART8)     || \
S                          ((AF) == GPIO_AF_FMC)       ||  ((AF) == GPIO_AF_SAI1)     || \
S                          ((AF) == GPIO_AF_LTDC))
X#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF_RTC_50Hz)  || ((AF) == GPIO_AF_TIM14)     ||                           ((AF) == GPIO_AF_MCO)       || ((AF) == GPIO_AF_TAMPER)    ||                           ((AF) == GPIO_AF_SWJ)       || ((AF) == GPIO_AF_TRACE)     ||                           ((AF) == GPIO_AF_TIM1)      || ((AF) == GPIO_AF_TIM2)      ||                           ((AF) == GPIO_AF_TIM3)      || ((AF) == GPIO_AF_TIM4)      ||                           ((AF) == GPIO_AF_TIM5)      || ((AF) == GPIO_AF_TIM8)      ||                           ((AF) == GPIO_AF_I2C1)      || ((AF) == GPIO_AF_I2C2)      ||                           ((AF) == GPIO_AF_I2C3)      || ((AF) == GPIO_AF_SPI1)      ||                           ((AF) == GPIO_AF_SPI2)      || ((AF) == GPIO_AF_TIM13)     ||                           ((AF) == GPIO_AF_SPI3)      || ((AF) == GPIO_AF_TIM14)     ||                           ((AF) == GPIO_AF_USART1)    || ((AF) == GPIO_AF_USART2)    ||                           ((AF) == GPIO_AF_USART3)    || ((AF) == GPIO_AF_UART4)     ||                           ((AF) == GPIO_AF_UART5)     || ((AF) == GPIO_AF_USART6)    ||                           ((AF) == GPIO_AF_CAN1)      || ((AF) == GPIO_AF_CAN2)      ||                           ((AF) == GPIO_AF_OTG_FS)    || ((AF) == GPIO_AF_OTG_HS)    ||                           ((AF) == GPIO_AF_ETH)       || ((AF) == GPIO_AF_OTG_HS_FS) ||                           ((AF) == GPIO_AF_SDIO)      || ((AF) == GPIO_AF_DCMI)      ||                           ((AF) == GPIO_AF_EVENTOUT)  || ((AF) == GPIO_AF_SPI4)      ||                           ((AF) == GPIO_AF_SPI5)      || ((AF) == GPIO_AF_SPI6)      ||                           ((AF) == GPIO_AF_UART7)     || ((AF) == GPIO_AF_UART8)     ||                           ((AF) == GPIO_AF_FMC)       ||  ((AF) == GPIO_AF_SAI1)     ||                           ((AF) == GPIO_AF_LTDC))
N#endif /* STM32F427_437xx ||  STM32F429_439xx */
N
N#if defined(STM32F412xG)
X#if 0L
S#define IS_GPIO_AF(AF)   (((AF) < 16) && ((AF) != 11) && ((AF) != 14))
N#endif /* STM32F412xG */
N
N#if defined(STM32F413_423xx)
X#if 0L
S#define IS_GPIO_AF(AF)   (((AF) < 16) && ((AF) != 13))
N#endif /* STM32F413_423xx */
N
N#if defined(STM32F446xx)
X#if 0L
S#define IS_GPIO_AF(AF)   (((AF) < 16) && ((AF) != 11) && ((AF) != 14))
N#endif /* STM32F446xx */
N
N#if defined(STM32F469_479xx)
X#if 0L
S#define IS_GPIO_AF(AF)   ((AF) < 16)
N#endif /* STM32F469_479xx */
N
N/**
N  * @}
N  */ 
N
N/** @defgroup GPIO_Legacy 
N  * @{
N  */
N    
N#define GPIO_Mode_AIN           GPIO_Mode_AN
N
N#define GPIO_AF_OTG1_FS         GPIO_AF_OTG_FS
N#define GPIO_AF_OTG2_HS         GPIO_AF_OTG_HS
N#define GPIO_AF_OTG2_FS         GPIO_AF_OTG_HS_FS
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/
N
N/*  Function used to set the GPIO configuration to the default reset state ****/
Nvoid GPIO_DeInit(GPIO_TypeDef* GPIOx);
N
N/* Initialization and Configuration functions *********************************/
Nvoid GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);
Nvoid GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct);
Nvoid GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
N
N/* GPIO Read and Write functions **********************************************/
Nuint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nuint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx);
Nuint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nuint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx);
Nvoid GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nvoid GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nvoid GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal);
Nvoid GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal);
Nvoid GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
N
N/* GPIO Alternate functions configuration function ****************************/
Nvoid GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F4xx_GPIO_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 41 "..\..\Service\stm32f4xx_conf.h" 2
N#include "stm32f4xx_i2c.h"
L 1 "..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\stm32f4xx_i2c.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_i2c.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    04-November-2016
N  * @brief   This file contains all the functions prototypes for the I2C firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************  
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_I2C_H
N#define __STM32F4xx_I2C_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
N
N/** @addtogroup STM32F4xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup I2C
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  I2C Init structure definition  
N  */
N
Ntypedef struct
N{
N  uint32_t I2C_ClockSpeed;          /*!< Specifies the clock frequency.
N                                         This parameter must be set to a value lower than 400kHz */
N
N  uint16_t I2C_Mode;                /*!< Specifies the I2C mode.
N                                         This parameter can be a value of @ref I2C_mode */
N
N  uint16_t I2C_DutyCycle;           /*!< Specifies the I2C fast mode duty cycle.
N                                         This parameter can be a value of @ref I2C_duty_cycle_in_fast_mode */
N
N  uint16_t I2C_OwnAddress1;         /*!< Specifies the first device own address.
N                                         This parameter can be a 7-bit or 10-bit address. */
N
N  uint16_t I2C_Ack;                 /*!< Enables or disables the acknowledgement.
N                                         This parameter can be a value of @ref I2C_acknowledgement */
N
N  uint16_t I2C_AcknowledgedAddress; /*!< Specifies if 7-bit or 10-bit address is acknowledged.
N                                         This parameter can be a value of @ref I2C_acknowledged_address */
N}I2C_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N
N/** @defgroup I2C_Exported_Constants
N  * @{
N  */
N#define IS_I2C_ALL_PERIPH(PERIPH) (((PERIPH) == I2C1) || \
N                                   ((PERIPH) == I2C2) || \
N                                   ((PERIPH) == I2C3))
X#define IS_I2C_ALL_PERIPH(PERIPH) (((PERIPH) == I2C1) ||                                    ((PERIPH) == I2C2) ||                                    ((PERIPH) == I2C3))
N/** @defgroup I2C_Digital_Filter
N  * @{
N  */
N
N#define IS_I2C_DIGITAL_FILTER(FILTER)   ((FILTER) <= 0x0000000F)
N/**
N  * @}
N  */
N
N
N/** @defgroup I2C_mode 
N  * @{
N  */
N
N#define I2C_Mode_I2C                    ((uint16_t)0x0000)
N#define I2C_Mode_SMBusDevice            ((uint16_t)0x0002)  
N#define I2C_Mode_SMBusHost              ((uint16_t)0x000A)
N#define IS_I2C_MODE(MODE) (((MODE) == I2C_Mode_I2C) || \
N                           ((MODE) == I2C_Mode_SMBusDevice) || \
N                           ((MODE) == I2C_Mode_SMBusHost))
X#define IS_I2C_MODE(MODE) (((MODE) == I2C_Mode_I2C) ||                            ((MODE) == I2C_Mode_SMBusDevice) ||                            ((MODE) == I2C_Mode_SMBusHost))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_duty_cycle_in_fast_mode 
N  * @{
N  */
N
N#define I2C_DutyCycle_16_9              ((uint16_t)0x4000) /*!< I2C fast mode Tlow/Thigh = 16/9 */
N#define I2C_DutyCycle_2                 ((uint16_t)0xBFFF) /*!< I2C fast mode Tlow/Thigh = 2 */
N#define IS_I2C_DUTY_CYCLE(CYCLE) (((CYCLE) == I2C_DutyCycle_16_9) || \
N                                  ((CYCLE) == I2C_DutyCycle_2))
X#define IS_I2C_DUTY_CYCLE(CYCLE) (((CYCLE) == I2C_DutyCycle_16_9) ||                                   ((CYCLE) == I2C_DutyCycle_2))
N/**
N  * @}
N  */ 
N
N/** @defgroup I2C_acknowledgement
N  * @{
N  */
N
N#define I2C_Ack_Enable                  ((uint16_t)0x0400)
N#define I2C_Ack_Disable                 ((uint16_t)0x0000)
N#define IS_I2C_ACK_STATE(STATE) (((STATE) == I2C_Ack_Enable) || \
N                                 ((STATE) == I2C_Ack_Disable))
X#define IS_I2C_ACK_STATE(STATE) (((STATE) == I2C_Ack_Enable) ||                                  ((STATE) == I2C_Ack_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_transfer_direction 
N  * @{
N  */
N
N#define  I2C_Direction_Transmitter      ((uint8_t)0x00)
N#define  I2C_Direction_Receiver         ((uint8_t)0x01)
N#define IS_I2C_DIRECTION(DIRECTION) (((DIRECTION) == I2C_Direction_Transmitter) || \
N                                     ((DIRECTION) == I2C_Direction_Receiver))
X#define IS_I2C_DIRECTION(DIRECTION) (((DIRECTION) == I2C_Direction_Transmitter) ||                                      ((DIRECTION) == I2C_Direction_Receiver))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_acknowledged_address 
N  * @{
N  */
N
N#define I2C_AcknowledgedAddress_7bit    ((uint16_t)0x4000)
N#define I2C_AcknowledgedAddress_10bit   ((uint16_t)0xC000)
N#define IS_I2C_ACKNOWLEDGE_ADDRESS(ADDRESS) (((ADDRESS) == I2C_AcknowledgedAddress_7bit) || \
N                                             ((ADDRESS) == I2C_AcknowledgedAddress_10bit))
X#define IS_I2C_ACKNOWLEDGE_ADDRESS(ADDRESS) (((ADDRESS) == I2C_AcknowledgedAddress_7bit) ||                                              ((ADDRESS) == I2C_AcknowledgedAddress_10bit))
N/**
N  * @}
N  */ 
N
N/** @defgroup I2C_registers 
N  * @{
N  */
N
N#define I2C_Register_CR1                ((uint8_t)0x00)
N#define I2C_Register_CR2                ((uint8_t)0x04)
N#define I2C_Register_OAR1               ((uint8_t)0x08)
N#define I2C_Register_OAR2               ((uint8_t)0x0C)
N#define I2C_Register_DR                 ((uint8_t)0x10)
N#define I2C_Register_SR1                ((uint8_t)0x14)
N#define I2C_Register_SR2                ((uint8_t)0x18)
N#define I2C_Register_CCR                ((uint8_t)0x1C)
N#define I2C_Register_TRISE              ((uint8_t)0x20)
N#define IS_I2C_REGISTER(REGISTER) (((REGISTER) == I2C_Register_CR1) || \
N                                   ((REGISTER) == I2C_Register_CR2) || \
N                                   ((REGISTER) == I2C_Register_OAR1) || \
N                                   ((REGISTER) == I2C_Register_OAR2) || \
N                                   ((REGISTER) == I2C_Register_DR) || \
N                                   ((REGISTER) == I2C_Register_SR1) || \
N                                   ((REGISTER) == I2C_Register_SR2) || \
N                                   ((REGISTER) == I2C_Register_CCR) || \
N                                   ((REGISTER) == I2C_Register_TRISE))
X#define IS_I2C_REGISTER(REGISTER) (((REGISTER) == I2C_Register_CR1) ||                                    ((REGISTER) == I2C_Register_CR2) ||                                    ((REGISTER) == I2C_Register_OAR1) ||                                    ((REGISTER) == I2C_Register_OAR2) ||                                    ((REGISTER) == I2C_Register_DR) ||                                    ((REGISTER) == I2C_Register_SR1) ||                                    ((REGISTER) == I2C_Register_SR2) ||                                    ((REGISTER) == I2C_Register_CCR) ||                                    ((REGISTER) == I2C_Register_TRISE))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_NACK_position 
N  * @{
N  */
N
N#define I2C_NACKPosition_Next           ((uint16_t)0x0800)
N#define I2C_NACKPosition_Current        ((uint16_t)0xF7FF)
N#define IS_I2C_NACK_POSITION(POSITION)  (((POSITION) == I2C_NACKPosition_Next) || \
N                                         ((POSITION) == I2C_NACKPosition_Current))
X#define IS_I2C_NACK_POSITION(POSITION)  (((POSITION) == I2C_NACKPosition_Next) ||                                          ((POSITION) == I2C_NACKPosition_Current))
N/**
N  * @}
N  */ 
N
N/** @defgroup I2C_SMBus_alert_pin_level 
N  * @{
N  */
N
N#define I2C_SMBusAlert_Low              ((uint16_t)0x2000)
N#define I2C_SMBusAlert_High             ((uint16_t)0xDFFF)
N#define IS_I2C_SMBUS_ALERT(ALERT) (((ALERT) == I2C_SMBusAlert_Low) || \
N                                   ((ALERT) == I2C_SMBusAlert_High))
X#define IS_I2C_SMBUS_ALERT(ALERT) (((ALERT) == I2C_SMBusAlert_Low) ||                                    ((ALERT) == I2C_SMBusAlert_High))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_PEC_position 
N  * @{
N  */
N
N#define I2C_PECPosition_Next            ((uint16_t)0x0800)
N#define I2C_PECPosition_Current         ((uint16_t)0xF7FF)
N#define IS_I2C_PEC_POSITION(POSITION) (((POSITION) == I2C_PECPosition_Next) || \
N                                       ((POSITION) == I2C_PECPosition_Current))
X#define IS_I2C_PEC_POSITION(POSITION) (((POSITION) == I2C_PECPosition_Next) ||                                        ((POSITION) == I2C_PECPosition_Current))
N/**
N  * @}
N  */ 
N
N/** @defgroup I2C_interrupts_definition 
N  * @{
N  */
N
N#define I2C_IT_BUF                      ((uint16_t)0x0400)
N#define I2C_IT_EVT                      ((uint16_t)0x0200)
N#define I2C_IT_ERR                      ((uint16_t)0x0100)
N#define IS_I2C_CONFIG_IT(IT) ((((IT) & (uint16_t)0xF8FF) == 0x00) && ((IT) != 0x00))
N/**
N  * @}
N  */ 
N
N/** @defgroup I2C_interrupts_definition 
N  * @{
N  */
N
N#define I2C_IT_SMBALERT                 ((uint32_t)0x01008000)
N#define I2C_IT_TIMEOUT                  ((uint32_t)0x01004000)
N#define I2C_IT_PECERR                   ((uint32_t)0x01001000)
N#define I2C_IT_OVR                      ((uint32_t)0x01000800)
N#define I2C_IT_AF                       ((uint32_t)0x01000400)
N#define I2C_IT_ARLO                     ((uint32_t)0x01000200)
N#define I2C_IT_BERR                     ((uint32_t)0x01000100)
N#define I2C_IT_TXE                      ((uint32_t)0x06000080)
N#define I2C_IT_RXNE                     ((uint32_t)0x06000040)
N#define I2C_IT_STOPF                    ((uint32_t)0x02000010)
N#define I2C_IT_ADD10                    ((uint32_t)0x02000008)
N#define I2C_IT_BTF                      ((uint32_t)0x02000004)
N#define I2C_IT_ADDR                     ((uint32_t)0x02000002)
N#define I2C_IT_SB                       ((uint32_t)0x02000001)
N
N#define IS_I2C_CLEAR_IT(IT) ((((IT) & (uint16_t)0x20FF) == 0x00) && ((IT) != (uint16_t)0x00))
N
N#define IS_I2C_GET_IT(IT) (((IT) == I2C_IT_SMBALERT) || ((IT) == I2C_IT_TIMEOUT) || \
N                           ((IT) == I2C_IT_PECERR) || ((IT) == I2C_IT_OVR) || \
N                           ((IT) == I2C_IT_AF) || ((IT) == I2C_IT_ARLO) || \
N                           ((IT) == I2C_IT_BERR) || ((IT) == I2C_IT_TXE) || \
N                           ((IT) == I2C_IT_RXNE) || ((IT) == I2C_IT_STOPF) || \
N                           ((IT) == I2C_IT_ADD10) || ((IT) == I2C_IT_BTF) || \
N                           ((IT) == I2C_IT_ADDR) || ((IT) == I2C_IT_SB))
X#define IS_I2C_GET_IT(IT) (((IT) == I2C_IT_SMBALERT) || ((IT) == I2C_IT_TIMEOUT) ||                            ((IT) == I2C_IT_PECERR) || ((IT) == I2C_IT_OVR) ||                            ((IT) == I2C_IT_AF) || ((IT) == I2C_IT_ARLO) ||                            ((IT) == I2C_IT_BERR) || ((IT) == I2C_IT_TXE) ||                            ((IT) == I2C_IT_RXNE) || ((IT) == I2C_IT_STOPF) ||                            ((IT) == I2C_IT_ADD10) || ((IT) == I2C_IT_BTF) ||                            ((IT) == I2C_IT_ADDR) || ((IT) == I2C_IT_SB))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_flags_definition 
N  * @{
N  */
N
N/** 
N  * @brief  SR2 register flags  
N  */
N
N#define I2C_FLAG_DUALF                  ((uint32_t)0x00800000)
N#define I2C_FLAG_SMBHOST                ((uint32_t)0x00400000)
N#define I2C_FLAG_SMBDEFAULT             ((uint32_t)0x00200000)
N#define I2C_FLAG_GENCALL                ((uint32_t)0x00100000)
N#define I2C_FLAG_TRA                    ((uint32_t)0x00040000)
N#define I2C_FLAG_BUSY                   ((uint32_t)0x00020000)
N#define I2C_FLAG_MSL                    ((uint32_t)0x00010000)
N
N/** 
N  * @brief  SR1 register flags  
N  */
N
N#define I2C_FLAG_SMBALERT               ((uint32_t)0x10008000)
N#define I2C_FLAG_TIMEOUT                ((uint32_t)0x10004000)
N#define I2C_FLAG_PECERR                 ((uint32_t)0x10001000)
N#define I2C_FLAG_OVR                    ((uint32_t)0x10000800)
N#define I2C_FLAG_AF                     ((uint32_t)0x10000400)
N#define I2C_FLAG_ARLO                   ((uint32_t)0x10000200)
N#define I2C_FLAG_BERR                   ((uint32_t)0x10000100)
N#define I2C_FLAG_TXE                    ((uint32_t)0x10000080)
N#define I2C_FLAG_RXNE                   ((uint32_t)0x10000040)
N#define I2C_FLAG_STOPF                  ((uint32_t)0x10000010)
N#define I2C_FLAG_ADD10                  ((uint32_t)0x10000008)
N#define I2C_FLAG_BTF                    ((uint32_t)0x10000004)
N#define I2C_FLAG_ADDR                   ((uint32_t)0x10000002)
N#define I2C_FLAG_SB                     ((uint32_t)0x10000001)
N
N#define IS_I2C_CLEAR_FLAG(FLAG) ((((FLAG) & (uint16_t)0x20FF) == 0x00) && ((FLAG) != (uint16_t)0x00))
N
N#define IS_I2C_GET_FLAG(FLAG) (((FLAG) == I2C_FLAG_DUALF) || ((FLAG) == I2C_FLAG_SMBHOST) || \
N                               ((FLAG) == I2C_FLAG_SMBDEFAULT) || ((FLAG) == I2C_FLAG_GENCALL) || \
N                               ((FLAG) == I2C_FLAG_TRA) || ((FLAG) == I2C_FLAG_BUSY) || \
N                               ((FLAG) == I2C_FLAG_MSL) || ((FLAG) == I2C_FLAG_SMBALERT) || \
N                               ((FLAG) == I2C_FLAG_TIMEOUT) || ((FLAG) == I2C_FLAG_PECERR) || \
N                               ((FLAG) == I2C_FLAG_OVR) || ((FLAG) == I2C_FLAG_AF) || \
N                               ((FLAG) == I2C_FLAG_ARLO) || ((FLAG) == I2C_FLAG_BERR) || \
N                               ((FLAG) == I2C_FLAG_TXE) || ((FLAG) == I2C_FLAG_RXNE) || \
N                               ((FLAG) == I2C_FLAG_STOPF) || ((FLAG) == I2C_FLAG_ADD10) || \
N                               ((FLAG) == I2C_FLAG_BTF) || ((FLAG) == I2C_FLAG_ADDR) || \
N                               ((FLAG) == I2C_FLAG_SB))
X#define IS_I2C_GET_FLAG(FLAG) (((FLAG) == I2C_FLAG_DUALF) || ((FLAG) == I2C_FLAG_SMBHOST) ||                                ((FLAG) == I2C_FLAG_SMBDEFAULT) || ((FLAG) == I2C_FLAG_GENCALL) ||                                ((FLAG) == I2C_FLAG_TRA) || ((FLAG) == I2C_FLAG_BUSY) ||                                ((FLAG) == I2C_FLAG_MSL) || ((FLAG) == I2C_FLAG_SMBALERT) ||                                ((FLAG) == I2C_FLAG_TIMEOUT) || ((FLAG) == I2C_FLAG_PECERR) ||                                ((FLAG) == I2C_FLAG_OVR) || ((FLAG) == I2C_FLAG_AF) ||                                ((FLAG) == I2C_FLAG_ARLO) || ((FLAG) == I2C_FLAG_BERR) ||                                ((FLAG) == I2C_FLAG_TXE) || ((FLAG) == I2C_FLAG_RXNE) ||                                ((FLAG) == I2C_FLAG_STOPF) || ((FLAG) == I2C_FLAG_ADD10) ||                                ((FLAG) == I2C_FLAG_BTF) || ((FLAG) == I2C_FLAG_ADDR) ||                                ((FLAG) == I2C_FLAG_SB))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_Events 
N  * @{
N  */
N
N/**
N ===============================================================================
N               I2C Master Events (Events grouped in order of communication)
N ===============================================================================
N */
N
N/** 
N  * @brief  Communication start
N  * 
N  * After sending the START condition (I2C_GenerateSTART() function) the master 
N  * has to wait for this event. It means that the Start condition has been correctly 
N  * released on the I2C bus (the bus is free, no other devices is communicating).
N  * 
N  */
N/* --EV5 */
N#define  I2C_EVENT_MASTER_MODE_SELECT                      ((uint32_t)0x00030001)  /* BUSY, MSL and SB flag */
N
N/** 
N  * @brief  Address Acknowledge
N  * 
N  * After checking on EV5 (start condition correctly released on the bus), the 
N  * master sends the address of the slave(s) with which it will communicate 
N  * (I2C_Send7bitAddress() function, it also determines the direction of the communication: 
N  * Master transmitter or Receiver). Then the master has to wait that a slave acknowledges 
N  * his address. If an acknowledge is sent on the bus, one of the following events will 
N  * be set:
N  * 
N  *  1) In case of Master Receiver (7-bit addressing): the I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED 
N  *     event is set.
N  *  
N  *  2) In case of Master Transmitter (7-bit addressing): the I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED 
N  *     is set
N  *  
N  *  3) In case of 10-Bit addressing mode, the master (just after generating the START 
N  *  and checking on EV5) has to send the header of 10-bit addressing mode (I2C_SendData() 
N  *  function). Then master should wait on EV9. It means that the 10-bit addressing 
N  *  header has been correctly sent on the bus. Then master should send the second part of 
N  *  the 10-bit address (LSB) using the function I2C_Send7bitAddress(). Then master 
N  *  should wait for event EV6. 
N  *     
N  */
N
N/* --EV6 */
N#define  I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED        ((uint32_t)0x00070082)  /* BUSY, MSL, ADDR, TXE and TRA flags */
N#define  I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED           ((uint32_t)0x00030002)  /* BUSY, MSL and ADDR flags */
N/* --EV9 */
N#define  I2C_EVENT_MASTER_MODE_ADDRESS10                   ((uint32_t)0x00030008)  /* BUSY, MSL and ADD10 flags */
N
N/** 
N  * @brief Communication events
N  * 
N  * If a communication is established (START condition generated and slave address 
N  * acknowledged) then the master has to check on one of the following events for 
N  * communication procedures:
N  *  
N  * 1) Master Receiver mode: The master has to wait on the event EV7 then to read 
N  *    the data received from the slave (I2C_ReceiveData() function).
N  * 
N  * 2) Master Transmitter mode: The master has to send data (I2C_SendData() 
N  *    function) then to wait on event EV8 or EV8_2.
N  *    These two events are similar: 
N  *     - EV8 means that the data has been written in the data register and is 
N  *       being shifted out.
N  *     - EV8_2 means that the data has been physically shifted out and output 
N  *       on the bus.
N  *     In most cases, using EV8 is sufficient for the application.
N  *     Using EV8_2 leads to a slower communication but ensure more reliable test.
N  *     EV8_2 is also more suitable than EV8 for testing on the last data transmission 
N  *     (before Stop condition generation).
N  *     
N  *  @note In case the  user software does not guarantee that this event EV7 is 
N  *        managed before the current byte end of transfer, then user may check on EV7 
N  *        and BTF flag at the same time (ie. (I2C_EVENT_MASTER_BYTE_RECEIVED | I2C_FLAG_BTF)).
N  *        In this case the communication may be slower.
N  * 
N  */
N
N/* Master RECEIVER mode -----------------------------*/ 
N/* --EV7 */
N#define  I2C_EVENT_MASTER_BYTE_RECEIVED                    ((uint32_t)0x00030040)  /* BUSY, MSL and RXNE flags */
N
N/* Master TRANSMITTER mode --------------------------*/
N/* --EV8 */
N#define I2C_EVENT_MASTER_BYTE_TRANSMITTING                 ((uint32_t)0x00070080) /* TRA, BUSY, MSL, TXE flags */
N/* --EV8_2 */
N#define  I2C_EVENT_MASTER_BYTE_TRANSMITTED                 ((uint32_t)0x00070084)  /* TRA, BUSY, MSL, TXE and BTF flags */
N
N
N/**
N ===============================================================================
N               I2C Slave Events (Events grouped in order of communication)
N ===============================================================================
N */
N
N
N/** 
N  * @brief  Communication start events
N  * 
N  * Wait on one of these events at the start of the communication. It means that 
N  * the I2C peripheral detected a Start condition on the bus (generated by master 
N  * device) followed by the peripheral address. The peripheral generates an ACK 
N  * condition on the bus (if the acknowledge feature is enabled through function 
N  * I2C_AcknowledgeConfig()) and the events listed above are set :
N  *  
N  * 1) In normal case (only one address managed by the slave), when the address 
N  *   sent by the master matches the own address of the peripheral (configured by 
N  *   I2C_OwnAddress1 field) the I2C_EVENT_SLAVE_XXX_ADDRESS_MATCHED event is set 
N  *   (where XXX could be TRANSMITTER or RECEIVER).
N  *    
N  * 2) In case the address sent by the master matches the second address of the 
N  *   peripheral (configured by the function I2C_OwnAddress2Config() and enabled 
N  *   by the function I2C_DualAddressCmd()) the events I2C_EVENT_SLAVE_XXX_SECONDADDRESS_MATCHED 
N  *   (where XXX could be TRANSMITTER or RECEIVER) are set.
N  *   
N  * 3) In case the address sent by the master is General Call (address 0x00) and 
N  *   if the General Call is enabled for the peripheral (using function I2C_GeneralCallCmd()) 
N  *   the following event is set I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED.   
N  * 
N  */
N
N/* --EV1  (all the events below are variants of EV1) */   
N/* 1) Case of One Single Address managed by the slave */
N#define  I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED          ((uint32_t)0x00020002) /* BUSY and ADDR flags */
N#define  I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED       ((uint32_t)0x00060082) /* TRA, BUSY, TXE and ADDR flags */
N
N/* 2) Case of Dual address managed by the slave */
N#define  I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED    ((uint32_t)0x00820000)  /* DUALF and BUSY flags */
N#define  I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED ((uint32_t)0x00860080)  /* DUALF, TRA, BUSY and TXE flags */
N
N/* 3) Case of General Call enabled for the slave */
N#define  I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED        ((uint32_t)0x00120000)  /* GENCALL and BUSY flags */
N
N/** 
N  * @brief  Communication events
N  * 
N  * Wait on one of these events when EV1 has already been checked and: 
N  * 
N  * - Slave RECEIVER mode:
N  *     - EV2: When the application is expecting a data byte to be received. 
N  *     - EV4: When the application is expecting the end of the communication: master 
N  *       sends a stop condition and data transmission is stopped.
N  *    
N  * - Slave Transmitter mode:
N  *    - EV3: When a byte has been transmitted by the slave and the application is expecting 
N  *      the end of the byte transmission. The two events I2C_EVENT_SLAVE_BYTE_TRANSMITTED and
N  *      I2C_EVENT_SLAVE_BYTE_TRANSMITTING are similar. The second one can optionally be 
N  *      used when the user software doesn't guarantee the EV3 is managed before the
N  *      current byte end of transfer.
N  *    - EV3_2: When the master sends a NACK in order to tell slave that data transmission 
N  *      shall end (before sending the STOP condition). In this case slave has to stop sending 
N  *      data bytes and expect a Stop condition on the bus.
N  *      
N  *  @note In case the  user software does not guarantee that the event EV2 is 
N  *        managed before the current byte end of transfer, then user may check on EV2 
N  *        and BTF flag at the same time (ie. (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_BTF)).
N  *        In this case the communication may be slower.
N  *
N  */
N
N/* Slave RECEIVER mode --------------------------*/ 
N/* --EV2 */
N#define  I2C_EVENT_SLAVE_BYTE_RECEIVED                     ((uint32_t)0x00020040)  /* BUSY and RXNE flags */
N/* --EV4  */
N#define  I2C_EVENT_SLAVE_STOP_DETECTED                     ((uint32_t)0x00000010)  /* STOPF flag */
N
N/* Slave TRANSMITTER mode -----------------------*/
N/* --EV3 */
N#define  I2C_EVENT_SLAVE_BYTE_TRANSMITTED                  ((uint32_t)0x00060084)  /* TRA, BUSY, TXE and BTF flags */
N#define  I2C_EVENT_SLAVE_BYTE_TRANSMITTING                 ((uint32_t)0x00060080)  /* TRA, BUSY and TXE flags */
N/* --EV3_2 */
N#define  I2C_EVENT_SLAVE_ACK_FAILURE                       ((uint32_t)0x00000400)  /* AF flag */
N
N/*
N ===============================================================================
N                          End of Events Description
N ===============================================================================
N */
N
N#define IS_I2C_EVENT(EVENT) (((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_BYTE_RECEIVED) || \
N                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)) || \
N                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_BYTE_TRANSMITTED) || \
N                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)) || \
N                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL)) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_STOP_DETECTED) || \
N                             ((EVENT) == I2C_EVENT_MASTER_MODE_SELECT) || \
N                             ((EVENT) == I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) || \
N                             ((EVENT) == I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) || \
N                             ((EVENT) == I2C_EVENT_MASTER_BYTE_RECEIVED) || \
N                             ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTED) || \
N                             ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTING) || \
N                             ((EVENT) == I2C_EVENT_MASTER_MODE_ADDRESS10) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_ACK_FAILURE))
X#define IS_I2C_EVENT(EVENT) (((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED) ||                              ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED) ||                              ((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED) ||                              ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED) ||                              ((EVENT) == I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED) ||                              ((EVENT) == I2C_EVENT_SLAVE_BYTE_RECEIVED) ||                              ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)) ||                              ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)) ||                              ((EVENT) == I2C_EVENT_SLAVE_BYTE_TRANSMITTED) ||                              ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)) ||                              ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL)) ||                              ((EVENT) == I2C_EVENT_SLAVE_STOP_DETECTED) ||                              ((EVENT) == I2C_EVENT_MASTER_MODE_SELECT) ||                              ((EVENT) == I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) ||                              ((EVENT) == I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) ||                              ((EVENT) == I2C_EVENT_MASTER_BYTE_RECEIVED) ||                              ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTED) ||                              ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTING) ||                              ((EVENT) == I2C_EVENT_MASTER_MODE_ADDRESS10) ||                              ((EVENT) == I2C_EVENT_SLAVE_ACK_FAILURE))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_own_address1 
N  * @{
N  */
N
N#define IS_I2C_OWN_ADDRESS1(ADDRESS1) ((ADDRESS1) <= 0x3FF)
N/**
N  * @}
N  */
N
N/** @defgroup I2C_clock_speed 
N  * @{
N  */
N
N#define IS_I2C_CLOCK_SPEED(SPEED) (((SPEED) >= 0x1) && ((SPEED) <= 400000))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/ 
N
N/*  Function used to set the I2C configuration to the default reset state *****/
Nvoid I2C_DeInit(I2C_TypeDef* I2Cx);
N
N/* Initialization and Configuration functions *********************************/
Nvoid I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct);
Nvoid I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct);
Nvoid I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_DigitalFilterConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DigitalFilter);
Nvoid I2C_AnalogFilterCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction);
Nvoid I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address);
Nvoid I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle);
Nvoid I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition);
Nvoid I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert);
Nvoid I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
N
N/* Data transfers functions ***************************************************/ 
Nvoid I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data);
Nuint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx);
N
N/* PEC management functions ***************************************************/ 
Nvoid I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition);
Nvoid I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nuint8_t I2C_GetPEC(I2C_TypeDef* I2Cx);
N
N/* DMA transfers management functions *****************************************/
Nvoid I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
N
N/* Interrupts, events and flags management functions **************************/
Nuint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register);
Nvoid I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState);
N
N/* 
N ===============================================================================
N                          I2C State Monitoring Functions
N ===============================================================================
N  This I2C driver provides three different ways for I2C state monitoring
N  depending on the application requirements and constraints:
N         
N   
N     1. Basic state monitoring (Using I2C_CheckEvent() function)
N     -----------------------------------------------------------
N        It compares the status registers (SR1 and SR2) content to a given event
N        (can be the combination of one or more flags).
N        It returns SUCCESS if the current status includes the given flags 
N        and returns ERROR if one or more flags are missing in the current status.
N
N          - When to use
N             - This function is suitable for most applications as well as for startup 
N               activity since the events are fully described in the product reference 
N               manual (RM0090).
N             - It is also suitable for users who need to define their own events.
N
N          - Limitations
N             - If an error occurs (ie. error flags are set besides to the monitored 
N               flags), the I2C_CheckEvent() function may return SUCCESS despite 
N               the communication hold or corrupted real state. 
N               In this case, it is advised to use error interrupts to monitor 
N               the error events and handle them in the interrupt IRQ handler.
N         
N     Note 
N         For error management, it is advised to use the following functions:
N           - I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).
N           - I2Cx_ER_IRQHandler() which is called when the error interrupt occurs.
N             Where x is the peripheral instance (I2C1, I2C2 ...)
N           - I2C_GetFlagStatus() or I2C_GetITStatus()  to be called into the 
N             I2Cx_ER_IRQHandler() function in order to determine which error occurred.
N           - I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd() 
N             and/or I2C_GenerateStop() in order to clear the error flag and source 
N             and return to correct  communication status.
N             
N 
N     2. Advanced state monitoring (Using the function I2C_GetLastEvent())
N     -------------------------------------------------------------------- 
N        Using the function I2C_GetLastEvent() which returns the image of both status 
N        registers in a single word (uint32_t) (Status Register 2 value is shifted left 
N        by 16 bits and concatenated to Status Register 1).
N
N          - When to use
N             - This function is suitable for the same applications above but it 
N               allows to overcome the mentioned limitation of I2C_GetFlagStatus() 
N               function.
N             - The returned value could be compared to events already defined in 
N               this file or to custom values defined by user.
N               This function is suitable when multiple flags are monitored at the 
N               same time.
N             - At the opposite of I2C_CheckEvent() function, this function allows 
N               user to choose when an event is accepted (when all events flags are 
N               set and no other flags are set or just when the needed flags are set 
N               like I2C_CheckEvent() function.
N
N          - Limitations
N             - User may need to define his own events.
N             - Same remark concerning the error management is applicable for this 
N               function if user decides to check only regular communication flags 
N               (and ignores error flags).
N      
N 
N     3. Flag-based state monitoring (Using the function I2C_GetFlagStatus())
N     -----------------------------------------------------------------------
N     
N      Using the function I2C_GetFlagStatus() which simply returns the status of 
N      one single flag (ie. I2C_FLAG_RXNE ...). 
N
N          - When to use
N             - This function could be used for specific applications or in debug 
N               phase.
N             - It is suitable when only one flag checking is needed (most I2C 
N               events are monitored through multiple flags).
N          - Limitations: 
N             - When calling this function, the Status register is accessed. 
N               Some flags are cleared when the status register is accessed. 
N               So checking the status of one Flag, may clear other ones.
N             - Function may need to be called twice or more in order to monitor 
N               one single event.           
N */
N
N/*
N ===============================================================================
N                          1. Basic state monitoring
N ===============================================================================
N */
NErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT);
N/*
N ===============================================================================
N                          2. Advanced state monitoring
N ===============================================================================
N */
Nuint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx);
N/*
N ===============================================================================
N                          3. Flag-based state monitoring
N ===============================================================================
N */
NFlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);
N
N
Nvoid I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);
NITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT);
Nvoid I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F4xx_I2C_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 42 "..\..\Service\stm32f4xx_conf.h" 2
N#include "stm32f4xx_iwdg.h"
L 1 "..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\stm32f4xx_iwdg.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_iwdg.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    04-November-2016
N  * @brief   This file contains all the functions prototypes for the IWDG 
N  *          firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_IWDG_H
N#define __STM32F4xx_IWDG_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
N
N/** @addtogroup STM32F4xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup IWDG
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup IWDG_Exported_Constants
N  * @{
N  */
N  
N/** @defgroup IWDG_WriteAccess
N  * @{
N  */
N#define IWDG_WriteAccess_Enable     ((uint16_t)0x5555)
N#define IWDG_WriteAccess_Disable    ((uint16_t)0x0000)
N#define IS_IWDG_WRITE_ACCESS(ACCESS) (((ACCESS) == IWDG_WriteAccess_Enable) || \
N                                      ((ACCESS) == IWDG_WriteAccess_Disable))
X#define IS_IWDG_WRITE_ACCESS(ACCESS) (((ACCESS) == IWDG_WriteAccess_Enable) ||                                       ((ACCESS) == IWDG_WriteAccess_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup IWDG_prescaler 
N  * @{
N  */
N#define IWDG_Prescaler_4            ((uint8_t)0x00)
N#define IWDG_Prescaler_8            ((uint8_t)0x01)
N#define IWDG_Prescaler_16           ((uint8_t)0x02)
N#define IWDG_Prescaler_32           ((uint8_t)0x03)
N#define IWDG_Prescaler_64           ((uint8_t)0x04)
N#define IWDG_Prescaler_128          ((uint8_t)0x05)
N#define IWDG_Prescaler_256          ((uint8_t)0x06)
N#define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  || \
N                                      ((PRESCALER) == IWDG_Prescaler_8)  || \
N                                      ((PRESCALER) == IWDG_Prescaler_16) || \
N                                      ((PRESCALER) == IWDG_Prescaler_32) || \
N                                      ((PRESCALER) == IWDG_Prescaler_64) || \
N                                      ((PRESCALER) == IWDG_Prescaler_128)|| \
N                                      ((PRESCALER) == IWDG_Prescaler_256))
X#define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  ||                                       ((PRESCALER) == IWDG_Prescaler_8)  ||                                       ((PRESCALER) == IWDG_Prescaler_16) ||                                       ((PRESCALER) == IWDG_Prescaler_32) ||                                       ((PRESCALER) == IWDG_Prescaler_64) ||                                       ((PRESCALER) == IWDG_Prescaler_128)||                                       ((PRESCALER) == IWDG_Prescaler_256))
N/**
N  * @}
N  */
N
N/** @defgroup IWDG_Flag 
N  * @{
N  */
N#define IWDG_FLAG_PVU               ((uint16_t)0x0001)
N#define IWDG_FLAG_RVU               ((uint16_t)0x0002)
N#define IS_IWDG_FLAG(FLAG) (((FLAG) == IWDG_FLAG_PVU) || ((FLAG) == IWDG_FLAG_RVU))
N#define IS_IWDG_RELOAD(RELOAD) ((RELOAD) <= 0xFFF)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/
N
N/* Prescaler and Counter configuration functions ******************************/
Nvoid IWDG_WriteAccessCmd(uint16_t IWDG_WriteAccess);
Nvoid IWDG_SetPrescaler(uint8_t IWDG_Prescaler);
Nvoid IWDG_SetReload(uint16_t Reload);
Nvoid IWDG_ReloadCounter(void);
N
N/* IWDG activation function ***************************************************/
Nvoid IWDG_Enable(void);
N
N/* Flag management function ***************************************************/
NFlagStatus IWDG_GetFlagStatus(uint16_t IWDG_FLAG);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_IWDG_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 43 "..\..\Service\stm32f4xx_conf.h" 2
N#include "stm32f4xx_pwr.h"
L 1 "..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\stm32f4xx_pwr.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_pwr.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    04-November-2016
N  * @brief   This file contains all the functions prototypes for the PWR firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_PWR_H
N#define __STM32F4xx_PWR_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
N
N/** @addtogroup STM32F4xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup PWR
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup PWR_Exported_Constants
N  * @{
N  */ 
N
N/** @defgroup PWR_PVD_detection_level 
N  * @{
N  */ 
N#define PWR_PVDLevel_0                  PWR_CR_PLS_LEV0
N#define PWR_PVDLevel_1                  PWR_CR_PLS_LEV1
N#define PWR_PVDLevel_2                  PWR_CR_PLS_LEV2
N#define PWR_PVDLevel_3                  PWR_CR_PLS_LEV3
N#define PWR_PVDLevel_4                  PWR_CR_PLS_LEV4
N#define PWR_PVDLevel_5                  PWR_CR_PLS_LEV5
N#define PWR_PVDLevel_6                  PWR_CR_PLS_LEV6
N#define PWR_PVDLevel_7                  PWR_CR_PLS_LEV7
N
N#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLevel_0) || ((LEVEL) == PWR_PVDLevel_1)|| \
N                                 ((LEVEL) == PWR_PVDLevel_2) || ((LEVEL) == PWR_PVDLevel_3)|| \
N                                 ((LEVEL) == PWR_PVDLevel_4) || ((LEVEL) == PWR_PVDLevel_5)|| \
N                                 ((LEVEL) == PWR_PVDLevel_6) || ((LEVEL) == PWR_PVDLevel_7))
X#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLevel_0) || ((LEVEL) == PWR_PVDLevel_1)||                                  ((LEVEL) == PWR_PVDLevel_2) || ((LEVEL) == PWR_PVDLevel_3)||                                  ((LEVEL) == PWR_PVDLevel_4) || ((LEVEL) == PWR_PVDLevel_5)||                                  ((LEVEL) == PWR_PVDLevel_6) || ((LEVEL) == PWR_PVDLevel_7))
N/**
N  * @}
N  */
N
N  
N/** @defgroup PWR_Regulator_state_in_STOP_mode 
N  * @{
N  */
N#define PWR_MainRegulator_ON                        ((uint32_t)0x00000000)
N#define PWR_LowPowerRegulator_ON                    PWR_CR_LPDS
N
N/* --- PWR_Legacy ---*/
N#define PWR_Regulator_ON                            PWR_MainRegulator_ON
N#define PWR_Regulator_LowPower                      PWR_LowPowerRegulator_ON
N
N#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_MainRegulator_ON) || \
N                                     ((REGULATOR) == PWR_LowPowerRegulator_ON))
X#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_MainRegulator_ON) ||                                      ((REGULATOR) == PWR_LowPowerRegulator_ON))
N
N/**
N  * @}
N  */
N
N/** @defgroup PWR_Regulator_state_in_UnderDrive_mode 
N  * @{
N  */
N#define PWR_MainRegulator_UnderDrive_ON               PWR_CR_MRUDS
N#define PWR_LowPowerRegulator_UnderDrive_ON           ((uint32_t)(PWR_CR_LPDS | PWR_CR_LPUDS))
N
N#define IS_PWR_REGULATOR_UNDERDRIVE(REGULATOR) (((REGULATOR) == PWR_MainRegulator_UnderDrive_ON) || \
N                                                ((REGULATOR) == PWR_LowPowerRegulator_UnderDrive_ON))
X#define IS_PWR_REGULATOR_UNDERDRIVE(REGULATOR) (((REGULATOR) == PWR_MainRegulator_UnderDrive_ON) ||                                                 ((REGULATOR) == PWR_LowPowerRegulator_UnderDrive_ON))
N
N/**
N  * @}
N  */
N#if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
X#if 0L || 0L || 0L || 0L
S/** @defgroup PWR_Wake_Up_Pin
S  * @{
S  */
S#define PWR_WakeUp_Pin1           ((uint32_t)0x00)
S#define PWR_WakeUp_Pin2           ((uint32_t)0x01)
S#if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx)
S#define PWR_WakeUp_Pin3           ((uint32_t)0x02)
S#endif /* STM32F410xx || STM32F412xG || STM32F413_423xx */
S
S#if defined(STM32F446xx)
S#define IS_PWR_WAKEUP_PIN(PIN) (((PIN) == PWR_WakeUp_Pin1) || \
S                                ((PIN) == PWR_WakeUp_Pin2))
X#define IS_PWR_WAKEUP_PIN(PIN) (((PIN) == PWR_WakeUp_Pin1) ||                                 ((PIN) == PWR_WakeUp_Pin2))
S#else /* STM32F410xx || STM32F412xG */
S#define IS_PWR_WAKEUP_PIN(PIN) (((PIN) == PWR_WakeUp_Pin1) || ((PIN) == PWR_WakeUp_Pin2) || \
S                                ((PIN) == PWR_WakeUp_Pin3)) 
X#define IS_PWR_WAKEUP_PIN(PIN) (((PIN) == PWR_WakeUp_Pin1) || ((PIN) == PWR_WakeUp_Pin2) ||                                 ((PIN) == PWR_WakeUp_Pin3)) 
S#endif /* STM32F446xx */
S/**
S  * @}
S  */    
N#endif /* STM32F410xx || STM32F412xG || STM32F413_423xx || STM32F446xx */
N
N/** @defgroup PWR_STOP_mode_entry 
N  * @{
N  */
N#define PWR_STOPEntry_WFI               ((uint8_t)0x01)
N#define PWR_STOPEntry_WFE               ((uint8_t)0x02)
N#define IS_PWR_STOP_ENTRY(ENTRY) (((ENTRY) == PWR_STOPEntry_WFI) || ((ENTRY) == PWR_STOPEntry_WFE))
N/**
N  * @}
N  */
N
N/** @defgroup PWR_Regulator_Voltage_Scale 
N  * @{
N  */
N#define PWR_Regulator_Voltage_Scale1    ((uint32_t)0x0000C000)
N#define PWR_Regulator_Voltage_Scale2    ((uint32_t)0x00008000)
N#define PWR_Regulator_Voltage_Scale3    ((uint32_t)0x00004000)
N#define IS_PWR_REGULATOR_VOLTAGE(VOLTAGE) (((VOLTAGE) == PWR_Regulator_Voltage_Scale1) || \
N                                           ((VOLTAGE) == PWR_Regulator_Voltage_Scale2) || \
N                                           ((VOLTAGE) == PWR_Regulator_Voltage_Scale3))
X#define IS_PWR_REGULATOR_VOLTAGE(VOLTAGE) (((VOLTAGE) == PWR_Regulator_Voltage_Scale1) ||                                            ((VOLTAGE) == PWR_Regulator_Voltage_Scale2) ||                                            ((VOLTAGE) == PWR_Regulator_Voltage_Scale3))
N/**
N  * @}
N  */
N
N/** @defgroup PWR_Flag 
N  * @{
N  */
N#define PWR_FLAG_WU                     PWR_CSR_WUF
N#define PWR_FLAG_SB                     PWR_CSR_SBF
N#define PWR_FLAG_PVDO                   PWR_CSR_PVDO
N#define PWR_FLAG_BRR                    PWR_CSR_BRR
N#define PWR_FLAG_VOSRDY                 PWR_CSR_VOSRDY
N#define PWR_FLAG_ODRDY                  PWR_CSR_ODRDY
N#define PWR_FLAG_ODSWRDY                PWR_CSR_ODSWRDY
N#define PWR_FLAG_UDRDY                  PWR_CSR_UDSWRDY
N
N/* --- FLAG Legacy ---*/
N#define PWR_FLAG_REGRDY                  PWR_FLAG_VOSRDY               
N
N#define IS_PWR_GET_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB) || \
N                               ((FLAG) == PWR_FLAG_PVDO) || ((FLAG) == PWR_FLAG_BRR) || \
N                               ((FLAG) == PWR_FLAG_VOSRDY) || ((FLAG) == PWR_FLAG_ODRDY) || \
N                               ((FLAG) == PWR_FLAG_ODSWRDY) || ((FLAG) == PWR_FLAG_UDRDY))
X#define IS_PWR_GET_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB) ||                                ((FLAG) == PWR_FLAG_PVDO) || ((FLAG) == PWR_FLAG_BRR) ||                                ((FLAG) == PWR_FLAG_VOSRDY) || ((FLAG) == PWR_FLAG_ODRDY) ||                                ((FLAG) == PWR_FLAG_ODSWRDY) || ((FLAG) == PWR_FLAG_UDRDY))
N
N
N#define IS_PWR_CLEAR_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB) || \
N                                 ((FLAG) == PWR_FLAG_UDRDY))
X#define IS_PWR_CLEAR_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB) ||                                  ((FLAG) == PWR_FLAG_UDRDY))
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/ 
N
N/* Function used to set the PWR configuration to the default reset state ******/ 
Nvoid PWR_DeInit(void);
N
N/* Backup Domain Access function **********************************************/ 
Nvoid PWR_BackupAccessCmd(FunctionalState NewState);
N
N/* PVD configuration functions ************************************************/ 
Nvoid PWR_PVDLevelConfig(uint32_t PWR_PVDLevel);
Nvoid PWR_PVDCmd(FunctionalState NewState);
N
N/* WakeUp pins configuration functions ****************************************/
N#if defined(STM32F40_41xxx) || defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F401xx) || defined(STM32F411xE)
X#if 1L || 0L || 0L || 0L || 0L
Nvoid PWR_WakeUpPinCmd(FunctionalState NewState);
N#endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F401xx || STM32F411xE */
N#if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx) ||defined(STM32F446xx)
X#if 0L || 0L || 0L ||0L
Svoid PWR_WakeUpPinCmd(uint32_t PWR_WakeUpPinx, FunctionalState NewState);
N#endif /* STM32F410xx || STM32F412xG || STM32F413_423xx || STM32F446xx */
N/* Main and Backup Regulators configuration functions *************************/ 
Nvoid PWR_BackupRegulatorCmd(FunctionalState NewState);
Nvoid PWR_MainRegulatorModeConfig(uint32_t PWR_Regulator_Voltage);
Nvoid PWR_OverDriveCmd(FunctionalState NewState);
Nvoid PWR_OverDriveSWCmd(FunctionalState NewState);
Nvoid PWR_UnderDriveCmd(FunctionalState NewState);
N
N#if defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F446xx)
X#if 0L || 0L || 0L
Svoid PWR_MainRegulatorUnderDriveCmd(FunctionalState NewState);
Svoid PWR_LowRegulatorUnderDriveCmd(FunctionalState NewState);
N#endif /* STM32F427_437xx || STM32F429_439xx || STM32F446xx */
N
N#if defined(STM32F401xx) || defined(STM32F410xx) || defined(STM32F411xE) || defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 0L || 0L || 0L || 0L || 0L
Svoid PWR_MainRegulatorLowVoltageCmd(FunctionalState NewState);
Svoid PWR_LowRegulatorLowVoltageCmd(FunctionalState NewState);
N#endif /* STM32F401xx || STM32F410xx || STM32F411xE || STM32F412xG || STM32F413_423xx */
N
N/* FLASH Power Down configuration functions ***********************************/ 
Nvoid PWR_FlashPowerDownCmd(FunctionalState NewState);
N
N/* Low Power modes configuration functions ************************************/ 
Nvoid PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry);
Nvoid PWR_EnterUnderDriveSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry);
Nvoid PWR_EnterSTANDBYMode(void);
N
N/* Flags management functions *************************************************/ 
NFlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG);
Nvoid PWR_ClearFlag(uint32_t PWR_FLAG);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_PWR_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 44 "..\..\Service\stm32f4xx_conf.h" 2
N#include "stm32f4xx_rcc.h"
L 1 "..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\stm32f4xx_rcc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_rcc.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    04-November-2016
N  * @brief   This file contains all the functions prototypes for the RCC firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_RCC_H
N#define __STM32F4xx_RCC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
N
N/** @addtogroup STM32F4xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup RCC
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
Ntypedef struct
N{
N  uint32_t SYSCLK_Frequency; /*!<  SYSCLK clock frequency expressed in Hz */
N  uint32_t HCLK_Frequency;   /*!<  HCLK clock frequency expressed in Hz   */
N  uint32_t PCLK1_Frequency;  /*!<  PCLK1 clock frequency expressed in Hz  */
N  uint32_t PCLK2_Frequency;  /*!<  PCLK2 clock frequency expressed in Hz  */
N}RCC_ClocksTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup RCC_Exported_Constants
N  * @{
N  */
N  
N/** @defgroup RCC_HSE_configuration 
N  * @{
N  */
N#define RCC_HSE_OFF                      ((uint8_t)0x00)
N#define RCC_HSE_ON                       ((uint8_t)0x01)
N#define RCC_HSE_Bypass                   ((uint8_t)0x05)
N#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) || \
N                         ((HSE) == RCC_HSE_Bypass))
X#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) ||                          ((HSE) == RCC_HSE_Bypass))
N/**
N  * @}
N  */ 
N
N/** @defgroup RCC_LSE_Dual_Mode_Selection
N  * @{
N  */
N#define RCC_LSE_LOWPOWER_MODE           ((uint8_t)0x00)
N#define RCC_LSE_HIGHDRIVE_MODE          ((uint8_t)0x01)
N#define IS_RCC_LSE_MODE(MODE)           (((MODE) == RCC_LSE_LOWPOWER_MODE) || \
N                                         ((MODE) == RCC_LSE_HIGHDRIVE_MODE))
X#define IS_RCC_LSE_MODE(MODE)           (((MODE) == RCC_LSE_LOWPOWER_MODE) ||                                          ((MODE) == RCC_LSE_HIGHDRIVE_MODE))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_PLLSAIDivR_Factor
N  * @{
N  */
N#define RCC_PLLSAIDivR_Div2                ((uint32_t)0x00000000)
N#define RCC_PLLSAIDivR_Div4                ((uint32_t)0x00010000)
N#define RCC_PLLSAIDivR_Div8                ((uint32_t)0x00020000)
N#define RCC_PLLSAIDivR_Div16               ((uint32_t)0x00030000)
N#define IS_RCC_PLLSAI_DIVR_VALUE(VALUE) (((VALUE) == RCC_PLLSAIDivR_Div2) ||\
N                                        ((VALUE) == RCC_PLLSAIDivR_Div4)  ||\
N                                        ((VALUE) == RCC_PLLSAIDivR_Div8)  ||\
N                                        ((VALUE) == RCC_PLLSAIDivR_Div16))
X#define IS_RCC_PLLSAI_DIVR_VALUE(VALUE) (((VALUE) == RCC_PLLSAIDivR_Div2) ||                                        ((VALUE) == RCC_PLLSAIDivR_Div4)  ||                                        ((VALUE) == RCC_PLLSAIDivR_Div8)  ||                                        ((VALUE) == RCC_PLLSAIDivR_Div16))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_PLL_Clock_Source 
N  * @{
N  */
N#define RCC_PLLSource_HSI                ((uint32_t)0x00000000)
N#define RCC_PLLSource_HSE                ((uint32_t)0x00400000)
N#define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI) || \
N                                   ((SOURCE) == RCC_PLLSource_HSE))
X#define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI) ||                                    ((SOURCE) == RCC_PLLSource_HSE))
N#define IS_RCC_PLLM_VALUE(VALUE) ((VALUE) <= 63)
N#define IS_RCC_PLLN_VALUE(VALUE) ((50 <= (VALUE)) && ((VALUE) <= 432))
N#define IS_RCC_PLLP_VALUE(VALUE) (((VALUE) == 2) || ((VALUE) == 4) || ((VALUE) == 6) || ((VALUE) == 8))
N#define IS_RCC_PLLQ_VALUE(VALUE) ((4 <= (VALUE)) && ((VALUE) <= 15))
N#if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
X#if 0L || 0L || 0L || 0L || 0L
S#define IS_RCC_PLLR_VALUE(VALUE) ((2 <= (VALUE)) && ((VALUE) <= 7))
N#endif /* STM32F410xx || STM32F412xG || STM32F413_423xx || STM32F446xx || STM32F469_479xx */
N
N#define IS_RCC_PLLI2SN_VALUE(VALUE) ((50 <= (VALUE)) && ((VALUE) <= 432))
N#define IS_RCC_PLLI2SR_VALUE(VALUE) ((2 <= (VALUE))  && ((VALUE) <= 7))
N#define IS_RCC_PLLI2SM_VALUE(VALUE) ((2 <= (VALUE))  && ((VALUE) <= 63))
N#define IS_RCC_PLLI2SQ_VALUE(VALUE) ((2 <= (VALUE))  && ((VALUE) <= 15))
N#if defined(STM32F446xx) 
X#if 0L 
S#define IS_RCC_PLLI2SP_VALUE(VALUE) (((VALUE) == 2) || ((VALUE) == 4) || ((VALUE) == 6) || ((VALUE) == 8))
S#define IS_RCC_PLLSAIM_VALUE(VALUE) ((VALUE) <= 63)
S#elif  defined(STM32F412xG) || defined(STM32F413_423xx)
X#elif  0L || 0L
S#define IS_RCC_PLLI2SP_VALUE(VALUE) (((VALUE) == 2) || ((VALUE) == 4) || ((VALUE) == 6) || ((VALUE) == 8))
N#else
N#endif /* STM32F446xx */
N#define IS_RCC_PLLSAIN_VALUE(VALUE) ((50 <= (VALUE)) && ((VALUE) <= 432))
N#if defined(STM32F446xx) || defined(STM32F469_479xx)
X#if 0L || 0L
S#define IS_RCC_PLLSAIP_VALUE(VALUE) (((VALUE) == 2) || ((VALUE) == 4) || ((VALUE) == 6) || ((VALUE) == 8))
N#endif /* STM32F446xx || STM32F469_479xx */
N#define IS_RCC_PLLSAIQ_VALUE(VALUE) ((2 <= (VALUE)) && ((VALUE) <= 15))
N#define IS_RCC_PLLSAIR_VALUE(VALUE) ((2 <= (VALUE)) && ((VALUE) <= 7))  
N
N#define IS_RCC_PLLSAI_DIVQ_VALUE(VALUE) ((1 <= (VALUE)) && ((VALUE) <= 32))
N#define IS_RCC_PLLI2S_DIVQ_VALUE(VALUE) ((1 <= (VALUE)) && ((VALUE) <= 32))
N
N#if defined(STM32F413_423xx)
X#if 0L
S#define IS_RCC_PLLI2S_DIVR_VALUE(VALUE) ((1 <= (VALUE)) && ((VALUE) <= 32))
S#define IS_RCC_PLL_DIVR_VALUE(VALUE)    ((1 <= (VALUE)) && ((VALUE) <= 32))
N#endif /* STM32F413_423xx */
N/**
N  * @}
N  */ 
N  
N/** @defgroup RCC_System_Clock_Source 
N  * @{
N  */
N
N#if  defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
X#if  0L || 0L || 0L
S#define RCC_SYSCLKSource_HSI             ((uint32_t)0x00000000)
S#define RCC_SYSCLKSource_HSE             ((uint32_t)0x00000001)
S#define RCC_SYSCLKSource_PLLPCLK         ((uint32_t)0x00000002)
S#define RCC_SYSCLKSource_PLLRCLK         ((uint32_t)0x00000003)
S#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI) || \
S                                      ((SOURCE) == RCC_SYSCLKSource_HSE) || \
S                                      ((SOURCE) == RCC_SYSCLKSource_PLLPCLK) || \
S                                      ((SOURCE) == RCC_SYSCLKSource_PLLRCLK))
X#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI) ||                                       ((SOURCE) == RCC_SYSCLKSource_HSE) ||                                       ((SOURCE) == RCC_SYSCLKSource_PLLPCLK) ||                                       ((SOURCE) == RCC_SYSCLKSource_PLLRCLK))
S/* Add legacy definition */
S#define  RCC_SYSCLKSource_PLLCLK    RCC_SYSCLKSource_PLLPCLK  
N#endif /* STM32F446xx */
N
N#if defined(STM32F40_41xxx) || defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F401xx) || defined(STM32F410xx) || defined(STM32F411xE) || defined(STM32F469_479xx)
X#if 1L || 0L || 0L || 0L || 0L || 0L || 0L
N#define RCC_SYSCLKSource_HSI             ((uint32_t)0x00000000)
N#define RCC_SYSCLKSource_HSE             ((uint32_t)0x00000001)
N#define RCC_SYSCLKSource_PLLCLK          ((uint32_t)0x00000002)
N#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI) || \
N                                      ((SOURCE) == RCC_SYSCLKSource_HSE) || \
N                                      ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
X#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI) ||                                       ((SOURCE) == RCC_SYSCLKSource_HSE) ||                                       ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
N#endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F401xx || STM32F410xx || STM32F411xE || STM32F469_479xx */ 
N/**
N  * @}
N  */ 
N  
N/** @defgroup RCC_AHB_Clock_Source
N  * @{
N  */
N#define RCC_SYSCLK_Div1                  ((uint32_t)0x00000000)
N#define RCC_SYSCLK_Div2                  ((uint32_t)0x00000080)
N#define RCC_SYSCLK_Div4                  ((uint32_t)0x00000090)
N#define RCC_SYSCLK_Div8                  ((uint32_t)0x000000A0)
N#define RCC_SYSCLK_Div16                 ((uint32_t)0x000000B0)
N#define RCC_SYSCLK_Div64                 ((uint32_t)0x000000C0)
N#define RCC_SYSCLK_Div128                ((uint32_t)0x000000D0)
N#define RCC_SYSCLK_Div256                ((uint32_t)0x000000E0)
N#define RCC_SYSCLK_Div512                ((uint32_t)0x000000F0)
N#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) || \
N                           ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) || \
N                           ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) || \
N                           ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) || \
N                           ((HCLK) == RCC_SYSCLK_Div512))
X#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) ||                            ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) ||                            ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) ||                            ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) ||                            ((HCLK) == RCC_SYSCLK_Div512))
N/**
N  * @}
N  */ 
N  
N/** @defgroup RCC_APB1_APB2_Clock_Source
N  * @{
N  */
N#define RCC_HCLK_Div1                    ((uint32_t)0x00000000)
N#define RCC_HCLK_Div2                    ((uint32_t)0x00001000)
N#define RCC_HCLK_Div4                    ((uint32_t)0x00001400)
N#define RCC_HCLK_Div8                    ((uint32_t)0x00001800)
N#define RCC_HCLK_Div16                   ((uint32_t)0x00001C00)
N#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) || \
N                           ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) || \
N                           ((PCLK) == RCC_HCLK_Div16))
X#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) ||                            ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) ||                            ((PCLK) == RCC_HCLK_Div16))
N/**
N  * @}
N  */ 
N  
N/** @defgroup RCC_Interrupt_Source 
N  * @{
N  */
N#define RCC_IT_LSIRDY                    ((uint8_t)0x01)
N#define RCC_IT_LSERDY                    ((uint8_t)0x02)
N#define RCC_IT_HSIRDY                    ((uint8_t)0x04)
N#define RCC_IT_HSERDY                    ((uint8_t)0x08)
N#define RCC_IT_PLLRDY                    ((uint8_t)0x10)
N#define RCC_IT_PLLI2SRDY                 ((uint8_t)0x20) 
N#define RCC_IT_PLLSAIRDY                 ((uint8_t)0x40)
N#define RCC_IT_CSS                       ((uint8_t)0x80)
N
N#define IS_RCC_IT(IT) ((((IT) & (uint8_t)0x80) == 0x00) && ((IT) != 0x00))
N#define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) || \
N                           ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) || \
N                           ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS) || \
N                           ((IT) == RCC_IT_PLLSAIRDY) || ((IT) == RCC_IT_PLLI2SRDY))
X#define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) ||                            ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) ||                            ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS) ||                            ((IT) == RCC_IT_PLLSAIRDY) || ((IT) == RCC_IT_PLLI2SRDY))
N#define IS_RCC_CLEAR_IT(IT)((IT) != 0x00)
N
N/**
N  * @}
N  */ 
N  
N/** @defgroup RCC_LSE_Configuration 
N  * @{
N  */
N#define RCC_LSE_OFF                      ((uint8_t)0x00)
N#define RCC_LSE_ON                       ((uint8_t)0x01)
N#define RCC_LSE_Bypass                   ((uint8_t)0x04)
N#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) || \
N                         ((LSE) == RCC_LSE_Bypass))
X#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) ||                          ((LSE) == RCC_LSE_Bypass))
N/**
N  * @}
N  */ 
N  
N/** @defgroup RCC_RTC_Clock_Source
N  * @{
N  */
N#define RCC_RTCCLKSource_LSE             ((uint32_t)0x00000100)
N#define RCC_RTCCLKSource_LSI             ((uint32_t)0x00000200)
N#define RCC_RTCCLKSource_HSE_Div2        ((uint32_t)0x00020300)
N#define RCC_RTCCLKSource_HSE_Div3        ((uint32_t)0x00030300)
N#define RCC_RTCCLKSource_HSE_Div4        ((uint32_t)0x00040300)
N#define RCC_RTCCLKSource_HSE_Div5        ((uint32_t)0x00050300)
N#define RCC_RTCCLKSource_HSE_Div6        ((uint32_t)0x00060300)
N#define RCC_RTCCLKSource_HSE_Div7        ((uint32_t)0x00070300)
N#define RCC_RTCCLKSource_HSE_Div8        ((uint32_t)0x00080300)
N#define RCC_RTCCLKSource_HSE_Div9        ((uint32_t)0x00090300)
N#define RCC_RTCCLKSource_HSE_Div10       ((uint32_t)0x000A0300)
N#define RCC_RTCCLKSource_HSE_Div11       ((uint32_t)0x000B0300)
N#define RCC_RTCCLKSource_HSE_Div12       ((uint32_t)0x000C0300)
N#define RCC_RTCCLKSource_HSE_Div13       ((uint32_t)0x000D0300)
N#define RCC_RTCCLKSource_HSE_Div14       ((uint32_t)0x000E0300)
N#define RCC_RTCCLKSource_HSE_Div15       ((uint32_t)0x000F0300)
N#define RCC_RTCCLKSource_HSE_Div16       ((uint32_t)0x00100300)
N#define RCC_RTCCLKSource_HSE_Div17       ((uint32_t)0x00110300)
N#define RCC_RTCCLKSource_HSE_Div18       ((uint32_t)0x00120300)
N#define RCC_RTCCLKSource_HSE_Div19       ((uint32_t)0x00130300)
N#define RCC_RTCCLKSource_HSE_Div20       ((uint32_t)0x00140300)
N#define RCC_RTCCLKSource_HSE_Div21       ((uint32_t)0x00150300)
N#define RCC_RTCCLKSource_HSE_Div22       ((uint32_t)0x00160300)
N#define RCC_RTCCLKSource_HSE_Div23       ((uint32_t)0x00170300)
N#define RCC_RTCCLKSource_HSE_Div24       ((uint32_t)0x00180300)
N#define RCC_RTCCLKSource_HSE_Div25       ((uint32_t)0x00190300)
N#define RCC_RTCCLKSource_HSE_Div26       ((uint32_t)0x001A0300)
N#define RCC_RTCCLKSource_HSE_Div27       ((uint32_t)0x001B0300)
N#define RCC_RTCCLKSource_HSE_Div28       ((uint32_t)0x001C0300)
N#define RCC_RTCCLKSource_HSE_Div29       ((uint32_t)0x001D0300)
N#define RCC_RTCCLKSource_HSE_Div30       ((uint32_t)0x001E0300)
N#define RCC_RTCCLKSource_HSE_Div31       ((uint32_t)0x001F0300)
N#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_LSI) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div2) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div3) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div4) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div5) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div6) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div7) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div8) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div9) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div10) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div11) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div12) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div13) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div14) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div15) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div16) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div17) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div18) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div19) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div20) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div21) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div22) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div23) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div24) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div25) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div26) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div27) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div28) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div29) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div30) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div31))
X#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) ||                                       ((SOURCE) == RCC_RTCCLKSource_LSI) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div2) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div3) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div4) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div5) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div6) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div7) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div8) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div9) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div10) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div11) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div12) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div13) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div14) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div15) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div16) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div17) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div18) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div19) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div20) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div21) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div22) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div23) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div24) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div25) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div26) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div27) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div28) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div29) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div30) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div31))
N/**
N  * @}
N  */ 
N
N#if defined(STM32F410xx) || defined(STM32F413_423xx)
X#if 0L || 0L
S/** @defgroup RCCEx_LPTIM1_Clock_Source  RCC LPTIM1 Clock Source
S  * @{
S  */
S#define RCC_LPTIM1CLKSOURCE_PCLK            ((uint32_t)0x00000000)
S#define RCC_LPTIM1CLKSOURCE_HSI            ((uint32_t)RCC_DCKCFGR2_LPTIM1SEL_0)
S#define RCC_LPTIM1CLKSOURCE_LSI            ((uint32_t)RCC_DCKCFGR2_LPTIM1SEL_1)
S#define RCC_LPTIM1CLKSOURCE_LSE            ((uint32_t)RCC_DCKCFGR2_LPTIM1SEL_0 | RCC_DCKCFGR2_LPTIM1SEL_1)
S
S#define IS_RCC_LPTIM1_CLOCKSOURCE(SOURCE) (((SOURCE) == RCC_LPTIM1CLKSOURCE_PCLK) || ((SOURCE) == RCC_LPTIM1CLKSOURCE_HSI) || \
S                                           ((SOURCE) == RCC_LPTIM1CLKSOURCE_LSI) || ((SOURCE) == RCC_LPTIM1CLKSOURCE_LSE))
X#define IS_RCC_LPTIM1_CLOCKSOURCE(SOURCE) (((SOURCE) == RCC_LPTIM1CLKSOURCE_PCLK) || ((SOURCE) == RCC_LPTIM1CLKSOURCE_HSI) ||                                            ((SOURCE) == RCC_LPTIM1CLKSOURCE_LSI) || ((SOURCE) == RCC_LPTIM1CLKSOURCE_LSE))
S/* Legacy Defines */
S#define IS_RCC_LPTIM1_SOURCE           IS_RCC_LPTIM1_CLOCKSOURCE
S
S#if defined(STM32F410xx)
S/**
S  * @}
S  */
S
S/** @defgroup RCCEx_I2S_APB_Clock_Source  RCC I2S APB Clock Source
S  * @{
S  */
S#define RCC_I2SAPBCLKSOURCE_PLLR            ((uint32_t)0x00000000)
S#define RCC_I2SAPBCLKSOURCE_EXT             ((uint32_t)RCC_DCKCFGR_I2SSRC_0)
S#define RCC_I2SAPBCLKSOURCE_PLLSRC          ((uint32_t)RCC_DCKCFGR_I2SSRC_1)
S#define IS_RCC_I2SCLK_SOURCE(SOURCE) (((SOURCE) == RCC_I2SAPBCLKSOURCE_PLLR) || ((SOURCE) == RCC_I2SAPBCLKSOURCE_EXT) || \
S                                      ((SOURCE) == RCC_I2SAPBCLKSOURCE_PLLSRC)) 
X#define IS_RCC_I2SCLK_SOURCE(SOURCE) (((SOURCE) == RCC_I2SAPBCLKSOURCE_PLLR) || ((SOURCE) == RCC_I2SAPBCLKSOURCE_EXT) ||                                       ((SOURCE) == RCC_I2SAPBCLKSOURCE_PLLSRC)) 
S/**
S  * @}
S  */
S#endif /* STM32F413_423xx */
N#endif /* STM32F410xx  || STM32F413_423xx */
N
N#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
X#if 0L || 0L || 0L
S/** @defgroup RCC_I2S_Clock_Source
S  * @{
S  */
S#define RCC_I2SCLKSource_PLLI2S             ((uint32_t)0x00)
S#define RCC_I2SCLKSource_Ext                ((uint32_t)RCC_DCKCFGR_I2S1SRC_0)
S#define RCC_I2SCLKSource_PLL                ((uint32_t)RCC_DCKCFGR_I2S1SRC_1)
S#define RCC_I2SCLKSource_HSI_HSE            ((uint32_t)RCC_DCKCFGR_I2S1SRC_0 | RCC_DCKCFGR_I2S1SRC_1)
S
S#define IS_RCC_I2SCLK_SOURCE(SOURCE) (((SOURCE) == RCC_I2SCLKSource_PLLI2S) || ((SOURCE) == RCC_I2SCLKSource_Ext) || \
S                                      ((SOURCE) == RCC_I2SCLKSource_PLL) || ((SOURCE) == RCC_I2SCLKSource_HSI_HSE))                                
X#define IS_RCC_I2SCLK_SOURCE(SOURCE) (((SOURCE) == RCC_I2SCLKSource_PLLI2S) || ((SOURCE) == RCC_I2SCLKSource_Ext) ||                                       ((SOURCE) == RCC_I2SCLKSource_PLL) || ((SOURCE) == RCC_I2SCLKSource_HSI_HSE))                                
S/**
S  * @}
S  */
S
S/** @defgroup RCC_I2S_APBBus
S  * @{
S  */
S#define RCC_I2SBus_APB1             ((uint8_t)0x00)
S#define RCC_I2SBus_APB2             ((uint8_t)0x01)
S#define IS_RCC_I2S_APBx(BUS) (((BUS) == RCC_I2SBus_APB1) || ((BUS) == RCC_I2SBus_APB2))                                
S/**
S  * @}
S  */
S#if defined(STM32F446xx)    
S/** @defgroup RCC_SAI_Clock_Source
S  * @{
S  */
S#define RCC_SAICLKSource_PLLSAI             ((uint32_t)0x00)
S#define RCC_SAICLKSource_PLLI2S             ((uint32_t)RCC_DCKCFGR_SAI1SRC_0)
S#define RCC_SAICLKSource_PLL                ((uint32_t)RCC_DCKCFGR_SAI1SRC_1)
S#define RCC_SAICLKSource_HSI_HSE            ((uint32_t)RCC_DCKCFGR_SAI1SRC_0 | RCC_DCKCFGR_SAI1SRC_1)
S
S#define IS_RCC_SAICLK_SOURCE(SOURCE) (((SOURCE) == RCC_SAICLKSource_PLLSAI) || ((SOURCE) == RCC_SAICLKSource_PLLI2S) || \
S                                      ((SOURCE) == RCC_SAICLKSource_PLL) || ((SOURCE) == RCC_SAICLKSource_HSI_HSE))                                
X#define IS_RCC_SAICLK_SOURCE(SOURCE) (((SOURCE) == RCC_SAICLKSource_PLLSAI) || ((SOURCE) == RCC_SAICLKSource_PLLI2S) ||                                       ((SOURCE) == RCC_SAICLKSource_PLL) || ((SOURCE) == RCC_SAICLKSource_HSI_HSE))                                
S/**
S  * @}
S  */    
S    
S/** @defgroup RCC_SAI_Instance
S  * @{
S  */
S#define RCC_SAIInstance_SAI1             ((uint8_t)0x00)
S#define RCC_SAIInstance_SAI2             ((uint8_t)0x01)
S#define IS_RCC_SAI_INSTANCE(BUS) (((BUS) == RCC_SAIInstance_SAI1) || ((BUS) == RCC_SAIInstance_SAI2))                                
S/**
S  * @}
S  */
S#endif /* STM32F446xx */
S#if defined(STM32F413_423xx)    
S
S/** @defgroup RCC_SAI_BlockA_Clock_Source
S  * @{
S  */
S#define RCC_SAIACLKSource_PLLI2S_R             ((uint32_t)0x00000000)
S#define RCC_SAIACLKSource_I2SCKIN              ((uint32_t)RCC_DCKCFGR_SAI1ASRC_0)
S#define RCC_SAIACLKSource_PLLR                 ((uint32_t)RCC_DCKCFGR_SAI1ASRC_1)
S#define RCC_SAIACLKSource_HSI_HSE              ((uint32_t)RCC_DCKCFGR_SAI1ASRC_0 | RCC_DCKCFGR_SAI1ASRC_1)
S
S#define IS_RCC_SAIACLK_SOURCE(SOURCE) (((SOURCE) == RCC_SAIACLKSource_PLLI2S_R) || ((SOURCE) == RCC_SAIACLKSource_I2SCKIN) || \
S                                      ((SOURCE) == RCC_SAIACLKSource_PLLR) || ((SOURCE) == RCC_SAIACLKSource_HSI_HSE))
X#define IS_RCC_SAIACLK_SOURCE(SOURCE) (((SOURCE) == RCC_SAIACLKSource_PLLI2S_R) || ((SOURCE) == RCC_SAIACLKSource_I2SCKIN) ||                                       ((SOURCE) == RCC_SAIACLKSource_PLLR) || ((SOURCE) == RCC_SAIACLKSource_HSI_HSE))
S/**
S  * @}
S  */
S
S/** @defgroup RCC_SAI_BlockB_Clock_Source
S  * @{
S  */
S#define RCC_SAIBCLKSource_PLLI2S_R             ((uint32_t)0x00000000)
S#define RCC_SAIBCLKSource_I2SCKIN              ((uint32_t)RCC_DCKCFGR_SAI1BSRC_0)
S#define RCC_SAIBCLKSource_PLLR                 ((uint32_t)RCC_DCKCFGR_SAI1BSRC_1)
S#define RCC_SAIBCLKSource_HSI_HSE              ((uint32_t)RCC_DCKCFGR_SAI1BSRC_0 | RCC_DCKCFGR_SAI1BSRC_1)
S
S#define IS_RCC_SAIBCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SAIBCLKSource_PLLI2S_R) || ((SOURCE) == RCC_SAIBCLKSource_I2SCKIN) || \
S                                      ((SOURCE) == RCC_SAIBCLKSource_PLLR) || ((SOURCE) == RCC_SAIBCLKSource_HSI_HSE))
X#define IS_RCC_SAIBCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SAIBCLKSource_PLLI2S_R) || ((SOURCE) == RCC_SAIBCLKSource_I2SCKIN) ||                                       ((SOURCE) == RCC_SAIBCLKSource_PLLR) || ((SOURCE) == RCC_SAIBCLKSource_HSI_HSE))
S/**
S  * @}
S  */
S#endif /* STM32F413_423xx */
N#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx */
N
N#if defined(STM32F40_41xxx) || defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F401xx) || defined(STM32F411xE) || defined(STM32F469_479xx)
X#if 1L || 0L || 0L || 0L || 0L || 0L
N/** @defgroup RCC_I2S_Clock_Source
N  * @{
N  */
N#define RCC_I2S2CLKSource_PLLI2S             ((uint8_t)0x00)
N#define RCC_I2S2CLKSource_Ext                ((uint8_t)0x01)
N
N#define IS_RCC_I2SCLK_SOURCE(SOURCE) (((SOURCE) == RCC_I2S2CLKSource_PLLI2S) || ((SOURCE) == RCC_I2S2CLKSource_Ext))                                
N/**
N  * @}
N  */ 
N
N/** @defgroup RCC_SAI_BlockA_Clock_Source
N  * @{
N  */
N#define RCC_SAIACLKSource_PLLSAI             ((uint32_t)0x00000000)
N#define RCC_SAIACLKSource_PLLI2S             ((uint32_t)0x00100000)
N#define RCC_SAIACLKSource_Ext                ((uint32_t)0x00200000)
N
N#define IS_RCC_SAIACLK_SOURCE(SOURCE) (((SOURCE) == RCC_SAIACLKSource_PLLI2S) ||\
N                                       ((SOURCE) == RCC_SAIACLKSource_PLLSAI) ||\
N                                       ((SOURCE) == RCC_SAIACLKSource_Ext))
X#define IS_RCC_SAIACLK_SOURCE(SOURCE) (((SOURCE) == RCC_SAIACLKSource_PLLI2S) ||                                       ((SOURCE) == RCC_SAIACLKSource_PLLSAI) ||                                       ((SOURCE) == RCC_SAIACLKSource_Ext))
N/**
N  * @}
N  */ 
N
N/** @defgroup RCC_SAI_BlockB_Clock_Source
N  * @{
N  */
N#define RCC_SAIBCLKSource_PLLSAI             ((uint32_t)0x00000000)
N#define RCC_SAIBCLKSource_PLLI2S             ((uint32_t)0x00400000)
N#define RCC_SAIBCLKSource_Ext                ((uint32_t)0x00800000)
N
N#define IS_RCC_SAIBCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SAIBCLKSource_PLLI2S) ||\
N                                       ((SOURCE) == RCC_SAIBCLKSource_PLLSAI) ||\
N                                       ((SOURCE) == RCC_SAIBCLKSource_Ext))
X#define IS_RCC_SAIBCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SAIBCLKSource_PLLI2S) ||                                       ((SOURCE) == RCC_SAIBCLKSource_PLLSAI) ||                                       ((SOURCE) == RCC_SAIBCLKSource_Ext))
N/**
N  * @}
N  */ 
N#endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F401xx || STM32F411xE || STM32F469_479xx */
N
N/** @defgroup RCC_TIM_PRescaler_Selection
N  * @{
N  */
N#define RCC_TIMPrescDesactivated             ((uint8_t)0x00)
N#define RCC_TIMPrescActivated                ((uint8_t)0x01)
N
N#define IS_RCC_TIMCLK_PRESCALER(VALUE) (((VALUE) == RCC_TIMPrescDesactivated) || ((VALUE) == RCC_TIMPrescActivated))
N/**
N  * @}
N  */
N
N#if defined(STM32F469_479xx)
X#if 0L
S/** @defgroup RCC_DSI_Clock_Source_Selection
S  * @{
S  */
S#define RCC_DSICLKSource_PHY                ((uint8_t)0x00)
S#define RCC_DSICLKSource_PLLR               ((uint8_t)0x01)
S#define IS_RCC_DSI_CLOCKSOURCE(CLKSOURCE)   (((CLKSOURCE) == RCC_DSICLKSource_PHY) || \
S                                             ((CLKSOURCE) == RCC_DSICLKSource_PLLR))
X#define IS_RCC_DSI_CLOCKSOURCE(CLKSOURCE)   (((CLKSOURCE) == RCC_DSICLKSource_PHY) ||                                              ((CLKSOURCE) == RCC_DSICLKSource_PLLR))
S/**
S  * @}
S  */
N#endif /* STM32F469_479xx */
N
N#if  defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
X#if  0L || 0L || 0L || 0L
S/** @defgroup RCC_SDIO_Clock_Source_Selection
S  * @{
S  */
S#define RCC_SDIOCLKSource_48MHZ              ((uint8_t)0x00)
S#define RCC_SDIOCLKSource_SYSCLK             ((uint8_t)0x01)
S#define IS_RCC_SDIO_CLOCKSOURCE(CLKSOURCE)   (((CLKSOURCE) == RCC_SDIOCLKSource_48MHZ) || \
S                                              ((CLKSOURCE) == RCC_SDIOCLKSource_SYSCLK))
X#define IS_RCC_SDIO_CLOCKSOURCE(CLKSOURCE)   (((CLKSOURCE) == RCC_SDIOCLKSource_48MHZ) ||                                               ((CLKSOURCE) == RCC_SDIOCLKSource_SYSCLK))
S/**
S  * @}
S  */
S
S
S/** @defgroup RCC_48MHZ_Clock_Source_Selection
S  * @{
S  */
S#if  defined(STM32F446xx) || defined(STM32F469_479xx)
S#define RCC_48MHZCLKSource_PLL                ((uint8_t)0x00)
S#define RCC_48MHZCLKSource_PLLSAI             ((uint8_t)0x01)
S#define IS_RCC_48MHZ_CLOCKSOURCE(CLKSOURCE)   (((CLKSOURCE) == RCC_48MHZCLKSource_PLL) || \
S                                               ((CLKSOURCE) == RCC_48MHZCLKSource_PLLSAI))
X#define IS_RCC_48MHZ_CLOCKSOURCE(CLKSOURCE)   (((CLKSOURCE) == RCC_48MHZCLKSource_PLL) ||                                                ((CLKSOURCE) == RCC_48MHZCLKSource_PLLSAI))
S#endif /* STM32F446xx || STM32F469_479xx */
S#if defined(STM32F412xG) || defined(STM32F413_423xx)
S#define RCC_CK48CLKSOURCE_PLLQ                ((uint8_t)0x00)
S#define RCC_CK48CLKSOURCE_PLLI2SQ             ((uint8_t)0x01) /* Only for STM32F412xG and STM32F413_423xx Devices */    
S#define IS_RCC_48MHZ_CLOCKSOURCE(CLKSOURCE)   (((CLKSOURCE) == RCC_CK48CLKSOURCE_PLLQ) || \
S                                               ((CLKSOURCE) == RCC_CK48CLKSOURCE_PLLI2SQ))
X#define IS_RCC_48MHZ_CLOCKSOURCE(CLKSOURCE)   (((CLKSOURCE) == RCC_CK48CLKSOURCE_PLLQ) ||                                                ((CLKSOURCE) == RCC_CK48CLKSOURCE_PLLI2SQ))
S#endif /* STM32F412xG || STM32F413_423xx */
S/**
S  * @}
S  */
N#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx || STM32F469_479xx */
N
N#if defined(STM32F446xx) 
X#if 0L 
S/** @defgroup RCC_SPDIFRX_Clock_Source_Selection
S  * @{
S  */
S#define RCC_SPDIFRXCLKSource_PLLR                 ((uint8_t)0x00)
S#define RCC_SPDIFRXCLKSource_PLLI2SP              ((uint8_t)0x01)
S#define IS_RCC_SPDIFRX_CLOCKSOURCE(CLKSOURCE)     (((CLKSOURCE) == RCC_SPDIFRXCLKSource_PLLR) || \
S                                                   ((CLKSOURCE) == RCC_SPDIFRXCLKSource_PLLI2SP))
X#define IS_RCC_SPDIFRX_CLOCKSOURCE(CLKSOURCE)     (((CLKSOURCE) == RCC_SPDIFRXCLKSource_PLLR) ||                                                    ((CLKSOURCE) == RCC_SPDIFRXCLKSource_PLLI2SP))
S/**
S  * @}
S  */
S
S/** @defgroup RCC_CEC_Clock_Source_Selection
S  * @{
S  */
S#define RCC_CECCLKSource_HSIDiv488            ((uint8_t)0x00)
S#define RCC_CECCLKSource_LSE                  ((uint8_t)0x01)
S#define IS_RCC_CEC_CLOCKSOURCE(CLKSOURCE)     (((CLKSOURCE) == RCC_CECCLKSource_HSIDiv488) || \
S                                               ((CLKSOURCE) == RCC_CECCLKSource_LSE))
X#define IS_RCC_CEC_CLOCKSOURCE(CLKSOURCE)     (((CLKSOURCE) == RCC_CECCLKSource_HSIDiv488) ||                                                ((CLKSOURCE) == RCC_CECCLKSource_LSE))
S/**
S  * @}
S  */
S
S/** @defgroup RCC_AHB1_ClockGating
S  * @{
S  */ 
S#define RCC_AHB1ClockGating_APB1Bridge         ((uint32_t)0x00000001)
S#define RCC_AHB1ClockGating_APB2Bridge         ((uint32_t)0x00000002)
S#define RCC_AHB1ClockGating_CM4DBG             ((uint32_t)0x00000004)
S#define RCC_AHB1ClockGating_SPARE              ((uint32_t)0x00000008)
S#define RCC_AHB1ClockGating_SRAM               ((uint32_t)0x00000010)
S#define RCC_AHB1ClockGating_FLITF              ((uint32_t)0x00000020)
S#define RCC_AHB1ClockGating_RCC                ((uint32_t)0x00000040)
S
S#define IS_RCC_AHB1_CLOCKGATING(PERIPH) ((((PERIPH) & 0xFFFFFF80) == 0x00) && ((PERIPH) != 0x00))
S
S/**
S  * @}
S  */
N#endif /* STM32F446xx */
N
N#if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
X#if 0L || 0L || 0L || 0L
S/** @defgroup RCC_FMPI2C1_Clock_Source
S  * @{
S  */
S#define RCC_FMPI2C1CLKSource_APB1            ((uint32_t)0x00)
S#define RCC_FMPI2C1CLKSource_SYSCLK          ((uint32_t)RCC_DCKCFGR2_FMPI2C1SEL_0)
S#define RCC_FMPI2C1CLKSource_HSI             ((uint32_t)RCC_DCKCFGR2_FMPI2C1SEL_1)
S    
S#define IS_RCC_FMPI2C1_CLOCKSOURCE(SOURCE) (((SOURCE) == RCC_FMPI2C1CLKSource_APB1) || ((SOURCE) == RCC_FMPI2C1CLKSource_SYSCLK) || \
S                                            ((SOURCE) == RCC_FMPI2C1CLKSource_HSI))
X#define IS_RCC_FMPI2C1_CLOCKSOURCE(SOURCE) (((SOURCE) == RCC_FMPI2C1CLKSource_APB1) || ((SOURCE) == RCC_FMPI2C1CLKSource_SYSCLK) ||                                             ((SOURCE) == RCC_FMPI2C1CLKSource_HSI))
S/**
S  * @}
S  */
N#endif /* STM32F410xx || STM32F412xG || STM32F413_423xx || STM32F446xx */
N
N#if defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 0L || 0L
S/** @defgroup RCC_DFSDM_Clock_Source
S * @{
S */
S#define RCC_DFSDMCLKSource_APB             ((uint8_t)0x00)
S#define RCC_DFSDMCLKSource_SYS             ((uint8_t)0x01)
S#define IS_RCC_DFSDMCLK_SOURCE(SOURCE) (((SOURCE) == RCC_DFSDMCLKSource_APB) || ((SOURCE) == RCC_DFSDMCLKSource_SYS))
S
S/* Legacy Defines */
S#define RCC_DFSDM1CLKSource_APB   RCC_DFSDMCLKSource_APB
S#define RCC_DFSDM1CLKSource_SYS   RCC_DFSDMCLKSource_SYS
S#define IS_RCC_DFSDM1CLK_SOURCE   IS_RCC_DFSDMCLK_SOURCE
S/**
S  * @}
S  */
S
S/** @defgroup RCC_DFSDM_Audio_Clock_Source  RCC DFSDM Audio Clock Source
S  * @{
S  */
S#define RCC_DFSDM1AUDIOCLKSOURCE_I2SAPB1          ((uint32_t)0x00000000)
S#define RCC_DFSDM1AUDIOCLKSOURCE_I2SAPB2          ((uint32_t)RCC_DCKCFGR_CKDFSDM1ASEL)
S#define IS_RCC_DFSDM1ACLK_SOURCE(SOURCE) (((SOURCE) == RCC_DFSDM1AUDIOCLKSOURCE_I2SAPB1) || ((SOURCE) == RCC_DFSDM1AUDIOCLKSOURCE_I2SAPB2))
S
S/* Legacy Defines */
S#define IS_RCC_DFSDMACLK_SOURCE      IS_RCC_DFSDM1ACLK_SOURCE
S/**
S  * @}
S  */
S
S#if defined(STM32F413_423xx)
S/** @defgroup RCC_DFSDM_Audio_Clock_Source  RCC DFSDM Audio Clock Source
S  * @{
S  */
S#define RCC_DFSDM2AUDIOCLKSOURCE_I2SAPB1          ((uint32_t)0x00000000)
S#define RCC_DFSDM2AUDIOCLKSOURCE_I2SAPB2          ((uint32_t)RCC_DCKCFGR_CKDFSDM2ASEL)
S#define IS_RCC_DFSDM2ACLK_SOURCE(SOURCE) (((SOURCE) == RCC_DFSDM2AUDIOCLKSOURCE_I2SAPB1) || ((SOURCE) == RCC_DFSDM2AUDIOCLKSOURCE_I2SAPB2))
S/**
S  * @}
S  */
S#endif /* STM32F413_423xx */
N#endif /* STM32F412xG || STM32F413_423xx */
N
N/** @defgroup RCC_AHB1_Peripherals 
N  * @{
N  */ 
N#define RCC_AHB1Periph_GPIOA             ((uint32_t)0x00000001)
N#define RCC_AHB1Periph_GPIOB             ((uint32_t)0x00000002)
N#define RCC_AHB1Periph_GPIOC             ((uint32_t)0x00000004)
N#define RCC_AHB1Periph_GPIOD             ((uint32_t)0x00000008)
N#define RCC_AHB1Periph_GPIOE             ((uint32_t)0x00000010)
N#define RCC_AHB1Periph_GPIOF             ((uint32_t)0x00000020)
N#define RCC_AHB1Periph_GPIOG             ((uint32_t)0x00000040)
N#define RCC_AHB1Periph_GPIOH             ((uint32_t)0x00000080)
N#define RCC_AHB1Periph_GPIOI             ((uint32_t)0x00000100) 
N#define RCC_AHB1Periph_GPIOJ             ((uint32_t)0x00000200)
N#define RCC_AHB1Periph_GPIOK             ((uint32_t)0x00000400)
N#define RCC_AHB1Periph_CRC               ((uint32_t)0x00001000)
N#define RCC_AHB1Periph_FLITF             ((uint32_t)0x00008000)
N#define RCC_AHB1Periph_SRAM1             ((uint32_t)0x00010000)
N#define RCC_AHB1Periph_SRAM2             ((uint32_t)0x00020000)
N#define RCC_AHB1Periph_BKPSRAM           ((uint32_t)0x00040000)
N#define RCC_AHB1Periph_SRAM3             ((uint32_t)0x00080000)
N#define RCC_AHB1Periph_CCMDATARAMEN      ((uint32_t)0x00100000)
N#define RCC_AHB1Periph_DMA1              ((uint32_t)0x00200000)
N#define RCC_AHB1Periph_DMA2              ((uint32_t)0x00400000)
N#define RCC_AHB1Periph_DMA2D             ((uint32_t)0x00800000)
N#define RCC_AHB1Periph_ETH_MAC           ((uint32_t)0x02000000)
N#define RCC_AHB1Periph_ETH_MAC_Tx        ((uint32_t)0x04000000)
N#define RCC_AHB1Periph_ETH_MAC_Rx        ((uint32_t)0x08000000)
N#define RCC_AHB1Periph_ETH_MAC_PTP       ((uint32_t)0x10000000)
N#define RCC_AHB1Periph_OTG_HS            ((uint32_t)0x20000000)
N#define RCC_AHB1Periph_OTG_HS_ULPI       ((uint32_t)0x40000000)
N#if defined(STM32F410xx)
X#if 0L
S#define RCC_AHB1Periph_RNG               ((uint32_t)0x80000000)
N#endif /* STM32F410xx */
N#define IS_RCC_AHB1_CLOCK_PERIPH(PERIPH) ((((PERIPH) & 0x010BE800) == 0x00) && ((PERIPH) != 0x00))
N#define IS_RCC_AHB1_RESET_PERIPH(PERIPH) ((((PERIPH) & 0x51FE800) == 0x00) && ((PERIPH) != 0x00))
N#define IS_RCC_AHB1_LPMODE_PERIPH(PERIPH) ((((PERIPH) & 0x01106800) == 0x00) && ((PERIPH) != 0x00))
N
N/**
N  * @}
N  */ 
N  
N/** @defgroup RCC_AHB2_Peripherals 
N  * @{
N  */  
N#define RCC_AHB2Periph_DCMI              ((uint32_t)0x00000001)
N#define RCC_AHB2Periph_CRYP              ((uint32_t)0x00000010)
N#define RCC_AHB2Periph_HASH              ((uint32_t)0x00000020)
N#if defined(STM32F40_41xxx) || defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F469_479xx)    
X#if 1L || 0L || 0L || 0L || 0L || 0L    
N#define RCC_AHB2Periph_RNG               ((uint32_t)0x00000040)
N#endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F469_479xx */
N#define RCC_AHB2Periph_OTG_FS            ((uint32_t)0x00000080)
N#define IS_RCC_AHB2_PERIPH(PERIPH) ((((PERIPH) & 0xFFFFFF0E) == 0x00) && ((PERIPH) != 0x00))
N/**
N  * @}
N  */ 
N  
N/** @defgroup RCC_AHB3_Peripherals 
N  * @{
N  */ 
N#if defined(STM32F40_41xxx)
X#if 1L
N#define RCC_AHB3Periph_FSMC                ((uint32_t)0x00000001)
N#define IS_RCC_AHB3_PERIPH(PERIPH) ((((PERIPH) & 0xFFFFFFFE) == 0x00) && ((PERIPH) != 0x00))
N#endif /* STM32F40_41xxx */
N
N#if defined(STM32F427_437xx) || defined(STM32F429_439xx)
X#if 0L || 0L
S#define RCC_AHB3Periph_FMC                 ((uint32_t)0x00000001)
S#define IS_RCC_AHB3_PERIPH(PERIPH) ((((PERIPH) & 0xFFFFFFFE) == 0x00) && ((PERIPH) != 0x00))
N#endif /* STM32F427_437xx ||  STM32F429_439xx */
N
N#if defined(STM32F446xx) || defined(STM32F469_479xx) 
X#if 0L || 0L 
S#define RCC_AHB3Periph_FMC                 ((uint32_t)0x00000001)
S#define RCC_AHB3Periph_QSPI                ((uint32_t)0x00000002)
S#define IS_RCC_AHB3_PERIPH(PERIPH) ((((PERIPH) & 0xFFFFFFFC) == 0x00) && ((PERIPH) != 0x00))
N#endif /* STM32F446xx ||  STM32F469_479xx */
N
N#if defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 0L || 0L
S#define RCC_AHB3Periph_FSMC                 ((uint32_t)0x00000001)
S#define RCC_AHB3Periph_QSPI                 ((uint32_t)0x00000002)
S#define IS_RCC_AHB3_PERIPH(PERIPH) ((((PERIPH) & 0xFFFFFFFC) == 0x00) && ((PERIPH) != 0x00))
N#endif /* STM32F412xG || STM32F413_423xx */
N
N/**
N  * @}
N  */ 
N  
N/** @defgroup RCC_APB1_Peripherals 
N  * @{
N  */ 
N#define RCC_APB1Periph_TIM2              ((uint32_t)0x00000001)
N#define RCC_APB1Periph_TIM3              ((uint32_t)0x00000002)
N#define RCC_APB1Periph_TIM4              ((uint32_t)0x00000004)
N#define RCC_APB1Periph_TIM5              ((uint32_t)0x00000008)
N#define RCC_APB1Periph_TIM6              ((uint32_t)0x00000010)
N#define RCC_APB1Periph_TIM7              ((uint32_t)0x00000020)
N#define RCC_APB1Periph_TIM12             ((uint32_t)0x00000040)
N#define RCC_APB1Periph_TIM13             ((uint32_t)0x00000080)
N#define RCC_APB1Periph_TIM14             ((uint32_t)0x00000100)
N#if defined(STM32F410xx) || defined(STM32F413_423xx)
X#if 0L || 0L
S#define RCC_APB1Periph_LPTIM1            ((uint32_t)0x00000200)
N#endif /* STM32F410xx || STM32F413_423xx */
N#define RCC_APB1Periph_WWDG              ((uint32_t)0x00000800)
N#define RCC_APB1Periph_SPI2              ((uint32_t)0x00004000)
N#define RCC_APB1Periph_SPI3              ((uint32_t)0x00008000)
N#if defined(STM32F446xx)
X#if 0L
S#define RCC_APB1Periph_SPDIFRX           ((uint32_t)0x00010000)
N#endif /* STM32F446xx */ 
N#define RCC_APB1Periph_USART2            ((uint32_t)0x00020000)
N#define RCC_APB1Periph_USART3            ((uint32_t)0x00040000)
N#define RCC_APB1Periph_UART4             ((uint32_t)0x00080000)
N#define RCC_APB1Periph_UART5             ((uint32_t)0x00100000)
N#define RCC_APB1Periph_I2C1              ((uint32_t)0x00200000)
N#define RCC_APB1Periph_I2C2              ((uint32_t)0x00400000)
N#define RCC_APB1Periph_I2C3              ((uint32_t)0x00800000)
N#if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
X#if 0L || 0L || 0L || 0L
S#define RCC_APB1Periph_FMPI2C1           ((uint32_t)0x01000000)
N#endif /* STM32F410xx || STM32F446xx || STM32F413_423xx*/ 
N#define RCC_APB1Periph_CAN1              ((uint32_t)0x02000000)
N#define RCC_APB1Periph_CAN2              ((uint32_t)0x04000000)
N#if defined(STM32F413_423xx)
X#if 0L
S#define RCC_APB1Periph_CAN3              ((uint32_t)0x08000000)
N#endif /* STM32F413_423xx */
N#if defined(STM32F446xx)
X#if 0L
S#define RCC_APB1Periph_CEC               ((uint32_t)0x08000000)
N#endif /* STM32F446xx */ 
N#define RCC_APB1Periph_PWR               ((uint32_t)0x10000000)
N#define RCC_APB1Periph_DAC               ((uint32_t)0x20000000)
N#define RCC_APB1Periph_UART7             ((uint32_t)0x40000000)
N#define RCC_APB1Periph_UART8             ((uint32_t)0x80000000)
N#define IS_RCC_APB1_PERIPH(PERIPH) ((((PERIPH) & 0x00003600) == 0x00) && ((PERIPH) != 0x00))
N/**
N  * @}
N  */ 
N  
N/** @defgroup RCC_APB2_Peripherals 
N  * @{
N  */ 
N#define RCC_APB2Periph_TIM1              ((uint32_t)0x00000001)
N#define RCC_APB2Periph_TIM8              ((uint32_t)0x00000002)
N#define RCC_APB2Periph_USART1            ((uint32_t)0x00000010)
N#define RCC_APB2Periph_USART6            ((uint32_t)0x00000020)
N#define RCC_APB2Periph_ADC               ((uint32_t)0x00000100)
N#define RCC_APB2Periph_ADC1              ((uint32_t)0x00000100)
N#define RCC_APB2Periph_ADC2              ((uint32_t)0x00000200)
N#define RCC_APB2Periph_ADC3              ((uint32_t)0x00000400)
N#define RCC_APB2Periph_SDIO              ((uint32_t)0x00000800)
N#define RCC_APB2Periph_SPI1              ((uint32_t)0x00001000)
N#define RCC_APB2Periph_SPI4              ((uint32_t)0x00002000)
N#define RCC_APB2Periph_SYSCFG            ((uint32_t)0x00004000)
N#define RCC_APB2Periph_EXTIT             ((uint32_t)0x00008000)
N#define RCC_APB2Periph_TIM9              ((uint32_t)0x00010000)
N#define RCC_APB2Periph_TIM10             ((uint32_t)0x00020000)
N#define RCC_APB2Periph_TIM11             ((uint32_t)0x00040000)
N#define RCC_APB2Periph_SPI5              ((uint32_t)0x00100000)
N#define RCC_APB2Periph_SPI6              ((uint32_t)0x00200000)
N#define RCC_APB2Periph_SAI1              ((uint32_t)0x00400000)
N#if defined(STM32F446xx) || defined(STM32F469_479xx)
X#if 0L || 0L
S#define RCC_APB2Periph_SAI2              ((uint32_t)0x00800000)
N#endif /* STM32F446xx || STM32F469_479xx */
N#define RCC_APB2Periph_LTDC              ((uint32_t)0x04000000)
N#if defined(STM32F469_479xx)
X#if 0L
S#define RCC_APB2Periph_DSI               ((uint32_t)0x08000000)
N#endif /* STM32F469_479xx */
N#if defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 0L || 0L
S#define RCC_APB2Periph_DFSDM1            ((uint32_t)0x01000000)
N#endif /* STM32F412xG || STM32F413_423xx */
N#if defined(STM32F413_423xx)
X#if 0L
S#define RCC_APB2Periph_DFSDM2            ((uint32_t)0x02000000)
S#define RCC_APB2Periph_UART9             ((uint32_t)0x02000040)
S#define RCC_APB2Periph_UART10            ((uint32_t)0x00000080)
N#endif /* STM32F413_423xx */
N
N/* Legacy Defines */
N#define RCC_APB2Periph_DFSDM              RCC_APB2Periph_DFSDM1
N
N#define IS_RCC_APB2_PERIPH(PERIPH) ((((PERIPH) & 0xF008000C) == 0x00) && ((PERIPH) != 0x00))
N#define IS_RCC_APB2_RESET_PERIPH(PERIPH) ((((PERIPH) & 0xF208860C) == 0x00) && ((PERIPH) != 0x00))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RCC_MCO1_Clock_Source_Prescaler
N  * @{
N  */
N#define RCC_MCO1Source_HSI               ((uint32_t)0x00000000)
N#define RCC_MCO1Source_LSE               ((uint32_t)0x00200000)
N#define RCC_MCO1Source_HSE               ((uint32_t)0x00400000)
N#define RCC_MCO1Source_PLLCLK            ((uint32_t)0x00600000)
N#define RCC_MCO1Div_1                    ((uint32_t)0x00000000)
N#define RCC_MCO1Div_2                    ((uint32_t)0x04000000)
N#define RCC_MCO1Div_3                    ((uint32_t)0x05000000)
N#define RCC_MCO1Div_4                    ((uint32_t)0x06000000)
N#define RCC_MCO1Div_5                    ((uint32_t)0x07000000)
N#define IS_RCC_MCO1SOURCE(SOURCE) (((SOURCE) == RCC_MCO1Source_HSI) || ((SOURCE) == RCC_MCO1Source_LSE) || \
N                                   ((SOURCE) == RCC_MCO1Source_HSE) || ((SOURCE) == RCC_MCO1Source_PLLCLK))
X#define IS_RCC_MCO1SOURCE(SOURCE) (((SOURCE) == RCC_MCO1Source_HSI) || ((SOURCE) == RCC_MCO1Source_LSE) ||                                    ((SOURCE) == RCC_MCO1Source_HSE) || ((SOURCE) == RCC_MCO1Source_PLLCLK))
N                                   
N#define IS_RCC_MCO1DIV(DIV) (((DIV) == RCC_MCO1Div_1) || ((DIV) == RCC_MCO1Div_2) || \
N                             ((DIV) == RCC_MCO1Div_3) || ((DIV) == RCC_MCO1Div_4) || \
N                             ((DIV) == RCC_MCO1Div_5)) 
X#define IS_RCC_MCO1DIV(DIV) (((DIV) == RCC_MCO1Div_1) || ((DIV) == RCC_MCO1Div_2) ||                              ((DIV) == RCC_MCO1Div_3) || ((DIV) == RCC_MCO1Div_4) ||                              ((DIV) == RCC_MCO1Div_5)) 
N/**
N  * @}
N  */ 
N  
N/** @defgroup RCC_MCO2_Clock_Source_Prescaler
N  * @{
N  */
N#define RCC_MCO2Source_SYSCLK            ((uint32_t)0x00000000)
N#define RCC_MCO2Source_PLLI2SCLK         ((uint32_t)0x40000000)
N#define RCC_MCO2Source_HSE               ((uint32_t)0x80000000)
N#define RCC_MCO2Source_PLLCLK            ((uint32_t)0xC0000000)
N#define RCC_MCO2Div_1                    ((uint32_t)0x00000000)
N#define RCC_MCO2Div_2                    ((uint32_t)0x20000000)
N#define RCC_MCO2Div_3                    ((uint32_t)0x28000000)
N#define RCC_MCO2Div_4                    ((uint32_t)0x30000000)
N#define RCC_MCO2Div_5                    ((uint32_t)0x38000000)
N#define IS_RCC_MCO2SOURCE(SOURCE) (((SOURCE) == RCC_MCO2Source_SYSCLK) || ((SOURCE) == RCC_MCO2Source_PLLI2SCLK)|| \
N                                   ((SOURCE) == RCC_MCO2Source_HSE) || ((SOURCE) == RCC_MCO2Source_PLLCLK))
X#define IS_RCC_MCO2SOURCE(SOURCE) (((SOURCE) == RCC_MCO2Source_SYSCLK) || ((SOURCE) == RCC_MCO2Source_PLLI2SCLK)||                                    ((SOURCE) == RCC_MCO2Source_HSE) || ((SOURCE) == RCC_MCO2Source_PLLCLK))
N                                   
N#define IS_RCC_MCO2DIV(DIV) (((DIV) == RCC_MCO2Div_1) || ((DIV) == RCC_MCO2Div_2) || \
N                             ((DIV) == RCC_MCO2Div_3) || ((DIV) == RCC_MCO2Div_4) || \
N                             ((DIV) == RCC_MCO2Div_5))                             
X#define IS_RCC_MCO2DIV(DIV) (((DIV) == RCC_MCO2Div_1) || ((DIV) == RCC_MCO2Div_2) ||                              ((DIV) == RCC_MCO2Div_3) || ((DIV) == RCC_MCO2Div_4) ||                              ((DIV) == RCC_MCO2Div_5))                             
N/**
N  * @}
N  */ 
N  
N/** @defgroup RCC_Flag 
N  * @{
N  */
N#define RCC_FLAG_HSIRDY                  ((uint8_t)0x21)
N#define RCC_FLAG_HSERDY                  ((uint8_t)0x31)
N#define RCC_FLAG_PLLRDY                  ((uint8_t)0x39)
N#define RCC_FLAG_PLLI2SRDY               ((uint8_t)0x3B)
N#define RCC_FLAG_PLLSAIRDY               ((uint8_t)0x3D)
N#define RCC_FLAG_LSERDY                  ((uint8_t)0x41)
N#define RCC_FLAG_LSIRDY                  ((uint8_t)0x61)
N#define RCC_FLAG_BORRST                  ((uint8_t)0x79)
N#define RCC_FLAG_PINRST                  ((uint8_t)0x7A)
N#define RCC_FLAG_PORRST                  ((uint8_t)0x7B)
N#define RCC_FLAG_SFTRST                  ((uint8_t)0x7C)
N#define RCC_FLAG_IWDGRST                 ((uint8_t)0x7D)
N#define RCC_FLAG_WWDGRST                 ((uint8_t)0x7E)
N#define RCC_FLAG_LPWRRST                 ((uint8_t)0x7F)
N
N#define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY)   || ((FLAG) == RCC_FLAG_HSERDY) || \
N                           ((FLAG) == RCC_FLAG_PLLRDY)   || ((FLAG) == RCC_FLAG_LSERDY) || \
N                           ((FLAG) == RCC_FLAG_LSIRDY)   || ((FLAG) == RCC_FLAG_BORRST) || \
N                           ((FLAG) == RCC_FLAG_PINRST)   || ((FLAG) == RCC_FLAG_PORRST) || \
N                           ((FLAG) == RCC_FLAG_SFTRST)   || ((FLAG) == RCC_FLAG_IWDGRST)|| \
N                           ((FLAG) == RCC_FLAG_WWDGRST)  || ((FLAG) == RCC_FLAG_LPWRRST)|| \
N                           ((FLAG) == RCC_FLAG_PLLI2SRDY)|| ((FLAG) == RCC_FLAG_PLLSAIRDY))
X#define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY)   || ((FLAG) == RCC_FLAG_HSERDY) ||                            ((FLAG) == RCC_FLAG_PLLRDY)   || ((FLAG) == RCC_FLAG_LSERDY) ||                            ((FLAG) == RCC_FLAG_LSIRDY)   || ((FLAG) == RCC_FLAG_BORRST) ||                            ((FLAG) == RCC_FLAG_PINRST)   || ((FLAG) == RCC_FLAG_PORRST) ||                            ((FLAG) == RCC_FLAG_SFTRST)   || ((FLAG) == RCC_FLAG_IWDGRST)||                            ((FLAG) == RCC_FLAG_WWDGRST)  || ((FLAG) == RCC_FLAG_LPWRRST)||                            ((FLAG) == RCC_FLAG_PLLI2SRDY)|| ((FLAG) == RCC_FLAG_PLLSAIRDY))
N
N#define IS_RCC_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x1F)
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/ 
N
N/* Function used to set the RCC clock configuration to the default reset state */
Nvoid        RCC_DeInit(void);
N
N/* Internal/external clocks, PLL, CSS and MCO configuration functions *********/
Nvoid        RCC_HSEConfig(uint8_t RCC_HSE);
NErrorStatus RCC_WaitForHSEStartUp(void);
Nvoid        RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue);
Nvoid        RCC_HSICmd(FunctionalState NewState);
Nvoid        RCC_LSEConfig(uint8_t RCC_LSE);
Nvoid        RCC_LSICmd(FunctionalState NewState);
N
Nvoid        RCC_PLLCmd(FunctionalState NewState);
N
N#if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
X#if 0L || 0L || 0L || 0L || 0L
Svoid        RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ, uint32_t PLLR);
N#endif /* STM32F410xx || STM32F412xG || STM32F413_423xx || STM32F446xx || STM32F469_479xx */
N
N#if defined(STM32F40_41xxx) || defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F401xx) || defined(STM32F411xE)
X#if 1L || 0L || 0L || 0L || 0L
Nvoid        RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ);
N#endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F401xx || STM32F411xE */
N
Nvoid        RCC_PLLI2SCmd(FunctionalState NewState);
N
N#if defined(STM32F40_41xxx) || defined(STM32F401xx)
X#if 1L || 0L
Nvoid        RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SR);
N#endif /* STM32F40_41xxx || STM32F401xx */
N#if defined(STM32F411xE)
X#if 0L
Svoid        RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SR, uint32_t PLLI2SM);
N#endif /* STM32F411xE */
N#if defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F469_479xx)
X#if 0L || 0L || 0L
Svoid        RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SQ, uint32_t PLLI2SR);
N#endif /* STM32F427_437xx || STM32F429_439xx || STM32F469_479xx */
N#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
X#if 0L || 0L || 0L
Svoid        RCC_PLLI2SConfig(uint32_t PLLI2SM, uint32_t PLLI2SN, uint32_t PLLI2SP, uint32_t PLLI2SQ, uint32_t PLLI2SR);
N#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx */
N
Nvoid        RCC_PLLSAICmd(FunctionalState NewState);
N#if defined(STM32F469_479xx)
X#if 0L
Svoid        RCC_PLLSAIConfig(uint32_t PLLSAIN, uint32_t PLLSAIP, uint32_t PLLSAIQ, uint32_t PLLSAIR);
N#endif /* STM32F469_479xx */
N#if defined(STM32F446xx)
X#if 0L
Svoid        RCC_PLLSAIConfig(uint32_t PLLSAIM, uint32_t PLLSAIN, uint32_t PLLSAIP, uint32_t PLLSAIQ);
N#endif /* STM32F446xx */
N#if defined(STM32F40_41xxx) || defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F401xx) || defined(STM32F411xE)
X#if 1L || 0L || 0L || 0L || 0L
Nvoid        RCC_PLLSAIConfig(uint32_t PLLSAIN, uint32_t PLLSAIQ, uint32_t PLLSAIR);
N#endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F401xx || STM32F411xE */
N
Nvoid        RCC_ClockSecuritySystemCmd(FunctionalState NewState);
Nvoid        RCC_MCO1Config(uint32_t RCC_MCO1Source, uint32_t RCC_MCO1Div);
Nvoid        RCC_MCO2Config(uint32_t RCC_MCO2Source, uint32_t RCC_MCO2Div);
N
N/* System, AHB and APB busses clocks configuration functions ******************/
Nvoid        RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource);
Nuint8_t     RCC_GetSYSCLKSource(void);
Nvoid        RCC_HCLKConfig(uint32_t RCC_SYSCLK);
Nvoid        RCC_PCLK1Config(uint32_t RCC_HCLK);
Nvoid        RCC_PCLK2Config(uint32_t RCC_HCLK);
Nvoid        RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks);
N
N/* Peripheral clocks configuration functions **********************************/
Nvoid        RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource);
Nvoid        RCC_RTCCLKCmd(FunctionalState NewState);
Nvoid        RCC_BackupResetCmd(FunctionalState NewState);
N
N#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)  
X#if 0L || 0L || 0L  
Svoid        RCC_I2SCLKConfig(uint32_t RCC_I2SAPBx, uint32_t RCC_I2SCLKSource);
S#if defined(STM32F446xx)
Svoid        RCC_SAICLKConfig(uint32_t RCC_SAIInstance, uint32_t RCC_SAICLKSource);
S#endif /* STM32F446xx */
S#if defined(STM32F413_423xx)
Svoid RCC_SAIBlockACLKConfig(uint32_t RCC_SAIBlockACLKSource);
Svoid RCC_SAIBlockBCLKConfig(uint32_t RCC_SAIBlockBCLKSource);
S#endif /* STM32F413_423xx */
N#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx */
N
N#if defined(STM32F40_41xxx) || defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F401xx) || defined(STM32F410xx) || defined(STM32F411xE) || defined(STM32F469_479xx)
X#if 1L || 0L || 0L || 0L || 0L || 0L || 0L
Nvoid        RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource);
N#endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F401xx || STM32F410xx || STM32F411xE || STM32F469_479xx */
N
N#if defined(STM32F40_41xxx) || defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F469_479xx)
X#if 1L || 0L || 0L || 0L
Nvoid        RCC_SAIBlockACLKConfig(uint32_t RCC_SAIBlockACLKSource);
Nvoid        RCC_SAIBlockBCLKConfig(uint32_t RCC_SAIBlockBCLKSource);
N#endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F469_479xx */
N
Nvoid        RCC_SAIPLLI2SClkDivConfig(uint32_t RCC_PLLI2SDivQ);
Nvoid        RCC_SAIPLLSAIClkDivConfig(uint32_t RCC_PLLSAIDivQ);
N
N#if defined(STM32F413_423xx)
X#if 0L
Svoid        RCC_SAIPLLI2SRClkDivConfig(uint32_t RCC_PLLI2SDivR);
Svoid        RCC_SAIPLLRClkDivConfig(uint32_t RCC_PLLDivR);
N#endif /* STM32F413_423xx */
N
Nvoid        RCC_LTDCCLKDivConfig(uint32_t RCC_PLLSAIDivR);
Nvoid        RCC_TIMCLKPresConfig(uint32_t RCC_TIMCLKPrescaler);
N
Nvoid        RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState);
Nvoid        RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState);
Nvoid        RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState);
Nvoid        RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
Nvoid        RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
N
Nvoid        RCC_AHB1PeriphResetCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState);
Nvoid        RCC_AHB2PeriphResetCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState);
Nvoid        RCC_AHB3PeriphResetCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState);
Nvoid        RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
Nvoid        RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
N
Nvoid        RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState);
Nvoid        RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState);
Nvoid        RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState);
Nvoid        RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
Nvoid        RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
N
N/* Features available only for STM32F410xx/STM32F411xx/STM32F446xx/STM32F469_479xx devices */
Nvoid        RCC_LSEModeConfig(uint8_t RCC_Mode);
N
N/* Features available only for STM32F469_479xx devices */
N#if defined(STM32F469_479xx)
X#if 0L
Svoid        RCC_DSIClockSourceConfig(uint8_t RCC_ClockSource);
N#endif /*  STM32F469_479xx */
N
N/* Features available only for STM32F412xG/STM32F413_423xx/STM32F446xx/STM32F469_479xx devices */
N#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) || defined(STM32F469_479xx)
X#if 0L || 0L || 0L || 0L
Svoid        RCC_48MHzClockSourceConfig(uint8_t RCC_ClockSource);
Svoid        RCC_SDIOClockSourceConfig(uint8_t RCC_ClockSource);
N#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx || STM32F469_479xx */
N
N/* Features available only for STM32F446xx devices */
N#if defined(STM32F446xx)
X#if 0L
Svoid        RCC_AHB1ClockGatingCmd(uint32_t RCC_AHB1ClockGating, FunctionalState NewState);
Svoid        RCC_SPDIFRXClockSourceConfig(uint8_t RCC_ClockSource);
Svoid        RCC_CECClockSourceConfig(uint8_t RCC_ClockSource);
N#endif /* STM32F446xx */
N
N/* Features available only for STM32F410xx/STM32F412xG/STM32F446xx devices */
N#if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
X#if 0L || 0L || 0L || 0L
Svoid        RCC_FMPI2C1ClockSourceConfig(uint32_t RCC_ClockSource);
N#endif /* STM32F410xx || STM32F412xG || STM32F413_423xx || STM32F446xx */
N
N/* Features available only for STM32F410xx devices */
N#if defined(STM32F410xx) || defined(STM32F413_423xx)
X#if 0L || 0L
Svoid        RCC_LPTIM1ClockSourceConfig(uint32_t RCC_ClockSource);
S#if defined(STM32F410xx)
Svoid        RCC_MCO1Cmd(FunctionalState NewState);
Svoid        RCC_MCO2Cmd(FunctionalState NewState);
S#endif /* STM32F410xx */
N#endif /* STM32F410xx || STM32F413_423xx */
N
N#if defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 0L || 0L
Svoid RCC_DFSDMCLKConfig(uint32_t RCC_DFSDMCLKSource);
Svoid RCC_DFSDM1ACLKConfig(uint32_t RCC_DFSDM1ACLKSource);
S#if defined(STM32F413_423xx)
Svoid RCC_DFSDM2ACLKConfig(uint32_t RCC_DFSDMACLKSource);
S#endif /* STM32F413_423xx */
S/* Legacy Defines */
S#define RCC_DFSDM1CLKConfig      RCC_DFSDMCLKConfig
N#endif /* STM32F412xG || STM32F413_423xx */
N/* Interrupts and flags management functions **********************************/
Nvoid        RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState);
NFlagStatus  RCC_GetFlagStatus(uint8_t RCC_FLAG);
Nvoid        RCC_ClearFlag(void);
NITStatus    RCC_GetITStatus(uint8_t RCC_IT);
Nvoid        RCC_ClearITPendingBit(uint8_t RCC_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_RCC_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 45 "..\..\Service\stm32f4xx_conf.h" 2
N#include "stm32f4xx_rtc.h"
L 1 "..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\stm32f4xx_rtc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_rtc.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    04-November-2016
N  * @brief   This file contains all the functions prototypes for the RTC firmware
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ****************************************************************************** 
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_RTC_H
N#define __STM32F4xx_RTC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
N
N/** @addtogroup STM32F4xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup RTC
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  RTC Init structures definition  
N  */ 
Ntypedef struct
N{
N  uint32_t RTC_HourFormat;   /*!< Specifies the RTC Hour Format.
N                             This parameter can be a value of @ref RTC_Hour_Formats */
N  
N  uint32_t RTC_AsynchPrediv; /*!< Specifies the RTC Asynchronous Predivider value.
N                             This parameter must be set to a value lower than 0x7F */
N  
N  uint32_t RTC_SynchPrediv;  /*!< Specifies the RTC Synchronous Predivider value.
N                             This parameter must be set to a value lower than 0x7FFF */
N}RTC_InitTypeDef;
N
N/** 
N  * @brief  RTC Time structure definition  
N  */
Ntypedef struct
N{
N  uint8_t RTC_Hours;    /*!< Specifies the RTC Time Hour.
N                        This parameter must be set to a value in the 0-12 range
N                        if the RTC_HourFormat_12 is selected or 0-23 range if
N                        the RTC_HourFormat_24 is selected. */
N
N  uint8_t RTC_Minutes;  /*!< Specifies the RTC Time Minutes.
N                        This parameter must be set to a value in the 0-59 range. */
N  
N  uint8_t RTC_Seconds;  /*!< Specifies the RTC Time Seconds.
N                        This parameter must be set to a value in the 0-59 range. */
N
N  uint8_t RTC_H12;      /*!< Specifies the RTC AM/PM Time.
N                        This parameter can be a value of @ref RTC_AM_PM_Definitions */
N}RTC_TimeTypeDef; 
N
N/** 
N  * @brief  RTC Date structure definition  
N  */
Ntypedef struct
N{
N  uint8_t RTC_WeekDay; /*!< Specifies the RTC Date WeekDay.
N                        This parameter can be a value of @ref RTC_WeekDay_Definitions */
N  
N  uint8_t RTC_Month;   /*!< Specifies the RTC Date Month (in BCD format).
N                        This parameter can be a value of @ref RTC_Month_Date_Definitions */
N
N  uint8_t RTC_Date;     /*!< Specifies the RTC Date.
N                        This parameter must be set to a value in the 1-31 range. */
N  
N  uint8_t RTC_Year;     /*!< Specifies the RTC Date Year.
N                        This parameter must be set to a value in the 0-99 range. */
N}RTC_DateTypeDef;
N
N/** 
N  * @brief  RTC Alarm structure definition  
N  */
Ntypedef struct
N{
N  RTC_TimeTypeDef RTC_AlarmTime;     /*!< Specifies the RTC Alarm Time members. */
N
N  uint32_t RTC_AlarmMask;            /*!< Specifies the RTC Alarm Masks.
N                                     This parameter can be a value of @ref RTC_AlarmMask_Definitions */
N
N  uint32_t RTC_AlarmDateWeekDaySel;  /*!< Specifies the RTC Alarm is on Date or WeekDay.
N                                     This parameter can be a value of @ref RTC_AlarmDateWeekDay_Definitions */
N  
N  uint8_t RTC_AlarmDateWeekDay;      /*!< Specifies the RTC Alarm Date/WeekDay.
N                                     If the Alarm Date is selected, this parameter
N                                     must be set to a value in the 1-31 range.
N                                     If the Alarm WeekDay is selected, this 
N                                     parameter can be a value of @ref RTC_WeekDay_Definitions */
N}RTC_AlarmTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup RTC_Exported_Constants
N  * @{
N  */ 
N
N
N/** @defgroup RTC_Hour_Formats 
N  * @{
N  */ 
N#define RTC_HourFormat_24              ((uint32_t)0x00000000)
N#define RTC_HourFormat_12              ((uint32_t)0x00000040)
N#define IS_RTC_HOUR_FORMAT(FORMAT)     (((FORMAT) == RTC_HourFormat_12) || \
N                                        ((FORMAT) == RTC_HourFormat_24))
X#define IS_RTC_HOUR_FORMAT(FORMAT)     (((FORMAT) == RTC_HourFormat_12) ||                                         ((FORMAT) == RTC_HourFormat_24))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Asynchronous_Predivider 
N  * @{
N  */ 
N#define IS_RTC_ASYNCH_PREDIV(PREDIV)   ((PREDIV) <= 0x7F)
N 
N/**
N  * @}
N  */ 
N
N
N/** @defgroup RTC_Synchronous_Predivider 
N  * @{
N  */ 
N#define IS_RTC_SYNCH_PREDIV(PREDIV)    ((PREDIV) <= 0x7FFF)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Time_Definitions 
N  * @{
N  */ 
N#define IS_RTC_HOUR12(HOUR)            (((HOUR) > 0) && ((HOUR) <= 12))
N#define IS_RTC_HOUR24(HOUR)            ((HOUR) <= 23)
N#define IS_RTC_MINUTES(MINUTES)        ((MINUTES) <= 59)
N#define IS_RTC_SECONDS(SECONDS)        ((SECONDS) <= 59)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_AM_PM_Definitions 
N  * @{
N  */ 
N#define RTC_H12_AM                     ((uint8_t)0x00)
N#define RTC_H12_PM                     ((uint8_t)0x40)
N#define IS_RTC_H12(PM) (((PM) == RTC_H12_AM) || ((PM) == RTC_H12_PM))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Year_Date_Definitions 
N  * @{
N  */ 
N#define IS_RTC_YEAR(YEAR)              ((YEAR) <= 99)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Month_Date_Definitions 
N  * @{
N  */ 
N
N/* Coded in BCD format */
N#define RTC_Month_January              ((uint8_t)0x01)
N#define RTC_Month_February             ((uint8_t)0x02)
N#define RTC_Month_March                ((uint8_t)0x03)
N#define RTC_Month_April                ((uint8_t)0x04)
N#define RTC_Month_May                  ((uint8_t)0x05)
N#define RTC_Month_June                 ((uint8_t)0x06)
N#define RTC_Month_July                 ((uint8_t)0x07)
N#define RTC_Month_August               ((uint8_t)0x08)
N#define RTC_Month_September            ((uint8_t)0x09)
N#define RTC_Month_October              ((uint8_t)0x10)
N#define RTC_Month_November             ((uint8_t)0x11)
N#define RTC_Month_December             ((uint8_t)0x12)
N#define IS_RTC_MONTH(MONTH)            (((MONTH) >= 1) && ((MONTH) <= 12))
N#define IS_RTC_DATE(DATE)              (((DATE) >= 1) && ((DATE) <= 31))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_WeekDay_Definitions 
N  * @{
N  */ 
N  
N#define RTC_Weekday_Monday             ((uint8_t)0x01)
N#define RTC_Weekday_Tuesday            ((uint8_t)0x02)
N#define RTC_Weekday_Wednesday          ((uint8_t)0x03)
N#define RTC_Weekday_Thursday           ((uint8_t)0x04)
N#define RTC_Weekday_Friday             ((uint8_t)0x05)
N#define RTC_Weekday_Saturday           ((uint8_t)0x06)
N#define RTC_Weekday_Sunday             ((uint8_t)0x07)
N#define IS_RTC_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_Weekday_Monday) || \
N                                 ((WEEKDAY) == RTC_Weekday_Tuesday) || \
N                                 ((WEEKDAY) == RTC_Weekday_Wednesday) || \
N                                 ((WEEKDAY) == RTC_Weekday_Thursday) || \
N                                 ((WEEKDAY) == RTC_Weekday_Friday) || \
N                                 ((WEEKDAY) == RTC_Weekday_Saturday) || \
N                                 ((WEEKDAY) == RTC_Weekday_Sunday))
X#define IS_RTC_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_Weekday_Monday) ||                                  ((WEEKDAY) == RTC_Weekday_Tuesday) ||                                  ((WEEKDAY) == RTC_Weekday_Wednesday) ||                                  ((WEEKDAY) == RTC_Weekday_Thursday) ||                                  ((WEEKDAY) == RTC_Weekday_Friday) ||                                  ((WEEKDAY) == RTC_Weekday_Saturday) ||                                  ((WEEKDAY) == RTC_Weekday_Sunday))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup RTC_Alarm_Definitions
N  * @{
N  */ 
N#define IS_RTC_ALARM_DATE_WEEKDAY_DATE(DATE) (((DATE) > 0) && ((DATE) <= 31))
N#define IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_Weekday_Monday) || \
N                                                    ((WEEKDAY) == RTC_Weekday_Tuesday) || \
N                                                    ((WEEKDAY) == RTC_Weekday_Wednesday) || \
N                                                    ((WEEKDAY) == RTC_Weekday_Thursday) || \
N                                                    ((WEEKDAY) == RTC_Weekday_Friday) || \
N                                                    ((WEEKDAY) == RTC_Weekday_Saturday) || \
N                                                    ((WEEKDAY) == RTC_Weekday_Sunday))
X#define IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_Weekday_Monday) ||                                                     ((WEEKDAY) == RTC_Weekday_Tuesday) ||                                                     ((WEEKDAY) == RTC_Weekday_Wednesday) ||                                                     ((WEEKDAY) == RTC_Weekday_Thursday) ||                                                     ((WEEKDAY) == RTC_Weekday_Friday) ||                                                     ((WEEKDAY) == RTC_Weekday_Saturday) ||                                                     ((WEEKDAY) == RTC_Weekday_Sunday))
N
N/**
N  * @}
N  */ 
N
N
N/** @defgroup RTC_AlarmDateWeekDay_Definitions 
N  * @{
N  */ 
N#define RTC_AlarmDateWeekDaySel_Date      ((uint32_t)0x00000000)
N#define RTC_AlarmDateWeekDaySel_WeekDay   ((uint32_t)0x40000000)
N
N#define IS_RTC_ALARM_DATE_WEEKDAY_SEL(SEL) (((SEL) == RTC_AlarmDateWeekDaySel_Date) || \
N                                            ((SEL) == RTC_AlarmDateWeekDaySel_WeekDay))
X#define IS_RTC_ALARM_DATE_WEEKDAY_SEL(SEL) (((SEL) == RTC_AlarmDateWeekDaySel_Date) ||                                             ((SEL) == RTC_AlarmDateWeekDaySel_WeekDay))
N
N/**
N  * @}
N  */ 
N
N
N/** @defgroup RTC_AlarmMask_Definitions 
N  * @{
N  */ 
N#define RTC_AlarmMask_None                ((uint32_t)0x00000000)
N#define RTC_AlarmMask_DateWeekDay         ((uint32_t)0x80000000)
N#define RTC_AlarmMask_Hours               ((uint32_t)0x00800000)
N#define RTC_AlarmMask_Minutes             ((uint32_t)0x00008000)
N#define RTC_AlarmMask_Seconds             ((uint32_t)0x00000080)
N#define RTC_AlarmMask_All                 ((uint32_t)0x80808080)
N#define IS_ALARM_MASK(MASK)  (((MASK) & 0x7F7F7F7F) == (uint32_t)RESET)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Alarms_Definitions 
N  * @{
N  */ 
N#define RTC_Alarm_A                       ((uint32_t)0x00000100)
N#define RTC_Alarm_B                       ((uint32_t)0x00000200)
N#define IS_RTC_ALARM(ALARM)     (((ALARM) == RTC_Alarm_A) || ((ALARM) == RTC_Alarm_B))
N#define IS_RTC_CMD_ALARM(ALARM) (((ALARM) & (RTC_Alarm_A | RTC_Alarm_B)) != (uint32_t)RESET)
N
N/**
N  * @}
N  */ 
N
N  /** @defgroup RTC_Alarm_Sub_Seconds_Masks_Definitions
N  * @{
N  */ 
N#define RTC_AlarmSubSecondMask_All         ((uint32_t)0x00000000) /*!< All Alarm SS fields are masked. 
N                                                                       There is no comparison on sub seconds 
N                                                                       for Alarm */
N#define RTC_AlarmSubSecondMask_SS14_1      ((uint32_t)0x01000000) /*!< SS[14:1] are don't care in Alarm 
N                                                                       comparison. Only SS[0] is compared. */
N#define RTC_AlarmSubSecondMask_SS14_2      ((uint32_t)0x02000000) /*!< SS[14:2] are don't care in Alarm 
N                                                                       comparison. Only SS[1:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_3      ((uint32_t)0x03000000) /*!< SS[14:3] are don't care in Alarm 
N                                                                       comparison. Only SS[2:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_4      ((uint32_t)0x04000000) /*!< SS[14:4] are don't care in Alarm 
N                                                                       comparison. Only SS[3:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_5      ((uint32_t)0x05000000) /*!< SS[14:5] are don't care in Alarm 
N                                                                       comparison. Only SS[4:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_6      ((uint32_t)0x06000000) /*!< SS[14:6] are don't care in Alarm 
N                                                                       comparison. Only SS[5:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_7      ((uint32_t)0x07000000) /*!< SS[14:7] are don't care in Alarm 
N                                                                       comparison. Only SS[6:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_8      ((uint32_t)0x08000000) /*!< SS[14:8] are don't care in Alarm 
N                                                                       comparison. Only SS[7:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_9      ((uint32_t)0x09000000) /*!< SS[14:9] are don't care in Alarm 
N                                                                       comparison. Only SS[8:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_10     ((uint32_t)0x0A000000) /*!< SS[14:10] are don't care in Alarm 
N                                                                       comparison. Only SS[9:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_11     ((uint32_t)0x0B000000) /*!< SS[14:11] are don't care in Alarm 
N                                                                       comparison. Only SS[10:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_12     ((uint32_t)0x0C000000) /*!< SS[14:12] are don't care in Alarm 
N                                                                       comparison.Only SS[11:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_13     ((uint32_t)0x0D000000) /*!< SS[14:13] are don't care in Alarm 
N                                                                       comparison. Only SS[12:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14        ((uint32_t)0x0E000000) /*!< SS[14] is don't care in Alarm 
N                                                                       comparison.Only SS[13:0] are compared */
N#define RTC_AlarmSubSecondMask_None        ((uint32_t)0x0F000000) /*!< SS[14:0] are compared and must match 
N                                                                       to activate alarm. */
N#define IS_RTC_ALARM_SUB_SECOND_MASK(MASK)   (((MASK) == RTC_AlarmSubSecondMask_All) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_1) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_2) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_3) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_4) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_5) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_6) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_7) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_8) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_9) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_10) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_11) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_12) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_13) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_None))
X#define IS_RTC_ALARM_SUB_SECOND_MASK(MASK)   (((MASK) == RTC_AlarmSubSecondMask_All) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_1) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_2) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_3) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_4) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_5) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_6) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_7) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_8) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_9) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_10) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_11) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_12) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_13) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14) ||                                               ((MASK) == RTC_AlarmSubSecondMask_None))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Alarm_Sub_Seconds_Value
N  * @{
N  */ 
N
N#define IS_RTC_ALARM_SUB_SECOND_VALUE(VALUE) ((VALUE) <= 0x00007FFF)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Wakeup_Timer_Definitions 
N  * @{
N  */ 
N#define RTC_WakeUpClock_RTCCLK_Div16        ((uint32_t)0x00000000)
N#define RTC_WakeUpClock_RTCCLK_Div8         ((uint32_t)0x00000001)
N#define RTC_WakeUpClock_RTCCLK_Div4         ((uint32_t)0x00000002)
N#define RTC_WakeUpClock_RTCCLK_Div2         ((uint32_t)0x00000003)
N#define RTC_WakeUpClock_CK_SPRE_16bits      ((uint32_t)0x00000004)
N#define RTC_WakeUpClock_CK_SPRE_17bits      ((uint32_t)0x00000006)
N#define IS_RTC_WAKEUP_CLOCK(CLOCK) (((CLOCK) == RTC_WakeUpClock_RTCCLK_Div16) || \
N                                    ((CLOCK) == RTC_WakeUpClock_RTCCLK_Div8) || \
N                                    ((CLOCK) == RTC_WakeUpClock_RTCCLK_Div4) || \
N                                    ((CLOCK) == RTC_WakeUpClock_RTCCLK_Div2) || \
N                                    ((CLOCK) == RTC_WakeUpClock_CK_SPRE_16bits) || \
N                                    ((CLOCK) == RTC_WakeUpClock_CK_SPRE_17bits))
X#define IS_RTC_WAKEUP_CLOCK(CLOCK) (((CLOCK) == RTC_WakeUpClock_RTCCLK_Div16) ||                                     ((CLOCK) == RTC_WakeUpClock_RTCCLK_Div8) ||                                     ((CLOCK) == RTC_WakeUpClock_RTCCLK_Div4) ||                                     ((CLOCK) == RTC_WakeUpClock_RTCCLK_Div2) ||                                     ((CLOCK) == RTC_WakeUpClock_CK_SPRE_16bits) ||                                     ((CLOCK) == RTC_WakeUpClock_CK_SPRE_17bits))
N#define IS_RTC_WAKEUP_COUNTER(COUNTER)  ((COUNTER) <= 0xFFFF)
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Time_Stamp_Edges_definitions 
N  * @{
N  */ 
N#define RTC_TimeStampEdge_Rising          ((uint32_t)0x00000000)
N#define RTC_TimeStampEdge_Falling         ((uint32_t)0x00000008)
N#define IS_RTC_TIMESTAMP_EDGE(EDGE) (((EDGE) == RTC_TimeStampEdge_Rising) || \
N                                     ((EDGE) == RTC_TimeStampEdge_Falling))
X#define IS_RTC_TIMESTAMP_EDGE(EDGE) (((EDGE) == RTC_TimeStampEdge_Rising) ||                                      ((EDGE) == RTC_TimeStampEdge_Falling))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Output_selection_Definitions 
N  * @{
N  */ 
N#define RTC_Output_Disable             ((uint32_t)0x00000000)
N#define RTC_Output_AlarmA              ((uint32_t)0x00200000)
N#define RTC_Output_AlarmB              ((uint32_t)0x00400000)
N#define RTC_Output_WakeUp              ((uint32_t)0x00600000)
N 
N#define IS_RTC_OUTPUT(OUTPUT) (((OUTPUT) == RTC_Output_Disable) || \
N                               ((OUTPUT) == RTC_Output_AlarmA) || \
N                               ((OUTPUT) == RTC_Output_AlarmB) || \
N                               ((OUTPUT) == RTC_Output_WakeUp))
X#define IS_RTC_OUTPUT(OUTPUT) (((OUTPUT) == RTC_Output_Disable) ||                                ((OUTPUT) == RTC_Output_AlarmA) ||                                ((OUTPUT) == RTC_Output_AlarmB) ||                                ((OUTPUT) == RTC_Output_WakeUp))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Output_Polarity_Definitions 
N  * @{
N  */ 
N#define RTC_OutputPolarity_High           ((uint32_t)0x00000000)
N#define RTC_OutputPolarity_Low            ((uint32_t)0x00100000)
N#define IS_RTC_OUTPUT_POL(POL) (((POL) == RTC_OutputPolarity_High) || \
N                                ((POL) == RTC_OutputPolarity_Low))
X#define IS_RTC_OUTPUT_POL(POL) (((POL) == RTC_OutputPolarity_High) ||                                 ((POL) == RTC_OutputPolarity_Low))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup RTC_Digital_Calibration_Definitions 
N  * @{
N  */ 
N#define RTC_CalibSign_Positive            ((uint32_t)0x00000000) 
N#define RTC_CalibSign_Negative            ((uint32_t)0x00000080)
N#define IS_RTC_CALIB_SIGN(SIGN) (((SIGN) == RTC_CalibSign_Positive) || \
N                                 ((SIGN) == RTC_CalibSign_Negative))
X#define IS_RTC_CALIB_SIGN(SIGN) (((SIGN) == RTC_CalibSign_Positive) ||                                  ((SIGN) == RTC_CalibSign_Negative))
N#define IS_RTC_CALIB_VALUE(VALUE) ((VALUE) < 0x20)
N
N/**
N  * @}
N  */ 
N
N /** @defgroup RTC_Calib_Output_selection_Definitions 
N  * @{
N  */ 
N#define RTC_CalibOutput_512Hz            ((uint32_t)0x00000000) 
N#define RTC_CalibOutput_1Hz              ((uint32_t)0x00080000)
N#define IS_RTC_CALIB_OUTPUT(OUTPUT)  (((OUTPUT) == RTC_CalibOutput_512Hz) || \
N                                      ((OUTPUT) == RTC_CalibOutput_1Hz))
X#define IS_RTC_CALIB_OUTPUT(OUTPUT)  (((OUTPUT) == RTC_CalibOutput_512Hz) ||                                       ((OUTPUT) == RTC_CalibOutput_1Hz))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Smooth_calib_period_Definitions 
N  * @{
N  */ 
N#define RTC_SmoothCalibPeriod_32sec   ((uint32_t)0x00000000) /*!<  if RTCCLK = 32768 Hz, Smooth calibation
N                                                             period is 32s,  else 2exp20 RTCCLK seconds */
N#define RTC_SmoothCalibPeriod_16sec   ((uint32_t)0x00002000) /*!<  if RTCCLK = 32768 Hz, Smooth calibration 
N                                                             period is 16s, else 2exp19 RTCCLK seconds */
N#define RTC_SmoothCalibPeriod_8sec    ((uint32_t)0x00004000) /*!<  if RTCCLK = 32768 Hz, Smooth calibation 
N                                                             period is 8s, else 2exp18 RTCCLK seconds */
N#define IS_RTC_SMOOTH_CALIB_PERIOD(PERIOD) (((PERIOD) == RTC_SmoothCalibPeriod_32sec) || \
N                                             ((PERIOD) == RTC_SmoothCalibPeriod_16sec) || \
N                                             ((PERIOD) == RTC_SmoothCalibPeriod_8sec))
X#define IS_RTC_SMOOTH_CALIB_PERIOD(PERIOD) (((PERIOD) == RTC_SmoothCalibPeriod_32sec) ||                                              ((PERIOD) == RTC_SmoothCalibPeriod_16sec) ||                                              ((PERIOD) == RTC_SmoothCalibPeriod_8sec))
N                                          
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Smooth_calib_Plus_pulses_Definitions 
N  * @{
N  */ 
N#define RTC_SmoothCalibPlusPulses_Set    ((uint32_t)0x00008000) /*!<  The number of RTCCLK pulses added  
N                                                                during a X -second window = Y - CALM[8:0]. 
N                                                                 with Y = 512, 256, 128 when X = 32, 16, 8 */
N#define RTC_SmoothCalibPlusPulses_Reset  ((uint32_t)0x00000000) /*!<  The number of RTCCLK pulses subbstited
N                                                                 during a 32-second window =   CALM[8:0]. */
N#define IS_RTC_SMOOTH_CALIB_PLUS(PLUS) (((PLUS) == RTC_SmoothCalibPlusPulses_Set) || \
N                                         ((PLUS) == RTC_SmoothCalibPlusPulses_Reset))
X#define IS_RTC_SMOOTH_CALIB_PLUS(PLUS) (((PLUS) == RTC_SmoothCalibPlusPulses_Set) ||                                          ((PLUS) == RTC_SmoothCalibPlusPulses_Reset))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Smooth_calib_Minus_pulses_Definitions 
N  * @{
N  */ 
N#define  IS_RTC_SMOOTH_CALIB_MINUS(VALUE) ((VALUE) <= 0x000001FF)
N
N/**
N  * @}
N  */
N
N/** @defgroup RTC_DayLightSaving_Definitions 
N  * @{
N  */ 
N#define RTC_DayLightSaving_SUB1H   ((uint32_t)0x00020000)
N#define RTC_DayLightSaving_ADD1H   ((uint32_t)0x00010000)
N#define IS_RTC_DAYLIGHT_SAVING(SAVE) (((SAVE) == RTC_DayLightSaving_SUB1H) || \
N                                      ((SAVE) == RTC_DayLightSaving_ADD1H))
X#define IS_RTC_DAYLIGHT_SAVING(SAVE) (((SAVE) == RTC_DayLightSaving_SUB1H) ||                                       ((SAVE) == RTC_DayLightSaving_ADD1H))
N
N#define RTC_StoreOperation_Reset        ((uint32_t)0x00000000)
N#define RTC_StoreOperation_Set          ((uint32_t)0x00040000)
N#define IS_RTC_STORE_OPERATION(OPERATION) (((OPERATION) == RTC_StoreOperation_Reset) || \
N                                           ((OPERATION) == RTC_StoreOperation_Set))
X#define IS_RTC_STORE_OPERATION(OPERATION) (((OPERATION) == RTC_StoreOperation_Reset) ||                                            ((OPERATION) == RTC_StoreOperation_Set))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Tamper_Trigger_Definitions 
N  * @{
N  */ 
N#define RTC_TamperTrigger_RisingEdge            ((uint32_t)0x00000000)
N#define RTC_TamperTrigger_FallingEdge           ((uint32_t)0x00000001)
N#define RTC_TamperTrigger_LowLevel              ((uint32_t)0x00000000)
N#define RTC_TamperTrigger_HighLevel             ((uint32_t)0x00000001)
N#define IS_RTC_TAMPER_TRIGGER(TRIGGER) (((TRIGGER) == RTC_TamperTrigger_RisingEdge) || \
N                                        ((TRIGGER) == RTC_TamperTrigger_FallingEdge) || \
N                                        ((TRIGGER) == RTC_TamperTrigger_LowLevel) || \
N                                        ((TRIGGER) == RTC_TamperTrigger_HighLevel)) 
X#define IS_RTC_TAMPER_TRIGGER(TRIGGER) (((TRIGGER) == RTC_TamperTrigger_RisingEdge) ||                                         ((TRIGGER) == RTC_TamperTrigger_FallingEdge) ||                                         ((TRIGGER) == RTC_TamperTrigger_LowLevel) ||                                         ((TRIGGER) == RTC_TamperTrigger_HighLevel)) 
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Tamper_Filter_Definitions 
N  * @{
N  */ 
N#define RTC_TamperFilter_Disable   ((uint32_t)0x00000000) /*!< Tamper filter is disabled */
N
N#define RTC_TamperFilter_2Sample   ((uint32_t)0x00000800) /*!< Tamper is activated after 2 
N                                                          consecutive samples at the active level */
N#define RTC_TamperFilter_4Sample   ((uint32_t)0x00001000) /*!< Tamper is activated after 4 
N                                                          consecutive samples at the active level */
N#define RTC_TamperFilter_8Sample   ((uint32_t)0x00001800) /*!< Tamper is activated after 8 
N                                                          consecutive samples at the active level. */
N#define IS_RTC_TAMPER_FILTER(FILTER) (((FILTER) == RTC_TamperFilter_Disable) || \
N                                      ((FILTER) == RTC_TamperFilter_2Sample) || \
N                                      ((FILTER) == RTC_TamperFilter_4Sample) || \
N                                      ((FILTER) == RTC_TamperFilter_8Sample))
X#define IS_RTC_TAMPER_FILTER(FILTER) (((FILTER) == RTC_TamperFilter_Disable) ||                                       ((FILTER) == RTC_TamperFilter_2Sample) ||                                       ((FILTER) == RTC_TamperFilter_4Sample) ||                                       ((FILTER) == RTC_TamperFilter_8Sample))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Tamper_Sampling_Frequencies_Definitions 
N  * @{
N  */ 
N#define RTC_TamperSamplingFreq_RTCCLK_Div32768  ((uint32_t)0x00000000) /*!< Each of the tamper inputs are sampled
N                                                                           with a frequency =  RTCCLK / 32768 */
N#define RTC_TamperSamplingFreq_RTCCLK_Div16384  ((uint32_t)0x000000100) /*!< Each of the tamper inputs are sampled
N                                                                            with a frequency =  RTCCLK / 16384 */
N#define RTC_TamperSamplingFreq_RTCCLK_Div8192   ((uint32_t)0x00000200) /*!< Each of the tamper inputs are sampled
N                                                                           with a frequency =  RTCCLK / 8192  */
N#define RTC_TamperSamplingFreq_RTCCLK_Div4096   ((uint32_t)0x00000300) /*!< Each of the tamper inputs are sampled
N                                                                           with a frequency =  RTCCLK / 4096  */
N#define RTC_TamperSamplingFreq_RTCCLK_Div2048   ((uint32_t)0x00000400) /*!< Each of the tamper inputs are sampled
N                                                                           with a frequency =  RTCCLK / 2048  */
N#define RTC_TamperSamplingFreq_RTCCLK_Div1024   ((uint32_t)0x00000500) /*!< Each of the tamper inputs are sampled
N                                                                           with a frequency =  RTCCLK / 1024  */
N#define RTC_TamperSamplingFreq_RTCCLK_Div512    ((uint32_t)0x00000600) /*!< Each of the tamper inputs are sampled
N                                                                           with a frequency =  RTCCLK / 512   */
N#define RTC_TamperSamplingFreq_RTCCLK_Div256    ((uint32_t)0x00000700) /*!< Each of the tamper inputs are sampled
N                                                                           with a frequency =  RTCCLK / 256   */
N#define IS_RTC_TAMPER_SAMPLING_FREQ(FREQ) (((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div32768) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div16384) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div8192) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div4096) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div2048) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div1024) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div512) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div256))
X#define IS_RTC_TAMPER_SAMPLING_FREQ(FREQ) (((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div32768) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div16384) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div8192) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div4096) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div2048) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div1024) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div512) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div256))
N
N/**
N  * @}
N  */
N
N  /** @defgroup RTC_Tamper_Pin_Precharge_Duration_Definitions 
N  * @{
N  */ 
N#define RTC_TamperPrechargeDuration_1RTCCLK ((uint32_t)0x00000000)  /*!< Tamper pins are pre-charged before 
N                                                                         sampling during 1 RTCCLK cycle */
N#define RTC_TamperPrechargeDuration_2RTCCLK ((uint32_t)0x00002000)  /*!< Tamper pins are pre-charged before 
N                                                                         sampling during 2 RTCCLK cycles */
N#define RTC_TamperPrechargeDuration_4RTCCLK ((uint32_t)0x00004000)  /*!< Tamper pins are pre-charged before 
N                                                                         sampling during 4 RTCCLK cycles */
N#define RTC_TamperPrechargeDuration_8RTCCLK ((uint32_t)0x00006000)  /*!< Tamper pins are pre-charged before 
N                                                                         sampling during 8 RTCCLK cycles */
N
N#define IS_RTC_TAMPER_PRECHARGE_DURATION(DURATION) (((DURATION) == RTC_TamperPrechargeDuration_1RTCCLK) || \
N                                                    ((DURATION) == RTC_TamperPrechargeDuration_2RTCCLK) || \
N                                                    ((DURATION) == RTC_TamperPrechargeDuration_4RTCCLK) || \
N                                                    ((DURATION) == RTC_TamperPrechargeDuration_8RTCCLK))
X#define IS_RTC_TAMPER_PRECHARGE_DURATION(DURATION) (((DURATION) == RTC_TamperPrechargeDuration_1RTCCLK) ||                                                     ((DURATION) == RTC_TamperPrechargeDuration_2RTCCLK) ||                                                     ((DURATION) == RTC_TamperPrechargeDuration_4RTCCLK) ||                                                     ((DURATION) == RTC_TamperPrechargeDuration_8RTCCLK))
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Tamper_Pins_Definitions 
N  * @{
N  */ 
N#define RTC_Tamper_1 RTC_TAFCR_TAMP1E
N#define RTC_Tamper_2 RTC_TAFCR_TAMP2E
N#define IS_RTC_TAMPER(TAMPER) (((TAMPER) == RTC_Tamper_1) || ((TAMPER) == RTC_Tamper_2))
N
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Tamper_Pin_Selection 
N  * @{
N  */ 
N#define RTC_TamperPin_Default       ((uint32_t)0x00000000)
N#define RTC_TamperPin_Pos1          ((uint32_t)0x00010000)
N#define IS_RTC_TAMPER_PIN(PIN)      (((PIN) == RTC_TamperPin_Default) || \
N                                    ((PIN) == RTC_TamperPin_Pos1))
X#define IS_RTC_TAMPER_PIN(PIN)      (((PIN) == RTC_TamperPin_Default) ||                                     ((PIN) == RTC_TamperPin_Pos1))
N/* Legacy Defines */
N#define RTC_TamperPin_PC13           RTC_TamperPin_Default
N#define RTC_TamperPin_PI8            RTC_TamperPin_Pos1
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_TimeStamp_Pin_Selection 
N  * @{
N  */ 
N#define RTC_TimeStampPin_PC13              ((uint32_t)0x00000000)
N#define RTC_TimeStampPin_PI8               ((uint32_t)0x00020000)
N#define IS_RTC_TIMESTAMP_PIN(PIN) (((PIN) == RTC_TimeStampPin_PC13) || \
N                                   ((PIN) == RTC_TimeStampPin_PI8))
X#define IS_RTC_TIMESTAMP_PIN(PIN) (((PIN) == RTC_TimeStampPin_PC13) ||                                    ((PIN) == RTC_TimeStampPin_PI8))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Output_Type_ALARM_OUT 
N  * @{
N  */ 
N#define RTC_OutputType_OpenDrain           ((uint32_t)0x00000000)
N#define RTC_OutputType_PushPull            ((uint32_t)0x00040000)
N#define IS_RTC_OUTPUT_TYPE(TYPE) (((TYPE) == RTC_OutputType_OpenDrain) || \
N                                  ((TYPE) == RTC_OutputType_PushPull))
X#define IS_RTC_OUTPUT_TYPE(TYPE) (((TYPE) == RTC_OutputType_OpenDrain) ||                                   ((TYPE) == RTC_OutputType_PushPull))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Add_1_Second_Parameter_Definitions
N  * @{
N  */ 
N#define RTC_ShiftAdd1S_Reset      ((uint32_t)0x00000000)
N#define RTC_ShiftAdd1S_Set        ((uint32_t)0x80000000)
N#define IS_RTC_SHIFT_ADD1S(SEL) (((SEL) == RTC_ShiftAdd1S_Reset) || \
N                                 ((SEL) == RTC_ShiftAdd1S_Set))
X#define IS_RTC_SHIFT_ADD1S(SEL) (((SEL) == RTC_ShiftAdd1S_Reset) ||                                  ((SEL) == RTC_ShiftAdd1S_Set))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Substract_Fraction_Of_Second_Value
N  * @{
N  */ 
N#define IS_RTC_SHIFT_SUBFS(FS) ((FS) <= 0x00007FFF)
N
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Backup_Registers_Definitions 
N  * @{
N  */
N
N#define RTC_BKP_DR0                       ((uint32_t)0x00000000)
N#define RTC_BKP_DR1                       ((uint32_t)0x00000001)
N#define RTC_BKP_DR2                       ((uint32_t)0x00000002)
N#define RTC_BKP_DR3                       ((uint32_t)0x00000003)
N#define RTC_BKP_DR4                       ((uint32_t)0x00000004)
N#define RTC_BKP_DR5                       ((uint32_t)0x00000005)
N#define RTC_BKP_DR6                       ((uint32_t)0x00000006)
N#define RTC_BKP_DR7                       ((uint32_t)0x00000007)
N#define RTC_BKP_DR8                       ((uint32_t)0x00000008)
N#define RTC_BKP_DR9                       ((uint32_t)0x00000009)
N#define RTC_BKP_DR10                      ((uint32_t)0x0000000A)
N#define RTC_BKP_DR11                      ((uint32_t)0x0000000B)
N#define RTC_BKP_DR12                      ((uint32_t)0x0000000C)
N#define RTC_BKP_DR13                      ((uint32_t)0x0000000D)
N#define RTC_BKP_DR14                      ((uint32_t)0x0000000E)
N#define RTC_BKP_DR15                      ((uint32_t)0x0000000F)
N#define RTC_BKP_DR16                      ((uint32_t)0x00000010)
N#define RTC_BKP_DR17                      ((uint32_t)0x00000011)
N#define RTC_BKP_DR18                      ((uint32_t)0x00000012)
N#define RTC_BKP_DR19                      ((uint32_t)0x00000013)
N#define IS_RTC_BKP(BKP)                   (((BKP) == RTC_BKP_DR0) || \
N                                           ((BKP) == RTC_BKP_DR1) || \
N                                           ((BKP) == RTC_BKP_DR2) || \
N                                           ((BKP) == RTC_BKP_DR3) || \
N                                           ((BKP) == RTC_BKP_DR4) || \
N                                           ((BKP) == RTC_BKP_DR5) || \
N                                           ((BKP) == RTC_BKP_DR6) || \
N                                           ((BKP) == RTC_BKP_DR7) || \
N                                           ((BKP) == RTC_BKP_DR8) || \
N                                           ((BKP) == RTC_BKP_DR9) || \
N                                           ((BKP) == RTC_BKP_DR10) || \
N                                           ((BKP) == RTC_BKP_DR11) || \
N                                           ((BKP) == RTC_BKP_DR12) || \
N                                           ((BKP) == RTC_BKP_DR13) || \
N                                           ((BKP) == RTC_BKP_DR14) || \
N                                           ((BKP) == RTC_BKP_DR15) || \
N                                           ((BKP) == RTC_BKP_DR16) || \
N                                           ((BKP) == RTC_BKP_DR17) || \
N                                           ((BKP) == RTC_BKP_DR18) || \
N                                           ((BKP) == RTC_BKP_DR19))
X#define IS_RTC_BKP(BKP)                   (((BKP) == RTC_BKP_DR0) ||                                            ((BKP) == RTC_BKP_DR1) ||                                            ((BKP) == RTC_BKP_DR2) ||                                            ((BKP) == RTC_BKP_DR3) ||                                            ((BKP) == RTC_BKP_DR4) ||                                            ((BKP) == RTC_BKP_DR5) ||                                            ((BKP) == RTC_BKP_DR6) ||                                            ((BKP) == RTC_BKP_DR7) ||                                            ((BKP) == RTC_BKP_DR8) ||                                            ((BKP) == RTC_BKP_DR9) ||                                            ((BKP) == RTC_BKP_DR10) ||                                            ((BKP) == RTC_BKP_DR11) ||                                            ((BKP) == RTC_BKP_DR12) ||                                            ((BKP) == RTC_BKP_DR13) ||                                            ((BKP) == RTC_BKP_DR14) ||                                            ((BKP) == RTC_BKP_DR15) ||                                            ((BKP) == RTC_BKP_DR16) ||                                            ((BKP) == RTC_BKP_DR17) ||                                            ((BKP) == RTC_BKP_DR18) ||                                            ((BKP) == RTC_BKP_DR19))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Input_parameter_format_definitions 
N  * @{
N  */ 
N#define RTC_Format_BIN                    ((uint32_t)0x000000000)
N#define RTC_Format_BCD                    ((uint32_t)0x000000001)
N#define IS_RTC_FORMAT(FORMAT) (((FORMAT) == RTC_Format_BIN) || ((FORMAT) == RTC_Format_BCD))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Flags_Definitions 
N  * @{
N  */ 
N#define RTC_FLAG_RECALPF                  ((uint32_t)0x00010000)
N#define RTC_FLAG_TAMP1F                   ((uint32_t)0x00002000)
N#define RTC_FLAG_TAMP2F                   ((uint32_t)0x00004000) 
N#define RTC_FLAG_TSOVF                    ((uint32_t)0x00001000)
N#define RTC_FLAG_TSF                      ((uint32_t)0x00000800)
N#define RTC_FLAG_WUTF                     ((uint32_t)0x00000400)
N#define RTC_FLAG_ALRBF                    ((uint32_t)0x00000200)
N#define RTC_FLAG_ALRAF                    ((uint32_t)0x00000100)
N#define RTC_FLAG_INITF                    ((uint32_t)0x00000040)
N#define RTC_FLAG_RSF                      ((uint32_t)0x00000020)
N#define RTC_FLAG_INITS                    ((uint32_t)0x00000010)
N#define RTC_FLAG_SHPF                     ((uint32_t)0x00000008)
N#define RTC_FLAG_WUTWF                    ((uint32_t)0x00000004)
N#define RTC_FLAG_ALRBWF                   ((uint32_t)0x00000002)
N#define RTC_FLAG_ALRAWF                   ((uint32_t)0x00000001)
N#define IS_RTC_GET_FLAG(FLAG) (((FLAG) == RTC_FLAG_TSOVF) || ((FLAG) == RTC_FLAG_TSF) || \
N                               ((FLAG) == RTC_FLAG_WUTF) || ((FLAG) == RTC_FLAG_ALRBF) || \
N                               ((FLAG) == RTC_FLAG_ALRAF) || ((FLAG) == RTC_FLAG_INITF) || \
N                               ((FLAG) == RTC_FLAG_RSF) || ((FLAG) == RTC_FLAG_WUTWF) || \
N                               ((FLAG) == RTC_FLAG_ALRBWF) || ((FLAG) == RTC_FLAG_ALRAWF) || \
N                               ((FLAG) == RTC_FLAG_TAMP1F) || ((FLAG) == RTC_FLAG_RECALPF) || \
N                                ((FLAG) == RTC_FLAG_TAMP2F) ||((FLAG) == RTC_FLAG_SHPF))
X#define IS_RTC_GET_FLAG(FLAG) (((FLAG) == RTC_FLAG_TSOVF) || ((FLAG) == RTC_FLAG_TSF) ||                                ((FLAG) == RTC_FLAG_WUTF) || ((FLAG) == RTC_FLAG_ALRBF) ||                                ((FLAG) == RTC_FLAG_ALRAF) || ((FLAG) == RTC_FLAG_INITF) ||                                ((FLAG) == RTC_FLAG_RSF) || ((FLAG) == RTC_FLAG_WUTWF) ||                                ((FLAG) == RTC_FLAG_ALRBWF) || ((FLAG) == RTC_FLAG_ALRAWF) ||                                ((FLAG) == RTC_FLAG_TAMP1F) || ((FLAG) == RTC_FLAG_RECALPF) ||                                 ((FLAG) == RTC_FLAG_TAMP2F) ||((FLAG) == RTC_FLAG_SHPF))
N#define IS_RTC_CLEAR_FLAG(FLAG) (((FLAG) != (uint32_t)RESET) && (((FLAG) & 0xFFFF00DF) == (uint32_t)RESET))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Interrupts_Definitions 
N  * @{
N  */ 
N#define RTC_IT_TS                         ((uint32_t)0x00008000)
N#define RTC_IT_WUT                        ((uint32_t)0x00004000)
N#define RTC_IT_ALRB                       ((uint32_t)0x00002000)
N#define RTC_IT_ALRA                       ((uint32_t)0x00001000)
N#define RTC_IT_TAMP                       ((uint32_t)0x00000004) /* Used only to Enable the Tamper Interrupt */
N#define RTC_IT_TAMP1                      ((uint32_t)0x00020000)
N#define RTC_IT_TAMP2                      ((uint32_t)0x00040000)
N
N#define IS_RTC_CONFIG_IT(IT) (((IT) != (uint32_t)RESET) && (((IT) & 0xFFFF0FFB) == (uint32_t)RESET))
N#define IS_RTC_GET_IT(IT) (((IT) == RTC_IT_TS) || ((IT) == RTC_IT_WUT) || \
N                           ((IT) == RTC_IT_ALRB) || ((IT) == RTC_IT_ALRA) || \
N                           ((IT) == RTC_IT_TAMP1) || ((IT) == RTC_IT_TAMP2))
X#define IS_RTC_GET_IT(IT) (((IT) == RTC_IT_TS) || ((IT) == RTC_IT_WUT) ||                            ((IT) == RTC_IT_ALRB) || ((IT) == RTC_IT_ALRA) ||                            ((IT) == RTC_IT_TAMP1) || ((IT) == RTC_IT_TAMP2))
N#define IS_RTC_CLEAR_IT(IT) (((IT) != (uint32_t)RESET) && (((IT) & 0xFFF90FFF) == (uint32_t)RESET))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Legacy 
N  * @{
N  */ 
N#define RTC_DigitalCalibConfig  RTC_CoarseCalibConfig
N#define RTC_DigitalCalibCmd     RTC_CoarseCalibCmd
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/ 
N
N/*  Function used to set the RTC configuration to the default reset state *****/
NErrorStatus RTC_DeInit(void);
N
N/* Initialization and Configuration functions *********************************/
NErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct);
Nvoid RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct);
Nvoid RTC_WriteProtectionCmd(FunctionalState NewState);
NErrorStatus RTC_EnterInitMode(void);
Nvoid RTC_ExitInitMode(void);
NErrorStatus RTC_WaitForSynchro(void);
NErrorStatus RTC_RefClockCmd(FunctionalState NewState);
Nvoid RTC_BypassShadowCmd(FunctionalState NewState);
N
N/* Time and Date configuration functions **************************************/
NErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct);
Nvoid RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct);
Nvoid RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct);
Nuint32_t RTC_GetSubSecond(void);
NErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct);
Nvoid RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct);
Nvoid RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct);
N
N/* Alarms (Alarm A and Alarm B) configuration functions  **********************/
Nvoid RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct);
Nvoid RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct);
Nvoid RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct);
NErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState);
Nvoid RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint32_t RTC_AlarmSubSecondMask);
Nuint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm);
N
N/* WakeUp Timer configuration functions ***************************************/
Nvoid RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock);
Nvoid RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter);
Nuint32_t RTC_GetWakeUpCounter(void);
NErrorStatus RTC_WakeUpCmd(FunctionalState NewState);
N
N/* Daylight Saving configuration functions ************************************/
Nvoid RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation);
Nuint32_t RTC_GetStoreOperation(void);
N
N/* Output pin Configuration function ******************************************/
Nvoid RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity);
N
N/* Digital Calibration configuration functions *********************************/
NErrorStatus RTC_CoarseCalibConfig(uint32_t RTC_CalibSign, uint32_t Value);
NErrorStatus RTC_CoarseCalibCmd(FunctionalState NewState);
Nvoid RTC_CalibOutputCmd(FunctionalState NewState);
Nvoid RTC_CalibOutputConfig(uint32_t RTC_CalibOutput);
NErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod, 
N                                  uint32_t RTC_SmoothCalibPlusPulses,
N                                  uint32_t RTC_SmouthCalibMinusPulsesValue);
N
N/* TimeStamp configuration functions ******************************************/
Nvoid RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState);
Nvoid RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct,
N                                      RTC_DateTypeDef* RTC_StampDateStruct);
Nuint32_t RTC_GetTimeStampSubSecond(void);
N
N/* Tampers configuration functions ********************************************/
Nvoid RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger);
Nvoid RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState);
Nvoid RTC_TamperFilterConfig(uint32_t RTC_TamperFilter);
Nvoid RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq);
Nvoid RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration);
Nvoid RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState);
Nvoid RTC_TamperPullUpCmd(FunctionalState NewState);
N
N/* Backup Data Registers configuration functions ******************************/
Nvoid RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data);
Nuint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR);
N
N/* RTC Tamper and TimeStamp Pins Selection and Output Type Config configuration
N   functions ******************************************************************/
Nvoid RTC_TamperPinSelection(uint32_t RTC_TamperPin);
Nvoid RTC_TimeStampPinSelection(uint32_t RTC_TimeStampPin);
Nvoid RTC_OutputTypeConfig(uint32_t RTC_OutputType);
N
N/* RTC_Shift_control_synchonisation_functions *********************************/
NErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS);
N
N/* Interrupts and flags management functions **********************************/
Nvoid RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState);
NFlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG);
Nvoid RTC_ClearFlag(uint32_t RTC_FLAG);
NITStatus RTC_GetITStatus(uint32_t RTC_IT);
Nvoid RTC_ClearITPendingBit(uint32_t RTC_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F4xx_RTC_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 46 "..\..\Service\stm32f4xx_conf.h" 2
N#include "stm32f4xx_sdio.h"
L 1 "..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\stm32f4xx_sdio.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_sdio.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    04-November-2016
N  * @brief   This file contains all the functions prototypes for the SDIO firmware
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_SDIO_H
N#define __STM32F4xx_SDIO_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
N
N/** @addtogroup STM32F4xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup SDIO
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
Ntypedef struct
N{
N  uint32_t SDIO_ClockEdge;            /*!< Specifies the clock transition on which the bit capture is made.
N                                           This parameter can be a value of @ref SDIO_Clock_Edge */
N
N  uint32_t SDIO_ClockBypass;          /*!< Specifies whether the SDIO Clock divider bypass is
N                                           enabled or disabled.
N                                           This parameter can be a value of @ref SDIO_Clock_Bypass */
N
N  uint32_t SDIO_ClockPowerSave;       /*!< Specifies whether SDIO Clock output is enabled or
N                                           disabled when the bus is idle.
N                                           This parameter can be a value of @ref SDIO_Clock_Power_Save */
N
N  uint32_t SDIO_BusWide;              /*!< Specifies the SDIO bus width.
N                                           This parameter can be a value of @ref SDIO_Bus_Wide */
N
N  uint32_t SDIO_HardwareFlowControl;  /*!< Specifies whether the SDIO hardware flow control is enabled or disabled.
N                                           This parameter can be a value of @ref SDIO_Hardware_Flow_Control */
N
N  uint8_t SDIO_ClockDiv;              /*!< Specifies the clock frequency of the SDIO controller.
N                                           This parameter can be a value between 0x00 and 0xFF. */
N                                           
N} SDIO_InitTypeDef;
N
Ntypedef struct
N{
N  uint32_t SDIO_Argument;  /*!< Specifies the SDIO command argument which is sent
N                                to a card as part of a command message. If a command
N                                contains an argument, it must be loaded into this register
N                                before writing the command to the command register */
N
N  uint32_t SDIO_CmdIndex;  /*!< Specifies the SDIO command index. It must be lower than 0x40. */
N
N  uint32_t SDIO_Response;  /*!< Specifies the SDIO response type.
N                                This parameter can be a value of @ref SDIO_Response_Type */
N
N  uint32_t SDIO_Wait;      /*!< Specifies whether SDIO wait for interrupt request is enabled or disabled.
N                                This parameter can be a value of @ref SDIO_Wait_Interrupt_State */
N
N  uint32_t SDIO_CPSM;      /*!< Specifies whether SDIO Command path state machine (CPSM)
N                                is enabled or disabled.
N                                This parameter can be a value of @ref SDIO_CPSM_State */
N} SDIO_CmdInitTypeDef;
N
Ntypedef struct
N{
N  uint32_t SDIO_DataTimeOut;    /*!< Specifies the data timeout period in card bus clock periods. */
N
N  uint32_t SDIO_DataLength;     /*!< Specifies the number of data bytes to be transferred. */
N 
N  uint32_t SDIO_DataBlockSize;  /*!< Specifies the data block size for block transfer.
N                                     This parameter can be a value of @ref SDIO_Data_Block_Size */
N 
N  uint32_t SDIO_TransferDir;    /*!< Specifies the data transfer direction, whether the transfer
N                                     is a read or write.
N                                     This parameter can be a value of @ref SDIO_Transfer_Direction */
N 
N  uint32_t SDIO_TransferMode;   /*!< Specifies whether data transfer is in stream or block mode.
N                                     This parameter can be a value of @ref SDIO_Transfer_Type */
N 
N  uint32_t SDIO_DPSM;           /*!< Specifies whether SDIO Data path state machine (DPSM)
N                                     is enabled or disabled.
N                                     This parameter can be a value of @ref SDIO_DPSM_State */
N} SDIO_DataInitTypeDef;
N
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup SDIO_Exported_Constants
N  * @{
N  */
N
N/** @defgroup SDIO_Clock_Edge 
N  * @{
N  */
N
N#define SDIO_ClockEdge_Rising               ((uint32_t)0x00000000)
N#define SDIO_ClockEdge_Falling              ((uint32_t)0x00002000)
N#define IS_SDIO_CLOCK_EDGE(EDGE) (((EDGE) == SDIO_ClockEdge_Rising) || \
N                                  ((EDGE) == SDIO_ClockEdge_Falling))
X#define IS_SDIO_CLOCK_EDGE(EDGE) (((EDGE) == SDIO_ClockEdge_Rising) ||                                   ((EDGE) == SDIO_ClockEdge_Falling))
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Clock_Bypass 
N  * @{
N  */
N
N#define SDIO_ClockBypass_Disable             ((uint32_t)0x00000000)
N#define SDIO_ClockBypass_Enable              ((uint32_t)0x00000400)    
N#define IS_SDIO_CLOCK_BYPASS(BYPASS) (((BYPASS) == SDIO_ClockBypass_Disable) || \
N                                     ((BYPASS) == SDIO_ClockBypass_Enable))
X#define IS_SDIO_CLOCK_BYPASS(BYPASS) (((BYPASS) == SDIO_ClockBypass_Disable) ||                                      ((BYPASS) == SDIO_ClockBypass_Enable))
N/**
N  * @}
N  */ 
N
N/** @defgroup SDIO_Clock_Power_Save 
N  * @{
N  */
N
N#define SDIO_ClockPowerSave_Disable         ((uint32_t)0x00000000)
N#define SDIO_ClockPowerSave_Enable          ((uint32_t)0x00000200) 
N#define IS_SDIO_CLOCK_POWER_SAVE(SAVE) (((SAVE) == SDIO_ClockPowerSave_Disable) || \
N                                        ((SAVE) == SDIO_ClockPowerSave_Enable))
X#define IS_SDIO_CLOCK_POWER_SAVE(SAVE) (((SAVE) == SDIO_ClockPowerSave_Disable) ||                                         ((SAVE) == SDIO_ClockPowerSave_Enable))
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Bus_Wide 
N  * @{
N  */
N
N#define SDIO_BusWide_1b                     ((uint32_t)0x00000000)
N#define SDIO_BusWide_4b                     ((uint32_t)0x00000800)
N#define SDIO_BusWide_8b                     ((uint32_t)0x00001000)
N#define IS_SDIO_BUS_WIDE(WIDE) (((WIDE) == SDIO_BusWide_1b) || ((WIDE) == SDIO_BusWide_4b) || \
N                                ((WIDE) == SDIO_BusWide_8b))
X#define IS_SDIO_BUS_WIDE(WIDE) (((WIDE) == SDIO_BusWide_1b) || ((WIDE) == SDIO_BusWide_4b) ||                                 ((WIDE) == SDIO_BusWide_8b))
N
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Hardware_Flow_Control 
N  * @{
N  */
N
N#define SDIO_HardwareFlowControl_Disable    ((uint32_t)0x00000000)
N#define SDIO_HardwareFlowControl_Enable     ((uint32_t)0x00004000)
N#define IS_SDIO_HARDWARE_FLOW_CONTROL(CONTROL) (((CONTROL) == SDIO_HardwareFlowControl_Disable) || \
N                                                ((CONTROL) == SDIO_HardwareFlowControl_Enable))
X#define IS_SDIO_HARDWARE_FLOW_CONTROL(CONTROL) (((CONTROL) == SDIO_HardwareFlowControl_Disable) ||                                                 ((CONTROL) == SDIO_HardwareFlowControl_Enable))
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Power_State 
N  * @{
N  */
N
N#define SDIO_PowerState_OFF                 ((uint32_t)0x00000000)
N#define SDIO_PowerState_ON                  ((uint32_t)0x00000003)
N#define IS_SDIO_POWER_STATE(STATE) (((STATE) == SDIO_PowerState_OFF) || ((STATE) == SDIO_PowerState_ON))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup SDIO_Interrupt_sources
N  * @{
N  */
N
N#define SDIO_IT_CCRCFAIL                    ((uint32_t)0x00000001)
N#define SDIO_IT_DCRCFAIL                    ((uint32_t)0x00000002)
N#define SDIO_IT_CTIMEOUT                    ((uint32_t)0x00000004)
N#define SDIO_IT_DTIMEOUT                    ((uint32_t)0x00000008)
N#define SDIO_IT_TXUNDERR                    ((uint32_t)0x00000010)
N#define SDIO_IT_RXOVERR                     ((uint32_t)0x00000020)
N#define SDIO_IT_CMDREND                     ((uint32_t)0x00000040)
N#define SDIO_IT_CMDSENT                     ((uint32_t)0x00000080)
N#define SDIO_IT_DATAEND                     ((uint32_t)0x00000100)
N#define SDIO_IT_STBITERR                    ((uint32_t)0x00000200)
N#define SDIO_IT_DBCKEND                     ((uint32_t)0x00000400)
N#define SDIO_IT_CMDACT                      ((uint32_t)0x00000800)
N#define SDIO_IT_TXACT                       ((uint32_t)0x00001000)
N#define SDIO_IT_RXACT                       ((uint32_t)0x00002000)
N#define SDIO_IT_TXFIFOHE                    ((uint32_t)0x00004000)
N#define SDIO_IT_RXFIFOHF                    ((uint32_t)0x00008000)
N#define SDIO_IT_TXFIFOF                     ((uint32_t)0x00010000)
N#define SDIO_IT_RXFIFOF                     ((uint32_t)0x00020000)
N#define SDIO_IT_TXFIFOE                     ((uint32_t)0x00040000)
N#define SDIO_IT_RXFIFOE                     ((uint32_t)0x00080000)
N#define SDIO_IT_TXDAVL                      ((uint32_t)0x00100000)
N#define SDIO_IT_RXDAVL                      ((uint32_t)0x00200000)
N#define SDIO_IT_SDIOIT                      ((uint32_t)0x00400000)
N#define SDIO_IT_CEATAEND                    ((uint32_t)0x00800000)
N#define IS_SDIO_IT(IT) ((((IT) & (uint32_t)0xFF000000) == 0x00) && ((IT) != (uint32_t)0x00))
N/**
N  * @}
N  */ 
N
N/** @defgroup SDIO_Command_Index
N  * @{
N  */
N
N#define IS_SDIO_CMD_INDEX(INDEX)            ((INDEX) < 0x40)
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Response_Type
N  * @{
N  */
N
N#define SDIO_Response_No                    ((uint32_t)0x00000000)
N#define SDIO_Response_Short                 ((uint32_t)0x00000040)
N#define SDIO_Response_Long                  ((uint32_t)0x000000C0)
N#define IS_SDIO_RESPONSE(RESPONSE) (((RESPONSE) == SDIO_Response_No) || \
N                                    ((RESPONSE) == SDIO_Response_Short) || \
N                                    ((RESPONSE) == SDIO_Response_Long))
X#define IS_SDIO_RESPONSE(RESPONSE) (((RESPONSE) == SDIO_Response_No) ||                                     ((RESPONSE) == SDIO_Response_Short) ||                                     ((RESPONSE) == SDIO_Response_Long))
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Wait_Interrupt_State
N  * @{
N  */
N
N#define SDIO_Wait_No                        ((uint32_t)0x00000000) /*!< SDIO No Wait, TimeOut is enabled */
N#define SDIO_Wait_IT                        ((uint32_t)0x00000100) /*!< SDIO Wait Interrupt Request */
N#define SDIO_Wait_Pend                      ((uint32_t)0x00000200) /*!< SDIO Wait End of transfer */
N#define IS_SDIO_WAIT(WAIT) (((WAIT) == SDIO_Wait_No) || ((WAIT) == SDIO_Wait_IT) || \
N                            ((WAIT) == SDIO_Wait_Pend))
X#define IS_SDIO_WAIT(WAIT) (((WAIT) == SDIO_Wait_No) || ((WAIT) == SDIO_Wait_IT) ||                             ((WAIT) == SDIO_Wait_Pend))
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_CPSM_State
N  * @{
N  */
N
N#define SDIO_CPSM_Disable                    ((uint32_t)0x00000000)
N#define SDIO_CPSM_Enable                     ((uint32_t)0x00000400)
N#define IS_SDIO_CPSM(CPSM) (((CPSM) == SDIO_CPSM_Enable) || ((CPSM) == SDIO_CPSM_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup SDIO_Response_Registers
N  * @{
N  */
N
N#define SDIO_RESP1                          ((uint32_t)0x00000000)
N#define SDIO_RESP2                          ((uint32_t)0x00000004)
N#define SDIO_RESP3                          ((uint32_t)0x00000008)
N#define SDIO_RESP4                          ((uint32_t)0x0000000C)
N#define IS_SDIO_RESP(RESP) (((RESP) == SDIO_RESP1) || ((RESP) == SDIO_RESP2) || \
N                            ((RESP) == SDIO_RESP3) || ((RESP) == SDIO_RESP4))
X#define IS_SDIO_RESP(RESP) (((RESP) == SDIO_RESP1) || ((RESP) == SDIO_RESP2) ||                             ((RESP) == SDIO_RESP3) || ((RESP) == SDIO_RESP4))
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Data_Length 
N  * @{
N  */
N
N#define IS_SDIO_DATA_LENGTH(LENGTH) ((LENGTH) <= 0x01FFFFFF)
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Data_Block_Size 
N  * @{
N  */
N
N#define SDIO_DataBlockSize_1b               ((uint32_t)0x00000000)
N#define SDIO_DataBlockSize_2b               ((uint32_t)0x00000010)
N#define SDIO_DataBlockSize_4b               ((uint32_t)0x00000020)
N#define SDIO_DataBlockSize_8b               ((uint32_t)0x00000030)
N#define SDIO_DataBlockSize_16b              ((uint32_t)0x00000040)
N#define SDIO_DataBlockSize_32b              ((uint32_t)0x00000050)
N#define SDIO_DataBlockSize_64b              ((uint32_t)0x00000060)
N#define SDIO_DataBlockSize_128b             ((uint32_t)0x00000070)
N#define SDIO_DataBlockSize_256b             ((uint32_t)0x00000080)
N#define SDIO_DataBlockSize_512b             ((uint32_t)0x00000090)
N#define SDIO_DataBlockSize_1024b            ((uint32_t)0x000000A0)
N#define SDIO_DataBlockSize_2048b            ((uint32_t)0x000000B0)
N#define SDIO_DataBlockSize_4096b            ((uint32_t)0x000000C0)
N#define SDIO_DataBlockSize_8192b            ((uint32_t)0x000000D0)
N#define SDIO_DataBlockSize_16384b           ((uint32_t)0x000000E0)
N#define IS_SDIO_BLOCK_SIZE(SIZE) (((SIZE) == SDIO_DataBlockSize_1b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_2b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_4b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_8b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_16b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_32b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_64b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_128b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_256b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_512b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_1024b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_2048b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_4096b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_8192b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_16384b)) 
X#define IS_SDIO_BLOCK_SIZE(SIZE) (((SIZE) == SDIO_DataBlockSize_1b) ||                                   ((SIZE) == SDIO_DataBlockSize_2b) ||                                   ((SIZE) == SDIO_DataBlockSize_4b) ||                                   ((SIZE) == SDIO_DataBlockSize_8b) ||                                   ((SIZE) == SDIO_DataBlockSize_16b) ||                                   ((SIZE) == SDIO_DataBlockSize_32b) ||                                   ((SIZE) == SDIO_DataBlockSize_64b) ||                                   ((SIZE) == SDIO_DataBlockSize_128b) ||                                   ((SIZE) == SDIO_DataBlockSize_256b) ||                                   ((SIZE) == SDIO_DataBlockSize_512b) ||                                   ((SIZE) == SDIO_DataBlockSize_1024b) ||                                   ((SIZE) == SDIO_DataBlockSize_2048b) ||                                   ((SIZE) == SDIO_DataBlockSize_4096b) ||                                   ((SIZE) == SDIO_DataBlockSize_8192b) ||                                   ((SIZE) == SDIO_DataBlockSize_16384b)) 
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Transfer_Direction 
N  * @{
N  */
N
N#define SDIO_TransferDir_ToCard             ((uint32_t)0x00000000)
N#define SDIO_TransferDir_ToSDIO             ((uint32_t)0x00000002)
N#define IS_SDIO_TRANSFER_DIR(DIR) (((DIR) == SDIO_TransferDir_ToCard) || \
N                                   ((DIR) == SDIO_TransferDir_ToSDIO))
X#define IS_SDIO_TRANSFER_DIR(DIR) (((DIR) == SDIO_TransferDir_ToCard) ||                                    ((DIR) == SDIO_TransferDir_ToSDIO))
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Transfer_Type 
N  * @{
N  */
N
N#define SDIO_TransferMode_Block             ((uint32_t)0x00000000)
N#define SDIO_TransferMode_Stream            ((uint32_t)0x00000004)
N#define IS_SDIO_TRANSFER_MODE(MODE) (((MODE) == SDIO_TransferMode_Stream) || \
N                                     ((MODE) == SDIO_TransferMode_Block))
X#define IS_SDIO_TRANSFER_MODE(MODE) (((MODE) == SDIO_TransferMode_Stream) ||                                      ((MODE) == SDIO_TransferMode_Block))
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_DPSM_State 
N  * @{
N  */
N
N#define SDIO_DPSM_Disable                    ((uint32_t)0x00000000)
N#define SDIO_DPSM_Enable                     ((uint32_t)0x00000001)
N#define IS_SDIO_DPSM(DPSM) (((DPSM) == SDIO_DPSM_Enable) || ((DPSM) == SDIO_DPSM_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Flags 
N  * @{
N  */
N
N#define SDIO_FLAG_CCRCFAIL                  ((uint32_t)0x00000001)
N#define SDIO_FLAG_DCRCFAIL                  ((uint32_t)0x00000002)
N#define SDIO_FLAG_CTIMEOUT                  ((uint32_t)0x00000004)
N#define SDIO_FLAG_DTIMEOUT                  ((uint32_t)0x00000008)
N#define SDIO_FLAG_TXUNDERR                  ((uint32_t)0x00000010)
N#define SDIO_FLAG_RXOVERR                   ((uint32_t)0x00000020)
N#define SDIO_FLAG_CMDREND                   ((uint32_t)0x00000040)
N#define SDIO_FLAG_CMDSENT                   ((uint32_t)0x00000080)
N#define SDIO_FLAG_DATAEND                   ((uint32_t)0x00000100)
N#define SDIO_FLAG_STBITERR                  ((uint32_t)0x00000200)
N#define SDIO_FLAG_DBCKEND                   ((uint32_t)0x00000400)
N#define SDIO_FLAG_CMDACT                    ((uint32_t)0x00000800)
N#define SDIO_FLAG_TXACT                     ((uint32_t)0x00001000)
N#define SDIO_FLAG_RXACT                     ((uint32_t)0x00002000)
N#define SDIO_FLAG_TXFIFOHE                  ((uint32_t)0x00004000)
N#define SDIO_FLAG_RXFIFOHF                  ((uint32_t)0x00008000)
N#define SDIO_FLAG_TXFIFOF                   ((uint32_t)0x00010000)
N#define SDIO_FLAG_RXFIFOF                   ((uint32_t)0x00020000)
N#define SDIO_FLAG_TXFIFOE                   ((uint32_t)0x00040000)
N#define SDIO_FLAG_RXFIFOE                   ((uint32_t)0x00080000)
N#define SDIO_FLAG_TXDAVL                    ((uint32_t)0x00100000)
N#define SDIO_FLAG_RXDAVL                    ((uint32_t)0x00200000)
N#define SDIO_FLAG_SDIOIT                    ((uint32_t)0x00400000)
N#define SDIO_FLAG_CEATAEND                  ((uint32_t)0x00800000)
N#define IS_SDIO_FLAG(FLAG) (((FLAG)  == SDIO_FLAG_CCRCFAIL) || \
N                            ((FLAG)  == SDIO_FLAG_DCRCFAIL) || \
N                            ((FLAG)  == SDIO_FLAG_CTIMEOUT) || \
N                            ((FLAG)  == SDIO_FLAG_DTIMEOUT) || \
N                            ((FLAG)  == SDIO_FLAG_TXUNDERR) || \
N                            ((FLAG)  == SDIO_FLAG_RXOVERR) || \
N                            ((FLAG)  == SDIO_FLAG_CMDREND) || \
N                            ((FLAG)  == SDIO_FLAG_CMDSENT) || \
N                            ((FLAG)  == SDIO_FLAG_DATAEND) || \
N                            ((FLAG)  == SDIO_FLAG_STBITERR) || \
N                            ((FLAG)  == SDIO_FLAG_DBCKEND) || \
N                            ((FLAG)  == SDIO_FLAG_CMDACT) || \
N                            ((FLAG)  == SDIO_FLAG_TXACT) || \
N                            ((FLAG)  == SDIO_FLAG_RXACT) || \
N                            ((FLAG)  == SDIO_FLAG_TXFIFOHE) || \
N                            ((FLAG)  == SDIO_FLAG_RXFIFOHF) || \
N                            ((FLAG)  == SDIO_FLAG_TXFIFOF) || \
N                            ((FLAG)  == SDIO_FLAG_RXFIFOF) || \
N                            ((FLAG)  == SDIO_FLAG_TXFIFOE) || \
N                            ((FLAG)  == SDIO_FLAG_RXFIFOE) || \
N                            ((FLAG)  == SDIO_FLAG_TXDAVL) || \
N                            ((FLAG)  == SDIO_FLAG_RXDAVL) || \
N                            ((FLAG)  == SDIO_FLAG_SDIOIT) || \
N                            ((FLAG)  == SDIO_FLAG_CEATAEND))
X#define IS_SDIO_FLAG(FLAG) (((FLAG)  == SDIO_FLAG_CCRCFAIL) ||                             ((FLAG)  == SDIO_FLAG_DCRCFAIL) ||                             ((FLAG)  == SDIO_FLAG_CTIMEOUT) ||                             ((FLAG)  == SDIO_FLAG_DTIMEOUT) ||                             ((FLAG)  == SDIO_FLAG_TXUNDERR) ||                             ((FLAG)  == SDIO_FLAG_RXOVERR) ||                             ((FLAG)  == SDIO_FLAG_CMDREND) ||                             ((FLAG)  == SDIO_FLAG_CMDSENT) ||                             ((FLAG)  == SDIO_FLAG_DATAEND) ||                             ((FLAG)  == SDIO_FLAG_STBITERR) ||                             ((FLAG)  == SDIO_FLAG_DBCKEND) ||                             ((FLAG)  == SDIO_FLAG_CMDACT) ||                             ((FLAG)  == SDIO_FLAG_TXACT) ||                             ((FLAG)  == SDIO_FLAG_RXACT) ||                             ((FLAG)  == SDIO_FLAG_TXFIFOHE) ||                             ((FLAG)  == SDIO_FLAG_RXFIFOHF) ||                             ((FLAG)  == SDIO_FLAG_TXFIFOF) ||                             ((FLAG)  == SDIO_FLAG_RXFIFOF) ||                             ((FLAG)  == SDIO_FLAG_TXFIFOE) ||                             ((FLAG)  == SDIO_FLAG_RXFIFOE) ||                             ((FLAG)  == SDIO_FLAG_TXDAVL) ||                             ((FLAG)  == SDIO_FLAG_RXDAVL) ||                             ((FLAG)  == SDIO_FLAG_SDIOIT) ||                             ((FLAG)  == SDIO_FLAG_CEATAEND))
N
N#define IS_SDIO_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFF3FF800) == 0x00) && ((FLAG) != (uint32_t)0x00))
N
N#define IS_SDIO_GET_IT(IT) (((IT)  == SDIO_IT_CCRCFAIL) || \
N                            ((IT)  == SDIO_IT_DCRCFAIL) || \
N                            ((IT)  == SDIO_IT_CTIMEOUT) || \
N                            ((IT)  == SDIO_IT_DTIMEOUT) || \
N                            ((IT)  == SDIO_IT_TXUNDERR) || \
N                            ((IT)  == SDIO_IT_RXOVERR) || \
N                            ((IT)  == SDIO_IT_CMDREND) || \
N                            ((IT)  == SDIO_IT_CMDSENT) || \
N                            ((IT)  == SDIO_IT_DATAEND) || \
N                            ((IT)  == SDIO_IT_STBITERR) || \
N                            ((IT)  == SDIO_IT_DBCKEND) || \
N                            ((IT)  == SDIO_IT_CMDACT) || \
N                            ((IT)  == SDIO_IT_TXACT) || \
N                            ((IT)  == SDIO_IT_RXACT) || \
N                            ((IT)  == SDIO_IT_TXFIFOHE) || \
N                            ((IT)  == SDIO_IT_RXFIFOHF) || \
N                            ((IT)  == SDIO_IT_TXFIFOF) || \
N                            ((IT)  == SDIO_IT_RXFIFOF) || \
N                            ((IT)  == SDIO_IT_TXFIFOE) || \
N                            ((IT)  == SDIO_IT_RXFIFOE) || \
N                            ((IT)  == SDIO_IT_TXDAVL) || \
N                            ((IT)  == SDIO_IT_RXDAVL) || \
N                            ((IT)  == SDIO_IT_SDIOIT) || \
N                            ((IT)  == SDIO_IT_CEATAEND))
X#define IS_SDIO_GET_IT(IT) (((IT)  == SDIO_IT_CCRCFAIL) ||                             ((IT)  == SDIO_IT_DCRCFAIL) ||                             ((IT)  == SDIO_IT_CTIMEOUT) ||                             ((IT)  == SDIO_IT_DTIMEOUT) ||                             ((IT)  == SDIO_IT_TXUNDERR) ||                             ((IT)  == SDIO_IT_RXOVERR) ||                             ((IT)  == SDIO_IT_CMDREND) ||                             ((IT)  == SDIO_IT_CMDSENT) ||                             ((IT)  == SDIO_IT_DATAEND) ||                             ((IT)  == SDIO_IT_STBITERR) ||                             ((IT)  == SDIO_IT_DBCKEND) ||                             ((IT)  == SDIO_IT_CMDACT) ||                             ((IT)  == SDIO_IT_TXACT) ||                             ((IT)  == SDIO_IT_RXACT) ||                             ((IT)  == SDIO_IT_TXFIFOHE) ||                             ((IT)  == SDIO_IT_RXFIFOHF) ||                             ((IT)  == SDIO_IT_TXFIFOF) ||                             ((IT)  == SDIO_IT_RXFIFOF) ||                             ((IT)  == SDIO_IT_TXFIFOE) ||                             ((IT)  == SDIO_IT_RXFIFOE) ||                             ((IT)  == SDIO_IT_TXDAVL) ||                             ((IT)  == SDIO_IT_RXDAVL) ||                             ((IT)  == SDIO_IT_SDIOIT) ||                             ((IT)  == SDIO_IT_CEATAEND))
N
N#define IS_SDIO_CLEAR_IT(IT) ((((IT) & (uint32_t)0xFF3FF800) == 0x00) && ((IT) != (uint32_t)0x00))
N
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Read_Wait_Mode 
N  * @{
N  */
N
N#define SDIO_ReadWaitMode_DATA2             ((uint32_t)0x00000000)
N#define SDIO_ReadWaitMode_CLK               ((uint32_t)0x00000001)
N#define IS_SDIO_READWAIT_MODE(MODE) (((MODE) == SDIO_ReadWaitMode_CLK) || \
N                                     ((MODE) == SDIO_ReadWaitMode_DATA2))
X#define IS_SDIO_READWAIT_MODE(MODE) (((MODE) == SDIO_ReadWaitMode_CLK) ||                                      ((MODE) == SDIO_ReadWaitMode_DATA2))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/
N/*  Function used to set the SDIO configuration to the default reset state ****/
Nvoid SDIO_DeInit(void);
N
N/* Initialization and Configuration functions *********************************/
Nvoid SDIO_Init(SDIO_InitTypeDef* SDIO_InitStruct);
Nvoid SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct);
Nvoid SDIO_ClockCmd(FunctionalState NewState);
Nvoid SDIO_SetPowerState(uint32_t SDIO_PowerState);
Nuint32_t SDIO_GetPowerState(void);
N
N/* Command path state machine (CPSM) management functions *********************/
Nvoid SDIO_SendCommand(SDIO_CmdInitTypeDef *SDIO_CmdInitStruct);
Nvoid SDIO_CmdStructInit(SDIO_CmdInitTypeDef* SDIO_CmdInitStruct);
Nuint8_t SDIO_GetCommandResponse(void);
Nuint32_t SDIO_GetResponse(uint32_t SDIO_RESP);
N
N/* Data path state machine (DPSM) management functions ************************/
Nvoid SDIO_DataConfig(SDIO_DataInitTypeDef* SDIO_DataInitStruct);
Nvoid SDIO_DataStructInit(SDIO_DataInitTypeDef* SDIO_DataInitStruct);
Nuint32_t SDIO_GetDataCounter(void);
Nuint32_t SDIO_ReadData(void);
Nvoid SDIO_WriteData(uint32_t Data);
Nuint32_t SDIO_GetFIFOCount(void);
N
N/* SDIO IO Cards mode management functions ************************************/
Nvoid SDIO_StartSDIOReadWait(FunctionalState NewState);
Nvoid SDIO_StopSDIOReadWait(FunctionalState NewState);
Nvoid SDIO_SetSDIOReadWaitMode(uint32_t SDIO_ReadWaitMode);
Nvoid SDIO_SetSDIOOperation(FunctionalState NewState);
Nvoid SDIO_SendSDIOSuspendCmd(FunctionalState NewState);
N
N/* CE-ATA mode management functions *******************************************/
Nvoid SDIO_CommandCompletionCmd(FunctionalState NewState);
Nvoid SDIO_CEATAITCmd(FunctionalState NewState);
Nvoid SDIO_SendCEATACmd(FunctionalState NewState);
N
N/* DMA transfers management functions *****************************************/
Nvoid SDIO_DMACmd(FunctionalState NewState);
N
N/* Interrupts and flags management functions **********************************/
Nvoid SDIO_ITConfig(uint32_t SDIO_IT, FunctionalState NewState);
NFlagStatus SDIO_GetFlagStatus(uint32_t SDIO_FLAG);
Nvoid SDIO_ClearFlag(uint32_t SDIO_FLAG);
NITStatus SDIO_GetITStatus(uint32_t SDIO_IT);
Nvoid SDIO_ClearITPendingBit(uint32_t SDIO_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_SDIO_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 47 "..\..\Service\stm32f4xx_conf.h" 2
N#include "stm32f4xx_spi.h"
L 1 "..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\stm32f4xx_spi.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_spi.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    04-November-2016
N  * @brief   This file contains all the functions prototypes for the SPI 
N  *          firmware library. 
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************  
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_SPI_H
N#define __STM32F4xx_SPI_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
N
N/** @addtogroup STM32F4xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup SPI
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  SPI Init structure definition  
N  */
N
Ntypedef struct
N{
N  uint16_t SPI_Direction;           /*!< Specifies the SPI unidirectional or bidirectional data mode.
N                                         This parameter can be a value of @ref SPI_data_direction */
N
N  uint16_t SPI_Mode;                /*!< Specifies the SPI operating mode.
N                                         This parameter can be a value of @ref SPI_mode */
N
N  uint16_t SPI_DataSize;            /*!< Specifies the SPI data size.
N                                         This parameter can be a value of @ref SPI_data_size */
N
N  uint16_t SPI_CPOL;                /*!< Specifies the serial clock steady state.
N                                         This parameter can be a value of @ref SPI_Clock_Polarity */
N
N  uint16_t SPI_CPHA;                /*!< Specifies the clock active edge for the bit capture.
N                                         This parameter can be a value of @ref SPI_Clock_Phase */
N
N  uint16_t SPI_NSS;                 /*!< Specifies whether the NSS signal is managed by
N                                         hardware (NSS pin) or by software using the SSI bit.
N                                         This parameter can be a value of @ref SPI_Slave_Select_management */
N 
N  uint16_t SPI_BaudRatePrescaler;   /*!< Specifies the Baud Rate prescaler value which will be
N                                         used to configure the transmit and receive SCK clock.
N                                         This parameter can be a value of @ref SPI_BaudRate_Prescaler
N                                         @note The communication clock is derived from the master
N                                               clock. The slave clock does not need to be set. */
N
N  uint16_t SPI_FirstBit;            /*!< Specifies whether data transfers start from MSB or LSB bit.
N                                         This parameter can be a value of @ref SPI_MSB_LSB_transmission */
N
N  uint16_t SPI_CRCPolynomial;       /*!< Specifies the polynomial used for the CRC calculation. */
N}SPI_InitTypeDef;
N
N/** 
N  * @brief  I2S Init structure definition  
N  */
N
Ntypedef struct
N{
N
N  uint16_t I2S_Mode;         /*!< Specifies the I2S operating mode.
N                                  This parameter can be a value of @ref I2S_Mode */
N
N  uint16_t I2S_Standard;     /*!< Specifies the standard used for the I2S communication.
N                                  This parameter can be a value of @ref I2S_Standard */
N
N  uint16_t I2S_DataFormat;   /*!< Specifies the data format for the I2S communication.
N                                  This parameter can be a value of @ref I2S_Data_Format */
N
N  uint16_t I2S_MCLKOutput;   /*!< Specifies whether the I2S MCLK output is enabled or not.
N                                  This parameter can be a value of @ref I2S_MCLK_Output */
N
N  uint32_t I2S_AudioFreq;    /*!< Specifies the frequency selected for the I2S communication.
N                                  This parameter can be a value of @ref I2S_Audio_Frequency */
N
N  uint16_t I2S_CPOL;         /*!< Specifies the idle state of the I2S clock.
N                                  This parameter can be a value of @ref I2S_Clock_Polarity */
N}I2S_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup SPI_Exported_Constants
N  * @{
N  */
N
N#define IS_SPI_ALL_PERIPH(PERIPH) (((PERIPH) == SPI1) || \
N                                   ((PERIPH) == SPI2) || \
N                                   ((PERIPH) == SPI3) || \
N                                   ((PERIPH) == SPI4) || \
N                                   ((PERIPH) == SPI5) || \
N                                   ((PERIPH) == SPI6))
X#define IS_SPI_ALL_PERIPH(PERIPH) (((PERIPH) == SPI1) ||                                    ((PERIPH) == SPI2) ||                                    ((PERIPH) == SPI3) ||                                    ((PERIPH) == SPI4) ||                                    ((PERIPH) == SPI5) ||                                    ((PERIPH) == SPI6))
N
N#define IS_SPI_ALL_PERIPH_EXT(PERIPH) (((PERIPH) == SPI1)    || \
N                                       ((PERIPH) == SPI2)    || \
N                                       ((PERIPH) == SPI3)    || \
N                                       ((PERIPH) == SPI4)    || \
N                                       ((PERIPH) == SPI5)    || \
N                                       ((PERIPH) == SPI6)    || \
N                                       ((PERIPH) == I2S2ext) || \
N                                       ((PERIPH) == I2S3ext))
X#define IS_SPI_ALL_PERIPH_EXT(PERIPH) (((PERIPH) == SPI1)    ||                                        ((PERIPH) == SPI2)    ||                                        ((PERIPH) == SPI3)    ||                                        ((PERIPH) == SPI4)    ||                                        ((PERIPH) == SPI5)    ||                                        ((PERIPH) == SPI6)    ||                                        ((PERIPH) == I2S2ext) ||                                        ((PERIPH) == I2S3ext))
N
N#define IS_SPI_23_PERIPH(PERIPH)  (((PERIPH) == SPI2) || \
N                                   ((PERIPH) == SPI3))
X#define IS_SPI_23_PERIPH(PERIPH)  (((PERIPH) == SPI2) ||                                    ((PERIPH) == SPI3))
N
N#define IS_SPI_23_PERIPH_EXT(PERIPH)  (((PERIPH) == SPI2)    || \
N                                       ((PERIPH) == SPI3)    || \
N                                       ((PERIPH) == I2S2ext) || \
N                                       ((PERIPH) == I2S3ext))
X#define IS_SPI_23_PERIPH_EXT(PERIPH)  (((PERIPH) == SPI2)    ||                                        ((PERIPH) == SPI3)    ||                                        ((PERIPH) == I2S2ext) ||                                        ((PERIPH) == I2S3ext))
N
N#define IS_I2S_EXT_PERIPH(PERIPH)  (((PERIPH) == I2S2ext) || \
N                                    ((PERIPH) == I2S3ext))
X#define IS_I2S_EXT_PERIPH(PERIPH)  (((PERIPH) == I2S2ext) ||                                     ((PERIPH) == I2S3ext))
N
N
N/** @defgroup SPI_data_direction 
N  * @{
N  */
N  
N#define SPI_Direction_2Lines_FullDuplex ((uint16_t)0x0000)
N#define SPI_Direction_2Lines_RxOnly     ((uint16_t)0x0400)
N#define SPI_Direction_1Line_Rx          ((uint16_t)0x8000)
N#define SPI_Direction_1Line_Tx          ((uint16_t)0xC000)
N#define IS_SPI_DIRECTION_MODE(MODE) (((MODE) == SPI_Direction_2Lines_FullDuplex) || \
N                                     ((MODE) == SPI_Direction_2Lines_RxOnly) || \
N                                     ((MODE) == SPI_Direction_1Line_Rx) || \
N                                     ((MODE) == SPI_Direction_1Line_Tx))
X#define IS_SPI_DIRECTION_MODE(MODE) (((MODE) == SPI_Direction_2Lines_FullDuplex) ||                                      ((MODE) == SPI_Direction_2Lines_RxOnly) ||                                      ((MODE) == SPI_Direction_1Line_Rx) ||                                      ((MODE) == SPI_Direction_1Line_Tx))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_mode 
N  * @{
N  */
N
N#define SPI_Mode_Master                 ((uint16_t)0x0104)
N#define SPI_Mode_Slave                  ((uint16_t)0x0000)
N#define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) || \
N                           ((MODE) == SPI_Mode_Slave))
X#define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) ||                            ((MODE) == SPI_Mode_Slave))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_data_size 
N  * @{
N  */
N
N#define SPI_DataSize_16b                ((uint16_t)0x0800)
N#define SPI_DataSize_8b                 ((uint16_t)0x0000)
N#define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DataSize_16b) || \
N                                   ((DATASIZE) == SPI_DataSize_8b))
X#define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DataSize_16b) ||                                    ((DATASIZE) == SPI_DataSize_8b))
N/**
N  * @}
N  */ 
N
N/** @defgroup SPI_Clock_Polarity 
N  * @{
N  */
N
N#define SPI_CPOL_Low                    ((uint16_t)0x0000)
N#define SPI_CPOL_High                   ((uint16_t)0x0002)
N#define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) || \
N                           ((CPOL) == SPI_CPOL_High))
X#define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) ||                            ((CPOL) == SPI_CPOL_High))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Clock_Phase 
N  * @{
N  */
N
N#define SPI_CPHA_1Edge                  ((uint16_t)0x0000)
N#define SPI_CPHA_2Edge                  ((uint16_t)0x0001)
N#define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) || \
N                           ((CPHA) == SPI_CPHA_2Edge))
X#define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) ||                            ((CPHA) == SPI_CPHA_2Edge))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Slave_Select_management 
N  * @{
N  */
N
N#define SPI_NSS_Soft                    ((uint16_t)0x0200)
N#define SPI_NSS_Hard                    ((uint16_t)0x0000)
N#define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) || \
N                         ((NSS) == SPI_NSS_Hard))
X#define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) ||                          ((NSS) == SPI_NSS_Hard))
N/**
N  * @}
N  */ 
N
N/** @defgroup SPI_BaudRate_Prescaler 
N  * @{
N  */
N
N#define SPI_BaudRatePrescaler_2         ((uint16_t)0x0000)
N#define SPI_BaudRatePrescaler_4         ((uint16_t)0x0008)
N#define SPI_BaudRatePrescaler_8         ((uint16_t)0x0010)
N#define SPI_BaudRatePrescaler_16        ((uint16_t)0x0018)
N#define SPI_BaudRatePrescaler_32        ((uint16_t)0x0020)
N#define SPI_BaudRatePrescaler_64        ((uint16_t)0x0028)
N#define SPI_BaudRatePrescaler_128       ((uint16_t)0x0030)
N#define SPI_BaudRatePrescaler_256       ((uint16_t)0x0038)
N#define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_4) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_8) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_16) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_32) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_64) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_128) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_256))
X#define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_4) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_8) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_16) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_32) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_64) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_128) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_256))
N/**
N  * @}
N  */ 
N
N/** @defgroup SPI_MSB_LSB_transmission 
N  * @{
N  */
N
N#define SPI_FirstBit_MSB                ((uint16_t)0x0000)
N#define SPI_FirstBit_LSB                ((uint16_t)0x0080)
N#define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) || \
N                               ((BIT) == SPI_FirstBit_LSB))
X#define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) ||                                ((BIT) == SPI_FirstBit_LSB))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_Mode 
N  * @{
N  */
N
N#define I2S_Mode_SlaveTx                ((uint16_t)0x0000)
N#define I2S_Mode_SlaveRx                ((uint16_t)0x0100)
N#define I2S_Mode_MasterTx               ((uint16_t)0x0200)
N#define I2S_Mode_MasterRx               ((uint16_t)0x0300)
N#define IS_I2S_MODE(MODE) (((MODE) == I2S_Mode_SlaveTx) || \
N                           ((MODE) == I2S_Mode_SlaveRx) || \
N                           ((MODE) == I2S_Mode_MasterTx)|| \
N                           ((MODE) == I2S_Mode_MasterRx))
X#define IS_I2S_MODE(MODE) (((MODE) == I2S_Mode_SlaveTx) ||                            ((MODE) == I2S_Mode_SlaveRx) ||                            ((MODE) == I2S_Mode_MasterTx)||                            ((MODE) == I2S_Mode_MasterRx))
N/**
N  * @}
N  */
N  
N
N/** @defgroup SPI_I2S_Standard 
N  * @{
N  */
N
N#define I2S_Standard_Phillips           ((uint16_t)0x0000)
N#define I2S_Standard_MSB                ((uint16_t)0x0010)
N#define I2S_Standard_LSB                ((uint16_t)0x0020)
N#define I2S_Standard_PCMShort           ((uint16_t)0x0030)
N#define I2S_Standard_PCMLong            ((uint16_t)0x00B0)
N#define IS_I2S_STANDARD(STANDARD) (((STANDARD) == I2S_Standard_Phillips) || \
N                                   ((STANDARD) == I2S_Standard_MSB) || \
N                                   ((STANDARD) == I2S_Standard_LSB) || \
N                                   ((STANDARD) == I2S_Standard_PCMShort) || \
N                                   ((STANDARD) == I2S_Standard_PCMLong))
X#define IS_I2S_STANDARD(STANDARD) (((STANDARD) == I2S_Standard_Phillips) ||                                    ((STANDARD) == I2S_Standard_MSB) ||                                    ((STANDARD) == I2S_Standard_LSB) ||                                    ((STANDARD) == I2S_Standard_PCMShort) ||                                    ((STANDARD) == I2S_Standard_PCMLong))
N/**
N  * @}
N  */
N  
N/** @defgroup SPI_I2S_Data_Format 
N  * @{
N  */
N
N#define I2S_DataFormat_16b              ((uint16_t)0x0000)
N#define I2S_DataFormat_16bextended      ((uint16_t)0x0001)
N#define I2S_DataFormat_24b              ((uint16_t)0x0003)
N#define I2S_DataFormat_32b              ((uint16_t)0x0005)
N#define IS_I2S_DATA_FORMAT(FORMAT) (((FORMAT) == I2S_DataFormat_16b) || \
N                                    ((FORMAT) == I2S_DataFormat_16bextended) || \
N                                    ((FORMAT) == I2S_DataFormat_24b) || \
N                                    ((FORMAT) == I2S_DataFormat_32b))
X#define IS_I2S_DATA_FORMAT(FORMAT) (((FORMAT) == I2S_DataFormat_16b) ||                                     ((FORMAT) == I2S_DataFormat_16bextended) ||                                     ((FORMAT) == I2S_DataFormat_24b) ||                                     ((FORMAT) == I2S_DataFormat_32b))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_MCLK_Output 
N  * @{
N  */
N
N#define I2S_MCLKOutput_Enable           ((uint16_t)0x0200)
N#define I2S_MCLKOutput_Disable          ((uint16_t)0x0000)
N#define IS_I2S_MCLK_OUTPUT(OUTPUT) (((OUTPUT) == I2S_MCLKOutput_Enable) || \
N                                    ((OUTPUT) == I2S_MCLKOutput_Disable))
X#define IS_I2S_MCLK_OUTPUT(OUTPUT) (((OUTPUT) == I2S_MCLKOutput_Enable) ||                                     ((OUTPUT) == I2S_MCLKOutput_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_Audio_Frequency 
N  * @{
N  */
N
N#define I2S_AudioFreq_192k               ((uint32_t)192000)
N#define I2S_AudioFreq_96k                ((uint32_t)96000)
N#define I2S_AudioFreq_48k                ((uint32_t)48000)
N#define I2S_AudioFreq_44k                ((uint32_t)44100)
N#define I2S_AudioFreq_32k                ((uint32_t)32000)
N#define I2S_AudioFreq_22k                ((uint32_t)22050)
N#define I2S_AudioFreq_16k                ((uint32_t)16000)
N#define I2S_AudioFreq_11k                ((uint32_t)11025)
N#define I2S_AudioFreq_8k                 ((uint32_t)8000)
N#define I2S_AudioFreq_Default            ((uint32_t)2)
N
N#define IS_I2S_AUDIO_FREQ(FREQ) ((((FREQ) >= I2S_AudioFreq_8k) && \
N                                 ((FREQ) <= I2S_AudioFreq_192k)) || \
N                                 ((FREQ) == I2S_AudioFreq_Default))
X#define IS_I2S_AUDIO_FREQ(FREQ) ((((FREQ) >= I2S_AudioFreq_8k) &&                                  ((FREQ) <= I2S_AudioFreq_192k)) ||                                  ((FREQ) == I2S_AudioFreq_Default))
N/**
N  * @}
N  */
N            
N/** @defgroup SPI_I2S_Clock_Polarity 
N  * @{
N  */
N
N#define I2S_CPOL_Low                    ((uint16_t)0x0000)
N#define I2S_CPOL_High                   ((uint16_t)0x0008)
N#define IS_I2S_CPOL(CPOL) (((CPOL) == I2S_CPOL_Low) || \
N                           ((CPOL) == I2S_CPOL_High))
X#define IS_I2S_CPOL(CPOL) (((CPOL) == I2S_CPOL_Low) ||                            ((CPOL) == I2S_CPOL_High))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_DMA_transfer_requests 
N  * @{
N  */
N
N#define SPI_I2S_DMAReq_Tx               ((uint16_t)0x0002)
N#define SPI_I2S_DMAReq_Rx               ((uint16_t)0x0001)
N#define IS_SPI_I2S_DMAREQ(DMAREQ) ((((DMAREQ) & (uint16_t)0xFFFC) == 0x00) && ((DMAREQ) != 0x00))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_NSS_internal_software_management 
N  * @{
N  */
N
N#define SPI_NSSInternalSoft_Set         ((uint16_t)0x0100)
N#define SPI_NSSInternalSoft_Reset       ((uint16_t)0xFEFF)
N#define IS_SPI_NSS_INTERNAL(INTERNAL) (((INTERNAL) == SPI_NSSInternalSoft_Set) || \
N                                       ((INTERNAL) == SPI_NSSInternalSoft_Reset))
X#define IS_SPI_NSS_INTERNAL(INTERNAL) (((INTERNAL) == SPI_NSSInternalSoft_Set) ||                                        ((INTERNAL) == SPI_NSSInternalSoft_Reset))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_CRC_Transmit_Receive 
N  * @{
N  */
N
N#define SPI_CRC_Tx                      ((uint8_t)0x00)
N#define SPI_CRC_Rx                      ((uint8_t)0x01)
N#define IS_SPI_CRC(CRC) (((CRC) == SPI_CRC_Tx) || ((CRC) == SPI_CRC_Rx))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_direction_transmit_receive 
N  * @{
N  */
N
N#define SPI_Direction_Rx                ((uint16_t)0xBFFF)
N#define SPI_Direction_Tx                ((uint16_t)0x4000)
N#define IS_SPI_DIRECTION(DIRECTION) (((DIRECTION) == SPI_Direction_Rx) || \
N                                     ((DIRECTION) == SPI_Direction_Tx))
X#define IS_SPI_DIRECTION(DIRECTION) (((DIRECTION) == SPI_Direction_Rx) ||                                      ((DIRECTION) == SPI_Direction_Tx))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_interrupts_definition 
N  * @{
N  */
N
N#define SPI_I2S_IT_TXE                  ((uint8_t)0x71)
N#define SPI_I2S_IT_RXNE                 ((uint8_t)0x60)
N#define SPI_I2S_IT_ERR                  ((uint8_t)0x50)
N#define I2S_IT_UDR                      ((uint8_t)0x53)
N#define SPI_I2S_IT_TIFRFE               ((uint8_t)0x58)
N
N#define IS_SPI_I2S_CONFIG_IT(IT) (((IT) == SPI_I2S_IT_TXE) || \
N                                  ((IT) == SPI_I2S_IT_RXNE) || \
N                                  ((IT) == SPI_I2S_IT_ERR))
X#define IS_SPI_I2S_CONFIG_IT(IT) (((IT) == SPI_I2S_IT_TXE) ||                                   ((IT) == SPI_I2S_IT_RXNE) ||                                   ((IT) == SPI_I2S_IT_ERR))
N
N#define SPI_I2S_IT_OVR                  ((uint8_t)0x56)
N#define SPI_IT_MODF                     ((uint8_t)0x55)
N#define SPI_IT_CRCERR                   ((uint8_t)0x54)
N
N#define IS_SPI_I2S_CLEAR_IT(IT) (((IT) == SPI_IT_CRCERR))
N
N#define IS_SPI_I2S_GET_IT(IT) (((IT) == SPI_I2S_IT_RXNE)|| ((IT) == SPI_I2S_IT_TXE) || \
N                               ((IT) == SPI_IT_CRCERR)  || ((IT) == SPI_IT_MODF) || \
N                               ((IT) == SPI_I2S_IT_OVR) || ((IT) == I2S_IT_UDR) ||\
N                               ((IT) == SPI_I2S_IT_TIFRFE))
X#define IS_SPI_I2S_GET_IT(IT) (((IT) == SPI_I2S_IT_RXNE)|| ((IT) == SPI_I2S_IT_TXE) ||                                ((IT) == SPI_IT_CRCERR)  || ((IT) == SPI_IT_MODF) ||                                ((IT) == SPI_I2S_IT_OVR) || ((IT) == I2S_IT_UDR) ||                               ((IT) == SPI_I2S_IT_TIFRFE))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_flags_definition 
N  * @{
N  */
N
N#define SPI_I2S_FLAG_RXNE               ((uint16_t)0x0001)
N#define SPI_I2S_FLAG_TXE                ((uint16_t)0x0002)
N#define I2S_FLAG_CHSIDE                 ((uint16_t)0x0004)
N#define I2S_FLAG_UDR                    ((uint16_t)0x0008)
N#define SPI_FLAG_CRCERR                 ((uint16_t)0x0010)
N#define SPI_FLAG_MODF                   ((uint16_t)0x0020)
N#define SPI_I2S_FLAG_OVR                ((uint16_t)0x0040)
N#define SPI_I2S_FLAG_BSY                ((uint16_t)0x0080)
N#define SPI_I2S_FLAG_TIFRFE             ((uint16_t)0x0100)
N
N#define IS_SPI_I2S_CLEAR_FLAG(FLAG) (((FLAG) == SPI_FLAG_CRCERR))
N#define IS_SPI_I2S_GET_FLAG(FLAG) (((FLAG) == SPI_I2S_FLAG_BSY) || ((FLAG) == SPI_I2S_FLAG_OVR) || \
N                                   ((FLAG) == SPI_FLAG_MODF) || ((FLAG) == SPI_FLAG_CRCERR) || \
N                                   ((FLAG) == I2S_FLAG_UDR) || ((FLAG) == I2S_FLAG_CHSIDE) || \
N                                   ((FLAG) == SPI_I2S_FLAG_TXE) || ((FLAG) == SPI_I2S_FLAG_RXNE)|| \
N                                   ((FLAG) == SPI_I2S_FLAG_TIFRFE))
X#define IS_SPI_I2S_GET_FLAG(FLAG) (((FLAG) == SPI_I2S_FLAG_BSY) || ((FLAG) == SPI_I2S_FLAG_OVR) ||                                    ((FLAG) == SPI_FLAG_MODF) || ((FLAG) == SPI_FLAG_CRCERR) ||                                    ((FLAG) == I2S_FLAG_UDR) || ((FLAG) == I2S_FLAG_CHSIDE) ||                                    ((FLAG) == SPI_I2S_FLAG_TXE) || ((FLAG) == SPI_I2S_FLAG_RXNE)||                                    ((FLAG) == SPI_I2S_FLAG_TIFRFE))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_CRC_polynomial 
N  * @{
N  */
N
N#define IS_SPI_CRC_POLYNOMIAL(POLYNOMIAL) ((POLYNOMIAL) >= 0x1)
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_Legacy 
N  * @{
N  */
N
N#define SPI_DMAReq_Tx                SPI_I2S_DMAReq_Tx
N#define SPI_DMAReq_Rx                SPI_I2S_DMAReq_Rx
N#define SPI_IT_TXE                   SPI_I2S_IT_TXE
N#define SPI_IT_RXNE                  SPI_I2S_IT_RXNE
N#define SPI_IT_ERR                   SPI_I2S_IT_ERR
N#define SPI_IT_OVR                   SPI_I2S_IT_OVR
N#define SPI_FLAG_RXNE                SPI_I2S_FLAG_RXNE
N#define SPI_FLAG_TXE                 SPI_I2S_FLAG_TXE
N#define SPI_FLAG_OVR                 SPI_I2S_FLAG_OVR
N#define SPI_FLAG_BSY                 SPI_I2S_FLAG_BSY
N#define SPI_DeInit                   SPI_I2S_DeInit
N#define SPI_ITConfig                 SPI_I2S_ITConfig
N#define SPI_DMACmd                   SPI_I2S_DMACmd
N#define SPI_SendData                 SPI_I2S_SendData
N#define SPI_ReceiveData              SPI_I2S_ReceiveData
N#define SPI_GetFlagStatus            SPI_I2S_GetFlagStatus
N#define SPI_ClearFlag                SPI_I2S_ClearFlag
N#define SPI_GetITStatus              SPI_I2S_GetITStatus
N#define SPI_ClearITPendingBit        SPI_I2S_ClearITPendingBit
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/ 
N
N/*  Function used to set the SPI configuration to the default reset state *****/ 
Nvoid SPI_I2S_DeInit(SPI_TypeDef* SPIx);
N
N/* Initialization and Configuration functions *********************************/
Nvoid SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct);
Nvoid I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct);
Nvoid SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct);
Nvoid I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct);
Nvoid SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);
Nvoid I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);
Nvoid SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize);
Nvoid SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction);
Nvoid SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft);
Nvoid SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState);
Nvoid SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState);
N
Nvoid I2S_FullDuplexConfig(SPI_TypeDef* I2Sxext, I2S_InitTypeDef* I2S_InitStruct);
N
N/* Data transfers functions ***************************************************/ 
Nvoid SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data);
Nuint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx);
N
N/* Hardware CRC Calculation functions *****************************************/
Nvoid SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState);
Nvoid SPI_TransmitCRC(SPI_TypeDef* SPIx);
Nuint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC);
Nuint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx);
N
N/* DMA transfers management functions *****************************************/
Nvoid SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState);
N
N/* Interrupts and flags management functions **********************************/
Nvoid SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState);
NFlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
Nvoid SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
NITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
Nvoid SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F4xx_SPI_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 48 "..\..\Service\stm32f4xx_conf.h" 2
N#include "stm32f4xx_syscfg.h"
L 1 "..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\stm32f4xx_syscfg.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_syscfg.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    04-November-2016
N  * @brief   This file contains all the functions prototypes for the SYSCFG firmware
N  *          library. 
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_SYSCFG_H
N#define __STM32F4xx_SYSCFG_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
N
N/** @addtogroup STM32F4xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup SYSCFG
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/** @defgroup SYSCFG_Exported_Constants 
N  * @{
N  */ 
N#if defined(STM32F413_423xx)
X#if 0L
S/** @defgroup BITSTREAM_CLOCK  Bit Stream clock source selection
S  * @{
S  */
S#define BITSTREAM_CLOCK_DFSDM2     SYSCFG_MCHDLYCR_BSCKSEL
S#define BITSTREAM_CLOCK_TIM2OC1    (uint32_t)0x00000000
S/**
S  * @}
S  */
S  
S/** @defgroup MCHDLY_CLOCK  MCHDLY Clock enable
S  * @{
S  */
S#define MCHDLY_CLOCK_DFSDM2       SYSCFG_MCHDLYCR_MCHDLY2EN
S#define MCHDLY_CLOCK_DFSDM1       SYSCFG_MCHDLYCR_MCHDLY1EN
S/**
S  * @}
S  */  
S  
S/** @defgroup DFSDM_CLOCKIN_SOURCE   DFSDM Clock In Source Selection
S  * @{
S  */
S#define DFSDM2_CKIN_PAD           (uint32_t)0x00000000
S#define DFSDM2_CKIN_DM            SYSCFG_MCHDLYCR_DFSDM2CFG
S#define DFSDM1_CKIN_PAD           (uint32_t)0x00000000
S#define DFSDM1_CKIN_DM            SYSCFG_MCHDLYCR_DFSDM1CFG
S/**
S  * @}
S  */
S  
S/** @defgroup DFSDM_CLOCKOUT_SOURCE   DFSDM Clock Source Selection
S  * @{
S  */
S#define DFSDM2_CKOUT_DFSDM2       (uint32_t)0x00000000
S#define DFSDM2_CKOUT_M27          SYSCFG_MCHDLYCR_DFSDM2CKOSEL
S#define DFSDM1_CKOUT_DFSDM1       (uint32_t)0x00000000U
S#define DFSDM1_CKOUT_M27          SYSCFG_MCHDLYCR_DFSDM1CKOSEL
S/**
S  * @}
S  */
S  
S/** @defgroup DFSDM_DATAIN0_SOURCE   DFSDM Source Selection For DATAIN0
S  * @{
S  */
S#define DATAIN0_DFSDM2_PAD        (uint32_t)0x00000000
S#define DATAIN0_DFSDM2_DATAIN1    SYSCFG_MCHDLYCR_DFSDM2D0SEL
S#define DATAIN0_DFSDM1_PAD        (uint32_t)0x00000000
S#define DATAIN0_DFSDM1_DATAIN1    SYSCFG_MCHDLYCR_DFSDM1D0SEL
S/**
S  * @}
S  */  
S  
S/** @defgroup DFSDM_DATAIN2_SOURCE   DFSDM Source Selection For DATAIN2
S  * @{
S  */
S#define DATAIN2_DFSDM2_PAD        (uint32_t)0x00000000
S#define DATAIN2_DFSDM2_DATAIN3    SYSCFG_MCHDLYCR_DFSDM2D2SEL
S#define DATAIN2_DFSDM1_PAD        (uint32_t)0x00000000
S#define DATAIN2_DFSDM1_DATAIN3    SYSCFG_MCHDLYCR_DFSDM1D2SEL
S/**
S  * @}
S  */ 
S 
S/** @defgroup DFSDM_DATAIN4_SOURCE   DFSDM Source Selection For DATAIN4
S  * @{
S  */
S#define DATAIN4_DFSDM2_PAD        (uint32_t)0x00000000
S#define DATAIN4_DFSDM2_DATAIN5    SYSCFG_MCHDLYCR_DFSDM2D4SEL
S/**
S  * @}
S  */ 
S  
S/** @defgroup DFSDM_DATAIN6_SOURCE   DFSDM Source Selection For DATAIN6
S  * @{
S  */
S#define DATAIN6_DFSDM2_PAD        (uint32_t)0x00000000
S#define DATAIN6_DFSDM2_DATAIN7    SYSCFG_MCHDLYCR_DFSDM2D6SEL
S/**
S  * @}
S  */ 
S
S/** @defgroup DFSDM_CLKIN_SOURCE   DFSDM1 Source Selection For CLKIN
S  * @{
S  */
S#define DFSDM1_CLKIN0_TIM4OC2      (uint32_t)0x00000000
S#define DFSDM1_CLKIN2_TIM4OC2      SYSCFG_MCHDLYCR_DFSDM1CK02SEL
S#define DFSDM1_CLKIN1_TIM4OC1      (uint32_t)0x00000000
S#define DFSDM1_CLKIN3_TIM4OC1      SYSCFG_MCHDLYCR_DFSDM1CK13SEL
S/**
S  * @}
S  */ 
S  
S/** @defgroup DFSDM_CLKIN_SOURCE   DFSDM2 Source Selection For CLKIN
S  * @{
S  */
S#define DFSDM2_CLKIN0_TIM3OC4      (uint32_t)0x00000000
S#define DFSDM2_CLKIN4_TIM3OC4      SYSCFG_MCHDLYCR_DFSDM2CK04SEL
S#define DFSDM2_CLKIN1_TIM3OC3      (uint32_t)0x00000000
S#define DFSDM2_CLKIN5_TIM3OC3      SYSCFG_MCHDLYCR_DFSDM2CK15SEL
S#define DFSDM2_CLKIN2_TIM3OC2      (uint32_t)0x00000000
S#define DFSDM2_CLKIN6_TIM3OC2      SYSCFG_MCHDLYCR_DFSDM2CK26SEL
S#define DFSDM2_CLKIN3_TIM3OC1      (uint32_t)0x00000000
S#define DFSDM2_CLKIN7_TIM3OC1      SYSCFG_MCHDLYCR_DFSDM2CK37SEL
S/**
S  * @}
S  */      
N#endif /* STM32F413_423xx */
N
N/** @defgroup SYSCFG_EXTI_Port_Sources 
N  * @{
N  */ 
N#define EXTI_PortSourceGPIOA       ((uint8_t)0x00)
N#define EXTI_PortSourceGPIOB       ((uint8_t)0x01)
N#define EXTI_PortSourceGPIOC       ((uint8_t)0x02)
N#define EXTI_PortSourceGPIOD       ((uint8_t)0x03)
N#define EXTI_PortSourceGPIOE       ((uint8_t)0x04)
N#define EXTI_PortSourceGPIOF       ((uint8_t)0x05)
N#define EXTI_PortSourceGPIOG       ((uint8_t)0x06)
N#define EXTI_PortSourceGPIOH       ((uint8_t)0x07)
N#define EXTI_PortSourceGPIOI       ((uint8_t)0x08)
N#define EXTI_PortSourceGPIOJ       ((uint8_t)0x09)
N#define EXTI_PortSourceGPIOK       ((uint8_t)0x0A)
N
N#define IS_EXTI_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == EXTI_PortSourceGPIOA) || \
N                                         ((PORTSOURCE) == EXTI_PortSourceGPIOB) || \
N                                         ((PORTSOURCE) == EXTI_PortSourceGPIOC) || \
N                                         ((PORTSOURCE) == EXTI_PortSourceGPIOD) || \
N                                         ((PORTSOURCE) == EXTI_PortSourceGPIOE) || \
N                                         ((PORTSOURCE) == EXTI_PortSourceGPIOF) || \
N                                         ((PORTSOURCE) == EXTI_PortSourceGPIOG) || \
N                                         ((PORTSOURCE) == EXTI_PortSourceGPIOH) || \
N                                         ((PORTSOURCE) == EXTI_PortSourceGPIOI) || \
N                                         ((PORTSOURCE) == EXTI_PortSourceGPIOJ) || \
N                                         ((PORTSOURCE) == EXTI_PortSourceGPIOK))
X#define IS_EXTI_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == EXTI_PortSourceGPIOA) ||                                          ((PORTSOURCE) == EXTI_PortSourceGPIOB) ||                                          ((PORTSOURCE) == EXTI_PortSourceGPIOC) ||                                          ((PORTSOURCE) == EXTI_PortSourceGPIOD) ||                                          ((PORTSOURCE) == EXTI_PortSourceGPIOE) ||                                          ((PORTSOURCE) == EXTI_PortSourceGPIOF) ||                                          ((PORTSOURCE) == EXTI_PortSourceGPIOG) ||                                          ((PORTSOURCE) == EXTI_PortSourceGPIOH) ||                                          ((PORTSOURCE) == EXTI_PortSourceGPIOI) ||                                          ((PORTSOURCE) == EXTI_PortSourceGPIOJ) ||                                          ((PORTSOURCE) == EXTI_PortSourceGPIOK))
N                                         
N/**
N  * @}
N  */ 
N
N
N/** @defgroup SYSCFG_EXTI_Pin_Sources 
N  * @{
N  */ 
N#define EXTI_PinSource0            ((uint8_t)0x00)
N#define EXTI_PinSource1            ((uint8_t)0x01)
N#define EXTI_PinSource2            ((uint8_t)0x02)
N#define EXTI_PinSource3            ((uint8_t)0x03)
N#define EXTI_PinSource4            ((uint8_t)0x04)
N#define EXTI_PinSource5            ((uint8_t)0x05)
N#define EXTI_PinSource6            ((uint8_t)0x06)
N#define EXTI_PinSource7            ((uint8_t)0x07)
N#define EXTI_PinSource8            ((uint8_t)0x08)
N#define EXTI_PinSource9            ((uint8_t)0x09)
N#define EXTI_PinSource10           ((uint8_t)0x0A)
N#define EXTI_PinSource11           ((uint8_t)0x0B)
N#define EXTI_PinSource12           ((uint8_t)0x0C)
N#define EXTI_PinSource13           ((uint8_t)0x0D)
N#define EXTI_PinSource14           ((uint8_t)0x0E)
N#define EXTI_PinSource15           ((uint8_t)0x0F)
N#define IS_EXTI_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == EXTI_PinSource0)  || \
N                                       ((PINSOURCE) == EXTI_PinSource1)  || \
N                                       ((PINSOURCE) == EXTI_PinSource2)  || \
N                                       ((PINSOURCE) == EXTI_PinSource3)  || \
N                                       ((PINSOURCE) == EXTI_PinSource4)  || \
N                                       ((PINSOURCE) == EXTI_PinSource5)  || \
N                                       ((PINSOURCE) == EXTI_PinSource6)  || \
N                                       ((PINSOURCE) == EXTI_PinSource7)  || \
N                                       ((PINSOURCE) == EXTI_PinSource8)  || \
N                                       ((PINSOURCE) == EXTI_PinSource9)  || \
N                                       ((PINSOURCE) == EXTI_PinSource10) || \
N                                       ((PINSOURCE) == EXTI_PinSource11) || \
N                                       ((PINSOURCE) == EXTI_PinSource12) || \
N                                       ((PINSOURCE) == EXTI_PinSource13) || \
N                                       ((PINSOURCE) == EXTI_PinSource14) || \
N                                       ((PINSOURCE) == EXTI_PinSource15))
X#define IS_EXTI_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == EXTI_PinSource0)  ||                                        ((PINSOURCE) == EXTI_PinSource1)  ||                                        ((PINSOURCE) == EXTI_PinSource2)  ||                                        ((PINSOURCE) == EXTI_PinSource3)  ||                                        ((PINSOURCE) == EXTI_PinSource4)  ||                                        ((PINSOURCE) == EXTI_PinSource5)  ||                                        ((PINSOURCE) == EXTI_PinSource6)  ||                                        ((PINSOURCE) == EXTI_PinSource7)  ||                                        ((PINSOURCE) == EXTI_PinSource8)  ||                                        ((PINSOURCE) == EXTI_PinSource9)  ||                                        ((PINSOURCE) == EXTI_PinSource10) ||                                        ((PINSOURCE) == EXTI_PinSource11) ||                                        ((PINSOURCE) == EXTI_PinSource12) ||                                        ((PINSOURCE) == EXTI_PinSource13) ||                                        ((PINSOURCE) == EXTI_PinSource14) ||                                        ((PINSOURCE) == EXTI_PinSource15))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup SYSCFG_Memory_Remap_Config 
N  * @{
N  */ 
N#define SYSCFG_MemoryRemap_Flash       ((uint8_t)0x00)
N#define SYSCFG_MemoryRemap_SystemFlash ((uint8_t)0x01)
N#define SYSCFG_MemoryRemap_SRAM        ((uint8_t)0x03)
N#define SYSCFG_MemoryRemap_SDRAM       ((uint8_t)0x04)
N
N#if defined (STM32F40_41xxx) || defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 1L || 0L || 0L
N#define SYSCFG_MemoryRemap_FSMC        ((uint8_t)0x02) 
N#endif /* STM32F40_41xxx || STM32F412xG || STM32F413_423xx */
N
N#if defined (STM32F427_437xx) || defined (STM32F429_439xx)
X#if 0L || 0L
S#define SYSCFG_MemoryRemap_FMC         ((uint8_t)0x02) 
N#endif /* STM32F427_437xx ||  STM32F429_439xx */  
N
N#if defined (STM32F446xx) || defined (STM32F469_479xx)
X#if 0L || 0L
S#define SYSCFG_MemoryRemap_ExtMEM      ((uint8_t)0x02) 
N#endif /*  STM32F446xx || STM32F469_479xx */ 
N
N#if defined (STM32F40_41xxx) || defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 1L || 0L || 0L
N#define IS_SYSCFG_MEMORY_REMAP_CONFING(REMAP) (((REMAP) == SYSCFG_MemoryRemap_Flash)       || \
N                                               ((REMAP) == SYSCFG_MemoryRemap_SystemFlash) || \
N                                               ((REMAP) == SYSCFG_MemoryRemap_SRAM)        || \
N                                               ((REMAP) == SYSCFG_MemoryRemap_FSMC))
X#define IS_SYSCFG_MEMORY_REMAP_CONFING(REMAP) (((REMAP) == SYSCFG_MemoryRemap_Flash)       ||                                                ((REMAP) == SYSCFG_MemoryRemap_SystemFlash) ||                                                ((REMAP) == SYSCFG_MemoryRemap_SRAM)        ||                                                ((REMAP) == SYSCFG_MemoryRemap_FSMC))
N#endif /* STM32F40_41xxx || STM32F412xG || STM32F413_423xx */
N
N#if defined (STM32F401xx) || defined (STM32F410xx) || defined (STM32F411xE)
X#if 0L || 0L || 0L
S#define IS_SYSCFG_MEMORY_REMAP_CONFING(REMAP) (((REMAP) == SYSCFG_MemoryRemap_Flash)       || \
S                                               ((REMAP) == SYSCFG_MemoryRemap_SystemFlash) || \
S                                               ((REMAP) == SYSCFG_MemoryRemap_SRAM))
X#define IS_SYSCFG_MEMORY_REMAP_CONFING(REMAP) (((REMAP) == SYSCFG_MemoryRemap_Flash)       ||                                                ((REMAP) == SYSCFG_MemoryRemap_SystemFlash) ||                                                ((REMAP) == SYSCFG_MemoryRemap_SRAM))
N#endif /* STM32F401xx || STM32F410xx || STM32F411xE */
N
N#if defined (STM32F427_437xx) || defined (STM32F429_439xx)
X#if 0L || 0L
S#define IS_SYSCFG_MEMORY_REMAP_CONFING(REMAP) (((REMAP) == SYSCFG_MemoryRemap_Flash)       || \
S                                               ((REMAP) == SYSCFG_MemoryRemap_SystemFlash) || \
S                                               ((REMAP) == SYSCFG_MemoryRemap_SRAM)        || \
S                                               ((REMAP) == SYSCFG_MemoryRemap_SDRAM)       || \
S                                               ((REMAP) == SYSCFG_MemoryRemap_FMC))
X#define IS_SYSCFG_MEMORY_REMAP_CONFING(REMAP) (((REMAP) == SYSCFG_MemoryRemap_Flash)       ||                                                ((REMAP) == SYSCFG_MemoryRemap_SystemFlash) ||                                                ((REMAP) == SYSCFG_MemoryRemap_SRAM)        ||                                                ((REMAP) == SYSCFG_MemoryRemap_SDRAM)       ||                                                ((REMAP) == SYSCFG_MemoryRemap_FMC))
N#endif /* STM32F427_437xx ||  STM32F429_439xx */
N
N#if defined (STM32F446xx) || defined (STM32F469_479xx)
X#if 0L || 0L
S#define IS_SYSCFG_MEMORY_REMAP_CONFING(REMAP) (((REMAP) == SYSCFG_MemoryRemap_Flash)       || \
S                                               ((REMAP) == SYSCFG_MemoryRemap_ExtMEM)      || \
S                                               ((REMAP) == SYSCFG_MemoryRemap_SystemFlash) || \
S                                               ((REMAP) == SYSCFG_MemoryRemap_SRAM)        || \
S                                               ((REMAP) == SYSCFG_MemoryRemap_SDRAM))
X#define IS_SYSCFG_MEMORY_REMAP_CONFING(REMAP) (((REMAP) == SYSCFG_MemoryRemap_Flash)       ||                                                ((REMAP) == SYSCFG_MemoryRemap_ExtMEM)      ||                                                ((REMAP) == SYSCFG_MemoryRemap_SystemFlash) ||                                                ((REMAP) == SYSCFG_MemoryRemap_SRAM)        ||                                                ((REMAP) == SYSCFG_MemoryRemap_SDRAM))
N#endif /* STM32F446xx || STM32F469_479xx */
N
N#if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 0L || 0L || 0L
S#define SYSCFG_Break_PVD             SYSCFG_CFGR2_PVDL
S#define SYSCFG_Break_HardFault       SYSCFG_CFGR2_CLL
S
S#define IS_SYSCFG_LOCK_CONFIG(BREAK) (((BREAK) == SYSCFG_Break_PVD)       || \
S                                      ((BREAK) == SYSCFG_Break_HardFault))
X#define IS_SYSCFG_LOCK_CONFIG(BREAK) (((BREAK) == SYSCFG_Break_PVD)       ||                                       ((BREAK) == SYSCFG_Break_HardFault))
N#endif /* STM32F410xx || STM32F412xG || STM32F413_423xx */
N/**
N  * @}
N  */ 
N
N
N/** @defgroup SYSCFG_ETHERNET_Media_Interface 
N  * @{
N  */ 
N#define SYSCFG_ETH_MediaInterface_MII    ((uint32_t)0x00000000)
N#define SYSCFG_ETH_MediaInterface_RMII   ((uint32_t)0x00000001)
N
N#define IS_SYSCFG_ETH_MEDIA_INTERFACE(INTERFACE) (((INTERFACE) == SYSCFG_ETH_MediaInterface_MII) || \
N                                                 ((INTERFACE) == SYSCFG_ETH_MediaInterface_RMII))
X#define IS_SYSCFG_ETH_MEDIA_INTERFACE(INTERFACE) (((INTERFACE) == SYSCFG_ETH_MediaInterface_MII) ||                                                  ((INTERFACE) == SYSCFG_ETH_MediaInterface_RMII))
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/ 
N 
Nvoid       SYSCFG_DeInit(void);
Nvoid       SYSCFG_MemoryRemapConfig(uint8_t SYSCFG_MemoryRemap);
Nvoid       SYSCFG_MemorySwappingBank(FunctionalState NewState);
Nvoid       SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex);
Nvoid       SYSCFG_ETH_MediaInterfaceConfig(uint32_t SYSCFG_ETH_MediaInterface); 
Nvoid       SYSCFG_CompensationCellCmd(FunctionalState NewState); 
NFlagStatus SYSCFG_GetCompensationCellStatus(void);
N#if defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx)
X#if 0L || 0L || 0L
Svoid       SYSCFG_BreakConfig(uint32_t SYSCFG_Break);
N#endif /* STM32F410xx || STM32F412xG || STM32F413_423xx */
N#if defined(STM32F413_423xx)
X#if 0L
Svoid DFSDM_BitstreamClock_SourceSelection(uint32_t source);
Svoid DFSDM_DisableDelayClock(uint32_t MCHDLY);
Svoid DFSDM_EnableDelayClock(uint32_t MCHDLY);
Svoid DFSDM_ClockIn_SourceSelection(uint32_t source);
Svoid DFSDM_ClockOut_SourceSelection(uint32_t source);
Svoid DFSDM_DataIn0_SourceSelection(uint32_t source);
Svoid DFSDM_DataIn2_SourceSelection(uint32_t source);
Svoid DFSDM_DataIn4_SourceSelection(uint32_t source);
Svoid DFSDM_DataIn6_SourceSelection(uint32_t source);
Svoid DFSDM1_BitStreamClk_Config(uint32_t source);
Svoid DFSDM2_BitStreamClk_Config(uint32_t source);
N#endif /* STM32F413_423xx */
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F4xx_SYSCFG_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 49 "..\..\Service\stm32f4xx_conf.h" 2
N#include "stm32f4xx_tim.h"
L 1 "..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\stm32f4xx_tim.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_tim.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    04-November-2016
N  * @brief   This file contains all the functions prototypes for the TIM firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_TIM_H
N#define __STM32F4xx_TIM_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
N
N/** @addtogroup STM32F4xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup TIM
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  TIM Time Base Init structure definition  
N  * @note   This structure is used with all TIMx except for TIM6 and TIM7.  
N  */
N
Ntypedef struct
N{
N  uint16_t TIM_Prescaler;         /*!< Specifies the prescaler value used to divide the TIM clock.
N                                       This parameter can be a number between 0x0000 and 0xFFFF */
N
N  uint16_t TIM_CounterMode;       /*!< Specifies the counter mode.
N                                       This parameter can be a value of @ref TIM_Counter_Mode */
N
N  uint32_t TIM_Period;            /*!< Specifies the period value to be loaded into the active
N                                       Auto-Reload Register at the next update event.
N                                       This parameter must be a number between 0x0000 and 0xFFFF.  */ 
N
N  uint16_t TIM_ClockDivision;     /*!< Specifies the clock division.
N                                      This parameter can be a value of @ref TIM_Clock_Division_CKD */
N
N  uint8_t TIM_RepetitionCounter;  /*!< Specifies the repetition counter value. Each time the RCR downcounter
N                                       reaches zero, an update event is generated and counting restarts
N                                       from the RCR value (N).
N                                       This means in PWM mode that (N+1) corresponds to:
N                                          - the number of PWM periods in edge-aligned mode
N                                          - the number of half PWM period in center-aligned mode
N                                       This parameter must be a number between 0x00 and 0xFF. 
N                                       @note This parameter is valid only for TIM1 and TIM8. */
N} TIM_TimeBaseInitTypeDef; 
N
N/** 
N  * @brief  TIM Output Compare Init structure definition  
N  */
N
Ntypedef struct
N{
N  uint16_t TIM_OCMode;        /*!< Specifies the TIM mode.
N                                   This parameter can be a value of @ref TIM_Output_Compare_and_PWM_modes */
N
N  uint16_t TIM_OutputState;   /*!< Specifies the TIM Output Compare state.
N                                   This parameter can be a value of @ref TIM_Output_Compare_State */
N
N  uint16_t TIM_OutputNState;  /*!< Specifies the TIM complementary Output Compare state.
N                                   This parameter can be a value of @ref TIM_Output_Compare_N_State
N                                   @note This parameter is valid only for TIM1 and TIM8. */
N
N  uint32_t TIM_Pulse;         /*!< Specifies the pulse value to be loaded into the Capture Compare Register. 
N                                   This parameter can be a number between 0x0000 and 0xFFFF */
N
N  uint16_t TIM_OCPolarity;    /*!< Specifies the output polarity.
N                                   This parameter can be a value of @ref TIM_Output_Compare_Polarity */
N
N  uint16_t TIM_OCNPolarity;   /*!< Specifies the complementary output polarity.
N                                   This parameter can be a value of @ref TIM_Output_Compare_N_Polarity
N                                   @note This parameter is valid only for TIM1 and TIM8. */
N
N  uint16_t TIM_OCIdleState;   /*!< Specifies the TIM Output Compare pin state during Idle state.
N                                   This parameter can be a value of @ref TIM_Output_Compare_Idle_State
N                                   @note This parameter is valid only for TIM1 and TIM8. */
N
N  uint16_t TIM_OCNIdleState;  /*!< Specifies the TIM Output Compare pin state during Idle state.
N                                   This parameter can be a value of @ref TIM_Output_Compare_N_Idle_State
N                                   @note This parameter is valid only for TIM1 and TIM8. */
N} TIM_OCInitTypeDef;
N
N/** 
N  * @brief  TIM Input Capture Init structure definition  
N  */
N
Ntypedef struct
N{
N
N  uint16_t TIM_Channel;      /*!< Specifies the TIM channel.
N                                  This parameter can be a value of @ref TIM_Channel */
N
N  uint16_t TIM_ICPolarity;   /*!< Specifies the active edge of the input signal.
N                                  This parameter can be a value of @ref TIM_Input_Capture_Polarity */
N
N  uint16_t TIM_ICSelection;  /*!< Specifies the input.
N                                  This parameter can be a value of @ref TIM_Input_Capture_Selection */
N
N  uint16_t TIM_ICPrescaler;  /*!< Specifies the Input Capture Prescaler.
N                                  This parameter can be a value of @ref TIM_Input_Capture_Prescaler */
N
N  uint16_t TIM_ICFilter;     /*!< Specifies the input capture filter.
N                                  This parameter can be a number between 0x0 and 0xF */
N} TIM_ICInitTypeDef;
N
N/** 
N  * @brief  BDTR structure definition 
N  * @note   This structure is used only with TIM1 and TIM8.    
N  */
N
Ntypedef struct
N{
N
N  uint16_t TIM_OSSRState;        /*!< Specifies the Off-State selection used in Run mode.
N                                      This parameter can be a value of @ref TIM_OSSR_Off_State_Selection_for_Run_mode_state */
N
N  uint16_t TIM_OSSIState;        /*!< Specifies the Off-State used in Idle state.
N                                      This parameter can be a value of @ref TIM_OSSI_Off_State_Selection_for_Idle_mode_state */
N
N  uint16_t TIM_LOCKLevel;        /*!< Specifies the LOCK level parameters.
N                                      This parameter can be a value of @ref TIM_Lock_level */ 
N
N  uint16_t TIM_DeadTime;         /*!< Specifies the delay time between the switching-off and the
N                                      switching-on of the outputs.
N                                      This parameter can be a number between 0x00 and 0xFF  */
N
N  uint16_t TIM_Break;            /*!< Specifies whether the TIM Break input is enabled or not. 
N                                      This parameter can be a value of @ref TIM_Break_Input_enable_disable */
N
N  uint16_t TIM_BreakPolarity;    /*!< Specifies the TIM Break Input pin polarity.
N                                      This parameter can be a value of @ref TIM_Break_Polarity */
N
N  uint16_t TIM_AutomaticOutput;  /*!< Specifies whether the TIM Automatic Output feature is enabled or not. 
N                                      This parameter can be a value of @ref TIM_AOE_Bit_Set_Reset */
N} TIM_BDTRInitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup TIM_Exported_constants 
N  * @{
N  */
N
N#define IS_TIM_ALL_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
N                                   ((PERIPH) == TIM2) || \
N                                   ((PERIPH) == TIM3) || \
N                                   ((PERIPH) == TIM4) || \
N                                   ((PERIPH) == TIM5) || \
N                                   ((PERIPH) == TIM6) || \
N                                   ((PERIPH) == TIM7) || \
N                                   ((PERIPH) == TIM8) || \
N                                   ((PERIPH) == TIM9) || \
N                                   ((PERIPH) == TIM10) || \
N                                   ((PERIPH) == TIM11) || \
N                                   ((PERIPH) == TIM12) || \
N                                   (((PERIPH) == TIM13) || \
N                                   ((PERIPH) == TIM14)))
X#define IS_TIM_ALL_PERIPH(PERIPH) (((PERIPH) == TIM1) ||                                    ((PERIPH) == TIM2) ||                                    ((PERIPH) == TIM3) ||                                    ((PERIPH) == TIM4) ||                                    ((PERIPH) == TIM5) ||                                    ((PERIPH) == TIM6) ||                                    ((PERIPH) == TIM7) ||                                    ((PERIPH) == TIM8) ||                                    ((PERIPH) == TIM9) ||                                    ((PERIPH) == TIM10) ||                                    ((PERIPH) == TIM11) ||                                    ((PERIPH) == TIM12) ||                                    (((PERIPH) == TIM13) ||                                    ((PERIPH) == TIM14)))
N/* LIST1: TIM1, TIM2, TIM3, TIM4, TIM5, TIM8, TIM9, TIM10, TIM11, TIM12, TIM13 and TIM14 */                                         
N#define IS_TIM_LIST1_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
N                                     ((PERIPH) == TIM2) || \
N                                     ((PERIPH) == TIM3) || \
N                                     ((PERIPH) == TIM4) || \
N                                     ((PERIPH) == TIM5) || \
N                                     ((PERIPH) == TIM8) || \
N                                     ((PERIPH) == TIM9) || \
N                                     ((PERIPH) == TIM10) || \
N                                     ((PERIPH) == TIM11) || \
N                                     ((PERIPH) == TIM12) || \
N                                     ((PERIPH) == TIM13) || \
N                                     ((PERIPH) == TIM14))
X#define IS_TIM_LIST1_PERIPH(PERIPH) (((PERIPH) == TIM1) ||                                      ((PERIPH) == TIM2) ||                                      ((PERIPH) == TIM3) ||                                      ((PERIPH) == TIM4) ||                                      ((PERIPH) == TIM5) ||                                      ((PERIPH) == TIM8) ||                                      ((PERIPH) == TIM9) ||                                      ((PERIPH) == TIM10) ||                                      ((PERIPH) == TIM11) ||                                      ((PERIPH) == TIM12) ||                                      ((PERIPH) == TIM13) ||                                      ((PERIPH) == TIM14))
N                                     
N/* LIST2: TIM1, TIM2, TIM3, TIM4, TIM5, TIM8, TIM9 and TIM12 */
N#define IS_TIM_LIST2_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
N                                     ((PERIPH) == TIM2) || \
N                                     ((PERIPH) == TIM3) || \
N                                     ((PERIPH) == TIM4) || \
N                                     ((PERIPH) == TIM5) || \
N                                     ((PERIPH) == TIM8) || \
N                                     ((PERIPH) == TIM9) || \
N                                     ((PERIPH) == TIM12))
X#define IS_TIM_LIST2_PERIPH(PERIPH) (((PERIPH) == TIM1) ||                                      ((PERIPH) == TIM2) ||                                      ((PERIPH) == TIM3) ||                                      ((PERIPH) == TIM4) ||                                      ((PERIPH) == TIM5) ||                                      ((PERIPH) == TIM8) ||                                      ((PERIPH) == TIM9) ||                                      ((PERIPH) == TIM12))
N/* LIST3: TIM1, TIM2, TIM3, TIM4, TIM5 and TIM8 */
N#define IS_TIM_LIST3_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
N                                     ((PERIPH) == TIM2) || \
N                                     ((PERIPH) == TIM3) || \
N                                     ((PERIPH) == TIM4) || \
N                                     ((PERIPH) == TIM5) || \
N                                     ((PERIPH) == TIM8))
X#define IS_TIM_LIST3_PERIPH(PERIPH) (((PERIPH) == TIM1) ||                                      ((PERIPH) == TIM2) ||                                      ((PERIPH) == TIM3) ||                                      ((PERIPH) == TIM4) ||                                      ((PERIPH) == TIM5) ||                                      ((PERIPH) == TIM8))
N/* LIST4: TIM1 and TIM8 */
N#define IS_TIM_LIST4_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
N                                     ((PERIPH) == TIM8))
X#define IS_TIM_LIST4_PERIPH(PERIPH) (((PERIPH) == TIM1) ||                                      ((PERIPH) == TIM8))
N/* LIST5: TIM1, TIM2, TIM3, TIM4, TIM5, TIM6, TIM7 and TIM8 */
N#define IS_TIM_LIST5_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
N                                     ((PERIPH) == TIM2) || \
N                                     ((PERIPH) == TIM3) || \
N                                     ((PERIPH) == TIM4) || \
N                                     ((PERIPH) == TIM5) || \
N                                     ((PERIPH) == TIM6) || \
N                                     ((PERIPH) == TIM7) || \
N                                     ((PERIPH) == TIM8))
X#define IS_TIM_LIST5_PERIPH(PERIPH) (((PERIPH) == TIM1) ||                                      ((PERIPH) == TIM2) ||                                      ((PERIPH) == TIM3) ||                                      ((PERIPH) == TIM4) ||                                      ((PERIPH) == TIM5) ||                                      ((PERIPH) == TIM6) ||                                      ((PERIPH) == TIM7) ||                                      ((PERIPH) == TIM8))
N/* LIST6: TIM2, TIM5 and TIM11 */                               
N#define IS_TIM_LIST6_PERIPH(TIMx)(((TIMx) == TIM2) || \
N                                 ((TIMx) == TIM5) || \
N                                 ((TIMx) == TIM11))
X#define IS_TIM_LIST6_PERIPH(TIMx)(((TIMx) == TIM2) ||                                  ((TIMx) == TIM5) ||                                  ((TIMx) == TIM11))
N
N/** @defgroup TIM_Output_Compare_and_PWM_modes 
N  * @{
N  */
N
N#define TIM_OCMode_Timing                  ((uint16_t)0x0000)
N#define TIM_OCMode_Active                  ((uint16_t)0x0010)
N#define TIM_OCMode_Inactive                ((uint16_t)0x0020)
N#define TIM_OCMode_Toggle                  ((uint16_t)0x0030)
N#define TIM_OCMode_PWM1                    ((uint16_t)0x0060)
N#define TIM_OCMode_PWM2                    ((uint16_t)0x0070)
N#define IS_TIM_OC_MODE(MODE) (((MODE) == TIM_OCMode_Timing) || \
N                              ((MODE) == TIM_OCMode_Active) || \
N                              ((MODE) == TIM_OCMode_Inactive) || \
N                              ((MODE) == TIM_OCMode_Toggle)|| \
N                              ((MODE) == TIM_OCMode_PWM1) || \
N                              ((MODE) == TIM_OCMode_PWM2))
X#define IS_TIM_OC_MODE(MODE) (((MODE) == TIM_OCMode_Timing) ||                               ((MODE) == TIM_OCMode_Active) ||                               ((MODE) == TIM_OCMode_Inactive) ||                               ((MODE) == TIM_OCMode_Toggle)||                               ((MODE) == TIM_OCMode_PWM1) ||                               ((MODE) == TIM_OCMode_PWM2))
N#define IS_TIM_OCM(MODE) (((MODE) == TIM_OCMode_Timing) || \
N                          ((MODE) == TIM_OCMode_Active) || \
N                          ((MODE) == TIM_OCMode_Inactive) || \
N                          ((MODE) == TIM_OCMode_Toggle)|| \
N                          ((MODE) == TIM_OCMode_PWM1) || \
N                          ((MODE) == TIM_OCMode_PWM2) ||	\
N                          ((MODE) == TIM_ForcedAction_Active) || \
N                          ((MODE) == TIM_ForcedAction_InActive))
X#define IS_TIM_OCM(MODE) (((MODE) == TIM_OCMode_Timing) ||                           ((MODE) == TIM_OCMode_Active) ||                           ((MODE) == TIM_OCMode_Inactive) ||                           ((MODE) == TIM_OCMode_Toggle)||                           ((MODE) == TIM_OCMode_PWM1) ||                           ((MODE) == TIM_OCMode_PWM2) ||	                          ((MODE) == TIM_ForcedAction_Active) ||                           ((MODE) == TIM_ForcedAction_InActive))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_One_Pulse_Mode 
N  * @{
N  */
N
N#define TIM_OPMode_Single                  ((uint16_t)0x0008)
N#define TIM_OPMode_Repetitive              ((uint16_t)0x0000)
N#define IS_TIM_OPM_MODE(MODE) (((MODE) == TIM_OPMode_Single) || \
N                               ((MODE) == TIM_OPMode_Repetitive))
X#define IS_TIM_OPM_MODE(MODE) (((MODE) == TIM_OPMode_Single) ||                                ((MODE) == TIM_OPMode_Repetitive))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Channel 
N  * @{
N  */
N
N#define TIM_Channel_1                      ((uint16_t)0x0000)
N#define TIM_Channel_2                      ((uint16_t)0x0004)
N#define TIM_Channel_3                      ((uint16_t)0x0008)
N#define TIM_Channel_4                      ((uint16_t)0x000C)
N                                 
N#define IS_TIM_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
N                                 ((CHANNEL) == TIM_Channel_2) || \
N                                 ((CHANNEL) == TIM_Channel_3) || \
N                                 ((CHANNEL) == TIM_Channel_4))
X#define IS_TIM_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) ||                                  ((CHANNEL) == TIM_Channel_2) ||                                  ((CHANNEL) == TIM_Channel_3) ||                                  ((CHANNEL) == TIM_Channel_4))
N                                 
N#define IS_TIM_PWMI_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
N                                      ((CHANNEL) == TIM_Channel_2))
X#define IS_TIM_PWMI_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) ||                                       ((CHANNEL) == TIM_Channel_2))
N#define IS_TIM_COMPLEMENTARY_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
N                                               ((CHANNEL) == TIM_Channel_2) || \
N                                               ((CHANNEL) == TIM_Channel_3))
X#define IS_TIM_COMPLEMENTARY_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) ||                                                ((CHANNEL) == TIM_Channel_2) ||                                                ((CHANNEL) == TIM_Channel_3))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Clock_Division_CKD 
N  * @{
N  */
N
N#define TIM_CKD_DIV1                       ((uint16_t)0x0000)
N#define TIM_CKD_DIV2                       ((uint16_t)0x0100)
N#define TIM_CKD_DIV4                       ((uint16_t)0x0200)
N#define IS_TIM_CKD_DIV(DIV) (((DIV) == TIM_CKD_DIV1) || \
N                             ((DIV) == TIM_CKD_DIV2) || \
N                             ((DIV) == TIM_CKD_DIV4))
X#define IS_TIM_CKD_DIV(DIV) (((DIV) == TIM_CKD_DIV1) ||                              ((DIV) == TIM_CKD_DIV2) ||                              ((DIV) == TIM_CKD_DIV4))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Counter_Mode 
N  * @{
N  */
N
N#define TIM_CounterMode_Up                 ((uint16_t)0x0000)
N#define TIM_CounterMode_Down               ((uint16_t)0x0010)
N#define TIM_CounterMode_CenterAligned1     ((uint16_t)0x0020)
N#define TIM_CounterMode_CenterAligned2     ((uint16_t)0x0040)
N#define TIM_CounterMode_CenterAligned3     ((uint16_t)0x0060)
N#define IS_TIM_COUNTER_MODE(MODE) (((MODE) == TIM_CounterMode_Up) ||  \
N                                   ((MODE) == TIM_CounterMode_Down) || \
N                                   ((MODE) == TIM_CounterMode_CenterAligned1) || \
N                                   ((MODE) == TIM_CounterMode_CenterAligned2) || \
N                                   ((MODE) == TIM_CounterMode_CenterAligned3))
X#define IS_TIM_COUNTER_MODE(MODE) (((MODE) == TIM_CounterMode_Up) ||                                     ((MODE) == TIM_CounterMode_Down) ||                                    ((MODE) == TIM_CounterMode_CenterAligned1) ||                                    ((MODE) == TIM_CounterMode_CenterAligned2) ||                                    ((MODE) == TIM_CounterMode_CenterAligned3))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Polarity 
N  * @{
N  */
N
N#define TIM_OCPolarity_High                ((uint16_t)0x0000)
N#define TIM_OCPolarity_Low                 ((uint16_t)0x0002)
N#define IS_TIM_OC_POLARITY(POLARITY) (((POLARITY) == TIM_OCPolarity_High) || \
N                                      ((POLARITY) == TIM_OCPolarity_Low))
X#define IS_TIM_OC_POLARITY(POLARITY) (((POLARITY) == TIM_OCPolarity_High) ||                                       ((POLARITY) == TIM_OCPolarity_Low))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Output_Compare_N_Polarity 
N  * @{
N  */
N  
N#define TIM_OCNPolarity_High               ((uint16_t)0x0000)
N#define TIM_OCNPolarity_Low                ((uint16_t)0x0008)
N#define IS_TIM_OCN_POLARITY(POLARITY) (((POLARITY) == TIM_OCNPolarity_High) || \
N                                       ((POLARITY) == TIM_OCNPolarity_Low))
X#define IS_TIM_OCN_POLARITY(POLARITY) (((POLARITY) == TIM_OCNPolarity_High) ||                                        ((POLARITY) == TIM_OCNPolarity_Low))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Output_Compare_State 
N  * @{
N  */
N
N#define TIM_OutputState_Disable            ((uint16_t)0x0000)
N#define TIM_OutputState_Enable             ((uint16_t)0x0001)
N#define IS_TIM_OUTPUT_STATE(STATE) (((STATE) == TIM_OutputState_Disable) || \
N                                    ((STATE) == TIM_OutputState_Enable))
X#define IS_TIM_OUTPUT_STATE(STATE) (((STATE) == TIM_OutputState_Disable) ||                                     ((STATE) == TIM_OutputState_Enable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_N_State
N  * @{
N  */
N
N#define TIM_OutputNState_Disable           ((uint16_t)0x0000)
N#define TIM_OutputNState_Enable            ((uint16_t)0x0004)
N#define IS_TIM_OUTPUTN_STATE(STATE) (((STATE) == TIM_OutputNState_Disable) || \
N                                     ((STATE) == TIM_OutputNState_Enable))
X#define IS_TIM_OUTPUTN_STATE(STATE) (((STATE) == TIM_OutputNState_Disable) ||                                      ((STATE) == TIM_OutputNState_Enable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Capture_Compare_State
N  * @{
N  */
N
N#define TIM_CCx_Enable                      ((uint16_t)0x0001)
N#define TIM_CCx_Disable                     ((uint16_t)0x0000)
N#define IS_TIM_CCX(CCX) (((CCX) == TIM_CCx_Enable) || \
N                         ((CCX) == TIM_CCx_Disable))
X#define IS_TIM_CCX(CCX) (((CCX) == TIM_CCx_Enable) ||                          ((CCX) == TIM_CCx_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Capture_Compare_N_State
N  * @{
N  */
N
N#define TIM_CCxN_Enable                     ((uint16_t)0x0004)
N#define TIM_CCxN_Disable                    ((uint16_t)0x0000)
N#define IS_TIM_CCXN(CCXN) (((CCXN) == TIM_CCxN_Enable) || \
N                           ((CCXN) == TIM_CCxN_Disable))
X#define IS_TIM_CCXN(CCXN) (((CCXN) == TIM_CCxN_Enable) ||                            ((CCXN) == TIM_CCxN_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Break_Input_enable_disable 
N  * @{
N  */
N
N#define TIM_Break_Enable                   ((uint16_t)0x1000)
N#define TIM_Break_Disable                  ((uint16_t)0x0000)
N#define IS_TIM_BREAK_STATE(STATE) (((STATE) == TIM_Break_Enable) || \
N                                   ((STATE) == TIM_Break_Disable))
X#define IS_TIM_BREAK_STATE(STATE) (((STATE) == TIM_Break_Enable) ||                                    ((STATE) == TIM_Break_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Break_Polarity 
N  * @{
N  */
N
N#define TIM_BreakPolarity_Low              ((uint16_t)0x0000)
N#define TIM_BreakPolarity_High             ((uint16_t)0x2000)
N#define IS_TIM_BREAK_POLARITY(POLARITY) (((POLARITY) == TIM_BreakPolarity_Low) || \
N                                         ((POLARITY) == TIM_BreakPolarity_High))
X#define IS_TIM_BREAK_POLARITY(POLARITY) (((POLARITY) == TIM_BreakPolarity_Low) ||                                          ((POLARITY) == TIM_BreakPolarity_High))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_AOE_Bit_Set_Reset 
N  * @{
N  */
N
N#define TIM_AutomaticOutput_Enable         ((uint16_t)0x4000)
N#define TIM_AutomaticOutput_Disable        ((uint16_t)0x0000)
N#define IS_TIM_AUTOMATIC_OUTPUT_STATE(STATE) (((STATE) == TIM_AutomaticOutput_Enable) || \
N                                              ((STATE) == TIM_AutomaticOutput_Disable))
X#define IS_TIM_AUTOMATIC_OUTPUT_STATE(STATE) (((STATE) == TIM_AutomaticOutput_Enable) ||                                               ((STATE) == TIM_AutomaticOutput_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Lock_level
N  * @{
N  */
N
N#define TIM_LOCKLevel_OFF                  ((uint16_t)0x0000)
N#define TIM_LOCKLevel_1                    ((uint16_t)0x0100)
N#define TIM_LOCKLevel_2                    ((uint16_t)0x0200)
N#define TIM_LOCKLevel_3                    ((uint16_t)0x0300)
N#define IS_TIM_LOCK_LEVEL(LEVEL) (((LEVEL) == TIM_LOCKLevel_OFF) || \
N                                  ((LEVEL) == TIM_LOCKLevel_1) || \
N                                  ((LEVEL) == TIM_LOCKLevel_2) || \
N                                  ((LEVEL) == TIM_LOCKLevel_3))
X#define IS_TIM_LOCK_LEVEL(LEVEL) (((LEVEL) == TIM_LOCKLevel_OFF) ||                                   ((LEVEL) == TIM_LOCKLevel_1) ||                                   ((LEVEL) == TIM_LOCKLevel_2) ||                                   ((LEVEL) == TIM_LOCKLevel_3))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_OSSI_Off_State_Selection_for_Idle_mode_state 
N  * @{
N  */
N
N#define TIM_OSSIState_Enable               ((uint16_t)0x0400)
N#define TIM_OSSIState_Disable              ((uint16_t)0x0000)
N#define IS_TIM_OSSI_STATE(STATE) (((STATE) == TIM_OSSIState_Enable) || \
N                                  ((STATE) == TIM_OSSIState_Disable))
X#define IS_TIM_OSSI_STATE(STATE) (((STATE) == TIM_OSSIState_Enable) ||                                   ((STATE) == TIM_OSSIState_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_OSSR_Off_State_Selection_for_Run_mode_state
N  * @{
N  */
N
N#define TIM_OSSRState_Enable               ((uint16_t)0x0800)
N#define TIM_OSSRState_Disable              ((uint16_t)0x0000)
N#define IS_TIM_OSSR_STATE(STATE) (((STATE) == TIM_OSSRState_Enable) || \
N                                  ((STATE) == TIM_OSSRState_Disable))
X#define IS_TIM_OSSR_STATE(STATE) (((STATE) == TIM_OSSRState_Enable) ||                                   ((STATE) == TIM_OSSRState_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Idle_State 
N  * @{
N  */
N
N#define TIM_OCIdleState_Set                ((uint16_t)0x0100)
N#define TIM_OCIdleState_Reset              ((uint16_t)0x0000)
N#define IS_TIM_OCIDLE_STATE(STATE) (((STATE) == TIM_OCIdleState_Set) || \
N                                    ((STATE) == TIM_OCIdleState_Reset))
X#define IS_TIM_OCIDLE_STATE(STATE) (((STATE) == TIM_OCIdleState_Set) ||                                     ((STATE) == TIM_OCIdleState_Reset))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_N_Idle_State 
N  * @{
N  */
N
N#define TIM_OCNIdleState_Set               ((uint16_t)0x0200)
N#define TIM_OCNIdleState_Reset             ((uint16_t)0x0000)
N#define IS_TIM_OCNIDLE_STATE(STATE) (((STATE) == TIM_OCNIdleState_Set) || \
N                                     ((STATE) == TIM_OCNIdleState_Reset))
X#define IS_TIM_OCNIDLE_STATE(STATE) (((STATE) == TIM_OCNIdleState_Set) ||                                      ((STATE) == TIM_OCNIdleState_Reset))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Input_Capture_Polarity 
N  * @{
N  */
N
N#define  TIM_ICPolarity_Rising             ((uint16_t)0x0000)
N#define  TIM_ICPolarity_Falling            ((uint16_t)0x0002)
N#define  TIM_ICPolarity_BothEdge           ((uint16_t)0x000A)
N#define IS_TIM_IC_POLARITY(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) || \
N                                      ((POLARITY) == TIM_ICPolarity_Falling)|| \
N                                      ((POLARITY) == TIM_ICPolarity_BothEdge))
X#define IS_TIM_IC_POLARITY(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) ||                                       ((POLARITY) == TIM_ICPolarity_Falling)||                                       ((POLARITY) == TIM_ICPolarity_BothEdge))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Input_Capture_Selection 
N  * @{
N  */
N
N#define TIM_ICSelection_DirectTI           ((uint16_t)0x0001) /*!< TIM Input 1, 2, 3 or 4 is selected to be 
N                                                                   connected to IC1, IC2, IC3 or IC4, respectively */
N#define TIM_ICSelection_IndirectTI         ((uint16_t)0x0002) /*!< TIM Input 1, 2, 3 or 4 is selected to be
N                                                                   connected to IC2, IC1, IC4 or IC3, respectively. */
N#define TIM_ICSelection_TRC                ((uint16_t)0x0003) /*!< TIM Input 1, 2, 3 or 4 is selected to be connected to TRC. */
N#define IS_TIM_IC_SELECTION(SELECTION) (((SELECTION) == TIM_ICSelection_DirectTI) || \
N                                        ((SELECTION) == TIM_ICSelection_IndirectTI) || \
N                                        ((SELECTION) == TIM_ICSelection_TRC))
X#define IS_TIM_IC_SELECTION(SELECTION) (((SELECTION) == TIM_ICSelection_DirectTI) ||                                         ((SELECTION) == TIM_ICSelection_IndirectTI) ||                                         ((SELECTION) == TIM_ICSelection_TRC))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Input_Capture_Prescaler 
N  * @{
N  */
N
N#define TIM_ICPSC_DIV1                     ((uint16_t)0x0000) /*!< Capture performed each time an edge is detected on the capture input. */
N#define TIM_ICPSC_DIV2                     ((uint16_t)0x0004) /*!< Capture performed once every 2 events. */
N#define TIM_ICPSC_DIV4                     ((uint16_t)0x0008) /*!< Capture performed once every 4 events. */
N#define TIM_ICPSC_DIV8                     ((uint16_t)0x000C) /*!< Capture performed once every 8 events. */
N#define IS_TIM_IC_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ICPSC_DIV1) || \
N                                        ((PRESCALER) == TIM_ICPSC_DIV2) || \
N                                        ((PRESCALER) == TIM_ICPSC_DIV4) || \
N                                        ((PRESCALER) == TIM_ICPSC_DIV8))
X#define IS_TIM_IC_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ICPSC_DIV1) ||                                         ((PRESCALER) == TIM_ICPSC_DIV2) ||                                         ((PRESCALER) == TIM_ICPSC_DIV4) ||                                         ((PRESCALER) == TIM_ICPSC_DIV8))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_interrupt_sources 
N  * @{
N  */
N
N#define TIM_IT_Update                      ((uint16_t)0x0001)
N#define TIM_IT_CC1                         ((uint16_t)0x0002)
N#define TIM_IT_CC2                         ((uint16_t)0x0004)
N#define TIM_IT_CC3                         ((uint16_t)0x0008)
N#define TIM_IT_CC4                         ((uint16_t)0x0010)
N#define TIM_IT_COM                         ((uint16_t)0x0020)
N#define TIM_IT_Trigger                     ((uint16_t)0x0040)
N#define TIM_IT_Break                       ((uint16_t)0x0080)
N#define IS_TIM_IT(IT) ((((IT) & (uint16_t)0xFF00) == 0x0000) && ((IT) != 0x0000))
N
N#define IS_TIM_GET_IT(IT) (((IT) == TIM_IT_Update) || \
N                           ((IT) == TIM_IT_CC1) || \
N                           ((IT) == TIM_IT_CC2) || \
N                           ((IT) == TIM_IT_CC3) || \
N                           ((IT) == TIM_IT_CC4) || \
N                           ((IT) == TIM_IT_COM) || \
N                           ((IT) == TIM_IT_Trigger) || \
N                           ((IT) == TIM_IT_Break))
X#define IS_TIM_GET_IT(IT) (((IT) == TIM_IT_Update) ||                            ((IT) == TIM_IT_CC1) ||                            ((IT) == TIM_IT_CC2) ||                            ((IT) == TIM_IT_CC3) ||                            ((IT) == TIM_IT_CC4) ||                            ((IT) == TIM_IT_COM) ||                            ((IT) == TIM_IT_Trigger) ||                            ((IT) == TIM_IT_Break))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_DMA_Base_address 
N  * @{
N  */
N
N#define TIM_DMABase_CR1                    ((uint16_t)0x0000)
N#define TIM_DMABase_CR2                    ((uint16_t)0x0001)
N#define TIM_DMABase_SMCR                   ((uint16_t)0x0002)
N#define TIM_DMABase_DIER                   ((uint16_t)0x0003)
N#define TIM_DMABase_SR                     ((uint16_t)0x0004)
N#define TIM_DMABase_EGR                    ((uint16_t)0x0005)
N#define TIM_DMABase_CCMR1                  ((uint16_t)0x0006)
N#define TIM_DMABase_CCMR2                  ((uint16_t)0x0007)
N#define TIM_DMABase_CCER                   ((uint16_t)0x0008)
N#define TIM_DMABase_CNT                    ((uint16_t)0x0009)
N#define TIM_DMABase_PSC                    ((uint16_t)0x000A)
N#define TIM_DMABase_ARR                    ((uint16_t)0x000B)
N#define TIM_DMABase_RCR                    ((uint16_t)0x000C)
N#define TIM_DMABase_CCR1                   ((uint16_t)0x000D)
N#define TIM_DMABase_CCR2                   ((uint16_t)0x000E)
N#define TIM_DMABase_CCR3                   ((uint16_t)0x000F)
N#define TIM_DMABase_CCR4                   ((uint16_t)0x0010)
N#define TIM_DMABase_BDTR                   ((uint16_t)0x0011)
N#define TIM_DMABase_DCR                    ((uint16_t)0x0012)
N#define TIM_DMABase_OR                     ((uint16_t)0x0013)
N#define IS_TIM_DMA_BASE(BASE) (((BASE) == TIM_DMABase_CR1) || \
N                               ((BASE) == TIM_DMABase_CR2) || \
N                               ((BASE) == TIM_DMABase_SMCR) || \
N                               ((BASE) == TIM_DMABase_DIER) || \
N                               ((BASE) == TIM_DMABase_SR) || \
N                               ((BASE) == TIM_DMABase_EGR) || \
N                               ((BASE) == TIM_DMABase_CCMR1) || \
N                               ((BASE) == TIM_DMABase_CCMR2) || \
N                               ((BASE) == TIM_DMABase_CCER) || \
N                               ((BASE) == TIM_DMABase_CNT) || \
N                               ((BASE) == TIM_DMABase_PSC) || \
N                               ((BASE) == TIM_DMABase_ARR) || \
N                               ((BASE) == TIM_DMABase_RCR) || \
N                               ((BASE) == TIM_DMABase_CCR1) || \
N                               ((BASE) == TIM_DMABase_CCR2) || \
N                               ((BASE) == TIM_DMABase_CCR3) || \
N                               ((BASE) == TIM_DMABase_CCR4) || \
N                               ((BASE) == TIM_DMABase_BDTR) || \
N                               ((BASE) == TIM_DMABase_DCR) || \
N                               ((BASE) == TIM_DMABase_OR))                     
X#define IS_TIM_DMA_BASE(BASE) (((BASE) == TIM_DMABase_CR1) ||                                ((BASE) == TIM_DMABase_CR2) ||                                ((BASE) == TIM_DMABase_SMCR) ||                                ((BASE) == TIM_DMABase_DIER) ||                                ((BASE) == TIM_DMABase_SR) ||                                ((BASE) == TIM_DMABase_EGR) ||                                ((BASE) == TIM_DMABase_CCMR1) ||                                ((BASE) == TIM_DMABase_CCMR2) ||                                ((BASE) == TIM_DMABase_CCER) ||                                ((BASE) == TIM_DMABase_CNT) ||                                ((BASE) == TIM_DMABase_PSC) ||                                ((BASE) == TIM_DMABase_ARR) ||                                ((BASE) == TIM_DMABase_RCR) ||                                ((BASE) == TIM_DMABase_CCR1) ||                                ((BASE) == TIM_DMABase_CCR2) ||                                ((BASE) == TIM_DMABase_CCR3) ||                                ((BASE) == TIM_DMABase_CCR4) ||                                ((BASE) == TIM_DMABase_BDTR) ||                                ((BASE) == TIM_DMABase_DCR) ||                                ((BASE) == TIM_DMABase_OR))                     
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_DMA_Burst_Length 
N  * @{
N  */
N
N#define TIM_DMABurstLength_1Transfer           ((uint16_t)0x0000)
N#define TIM_DMABurstLength_2Transfers          ((uint16_t)0x0100)
N#define TIM_DMABurstLength_3Transfers          ((uint16_t)0x0200)
N#define TIM_DMABurstLength_4Transfers          ((uint16_t)0x0300)
N#define TIM_DMABurstLength_5Transfers          ((uint16_t)0x0400)
N#define TIM_DMABurstLength_6Transfers          ((uint16_t)0x0500)
N#define TIM_DMABurstLength_7Transfers          ((uint16_t)0x0600)
N#define TIM_DMABurstLength_8Transfers          ((uint16_t)0x0700)
N#define TIM_DMABurstLength_9Transfers          ((uint16_t)0x0800)
N#define TIM_DMABurstLength_10Transfers         ((uint16_t)0x0900)
N#define TIM_DMABurstLength_11Transfers         ((uint16_t)0x0A00)
N#define TIM_DMABurstLength_12Transfers         ((uint16_t)0x0B00)
N#define TIM_DMABurstLength_13Transfers         ((uint16_t)0x0C00)
N#define TIM_DMABurstLength_14Transfers         ((uint16_t)0x0D00)
N#define TIM_DMABurstLength_15Transfers         ((uint16_t)0x0E00)
N#define TIM_DMABurstLength_16Transfers         ((uint16_t)0x0F00)
N#define TIM_DMABurstLength_17Transfers         ((uint16_t)0x1000)
N#define TIM_DMABurstLength_18Transfers         ((uint16_t)0x1100)
N#define IS_TIM_DMA_LENGTH(LENGTH) (((LENGTH) == TIM_DMABurstLength_1Transfer) || \
N                                   ((LENGTH) == TIM_DMABurstLength_2Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_3Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_4Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_5Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_6Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_7Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_8Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_9Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_10Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_11Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_12Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_13Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_14Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_15Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_16Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_17Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_18Transfers))
X#define IS_TIM_DMA_LENGTH(LENGTH) (((LENGTH) == TIM_DMABurstLength_1Transfer) ||                                    ((LENGTH) == TIM_DMABurstLength_2Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_3Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_4Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_5Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_6Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_7Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_8Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_9Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_10Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_11Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_12Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_13Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_14Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_15Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_16Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_17Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_18Transfers))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_DMA_sources 
N  * @{
N  */
N
N#define TIM_DMA_Update                     ((uint16_t)0x0100)
N#define TIM_DMA_CC1                        ((uint16_t)0x0200)
N#define TIM_DMA_CC2                        ((uint16_t)0x0400)
N#define TIM_DMA_CC3                        ((uint16_t)0x0800)
N#define TIM_DMA_CC4                        ((uint16_t)0x1000)
N#define TIM_DMA_COM                        ((uint16_t)0x2000)
N#define TIM_DMA_Trigger                    ((uint16_t)0x4000)
N#define IS_TIM_DMA_SOURCE(SOURCE) ((((SOURCE) & (uint16_t)0x80FF) == 0x0000) && ((SOURCE) != 0x0000))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_External_Trigger_Prescaler 
N  * @{
N  */
N
N#define TIM_ExtTRGPSC_OFF                  ((uint16_t)0x0000)
N#define TIM_ExtTRGPSC_DIV2                 ((uint16_t)0x1000)
N#define TIM_ExtTRGPSC_DIV4                 ((uint16_t)0x2000)
N#define TIM_ExtTRGPSC_DIV8                 ((uint16_t)0x3000)
N#define IS_TIM_EXT_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ExtTRGPSC_OFF) || \
N                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV2) || \
N                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV4) || \
N                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV8))
X#define IS_TIM_EXT_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ExtTRGPSC_OFF) ||                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV2) ||                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV4) ||                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV8))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Internal_Trigger_Selection 
N  * @{
N  */
N
N#define TIM_TS_ITR0                        ((uint16_t)0x0000)
N#define TIM_TS_ITR1                        ((uint16_t)0x0010)
N#define TIM_TS_ITR2                        ((uint16_t)0x0020)
N#define TIM_TS_ITR3                        ((uint16_t)0x0030)
N#define TIM_TS_TI1F_ED                     ((uint16_t)0x0040)
N#define TIM_TS_TI1FP1                      ((uint16_t)0x0050)
N#define TIM_TS_TI2FP2                      ((uint16_t)0x0060)
N#define TIM_TS_ETRF                        ((uint16_t)0x0070)
N#define IS_TIM_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \
N                                             ((SELECTION) == TIM_TS_ITR1) || \
N                                             ((SELECTION) == TIM_TS_ITR2) || \
N                                             ((SELECTION) == TIM_TS_ITR3) || \
N                                             ((SELECTION) == TIM_TS_TI1F_ED) || \
N                                             ((SELECTION) == TIM_TS_TI1FP1) || \
N                                             ((SELECTION) == TIM_TS_TI2FP2) || \
N                                             ((SELECTION) == TIM_TS_ETRF))
X#define IS_TIM_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) ||                                              ((SELECTION) == TIM_TS_ITR1) ||                                              ((SELECTION) == TIM_TS_ITR2) ||                                              ((SELECTION) == TIM_TS_ITR3) ||                                              ((SELECTION) == TIM_TS_TI1F_ED) ||                                              ((SELECTION) == TIM_TS_TI1FP1) ||                                              ((SELECTION) == TIM_TS_TI2FP2) ||                                              ((SELECTION) == TIM_TS_ETRF))
N#define IS_TIM_INTERNAL_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \
N                                                      ((SELECTION) == TIM_TS_ITR1) || \
N                                                      ((SELECTION) == TIM_TS_ITR2) || \
N                                                      ((SELECTION) == TIM_TS_ITR3))
X#define IS_TIM_INTERNAL_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) ||                                                       ((SELECTION) == TIM_TS_ITR1) ||                                                       ((SELECTION) == TIM_TS_ITR2) ||                                                       ((SELECTION) == TIM_TS_ITR3))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_TIx_External_Clock_Source 
N  * @{
N  */
N
N#define TIM_TIxExternalCLK1Source_TI1      ((uint16_t)0x0050)
N#define TIM_TIxExternalCLK1Source_TI2      ((uint16_t)0x0060)
N#define TIM_TIxExternalCLK1Source_TI1ED    ((uint16_t)0x0040)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_External_Trigger_Polarity 
N  * @{
N  */ 
N#define TIM_ExtTRGPolarity_Inverted        ((uint16_t)0x8000)
N#define TIM_ExtTRGPolarity_NonInverted     ((uint16_t)0x0000)
N#define IS_TIM_EXT_POLARITY(POLARITY) (((POLARITY) == TIM_ExtTRGPolarity_Inverted) || \
N                                       ((POLARITY) == TIM_ExtTRGPolarity_NonInverted))
X#define IS_TIM_EXT_POLARITY(POLARITY) (((POLARITY) == TIM_ExtTRGPolarity_Inverted) ||                                        ((POLARITY) == TIM_ExtTRGPolarity_NonInverted))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Prescaler_Reload_Mode 
N  * @{
N  */
N
N#define TIM_PSCReloadMode_Update           ((uint16_t)0x0000)
N#define TIM_PSCReloadMode_Immediate        ((uint16_t)0x0001)
N#define IS_TIM_PRESCALER_RELOAD(RELOAD) (((RELOAD) == TIM_PSCReloadMode_Update) || \
N                                         ((RELOAD) == TIM_PSCReloadMode_Immediate))
X#define IS_TIM_PRESCALER_RELOAD(RELOAD) (((RELOAD) == TIM_PSCReloadMode_Update) ||                                          ((RELOAD) == TIM_PSCReloadMode_Immediate))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Forced_Action 
N  * @{
N  */
N
N#define TIM_ForcedAction_Active            ((uint16_t)0x0050)
N#define TIM_ForcedAction_InActive          ((uint16_t)0x0040)
N#define IS_TIM_FORCED_ACTION(ACTION) (((ACTION) == TIM_ForcedAction_Active) || \
N                                      ((ACTION) == TIM_ForcedAction_InActive))
X#define IS_TIM_FORCED_ACTION(ACTION) (((ACTION) == TIM_ForcedAction_Active) ||                                       ((ACTION) == TIM_ForcedAction_InActive))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Encoder_Mode 
N  * @{
N  */
N
N#define TIM_EncoderMode_TI1                ((uint16_t)0x0001)
N#define TIM_EncoderMode_TI2                ((uint16_t)0x0002)
N#define TIM_EncoderMode_TI12               ((uint16_t)0x0003)
N#define IS_TIM_ENCODER_MODE(MODE) (((MODE) == TIM_EncoderMode_TI1) || \
N                                   ((MODE) == TIM_EncoderMode_TI2) || \
N                                   ((MODE) == TIM_EncoderMode_TI12))
X#define IS_TIM_ENCODER_MODE(MODE) (((MODE) == TIM_EncoderMode_TI1) ||                                    ((MODE) == TIM_EncoderMode_TI2) ||                                    ((MODE) == TIM_EncoderMode_TI12))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup TIM_Event_Source 
N  * @{
N  */
N
N#define TIM_EventSource_Update             ((uint16_t)0x0001)
N#define TIM_EventSource_CC1                ((uint16_t)0x0002)
N#define TIM_EventSource_CC2                ((uint16_t)0x0004)
N#define TIM_EventSource_CC3                ((uint16_t)0x0008)
N#define TIM_EventSource_CC4                ((uint16_t)0x0010)
N#define TIM_EventSource_COM                ((uint16_t)0x0020)
N#define TIM_EventSource_Trigger            ((uint16_t)0x0040)
N#define TIM_EventSource_Break              ((uint16_t)0x0080)
N#define IS_TIM_EVENT_SOURCE(SOURCE) ((((SOURCE) & (uint16_t)0xFF00) == 0x0000) && ((SOURCE) != 0x0000))                                          
N  
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Update_Source 
N  * @{
N  */
N
N#define TIM_UpdateSource_Global            ((uint16_t)0x0000) /*!< Source of update is the counter overflow/underflow
N                                                                   or the setting of UG bit, or an update generation
N                                                                   through the slave mode controller. */
N#define TIM_UpdateSource_Regular           ((uint16_t)0x0001) /*!< Source of update is counter overflow/underflow. */
N#define IS_TIM_UPDATE_SOURCE(SOURCE) (((SOURCE) == TIM_UpdateSource_Global) || \
N                                      ((SOURCE) == TIM_UpdateSource_Regular))
X#define IS_TIM_UPDATE_SOURCE(SOURCE) (((SOURCE) == TIM_UpdateSource_Global) ||                                       ((SOURCE) == TIM_UpdateSource_Regular))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Preload_State 
N  * @{
N  */
N
N#define TIM_OCPreload_Enable               ((uint16_t)0x0008)
N#define TIM_OCPreload_Disable              ((uint16_t)0x0000)
N#define IS_TIM_OCPRELOAD_STATE(STATE) (((STATE) == TIM_OCPreload_Enable) || \
N                                       ((STATE) == TIM_OCPreload_Disable))
X#define IS_TIM_OCPRELOAD_STATE(STATE) (((STATE) == TIM_OCPreload_Enable) ||                                        ((STATE) == TIM_OCPreload_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Fast_State 
N  * @{
N  */
N
N#define TIM_OCFast_Enable                  ((uint16_t)0x0004)
N#define TIM_OCFast_Disable                 ((uint16_t)0x0000)
N#define IS_TIM_OCFAST_STATE(STATE) (((STATE) == TIM_OCFast_Enable) || \
N                                    ((STATE) == TIM_OCFast_Disable))
X#define IS_TIM_OCFAST_STATE(STATE) (((STATE) == TIM_OCFast_Enable) ||                                     ((STATE) == TIM_OCFast_Disable))
N                                     
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Clear_State 
N  * @{
N  */
N
N#define TIM_OCClear_Enable                 ((uint16_t)0x0080)
N#define TIM_OCClear_Disable                ((uint16_t)0x0000)
N#define IS_TIM_OCCLEAR_STATE(STATE) (((STATE) == TIM_OCClear_Enable) || \
N                                     ((STATE) == TIM_OCClear_Disable))
X#define IS_TIM_OCCLEAR_STATE(STATE) (((STATE) == TIM_OCClear_Enable) ||                                      ((STATE) == TIM_OCClear_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Trigger_Output_Source 
N  * @{
N  */
N
N#define TIM_TRGOSource_Reset               ((uint16_t)0x0000)
N#define TIM_TRGOSource_Enable              ((uint16_t)0x0010)
N#define TIM_TRGOSource_Update              ((uint16_t)0x0020)
N#define TIM_TRGOSource_OC1                 ((uint16_t)0x0030)
N#define TIM_TRGOSource_OC1Ref              ((uint16_t)0x0040)
N#define TIM_TRGOSource_OC2Ref              ((uint16_t)0x0050)
N#define TIM_TRGOSource_OC3Ref              ((uint16_t)0x0060)
N#define TIM_TRGOSource_OC4Ref              ((uint16_t)0x0070)
N#define IS_TIM_TRGO_SOURCE(SOURCE) (((SOURCE) == TIM_TRGOSource_Reset) || \
N                                    ((SOURCE) == TIM_TRGOSource_Enable) || \
N                                    ((SOURCE) == TIM_TRGOSource_Update) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC1) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC1Ref) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC2Ref) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC3Ref) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC4Ref))
X#define IS_TIM_TRGO_SOURCE(SOURCE) (((SOURCE) == TIM_TRGOSource_Reset) ||                                     ((SOURCE) == TIM_TRGOSource_Enable) ||                                     ((SOURCE) == TIM_TRGOSource_Update) ||                                     ((SOURCE) == TIM_TRGOSource_OC1) ||                                     ((SOURCE) == TIM_TRGOSource_OC1Ref) ||                                     ((SOURCE) == TIM_TRGOSource_OC2Ref) ||                                     ((SOURCE) == TIM_TRGOSource_OC3Ref) ||                                     ((SOURCE) == TIM_TRGOSource_OC4Ref))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Slave_Mode 
N  * @{
N  */
N
N#define TIM_SlaveMode_Reset                ((uint16_t)0x0004)
N#define TIM_SlaveMode_Gated                ((uint16_t)0x0005)
N#define TIM_SlaveMode_Trigger              ((uint16_t)0x0006)
N#define TIM_SlaveMode_External1            ((uint16_t)0x0007)
N#define IS_TIM_SLAVE_MODE(MODE) (((MODE) == TIM_SlaveMode_Reset) || \
N                                 ((MODE) == TIM_SlaveMode_Gated) || \
N                                 ((MODE) == TIM_SlaveMode_Trigger) || \
N                                 ((MODE) == TIM_SlaveMode_External1))
X#define IS_TIM_SLAVE_MODE(MODE) (((MODE) == TIM_SlaveMode_Reset) ||                                  ((MODE) == TIM_SlaveMode_Gated) ||                                  ((MODE) == TIM_SlaveMode_Trigger) ||                                  ((MODE) == TIM_SlaveMode_External1))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Master_Slave_Mode 
N  * @{
N  */
N
N#define TIM_MasterSlaveMode_Enable         ((uint16_t)0x0080)
N#define TIM_MasterSlaveMode_Disable        ((uint16_t)0x0000)
N#define IS_TIM_MSM_STATE(STATE) (((STATE) == TIM_MasterSlaveMode_Enable) || \
N                                 ((STATE) == TIM_MasterSlaveMode_Disable))
X#define IS_TIM_MSM_STATE(STATE) (((STATE) == TIM_MasterSlaveMode_Enable) ||                                  ((STATE) == TIM_MasterSlaveMode_Disable))
N/**
N  * @}
N  */ 
N/** @defgroup TIM_Remap 
N  * @{
N  */
N
N#define TIM2_TIM8_TRGO                     ((uint16_t)0x0000)
N#define TIM2_ETH_PTP                       ((uint16_t)0x0400)
N#define TIM2_USBFS_SOF                     ((uint16_t)0x0800)
N#define TIM2_USBHS_SOF                     ((uint16_t)0x0C00)
N
N#define TIM5_GPIO                          ((uint16_t)0x0000)
N#define TIM5_LSI                           ((uint16_t)0x0040)
N#define TIM5_LSE                           ((uint16_t)0x0080)
N#define TIM5_RTC                           ((uint16_t)0x00C0)
N
N#define TIM11_GPIO                         ((uint16_t)0x0000)
N#define TIM11_HSE                          ((uint16_t)0x0002)
N
N#define IS_TIM_REMAP(TIM_REMAP)	 (((TIM_REMAP) == TIM2_TIM8_TRGO)||\
N                                  ((TIM_REMAP) == TIM2_ETH_PTP)||\
N                                  ((TIM_REMAP) == TIM2_USBFS_SOF)||\
N                                  ((TIM_REMAP) == TIM2_USBHS_SOF)||\
N                                  ((TIM_REMAP) == TIM5_GPIO)||\
N                                  ((TIM_REMAP) == TIM5_LSI)||\
N                                  ((TIM_REMAP) == TIM5_LSE)||\
N                                  ((TIM_REMAP) == TIM5_RTC)||\
N                                  ((TIM_REMAP) == TIM11_GPIO)||\
N                                  ((TIM_REMAP) == TIM11_HSE))
X#define IS_TIM_REMAP(TIM_REMAP)	 (((TIM_REMAP) == TIM2_TIM8_TRGO)||                                  ((TIM_REMAP) == TIM2_ETH_PTP)||                                  ((TIM_REMAP) == TIM2_USBFS_SOF)||                                  ((TIM_REMAP) == TIM2_USBHS_SOF)||                                  ((TIM_REMAP) == TIM5_GPIO)||                                  ((TIM_REMAP) == TIM5_LSI)||                                  ((TIM_REMAP) == TIM5_LSE)||                                  ((TIM_REMAP) == TIM5_RTC)||                                  ((TIM_REMAP) == TIM11_GPIO)||                                  ((TIM_REMAP) == TIM11_HSE))
N
N/**
N  * @}
N  */ 
N/** @defgroup TIM_Flags 
N  * @{
N  */
N
N#define TIM_FLAG_Update                    ((uint16_t)0x0001)
N#define TIM_FLAG_CC1                       ((uint16_t)0x0002)
N#define TIM_FLAG_CC2                       ((uint16_t)0x0004)
N#define TIM_FLAG_CC3                       ((uint16_t)0x0008)
N#define TIM_FLAG_CC4                       ((uint16_t)0x0010)
N#define TIM_FLAG_COM                       ((uint16_t)0x0020)
N#define TIM_FLAG_Trigger                   ((uint16_t)0x0040)
N#define TIM_FLAG_Break                     ((uint16_t)0x0080)
N#define TIM_FLAG_CC1OF                     ((uint16_t)0x0200)
N#define TIM_FLAG_CC2OF                     ((uint16_t)0x0400)
N#define TIM_FLAG_CC3OF                     ((uint16_t)0x0800)
N#define TIM_FLAG_CC4OF                     ((uint16_t)0x1000)
N#define IS_TIM_GET_FLAG(FLAG) (((FLAG) == TIM_FLAG_Update) || \
N                               ((FLAG) == TIM_FLAG_CC1) || \
N                               ((FLAG) == TIM_FLAG_CC2) || \
N                               ((FLAG) == TIM_FLAG_CC3) || \
N                               ((FLAG) == TIM_FLAG_CC4) || \
N                               ((FLAG) == TIM_FLAG_COM) || \
N                               ((FLAG) == TIM_FLAG_Trigger) || \
N                               ((FLAG) == TIM_FLAG_Break) || \
N                               ((FLAG) == TIM_FLAG_CC1OF) || \
N                               ((FLAG) == TIM_FLAG_CC2OF) || \
N                               ((FLAG) == TIM_FLAG_CC3OF) || \
N                               ((FLAG) == TIM_FLAG_CC4OF))
X#define IS_TIM_GET_FLAG(FLAG) (((FLAG) == TIM_FLAG_Update) ||                                ((FLAG) == TIM_FLAG_CC1) ||                                ((FLAG) == TIM_FLAG_CC2) ||                                ((FLAG) == TIM_FLAG_CC3) ||                                ((FLAG) == TIM_FLAG_CC4) ||                                ((FLAG) == TIM_FLAG_COM) ||                                ((FLAG) == TIM_FLAG_Trigger) ||                                ((FLAG) == TIM_FLAG_Break) ||                                ((FLAG) == TIM_FLAG_CC1OF) ||                                ((FLAG) == TIM_FLAG_CC2OF) ||                                ((FLAG) == TIM_FLAG_CC3OF) ||                                ((FLAG) == TIM_FLAG_CC4OF))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Input_Capture_Filer_Value 
N  * @{
N  */
N
N#define IS_TIM_IC_FILTER(ICFILTER) ((ICFILTER) <= 0xF) 
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_External_Trigger_Filter 
N  * @{
N  */
N
N#define IS_TIM_EXT_FILTER(EXTFILTER) ((EXTFILTER) <= 0xF)
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Legacy 
N  * @{
N  */
N
N#define TIM_DMABurstLength_1Byte           TIM_DMABurstLength_1Transfer
N#define TIM_DMABurstLength_2Bytes          TIM_DMABurstLength_2Transfers
N#define TIM_DMABurstLength_3Bytes          TIM_DMABurstLength_3Transfers
N#define TIM_DMABurstLength_4Bytes          TIM_DMABurstLength_4Transfers
N#define TIM_DMABurstLength_5Bytes          TIM_DMABurstLength_5Transfers
N#define TIM_DMABurstLength_6Bytes          TIM_DMABurstLength_6Transfers
N#define TIM_DMABurstLength_7Bytes          TIM_DMABurstLength_7Transfers
N#define TIM_DMABurstLength_8Bytes          TIM_DMABurstLength_8Transfers
N#define TIM_DMABurstLength_9Bytes          TIM_DMABurstLength_9Transfers
N#define TIM_DMABurstLength_10Bytes         TIM_DMABurstLength_10Transfers
N#define TIM_DMABurstLength_11Bytes         TIM_DMABurstLength_11Transfers
N#define TIM_DMABurstLength_12Bytes         TIM_DMABurstLength_12Transfers
N#define TIM_DMABurstLength_13Bytes         TIM_DMABurstLength_13Transfers
N#define TIM_DMABurstLength_14Bytes         TIM_DMABurstLength_14Transfers
N#define TIM_DMABurstLength_15Bytes         TIM_DMABurstLength_15Transfers
N#define TIM_DMABurstLength_16Bytes         TIM_DMABurstLength_16Transfers
N#define TIM_DMABurstLength_17Bytes         TIM_DMABurstLength_17Transfers
N#define TIM_DMABurstLength_18Bytes         TIM_DMABurstLength_18Transfers
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/ 
N
N/* TimeBase management ********************************************************/
Nvoid TIM_DeInit(TIM_TypeDef* TIMx);
Nvoid TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);
Nvoid TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);
Nvoid TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode);
Nvoid TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode);
Nvoid TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter);
Nvoid TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload);
Nuint32_t TIM_GetCounter(TIM_TypeDef* TIMx);
Nuint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx);
Nvoid TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource);
Nvoid TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode);
Nvoid TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD);
Nvoid TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState);
N
N/* Output Compare management **************************************************/
Nvoid TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode);
Nvoid TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1);
Nvoid TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2);
Nvoid TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3);
Nvoid TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4);
Nvoid TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
Nvoid TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
Nvoid TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
Nvoid TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
Nvoid TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
Nvoid TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
Nvoid TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
Nvoid TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
Nvoid TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
Nvoid TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
Nvoid TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
Nvoid TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
Nvoid TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
Nvoid TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
Nvoid TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
Nvoid TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
Nvoid TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
Nvoid TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
Nvoid TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
Nvoid TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
Nvoid TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
Nvoid TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
Nvoid TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
Nvoid TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx);
Nvoid TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN);
N
N/* Input Capture management ***************************************************/
Nvoid TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);
Nvoid TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct);
Nvoid TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);
Nuint32_t TIM_GetCapture1(TIM_TypeDef* TIMx);
Nuint32_t TIM_GetCapture2(TIM_TypeDef* TIMx);
Nuint32_t TIM_GetCapture3(TIM_TypeDef* TIMx);
Nuint32_t TIM_GetCapture4(TIM_TypeDef* TIMx);
Nvoid TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
Nvoid TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
Nvoid TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
Nvoid TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
N
N/* Advanced-control timers (TIM1 and TIM8) specific features ******************/
Nvoid TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct);
Nvoid TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct);
Nvoid TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState);
N
N/* Interrupts, DMA and flags management ***************************************/
Nvoid TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState);
Nvoid TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource);
NFlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);
Nvoid TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);
NITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT);
Nvoid TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT);
Nvoid TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength);
Nvoid TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState);
Nvoid TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState);
N
N/* Clocks management **********************************************************/
Nvoid TIM_InternalClockConfig(TIM_TypeDef* TIMx);
Nvoid TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);
Nvoid TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
N                                uint16_t TIM_ICPolarity, uint16_t ICFilter);
Nvoid TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
N                             uint16_t ExtTRGFilter);
Nvoid TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
N                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter);
N
N/* Synchronization management *************************************************/
Nvoid TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);
Nvoid TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource);
Nvoid TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode);
Nvoid TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode);
Nvoid TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
N                   uint16_t ExtTRGFilter);
N
N/* Specific interface management **********************************************/   
Nvoid TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
N                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity);
Nvoid TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState);
N
N/* Specific remapping management **********************************************/
Nvoid TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F4xx_TIM_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 50 "..\..\Service\stm32f4xx_conf.h" 2
N#include "stm32f4xx_usart.h"
L 1 "..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\stm32f4xx_usart.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_usart.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    04-November-2016
N  * @brief   This file contains all the functions prototypes for the USART 
N  *          firmware library.    
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************  
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_USART_H
N#define __STM32F4xx_USART_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
N
N/** @addtogroup STM32F4xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup USART
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/ 
N
N/** 
N  * @brief  USART Init Structure definition  
N  */ 
N  
Ntypedef struct
N{
N  uint32_t USART_BaudRate;            /*!< This member configures the USART communication baud rate.
N                                           The baud rate is computed using the following formula:
N                                            - IntegerDivider = ((PCLKx) / (8 * (OVR8+1) * (USART_InitStruct->USART_BaudRate)))
N                                            - FractionalDivider = ((IntegerDivider - ((u32) IntegerDivider)) * 8 * (OVR8+1)) + 0.5 
N                                           Where OVR8 is the "oversampling by 8 mode" configuration bit in the CR1 register. */
N
N  uint16_t USART_WordLength;          /*!< Specifies the number of data bits transmitted or received in a frame.
N                                           This parameter can be a value of @ref USART_Word_Length */
N
N  uint16_t USART_StopBits;            /*!< Specifies the number of stop bits transmitted.
N                                           This parameter can be a value of @ref USART_Stop_Bits */
N
N  uint16_t USART_Parity;              /*!< Specifies the parity mode.
N                                           This parameter can be a value of @ref USART_Parity
N                                           @note When parity is enabled, the computed parity is inserted
N                                                 at the MSB position of the transmitted data (9th bit when
N                                                 the word length is set to 9 data bits; 8th bit when the
N                                                 word length is set to 8 data bits). */
N 
N  uint16_t USART_Mode;                /*!< Specifies whether the Receive or Transmit mode is enabled or disabled.
N                                           This parameter can be a value of @ref USART_Mode */
N
N  uint16_t USART_HardwareFlowControl; /*!< Specifies wether the hardware flow control mode is enabled
N                                           or disabled.
N                                           This parameter can be a value of @ref USART_Hardware_Flow_Control */
N} USART_InitTypeDef;
N
N/** 
N  * @brief  USART Clock Init Structure definition  
N  */ 
N  
Ntypedef struct
N{
N
N  uint16_t USART_Clock;   /*!< Specifies whether the USART clock is enabled or disabled.
N                               This parameter can be a value of @ref USART_Clock */
N
N  uint16_t USART_CPOL;    /*!< Specifies the steady state of the serial clock.
N                               This parameter can be a value of @ref USART_Clock_Polarity */
N
N  uint16_t USART_CPHA;    /*!< Specifies the clock transition on which the bit capture is made.
N                               This parameter can be a value of @ref USART_Clock_Phase */
N
N  uint16_t USART_LastBit; /*!< Specifies whether the clock pulse corresponding to the last transmitted
N                               data bit (MSB) has to be output on the SCLK pin in synchronous mode.
N                               This parameter can be a value of @ref USART_Last_Bit */
N} USART_ClockInitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup USART_Exported_Constants
N  * @{
N  */ 
N  
N#define IS_USART_ALL_PERIPH(PERIPH) (((PERIPH) == USART1) || \
N                                     ((PERIPH) == USART2) || \
N                                     ((PERIPH) == USART3) || \
N                                     ((PERIPH) == UART4)  || \
N                                     ((PERIPH) == UART5)  || \
N                                     ((PERIPH) == USART6) || \
N                                     ((PERIPH) == UART7)  || \
N                                     ((PERIPH) == UART8)  || \
N                                     ((PERIPH) == UART9)  || \
N                                     ((PERIPH) == UART10)) 
X#define IS_USART_ALL_PERIPH(PERIPH) (((PERIPH) == USART1) ||                                      ((PERIPH) == USART2) ||                                      ((PERIPH) == USART3) ||                                      ((PERIPH) == UART4)  ||                                      ((PERIPH) == UART5)  ||                                      ((PERIPH) == USART6) ||                                      ((PERIPH) == UART7)  ||                                      ((PERIPH) == UART8)  ||                                      ((PERIPH) == UART9)  ||                                      ((PERIPH) == UART10)) 
N
N#define IS_USART_1236_PERIPH(PERIPH) (((PERIPH) == USART1) || \
N                                      ((PERIPH) == USART2) || \
N                                      ((PERIPH) == USART3) || \
N                                      ((PERIPH) == USART6))
X#define IS_USART_1236_PERIPH(PERIPH) (((PERIPH) == USART1) ||                                       ((PERIPH) == USART2) ||                                       ((PERIPH) == USART3) ||                                       ((PERIPH) == USART6))
N
N/** @defgroup USART_Word_Length 
N  * @{
N  */ 
N  
N#define USART_WordLength_8b                  ((uint16_t)0x0000)
N#define USART_WordLength_9b                  ((uint16_t)0x1000)
N                                    
N#define IS_USART_WORD_LENGTH(LENGTH) (((LENGTH) == USART_WordLength_8b) || \
N                                      ((LENGTH) == USART_WordLength_9b))
X#define IS_USART_WORD_LENGTH(LENGTH) (((LENGTH) == USART_WordLength_8b) ||                                       ((LENGTH) == USART_WordLength_9b))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Stop_Bits 
N  * @{
N  */ 
N  
N#define USART_StopBits_1                     ((uint16_t)0x0000)
N#define USART_StopBits_0_5                   ((uint16_t)0x1000)
N#define USART_StopBits_2                     ((uint16_t)0x2000)
N#define USART_StopBits_1_5                   ((uint16_t)0x3000)
N#define IS_USART_STOPBITS(STOPBITS) (((STOPBITS) == USART_StopBits_1) || \
N                                     ((STOPBITS) == USART_StopBits_0_5) || \
N                                     ((STOPBITS) == USART_StopBits_2) || \
N                                     ((STOPBITS) == USART_StopBits_1_5))
X#define IS_USART_STOPBITS(STOPBITS) (((STOPBITS) == USART_StopBits_1) ||                                      ((STOPBITS) == USART_StopBits_0_5) ||                                      ((STOPBITS) == USART_StopBits_2) ||                                      ((STOPBITS) == USART_StopBits_1_5))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Parity 
N  * @{
N  */ 
N  
N#define USART_Parity_No                      ((uint16_t)0x0000)
N#define USART_Parity_Even                    ((uint16_t)0x0400)
N#define USART_Parity_Odd                     ((uint16_t)0x0600) 
N#define IS_USART_PARITY(PARITY) (((PARITY) == USART_Parity_No) || \
N                                 ((PARITY) == USART_Parity_Even) || \
N                                 ((PARITY) == USART_Parity_Odd))
X#define IS_USART_PARITY(PARITY) (((PARITY) == USART_Parity_No) ||                                  ((PARITY) == USART_Parity_Even) ||                                  ((PARITY) == USART_Parity_Odd))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Mode 
N  * @{
N  */ 
N  
N#define USART_Mode_Rx                        ((uint16_t)0x0004)
N#define USART_Mode_Tx                        ((uint16_t)0x0008)
N#define IS_USART_MODE(MODE) ((((MODE) & (uint16_t)0xFFF3) == 0x00) && ((MODE) != (uint16_t)0x00))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Hardware_Flow_Control 
N  * @{
N  */ 
N#define USART_HardwareFlowControl_None       ((uint16_t)0x0000)
N#define USART_HardwareFlowControl_RTS        ((uint16_t)0x0100)
N#define USART_HardwareFlowControl_CTS        ((uint16_t)0x0200)
N#define USART_HardwareFlowControl_RTS_CTS    ((uint16_t)0x0300)
N#define IS_USART_HARDWARE_FLOW_CONTROL(CONTROL)\
N                              (((CONTROL) == USART_HardwareFlowControl_None) || \
N                               ((CONTROL) == USART_HardwareFlowControl_RTS) || \
N                               ((CONTROL) == USART_HardwareFlowControl_CTS) || \
N                               ((CONTROL) == USART_HardwareFlowControl_RTS_CTS))
X#define IS_USART_HARDWARE_FLOW_CONTROL(CONTROL)                              (((CONTROL) == USART_HardwareFlowControl_None) ||                                ((CONTROL) == USART_HardwareFlowControl_RTS) ||                                ((CONTROL) == USART_HardwareFlowControl_CTS) ||                                ((CONTROL) == USART_HardwareFlowControl_RTS_CTS))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Clock 
N  * @{
N  */ 
N#define USART_Clock_Disable                  ((uint16_t)0x0000)
N#define USART_Clock_Enable                   ((uint16_t)0x0800)
N#define IS_USART_CLOCK(CLOCK) (((CLOCK) == USART_Clock_Disable) || \
N                               ((CLOCK) == USART_Clock_Enable))
X#define IS_USART_CLOCK(CLOCK) (((CLOCK) == USART_Clock_Disable) ||                                ((CLOCK) == USART_Clock_Enable))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Clock_Polarity 
N  * @{
N  */
N  
N#define USART_CPOL_Low                       ((uint16_t)0x0000)
N#define USART_CPOL_High                      ((uint16_t)0x0400)
N#define IS_USART_CPOL(CPOL) (((CPOL) == USART_CPOL_Low) || ((CPOL) == USART_CPOL_High))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Clock_Phase
N  * @{
N  */
N
N#define USART_CPHA_1Edge                     ((uint16_t)0x0000)
N#define USART_CPHA_2Edge                     ((uint16_t)0x0200)
N#define IS_USART_CPHA(CPHA) (((CPHA) == USART_CPHA_1Edge) || ((CPHA) == USART_CPHA_2Edge))
N
N/**
N  * @}
N  */
N
N/** @defgroup USART_Last_Bit
N  * @{
N  */
N
N#define USART_LastBit_Disable                ((uint16_t)0x0000)
N#define USART_LastBit_Enable                 ((uint16_t)0x0100)
N#define IS_USART_LASTBIT(LASTBIT) (((LASTBIT) == USART_LastBit_Disable) || \
N                                   ((LASTBIT) == USART_LastBit_Enable))
X#define IS_USART_LASTBIT(LASTBIT) (((LASTBIT) == USART_LastBit_Disable) ||                                    ((LASTBIT) == USART_LastBit_Enable))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Interrupt_definition 
N  * @{
N  */
N  
N#define USART_IT_PE                          ((uint16_t)0x0028)
N#define USART_IT_TXE                         ((uint16_t)0x0727)
N#define USART_IT_TC                          ((uint16_t)0x0626)
N#define USART_IT_RXNE                        ((uint16_t)0x0525)
N#define USART_IT_ORE_RX                      ((uint16_t)0x0325) /* In case interrupt is generated if the RXNEIE bit is set */
N#define USART_IT_IDLE                        ((uint16_t)0x0424)
N#define USART_IT_LBD                         ((uint16_t)0x0846)
N#define USART_IT_CTS                         ((uint16_t)0x096A)
N#define USART_IT_ERR                         ((uint16_t)0x0060)
N#define USART_IT_ORE_ER                      ((uint16_t)0x0360) /* In case interrupt is generated if the EIE bit is set */
N#define USART_IT_NE                          ((uint16_t)0x0260)
N#define USART_IT_FE                          ((uint16_t)0x0160)
N
N/** @defgroup USART_Legacy 
N  * @{
N  */
N#define USART_IT_ORE                          USART_IT_ORE_ER               
N/**
N  * @}
N  */
N
N#define IS_USART_CONFIG_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) || \
N                                ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
N                                ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) || \
N                                ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ERR))
X#define IS_USART_CONFIG_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) ||                                 ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) ||                                 ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) ||                                 ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ERR))
N#define IS_USART_GET_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) || \
N                             ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
N                             ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) || \
N                             ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ORE) || \
N                             ((IT) == USART_IT_ORE_RX) || ((IT) == USART_IT_ORE_ER) || \
N                             ((IT) == USART_IT_NE) || ((IT) == USART_IT_FE))
X#define IS_USART_GET_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) ||                              ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) ||                              ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) ||                              ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ORE) ||                              ((IT) == USART_IT_ORE_RX) || ((IT) == USART_IT_ORE_ER) ||                              ((IT) == USART_IT_NE) || ((IT) == USART_IT_FE))
N#define IS_USART_CLEAR_IT(IT) (((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
N                               ((IT) == USART_IT_LBD) || ((IT) == USART_IT_CTS))
X#define IS_USART_CLEAR_IT(IT) (((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) ||                                ((IT) == USART_IT_LBD) || ((IT) == USART_IT_CTS))
N/**
N  * @}
N  */
N
N/** @defgroup USART_DMA_Requests 
N  * @{
N  */
N
N#define USART_DMAReq_Tx                      ((uint16_t)0x0080)
N#define USART_DMAReq_Rx                      ((uint16_t)0x0040)
N#define IS_USART_DMAREQ(DMAREQ) ((((DMAREQ) & (uint16_t)0xFF3F) == 0x00) && ((DMAREQ) != (uint16_t)0x00))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_WakeUp_methods
N  * @{
N  */
N
N#define USART_WakeUp_IdleLine                ((uint16_t)0x0000)
N#define USART_WakeUp_AddressMark             ((uint16_t)0x0800)
N#define IS_USART_WAKEUP(WAKEUP) (((WAKEUP) == USART_WakeUp_IdleLine) || \
N                                 ((WAKEUP) == USART_WakeUp_AddressMark))
X#define IS_USART_WAKEUP(WAKEUP) (((WAKEUP) == USART_WakeUp_IdleLine) ||                                  ((WAKEUP) == USART_WakeUp_AddressMark))
N/**
N  * @}
N  */
N
N/** @defgroup USART_LIN_Break_Detection_Length 
N  * @{
N  */
N  
N#define USART_LINBreakDetectLength_10b      ((uint16_t)0x0000)
N#define USART_LINBreakDetectLength_11b      ((uint16_t)0x0020)
N#define IS_USART_LIN_BREAK_DETECT_LENGTH(LENGTH) \
N                               (((LENGTH) == USART_LINBreakDetectLength_10b) || \
N                                ((LENGTH) == USART_LINBreakDetectLength_11b))
X#define IS_USART_LIN_BREAK_DETECT_LENGTH(LENGTH)                                (((LENGTH) == USART_LINBreakDetectLength_10b) ||                                 ((LENGTH) == USART_LINBreakDetectLength_11b))
N/**
N  * @}
N  */
N
N/** @defgroup USART_IrDA_Low_Power 
N  * @{
N  */
N
N#define USART_IrDAMode_LowPower              ((uint16_t)0x0004)
N#define USART_IrDAMode_Normal                ((uint16_t)0x0000)
N#define IS_USART_IRDA_MODE(MODE) (((MODE) == USART_IrDAMode_LowPower) || \
N                                  ((MODE) == USART_IrDAMode_Normal))
X#define IS_USART_IRDA_MODE(MODE) (((MODE) == USART_IrDAMode_LowPower) ||                                   ((MODE) == USART_IrDAMode_Normal))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Flags 
N  * @{
N  */
N
N#define USART_FLAG_CTS                       ((uint16_t)0x0200)
N#define USART_FLAG_LBD                       ((uint16_t)0x0100)
N#define USART_FLAG_TXE                       ((uint16_t)0x0080)
N#define USART_FLAG_TC                        ((uint16_t)0x0040)
N#define USART_FLAG_RXNE                      ((uint16_t)0x0020)
N#define USART_FLAG_IDLE                      ((uint16_t)0x0010)
N#define USART_FLAG_ORE                       ((uint16_t)0x0008)
N#define USART_FLAG_NE                        ((uint16_t)0x0004)
N#define USART_FLAG_FE                        ((uint16_t)0x0002)
N#define USART_FLAG_PE                        ((uint16_t)0x0001)
N#define IS_USART_FLAG(FLAG) (((FLAG) == USART_FLAG_PE) || ((FLAG) == USART_FLAG_TXE) || \
N                             ((FLAG) == USART_FLAG_TC) || ((FLAG) == USART_FLAG_RXNE) || \
N                             ((FLAG) == USART_FLAG_IDLE) || ((FLAG) == USART_FLAG_LBD) || \
N                             ((FLAG) == USART_FLAG_CTS) || ((FLAG) == USART_FLAG_ORE) || \
N                             ((FLAG) == USART_FLAG_NE) || ((FLAG) == USART_FLAG_FE))
X#define IS_USART_FLAG(FLAG) (((FLAG) == USART_FLAG_PE) || ((FLAG) == USART_FLAG_TXE) ||                              ((FLAG) == USART_FLAG_TC) || ((FLAG) == USART_FLAG_RXNE) ||                              ((FLAG) == USART_FLAG_IDLE) || ((FLAG) == USART_FLAG_LBD) ||                              ((FLAG) == USART_FLAG_CTS) || ((FLAG) == USART_FLAG_ORE) ||                              ((FLAG) == USART_FLAG_NE) || ((FLAG) == USART_FLAG_FE))
N                              
N#define IS_USART_CLEAR_FLAG(FLAG) ((((FLAG) & (uint16_t)0xFC9F) == 0x00) && ((FLAG) != (uint16_t)0x00))
N
N#define IS_USART_BAUDRATE(BAUDRATE) (((BAUDRATE) > 0) && ((BAUDRATE) < 7500001))
N#define IS_USART_ADDRESS(ADDRESS) ((ADDRESS) <= 0xF)
N#define IS_USART_DATA(DATA) ((DATA) <= 0x1FF)
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/  
N
N/*  Function used to set the USART configuration to the default reset state ***/ 
Nvoid USART_DeInit(USART_TypeDef* USARTx);
N
N/* Initialization and Configuration functions *********************************/
Nvoid USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct);
Nvoid USART_StructInit(USART_InitTypeDef* USART_InitStruct);
Nvoid USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct);
Nvoid USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct);
Nvoid USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler);
Nvoid USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState);
N
N/* Data transfers functions ***************************************************/ 
Nvoid USART_SendData(USART_TypeDef* USARTx, uint16_t Data);
Nuint16_t USART_ReceiveData(USART_TypeDef* USARTx);
N
N/* Multi-Processor Communication functions ************************************/
Nvoid USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address);
Nvoid USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp);
Nvoid USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState);
N
N/* LIN mode functions *********************************************************/
Nvoid USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength);
Nvoid USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_SendBreak(USART_TypeDef* USARTx);
N
N/* Half-duplex mode function **************************************************/
Nvoid USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState);
N
N/* Smartcard mode functions ***************************************************/
Nvoid USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime);
N
N/* IrDA mode functions ********************************************************/
Nvoid USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode);
Nvoid USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState);
N
N/* DMA transfers management functions *****************************************/
Nvoid USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState);
N
N/* Interrupts and flags management functions **********************************/
Nvoid USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);
NFlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);
Nvoid USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG);
NITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
Nvoid USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_USART_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 51 "..\..\Service\stm32f4xx_conf.h" 2
N#include "stm32f4xx_wwdg.h"
L 1 "..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\stm32f4xx_wwdg.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_wwdg.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    04-November-2016
N  * @brief   This file contains all the functions prototypes for the WWDG firmware
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_WWDG_H
N#define __STM32F4xx_WWDG_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
N
N/** @addtogroup STM32F4xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup WWDG
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup WWDG_Exported_Constants
N  * @{
N  */ 
N  
N/** @defgroup WWDG_Prescaler 
N  * @{
N  */
N  
N#define WWDG_Prescaler_1    ((uint32_t)0x00000000)
N#define WWDG_Prescaler_2    ((uint32_t)0x00000080)
N#define WWDG_Prescaler_4    ((uint32_t)0x00000100)
N#define WWDG_Prescaler_8    ((uint32_t)0x00000180)
N#define IS_WWDG_PRESCALER(PRESCALER) (((PRESCALER) == WWDG_Prescaler_1) || \
N                                      ((PRESCALER) == WWDG_Prescaler_2) || \
N                                      ((PRESCALER) == WWDG_Prescaler_4) || \
N                                      ((PRESCALER) == WWDG_Prescaler_8))
X#define IS_WWDG_PRESCALER(PRESCALER) (((PRESCALER) == WWDG_Prescaler_1) ||                                       ((PRESCALER) == WWDG_Prescaler_2) ||                                       ((PRESCALER) == WWDG_Prescaler_4) ||                                       ((PRESCALER) == WWDG_Prescaler_8))
N#define IS_WWDG_WINDOW_VALUE(VALUE) ((VALUE) <= 0x7F)
N#define IS_WWDG_COUNTER(COUNTER) (((COUNTER) >= 0x40) && ((COUNTER) <= 0x7F))
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/
N  
N/*  Function used to set the WWDG configuration to the default reset state ****/  
Nvoid WWDG_DeInit(void);
N
N/* Prescaler, Refresh window and Counter configuration functions **************/
Nvoid WWDG_SetPrescaler(uint32_t WWDG_Prescaler);
Nvoid WWDG_SetWindowValue(uint8_t WindowValue);
Nvoid WWDG_EnableIT(void);
Nvoid WWDG_SetCounter(uint8_t Counter);
N
N/* WWDG activation function ***************************************************/
Nvoid WWDG_Enable(uint8_t Counter);
N
N/* Interrupts and flags management functions **********************************/
NFlagStatus WWDG_GetFlagStatus(void);
Nvoid WWDG_ClearFlag(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_WWDG_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 52 "..\..\Service\stm32f4xx_conf.h" 2
N#include "misc.h" /* High level functions for NVIC and SysTick (add-on to CMSIS functions) */
L 1 "..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\misc.h" 1
N/**
N  ******************************************************************************
N  * @file    misc.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    04-November-2016
N  * @brief   This file contains all the functions prototypes for the miscellaneous
N  *          firmware library functions (add-on to CMSIS functions).
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MISC_H
N#define __MISC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
N
N/** @addtogroup STM32F4xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup MISC
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  NVIC Init Structure definition  
N  */
N
Ntypedef struct
N{
N  uint8_t NVIC_IRQChannel;                    /*!< Specifies the IRQ channel to be enabled or disabled.
N                                                   This parameter can be an enumerator of @ref IRQn_Type 
N                                                   enumeration (For the complete STM32 Devices IRQ Channels
N                                                   list, please refer to stm32f4xx.h file) */
N
N  uint8_t NVIC_IRQChannelPreemptionPriority;  /*!< Specifies the pre-emption priority for the IRQ channel
N                                                   specified in NVIC_IRQChannel. This parameter can be a value
N                                                   between 0 and 15 as described in the table @ref MISC_NVIC_Priority_Table
N                                                   A lower priority value indicates a higher priority */
N
N  uint8_t NVIC_IRQChannelSubPriority;         /*!< Specifies the subpriority level for the IRQ channel specified
N                                                   in NVIC_IRQChannel. This parameter can be a value
N                                                   between 0 and 15 as described in the table @ref MISC_NVIC_Priority_Table
N                                                   A lower priority value indicates a higher priority */
N
N  FunctionalState NVIC_IRQChannelCmd;         /*!< Specifies whether the IRQ channel defined in NVIC_IRQChannel
N                                                   will be enabled or disabled. 
N                                                   This parameter can be set either to ENABLE or DISABLE */   
N} NVIC_InitTypeDef;
N 
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup MISC_Exported_Constants
N  * @{
N  */
N
N/** @defgroup MISC_Vector_Table_Base 
N  * @{
N  */
N
N#define NVIC_VectTab_RAM             ((uint32_t)0x20000000)
N#define NVIC_VectTab_FLASH           ((uint32_t)0x08000000)
N#define IS_NVIC_VECTTAB(VECTTAB) (((VECTTAB) == NVIC_VectTab_RAM) || \
N                                  ((VECTTAB) == NVIC_VectTab_FLASH))
X#define IS_NVIC_VECTTAB(VECTTAB) (((VECTTAB) == NVIC_VectTab_RAM) ||                                   ((VECTTAB) == NVIC_VectTab_FLASH))
N/**
N  * @}
N  */
N
N/** @defgroup MISC_System_Low_Power 
N  * @{
N  */
N
N#define NVIC_LP_SEVONPEND            ((uint8_t)0x10)
N#define NVIC_LP_SLEEPDEEP            ((uint8_t)0x04)
N#define NVIC_LP_SLEEPONEXIT          ((uint8_t)0x02)
N#define IS_NVIC_LP(LP) (((LP) == NVIC_LP_SEVONPEND) || \
N                        ((LP) == NVIC_LP_SLEEPDEEP) || \
N                        ((LP) == NVIC_LP_SLEEPONEXIT))
X#define IS_NVIC_LP(LP) (((LP) == NVIC_LP_SEVONPEND) ||                         ((LP) == NVIC_LP_SLEEPDEEP) ||                         ((LP) == NVIC_LP_SLEEPONEXIT))
N/**
N  * @}
N  */
N
N/** @defgroup MISC_Preemption_Priority_Group 
N  * @{
N  */
N
N#define NVIC_PriorityGroup_0         ((uint32_t)0x700) /*!< 0 bits for pre-emption priority
N                                                            4 bits for subpriority */
N#define NVIC_PriorityGroup_1         ((uint32_t)0x600) /*!< 1 bits for pre-emption priority
N                                                            3 bits for subpriority */
N#define NVIC_PriorityGroup_2         ((uint32_t)0x500) /*!< 2 bits for pre-emption priority
N                                                            2 bits for subpriority */
N#define NVIC_PriorityGroup_3         ((uint32_t)0x400) /*!< 3 bits for pre-emption priority
N                                                            1 bits for subpriority */
N#define NVIC_PriorityGroup_4         ((uint32_t)0x300) /*!< 4 bits for pre-emption priority
N                                                            0 bits for subpriority */
N
N#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) || \
N                                       ((GROUP) == NVIC_PriorityGroup_1) || \
N                                       ((GROUP) == NVIC_PriorityGroup_2) || \
N                                       ((GROUP) == NVIC_PriorityGroup_3) || \
N                                       ((GROUP) == NVIC_PriorityGroup_4))
X#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) ||                                        ((GROUP) == NVIC_PriorityGroup_1) ||                                        ((GROUP) == NVIC_PriorityGroup_2) ||                                        ((GROUP) == NVIC_PriorityGroup_3) ||                                        ((GROUP) == NVIC_PriorityGroup_4))
N
N#define IS_NVIC_PREEMPTION_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10)
N
N#define IS_NVIC_SUB_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10)
N
N#define IS_NVIC_OFFSET(OFFSET)  ((OFFSET) < 0x000FFFFF)
N
N/**
N  * @}
N  */
N
N/** @defgroup MISC_SysTick_clock_source 
N  * @{
N  */
N
N#define SysTick_CLKSource_HCLK_Div8    ((uint32_t)0xFFFFFFFB)
N#define SysTick_CLKSource_HCLK         ((uint32_t)0x00000004)
N#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SysTick_CLKSource_HCLK) || \
N                                       ((SOURCE) == SysTick_CLKSource_HCLK_Div8))
X#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SysTick_CLKSource_HCLK) ||                                        ((SOURCE) == SysTick_CLKSource_HCLK_Div8))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/
N
Nvoid NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup);
Nvoid NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);
Nvoid NVIC_SetVectorTable(uint32_t NVIC_VectTab, uint32_t Offset);
Nvoid NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState);
Nvoid SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MISC_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 53 "..\..\Service\stm32f4xx_conf.h" 2
N
N#if defined (STM32F429_439xx) || defined(STM32F446xx)
X#if 0L || 0L
S#include "stm32f4xx_cryp.h"
S#include "stm32f4xx_hash.h"
S#include "stm32f4xx_rng.h"
S#include "stm32f4xx_can.h"
S#include "stm32f4xx_dac.h"
S#include "stm32f4xx_dcmi.h"
S#include "stm32f4xx_dma2d.h"
S#include "stm32f4xx_fmc.h"
S#include "stm32f4xx_ltdc.h"
S#include "stm32f4xx_sai.h"
N#endif /* STM32F429_439xx || STM32F446xx */
N
N#if defined (STM32F427_437xx)
X#if 0L
S#include "stm32f4xx_cryp.h"
S#include "stm32f4xx_hash.h"
S#include "stm32f4xx_rng.h"
S#include "stm32f4xx_can.h"
S#include "stm32f4xx_dac.h"
S#include "stm32f4xx_dcmi.h"
S#include "stm32f4xx_dma2d.h"
S#include "stm32f4xx_fmc.h"
S#include "stm32f4xx_sai.h"
N#endif /* STM32F427_437xx */
N
N#if defined (STM32F40_41xxx)
X#if 1L
N#include "stm32f4xx_cryp.h"
L 1 "..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\stm32f4xx_cryp.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_cryp.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    04-November-2016
N  * @brief   This file contains all the functions prototypes for the Cryptographic
N  *          processor(CRYP) firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_CRYP_H
N#define __STM32F4xx_CRYP_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
N
N/** @addtogroup STM32F4xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup CRYP
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief   CRYP Init structure definition  
N  */ 
Ntypedef struct
N{
N  uint32_t CRYP_AlgoDir;   /*!< Encrypt or Decrypt. This parameter can be a 
N                                value of @ref CRYP_Algorithm_Direction */
N  uint32_t CRYP_AlgoMode;  /*!< TDES-ECB, TDES-CBC, DES-ECB, DES-CBC, AES-ECB, 
N                                AES-CBC, AES-CTR, AES-Key, AES-GCM and AES-CCM.
N                                This parameter can be a value of @ref CRYP_Algorithm_Mode */
N  uint32_t CRYP_DataType;  /*!< 32-bit data, 16-bit data, bit data or bit string.
N                                This parameter can be a value of @ref CRYP_Data_Type */ 
N  uint32_t CRYP_KeySize;   /*!< Used only in AES mode only : 128, 192 or 256 bit 
N                                key length. This parameter can be a value of 
N                                @ref CRYP_Key_Size_for_AES_only */
N}CRYP_InitTypeDef;
N
N/** 
N  * @brief   CRYP Key(s) structure definition  
N  */ 
Ntypedef struct
N{
N  uint32_t CRYP_Key0Left;  /*!< Key 0 Left  */
N  uint32_t CRYP_Key0Right; /*!< Key 0 Right */
N  uint32_t CRYP_Key1Left;  /*!< Key 1 left  */
N  uint32_t CRYP_Key1Right; /*!< Key 1 Right */
N  uint32_t CRYP_Key2Left;  /*!< Key 2 left  */
N  uint32_t CRYP_Key2Right; /*!< Key 2 Right */
N  uint32_t CRYP_Key3Left;  /*!< Key 3 left  */
N  uint32_t CRYP_Key3Right; /*!< Key 3 Right */
N}CRYP_KeyInitTypeDef;
N/** 
N  * @brief   CRYP Initialization Vectors (IV) structure definition  
N  */ 
Ntypedef struct
N{
N  uint32_t CRYP_IV0Left;  /*!< Init Vector 0 Left  */
N  uint32_t CRYP_IV0Right; /*!< Init Vector 0 Right */
N  uint32_t CRYP_IV1Left;  /*!< Init Vector 1 left  */
N  uint32_t CRYP_IV1Right; /*!< Init Vector 1 Right */
N}CRYP_IVInitTypeDef;
N
N/** 
N  * @brief  CRYP context swapping structure definition  
N  */ 
Ntypedef struct
N{
N  /*!< Current Configuration */
N  uint32_t CR_CurrentConfig;
N  /*!< IV */
N  uint32_t CRYP_IV0LR;
N  uint32_t CRYP_IV0RR;
N  uint32_t CRYP_IV1LR;
N  uint32_t CRYP_IV1RR;
N  /*!< KEY */
N  uint32_t CRYP_K0LR;
N  uint32_t CRYP_K0RR;
N  uint32_t CRYP_K1LR;
N  uint32_t CRYP_K1RR;
N  uint32_t CRYP_K2LR;
N  uint32_t CRYP_K2RR;
N  uint32_t CRYP_K3LR;
N  uint32_t CRYP_K3RR;
N  uint32_t CRYP_CSGCMCCMR[8];
N  uint32_t CRYP_CSGCMR[8];
N}CRYP_Context;
N
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup CRYP_Exported_Constants
N  * @{
N  */
N
N/** @defgroup CRYP_Algorithm_Direction 
N  * @{
N  */
N#define CRYP_AlgoDir_Encrypt      ((uint16_t)0x0000)
N#define CRYP_AlgoDir_Decrypt      ((uint16_t)0x0004)
N#define IS_CRYP_ALGODIR(ALGODIR) (((ALGODIR) == CRYP_AlgoDir_Encrypt) || \
N                                  ((ALGODIR) == CRYP_AlgoDir_Decrypt))
X#define IS_CRYP_ALGODIR(ALGODIR) (((ALGODIR) == CRYP_AlgoDir_Encrypt) ||                                   ((ALGODIR) == CRYP_AlgoDir_Decrypt))
N
N/**
N  * @}
N  */ 
N 
N/** @defgroup CRYP_Algorithm_Mode 
N  * @{
N  */
N
N/*!< TDES Modes */
N#define CRYP_AlgoMode_TDES_ECB    ((uint32_t)0x00000000)
N#define CRYP_AlgoMode_TDES_CBC    ((uint32_t)0x00000008)
N
N/*!< DES Modes */
N#define CRYP_AlgoMode_DES_ECB     ((uint32_t)0x00000010)
N#define CRYP_AlgoMode_DES_CBC     ((uint32_t)0x00000018)
N
N/*!< AES Modes */
N#define CRYP_AlgoMode_AES_ECB     ((uint32_t)0x00000020)
N#define CRYP_AlgoMode_AES_CBC     ((uint32_t)0x00000028)
N#define CRYP_AlgoMode_AES_CTR     ((uint32_t)0x00000030)
N#define CRYP_AlgoMode_AES_Key     ((uint32_t)0x00000038)
N#define CRYP_AlgoMode_AES_GCM     ((uint32_t)0x00080000)
N#define CRYP_AlgoMode_AES_CCM     ((uint32_t)0x00080008)
N
N#define IS_CRYP_ALGOMODE(ALGOMODE) (((ALGOMODE) == CRYP_AlgoMode_TDES_ECB) || \
N                                   ((ALGOMODE) == CRYP_AlgoMode_TDES_CBC)|| \
N                                   ((ALGOMODE) == CRYP_AlgoMode_DES_ECB) || \
N                                   ((ALGOMODE) == CRYP_AlgoMode_DES_CBC) || \
N                                   ((ALGOMODE) == CRYP_AlgoMode_AES_ECB) || \
N                                   ((ALGOMODE) == CRYP_AlgoMode_AES_CBC) || \
N                                   ((ALGOMODE) == CRYP_AlgoMode_AES_CTR) || \
N                                   ((ALGOMODE) == CRYP_AlgoMode_AES_Key) || \
N                                   ((ALGOMODE) == CRYP_AlgoMode_AES_GCM) || \
N                                   ((ALGOMODE) == CRYP_AlgoMode_AES_CCM))
X#define IS_CRYP_ALGOMODE(ALGOMODE) (((ALGOMODE) == CRYP_AlgoMode_TDES_ECB) ||                                    ((ALGOMODE) == CRYP_AlgoMode_TDES_CBC)||                                    ((ALGOMODE) == CRYP_AlgoMode_DES_ECB) ||                                    ((ALGOMODE) == CRYP_AlgoMode_DES_CBC) ||                                    ((ALGOMODE) == CRYP_AlgoMode_AES_ECB) ||                                    ((ALGOMODE) == CRYP_AlgoMode_AES_CBC) ||                                    ((ALGOMODE) == CRYP_AlgoMode_AES_CTR) ||                                    ((ALGOMODE) == CRYP_AlgoMode_AES_Key) ||                                    ((ALGOMODE) == CRYP_AlgoMode_AES_GCM) ||                                    ((ALGOMODE) == CRYP_AlgoMode_AES_CCM))
N/**
N  * @}
N  */ 
N
N/** @defgroup CRYP_Phase 
N  * @{
N  */
N
N/*!< The phases are valid only for AES-GCM and AES-CCM modes */
N#define CRYP_Phase_Init           ((uint32_t)0x00000000)
N#define CRYP_Phase_Header         CRYP_CR_GCM_CCMPH_0
N#define CRYP_Phase_Payload        CRYP_CR_GCM_CCMPH_1
N#define CRYP_Phase_Final          CRYP_CR_GCM_CCMPH
N
N#define IS_CRYP_PHASE(PHASE) (((PHASE) == CRYP_Phase_Init)    || \
N                              ((PHASE) == CRYP_Phase_Header)  || \
N                              ((PHASE) == CRYP_Phase_Payload) || \
N                              ((PHASE) == CRYP_Phase_Final))
X#define IS_CRYP_PHASE(PHASE) (((PHASE) == CRYP_Phase_Init)    ||                               ((PHASE) == CRYP_Phase_Header)  ||                               ((PHASE) == CRYP_Phase_Payload) ||                               ((PHASE) == CRYP_Phase_Final))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup CRYP_Data_Type 
N  * @{
N  */
N#define CRYP_DataType_32b         ((uint16_t)0x0000)
N#define CRYP_DataType_16b         ((uint16_t)0x0040)
N#define CRYP_DataType_8b          ((uint16_t)0x0080)
N#define CRYP_DataType_1b          ((uint16_t)0x00C0)
N#define IS_CRYP_DATATYPE(DATATYPE) (((DATATYPE) == CRYP_DataType_32b) || \
N                                    ((DATATYPE) == CRYP_DataType_16b)|| \
N                                    ((DATATYPE) == CRYP_DataType_8b)|| \
N                                    ((DATATYPE) == CRYP_DataType_1b))  
X#define IS_CRYP_DATATYPE(DATATYPE) (((DATATYPE) == CRYP_DataType_32b) ||                                     ((DATATYPE) == CRYP_DataType_16b)||                                     ((DATATYPE) == CRYP_DataType_8b)||                                     ((DATATYPE) == CRYP_DataType_1b))  
N/**
N  * @}
N  */
N                                     
N/** @defgroup CRYP_Key_Size_for_AES_only 
N  * @{
N  */
N#define CRYP_KeySize_128b         ((uint16_t)0x0000)
N#define CRYP_KeySize_192b         ((uint16_t)0x0100)
N#define CRYP_KeySize_256b         ((uint16_t)0x0200)
N#define IS_CRYP_KEYSIZE(KEYSIZE) (((KEYSIZE) == CRYP_KeySize_128b)|| \
N                                  ((KEYSIZE) == CRYP_KeySize_192b)|| \
N                                  ((KEYSIZE) == CRYP_KeySize_256b))
X#define IS_CRYP_KEYSIZE(KEYSIZE) (((KEYSIZE) == CRYP_KeySize_128b)||                                   ((KEYSIZE) == CRYP_KeySize_192b)||                                   ((KEYSIZE) == CRYP_KeySize_256b))
N/**
N  * @}
N  */
N
N/** @defgroup CRYP_flags_definition 
N  * @{
N  */
N#define CRYP_FLAG_BUSY            ((uint8_t)0x10)  /*!< The CRYP core is currently 
N                                                        processing a block of data 
N                                                        or a key preparation (for 
N                                                        AES decryption). */
N#define CRYP_FLAG_IFEM            ((uint8_t)0x01)  /*!< Input Fifo Empty */
N#define CRYP_FLAG_IFNF            ((uint8_t)0x02)  /*!< Input Fifo is Not Full */
N#define CRYP_FLAG_INRIS           ((uint8_t)0x22)  /*!< Raw interrupt pending */
N#define CRYP_FLAG_OFNE            ((uint8_t)0x04)  /*!< Input Fifo service raw 
N                                                        interrupt status */
N#define CRYP_FLAG_OFFU            ((uint8_t)0x08)  /*!< Output Fifo is Full */
N#define CRYP_FLAG_OUTRIS          ((uint8_t)0x21)  /*!< Output Fifo service raw 
N                                                        interrupt status */
N
N#define IS_CRYP_GET_FLAG(FLAG) (((FLAG) == CRYP_FLAG_IFEM)  || \
N                                ((FLAG) == CRYP_FLAG_IFNF)  || \
N                                ((FLAG) == CRYP_FLAG_OFNE)  || \
N                                ((FLAG) == CRYP_FLAG_OFFU)  || \
N                                ((FLAG) == CRYP_FLAG_BUSY)  || \
N                                ((FLAG) == CRYP_FLAG_OUTRIS)|| \
N                                ((FLAG) == CRYP_FLAG_INRIS))
X#define IS_CRYP_GET_FLAG(FLAG) (((FLAG) == CRYP_FLAG_IFEM)  ||                                 ((FLAG) == CRYP_FLAG_IFNF)  ||                                 ((FLAG) == CRYP_FLAG_OFNE)  ||                                 ((FLAG) == CRYP_FLAG_OFFU)  ||                                 ((FLAG) == CRYP_FLAG_BUSY)  ||                                 ((FLAG) == CRYP_FLAG_OUTRIS)||                                 ((FLAG) == CRYP_FLAG_INRIS))
N/**
N  * @}
N  */
N
N/** @defgroup CRYP_interrupts_definition 
N  * @{
N  */
N#define CRYP_IT_INI               ((uint8_t)0x01) /*!< IN Fifo Interrupt */
N#define CRYP_IT_OUTI              ((uint8_t)0x02) /*!< OUT Fifo Interrupt */
N#define IS_CRYP_CONFIG_IT(IT) ((((IT) & (uint8_t)0xFC) == 0x00) && ((IT) != 0x00))
N#define IS_CRYP_GET_IT(IT) (((IT) == CRYP_IT_INI) || ((IT) == CRYP_IT_OUTI))
N
N/**
N  * @}
N  */
N
N/** @defgroup CRYP_Encryption_Decryption_modes_definition 
N  * @{
N  */
N#define MODE_ENCRYPT             ((uint8_t)0x01)
N#define MODE_DECRYPT             ((uint8_t)0x00)
N
N/**
N  * @}
N  */
N
N/** @defgroup CRYP_DMA_transfer_requests 
N  * @{
N  */
N#define CRYP_DMAReq_DataIN             ((uint8_t)0x01)
N#define CRYP_DMAReq_DataOUT            ((uint8_t)0x02)
N#define IS_CRYP_DMAREQ(DMAREQ) ((((DMAREQ) & (uint8_t)0xFC) == 0x00) && ((DMAREQ) != 0x00))
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/
N
N/*  Function used to set the CRYP configuration to the default reset state ****/
Nvoid CRYP_DeInit(void);
N
N/* CRYP Initialization and Configuration functions ****************************/
Nvoid CRYP_Init(CRYP_InitTypeDef* CRYP_InitStruct);
Nvoid CRYP_StructInit(CRYP_InitTypeDef* CRYP_InitStruct);
Nvoid CRYP_KeyInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct);
Nvoid CRYP_KeyStructInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct);
Nvoid CRYP_IVInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct);
Nvoid CRYP_IVStructInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct);
Nvoid CRYP_Cmd(FunctionalState NewState);
Nvoid CRYP_PhaseConfig(uint32_t CRYP_Phase);
Nvoid CRYP_FIFOFlush(void);
N/* CRYP Data processing functions *********************************************/
Nvoid CRYP_DataIn(uint32_t Data);
Nuint32_t CRYP_DataOut(void);
N
N/* CRYP Context swapping functions ********************************************/
NErrorStatus CRYP_SaveContext(CRYP_Context* CRYP_ContextSave,
N                             CRYP_KeyInitTypeDef* CRYP_KeyInitStruct);
Nvoid CRYP_RestoreContext(CRYP_Context* CRYP_ContextRestore);
N
N/* CRYP DMA interface function ************************************************/
Nvoid CRYP_DMACmd(uint8_t CRYP_DMAReq, FunctionalState NewState);
N
N/* Interrupts and flags management functions **********************************/
Nvoid CRYP_ITConfig(uint8_t CRYP_IT, FunctionalState NewState);
NITStatus CRYP_GetITStatus(uint8_t CRYP_IT);
NFunctionalState CRYP_GetCmdStatus(void);
NFlagStatus CRYP_GetFlagStatus(uint8_t CRYP_FLAG);
N
N/* High Level AES functions **************************************************/
NErrorStatus CRYP_AES_ECB(uint8_t Mode,
N                         uint8_t *Key, uint16_t Keysize,
N                         uint8_t *Input, uint32_t Ilength,
N                         uint8_t *Output);
N
NErrorStatus CRYP_AES_CBC(uint8_t Mode,
N                         uint8_t InitVectors[16],
N                         uint8_t *Key, uint16_t Keysize,
N                         uint8_t *Input, uint32_t Ilength,
N                         uint8_t *Output);
N
NErrorStatus CRYP_AES_CTR(uint8_t Mode,
N                         uint8_t InitVectors[16],
N                         uint8_t *Key, uint16_t Keysize,
N                         uint8_t *Input, uint32_t Ilength,
N                         uint8_t *Output);
N
NErrorStatus CRYP_AES_GCM(uint8_t Mode, uint8_t InitVectors[16],
N                         uint8_t *Key, uint16_t Keysize,
N                         uint8_t *Input, uint32_t ILength,
N                         uint8_t *Header, uint32_t HLength,
N                         uint8_t *Output, uint8_t *AuthTAG);
N
NErrorStatus CRYP_AES_CCM(uint8_t Mode, 
N                         uint8_t* Nonce, uint32_t NonceSize,
N                         uint8_t* Key, uint16_t Keysize,
N                         uint8_t* Input, uint32_t ILength,
N                         uint8_t* Header, uint32_t HLength, uint8_t *HBuffer,
N                         uint8_t* Output,
N                         uint8_t* AuthTAG, uint32_t TAGSize);
N
N/* High Level TDES functions **************************************************/
NErrorStatus CRYP_TDES_ECB(uint8_t Mode,
N                           uint8_t Key[24], 
N                           uint8_t *Input, uint32_t Ilength,
N                           uint8_t *Output);
N
NErrorStatus CRYP_TDES_CBC(uint8_t Mode,
N                          uint8_t Key[24],
N                          uint8_t InitVectors[8],
N                          uint8_t *Input, uint32_t Ilength,
N                          uint8_t *Output);
N
N/* High Level DES functions **************************************************/
NErrorStatus CRYP_DES_ECB(uint8_t Mode,
N                         uint8_t Key[8],
N                         uint8_t *Input, uint32_t Ilength,
N                         uint8_t *Output);
N
NErrorStatus CRYP_DES_CBC(uint8_t Mode,
N                         uint8_t Key[8],
N                         uint8_t InitVectors[8],
N                         uint8_t *Input,uint32_t Ilength,
N                         uint8_t *Output);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F4xx_CRYP_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 81 "..\..\Service\stm32f4xx_conf.h" 2
N#include "stm32f4xx_hash.h"
L 1 "..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\stm32f4xx_hash.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_hash.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    04-November-2016
N  * @brief   This file contains all the functions prototypes for the HASH 
N  *          firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_HASH_H
N#define __STM32F4xx_HASH_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
N
N/** @addtogroup STM32F4xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup HASH
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief   HASH Init structure definition
N  */ 
Ntypedef struct
N{
N  uint32_t HASH_AlgoSelection; /*!< SHA-1, SHA-224, SHA-256 or MD5. This parameter
N                                    can be a value of @ref HASH_Algo_Selection */
N  uint32_t HASH_AlgoMode;      /*!< HASH or HMAC. This parameter can be a value 
N                                    of @ref HASH_processor_Algorithm_Mode */
N  uint32_t HASH_DataType;      /*!< 32-bit data, 16-bit data, 8-bit data or 
N                                    bit string. This parameter can be a value of
N                                    @ref HASH_Data_Type */
N  uint32_t HASH_HMACKeyType;   /*!< HMAC Short key or HMAC Long Key. This parameter
N                                    can be a value of @ref HASH_HMAC_Long_key_only_for_HMAC_mode */
N}HASH_InitTypeDef;
N
N/** 
N  * @brief  HASH message digest result structure definition  
N  */ 
Ntypedef struct
N{
N  uint32_t Data[8];      /*!< Message digest result : 8x 32bit wors for SHA-256,
N                                                      7x 32bit wors for SHA-224,
N                                                      5x 32bit words for SHA-1 or
N                                                      4x 32bit words for MD5  */
N} HASH_MsgDigest; 
N
N/** 
N  * @brief  HASH context swapping structure definition  
N  */ 
Ntypedef struct
N{
N  uint32_t HASH_IMR; 
N  uint32_t HASH_STR;      
N  uint32_t HASH_CR;     
N  uint32_t HASH_CSR[54];       
N}HASH_Context;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup HASH_Exported_Constants
N  * @{
N  */ 
N
N/** @defgroup HASH_Algo_Selection 
N  * @{
N  */ 
N#define HASH_AlgoSelection_SHA1      ((uint32_t)0x0000) /*!< HASH function is SHA1   */
N#define HASH_AlgoSelection_SHA224    HASH_CR_ALGO_1     /*!< HASH function is SHA224 */
N#define HASH_AlgoSelection_SHA256    HASH_CR_ALGO       /*!< HASH function is SHA256 */
N#define HASH_AlgoSelection_MD5       HASH_CR_ALGO_0     /*!< HASH function is MD5    */
N
N#define IS_HASH_ALGOSELECTION(ALGOSELECTION) (((ALGOSELECTION) == HASH_AlgoSelection_SHA1) || \
N                                              ((ALGOSELECTION) == HASH_AlgoSelection_SHA224) || \
N                                              ((ALGOSELECTION) == HASH_AlgoSelection_SHA256) || \
N                                              ((ALGOSELECTION) == HASH_AlgoSelection_MD5))
X#define IS_HASH_ALGOSELECTION(ALGOSELECTION) (((ALGOSELECTION) == HASH_AlgoSelection_SHA1) ||                                               ((ALGOSELECTION) == HASH_AlgoSelection_SHA224) ||                                               ((ALGOSELECTION) == HASH_AlgoSelection_SHA256) ||                                               ((ALGOSELECTION) == HASH_AlgoSelection_MD5))
N/**
N  * @}
N  */
N
N/** @defgroup HASH_processor_Algorithm_Mode 
N  * @{
N  */ 
N#define HASH_AlgoMode_HASH         ((uint32_t)0x00000000) /*!< Algorithm is HASH */ 
N#define HASH_AlgoMode_HMAC         HASH_CR_MODE           /*!< Algorithm is HMAC */
N
N#define IS_HASH_ALGOMODE(ALGOMODE) (((ALGOMODE) == HASH_AlgoMode_HASH) || \
N                                    ((ALGOMODE) == HASH_AlgoMode_HMAC))
X#define IS_HASH_ALGOMODE(ALGOMODE) (((ALGOMODE) == HASH_AlgoMode_HASH) ||                                     ((ALGOMODE) == HASH_AlgoMode_HMAC))
N/**
N  * @}
N  */
N
N/** @defgroup HASH_Data_Type  
N  * @{
N  */  
N#define HASH_DataType_32b          ((uint32_t)0x0000) /*!< 32-bit data. No swapping                     */
N#define HASH_DataType_16b          HASH_CR_DATATYPE_0 /*!< 16-bit data. Each half word is swapped       */
N#define HASH_DataType_8b           HASH_CR_DATATYPE_1 /*!< 8-bit data. All bytes are swapped            */
N#define HASH_DataType_1b           HASH_CR_DATATYPE   /*!< 1-bit data. In the word all bits are swapped */
N
N#define IS_HASH_DATATYPE(DATATYPE) (((DATATYPE) == HASH_DataType_32b)|| \
N                                    ((DATATYPE) == HASH_DataType_16b)|| \
N                                    ((DATATYPE) == HASH_DataType_8b) || \
N                                    ((DATATYPE) == HASH_DataType_1b))
X#define IS_HASH_DATATYPE(DATATYPE) (((DATATYPE) == HASH_DataType_32b)||                                     ((DATATYPE) == HASH_DataType_16b)||                                     ((DATATYPE) == HASH_DataType_8b) ||                                     ((DATATYPE) == HASH_DataType_1b))
N/**
N  * @}
N  */
N
N/** @defgroup HASH_HMAC_Long_key_only_for_HMAC_mode  
N  * @{
N  */ 
N#define HASH_HMACKeyType_ShortKey      ((uint32_t)0x00000000) /*!< HMAC Key is <= 64 bytes */
N#define HASH_HMACKeyType_LongKey       HASH_CR_LKEY           /*!< HMAC Key is > 64 bytes  */
N
N#define IS_HASH_HMAC_KEYTYPE(KEYTYPE) (((KEYTYPE) == HASH_HMACKeyType_ShortKey) || \
N                                       ((KEYTYPE) == HASH_HMACKeyType_LongKey))
X#define IS_HASH_HMAC_KEYTYPE(KEYTYPE) (((KEYTYPE) == HASH_HMACKeyType_ShortKey) ||                                        ((KEYTYPE) == HASH_HMACKeyType_LongKey))
N/**
N  * @}
N  */
N
N/** @defgroup Number_of_valid_bits_in_last_word_of_the_message   
N  * @{
N  */  
N#define IS_HASH_VALIDBITSNUMBER(VALIDBITS) ((VALIDBITS) <= 0x1F)
N
N/**
N  * @}
N  */
N
N/** @defgroup HASH_interrupts_definition   
N  * @{
N  */  
N#define HASH_IT_DINI               HASH_IMR_DINIM  /*!< A new block can be entered into the input buffer (DIN) */
N#define HASH_IT_DCI                HASH_IMR_DCIM   /*!< Digest calculation complete                            */
N
N#define IS_HASH_IT(IT) ((((IT) & (uint32_t)0xFFFFFFFC) == 0x00000000) && ((IT) != 0x00000000))
N#define IS_HASH_GET_IT(IT) (((IT) == HASH_IT_DINI) || ((IT) == HASH_IT_DCI))
N				   
N/**
N  * @}
N  */
N
N/** @defgroup HASH_flags_definition   
N  * @{
N  */  
N#define HASH_FLAG_DINIS            HASH_SR_DINIS  /*!< 16 locations are free in the DIN : A new block can be entered into the input buffer */
N#define HASH_FLAG_DCIS             HASH_SR_DCIS   /*!< Digest calculation complete                                                         */
N#define HASH_FLAG_DMAS             HASH_SR_DMAS   /*!< DMA interface is enabled (DMAE=1) or a transfer is ongoing                          */
N#define HASH_FLAG_BUSY             HASH_SR_BUSY   /*!< The hash core is Busy : processing a block of data                                  */
N#define HASH_FLAG_DINNE            HASH_CR_DINNE  /*!< DIN not empty : The input buffer contains at least one word of data                 */
N
N#define IS_HASH_GET_FLAG(FLAG) (((FLAG) == HASH_FLAG_DINIS) || \
N                                ((FLAG) == HASH_FLAG_DCIS)  || \
N                                ((FLAG) == HASH_FLAG_DMAS)  || \
N                                ((FLAG) == HASH_FLAG_BUSY)  || \
N                                ((FLAG) == HASH_FLAG_DINNE)) 
X#define IS_HASH_GET_FLAG(FLAG) (((FLAG) == HASH_FLAG_DINIS) ||                                 ((FLAG) == HASH_FLAG_DCIS)  ||                                 ((FLAG) == HASH_FLAG_DMAS)  ||                                 ((FLAG) == HASH_FLAG_BUSY)  ||                                 ((FLAG) == HASH_FLAG_DINNE)) 
N
N#define IS_HASH_CLEAR_FLAG(FLAG)(((FLAG) == HASH_FLAG_DINIS) || \
N                                 ((FLAG) == HASH_FLAG_DCIS))                                 
X#define IS_HASH_CLEAR_FLAG(FLAG)(((FLAG) == HASH_FLAG_DINIS) ||                                  ((FLAG) == HASH_FLAG_DCIS))                                 
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/ 
N  
N/*  Function used to set the HASH configuration to the default reset state ****/
Nvoid HASH_DeInit(void);
N
N/* HASH Configuration function ************************************************/
Nvoid HASH_Init(HASH_InitTypeDef* HASH_InitStruct);
Nvoid HASH_StructInit(HASH_InitTypeDef* HASH_InitStruct);
Nvoid HASH_Reset(void);
N
N/* HASH Message Digest generation functions ***********************************/
Nvoid HASH_DataIn(uint32_t Data);
Nuint8_t HASH_GetInFIFOWordsNbr(void);
Nvoid HASH_SetLastWordValidBitsNbr(uint16_t ValidNumber);
Nvoid HASH_StartDigest(void);
Nvoid HASH_AutoStartDigest(FunctionalState NewState);
Nvoid HASH_GetDigest(HASH_MsgDigest* HASH_MessageDigest);
N
N/* HASH Context swapping functions ********************************************/
Nvoid HASH_SaveContext(HASH_Context* HASH_ContextSave);
Nvoid HASH_RestoreContext(HASH_Context* HASH_ContextRestore);
N
N/* HASH DMA interface function ************************************************/
Nvoid HASH_DMACmd(FunctionalState NewState);
N
N/* HASH Interrupts and flags management functions *****************************/
Nvoid HASH_ITConfig(uint32_t HASH_IT, FunctionalState NewState);
NFlagStatus HASH_GetFlagStatus(uint32_t HASH_FLAG);
Nvoid HASH_ClearFlag(uint32_t HASH_FLAG);
NITStatus HASH_GetITStatus(uint32_t HASH_IT);
Nvoid HASH_ClearITPendingBit(uint32_t HASH_IT);
N
N/* High Level SHA1 functions **************************************************/
NErrorStatus HASH_SHA1(uint8_t *Input, uint32_t Ilen, uint8_t Output[20]);
NErrorStatus HMAC_SHA1(uint8_t *Key, uint32_t Keylen,
N                      uint8_t *Input, uint32_t Ilen,
N                      uint8_t Output[20]);
N
N/* High Level MD5 functions ***************************************************/
NErrorStatus HASH_MD5(uint8_t *Input, uint32_t Ilen, uint8_t Output[16]);
NErrorStatus HMAC_MD5(uint8_t *Key, uint32_t Keylen,
N                     uint8_t *Input, uint32_t Ilen,
N                     uint8_t Output[16]);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F4xx_HASH_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 82 "..\..\Service\stm32f4xx_conf.h" 2
N#include "stm32f4xx_rng.h"
L 1 "..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\stm32f4xx_rng.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_rng.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    04-November-2016
N  * @brief   This file contains all the functions prototypes for the Random 
N  *          Number Generator(RNG) firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_RNG_H
N#define __STM32F4xx_RNG_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
N
N/** @addtogroup STM32F4xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup RNG
N  * @{
N  */ 
N#if defined(STM32F40_41xxx) || defined(STM32F427_437xx) || defined(STM32F410xx) || defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F429_439xx) || defined(STM32F469_479xx)
X#if 1L || 0L || 0L || 0L || 0L || 0L || 0L
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/ 
N
N/** @defgroup RNG_Exported_Constants
N  * @{
N  */
N  
N/** @defgroup RNG_flags_definition  
N  * @{
N  */ 
N#define RNG_FLAG_DRDY               ((uint8_t)0x0001) /*!< Data ready */
N#define RNG_FLAG_CECS               ((uint8_t)0x0002) /*!< Clock error current status */
N#define RNG_FLAG_SECS               ((uint8_t)0x0004) /*!< Seed error current status */
N
N#define IS_RNG_GET_FLAG(RNG_FLAG) (((RNG_FLAG) == RNG_FLAG_DRDY) || \
N                                   ((RNG_FLAG) == RNG_FLAG_CECS) || \
N                                   ((RNG_FLAG) == RNG_FLAG_SECS))
X#define IS_RNG_GET_FLAG(RNG_FLAG) (((RNG_FLAG) == RNG_FLAG_DRDY) ||                                    ((RNG_FLAG) == RNG_FLAG_CECS) ||                                    ((RNG_FLAG) == RNG_FLAG_SECS))
N#define IS_RNG_CLEAR_FLAG(RNG_FLAG) (((RNG_FLAG) == RNG_FLAG_CECS) || \
N                                    ((RNG_FLAG) == RNG_FLAG_SECS))
X#define IS_RNG_CLEAR_FLAG(RNG_FLAG) (((RNG_FLAG) == RNG_FLAG_CECS) ||                                     ((RNG_FLAG) == RNG_FLAG_SECS))
N/**
N  * @}
N  */ 
N
N/** @defgroup RNG_interrupts_definition   
N  * @{
N  */  
N#define RNG_IT_CEI                  ((uint8_t)0x20) /*!< Clock error interrupt */
N#define RNG_IT_SEI                  ((uint8_t)0x40) /*!< Seed error interrupt */
N
N#define IS_RNG_IT(IT) ((((IT) & (uint8_t)0x9F) == 0x00) && ((IT) != 0x00))
N#define IS_RNG_GET_IT(RNG_IT) (((RNG_IT) == RNG_IT_CEI) || ((RNG_IT) == RNG_IT_SEI))
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/ 
N
N/*  Function used to set the RNG configuration to the default reset state *****/ 
Nvoid RNG_DeInit(void);
N
N/* Configuration function *****************************************************/
Nvoid RNG_Cmd(FunctionalState NewState);
N
N/* Get 32 bit Random number function ******************************************/
Nuint32_t RNG_GetRandomNumber(void);
N
N/* Interrupts and flags management functions **********************************/
Nvoid RNG_ITConfig(FunctionalState NewState);
NFlagStatus RNG_GetFlagStatus(uint8_t RNG_FLAG);
Nvoid RNG_ClearFlag(uint8_t RNG_FLAG);
NITStatus RNG_GetITStatus(uint8_t RNG_IT);
Nvoid RNG_ClearITPendingBit(uint8_t RNG_IT);
N#endif /* STM32F40_41xxx || STM32F427_437xx || STM32F410xx || STM32F412xG || STM32F413_423xx || STM32F429_439xx || STM32F469_479xx */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F4xx_RNG_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 83 "..\..\Service\stm32f4xx_conf.h" 2
N#include "stm32f4xx_can.h"
L 1 "..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\stm32f4xx_can.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_can.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    04-November-2016
N  * @brief   This file contains all the functions prototypes for the CAN firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_CAN_H
N#define __STM32F4xx_CAN_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
N
N/** @addtogroup STM32F4xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup CAN
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N#if defined(STM32F413_423xx)
X#if 0L
S#define IS_CAN_ALL_PERIPH(PERIPH) (((PERIPH) == CAN1) || \
S                                   ((PERIPH) == CAN2) || \
S                                   ((PERIPH) == CAN3))
X#define IS_CAN_ALL_PERIPH(PERIPH) (((PERIPH) == CAN1) ||                                    ((PERIPH) == CAN2) ||                                    ((PERIPH) == CAN3))
N#else
N#define IS_CAN_ALL_PERIPH(PERIPH) (((PERIPH) == CAN1) || \
N                                   ((PERIPH) == CAN2))
X#define IS_CAN_ALL_PERIPH(PERIPH) (((PERIPH) == CAN1) ||                                    ((PERIPH) == CAN2))
N#endif /* STM32F413_423xx */
N
N/** 
N  * @brief  CAN init structure definition
N  */
Ntypedef struct
N{
N  uint16_t CAN_Prescaler;   /*!< Specifies the length of a time quantum. 
N                                 It ranges from 1 to 1024. */
N  
N  uint8_t CAN_Mode;         /*!< Specifies the CAN operating mode.
N                                 This parameter can be a value of @ref CAN_operating_mode */
N
N  uint8_t CAN_SJW;          /*!< Specifies the maximum number of time quanta 
N                                 the CAN hardware is allowed to lengthen or 
N                                 shorten a bit to perform resynchronization.
N                                 This parameter can be a value of @ref CAN_synchronisation_jump_width */
N
N  uint8_t CAN_BS1;          /*!< Specifies the number of time quanta in Bit 
N                                 Segment 1. This parameter can be a value of 
N                                 @ref CAN_time_quantum_in_bit_segment_1 */
N
N  uint8_t CAN_BS2;          /*!< Specifies the number of time quanta in Bit Segment 2.
N                                 This parameter can be a value of @ref CAN_time_quantum_in_bit_segment_2 */
N  
N  FunctionalState CAN_TTCM; /*!< Enable or disable the time triggered communication mode.
N                                This parameter can be set either to ENABLE or DISABLE. */
N  
N  FunctionalState CAN_ABOM;  /*!< Enable or disable the automatic bus-off management.
N                                  This parameter can be set either to ENABLE or DISABLE. */
N
N  FunctionalState CAN_AWUM;  /*!< Enable or disable the automatic wake-up mode. 
N                                  This parameter can be set either to ENABLE or DISABLE. */
N
N  FunctionalState CAN_NART;  /*!< Enable or disable the non-automatic retransmission mode.
N                                  This parameter can be set either to ENABLE or DISABLE. */
N
N  FunctionalState CAN_RFLM;  /*!< Enable or disable the Receive FIFO Locked mode.
N                                  This parameter can be set either to ENABLE or DISABLE. */
N
N  FunctionalState CAN_TXFP;  /*!< Enable or disable the transmit FIFO priority.
N                                  This parameter can be set either to ENABLE or DISABLE. */
N} CAN_InitTypeDef;
N
N/** 
N  * @brief  CAN filter init structure definition
N  */
Ntypedef struct
N{
N  uint16_t CAN_FilterIdHigh;         /*!< Specifies the filter identification number (MSBs for a 32-bit
N                                              configuration, first one for a 16-bit configuration).
N                                              This parameter can be a value between 0x0000 and 0xFFFF */
N
N  uint16_t CAN_FilterIdLow;          /*!< Specifies the filter identification number (LSBs for a 32-bit
N                                              configuration, second one for a 16-bit configuration).
N                                              This parameter can be a value between 0x0000 and 0xFFFF */
N
N  uint16_t CAN_FilterMaskIdHigh;     /*!< Specifies the filter mask number or identification number,
N                                              according to the mode (MSBs for a 32-bit configuration,
N                                              first one for a 16-bit configuration).
N                                              This parameter can be a value between 0x0000 and 0xFFFF */
N
N  uint16_t CAN_FilterMaskIdLow;      /*!< Specifies the filter mask number or identification number,
N                                              according to the mode (LSBs for a 32-bit configuration,
N                                              second one for a 16-bit configuration).
N                                              This parameter can be a value between 0x0000 and 0xFFFF */
N
N  uint16_t CAN_FilterFIFOAssignment; /*!< Specifies the FIFO (0 or 1) which will be assigned to the filter.
N                                              This parameter can be a value of @ref CAN_filter_FIFO */
N  
N  uint8_t CAN_FilterNumber;          /*!< Specifies the filter which will be initialized. It ranges from 0 to 13. */
N
N  uint8_t CAN_FilterMode;            /*!< Specifies the filter mode to be initialized.
N                                              This parameter can be a value of @ref CAN_filter_mode */
N
N  uint8_t CAN_FilterScale;           /*!< Specifies the filter scale.
N                                              This parameter can be a value of @ref CAN_filter_scale */
N
N  FunctionalState CAN_FilterActivation; /*!< Enable or disable the filter.
N                                              This parameter can be set either to ENABLE or DISABLE. */
N} CAN_FilterInitTypeDef;
N
N/** 
N  * @brief  CAN Tx message structure definition  
N  */
Ntypedef struct
N{
N  uint32_t StdId;  /*!< Specifies the standard identifier.
N                        This parameter can be a value between 0 to 0x7FF. */
N
N  uint32_t ExtId;  /*!< Specifies the extended identifier.
N                        This parameter can be a value between 0 to 0x1FFFFFFF. */
N
N  uint8_t IDE;     /*!< Specifies the type of identifier for the message that 
N                        will be transmitted. This parameter can be a value 
N                        of @ref CAN_identifier_type */
N
N  uint8_t RTR;     /*!< Specifies the type of frame for the message that will 
N                        be transmitted. This parameter can be a value of 
N                        @ref CAN_remote_transmission_request */
N
N  uint8_t DLC;     /*!< Specifies the length of the frame that will be 
N                        transmitted. This parameter can be a value between 
N                        0 to 8 */
N
N  uint8_t Data[8]; /*!< Contains the data to be transmitted. It ranges from 0 
N                        to 0xFF. */
N} CanTxMsg;
N
N/** 
N  * @brief  CAN Rx message structure definition  
N  */
Ntypedef struct
N{
N  uint32_t StdId;  /*!< Specifies the standard identifier.
N                        This parameter can be a value between 0 to 0x7FF. */
N
N  uint32_t ExtId;  /*!< Specifies the extended identifier.
N                        This parameter can be a value between 0 to 0x1FFFFFFF. */
N
N  uint8_t IDE;     /*!< Specifies the type of identifier for the message that 
N                        will be received. This parameter can be a value of 
N                        @ref CAN_identifier_type */
N
N  uint8_t RTR;     /*!< Specifies the type of frame for the received message.
N                        This parameter can be a value of 
N                        @ref CAN_remote_transmission_request */
N
N  uint8_t DLC;     /*!< Specifies the length of the frame that will be received.
N                        This parameter can be a value between 0 to 8 */
N
N  uint8_t Data[8]; /*!< Contains the data to be received. It ranges from 0 to 
N                        0xFF. */
N
N  uint8_t FMI;     /*!< Specifies the index of the filter the message stored in 
N                        the mailbox passes through. This parameter can be a 
N                        value between 0 to 0xFF */
N} CanRxMsg;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup CAN_Exported_Constants
N  * @{
N  */
N
N/** @defgroup CAN_InitStatus 
N  * @{
N  */
N
N#define CAN_InitStatus_Failed              ((uint8_t)0x00) /*!< CAN initialization failed */
N#define CAN_InitStatus_Success             ((uint8_t)0x01) /*!< CAN initialization OK */
N
N
N/* Legacy defines */
N#define CANINITFAILED    CAN_InitStatus_Failed
N#define CANINITOK        CAN_InitStatus_Success
N/**
N  * @}
N  */
N
N/** @defgroup CAN_operating_mode 
N  * @{
N  */
N
N#define CAN_Mode_Normal             ((uint8_t)0x00)  /*!< normal mode */
N#define CAN_Mode_LoopBack           ((uint8_t)0x01)  /*!< loopback mode */
N#define CAN_Mode_Silent             ((uint8_t)0x02)  /*!< silent mode */
N#define CAN_Mode_Silent_LoopBack    ((uint8_t)0x03)  /*!< loopback combined with silent mode */
N
N#define IS_CAN_MODE(MODE) (((MODE) == CAN_Mode_Normal) || \
N                           ((MODE) == CAN_Mode_LoopBack)|| \
N                           ((MODE) == CAN_Mode_Silent) || \
N                           ((MODE) == CAN_Mode_Silent_LoopBack))
X#define IS_CAN_MODE(MODE) (((MODE) == CAN_Mode_Normal) ||                            ((MODE) == CAN_Mode_LoopBack)||                            ((MODE) == CAN_Mode_Silent) ||                            ((MODE) == CAN_Mode_Silent_LoopBack))
N/**
N  * @}
N  */
N
N
N /**
N  * @defgroup CAN_operating_mode 
N  * @{
N  */  
N#define CAN_OperatingMode_Initialization  ((uint8_t)0x00) /*!< Initialization mode */
N#define CAN_OperatingMode_Normal          ((uint8_t)0x01) /*!< Normal mode */
N#define CAN_OperatingMode_Sleep           ((uint8_t)0x02) /*!< sleep mode */
N
N
N#define IS_CAN_OPERATING_MODE(MODE) (((MODE) == CAN_OperatingMode_Initialization) ||\
N                                    ((MODE) == CAN_OperatingMode_Normal)|| \
N																		((MODE) == CAN_OperatingMode_Sleep))
X#define IS_CAN_OPERATING_MODE(MODE) (((MODE) == CAN_OperatingMode_Initialization) ||                                    ((MODE) == CAN_OperatingMode_Normal)|| 																		((MODE) == CAN_OperatingMode_Sleep))
N/**
N  * @}
N  */
N  
N/**
N  * @defgroup CAN_operating_mode_status
N  * @{
N  */  
N
N#define CAN_ModeStatus_Failed    ((uint8_t)0x00)                /*!< CAN entering the specific mode failed */
N#define CAN_ModeStatus_Success   ((uint8_t)!CAN_ModeStatus_Failed)   /*!< CAN entering the specific mode Succeed */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_synchronisation_jump_width 
N  * @{
N  */
N#define CAN_SJW_1tq                 ((uint8_t)0x00)  /*!< 1 time quantum */
N#define CAN_SJW_2tq                 ((uint8_t)0x01)  /*!< 2 time quantum */
N#define CAN_SJW_3tq                 ((uint8_t)0x02)  /*!< 3 time quantum */
N#define CAN_SJW_4tq                 ((uint8_t)0x03)  /*!< 4 time quantum */
N
N#define IS_CAN_SJW(SJW) (((SJW) == CAN_SJW_1tq) || ((SJW) == CAN_SJW_2tq)|| \
N                         ((SJW) == CAN_SJW_3tq) || ((SJW) == CAN_SJW_4tq))
X#define IS_CAN_SJW(SJW) (((SJW) == CAN_SJW_1tq) || ((SJW) == CAN_SJW_2tq)||                          ((SJW) == CAN_SJW_3tq) || ((SJW) == CAN_SJW_4tq))
N/**
N  * @}
N  */
N
N/** @defgroup CAN_time_quantum_in_bit_segment_1 
N  * @{
N  */
N#define CAN_BS1_1tq                 ((uint8_t)0x00)  /*!< 1 time quantum */
N#define CAN_BS1_2tq                 ((uint8_t)0x01)  /*!< 2 time quantum */
N#define CAN_BS1_3tq                 ((uint8_t)0x02)  /*!< 3 time quantum */
N#define CAN_BS1_4tq                 ((uint8_t)0x03)  /*!< 4 time quantum */
N#define CAN_BS1_5tq                 ((uint8_t)0x04)  /*!< 5 time quantum */
N#define CAN_BS1_6tq                 ((uint8_t)0x05)  /*!< 6 time quantum */
N#define CAN_BS1_7tq                 ((uint8_t)0x06)  /*!< 7 time quantum */
N#define CAN_BS1_8tq                 ((uint8_t)0x07)  /*!< 8 time quantum */
N#define CAN_BS1_9tq                 ((uint8_t)0x08)  /*!< 9 time quantum */
N#define CAN_BS1_10tq                ((uint8_t)0x09)  /*!< 10 time quantum */
N#define CAN_BS1_11tq                ((uint8_t)0x0A)  /*!< 11 time quantum */
N#define CAN_BS1_12tq                ((uint8_t)0x0B)  /*!< 12 time quantum */
N#define CAN_BS1_13tq                ((uint8_t)0x0C)  /*!< 13 time quantum */
N#define CAN_BS1_14tq                ((uint8_t)0x0D)  /*!< 14 time quantum */
N#define CAN_BS1_15tq                ((uint8_t)0x0E)  /*!< 15 time quantum */
N#define CAN_BS1_16tq                ((uint8_t)0x0F)  /*!< 16 time quantum */
N
N#define IS_CAN_BS1(BS1) ((BS1) <= CAN_BS1_16tq)
N/**
N  * @}
N  */
N
N/** @defgroup CAN_time_quantum_in_bit_segment_2 
N  * @{
N  */
N#define CAN_BS2_1tq                 ((uint8_t)0x00)  /*!< 1 time quantum */
N#define CAN_BS2_2tq                 ((uint8_t)0x01)  /*!< 2 time quantum */
N#define CAN_BS2_3tq                 ((uint8_t)0x02)  /*!< 3 time quantum */
N#define CAN_BS2_4tq                 ((uint8_t)0x03)  /*!< 4 time quantum */
N#define CAN_BS2_5tq                 ((uint8_t)0x04)  /*!< 5 time quantum */
N#define CAN_BS2_6tq                 ((uint8_t)0x05)  /*!< 6 time quantum */
N#define CAN_BS2_7tq                 ((uint8_t)0x06)  /*!< 7 time quantum */
N#define CAN_BS2_8tq                 ((uint8_t)0x07)  /*!< 8 time quantum */
N
N#define IS_CAN_BS2(BS2) ((BS2) <= CAN_BS2_8tq)
N/**
N  * @}
N  */
N
N/** @defgroup CAN_clock_prescaler 
N  * @{
N  */
N#define IS_CAN_PRESCALER(PRESCALER) (((PRESCALER) >= 1) && ((PRESCALER) <= 1024))
N/**
N  * @}
N  */
N
N/** @defgroup CAN_filter_number 
N  * @{
N  */
N#define IS_CAN_FILTER_NUMBER(NUMBER) ((NUMBER) <= 27)
N/**
N  * @}
N  */
N
N/** @defgroup CAN_filter_mode 
N  * @{
N  */
N#define CAN_FilterMode_IdMask       ((uint8_t)0x00)  /*!< identifier/mask mode */
N#define CAN_FilterMode_IdList       ((uint8_t)0x01)  /*!< identifier list mode */
N
N#define IS_CAN_FILTER_MODE(MODE) (((MODE) == CAN_FilterMode_IdMask) || \
N                                  ((MODE) == CAN_FilterMode_IdList))
X#define IS_CAN_FILTER_MODE(MODE) (((MODE) == CAN_FilterMode_IdMask) ||                                   ((MODE) == CAN_FilterMode_IdList))
N/**
N  * @}
N  */
N
N/** @defgroup CAN_filter_scale 
N  * @{
N  */
N#define CAN_FilterScale_16bit       ((uint8_t)0x00) /*!< Two 16-bit filters */
N#define CAN_FilterScale_32bit       ((uint8_t)0x01) /*!< One 32-bit filter */
N
N#define IS_CAN_FILTER_SCALE(SCALE) (((SCALE) == CAN_FilterScale_16bit) || \
N                                    ((SCALE) == CAN_FilterScale_32bit))
X#define IS_CAN_FILTER_SCALE(SCALE) (((SCALE) == CAN_FilterScale_16bit) ||                                     ((SCALE) == CAN_FilterScale_32bit))
N/**
N  * @}
N  */
N
N/** @defgroup CAN_filter_FIFO
N  * @{
N  */
N#define CAN_Filter_FIFO0             ((uint8_t)0x00)  /*!< Filter FIFO 0 assignment for filter x */
N#define CAN_Filter_FIFO1             ((uint8_t)0x01)  /*!< Filter FIFO 1 assignment for filter x */
N#define IS_CAN_FILTER_FIFO(FIFO) (((FIFO) == CAN_FilterFIFO0) || \
N                                  ((FIFO) == CAN_FilterFIFO1))
X#define IS_CAN_FILTER_FIFO(FIFO) (((FIFO) == CAN_FilterFIFO0) ||                                   ((FIFO) == CAN_FilterFIFO1))
N
N/* Legacy defines */
N#define CAN_FilterFIFO0  CAN_Filter_FIFO0
N#define CAN_FilterFIFO1  CAN_Filter_FIFO1
N/**
N  * @}
N  */
N
N/** @defgroup CAN_Start_bank_filter_for_slave_CAN 
N  * @{
N  */
N#define IS_CAN_BANKNUMBER(BANKNUMBER) (((BANKNUMBER) >= 1) && ((BANKNUMBER) <= 27))
N/**
N  * @}
N  */
N
N/** @defgroup CAN_Tx 
N  * @{
N  */
N#define IS_CAN_TRANSMITMAILBOX(TRANSMITMAILBOX) ((TRANSMITMAILBOX) <= ((uint8_t)0x02))
N#define IS_CAN_STDID(STDID)   ((STDID) <= ((uint32_t)0x7FF))
N#define IS_CAN_EXTID(EXTID)   ((EXTID) <= ((uint32_t)0x1FFFFFFF))
N#define IS_CAN_DLC(DLC)       ((DLC) <= ((uint8_t)0x08))
N/**
N  * @}
N  */
N
N/** @defgroup CAN_identifier_type 
N  * @{
N  */
N#define CAN_Id_Standard             ((uint32_t)0x00000000)  /*!< Standard Id */
N#define CAN_Id_Extended             ((uint32_t)0x00000004)  /*!< Extended Id */
N#define IS_CAN_IDTYPE(IDTYPE) (((IDTYPE) == CAN_Id_Standard) || \
N                               ((IDTYPE) == CAN_Id_Extended))
X#define IS_CAN_IDTYPE(IDTYPE) (((IDTYPE) == CAN_Id_Standard) ||                                ((IDTYPE) == CAN_Id_Extended))
N
N/* Legacy defines */
N#define CAN_ID_STD      CAN_Id_Standard           
N#define CAN_ID_EXT      CAN_Id_Extended
N/**
N  * @}
N  */
N
N/** @defgroup CAN_remote_transmission_request 
N  * @{
N  */
N#define CAN_RTR_Data                ((uint32_t)0x00000000)  /*!< Data frame */
N#define CAN_RTR_Remote              ((uint32_t)0x00000002)  /*!< Remote frame */
N#define IS_CAN_RTR(RTR) (((RTR) == CAN_RTR_Data) || ((RTR) == CAN_RTR_Remote))
N
N/* Legacy defines */
N#define CAN_RTR_DATA     CAN_RTR_Data         
N#define CAN_RTR_REMOTE   CAN_RTR_Remote
N/**
N  * @}
N  */
N
N/** @defgroup CAN_transmit_constants 
N  * @{
N  */
N#define CAN_TxStatus_Failed         ((uint8_t)0x00)/*!< CAN transmission failed */
N#define CAN_TxStatus_Ok             ((uint8_t)0x01) /*!< CAN transmission succeeded */
N#define CAN_TxStatus_Pending        ((uint8_t)0x02) /*!< CAN transmission pending */
N#define CAN_TxStatus_NoMailBox      ((uint8_t)0x04) /*!< CAN cell did not provide 
N                                                         an empty mailbox */
N/* Legacy defines */	
N#define CANTXFAILED                  CAN_TxStatus_Failed
N#define CANTXOK                      CAN_TxStatus_Ok
N#define CANTXPENDING                 CAN_TxStatus_Pending
N#define CAN_NO_MB                    CAN_TxStatus_NoMailBox
N/**
N  * @}
N  */
N
N/** @defgroup CAN_receive_FIFO_number_constants 
N  * @{
N  */
N#define CAN_FIFO0                 ((uint8_t)0x00) /*!< CAN FIFO 0 used to receive */
N#define CAN_FIFO1                 ((uint8_t)0x01) /*!< CAN FIFO 1 used to receive */
N
N#define IS_CAN_FIFO(FIFO) (((FIFO) == CAN_FIFO0) || ((FIFO) == CAN_FIFO1))
N/**
N  * @}
N  */
N
N/** @defgroup CAN_sleep_constants 
N  * @{
N  */
N#define CAN_Sleep_Failed     ((uint8_t)0x00) /*!< CAN did not enter the sleep mode */
N#define CAN_Sleep_Ok         ((uint8_t)0x01) /*!< CAN entered the sleep mode */
N
N/* Legacy defines */	
N#define CANSLEEPFAILED   CAN_Sleep_Failed
N#define CANSLEEPOK       CAN_Sleep_Ok
N/**
N  * @}
N  */
N
N/** @defgroup CAN_wake_up_constants 
N  * @{
N  */
N#define CAN_WakeUp_Failed        ((uint8_t)0x00) /*!< CAN did not leave the sleep mode */
N#define CAN_WakeUp_Ok            ((uint8_t)0x01) /*!< CAN leaved the sleep mode */
N
N/* Legacy defines */
N#define CANWAKEUPFAILED   CAN_WakeUp_Failed        
N#define CANWAKEUPOK       CAN_WakeUp_Ok        
N/**
N  * @}
N  */
N
N/**
N  * @defgroup CAN_Error_Code_constants
N  * @{
N  */                                                         
N#define CAN_ErrorCode_NoErr           ((uint8_t)0x00) /*!< No Error */ 
N#define	CAN_ErrorCode_StuffErr        ((uint8_t)0x10) /*!< Stuff Error */ 
N#define	CAN_ErrorCode_FormErr         ((uint8_t)0x20) /*!< Form Error */ 
N#define	CAN_ErrorCode_ACKErr          ((uint8_t)0x30) /*!< Acknowledgment Error */ 
N#define	CAN_ErrorCode_BitRecessiveErr ((uint8_t)0x40) /*!< Bit Recessive Error */ 
N#define	CAN_ErrorCode_BitDominantErr  ((uint8_t)0x50) /*!< Bit Dominant Error */ 
N#define	CAN_ErrorCode_CRCErr          ((uint8_t)0x60) /*!< CRC Error  */ 
N#define	CAN_ErrorCode_SoftwareSetErr  ((uint8_t)0x70) /*!< Software Set Error */ 
N/**
N  * @}
N  */
N
N/** @defgroup CAN_flags 
N  * @{
N  */
N/* If the flag is 0x3XXXXXXX, it means that it can be used with CAN_GetFlagStatus()
N   and CAN_ClearFlag() functions. */
N/* If the flag is 0x1XXXXXXX, it means that it can only be used with 
N   CAN_GetFlagStatus() function.  */
N
N/* Transmit Flags */
N#define CAN_FLAG_RQCP0             ((uint32_t)0x38000001) /*!< Request MailBox0 Flag */
N#define CAN_FLAG_RQCP1             ((uint32_t)0x38000100) /*!< Request MailBox1 Flag */
N#define CAN_FLAG_RQCP2             ((uint32_t)0x38010000) /*!< Request MailBox2 Flag */
N
N/* Receive Flags */
N#define CAN_FLAG_FMP0              ((uint32_t)0x12000003) /*!< FIFO 0 Message Pending Flag */
N#define CAN_FLAG_FF0               ((uint32_t)0x32000008) /*!< FIFO 0 Full Flag            */
N#define CAN_FLAG_FOV0              ((uint32_t)0x32000010) /*!< FIFO 0 Overrun Flag         */
N#define CAN_FLAG_FMP1              ((uint32_t)0x14000003) /*!< FIFO 1 Message Pending Flag */
N#define CAN_FLAG_FF1               ((uint32_t)0x34000008) /*!< FIFO 1 Full Flag            */
N#define CAN_FLAG_FOV1              ((uint32_t)0x34000010) /*!< FIFO 1 Overrun Flag         */
N
N/* Operating Mode Flags */
N#define CAN_FLAG_WKU               ((uint32_t)0x31000008) /*!< Wake up Flag */
N#define CAN_FLAG_SLAK              ((uint32_t)0x31000012) /*!< Sleep acknowledge Flag */
N/* @note When SLAK interrupt is disabled (SLKIE=0), no polling on SLAKI is possible. 
N         In this case the SLAK bit can be polled.*/
N
N/* Error Flags */
N#define CAN_FLAG_EWG               ((uint32_t)0x10F00001) /*!< Error Warning Flag   */
N#define CAN_FLAG_EPV               ((uint32_t)0x10F00002) /*!< Error Passive Flag   */
N#define CAN_FLAG_BOF               ((uint32_t)0x10F00004) /*!< Bus-Off Flag         */
N#define CAN_FLAG_LEC               ((uint32_t)0x30F00070) /*!< Last error code Flag */
N
N#define IS_CAN_GET_FLAG(FLAG) (((FLAG) == CAN_FLAG_LEC)  || ((FLAG) == CAN_FLAG_BOF)   || \
N                               ((FLAG) == CAN_FLAG_EPV)  || ((FLAG) == CAN_FLAG_EWG)   || \
N                               ((FLAG) == CAN_FLAG_WKU)  || ((FLAG) == CAN_FLAG_FOV0)  || \
N                               ((FLAG) == CAN_FLAG_FF0)  || ((FLAG) == CAN_FLAG_FMP0)  || \
N                               ((FLAG) == CAN_FLAG_FOV1) || ((FLAG) == CAN_FLAG_FF1)   || \
N                               ((FLAG) == CAN_FLAG_FMP1) || ((FLAG) == CAN_FLAG_RQCP2) || \
N                               ((FLAG) == CAN_FLAG_RQCP1)|| ((FLAG) == CAN_FLAG_RQCP0) || \
N                               ((FLAG) == CAN_FLAG_SLAK ))
X#define IS_CAN_GET_FLAG(FLAG) (((FLAG) == CAN_FLAG_LEC)  || ((FLAG) == CAN_FLAG_BOF)   ||                                ((FLAG) == CAN_FLAG_EPV)  || ((FLAG) == CAN_FLAG_EWG)   ||                                ((FLAG) == CAN_FLAG_WKU)  || ((FLAG) == CAN_FLAG_FOV0)  ||                                ((FLAG) == CAN_FLAG_FF0)  || ((FLAG) == CAN_FLAG_FMP0)  ||                                ((FLAG) == CAN_FLAG_FOV1) || ((FLAG) == CAN_FLAG_FF1)   ||                                ((FLAG) == CAN_FLAG_FMP1) || ((FLAG) == CAN_FLAG_RQCP2) ||                                ((FLAG) == CAN_FLAG_RQCP1)|| ((FLAG) == CAN_FLAG_RQCP0) ||                                ((FLAG) == CAN_FLAG_SLAK ))
N
N#define IS_CAN_CLEAR_FLAG(FLAG)(((FLAG) == CAN_FLAG_LEC) || ((FLAG) == CAN_FLAG_RQCP2) || \
N                                ((FLAG) == CAN_FLAG_RQCP1)  || ((FLAG) == CAN_FLAG_RQCP0) || \
N                                ((FLAG) == CAN_FLAG_FF0)  || ((FLAG) == CAN_FLAG_FOV0) ||\
N                                ((FLAG) == CAN_FLAG_FF1) || ((FLAG) == CAN_FLAG_FOV1) || \
N                                ((FLAG) == CAN_FLAG_WKU) || ((FLAG) == CAN_FLAG_SLAK))
X#define IS_CAN_CLEAR_FLAG(FLAG)(((FLAG) == CAN_FLAG_LEC) || ((FLAG) == CAN_FLAG_RQCP2) ||                                 ((FLAG) == CAN_FLAG_RQCP1)  || ((FLAG) == CAN_FLAG_RQCP0) ||                                 ((FLAG) == CAN_FLAG_FF0)  || ((FLAG) == CAN_FLAG_FOV0) ||                                ((FLAG) == CAN_FLAG_FF1) || ((FLAG) == CAN_FLAG_FOV1) ||                                 ((FLAG) == CAN_FLAG_WKU) || ((FLAG) == CAN_FLAG_SLAK))
N/**
N  * @}
N  */
N
N  
N/** @defgroup CAN_interrupts 
N  * @{
N  */ 
N#define CAN_IT_TME                  ((uint32_t)0x00000001) /*!< Transmit mailbox empty Interrupt*/
N
N/* Receive Interrupts */
N#define CAN_IT_FMP0                 ((uint32_t)0x00000002) /*!< FIFO 0 message pending Interrupt*/
N#define CAN_IT_FF0                  ((uint32_t)0x00000004) /*!< FIFO 0 full Interrupt*/
N#define CAN_IT_FOV0                 ((uint32_t)0x00000008) /*!< FIFO 0 overrun Interrupt*/
N#define CAN_IT_FMP1                 ((uint32_t)0x00000010) /*!< FIFO 1 message pending Interrupt*/
N#define CAN_IT_FF1                  ((uint32_t)0x00000020) /*!< FIFO 1 full Interrupt*/
N#define CAN_IT_FOV1                 ((uint32_t)0x00000040) /*!< FIFO 1 overrun Interrupt*/
N
N/* Operating Mode Interrupts */
N#define CAN_IT_WKU                  ((uint32_t)0x00010000) /*!< Wake-up Interrupt*/
N#define CAN_IT_SLK                  ((uint32_t)0x00020000) /*!< Sleep acknowledge Interrupt*/
N
N/* Error Interrupts */
N#define CAN_IT_EWG                  ((uint32_t)0x00000100) /*!< Error warning Interrupt*/
N#define CAN_IT_EPV                  ((uint32_t)0x00000200) /*!< Error passive Interrupt*/
N#define CAN_IT_BOF                  ((uint32_t)0x00000400) /*!< Bus-off Interrupt*/
N#define CAN_IT_LEC                  ((uint32_t)0x00000800) /*!< Last error code Interrupt*/
N#define CAN_IT_ERR                  ((uint32_t)0x00008000) /*!< Error Interrupt*/
N
N/* Flags named as Interrupts : kept only for FW compatibility */
N#define CAN_IT_RQCP0   CAN_IT_TME
N#define CAN_IT_RQCP1   CAN_IT_TME
N#define CAN_IT_RQCP2   CAN_IT_TME
N
N
N#define IS_CAN_IT(IT)        (((IT) == CAN_IT_TME) || ((IT) == CAN_IT_FMP0)  ||\
N                             ((IT) == CAN_IT_FF0)  || ((IT) == CAN_IT_FOV0)  ||\
N                             ((IT) == CAN_IT_FMP1) || ((IT) == CAN_IT_FF1)   ||\
N                             ((IT) == CAN_IT_FOV1) || ((IT) == CAN_IT_EWG)   ||\
N                             ((IT) == CAN_IT_EPV)  || ((IT) == CAN_IT_BOF)   ||\
N                             ((IT) == CAN_IT_LEC)  || ((IT) == CAN_IT_ERR)   ||\
N                             ((IT) == CAN_IT_WKU)  || ((IT) == CAN_IT_SLK))
X#define IS_CAN_IT(IT)        (((IT) == CAN_IT_TME) || ((IT) == CAN_IT_FMP0)  ||                             ((IT) == CAN_IT_FF0)  || ((IT) == CAN_IT_FOV0)  ||                             ((IT) == CAN_IT_FMP1) || ((IT) == CAN_IT_FF1)   ||                             ((IT) == CAN_IT_FOV1) || ((IT) == CAN_IT_EWG)   ||                             ((IT) == CAN_IT_EPV)  || ((IT) == CAN_IT_BOF)   ||                             ((IT) == CAN_IT_LEC)  || ((IT) == CAN_IT_ERR)   ||                             ((IT) == CAN_IT_WKU)  || ((IT) == CAN_IT_SLK))
N
N#define IS_CAN_CLEAR_IT(IT) (((IT) == CAN_IT_TME) || ((IT) == CAN_IT_FF0)    ||\
N                             ((IT) == CAN_IT_FOV0)|| ((IT) == CAN_IT_FF1)    ||\
N                             ((IT) == CAN_IT_FOV1)|| ((IT) == CAN_IT_EWG)    ||\
N                             ((IT) == CAN_IT_EPV) || ((IT) == CAN_IT_BOF)    ||\
N                             ((IT) == CAN_IT_LEC) || ((IT) == CAN_IT_ERR)    ||\
N                             ((IT) == CAN_IT_WKU) || ((IT) == CAN_IT_SLK))
X#define IS_CAN_CLEAR_IT(IT) (((IT) == CAN_IT_TME) || ((IT) == CAN_IT_FF0)    ||                             ((IT) == CAN_IT_FOV0)|| ((IT) == CAN_IT_FF1)    ||                             ((IT) == CAN_IT_FOV1)|| ((IT) == CAN_IT_EWG)    ||                             ((IT) == CAN_IT_EPV) || ((IT) == CAN_IT_BOF)    ||                             ((IT) == CAN_IT_LEC) || ((IT) == CAN_IT_ERR)    ||                             ((IT) == CAN_IT_WKU) || ((IT) == CAN_IT_SLK))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/  
N
N/*  Function used to set the CAN configuration to the default reset state *****/ 
Nvoid CAN_DeInit(CAN_TypeDef* CANx);
N
N/* Initialization and Configuration functions *********************************/ 
Nuint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct);
N#if defined(STM32F413_423xx)
X#if 0L
Svoid CAN_FilterInit(CAN_TypeDef* CANx, CAN_FilterInitTypeDef* CAN_FilterInitStruct);
N#else
Nvoid CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct);
N#endif /* STM32F413_423xx */
Nvoid CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct);
N#if defined(STM32F413_423xx)
X#if 0L
Svoid CAN_SlaveStartBank(CAN_TypeDef* CANx, uint8_t CAN_BankNumber);
N#else
Nvoid CAN_SlaveStartBank(uint8_t CAN_BankNumber);
N#endif /* STM32F413_423xx */
Nvoid CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState);
Nvoid CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState);
N
N/* CAN Frames Transmission functions ******************************************/
Nuint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage);
Nuint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox);
Nvoid CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox);
N
N/* CAN Frames Reception functions *********************************************/
Nvoid CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage);
Nvoid CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber);
Nuint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber);
N
N/* Operation modes functions **************************************************/
Nuint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode);
Nuint8_t CAN_Sleep(CAN_TypeDef* CANx);
Nuint8_t CAN_WakeUp(CAN_TypeDef* CANx);
N
N/* CAN Bus Error management functions *****************************************/
Nuint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx);
Nuint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx);
Nuint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx);
N
N/* Interrupts and flags management functions **********************************/
Nvoid CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState);
NFlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG);
Nvoid CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG);
NITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT);
Nvoid CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_CAN_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 84 "..\..\Service\stm32f4xx_conf.h" 2
N#include "stm32f4xx_dac.h"
L 1 "..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\stm32f4xx_dac.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_dac.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    04-November-2016
N  * @brief   This file contains all the functions prototypes for the DAC firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_DAC_H
N#define __STM32F4xx_DAC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
N
N/** @addtogroup STM32F4xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup DAC
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  DAC Init structure definition
N  */
N
Ntypedef struct
N{
N  uint32_t DAC_Trigger;                      /*!< Specifies the external trigger for the selected DAC channel.
N                                                  This parameter can be a value of @ref DAC_trigger_selection */
N
N  uint32_t DAC_WaveGeneration;               /*!< Specifies whether DAC channel noise waves or triangle waves
N                                                  are generated, or whether no wave is generated.
N                                                  This parameter can be a value of @ref DAC_wave_generation */
N
N  uint32_t DAC_LFSRUnmask_TriangleAmplitude; /*!< Specifies the LFSR mask for noise wave generation or
N                                                  the maximum amplitude triangle generation for the DAC channel. 
N                                                  This parameter can be a value of @ref DAC_lfsrunmask_triangleamplitude */
N
N  uint32_t DAC_OutputBuffer;                 /*!< Specifies whether the DAC channel output buffer is enabled or disabled.
N                                                  This parameter can be a value of @ref DAC_output_buffer */
N}DAC_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup DAC_Exported_Constants
N  * @{
N  */
N
N/** @defgroup DAC_trigger_selection 
N  * @{
N  */
N
N#define DAC_Trigger_None                   ((uint32_t)0x00000000) /*!< Conversion is automatic once the DAC1_DHRxxxx register 
N                                                                       has been loaded, and not by external trigger */
N#define DAC_Trigger_T2_TRGO                ((uint32_t)0x00000024) /*!< TIM2 TRGO selected as external conversion trigger for DAC channel */
N#define DAC_Trigger_T4_TRGO                ((uint32_t)0x0000002C) /*!< TIM4 TRGO selected as external conversion trigger for DAC channel */
N#define DAC_Trigger_T5_TRGO                ((uint32_t)0x0000001C) /*!< TIM5 TRGO selected as external conversion trigger for DAC channel */
N#define DAC_Trigger_T6_TRGO                ((uint32_t)0x00000004) /*!< TIM6 TRGO selected as external conversion trigger for DAC channel */
N#define DAC_Trigger_T7_TRGO                ((uint32_t)0x00000014) /*!< TIM7 TRGO selected as external conversion trigger for DAC channel */
N#define DAC_Trigger_T8_TRGO                ((uint32_t)0x0000000C) /*!< TIM8 TRGO selected as external conversion trigger for DAC channel */                                                                       
N
N#define DAC_Trigger_Ext_IT9                ((uint32_t)0x00000034) /*!< EXTI Line9 event selected as external conversion trigger for DAC channel */
N#define DAC_Trigger_Software               ((uint32_t)0x0000003C) /*!< Conversion started by software trigger for DAC channel */
N
N#define IS_DAC_TRIGGER(TRIGGER) (((TRIGGER) == DAC_Trigger_None) || \
N                                 ((TRIGGER) == DAC_Trigger_T6_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_T8_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_T7_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_T5_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_T2_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_T4_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_Ext_IT9) || \
N                                 ((TRIGGER) == DAC_Trigger_Software))
X#define IS_DAC_TRIGGER(TRIGGER) (((TRIGGER) == DAC_Trigger_None) ||                                  ((TRIGGER) == DAC_Trigger_T6_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_T8_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_T7_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_T5_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_T2_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_T4_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_Ext_IT9) ||                                  ((TRIGGER) == DAC_Trigger_Software))
N
N/**
N  * @}
N  */
N
N/** @defgroup DAC_wave_generation 
N  * @{
N  */
N
N#define DAC_WaveGeneration_None            ((uint32_t)0x00000000)
N#define DAC_WaveGeneration_Noise           ((uint32_t)0x00000040)
N#define DAC_WaveGeneration_Triangle        ((uint32_t)0x00000080)
N#define IS_DAC_GENERATE_WAVE(WAVE) (((WAVE) == DAC_WaveGeneration_None) || \
N                                    ((WAVE) == DAC_WaveGeneration_Noise) || \
N                                    ((WAVE) == DAC_WaveGeneration_Triangle))
X#define IS_DAC_GENERATE_WAVE(WAVE) (((WAVE) == DAC_WaveGeneration_None) ||                                     ((WAVE) == DAC_WaveGeneration_Noise) ||                                     ((WAVE) == DAC_WaveGeneration_Triangle))
N/**
N  * @}
N  */
N
N/** @defgroup DAC_lfsrunmask_triangleamplitude
N  * @{
N  */
N
N#define DAC_LFSRUnmask_Bit0                ((uint32_t)0x00000000) /*!< Unmask DAC channel LFSR bit0 for noise wave generation */
N#define DAC_LFSRUnmask_Bits1_0             ((uint32_t)0x00000100) /*!< Unmask DAC channel LFSR bit[1:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits2_0             ((uint32_t)0x00000200) /*!< Unmask DAC channel LFSR bit[2:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits3_0             ((uint32_t)0x00000300) /*!< Unmask DAC channel LFSR bit[3:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits4_0             ((uint32_t)0x00000400) /*!< Unmask DAC channel LFSR bit[4:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits5_0             ((uint32_t)0x00000500) /*!< Unmask DAC channel LFSR bit[5:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits6_0             ((uint32_t)0x00000600) /*!< Unmask DAC channel LFSR bit[6:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits7_0             ((uint32_t)0x00000700) /*!< Unmask DAC channel LFSR bit[7:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits8_0             ((uint32_t)0x00000800) /*!< Unmask DAC channel LFSR bit[8:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits9_0             ((uint32_t)0x00000900) /*!< Unmask DAC channel LFSR bit[9:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits10_0            ((uint32_t)0x00000A00) /*!< Unmask DAC channel LFSR bit[10:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits11_0            ((uint32_t)0x00000B00) /*!< Unmask DAC channel LFSR bit[11:0] for noise wave generation */
N#define DAC_TriangleAmplitude_1            ((uint32_t)0x00000000) /*!< Select max triangle amplitude of 1 */
N#define DAC_TriangleAmplitude_3            ((uint32_t)0x00000100) /*!< Select max triangle amplitude of 3 */
N#define DAC_TriangleAmplitude_7            ((uint32_t)0x00000200) /*!< Select max triangle amplitude of 7 */
N#define DAC_TriangleAmplitude_15           ((uint32_t)0x00000300) /*!< Select max triangle amplitude of 15 */
N#define DAC_TriangleAmplitude_31           ((uint32_t)0x00000400) /*!< Select max triangle amplitude of 31 */
N#define DAC_TriangleAmplitude_63           ((uint32_t)0x00000500) /*!< Select max triangle amplitude of 63 */
N#define DAC_TriangleAmplitude_127          ((uint32_t)0x00000600) /*!< Select max triangle amplitude of 127 */
N#define DAC_TriangleAmplitude_255          ((uint32_t)0x00000700) /*!< Select max triangle amplitude of 255 */
N#define DAC_TriangleAmplitude_511          ((uint32_t)0x00000800) /*!< Select max triangle amplitude of 511 */
N#define DAC_TriangleAmplitude_1023         ((uint32_t)0x00000900) /*!< Select max triangle amplitude of 1023 */
N#define DAC_TriangleAmplitude_2047         ((uint32_t)0x00000A00) /*!< Select max triangle amplitude of 2047 */
N#define DAC_TriangleAmplitude_4095         ((uint32_t)0x00000B00) /*!< Select max triangle amplitude of 4095 */
N
N#define IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(VALUE) (((VALUE) == DAC_LFSRUnmask_Bit0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits1_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits2_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits3_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits4_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits5_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits6_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits7_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits8_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits9_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits10_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits11_0) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_1) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_3) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_7) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_15) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_31) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_63) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_127) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_255) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_511) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_1023) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_2047) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_4095))
X#define IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(VALUE) (((VALUE) == DAC_LFSRUnmask_Bit0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits1_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits2_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits3_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits4_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits5_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits6_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits7_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits8_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits9_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits10_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits11_0) ||                                                       ((VALUE) == DAC_TriangleAmplitude_1) ||                                                       ((VALUE) == DAC_TriangleAmplitude_3) ||                                                       ((VALUE) == DAC_TriangleAmplitude_7) ||                                                       ((VALUE) == DAC_TriangleAmplitude_15) ||                                                       ((VALUE) == DAC_TriangleAmplitude_31) ||                                                       ((VALUE) == DAC_TriangleAmplitude_63) ||                                                       ((VALUE) == DAC_TriangleAmplitude_127) ||                                                       ((VALUE) == DAC_TriangleAmplitude_255) ||                                                       ((VALUE) == DAC_TriangleAmplitude_511) ||                                                       ((VALUE) == DAC_TriangleAmplitude_1023) ||                                                       ((VALUE) == DAC_TriangleAmplitude_2047) ||                                                       ((VALUE) == DAC_TriangleAmplitude_4095))
N/**
N  * @}
N  */
N
N/** @defgroup DAC_output_buffer 
N  * @{
N  */
N
N#define DAC_OutputBuffer_Enable            ((uint32_t)0x00000000)
N#define DAC_OutputBuffer_Disable           ((uint32_t)0x00000002)
N#define IS_DAC_OUTPUT_BUFFER_STATE(STATE) (((STATE) == DAC_OutputBuffer_Enable) || \
N                                           ((STATE) == DAC_OutputBuffer_Disable))
X#define IS_DAC_OUTPUT_BUFFER_STATE(STATE) (((STATE) == DAC_OutputBuffer_Enable) ||                                            ((STATE) == DAC_OutputBuffer_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup DAC_Channel_selection 
N  * @{
N  */
N
N#define DAC_Channel_1                      ((uint32_t)0x00000000)
N#define DAC_Channel_2                      ((uint32_t)0x00000010)
N#define IS_DAC_CHANNEL(CHANNEL) (((CHANNEL) == DAC_Channel_1) || \
N                                 ((CHANNEL) == DAC_Channel_2))
X#define IS_DAC_CHANNEL(CHANNEL) (((CHANNEL) == DAC_Channel_1) ||                                  ((CHANNEL) == DAC_Channel_2))
N/**
N  * @}
N  */
N
N/** @defgroup DAC_data_alignement 
N  * @{
N  */
N
N#define DAC_Align_12b_R                    ((uint32_t)0x00000000)
N#define DAC_Align_12b_L                    ((uint32_t)0x00000004)
N#define DAC_Align_8b_R                     ((uint32_t)0x00000008)
N#define IS_DAC_ALIGN(ALIGN) (((ALIGN) == DAC_Align_12b_R) || \
N                             ((ALIGN) == DAC_Align_12b_L) || \
N                             ((ALIGN) == DAC_Align_8b_R))
X#define IS_DAC_ALIGN(ALIGN) (((ALIGN) == DAC_Align_12b_R) ||                              ((ALIGN) == DAC_Align_12b_L) ||                              ((ALIGN) == DAC_Align_8b_R))
N/**
N  * @}
N  */
N
N/** @defgroup DAC_wave_generation 
N  * @{
N  */
N
N#define DAC_Wave_Noise                     ((uint32_t)0x00000040)
N#define DAC_Wave_Triangle                  ((uint32_t)0x00000080)
N#define IS_DAC_WAVE(WAVE) (((WAVE) == DAC_Wave_Noise) || \
N                           ((WAVE) == DAC_Wave_Triangle))
X#define IS_DAC_WAVE(WAVE) (((WAVE) == DAC_Wave_Noise) ||                            ((WAVE) == DAC_Wave_Triangle))
N/**
N  * @}
N  */
N
N/** @defgroup DAC_data 
N  * @{
N  */
N
N#define IS_DAC_DATA(DATA) ((DATA) <= 0xFFF0) 
N/**
N  * @}
N  */
N  
N/** @defgroup DAC_interrupts_definition 
N  * @{
N  */   
N#define DAC_IT_DMAUDR                      ((uint32_t)0x00002000)  
N#define IS_DAC_IT(IT) (((IT) == DAC_IT_DMAUDR)) 
N
N/**
N  * @}
N  */ 
N
N/** @defgroup DAC_flags_definition 
N  * @{
N  */ 
N  
N#define DAC_FLAG_DMAUDR                    ((uint32_t)0x00002000)  
N#define IS_DAC_FLAG(FLAG) (((FLAG) == DAC_FLAG_DMAUDR))  
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/  
N
N/*  Function used to set the DAC configuration to the default reset state *****/  
Nvoid DAC_DeInit(void);
N
N/*  DAC channels configuration: trigger, output buffer, data format functions */
Nvoid DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct);
Nvoid DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct);
Nvoid DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState);
Nvoid DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState);
Nvoid DAC_DualSoftwareTriggerCmd(FunctionalState NewState);
Nvoid DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState);
Nvoid DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data);
Nvoid DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data);
Nvoid DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1);
Nuint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel);
N
N/* DMA management functions ***************************************************/
Nvoid DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState);
N
N/* Interrupts and flags management functions **********************************/
Nvoid DAC_ITConfig(uint32_t DAC_Channel, uint32_t DAC_IT, FunctionalState NewState);
NFlagStatus DAC_GetFlagStatus(uint32_t DAC_Channel, uint32_t DAC_FLAG);
Nvoid DAC_ClearFlag(uint32_t DAC_Channel, uint32_t DAC_FLAG);
NITStatus DAC_GetITStatus(uint32_t DAC_Channel, uint32_t DAC_IT);
Nvoid DAC_ClearITPendingBit(uint32_t DAC_Channel, uint32_t DAC_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F4xx_DAC_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 85 "..\..\Service\stm32f4xx_conf.h" 2
N#include "stm32f4xx_dcmi.h"
L 1 "..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\stm32f4xx_dcmi.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_dcmi.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    04-November-2016
N  * @brief   This file contains all the functions prototypes for the DCMI firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_DCMI_H
N#define __STM32F4xx_DCMI_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
N
N/** @addtogroup STM32F4xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup DCMI
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/** 
N  * @brief   DCMI Init structure definition  
N  */ 
Ntypedef struct
N{
N  uint16_t DCMI_CaptureMode;      /*!< Specifies the Capture Mode: Continuous or Snapshot.
N                                       This parameter can be a value of @ref DCMI_Capture_Mode */
N
N  uint16_t DCMI_SynchroMode;      /*!< Specifies the Synchronization Mode: Hardware or Embedded.
N                                       This parameter can be a value of @ref DCMI_Synchronization_Mode */
N
N  uint16_t DCMI_PCKPolarity;      /*!< Specifies the Pixel clock polarity: Falling or Rising.
N                                       This parameter can be a value of @ref DCMI_PIXCK_Polarity */
N
N  uint16_t DCMI_VSPolarity;       /*!< Specifies the Vertical synchronization polarity: High or Low.
N                                       This parameter can be a value of @ref DCMI_VSYNC_Polarity */
N
N  uint16_t DCMI_HSPolarity;       /*!< Specifies the Horizontal synchronization polarity: High or Low.
N                                       This parameter can be a value of @ref DCMI_HSYNC_Polarity */
N
N  uint16_t DCMI_CaptureRate;      /*!< Specifies the frequency of frame capture: All, 1/2 or 1/4.
N                                       This parameter can be a value of @ref DCMI_Capture_Rate */
N
N  uint16_t DCMI_ExtendedDataMode; /*!< Specifies the data width: 8-bit, 10-bit, 12-bit or 14-bit.
N                                       This parameter can be a value of @ref DCMI_Extended_Data_Mode */
N} DCMI_InitTypeDef;
N
N/** 
N  * @brief   DCMI CROP Init structure definition  
N  */ 
Ntypedef struct
N{
N  uint16_t DCMI_VerticalStartLine;      /*!< Specifies the Vertical start line count from which the image capture
N                                             will start. This parameter can be a value between 0x00 and 0x1FFF */
N
N  uint16_t DCMI_HorizontalOffsetCount;  /*!< Specifies the number of pixel clocks to count before starting a capture.
N                                             This parameter can be a value between 0x00 and 0x3FFF */
N
N  uint16_t DCMI_VerticalLineCount;      /*!< Specifies the number of lines to be captured from the starting point.
N                                             This parameter can be a value between 0x00 and 0x3FFF */
N
N  uint16_t DCMI_CaptureCount;           /*!< Specifies the number of pixel clocks to be captured from the starting
N                                             point on the same line.
N                                             This parameter can be a value between 0x00 and 0x3FFF */
N} DCMI_CROPInitTypeDef;
N
N/** 
N  * @brief   DCMI Embedded Synchronisation CODE Init structure definition  
N  */ 
Ntypedef struct
N{
N  uint8_t DCMI_FrameStartCode; /*!< Specifies the code of the frame start delimiter. */
N  uint8_t DCMI_LineStartCode;  /*!< Specifies the code of the line start delimiter. */
N  uint8_t DCMI_LineEndCode;    /*!< Specifies the code of the line end delimiter. */
N  uint8_t DCMI_FrameEndCode;   /*!< Specifies the code of the frame end delimiter. */
N} DCMI_CodesInitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup DCMI_Exported_Constants
N  * @{
N  */
N
N/** @defgroup DCMI_Capture_Mode 
N  * @{
N  */ 
N#define DCMI_CaptureMode_Continuous    ((uint16_t)0x0000) /*!< The received data are transferred continuously 
N                                                               into the destination memory through the DMA */
N#define DCMI_CaptureMode_SnapShot      ((uint16_t)0x0002) /*!< Once activated, the interface waits for the start of 
N                                                               frame and then transfers a single frame through the DMA */
N#define IS_DCMI_CAPTURE_MODE(MODE)(((MODE) == DCMI_CaptureMode_Continuous) || \
N                                   ((MODE) == DCMI_CaptureMode_SnapShot))
X#define IS_DCMI_CAPTURE_MODE(MODE)(((MODE) == DCMI_CaptureMode_Continuous) ||                                    ((MODE) == DCMI_CaptureMode_SnapShot))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DCMI_Synchronization_Mode
N  * @{
N  */ 
N#define DCMI_SynchroMode_Hardware    ((uint16_t)0x0000) /*!< Hardware synchronization data capture (frame/line start/stop)
N                                                             is synchronized with the HSYNC/VSYNC signals */
N#define DCMI_SynchroMode_Embedded    ((uint16_t)0x0010) /*!< Embedded synchronization data capture is synchronized with 
N                                                             synchronization codes embedded in the data flow */
N#define IS_DCMI_SYNCHRO(MODE)(((MODE) == DCMI_SynchroMode_Hardware) || \
N                              ((MODE) == DCMI_SynchroMode_Embedded))
X#define IS_DCMI_SYNCHRO(MODE)(((MODE) == DCMI_SynchroMode_Hardware) ||                               ((MODE) == DCMI_SynchroMode_Embedded))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DCMI_PIXCK_Polarity 
N  * @{
N  */ 
N#define DCMI_PCKPolarity_Falling    ((uint16_t)0x0000) /*!< Pixel clock active on Falling edge */
N#define DCMI_PCKPolarity_Rising     ((uint16_t)0x0020) /*!< Pixel clock active on Rising edge */
N#define IS_DCMI_PCKPOLARITY(POLARITY)(((POLARITY) == DCMI_PCKPolarity_Falling) || \
N                                      ((POLARITY) == DCMI_PCKPolarity_Rising))
X#define IS_DCMI_PCKPOLARITY(POLARITY)(((POLARITY) == DCMI_PCKPolarity_Falling) ||                                       ((POLARITY) == DCMI_PCKPolarity_Rising))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DCMI_VSYNC_Polarity 
N  * @{
N  */ 
N#define DCMI_VSPolarity_Low     ((uint16_t)0x0000) /*!< Vertical synchronization active Low */
N#define DCMI_VSPolarity_High    ((uint16_t)0x0080) /*!< Vertical synchronization active High */
N#define IS_DCMI_VSPOLARITY(POLARITY)(((POLARITY) == DCMI_VSPolarity_Low) || \
N                                     ((POLARITY) == DCMI_VSPolarity_High))
X#define IS_DCMI_VSPOLARITY(POLARITY)(((POLARITY) == DCMI_VSPolarity_Low) ||                                      ((POLARITY) == DCMI_VSPolarity_High))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DCMI_HSYNC_Polarity 
N  * @{
N  */ 
N#define DCMI_HSPolarity_Low     ((uint16_t)0x0000) /*!< Horizontal synchronization active Low */
N#define DCMI_HSPolarity_High    ((uint16_t)0x0040) /*!< Horizontal synchronization active High */
N#define IS_DCMI_HSPOLARITY(POLARITY)(((POLARITY) == DCMI_HSPolarity_Low) || \
N                                     ((POLARITY) == DCMI_HSPolarity_High))
X#define IS_DCMI_HSPOLARITY(POLARITY)(((POLARITY) == DCMI_HSPolarity_Low) ||                                      ((POLARITY) == DCMI_HSPolarity_High))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DCMI_Capture_Rate 
N  * @{
N  */ 
N#define DCMI_CaptureRate_All_Frame     ((uint16_t)0x0000) /*!< All frames are captured */
N#define DCMI_CaptureRate_1of2_Frame    ((uint16_t)0x0100) /*!< Every alternate frame captured */
N#define DCMI_CaptureRate_1of4_Frame    ((uint16_t)0x0200) /*!< One frame in 4 frames captured */
N#define IS_DCMI_CAPTURE_RATE(RATE) (((RATE) == DCMI_CaptureRate_All_Frame) || \
N                                    ((RATE) == DCMI_CaptureRate_1of2_Frame) ||\
N                                    ((RATE) == DCMI_CaptureRate_1of4_Frame))
X#define IS_DCMI_CAPTURE_RATE(RATE) (((RATE) == DCMI_CaptureRate_All_Frame) ||                                     ((RATE) == DCMI_CaptureRate_1of2_Frame) ||                                    ((RATE) == DCMI_CaptureRate_1of4_Frame))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DCMI_Extended_Data_Mode 
N  * @{
N  */ 
N#define DCMI_ExtendedDataMode_8b     ((uint16_t)0x0000) /*!< Interface captures 8-bit data on every pixel clock */
N#define DCMI_ExtendedDataMode_10b    ((uint16_t)0x0400) /*!< Interface captures 10-bit data on every pixel clock */
N#define DCMI_ExtendedDataMode_12b    ((uint16_t)0x0800) /*!< Interface captures 12-bit data on every pixel clock */
N#define DCMI_ExtendedDataMode_14b    ((uint16_t)0x0C00) /*!< Interface captures 14-bit data on every pixel clock */
N#define IS_DCMI_EXTENDED_DATA(DATA)(((DATA) == DCMI_ExtendedDataMode_8b) || \
N                                    ((DATA) == DCMI_ExtendedDataMode_10b) ||\
N                                    ((DATA) == DCMI_ExtendedDataMode_12b) ||\
N                                    ((DATA) == DCMI_ExtendedDataMode_14b))
X#define IS_DCMI_EXTENDED_DATA(DATA)(((DATA) == DCMI_ExtendedDataMode_8b) ||                                     ((DATA) == DCMI_ExtendedDataMode_10b) ||                                    ((DATA) == DCMI_ExtendedDataMode_12b) ||                                    ((DATA) == DCMI_ExtendedDataMode_14b))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DCMI_interrupt_sources 
N  * @{
N  */ 
N#define DCMI_IT_FRAME    ((uint16_t)0x0001)
N#define DCMI_IT_OVF      ((uint16_t)0x0002)
N#define DCMI_IT_ERR      ((uint16_t)0x0004)
N#define DCMI_IT_VSYNC    ((uint16_t)0x0008)
N#define DCMI_IT_LINE     ((uint16_t)0x0010)
N#define IS_DCMI_CONFIG_IT(IT) ((((IT) & (uint16_t)0xFFE0) == 0x0000) && ((IT) != 0x0000))
N#define IS_DCMI_GET_IT(IT) (((IT) == DCMI_IT_FRAME) || \
N                            ((IT) == DCMI_IT_OVF) || \
N                            ((IT) == DCMI_IT_ERR) || \
N                            ((IT) == DCMI_IT_VSYNC) || \
N                            ((IT) == DCMI_IT_LINE))
X#define IS_DCMI_GET_IT(IT) (((IT) == DCMI_IT_FRAME) ||                             ((IT) == DCMI_IT_OVF) ||                             ((IT) == DCMI_IT_ERR) ||                             ((IT) == DCMI_IT_VSYNC) ||                             ((IT) == DCMI_IT_LINE))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DCMI_Flags 
N  * @{
N  */ 
N/** 
N  * @brief   DCMI SR register  
N  */ 
N#define DCMI_FLAG_HSYNC     ((uint16_t)0x2001)
N#define DCMI_FLAG_VSYNC     ((uint16_t)0x2002)
N#define DCMI_FLAG_FNE       ((uint16_t)0x2004)
N/** 
N  * @brief   DCMI RISR register  
N  */ 
N#define DCMI_FLAG_FRAMERI    ((uint16_t)0x0001)
N#define DCMI_FLAG_OVFRI      ((uint16_t)0x0002)
N#define DCMI_FLAG_ERRRI      ((uint16_t)0x0004)
N#define DCMI_FLAG_VSYNCRI    ((uint16_t)0x0008)
N#define DCMI_FLAG_LINERI     ((uint16_t)0x0010)
N/** 
N  * @brief   DCMI MISR register  
N  */ 
N#define DCMI_FLAG_FRAMEMI    ((uint16_t)0x1001)
N#define DCMI_FLAG_OVFMI      ((uint16_t)0x1002)
N#define DCMI_FLAG_ERRMI      ((uint16_t)0x1004)
N#define DCMI_FLAG_VSYNCMI    ((uint16_t)0x1008)
N#define DCMI_FLAG_LINEMI     ((uint16_t)0x1010)
N#define IS_DCMI_GET_FLAG(FLAG) (((FLAG) == DCMI_FLAG_HSYNC) || \
N                                ((FLAG) == DCMI_FLAG_VSYNC) || \
N                                ((FLAG) == DCMI_FLAG_FNE) || \
N                                ((FLAG) == DCMI_FLAG_FRAMERI) || \
N                                ((FLAG) == DCMI_FLAG_OVFRI) || \
N                                ((FLAG) == DCMI_FLAG_ERRRI) || \
N                                ((FLAG) == DCMI_FLAG_VSYNCRI) || \
N                                ((FLAG) == DCMI_FLAG_LINERI) || \
N                                ((FLAG) == DCMI_FLAG_FRAMEMI) || \
N                                ((FLAG) == DCMI_FLAG_OVFMI) || \
N                                ((FLAG) == DCMI_FLAG_ERRMI) || \
N                                ((FLAG) == DCMI_FLAG_VSYNCMI) || \
N                                ((FLAG) == DCMI_FLAG_LINEMI))
X#define IS_DCMI_GET_FLAG(FLAG) (((FLAG) == DCMI_FLAG_HSYNC) ||                                 ((FLAG) == DCMI_FLAG_VSYNC) ||                                 ((FLAG) == DCMI_FLAG_FNE) ||                                 ((FLAG) == DCMI_FLAG_FRAMERI) ||                                 ((FLAG) == DCMI_FLAG_OVFRI) ||                                 ((FLAG) == DCMI_FLAG_ERRRI) ||                                 ((FLAG) == DCMI_FLAG_VSYNCRI) ||                                 ((FLAG) == DCMI_FLAG_LINERI) ||                                 ((FLAG) == DCMI_FLAG_FRAMEMI) ||                                 ((FLAG) == DCMI_FLAG_OVFMI) ||                                 ((FLAG) == DCMI_FLAG_ERRMI) ||                                 ((FLAG) == DCMI_FLAG_VSYNCMI) ||                                 ((FLAG) == DCMI_FLAG_LINEMI))
N                                
N#define IS_DCMI_CLEAR_FLAG(FLAG) ((((FLAG) & (uint16_t)0xFFE0) == 0x0000) && ((FLAG) != 0x0000))
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/ 
N
N/*  Function used to set the DCMI configuration to the default reset state ****/ 
Nvoid DCMI_DeInit(void);
N
N/* Initialization and Configuration functions *********************************/
Nvoid DCMI_Init(DCMI_InitTypeDef* DCMI_InitStruct);
Nvoid DCMI_StructInit(DCMI_InitTypeDef* DCMI_InitStruct);
Nvoid DCMI_CROPConfig(DCMI_CROPInitTypeDef* DCMI_CROPInitStruct);
Nvoid DCMI_CROPCmd(FunctionalState NewState);
Nvoid DCMI_SetEmbeddedSynchroCodes(DCMI_CodesInitTypeDef* DCMI_CodesInitStruct);
Nvoid DCMI_JPEGCmd(FunctionalState NewState);
N
N/* Image capture functions ****************************************************/
Nvoid DCMI_Cmd(FunctionalState NewState);
Nvoid DCMI_CaptureCmd(FunctionalState NewState);
Nuint32_t DCMI_ReadData(void);
N
N/* Interrupts and flags management functions **********************************/
Nvoid DCMI_ITConfig(uint16_t DCMI_IT, FunctionalState NewState);
NFlagStatus DCMI_GetFlagStatus(uint16_t DCMI_FLAG);
Nvoid DCMI_ClearFlag(uint16_t DCMI_FLAG);
NITStatus DCMI_GetITStatus(uint16_t DCMI_IT);
Nvoid DCMI_ClearITPendingBit(uint16_t DCMI_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F4xx_DCMI_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 86 "..\..\Service\stm32f4xx_conf.h" 2
N#include "stm32f4xx_fsmc.h"
L 1 "..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc\stm32f4xx_fsmc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4xx_fsmc.h
N  * @author  MCD Application Team
N  * @version V1.8.0
N  * @date    04-November-2016
N  * @brief   This file contains all the functions prototypes for the FSMC firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2016 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_FSMC_H
N#define __STM32F4xx_FSMC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
N
N/** @addtogroup STM32F4xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup FSMC
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  Timing parameters For NOR/SRAM Banks  
N  */
Ntypedef struct
N{
N  uint32_t FSMC_AddressSetupTime;       /*!< Defines the number of HCLK cycles to configure
N                                             the duration of the address setup time. 
N                                             This parameter can be a value between 0 and 0xF.
N                                             @note This parameter is not used with synchronous NOR Flash memories. */
N
N  uint32_t FSMC_AddressHoldTime;        /*!< Defines the number of HCLK cycles to configure
N                                             the duration of the address hold time.
N                                             This parameter can be a value between 0 and 0xF. 
N                                             @note This parameter is not used with synchronous NOR Flash memories.*/
N
N  uint32_t FSMC_DataSetupTime;          /*!< Defines the number of HCLK cycles to configure
N                                             the duration of the data setup time.
N                                             This parameter can be a value between 0 and 0xFF.
N                                             @note This parameter is used for SRAMs, ROMs and asynchronous multiplexed NOR Flash memories. */
N
N  uint32_t FSMC_BusTurnAroundDuration;  /*!< Defines the number of HCLK cycles to configure
N                                             the duration of the bus turnaround.
N                                             This parameter can be a value between 0 and 0xF.
N                                             @note This parameter is only used for multiplexed NOR Flash memories. */
N
N  uint32_t FSMC_CLKDivision;            /*!< Defines the period of CLK clock output signal, expressed in number of HCLK cycles.
N                                             This parameter can be a value between 1 and 0xF.
N                                             @note This parameter is not used for asynchronous NOR Flash, SRAM or ROM accesses. */
N
N  uint32_t FSMC_DataLatency;            /*!< Defines the number of memory clock cycles to issue
N                                             to the memory before getting the first data.
N                                             The parameter value depends on the memory type as shown below:
N                                              - It must be set to 0 in case of a CRAM
N                                              - It is don't care in asynchronous NOR, SRAM or ROM accesses
N                                              - It may assume a value between 0 and 0xF in NOR Flash memories
N                                                with synchronous burst mode enable */
N
N  uint32_t FSMC_AccessMode;             /*!< Specifies the asynchronous access mode. 
N                                             This parameter can be a value of @ref FSMC_Access_Mode */
N}FSMC_NORSRAMTimingInitTypeDef;
N
N/** 
N  * @brief  FSMC NOR/SRAM Init structure definition
N  */
Ntypedef struct
N{
N  uint32_t FSMC_Bank;                /*!< Specifies the NOR/SRAM memory bank that will be used.
N                                          This parameter can be a value of @ref FSMC_NORSRAM_Bank */
N
N  uint32_t FSMC_DataAddressMux;      /*!< Specifies whether the address and data values are
N                                          multiplexed on the data bus or not. 
N                                          This parameter can be a value of @ref FSMC_Data_Address_Bus_Multiplexing */
N
N  uint32_t FSMC_MemoryType;          /*!< Specifies the type of external memory attached to
N                                          the corresponding memory bank.
N                                          This parameter can be a value of @ref FSMC_Memory_Type */
N
N  uint32_t FSMC_MemoryDataWidth;     /*!< Specifies the external memory device width.
N                                          This parameter can be a value of @ref FSMC_Data_Width */
N
N  uint32_t FSMC_BurstAccessMode;     /*!< Enables or disables the burst access mode for Flash memory,
N                                          valid only with synchronous burst Flash memories.
N                                          This parameter can be a value of @ref FSMC_Burst_Access_Mode */
N
N  uint32_t FSMC_AsynchronousWait;     /*!< Enables or disables wait signal during asynchronous transfers,
N                                          valid only with asynchronous Flash memories.
N                                          This parameter can be a value of @ref FSMC_AsynchronousWait */                                          
N
N  uint32_t FSMC_WaitSignalPolarity;  /*!< Specifies the wait signal polarity, valid only when accessing
N                                          the Flash memory in burst mode.
N                                          This parameter can be a value of @ref FSMC_Wait_Signal_Polarity */
N
N  uint32_t FSMC_WrapMode;            /*!< Enables or disables the Wrapped burst access mode for Flash
N                                          memory, valid only when accessing Flash memories in burst mode.
N                                          This parameter can be a value of @ref FSMC_Wrap_Mode */
N
N  uint32_t FSMC_WaitSignalActive;    /*!< Specifies if the wait signal is asserted by the memory one
N                                          clock cycle before the wait state or during the wait state,
N                                          valid only when accessing memories in burst mode. 
N                                          This parameter can be a value of @ref FSMC_Wait_Timing */
N
N  uint32_t FSMC_WriteOperation;      /*!< Enables or disables the write operation in the selected bank by the FSMC. 
N                                          This parameter can be a value of @ref FSMC_Write_Operation */
N
N  uint32_t FSMC_WaitSignal;          /*!< Enables or disables the wait state insertion via wait
N                                          signal, valid for Flash memory access in burst mode. 
N                                          This parameter can be a value of @ref FSMC_Wait_Signal */
N
N  uint32_t FSMC_ExtendedMode;        /*!< Enables or disables the extended mode.
N                                          This parameter can be a value of @ref FSMC_Extended_Mode */
N
N  uint32_t FSMC_WriteBurst;          /*!< Enables or disables the write burst operation.
N                                          This parameter can be a value of @ref FSMC_Write_Burst */ 
N
N  FSMC_NORSRAMTimingInitTypeDef* FSMC_ReadWriteTimingStruct; /*!< Timing Parameters for write and read access if the  Extended Mode is not used*/  
N
N  FSMC_NORSRAMTimingInitTypeDef* FSMC_WriteTimingStruct;     /*!< Timing Parameters for write access if the  Extended Mode is used*/      
N}FSMC_NORSRAMInitTypeDef;
N
N/** 
N  * @brief  Timing parameters For FSMC NAND and PCCARD Banks
N  */
Ntypedef struct
N{
N  uint32_t FSMC_SetupTime;      /*!< Defines the number of HCLK cycles to setup address before
N                                     the command assertion for NAND Flash read or write access
N                                     to common/Attribute or I/O memory space (depending on
N                                     the memory space timing to be configured).
N                                     This parameter can be a value between 0 and 0xFF.*/
N
N  uint32_t FSMC_WaitSetupTime;  /*!< Defines the minimum number of HCLK cycles to assert the
N                                     command for NAND Flash read or write access to
N                                     common/Attribute or I/O memory space (depending on the
N                                     memory space timing to be configured). 
N                                     This parameter can be a number between 0x00 and 0xFF */
N
N  uint32_t FSMC_HoldSetupTime;  /*!< Defines the number of HCLK clock cycles to hold address
N                                     (and data for write access) after the command de-assertion
N                                     for NAND Flash read or write access to common/Attribute
N                                     or I/O memory space (depending on the memory space timing
N                                     to be configured).
N                                     This parameter can be a number between 0x00 and 0xFF */
N
N  uint32_t FSMC_HiZSetupTime;   /*!< Defines the number of HCLK clock cycles during which the
N                                     data bus is kept in HiZ after the start of a NAND Flash
N                                     write access to common/Attribute or I/O memory space (depending
N                                     on the memory space timing to be configured).
N                                     This parameter can be a number between 0x00 and 0xFF */
N}FSMC_NAND_PCCARDTimingInitTypeDef;
N
N/** 
N  * @brief  FSMC NAND Init structure definition
N  */
Ntypedef struct
N{
N  uint32_t FSMC_Bank;              /*!< Specifies the NAND memory bank that will be used.
N                                      This parameter can be a value of @ref FSMC_NAND_Bank */
N
N  uint32_t FSMC_Waitfeature;      /*!< Enables or disables the Wait feature for the NAND Memory Bank.
N                                       This parameter can be any value of @ref FSMC_Wait_feature */
N
N  uint32_t FSMC_MemoryDataWidth;  /*!< Specifies the external memory device width.
N                                       This parameter can be any value of @ref FSMC_Data_Width */
N
N  uint32_t FSMC_ECC;              /*!< Enables or disables the ECC computation.
N                                       This parameter can be any value of @ref FSMC_ECC */
N
N  uint32_t FSMC_ECCPageSize;      /*!< Defines the page size for the extended ECC.
N                                       This parameter can be any value of @ref FSMC_ECC_Page_Size */
N
N  uint32_t FSMC_TCLRSetupTime;    /*!< Defines the number of HCLK cycles to configure the
N                                       delay between CLE low and RE low.
N                                       This parameter can be a value between 0 and 0xFF. */
N
N  uint32_t FSMC_TARSetupTime;     /*!< Defines the number of HCLK cycles to configure the
N                                       delay between ALE low and RE low.
N                                       This parameter can be a number between 0x0 and 0xFF */ 
N
N  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_CommonSpaceTimingStruct;   /*!< FSMC Common Space Timing */ 
N
N  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_AttributeSpaceTimingStruct; /*!< FSMC Attribute Space Timing */
N}FSMC_NANDInitTypeDef;
N
N/** 
N  * @brief  FSMC PCCARD Init structure definition
N  */
N
Ntypedef struct
N{
N  uint32_t FSMC_Waitfeature;    /*!< Enables or disables the Wait feature for the Memory Bank.
N                                    This parameter can be any value of @ref FSMC_Wait_feature */
N
N  uint32_t FSMC_TCLRSetupTime;  /*!< Defines the number of HCLK cycles to configure the
N                                     delay between CLE low and RE low.
N                                     This parameter can be a value between 0 and 0xFF. */
N
N  uint32_t FSMC_TARSetupTime;   /*!< Defines the number of HCLK cycles to configure the
N                                     delay between ALE low and RE low.
N                                     This parameter can be a number between 0x0 and 0xFF */ 
N
N  
N  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_CommonSpaceTimingStruct; /*!< FSMC Common Space Timing */
N
N  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_AttributeSpaceTimingStruct;  /*!< FSMC Attribute Space Timing */ 
N  
N  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_IOSpaceTimingStruct; /*!< FSMC IO Space Timing */  
N}FSMC_PCCARDInitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup FSMC_Exported_Constants
N  * @{
N  */
N
N/** @defgroup FSMC_NORSRAM_Bank 
N  * @{
N  */
N#define FSMC_Bank1_NORSRAM1                      ((uint32_t)0x00000000)
N#define FSMC_Bank1_NORSRAM2                      ((uint32_t)0x00000002)
N#define FSMC_Bank1_NORSRAM3                      ((uint32_t)0x00000004)
N#define FSMC_Bank1_NORSRAM4                      ((uint32_t)0x00000006)
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_NAND_Bank 
N  * @{
N  */  
N#define FSMC_Bank2_NAND                          ((uint32_t)0x00000010)
N#define FSMC_Bank3_NAND                          ((uint32_t)0x00000100)
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_PCCARD_Bank 
N  * @{
N  */    
N#define FSMC_Bank4_PCCARD                        ((uint32_t)0x00001000)
N/**
N  * @}
N  */
N
N#define IS_FSMC_NORSRAM_BANK(BANK) (((BANK) == FSMC_Bank1_NORSRAM1) || \
N                                    ((BANK) == FSMC_Bank1_NORSRAM2) || \
N                                    ((BANK) == FSMC_Bank1_NORSRAM3) || \
N                                    ((BANK) == FSMC_Bank1_NORSRAM4))
X#define IS_FSMC_NORSRAM_BANK(BANK) (((BANK) == FSMC_Bank1_NORSRAM1) ||                                     ((BANK) == FSMC_Bank1_NORSRAM2) ||                                     ((BANK) == FSMC_Bank1_NORSRAM3) ||                                     ((BANK) == FSMC_Bank1_NORSRAM4))
N
N#define IS_FSMC_NAND_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
N                                 ((BANK) == FSMC_Bank3_NAND))
X#define IS_FSMC_NAND_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) ||                                  ((BANK) == FSMC_Bank3_NAND))
N
N#define IS_FSMC_GETFLAG_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
N                                    ((BANK) == FSMC_Bank3_NAND) || \
N                                    ((BANK) == FSMC_Bank4_PCCARD))
X#define IS_FSMC_GETFLAG_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) ||                                     ((BANK) == FSMC_Bank3_NAND) ||                                     ((BANK) == FSMC_Bank4_PCCARD))
N
N#define IS_FSMC_IT_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
N                               ((BANK) == FSMC_Bank3_NAND) || \
N                               ((BANK) == FSMC_Bank4_PCCARD))
X#define IS_FSMC_IT_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) ||                                ((BANK) == FSMC_Bank3_NAND) ||                                ((BANK) == FSMC_Bank4_PCCARD))
N
N/** @defgroup FSMC_NOR_SRAM_Controller 
N  * @{
N  */
N
N/** @defgroup FSMC_Data_Address_Bus_Multiplexing 
N  * @{
N  */
N
N#define FSMC_DataAddressMux_Disable                ((uint32_t)0x00000000)
N#define FSMC_DataAddressMux_Enable                 ((uint32_t)0x00000002)
N#define IS_FSMC_MUX(MUX) (((MUX) == FSMC_DataAddressMux_Disable) || \
N                          ((MUX) == FSMC_DataAddressMux_Enable))
X#define IS_FSMC_MUX(MUX) (((MUX) == FSMC_DataAddressMux_Disable) ||                           ((MUX) == FSMC_DataAddressMux_Enable))
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Memory_Type 
N  * @{
N  */
N
N#define FSMC_MemoryType_SRAM                     ((uint32_t)0x00000000)
N#define FSMC_MemoryType_PSRAM                    ((uint32_t)0x00000004)
N#define FSMC_MemoryType_NOR                      ((uint32_t)0x00000008)
N#define IS_FSMC_MEMORY(MEMORY) (((MEMORY) == FSMC_MemoryType_SRAM) || \
N                                ((MEMORY) == FSMC_MemoryType_PSRAM)|| \
N                                ((MEMORY) == FSMC_MemoryType_NOR))
X#define IS_FSMC_MEMORY(MEMORY) (((MEMORY) == FSMC_MemoryType_SRAM) ||                                 ((MEMORY) == FSMC_MemoryType_PSRAM)||                                 ((MEMORY) == FSMC_MemoryType_NOR))
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Data_Width 
N  * @{
N  */
N
N#define FSMC_MemoryDataWidth_8b                  ((uint32_t)0x00000000)
N#define FSMC_MemoryDataWidth_16b                 ((uint32_t)0x00000010)
N#define IS_FSMC_MEMORY_WIDTH(WIDTH) (((WIDTH) == FSMC_MemoryDataWidth_8b) || \
N                                     ((WIDTH) == FSMC_MemoryDataWidth_16b))
X#define IS_FSMC_MEMORY_WIDTH(WIDTH) (((WIDTH) == FSMC_MemoryDataWidth_8b) ||                                      ((WIDTH) == FSMC_MemoryDataWidth_16b))
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Burst_Access_Mode 
N  * @{
N  */
N
N#define FSMC_BurstAccessMode_Disable             ((uint32_t)0x00000000) 
N#define FSMC_BurstAccessMode_Enable              ((uint32_t)0x00000100)
N#define IS_FSMC_BURSTMODE(STATE) (((STATE) == FSMC_BurstAccessMode_Disable) || \
N                                  ((STATE) == FSMC_BurstAccessMode_Enable))
X#define IS_FSMC_BURSTMODE(STATE) (((STATE) == FSMC_BurstAccessMode_Disable) ||                                   ((STATE) == FSMC_BurstAccessMode_Enable))
N/**
N  * @}
N  */
N    
N/** @defgroup FSMC_AsynchronousWait 
N  * @{
N  */
N#define FSMC_AsynchronousWait_Disable            ((uint32_t)0x00000000)
N#define FSMC_AsynchronousWait_Enable             ((uint32_t)0x00008000)
N#define IS_FSMC_ASYNWAIT(STATE) (((STATE) == FSMC_AsynchronousWait_Disable) || \
N                                 ((STATE) == FSMC_AsynchronousWait_Enable))
X#define IS_FSMC_ASYNWAIT(STATE) (((STATE) == FSMC_AsynchronousWait_Disable) ||                                  ((STATE) == FSMC_AsynchronousWait_Enable))
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Wait_Signal_Polarity 
N  * @{
N  */
N#define FSMC_WaitSignalPolarity_Low              ((uint32_t)0x00000000)
N#define FSMC_WaitSignalPolarity_High             ((uint32_t)0x00000200)
N#define IS_FSMC_WAIT_POLARITY(POLARITY) (((POLARITY) == FSMC_WaitSignalPolarity_Low) || \
N                                         ((POLARITY) == FSMC_WaitSignalPolarity_High))
X#define IS_FSMC_WAIT_POLARITY(POLARITY) (((POLARITY) == FSMC_WaitSignalPolarity_Low) ||                                          ((POLARITY) == FSMC_WaitSignalPolarity_High))
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Wrap_Mode 
N  * @{
N  */
N#define FSMC_WrapMode_Disable                    ((uint32_t)0x00000000)
N#define FSMC_WrapMode_Enable                     ((uint32_t)0x00000400) 
N#define IS_FSMC_WRAP_MODE(MODE) (((MODE) == FSMC_WrapMode_Disable) || \
N                                 ((MODE) == FSMC_WrapMode_Enable))
X#define IS_FSMC_WRAP_MODE(MODE) (((MODE) == FSMC_WrapMode_Disable) ||                                  ((MODE) == FSMC_WrapMode_Enable))
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Wait_Timing 
N  * @{
N  */
N#define FSMC_WaitSignalActive_BeforeWaitState    ((uint32_t)0x00000000)
N#define FSMC_WaitSignalActive_DuringWaitState    ((uint32_t)0x00000800) 
N#define IS_FSMC_WAIT_SIGNAL_ACTIVE(ACTIVE) (((ACTIVE) == FSMC_WaitSignalActive_BeforeWaitState) || \
N                                            ((ACTIVE) == FSMC_WaitSignalActive_DuringWaitState))
X#define IS_FSMC_WAIT_SIGNAL_ACTIVE(ACTIVE) (((ACTIVE) == FSMC_WaitSignalActive_BeforeWaitState) ||                                             ((ACTIVE) == FSMC_WaitSignalActive_DuringWaitState))
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Write_Operation 
N  * @{
N  */
N#define FSMC_WriteOperation_Disable                     ((uint32_t)0x00000000)
N#define FSMC_WriteOperation_Enable                      ((uint32_t)0x00001000)
N#define IS_FSMC_WRITE_OPERATION(OPERATION) (((OPERATION) == FSMC_WriteOperation_Disable) || \
N                                            ((OPERATION) == FSMC_WriteOperation_Enable))                         
X#define IS_FSMC_WRITE_OPERATION(OPERATION) (((OPERATION) == FSMC_WriteOperation_Disable) ||                                             ((OPERATION) == FSMC_WriteOperation_Enable))                         
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Wait_Signal 
N  * @{
N  */
N#define FSMC_WaitSignal_Disable                  ((uint32_t)0x00000000)
N#define FSMC_WaitSignal_Enable                   ((uint32_t)0x00002000) 
N#define IS_FSMC_WAITE_SIGNAL(SIGNAL) (((SIGNAL) == FSMC_WaitSignal_Disable) || \
N                                      ((SIGNAL) == FSMC_WaitSignal_Enable))
X#define IS_FSMC_WAITE_SIGNAL(SIGNAL) (((SIGNAL) == FSMC_WaitSignal_Disable) ||                                       ((SIGNAL) == FSMC_WaitSignal_Enable))
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Extended_Mode 
N  * @{
N  */
N#define FSMC_ExtendedMode_Disable                ((uint32_t)0x00000000)
N#define FSMC_ExtendedMode_Enable                 ((uint32_t)0x00004000)
N
N#define IS_FSMC_EXTENDED_MODE(MODE) (((MODE) == FSMC_ExtendedMode_Disable) || \
N                                     ((MODE) == FSMC_ExtendedMode_Enable)) 
X#define IS_FSMC_EXTENDED_MODE(MODE) (((MODE) == FSMC_ExtendedMode_Disable) ||                                      ((MODE) == FSMC_ExtendedMode_Enable)) 
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Write_Burst 
N  * @{
N  */
N
N#define FSMC_WriteBurst_Disable                  ((uint32_t)0x00000000)
N#define FSMC_WriteBurst_Enable                   ((uint32_t)0x00080000) 
N#define IS_FSMC_WRITE_BURST(BURST) (((BURST) == FSMC_WriteBurst_Disable) || \
N                                    ((BURST) == FSMC_WriteBurst_Enable))
X#define IS_FSMC_WRITE_BURST(BURST) (((BURST) == FSMC_WriteBurst_Disable) ||                                     ((BURST) == FSMC_WriteBurst_Enable))
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Address_Setup_Time 
N  * @{
N  */
N#define IS_FSMC_ADDRESS_SETUP_TIME(TIME) ((TIME) <= 0xF)
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Address_Hold_Time 
N  * @{
N  */
N#define IS_FSMC_ADDRESS_HOLD_TIME(TIME) ((TIME) <= 0xF)
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Data_Setup_Time 
N  * @{
N  */
N#define IS_FSMC_DATASETUP_TIME(TIME) (((TIME) > 0) && ((TIME) <= 0xFF))
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Bus_Turn_around_Duration 
N  * @{
N  */
N#define IS_FSMC_TURNAROUND_TIME(TIME) ((TIME) <= 0xF)
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_CLK_Division 
N  * @{
N  */
N#define IS_FSMC_CLK_DIV(DIV) ((DIV) <= 0xF)
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Data_Latency 
N  * @{
N  */
N#define IS_FSMC_DATA_LATENCY(LATENCY) ((LATENCY) <= 0xF)
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Access_Mode 
N  * @{
N  */
N#define FSMC_AccessMode_A                        ((uint32_t)0x00000000)
N#define FSMC_AccessMode_B                        ((uint32_t)0x10000000) 
N#define FSMC_AccessMode_C                        ((uint32_t)0x20000000)
N#define FSMC_AccessMode_D                        ((uint32_t)0x30000000)
N#define IS_FSMC_ACCESS_MODE(MODE) (((MODE) == FSMC_AccessMode_A) || \
N                                   ((MODE) == FSMC_AccessMode_B) || \
N                                   ((MODE) == FSMC_AccessMode_C) || \
N                                   ((MODE) == FSMC_AccessMode_D))
X#define IS_FSMC_ACCESS_MODE(MODE) (((MODE) == FSMC_AccessMode_A) ||                                    ((MODE) == FSMC_AccessMode_B) ||                                    ((MODE) == FSMC_AccessMode_C) ||                                    ((MODE) == FSMC_AccessMode_D))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N  
N/** @defgroup FSMC_NAND_PCCARD_Controller 
N  * @{
N  */
N
N/** @defgroup FSMC_Wait_feature 
N  * @{
N  */
N#define FSMC_Waitfeature_Disable                 ((uint32_t)0x00000000)
N#define FSMC_Waitfeature_Enable                  ((uint32_t)0x00000002)
N#define IS_FSMC_WAIT_FEATURE(FEATURE) (((FEATURE) == FSMC_Waitfeature_Disable) || \
N                                       ((FEATURE) == FSMC_Waitfeature_Enable))
X#define IS_FSMC_WAIT_FEATURE(FEATURE) (((FEATURE) == FSMC_Waitfeature_Disable) ||                                        ((FEATURE) == FSMC_Waitfeature_Enable))
N/**
N  * @}
N  */
N
N
N/** @defgroup FSMC_ECC 
N  * @{
N  */
N#define FSMC_ECC_Disable                         ((uint32_t)0x00000000)
N#define FSMC_ECC_Enable                          ((uint32_t)0x00000040)
N#define IS_FSMC_ECC_STATE(STATE) (((STATE) == FSMC_ECC_Disable) || \
N                                  ((STATE) == FSMC_ECC_Enable))
X#define IS_FSMC_ECC_STATE(STATE) (((STATE) == FSMC_ECC_Disable) ||                                   ((STATE) == FSMC_ECC_Enable))
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_ECC_Page_Size 
N  * @{
N  */
N#define FSMC_ECCPageSize_256Bytes                ((uint32_t)0x00000000)
N#define FSMC_ECCPageSize_512Bytes                ((uint32_t)0x00020000)
N#define FSMC_ECCPageSize_1024Bytes               ((uint32_t)0x00040000)
N#define FSMC_ECCPageSize_2048Bytes               ((uint32_t)0x00060000)
N#define FSMC_ECCPageSize_4096Bytes               ((uint32_t)0x00080000)
N#define FSMC_ECCPageSize_8192Bytes               ((uint32_t)0x000A0000)
N#define IS_FSMC_ECCPAGE_SIZE(SIZE) (((SIZE) == FSMC_ECCPageSize_256Bytes) || \
N                                    ((SIZE) == FSMC_ECCPageSize_512Bytes) || \
N                                    ((SIZE) == FSMC_ECCPageSize_1024Bytes) || \
N                                    ((SIZE) == FSMC_ECCPageSize_2048Bytes) || \
N                                    ((SIZE) == FSMC_ECCPageSize_4096Bytes) || \
N                                    ((SIZE) == FSMC_ECCPageSize_8192Bytes))
X#define IS_FSMC_ECCPAGE_SIZE(SIZE) (((SIZE) == FSMC_ECCPageSize_256Bytes) ||                                     ((SIZE) == FSMC_ECCPageSize_512Bytes) ||                                     ((SIZE) == FSMC_ECCPageSize_1024Bytes) ||                                     ((SIZE) == FSMC_ECCPageSize_2048Bytes) ||                                     ((SIZE) == FSMC_ECCPageSize_4096Bytes) ||                                     ((SIZE) == FSMC_ECCPageSize_8192Bytes))
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_TCLR_Setup_Time 
N  * @{
N  */
N#define IS_FSMC_TCLR_TIME(TIME) ((TIME) <= 0xFF)
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_TAR_Setup_Time 
N  * @{
N  */
N#define IS_FSMC_TAR_TIME(TIME) ((TIME) <= 0xFF)
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Setup_Time 
N  * @{
N  */
N#define IS_FSMC_SETUP_TIME(TIME) ((TIME) <= 0xFF)
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Wait_Setup_Time 
N  * @{
N  */
N#define IS_FSMC_WAIT_TIME(TIME) ((TIME) <= 0xFF)
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Hold_Setup_Time 
N  * @{
N  */
N#define IS_FSMC_HOLD_TIME(TIME) ((TIME) <= 0xFF)
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_HiZ_Setup_Time 
N  * @{
N  */
N#define IS_FSMC_HIZ_TIME(TIME) ((TIME) <= 0xFF)
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Interrupt_sources 
N  * @{
N  */
N#define FSMC_IT_RisingEdge                       ((uint32_t)0x00000008)
N#define FSMC_IT_Level                            ((uint32_t)0x00000010)
N#define FSMC_IT_FallingEdge                      ((uint32_t)0x00000020)
N#define IS_FSMC_IT(IT) ((((IT) & (uint32_t)0xFFFFFFC7) == 0x00000000) && ((IT) != 0x00000000))
N#define IS_FSMC_GET_IT(IT) (((IT) == FSMC_IT_RisingEdge) || \
N                            ((IT) == FSMC_IT_Level) || \
N                            ((IT) == FSMC_IT_FallingEdge)) 
X#define IS_FSMC_GET_IT(IT) (((IT) == FSMC_IT_RisingEdge) ||                             ((IT) == FSMC_IT_Level) ||                             ((IT) == FSMC_IT_FallingEdge)) 
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Flags 
N  * @{
N  */
N#define FSMC_FLAG_RisingEdge                     ((uint32_t)0x00000001)
N#define FSMC_FLAG_Level                          ((uint32_t)0x00000002)
N#define FSMC_FLAG_FallingEdge                    ((uint32_t)0x00000004)
N#define FSMC_FLAG_FEMPT                          ((uint32_t)0x00000040)
N#define IS_FSMC_GET_FLAG(FLAG) (((FLAG) == FSMC_FLAG_RisingEdge) || \
N                                ((FLAG) == FSMC_FLAG_Level) || \
N                                ((FLAG) == FSMC_FLAG_FallingEdge) || \
N                                ((FLAG) == FSMC_FLAG_FEMPT))
X#define IS_FSMC_GET_FLAG(FLAG) (((FLAG) == FSMC_FLAG_RisingEdge) ||                                 ((FLAG) == FSMC_FLAG_Level) ||                                 ((FLAG) == FSMC_FLAG_FallingEdge) ||                                 ((FLAG) == FSMC_FLAG_FEMPT))
N
N#define IS_FSMC_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFFFFFFF8) == 0x00000000) && ((FLAG) != 0x00000000))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/ 
N
N/* NOR/SRAM Controller functions **********************************************/
Nvoid FSMC_NORSRAMDeInit(uint32_t FSMC_Bank);
Nvoid FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct);
Nvoid FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct);
Nvoid FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState);
N
N/* NAND Controller functions **************************************************/
Nvoid FSMC_NANDDeInit(uint32_t FSMC_Bank);
Nvoid FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct);
Nvoid FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct);
Nvoid FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState);
Nvoid FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState);
Nuint32_t FSMC_GetECC(uint32_t FSMC_Bank);
N
N/* PCCARD Controller functions ************************************************/
Nvoid FSMC_PCCARDDeInit(void);
Nvoid FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct);
Nvoid FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct);
Nvoid FSMC_PCCARDCmd(FunctionalState NewState);
N
N/* Interrupts and flags management functions **********************************/
Nvoid FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState);
NFlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG);
Nvoid FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG);
NITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT);
Nvoid FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F4xx_FSMC_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 87 "..\..\Service\stm32f4xx_conf.h" 2
N#endif /* STM32F40_41xxx */
N
N#if defined (STM32F411xE)
X#if 0L
S#include "stm32f4xx_flash_ramfunc.h"
N#endif /* STM32F411xE */
N
N#if defined (STM32F446xx)
X#if 0L
S#include "stm32f4xx_qspi.h"
S#include "stm32f4xx_fmpi2c.h"
S#include "stm32f4xx_spdifrx.h"
S#include "stm32f4xx_cec.h"
N#endif /* STM32F446xx */
N
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/* If an external clock source is used, then the value of the following define 
N   should be set to the value of the external clock source, else, if no external 
N   clock is used, keep this define commented */
N/*#define I2S_EXTERNAL_CLOCK_VAL   12288000 */ /* Value of the external clock in Hz */
N
N
N/* Uncomment the line below to expanse the "assert_param" macro in the 
N   Standard Peripheral Library drivers code */
N/* #define USE_FULL_ASSERT    1 */
N
N/* Exported macro ------------------------------------------------------------*/
N#ifdef  USE_FULL_ASSERT
S
S/**
S  * @brief  The assert_param macro is used for function's parameters check.
S  * @param  expr: If expr is false, it calls assert_failed function
S  *   which reports the name of the source file and the source
S  *   line number of the call that failed. 
S  *   If expr is true, it returns no value.
S  * @retval None
S  */
S  #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
S/* Exported functions ------------------------------------------------------- */
S  void assert_failed(uint8_t* file, uint32_t line);
N#else
N  #define assert_param(expr) ((void)0)
N#endif /* USE_FULL_ASSERT */
N
N#endif /* __STM32F4xx_CONF_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 12028 "..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include\stm32f4xx.h" 2
N#endif /* USE_STDPERIPH_DRIVER */
N
N/** @addtogroup Exported_macro
N  * @{
N  */
N
N#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
N
N#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
N
N#define READ_BIT(REG, BIT)    ((REG) & (BIT))
N
N#define CLEAR_REG(REG)        ((REG) = (0x0))
N
N#define WRITE_REG(REG, VAL)   ((REG) = (VAL))
N
N#define READ_REG(REG)         ((REG))
N
N#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif /* __STM32F4xx_H */
N
N/**
N  * @}
N  */
N
N  /**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 5 "..\..\Complex\./usart/bsp_debug_usart.h" 2
N
N#include <stdio.h>
N
N
N//引脚定义
N/*******************************************************/
N#define DEBUG_USART                             USART1
N#define DEBUG_USART_CLK                         RCC_APB2Periph_USART1
N#define DEBUG_USART_BAUDRATE                    115200  //串口波特率
N
N#define DEBUG_USART_RX_GPIO_PORT                GPIOA
N#define DEBUG_USART_RX_GPIO_CLK                 RCC_AHB1Periph_GPIOA
N#define DEBUG_USART_RX_PIN                      GPIO_Pin_10
N#define DEBUG_USART_RX_AF                       GPIO_AF_USART1
N#define DEBUG_USART_RX_SOURCE                   GPIO_PinSource10
N
N#define DEBUG_USART_TX_GPIO_PORT                GPIOA
N#define DEBUG_USART_TX_GPIO_CLK                 RCC_AHB1Periph_GPIOA
N#define DEBUG_USART_TX_PIN                      GPIO_Pin_9
N#define DEBUG_USART_TX_AF                       GPIO_AF_USART1
N#define DEBUG_USART_TX_SOURCE                   GPIO_PinSource9
N
N#define DEBUG_USART_IRQHandler                  USART1_IRQHandler
N#define DEBUG_USART_IRQ                 				USART1_IRQn
N/************************************************************/
N
Nvoid Debug_USART_Config(void);
Nvoid Usart_SendByte( USART_TypeDef * pUSARTx, uint8_t ch);
Nvoid Usart_SendString( USART_TypeDef * pUSARTx, char *str);
N
Nvoid Usart_SendHalfWord( USART_TypeDef * pUSARTx, uint16_t ch);
N
N#endif /* __USART1_H */
L 30 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "./usart3/usart3.h"
L 1 "..\..\Complex\./usart3/usart3.h" 1
N#ifndef __RS232_USART3_H
N#define	__RS232_USART3_H
N
N#include "stm32f4xx.h"
N#include <stdio.h>
N
N
N
N//引脚定义
N/*******************************************************/
N#define UART3_USART                             USART3
N#define UART3_USART_CLK                         RCC_APB1Periph_USART3
N
N#define UART3_USART_RX_GPIO_PORT                GPIOB
N#define UART3_USART_RX_GPIO_CLK                 RCC_AHB1Periph_GPIOB
N#define UART3_USART_RX_PIN                      GPIO_Pin_11
N#define UART3_USART_RX_AF                       GPIO_AF_USART3
N#define UART3_USART_RX_SOURCE                   GPIO_PinSource11
N
N#define UART3_USART_TX_GPIO_PORT                GPIOB
N#define UART3_USART_TX_GPIO_CLK                 RCC_AHB1Periph_GPIOB
N#define UART3_USART_TX_PIN                      GPIO_Pin_10
N#define UART3_USART_TX_AF                       GPIO_AF_USART3
N#define UART3_USART_TX_SOURCE                   GPIO_PinSource10
N
N          
N#define UART3_USART_IRQ                 				USART3_IRQn
N/************************************************************/
N
N
N//串口波特率
N#define UART3_USART_BAUDRATE                    115200
N
N
N
Nextern void USART3_Config(void);
N//void Usart_SendString( USART_TypeDef * pUSARTx, uint8_t *str);
Nextern void SetUSART_BaudRate(USART_TypeDef* USARTx, uint32_t Le_w_BaudRate);
N//int fputc(int ch, FILE *f);
N
N#endif /* __USART1_H */
L 31 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "./usart4/usart4.h"
L 1 "..\..\Complex\./usart4/usart4.h" 1
N#ifndef __RS232_USART4_H
N#define	__RS232_USART4_H
N
N#include "stm32f4xx.h"
N#include <stdio.h>
N
N
N
N//引脚定义
N/*******************************************************/
N#define UART4_USART                             UART4
N#define UART4_USART_CLK                         RCC_APB1Periph_UART4
N
N#define UART4_USART_RX_GPIO_PORT                GPIOC
N#define UART4_USART_RX_GPIO_CLK                 RCC_AHB1Periph_GPIOC
N#define UART4_USART_RX_PIN                      GPIO_Pin_11
N#define UART4_USART_RX_AF                       GPIO_AF_UART4
N#define UART4_USART_RX_SOURCE                   GPIO_PinSource11
N
N#define UART4_USART_TX_GPIO_PORT                GPIOC
N#define UART4_USART_TX_GPIO_CLK                 RCC_AHB1Periph_GPIOC
N#define UART4_USART_TX_PIN                      GPIO_Pin_10
N#define UART4_USART_TX_AF                       GPIO_AF_UART4
N#define UART4_USART_TX_SOURCE                   GPIO_PinSource10
N
N          
N#define UART4_USART_IRQ                 				UART4_IRQn
N/************************************************************/
N
N
N
N//串口波特率
N#define UART4_USART_BAUDRATE                    115200
N
N
N
Nvoid USART4_Config(void);
N//void Usart_SendString( USART_TypeDef * pUSARTx, uint8_t *str);
N
N//int fputc(int ch, FILE *f);
N
N#endif /* __USART1_H */
L 32 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "./usart5/usart5.h"
L 1 "..\..\Complex\./usart5/usart5.h" 1
N#ifndef __RS232_USART5_H
N#define	__RS232_USART5_H
N
N#include "stm32f4xx.h"
N#include <stdio.h>
N
N
N
N//引脚定义
N/*******************************************************/
N#define UART5_USART                             UART5
N#define UART5_USART_CLK                         RCC_APB1Periph_UART5
N
N#define UART5_USART_RX_GPIO_PORT                GPIOD
N#define UART5_USART_RX_GPIO_CLK                 RCC_AHB1Periph_GPIOD
N#define UART5_USART_RX_PIN                      GPIO_Pin_2
N#define UART5_USART_RX_AF                       GPIO_AF_UART5
N#define UART5_USART_RX_SOURCE                   GPIO_PinSource2
N
N#define UART5_USART_TX_GPIO_PORT                GPIOC
N#define UART5_USART_TX_GPIO_CLK                 RCC_AHB1Periph_GPIOC
N#define UART5_USART_TX_PIN                      GPIO_Pin_12
N#define UART5_USART_TX_AF                       GPIO_AF_UART5
N#define UART5_USART_TX_SOURCE                   GPIO_PinSource12
N
N          
N#define UART5_USART_IRQ                 				UART5_IRQn 
N/************************************************************/
N
N
N//串口波特率
N#define UART5_USART_BAUDRATE                    115200
N
N
N
Nvoid USART5_Config(void);
N//void Usart_SendString( USART_TypeDef * pUSARTx, uint8_t *str);
N
N//int fputc(int ch, FILE *f);
N//void bledata_deel(char *BleTemp,u8 blenum);
N
N#endif /* __USART1_H */
L 33 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N//#include "./i2c/bsP_i2c_ee.h"
N#include "./led/bsp_led.h"
L 1 "..\..\Complex\./led/bsp_led.h" 1
N#ifndef __LED_H
N#define	__LED_H
N
N#include "stm32f4xx.h"
N
N//引脚定义
N/*******************************************************/
N//R 红色灯
N#define LED1_PIN                  GPIO_Pin_6                 
N#define LED1_GPIO_PORT            GPIOF                      
N#define LED1_GPIO_CLK             RCC_AHB1Periph_GPIOF
N
N//G 绿色灯
N#define LED2_PIN                  GPIO_Pin_7                 
N#define LED2_GPIO_PORT            GPIOF                      
N#define LED2_GPIO_CLK             RCC_AHB1Periph_GPIOF
N
N//B 蓝色灯
N#define LED3_PIN                  GPIO_Pin_8                 
N#define LED3_GPIO_PORT            GPIOF                       
N#define LED3_GPIO_CLK             RCC_AHB1Periph_GPIOF
N/************************************************************/
N
N
N/** 控制LED灯亮灭的宏，
N	* LED低电平亮，设置ON=0，OFF=1
N	* 若LED高电平亮，把宏设置成ON=1 ，OFF=0 即可
N	*/
N#define ON  0
N#define OFF 1
N
N/* 带参宏，可以像内联函数一样使用 */
N#define LED1(a)	if (a)	\
N					digitalLo(LED1_GPIO_PORT,LED1_PIN);\
N					else		\
N					digitalHi(LED1_GPIO_PORT,LED1_PIN)
X#define LED1(a)	if (a)						digitalLo(LED1_GPIO_PORT,LED1_PIN);					else							digitalHi(LED1_GPIO_PORT,LED1_PIN)
N
N#define LED2(a)	if (a)	\
N					digitalLo(LED2_GPIO_PORT,LED2_PIN);\
N					else		\
N					digitalHi(LED2_GPIO_PORT,LED2_PIN)
X#define LED2(a)	if (a)						digitalLo(LED2_GPIO_PORT,LED2_PIN);					else							digitalHi(LED2_GPIO_PORT,LED2_PIN)
N
N#define LED3(a)	if (a)	\
N					digitalLo(LED3_GPIO_PORT,LED3_PIN);\
N					else		\
N					digitalHi(LED3_GPIO_PORT,LED3_PIN)
X#define LED3(a)	if (a)						digitalLo(LED3_GPIO_PORT,LED3_PIN);					else							digitalHi(LED3_GPIO_PORT,LED3_PIN)
N
N
N/* 直接操作寄存器的方法控制IO */
N#define	digitalHi(p,i)			 {p->BSRRL=i;}		//设置为高电平
N#define digitalLo(p,i)			 {p->BSRRH=i;}		//输出低电平
N#define digitalToggle(p,i)	 {p->ODR ^=i;}		//输出反转状态
N
N/* 定义控制IO的宏 */
N#define LED1_TOGGLE		digitalToggle(LED1_GPIO_PORT,LED1_PIN)
N#define LED1_OFF			digitalHi(LED1_GPIO_PORT,LED1_PIN)
N#define LED1_ON				digitalLo(LED1_GPIO_PORT,LED1_PIN)
N
N#define LED2_TOGGLE		digitalToggle(LED2_GPIO_PORT,LED2_PIN)
N#define LED2_OFF			digitalHi(LED2_GPIO_PORT,LED2_PIN)
N#define LED2_ON				digitalLo(LED2_GPIO_PORT,LED2_PIN)
N
N#define LED3_TOGGLE		digitalToggle(LED3_GPIO_PORT,LED3_PIN)
N#define LED3_OFF			digitalHi(LED3_GPIO_PORT,LED3_PIN)
N#define LED3_ON				digitalLo(LED3_GPIO_PORT,LED3_PIN)
N
N/* 基本混色，后面高级用法使用PWM可混出全彩颜色,且效果更好 */
N
N//红
N#define LED_RED  \
N					LED1_ON;\
N					LED2_OFF;\
N					LED3_OFF
X#define LED_RED  					LED1_ON;					LED2_OFF;					LED3_OFF
N
N//绿
N#define LED_GREEN		\
N					LED1_OFF;\
N					LED2_ON;\
N					LED3_OFF
X#define LED_GREEN							LED1_OFF;					LED2_ON;					LED3_OFF
N
N//蓝
N#define LED_BLUE	\
N					LED1_OFF;\
N					LED2_OFF;\
N					LED3_ON
X#define LED_BLUE						LED1_OFF;					LED2_OFF;					LED3_ON
N
N					
N//黄(红+绿)					
N#define LED_YELLOW	\
N					LED1_ON;\
N					LED2_ON;\
N					LED3_OFF
X#define LED_YELLOW						LED1_ON;					LED2_ON;					LED3_OFF
N//紫(红+蓝)
N#define LED_PURPLE	\
N					LED1_ON;\
N					LED2_OFF;\
N					LED3_ON
X#define LED_PURPLE						LED1_ON;					LED2_OFF;					LED3_ON
N
N//青(绿+蓝)
N#define LED_CYAN \
N					LED1_OFF;\
N					LED2_ON;\
N					LED3_ON
X#define LED_CYAN 					LED1_OFF;					LED2_ON;					LED3_ON
N					
N//白(红+绿+蓝)
N#define LED_WHITE	\
N					LED1_ON;\
N					LED2_ON;\
N					LED3_ON
X#define LED_WHITE						LED1_ON;					LED2_ON;					LED3_ON
N					
N//黑(全部关闭)
N#define LED_RGBOFF	\
N					LED1_OFF;\
N					LED2_OFF;\
N					LED3_OFF		
X#define LED_RGBOFF						LED1_OFF;					LED2_OFF;					LED3_OFF		
N
N
N
N
Nvoid LED_GPIO_Config(void);
N
N#endif /* __LED_H */
L 35 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "./i2c/bsp_i2c_gpio.h"
L 1 "..\..\Complex\./i2c/bsp_i2c_gpio.h" 1
N#ifndef _BSP_I2C_GPIO_H
N#define _BSP_I2C_GPIO_H
N
N#include "stm32f4xx.h"
N#include <inttypes.h>
L 1 "d:\Keil_v5\ARM\ARMCC\Bin\..\include\inttypes.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Based on WG14/N843 (C9X) Committee Draft August 3, 1998 */
N
N#ifndef __inttypes_h
N#define __inttypes_h
N#define __ARMCLIB_VERSION 5060019
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N
N#include <stdint.h>
N
N#if !defined(__cplusplus) || defined(__STDC_FORMAT_MACROS) || 201103L <= __cplusplus
X#if !0L || 0L || 201103L <= __cplusplus
N
N#ifdef __LP64__
S  #define __PRISCN64 "l" /* 'int64_t' is 'long' */
N#else
N  #define __PRISCN64 "ll" /* 'int64_t' is 'long long' */
N#endif
N#if __sizeof_ptr == 8
X#if 4 == 8
S  #define __PRISCNPTR __PRISCN64 /* 'intptr_t' is 64-bits */
N#else
N  #define __PRISCNPTR /*nothing*/ /* 'intptr_t' is 'int' */
N#endif
N
N
N    /* 7.8.1 */
N
N#define PRId8         "d"
N#define PRId16        "d"
N#define PRId32        "d"
N#define PRId64      __PRISCN64 "d"
N#define PRIdLEAST8    "d"
N#define PRIdLEAST16   "d"
N#define PRIdLEAST32   "d"
N#define PRIdLEAST64 __PRISCN64 "d"
N#define PRIdFAST8     "d"
N#define PRIdFAST16    "d"
N#define PRIdFAST32    "d"
N#define PRIdFAST64  __PRISCN64 "d"
N#define PRIdMAX      "jd"
N#define PRIdPTR     __PRISCNPTR "d"
N
N#define PRIi8         "i"
N#define PRIi16        "i"
N#define PRIi32        "i"
N#define PRIi64      __PRISCN64 "i"
N#define PRIiLEAST8    "i"
N#define PRIiLEAST16   "i"
N#define PRIiLEAST32   "i"
N#define PRIiLEAST64 __PRISCN64 "i"
N#define PRIiFAST8     "i"
N#define PRIiFAST16    "i"
N#define PRIiFAST32    "i"
N#define PRIiFAST64  __PRISCN64 "i"
N#define PRIiMAX      "ji"
N#define PRIiPTR     __PRISCNPTR "i"
N
N#define PRIo8         "o"
N#define PRIo16        "o"
N#define PRIo32        "o"
N#define PRIo64      __PRISCN64 "o"
N#define PRIoLEAST8    "o"
N#define PRIoLEAST16   "o"
N#define PRIoLEAST32   "o"
N#define PRIoLEAST64 __PRISCN64 "o"
N#define PRIoFAST8     "o"
N#define PRIoFAST16    "o"
N#define PRIoFAST32    "o"
N#define PRIoFAST64  __PRISCN64 "o"
N#define PRIoMAX      "jo"
N#define PRIoPTR     __PRISCNPTR "o"
N
N#define PRIu8         "d"
N#define PRIu16        "d"
N#define PRIu32        "u"
N#define PRIu64      __PRISCN64 "u"
N#define PRIuLEAST8    "d"
N#define PRIuLEAST16   "d"
N#define PRIuLEAST32   "u"
N#define PRIuLEAST64 __PRISCN64 "u"
N#define PRIuFAST8     "u"
N#define PRIuFAST16    "u"
N#define PRIuFAST32    "u"
N#define PRIuFAST64  __PRISCN64 "u"
N#define PRIuMAX      "ju"
N#define PRIuPTR     __PRISCNPTR "u"
N
N#define PRIx8         "x"
N#define PRIx16        "x"
N#define PRIx32        "x"
N#define PRIx64      __PRISCN64 "x"
N#define PRIxLEAST8    "x"
N#define PRIxLEAST16   "x"
N#define PRIxLEAST32   "x"
N#define PRIxLEAST64 __PRISCN64 "x"
N#define PRIxFAST8     "x"
N#define PRIxFAST16    "x"
N#define PRIxFAST32    "x"
N#define PRIxFAST64  __PRISCN64 "x"
N#define PRIxMAX      "jx"
N#define PRIxPTR     __PRISCNPTR "x"
N
N#define PRIX8         "X"
N#define PRIX16        "X"
N#define PRIX32        "X"
N#define PRIX64      __PRISCN64 "X"
N#define PRIXLEAST8    "X"
N#define PRIXLEAST16   "X"
N#define PRIXLEAST32   "X"
N#define PRIXLEAST64 __PRISCN64 "X"
N#define PRIXFAST8     "X"
N#define PRIXFAST16    "X"
N#define PRIXFAST32    "X"
N#define PRIXFAST64  __PRISCN64 "X"
N#define PRIXMAX      "jX"
N#define PRIXPTR     __PRISCNPTR "X"
N
N#define SCNd8       "hhd"
N#define SCNd16       "hd"
N#define SCNd32        "d"
N#define SCNd64      __PRISCN64 "d"
N#define SCNdLEAST8  "hhd"
N#define SCNdLEAST16  "hd"
N#define SCNdLEAST32   "d"
N#define SCNdLEAST64 __PRISCN64 "d"
N#define SCNdFAST8     "d"
N#define SCNdFAST16    "d"
N#define SCNdFAST32    "d"
N#define SCNdFAST64  __PRISCN64 "d"
N#define SCNdMAX      "jd"
N#define SCNdPTR     __PRISCNPTR "d"
N
N#define SCNi8       "hhd"
N#define SCNi16       "hi"
N#define SCNi32        "i"
N#define SCNi64      __PRISCN64 "i"
N#define SCNiLEAST8  "hhi"
N#define SCNiLEAST16  "hi"
N#define SCNiLEAST32   "i"
N#define SCNiLEAST64 __PRISCN64 "i"
N#define SCNiFAST8     "i"
N#define SCNiFAST16    "i"
N#define SCNiFAST32    "i"
N#define SCNiFAST64  __PRISCN64 "i"
N#define SCNiMAX      "ji"
N#define SCNiPTR     __PRISCNPTR "i"
N
N#define SCNo8       "hho"
N#define SCNo16       "ho"
N#define SCNo32        "o"
N#define SCNo64      __PRISCN64 "o"
N#define SCNoLEAST8  "hho"
N#define SCNoLEAST16  "ho"
N#define SCNoLEAST32   "o"
N#define SCNoLEAST64 __PRISCN64 "o"
N#define SCNoFAST8     "o"
N#define SCNoFAST16    "o"
N#define SCNoFAST32    "o"
N#define SCNoFAST64  __PRISCN64 "o"
N#define SCNoMAX      "jo"
N#define SCNoPTR     __PRISCNPTR "o"
N
N#define SCNu8       "hhu"
N#define SCNu16       "hu"
N#define SCNu32        "u"
N#define SCNu64      __PRISCN64 "u"
N#define SCNuLEAST8  "hhu"
N#define SCNuLEAST16  "hu"
N#define SCNuLEAST32   "u"
N#define SCNuLEAST64 __PRISCN64 "u"
N#define SCNuFAST8     "u"
N#define SCNuFAST16    "u"
N#define SCNuFAST32    "u"
N#define SCNuFAST64  __PRISCN64 "u"
N#define SCNuMAX      "ju"
N#define SCNuPTR     __PRISCNPTR "u"
N
N#define SCNx8       "hhx"
N#define SCNx16       "hx"
N#define SCNx32        "x"
N#define SCNx64      __PRISCN64 "x"
N#define SCNxLEAST8  "hhx"
N#define SCNxLEAST16  "hx"
N#define SCNxLEAST32   "x"
N#define SCNxLEAST64 __PRISCN64 "x"
N#define SCNxFAST8     "x"
N#define SCNxFAST16    "x"
N#define SCNxFAST32    "x"
N#define SCNxFAST64  __PRISCN64 "x"
N#define SCNxMAX      "jx"
N#define SCNxPTR     __PRISCNPTR "x"
N
N#endif /* __STDC_FORMAT_MACROS */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* see <stddef.h> */
N    #else
N      typedef unsigned short wchar_t; /* see <stddef.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* see <stddef.h> */
S    #else
S      typedef unsigned short wchar_t; /* see <stddef.h> */
S    #endif
N  #endif
N#endif
N
Ntypedef struct imaxdiv_t { intmax_t quot, rem; } imaxdiv_t;
N   /* type of the value returned by the imaxdiv function. */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N_ARMABI intmax_t strtoimax(const char * __restrict /*nptr*/,
X__declspec(__nothrow) intmax_t strtoimax(const char * __restrict  ,
N                   char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N    /* as for strtol */
N_ARMABI uintmax_t strtoumax(const char * __restrict /*nptr*/,
X__declspec(__nothrow) uintmax_t strtoumax(const char * __restrict  ,
N                    char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N    /* as for strtoul */
N
N_ARMABI intmax_t wcstoimax(const wchar_t * __restrict /*nptr*/,
X__declspec(__nothrow) intmax_t wcstoimax(const wchar_t * __restrict  ,
N                   wchar_t ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N_ARMABI uintmax_t wcstoumax(const wchar_t * __restrict /*nptr*/,
X__declspec(__nothrow) uintmax_t wcstoumax(const wchar_t * __restrict  ,
N                    wchar_t ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N
Nextern _ARMABI_PURE intmax_t imaxabs(intmax_t /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) intmax_t imaxabs(intmax_t  );
N   /*
N    * computes the absolute value of an intmax_t j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
Nextern _ARMABI_PURE imaxdiv_t imaxdiv(intmax_t /*numer*/, intmax_t /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) imaxdiv_t imaxdiv(intmax_t  , intmax_t  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type imaxdiv_t, comprising both the quotient and
N    *          the remainder. the structure shall contain the following
N    *          members, in either order.
N    *          intmax_t quot; intmax_t rem;
N    */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __inttypes_h */
N
N/* end of inttypes.h */
N
L 6 "..\..\Complex\./i2c/bsp_i2c_gpio.h" 2
N#include "stm32f4xx_rcc.h"
N#include "stm32f4xx_gpio.h"
N
N
N#define I2C_WR	0x00			/* 写控制bit */
N#define I2C_RD	0x01			/* 读控制bit */
N
N#define I2C_TYPE_SIMULATE		1		/* IIC通信方式：模拟 */
N#define I2C_TYPE_HARDWARE		2		/* IIC通信方式：硬件 */
N
N#define I2C_HARDWARE
N#ifdef 	I2C_HARDWARE   //定义硬件iic
N/* STM32 自身的 I2C 地址，这个地址只要与 STM32 外挂的 I2C 器件地址不一样即可 */
N#define I2C_OWN_ADDRESS7 		0X0A
N
N/* iic外设hym8563地址 */
N#define I2C_HYM8563_ADDRESS 	0XA2
N/* STM32<->hym8563 I2C 速率 */
N#define I2C_HYM8563_Speed 		200000 //200kbit/s
N
N
N/*I2C 接口*/
N#define I2C 					I2C1
N#define I2C_CLK 				RCC_APB1Periph_I2C1
N#define I2C_SCL_PIN 			GPIO_Pin_8
N#define I2C_SCL_GPIO_PORT 		GPIOB
N#define I2C_SCL_GPIO_CLK 		RCC_AHB1Periph_GPIOB
N#define I2C_SCL_SOURCE 			GPIO_PinSource8
N#define I2C_SCL_AF 				GPIO_AF_I2C1
N#define I2C_SDA_PIN 			GPIO_Pin_9
N#define I2C_SDA_GPIO_PORT 		GPIOB
N#define I2C_SDA_GPIO_CLK 		RCC_AHB1Periph_GPIOB
N#define I2C_SDA_SOURCE 			GPIO_PinSource9
N#define I2C_SDA_AF 				GPIO_AF_I2C1
N#endif
N
N
N/* 定义读写SCL和SDA的宏，已增加代码的可移植性和可阅读性 */
N#define EEPROM_I2C_SCL_1()  GPIO_SetBits(GPIOB, I2C_SCL_PIN)		/* SCL = 1 */
N#define EEPROM_I2C_SCL_0()  GPIO_ResetBits(GPIOB, I2C_SCL_PIN)		/* SCL = 0 */
N	
N#define EEPROM_I2C_SDA_1()  GPIO_SetBits(GPIOB, I2C_SDA_PIN)		/* SDA = 1 */
N#define EEPROM_I2C_SDA_0()  GPIO_ResetBits(GPIOB, I2C_SDA_PIN)		/* SDA = 0 */
N	
N#define EEPROM_I2C_SDA_READ()  GPIO_ReadInputDataBit(GPIOB,I2C_SDA_PIN)	/* 读SDA口线状态 */
N
N
N/*通讯等待超时时间*/
N#define I2CT_FLAG_TIMEOUT ((uint32_t)0x1000)
N#define I2CT_LONG_TIMEOUT ((uint32_t)(10 * I2CT_FLAG_TIMEOUT))
N
N
Ntypedef enum
N{
N	IIC_HYM8563 = 0U,/*hym8563时钟芯片*/
N	IIC_WM8978,/*wm8978音频芯片*/
N	IIC_LCD,/*lcd显示屏*/
N	IIC_TOUCHKEY,/*触摸按键*/
N	I2C_DEVICE_NUM//iic设备数量
N}bsp_iic_DevIndex;//设备类型索引
N
N
Ntypedef struct
N{
N	uint8_t DevAddr;//设备地址，代表了相应的设备
N	I2C_TypeDef* I2Cx;//I2C通道
N	uint32_t I2C_ClkSpeed;
N	uint32_t RCC_APB1Periph;
N	uint32_t RCC_AHB1Periph;
N	GPIO_TypeDef* GPIOx;
N	uint16_t SCL_PinSource;
N	uint16_t SDA_PinSource;
N	uint8_t GPIO_AF;
N	uint32_t SCL_pin;
N	uint32_t SDA_pin;
N}bsp_iic_confStruct;
N
N
N
N
N#ifdef 	I2C_HARDWARE   //定义硬件iic	
Nextern void i2c_CfgGpio(uint8_t Dev,uint8_t Le_u_workType);
Nextern void I2C_Mode_Config(uint8_t Dev);
Nextern uint8_t I2C_BytesWrite(uint8_t Dev,uint8_t RegWrAddr,uint8_t* pBuffer,uint8_t NumByteToWrite);
Nextern uint8_t I2C_BytesRead(uint8_t Dev,uint8_t RegRdAddr,uint8_t* pBuffer,uint8_t NumByteToRead);
N#endif
N/* 外部调用API */
Nextern void i2c_Start(void);
Nextern void i2c_Stop(void);
Nextern void i2c_SendByte(uint8_t _ucByte);
Nextern uint8_t i2c_ReadByte(void);
Nextern uint8_t i2c_WaitAck(void);
Nextern void i2c_Ack(void);
Nextern void i2c_NAck(void);
Nextern uint8_t i2c_CheckDevice(uint8_t _Address);
N
Nextern uint8_t I2C_Write_Byte(uint8_t ucDevAddr,uint8_t data);
Nextern uint8_t send_byte(uint8_t _ucByte);
Nextern uint8_t i2c_master_reg8_send(uint8_t ucDevAddr, uint8_t ucRegAddr, uint8_t *pucBuf, uint8_t uclength);
Nextern uint8_t i2c_master_reg8_recv(uint8_t ucDevAddr, uint8_t ucRegAddr, uint8_t *pucBuf, uint8_t uclength);
N
N#endif
N
L 36 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "./timeStamp/time_stamp.h"
L 1 "..\..\Complex\./timeStamp/time_stamp.h" 1
N#ifndef __TIME_STAMP_H__
N#define __TIME_STAMP_H__
N
N#include "stm32f4xx.h"
N#include "./hym8563/hym8563.h"
L 1 "..\..\Complex\./hym8563/hym8563.h" 1
N#ifndef _HYM8563_H
N#define _HYM8563_H
N
N#include "stm32f4xx.h"
N#include "Include.h"
L 1 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 1
N/******************************************************
N浠跺锛	
N
N杩帮
N
NData			  Vasion			author
N2018/1/4		  V1.0			    liujian
N*******************************************************/
N#ifndef		INCLUDE_H
S#define		INCLUDE_H
S/*******************************************************
Sdescription锛include the header file
S*******************************************************/
S
S#define NETWORK_ON     //定义时，开启网络功能
S#define UART_DEBUG
S//#define WM8978_DEBUG
S//#define NET_DEBUG
S//#define TIME_DEBUG
S//#define freeRTOS_RUN_DEBUG
S
S
S
S/*C标准库文件*/
S#include <string.h>
S#include <stdlib.h>
S#include <stdio.h>
S/*bsp文件*/
S#include "./usart/bsp_debug_usart.h"
S#include "./usart3/usart3.h"
S#include "./usart4/usart4.h"
S#include "./usart5/usart5.h"
S//#include "./i2c/bsP_i2c_ee.h"
S#include "./led/bsp_led.h"
S#include "./i2c/bsp_i2c_gpio.h"
S#include "./timeStamp/time_stamp.h"
S#include "time.h"
S#include "./systick/bsp_SysTick.h"
S#include "./key/bsp_exti.h"
S#include "./hym8563/hym8563.h"
S#include "./display/display.h"
S#include "./sm3/SM3.h"
S#include "./beep/bsp_beep.h" 
S#include "./wm8978/bsp_wm8978.h"
S#include "./FATFS/ff.h" 
S#include "./AudioIO/AudioIO.h"
S#include "./timeStamp/time_stamp.h"
S#include "./FATFS/tm_stm32f4_fatfs.h"
S#include "./FATFS/diskio.h"	
S#include "./flash/fatfs_flash_spi.h"
S#include "./adc/bsp_adc.h"
S#include "./wdata/wdata.h" 
S#include "./iwdg/bsp_iwdg.h"   
S#include "./rcc/bsp_clkconfig.h"
S#include "stm32f4xx_iwdg.h"
S
S/*STM32库文件*/
S#include "stm32f4xx.h"
S#include "stm32f4xx_it.h"
S#include "stm32f4xx_usart.h"
S#include "stm32f4xx_exti.h"
S#include "stm32f429_eth.h"
S#include "LAN8742A.h"
S#include "stm32f4xx_adc.h"
S#include "misc.h"
S/*用户文件*/
S//Ecal
S#include "MyType.h"
S#include "Mcu_Init.h"
S#include "BtnFltr.h"
S#include "UartCmn.h"
S#include "MemIf.h"
S#include "./BListCache/BListCache.h"
S#include "./UnlockLogCache/UnlockLogCache.h"
S#include "tcp_client_ShortConnect.h"
S#include "tcp_client_LngConnect.h"
S#include "dnsAnalysis.h"
S#include "ntpclient.h"
S#include "dhcpClient.h"
S#include "JsonIf.h"
S#include "cJSON.h"
S#include "./STD_ADFliter/STD_ADFliter.h"
S#include "./PeriStFliter/PSFltr.h"
S#include "./crc32/crc32.h"
S#include "http_client_iap.h"
S#include "STM8_FM17550_iap.h"
S
S//App
S#include "./ZR60_Ctrl/ZR60_Ctrl.h"
S#include "BListMng.h"
S#include "./readcard/readcard.h"
S
S/*Lwip库文件*/
S#include "lwip/init.h"
S#include "lwip/tcp.h"
S#include "lwip/udp.h"
S#include "netconf.h"
S#include "lwip/pbuf.h"
S//#include "lwipopts.h"
S//#include "lwip/opt.h"
S#include "lwip/ip_addr.h"
S#include "lwip/ip.h"
S#include "lwip/igmp.h"
S#include "lwip/dns.h"
S
S//freeRTOS
S#include "FreeRTOS.h"
S#include "task.h"
S#include "queue.h"
S#include "misc.h"
S#include "event_groups.h"
S
S/*******************************************************
Sdescription锛macro definitions
S*******************************************************/
S/**********瀹寮冲涔*******/
S
S/*******************************************************
Sdescription：Often use of macro definitions
S*******************************************************/
S/***********瀹芥*********/
S
S#ifdef UART_DEBUG
S#define USART_PRINTF_S(x)   	 printf("%s\n",x)
S#define USART_PRINTF_D(x,d)   	 printf(x,d)
S#define USART_PRINTF_CARD_NUM(x,d1,d2,d3,d4)    	printf(x,d1,d2,d3,d4)
S#define USART_PRINTF_IP(x,d1,d2,d3,d4)    			printf(x,d1,d2,d3,d4)
S#define USART_PRINTF_MAC(x,d1,d2,d3,d4,d5,d6)    	printf(x,d1,d2,d3,d4,d5,d6)
S#define USART_PRINTF_DATE(x,d1,d2,d3,d4,d5,d6)   	printf(x,d1,d2,d3,d4,d5,d6)
S#else
S#define USART_PRINTF_S(x)    
S#define USART_PRINTF_D(x,d)  
S#define USART_PRINTF_CARD_NUM(x,d1,d2,d3,d4)
S#define USART_PRINTF_IP(x,d1,d2,d3,d4)
S#define USART_PRINTF_MAC(x,d1,d2,d3,d4,d5,d6)
S#define USART_PRINTF_DATE(x,d1,d2,d3,d4,d5,d6)
S#endif
S
S
S/*******************************************************
Sdescription锛struct definitions
S*******************************************************/
S
S/*******************************************************
Sdescription锛typedef definitions
S*******************************************************/
S/*****struct definitions*****/
S
S/******enum definitions******/
S
S/******union definitions*****/
S
S/*******************************************************
Sdescription锛variable External declaration
S*******************************************************/
S//extern uint16 Vemain_w_5msTskTimer;
S
S/*******************************************************
Sdescription锛function External declaration
S*******************************************************/
S
N#endif
L 6 "..\..\Complex\./hym8563/hym8563.h" 2
N
N
N/* iic外设hym8563地址 */
N#define HYM8563_ADDRESS 	0XA2
N
N
N#define   RTC_CTL1		0x00
N#define   RTC_CTL2		0x01
N#define   RTC_SEC		0x02//秒寄存器地址
N#define   RTC_MIN		0x03
N#define   RTC_HOUR		0x04
N#define   RTC_DAY		0x05
N#define   RTC_WEEK		0x06
N#define   RTC_MON		0x07
N#define   RTC_YEAR		0x08
N#define   RTC_A_MIN 	0x09
N#define   RTC_A_HOUR	0x0A
N#define   RTC_A_DAY 	0x0B
N#define   RTC_A_WEEK	0x0C
N#define   RTC_CLKOUT	0x0D
N#define   RTC_T_CTL 	0x0E
N#define   RTC_T_COUNT	0x0F
N#define   CENTURY	0x80
N#define   STOP		0x20
N#define   TI		0x10
N#define   AF		0x08
N#define   TF		0x04
N#define   AIE		0x02
N#define   TIE		0x01
N#define   FE		0x80
N#define   TE		0x80
N#define   FD1		0x02
N#define   FD0		0x01
N#define   TD1		0x02
N#define   TD0		0x01
N#define   VL		0x80
N
N#define HYM8563_REG_LEN 	0x10
N#define HYM8563_RTC_SECTION_LEN	0x07
N
N
Nstruct rtc_time {
N	int tm_sec;
N	int tm_min;
N	int tm_hour;
N	int tm_mday;
N	int tm_mon;
N	int tm_year;
N	int tm_wday;
N	int tm_yday;
N	int tm_isdst;
N};
N
Nextern void Inithym8563_device(void);
Nextern uint8_t bin2bcd(uint8_t val);
Nextern uint8_t hym8563_set_time(struct rtc_time *tm);
Nextern void hym8563_Currenttime(uint64_t* time);
Nextern uint8_t hym8563_read_datetime(struct rtc_time *tm);
Nextern uint8_t hym8563_i2c_set_regs(u8 reg, u8 *buf, u8 len);
Nextern uint8_t hym8563_i2c_read_regs(u8 regAddr, u8 *buf, u8 len);
N
N#endif
N
L 6 "..\..\Complex\./timeStamp/time_stamp.h" 2
N#include "./wdata/wdata.h"
L 1 "..\..\Complex\./wdata/wdata.h" 1
N#ifndef __WDATA_H
N#define	__WDATA_H
N
N#include "stm32f4xx.h"
N
Nstruct comm_info //楼栋信息
N{
N	unsigned char community_id[16];//小区id
N	unsigned char build_numOne[16];//楼栋编号列表1(0x15)
N	unsigned char build_numTwo[16];//楼栋编号列表2(0x16)
N	unsigned char build_id[16];//楼栋id
N	unsigned char door_id[16];//门id
N	unsigned char suffix;//下标
N	//unsigned char BListFlag;//黑白名单标志:0--黑名单；1--白名单
N};
N
Nstruct sm3_info //楼栋信息
N{
N	unsigned char community_id[8];//小区id
N	unsigned char build_num[8];//楼栋号
N	unsigned char cell_num[8];//单元号
N	unsigned char null;//空字符'\0'
N};
N
N
N
Nint add_data(const char *filename,struct comm_info *sm3_buf);
Nint read_card_data(const char *filename,struct comm_info *sm3_buf);
Nvoid read_init_sminfo(struct comm_info *sm3_buf,struct sm3_info *sm);
N#endif
L 7 "..\..\Complex\./timeStamp/time_stamp.h" 2
N
N
N#define TIME_STAMP_PASSWORD  0
N#define TIME_STAMP_SOUND     1
N#define TIME_STAMP_BLE       2
N
N
N#define TIME_STAMP_BJT     0//时间类型为北京时间
N#define TIME_STAMP_UNT     1//时间类型为世界时间
N
Ntypedef union
N{
N	unsigned char currentdate[14U];
N	struct 
N	{	
N		unsigned char year[4U];
N		unsigned char mon[2U];
N		unsigned char mday[2U];
N		unsigned char hour[2U];
N		unsigned char min[2U];
N		unsigned char sec[2U];
N	}date;
N}time_stamp_Date;
N
N
Nextern u8 key_buf[6];
N
Nextern uint32_t GetTick(struct rtc_time *tm);
Nextern uint32_t  check_passwd(u32 type_value,u8 mach_type);
Nextern uint8_t sm3_time_PasswordAuth(uint32_t now_time,struct sm3_info *sm,u8 n,u8 mach_type);
Nextern uint32_t  generate_password(u32 *passwd2,u32 *passwd1);
Nextern void timestamp_timeCalibration(char *tm,uint8_t tmType);  
Nextern void timestamp_strBJtime(unsigned long timestamp, char *ftime);
N#endif
L 37 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "time.h"
L 1 "d:\Keil_v5\ARM\ARMCC\Bin\..\include\time.h" 1
N/* time.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.12 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                      */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.        */
N/* version 0.03 */
N
N/*
N * time.h declares two macros, four types and several functions for
N * manipulating time. Many functions deal with a calendar time that
N * represents the current date (according to the Gregorian
N * calendar) and time. Some functions deal with local time, which
N * is the calendar time expressed for some specific time zone, and
N * with Daylight Savings Time, which is a temporary change in the
N * algorithm for determining local time.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __time_h
N#define __time_h
N#define __ARMCLIB_VERSION 5060019
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N
N  #ifndef __TIME_DECLS
N  #define __TIME_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N    /* CLOCKS_PER_SEC: the number per second of the value returned by the
N     * clock function. */
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S  extern const int __aeabi_CLOCKS_PER_SEC;
S  #define CLOCKS_PER_SEC (__aeabi_CLOCKS_PER_SEC)
N#else
N  #ifdef __CLK_TCK
S    #define CLOCKS_PER_SEC  __CLK_TCK
N  #else
N    #define CLOCKS_PER_SEC  100
N  #endif
N#endif
N
N#ifndef __STRICT_ANSI__
N  #define CLK_TCK CLOCKS_PER_SEC
N#endif
N
Ntypedef unsigned int clock_t;    /* cpu time type */
Ntypedef unsigned int time_t;     /* date/time in unix secs past 1-Jan-70 */
N
N#pragma push
N#pragma anon_unions
N
Nstruct tm {
N    int tm_sec;   /* seconds after the minute, 0 to 60
N                     (0 - 60 allows for the occasional leap second) */
N    int tm_min;   /* minutes after the hour, 0 to 59 */
N    int tm_hour;  /* hours since midnight, 0 to 23 */
N    int tm_mday;  /* day of the month, 1 to 31 */
N    int tm_mon;   /* months since January, 0 to 11 */
N    int tm_year;  /* years since 1900 */
N    int tm_wday;  /* days since Sunday, 0 to 6 */
N    int tm_yday;  /* days since January 1, 0 to 365 */
N    int tm_isdst; /* Daylight Savings Time flag */
N    union {       /* ABI-required extra fields, in a variety of types */
N        struct {
N            int __extra_1, __extra_2;
N        };
N        struct {
N            long __extra_1_long, __extra_2_long;
N        };
N        struct {
N            char *__extra_1_cptr, *__extra_2_cptr;
N        };
N        struct {
N            void *__extra_1_vptr, *__extra_2_vptr;
N        };
N    };
N};
N
N#pragma pop
N
N   /* struct tm holds the components of a calendar time, called the broken-down
N    * time. The value of tm_isdst is positive if Daylight Savings Time is in
N    * effect, zero if Daylight Savings Time is not in effect, and negative if
N    * the information is not available.
N    */
N
Nextern _ARMABI clock_t clock(void);
Xextern __declspec(__nothrow) clock_t clock(void);
N   /* determines the processor time used.
N    * Returns: the implementation's best approximation to the processor time
N    *          used by the program since program invocation. The time in
N    *          seconds is the value returned divided by the value of the macro
N    *          CLK_TCK. The value (clock_t)-1 is returned if the processor time
N    *          used is not available.
N    */
Nextern _ARMABI double difftime(time_t /*time1*/, time_t /*time0*/);
Xextern __declspec(__nothrow) double difftime(time_t  , time_t  );
N   /*
N    * computes the difference between two calendar times: time1 - time0.
N    * Returns: the difference expressed in seconds as a double.
N    */
Nextern _ARMABI time_t mktime(struct tm * /*timeptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) time_t mktime(struct tm *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the broken-down time, expressed as local time, in the structure
N    * pointed to by timeptr into a calendar time value with the same encoding
N    * as that of the values returned by the time function. The original values
N    * of the tm_wday and tm_yday components of the structure are ignored, and
N    * the original values of the other components are not restricted to the
N    * ranges indicated above. On successful completion, the values of the
N    * tm_wday and tm_yday structure components are set appropriately, and the
N    * other components are set to represent the specified calendar time, but
N    * with their values forced to the ranges indicated above; the final value
N    * of tm_mday is not set until tm_mon and tm_year are determined.
N    * Returns: the specified calendar time encoded as a value of type time_t.
N    *          If the calendar time cannot be represented, the function returns
N    *          the value (time_t)-1.
N    */
Nextern _ARMABI time_t time(time_t * /*timer*/);
Xextern __declspec(__nothrow) time_t time(time_t *  );
N   /*
N    * determines the current calendar time. The encoding of the value is
N    * unspecified.
N    * Returns: the implementations best approximation to the current calendar
N    *          time. The value (time_t)-1 is returned if the calendar time is
N    *          not available. If timer is not a null pointer, the return value
N    *          is also assigned to the object it points to.
N    */
N
Nextern _ARMABI char *asctime(const struct tm * /*timeptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *asctime(const struct tm *  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI char *_asctime_r(const struct tm * /*timeptr*/,
Xextern __declspec(__nothrow) char *_asctime_r(const struct tm *  ,
N                                char * __restrict /*buf*/) __attribute__((__nonnull__(1,2)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *asctime_r(const struct tm * /*timeptr*/,
Xextern __declspec(__nothrow) char *asctime_r(const struct tm *  ,
N                               char * __restrict /*buf*/) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * converts the broken-down time in the structure pointed to by timeptr into
N    * a string in the form "Sun Sep 16 01:03:52 1973\n\0".
N    * Returns: a pointer to the string containing the date and time.
N    */
Nextern _ARMABI char *ctime(const time_t * /*timer*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *ctime(const time_t *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the calendar time pointed to by timer to local time in the form
N    * of a string. It is equivalent to asctime(localtime(timer));
N    * Returns: the pointer returned by the asctime function with that
N    *          broken-down time as argument.
N    */
Nextern _ARMABI struct tm *gmtime(const time_t * /*timer*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) struct tm *gmtime(const time_t *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the calendar time pointed to by timer into a broken-down time,
N    * expressed as Greenwich Mean Time (GMT).
N    * Returns: a pointer to that object or a null pointer if GMT not available.
N    */
Nextern _ARMABI struct tm *localtime(const time_t * /*timer*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) struct tm *localtime(const time_t *  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI struct tm *_localtime_r(const time_t * __restrict /*timer*/,
Xextern __declspec(__nothrow) struct tm *_localtime_r(const time_t * __restrict  ,
N                                       struct tm * __restrict /*result*/) __attribute__((__nonnull__(1,2)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI struct tm *localtime_r(const time_t * __restrict /*timer*/,
Xextern __declspec(__nothrow) struct tm *localtime_r(const time_t * __restrict  ,
N                                      struct tm * __restrict /*result*/) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * converts the calendar time pointed to by timer into a broken-down time,
N    * expressed a local time.
N    * Returns: a pointer to that object.
N    */
Nextern _ARMABI size_t strftime(char * __restrict /*s*/, size_t /*maxsize*/,
Xextern __declspec(__nothrow) size_t strftime(char * __restrict  , size_t  ,
N                       const char * __restrict /*format*/,
N                       const struct tm * __restrict /*timeptr*/) __attribute__((__nonnull__(1,3,4)));
N   /*
N    * places characters into the array pointed to by s as controlled by the
N    * string pointed to by format. The format string consists of zero or more
N    * directives and ordinary characters. A directive consists of a % character
N    * followed by a character that determines the directive's behaviour. All
N    * ordinary characters (including the terminating null character) are copied
N    * unchanged into the array. No more than maxsize characters are placed into
N    * the array. Each directive is replaced by appropriate characters  as
N    * described in the following list. The appropriate characters are
N    * determined by the LC_TIME category of the current locale and by the
N    * values contained in the structure pointed to by timeptr.
N    * %a is replaced by the locale's abbreviated weekday name.
N    * %A is replaced by the locale's full weekday name.
N    * %b is replaced by the locale's abbreviated month name.
N    * %B is replaced by the locale's full month name.
N    * %c is replaced by the locale's appropriate date and time representation.
N    * %d is replaced by the day of the month as a decimal number (01-31).
N    * %H is replaced by the hour (24-hour clock) as a decimal number (00-23).
N    * %I is replaced by the hour (12-hour clock) as a decimal number (01-12).
N    * %j is replaced by the day of the year as a decimal number (001-366).
N    * %m is replaced by the month as a decimal number (01-12).
N    * %M is replaced by the minute as a decimal number (00-59).
N    * %p is replaced by the locale's equivalent of either AM or PM designations
N    *       associated with a 12-hour clock.
N    * %S is replaced by the second as a decimal number (00-61).
N    * %U is replaced by the week number of the year (Sunday as the first day of
N    *       week 1) as a decimal number (00-53).
N    * %w is replaced by the weekday as a decimal number (0(Sunday) - 6).
N    * %W is replaced by the week number of the year (Monday as the first day of
N    *       week 1) as a decimal number (00-53).
N    * %x is replaced by the locale's appropriate date representation.
N    * %X is replaced by the locale's appropriate time representation.
N    * %y is replaced by the year without century as a decimal number (00-99).
N    * %Y is replaced by the year with century as a decimal number.
N    * %Z is replaced by the timezone name or abbreviation, or by no characters
N    *       if no time zone is determinable.
N    * %% is replaced by %.
N    * If a directive is not one of the above, the behaviour is undefined.
N    * Returns: If the total number of resulting characters including the
N    *          terminating null character is not more than maxsize, the
N    *          strftime function returns the number of characters placed into
N    *          the array pointed to by s not including the terminating null
N    *          character. otherwise, zero is returned and the contents of the
N    *          array are indeterminate.
N    */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __TIME_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __TIME_NO_EXPORTS
S      using ::std::clock_t;
S      using ::std::time_t;
S      using ::std::tm;
S      using ::std::tm;
S      using ::std::clock;
S      using ::std::difftime;
S      using ::std::mktime;
S      using ::std::time;
S      using ::std::asctime;
S      using ::std::_asctime_r;
S#ifndef __STRICT_ANSI__
S      using ::std::asctime_r;
S#endif
S      using ::std::ctime;
S      using ::std::gmtime;
S      using ::std::localtime;
S      using ::std::_localtime_r;
S#ifndef __STRICT_ANSI__
S      using ::std::localtime_r;
S#endif
S      using ::std::strftime;
S      using ::std::size_t;
S    #endif /* __TIME_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of time.h */
N
L 38 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "./systick/bsp_SysTick.h"
L 1 "..\..\Complex\./systick/bsp_SysTick.h" 1
N#ifndef __SYSTICK_H
N#define __SYSTICK_H
N
N#include "Include.h"
N
Nextern void SysTick_Init(void);
Nextern void delay_10us(__IO u32 nTime);
Xextern void delay_10us(volatile u32 nTime);
Nextern void delay_ms(__IO u32 mTime);
Xextern void delay_ms(volatile u32 mTime);
Nextern uint64_t GetSysTick_Timer(void);
Nextern uint32_t GetSysTick_delta_T(uint32_t T1,uint32_t T2);
Nextern void TimingDelay_Decrement(void);
N#endif /* __SYSTICK_H */
L 39 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "./key/bsp_exti.h"
L 1 "..\..\Complex\./key/bsp_exti.h" 1
N#ifndef __EXTI_H
N#define	__EXTI_H
N
N#include "stm32f4xx.h"
N#include "stdio.h"
N#include "Include.h"
N#include "stm32f4xx_syscfg.h"
N#include "stm32f4xx_exti.h"
N
N//引脚定义
N/*******************************************************/
N#define KEY1_INT_GPIO_PORT                GPIOA
N#define KEY1_INT_GPIO_CLK                 RCC_AHB1Periph_GPIOA
N#define KEY1_INT_GPIO_PIN                 GPIO_Pin_0
N#define KEY1_INT_EXTI_PORTSOURCE          EXTI_PortSourceGPIOA
N#define KEY1_INT_EXTI_PINSOURCE           EXTI_PinSource0
N#define KEY1_INT_EXTI_LINE                EXTI_Line0
N#define KEY1_INT_EXTI_IRQ                 EXTI0_IRQn
N#define KEY1_IRQHandler                   EXTI0_IRQHandler
N
N#define DOORLOCK_GPIO_PORT                GPIOA
N#define DOORLOCK_GPIO_CLK                 RCC_AHB1Periph_GPIOA
N#define DOORLOCK_GPIO_PIN                 GPIO_Pin_3
N
N#define KEY2_INT_GPIO_PORT                GPIOC
N#define KEY2_INT_GPIO_CLK                 RCC_AHB1Periph_GPIOC
N#define KEY2_INT_GPIO_PIN                 GPIO_Pin_2
N#define KEY2_INT_EXTI_PORTSOURCE          EXTI_PortSourceGPIOC
N#define KEY2_INT_EXTI_PINSOURCE           EXTI_PinSource2
N#define KEY2_INT_EXTI_LINE                EXTI_Line2
N#define KEY2_INT_EXTI_IRQ                 EXTI2_IRQn
N
N#define KEY2_IRQHandler                   EXTI2_IRQHandler
N
N
N
N#define KEY3_INT_GPIO_PORT                GPIOG
N#define KEY3_INT_GPIO_CLK                 RCC_AHB1Periph_GPIOG
N#define KEY3_INT_GPIO_PIN                 GPIO_Pin_15
N#define KEY3_INT_EXTI_PORTSOURCE          EXTI_PortSourceGPIOG
N#define KEY3_INT_EXTI_PINSOURCE           EXTI_PinSource15
N#define KEY3_INT_EXTI_LINE                EXTI_Line15
N#define KEY3_INT_EXTI_IRQ                 EXTI15_10_IRQn
N
N#define KEY3_IRQHandler                   EXTI15_10_IRQHandler
N
N
N
N#define KEY4_INT_GPIO_PORT                GPIOE
N#define KEY4_INT_GPIO_CLK                 RCC_AHB1Periph_GPIOE
N#define KEY4_INT_GPIO_PIN                 GPIO_Pin_3
N/*******************************************************/
N
N
Nextern void Key_Config(void);
N
N
N#endif /* __EXTI_H */
L 40 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "./hym8563/hym8563.h"
N#include "./display/display.h"
L 1 "..\..\Complex\./display/display.h" 1
N#ifndef _DISPLAY_H
N#define _DISPLAY_H
N
N
N#include "stm32f4xx.h"
N#include "./hym8563/hym8563.h"
N
Nextern unsigned long now_time;
N
N
Nvoid Write_Command(unsigned char com);
N
Nuint8_t Write_Data(uint8_t data);
Nvoid LCD_Init(void);
Nvoid display(uint8_t *buf,int n);
Nvoid display_time(void);
N
N#endif
L 42 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "./sm3/SM3.h"
L 1 "..\..\Complex\./sm3/SM3.h" 1
N#ifndef SM3_H
N#define SM3_H
N
N
N#include "stm32f4xx.h"
N
N
Nextern	void sm3(unsigned char * input_m, unsigned int input_m_len, unsigned char * output_m);
Nextern	int get_sm3_pass(unsigned long now_time,unsigned  char *community_id,unsigned char *build_num,unsigned char *cell_num); 
N
N#endif
L 43 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "./beep/bsp_beep.h" 
L 1 "..\..\Complex\./beep/bsp_beep.h" 1
N#ifndef __BEEP_H_
N#define	__BEEP_H_
N
N#include "stm32f4xx.h"
N
N
N
N/* 定义蜂鸣器连接的GPIO端口, 用户只需要修改下面的代码即可改变控制的蜂鸣器引脚 */
N#define BEEP_GPIO_PORT    	GPIOG			              /* GPIO端口 */
N#define BEEP_GPIO_CLK 	    RCC_AHB1Periph_GPIOG		/* GPIO端口时钟 */
N#define BEEP_GPIO_PIN		  	GPIO_Pin_7			        /* 连接到蜂鸣器的GPIO */
N
N#define LOCK_GPIO_PORT    	GPIOB			              /* GPIO端口 */
N#define LOCK_GPIO_CLK 	    RCC_AHB1Periph_GPIOG		/* GPIO端口时钟 */
N#define LOCK_GPIO_PIN		  	GPIO_Pin_0			        /* 连接到蜂鸣器的GPIO */
N
N					
N/* 直接操作寄存器的方法控制IO */
N#define	digitalHi(p,i)			{p->BSRRL=i;}			  //设置为高电平		
N#define digitalLo(p,i)			{p->BSRRH=i;}				//输出低电平
N#define digitalToggle(p,i)	{p->ODR ^=i;}			//输出反转状态
N
N
N/* 定义控制IO的宏 */
N#define BEEP_TOGGLE		digitalToggle(BEEP_GPIO_PORT,BEEP_GPIO_PIN)
N#define BEEP_OFF				digitalLo(BEEP_GPIO_PORT,BEEP_GPIO_PIN)
N#define BEEP_ON				digitalHi(BEEP_GPIO_PORT,BEEP_GPIO_PIN)
N
N/* 定义控制IO的宏 */
N#define LOCK_TOGGLE		digitalToggle(LOCK_GPIO_PORT,LOCK_GPIO_PIN)
N#define LOCK_OFF		digitalLo(LOCK_GPIO_PORT,LOCK_GPIO_PIN)
N#define LOCK_ON			digitalHi(LOCK_GPIO_PORT,LOCK_GPIO_PIN)
N
Nvoid BEEP_GPIO_Config(void);
N#endif /* __BEEP_H_ */
L 44 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "./wm8978/bsp_wm8978.h"
L 1 "..\..\Complex\./wm8978/bsp_wm8978.h" 1
N#ifndef __WM8978_H__
N#define	__WM8978_H__
N
N#include "stm32f4xx.h"
N#include "./i2c/bsp_i2c_gpio.h"
N/*---------------------------------------------------------------------------------------------*/
N/*------------------------   I2C控制WM8978配置部分  -------------------------------------------*/
N/* WM8978 音频输入通道控制选项, 可以选择多路，比如 MIC_LEFT_ON | LINE_ON */
Ntypedef enum
N{
N	IN_PATH_OFF		= 0x00,	/* 无输入 */
N	MIC_LEFT_ON 	= 0x01,	/* LIN,LIP脚，MIC左声道（接板载咪头）  */
N	MIC_RIGHT_ON	= 0x02,	/* RIN,RIP脚，MIC右声道（接板载咪头）  */
N	LINE_ON			  = 0x04, /* L2,R2 立体声输入(接板载耳机插座) */
N	AUX_ON			  = 0x08,	/* AUXL,AUXR 立体声输入（开发板没用到） */
N	DAC_ON			  = 0x10,	/* I2S数据DAC (CPU产生音频信号) */
N	ADC_ON			  = 0x20	/* 输入的音频馈入WM8978内部ADC （I2S录音) */
N}IN_PATH_E;
N
N/* WM8978 音频输出通道控制选项, 可以选择多路 */
Ntypedef enum
N{
N	OUT_PATH_OFF	= 0x00,	/* 无输出 */
N	EAR_LEFT_ON 	= 0x01,	/* LOUT1 耳机左声道(接板载耳机插座) */
N	EAR_RIGHT_ON	= 0x02,	/* ROUT1 耳机右声道(接板载耳机插座) */
N	SPK_ON			  = 0x04,	/* LOUT2和ROUT2反相输出单声道（开发板没用到）*/
N	OUT3_4_ON		  = 0x08,	/* OUT3 和 OUT4 输出单声道音频（开发板没用到）*/
N}OUT_PATH_E;
N
N/* 定义最大音量 */
N#define VOLUME_MAX		                      63		/* 最大音量 */
N#define VOLUME_STEP		                       1		/* 音量调节步长 */
N
N/* 定义最大MIC增益 */
N#define GAIN_MAX		                        63		/* 最大增益 */
N#define GAIN_STEP		                         1		/* 增益步长 */
N
N/* STM32 I2C 快速模式 */
N#define WM8978_I2C_Speed                    400000
N/* WM8978 I2C从机地址 */
N#define WM8978_SLAVE_ADDRESS                0x34	
N
N/*I2C接口*/
N#define WM8978_I2C                          I2C1
N#define WM8978_I2C_CLK                      RCC_APB1Periph_I2C1
N
N#define WM8978_I2C_SCL_PIN                  GPIO_Pin_8                  
N#define WM8978_I2C_SCL_GPIO_PORT            GPIOB                       
N#define WM8978_I2C_SCL_GPIO_CLK             RCC_AHB1Periph_GPIOB
N#define WM8978_I2C_SCL_SOURCE               GPIO_PinSource8
N#define WM8978_I2C_SCL_AF                   GPIO_AF_I2C1
N
N#define WM8978_I2C_SDA_PIN                  GPIO_Pin_9                  
N#define WM8978_I2C_SDA_GPIO_PORT            GPIOB                       
N#define WM8978_I2C_SDA_GPIO_CLK             RCC_AHB1Periph_GPIOB
N#define WM8978_I2C_SDA_SOURCE               GPIO_PinSource9
N#define WM8978_I2C_SDA_AF                   GPIO_AF_I2C1
N
N/*等待超时时间*/
N#define WM8978_I2C_FLAG_TIMEOUT             ((uint32_t)0x4000)
N#define WM8978_I2C_LONG_TIMEOUT             ((uint32_t)(10 * WM8978_I2C_FLAG_TIMEOUT))
N
N/* 供外部引用的函数声明 */
Nuint8_t wm8978_Init(void);
Nuint8_t wm8978_Reset(void);
Nvoid wm8978_CfgAudioIF(uint16_t _usStandard, uint8_t _ucWordLen);
Nvoid wm8978_OutMute(uint8_t _ucMute);
Nvoid wm8978_PowerDown(void);
Nvoid wm8978_CfgAudioPath(uint16_t _InPath, uint16_t _OutPath);
Nvoid wm8978_SetMicGain(uint8_t _ucGain);
Nvoid wm8978_SetLineGain(uint8_t _ucGain);
Nvoid wm8978_SetOUT2Volume(uint8_t _ucVolume);
Nvoid wm8978_SetOUT1Volume(uint8_t _ucVolume);
Nuint8_t wm8978_ReadOUT1Volume(void);
Nuint8_t wm8978_ReadOUT2Volume(void);
Nvoid wm8978_NotchFilter(uint16_t _NFA0, uint16_t _NFA1);
N																					
N/*---------------------------------------------------------------------------------------------*/
N/*------------------------   I2S控制数据传输部分  ---------------------------------------------*/																					
N/**
N	* I2S总线传输音频数据口线
N	* WM8978_LRC    -> PB12/I2S2_WS
N	* WM8978_BCLK   -> PB14/I2S2_CK
N	* WM8978_ADCDAT -> PB14/I2S2ext_SD
N	* WM8978_DACDAT -> PB15/I2S2_SD
N	* WM8978_MCLK   -> PC6/I2S2_MCK
N	*/
N#define WM8978_CLK                     RCC_APB1Periph_SPI2
N#define WM8978_I2Sx_SPI                SPI2
N#define WM8978_I2Sx_ext                I2S2ext
N
N#define WM8978_LRC_GPIO_CLK            RCC_AHB1Periph_GPIOB
N#define WM8978_LRC_PORT            	   GPIOB
N#define WM8978_LRC_PIN             	   GPIO_Pin_12
N#define WM8978_LRC_AF                  GPIO_AF_SPI2
N#define WM8978_LRC_SOURCE              GPIO_PinSource12
N
N#define WM8978_BCLK_GPIO_CLK           RCC_AHB1Periph_GPIOB
N#define WM8978_BCLK_PORT            	 GPIOB
N#define WM8978_BCLK_PIN             	 GPIO_Pin_13
N#define WM8978_BCLK_AF                 GPIO_AF_SPI2
N#define WM8978_BCLK_SOURCE             GPIO_PinSource13
N
N#define WM8978_ADCDAT_GPIO_CLK         RCC_AHB1Periph_GPIOB
N#define WM8978_ADCDAT_PORT             GPIOB
N#define WM8978_ADCDAT_PIN              GPIO_Pin_14
N#define WM8978_ADCDAT_AF               GPIO_AF_SPI3    
N#define WM8978_ADCDAT_SOURCE           GPIO_PinSource14
N
N#define WM8978_DACDAT_GPIO_CLK         RCC_AHB1Periph_GPIOB
N#define WM8978_DACDAT_PORT             GPIOB
N#define WM8978_DACDAT_PIN              GPIO_Pin_15
N#define WM8978_DACDAT_AF               GPIO_AF_SPI2
N#define WM8978_DACDAT_SOURCE           GPIO_PinSource15
N
N#define WM8978_MCLK_GPIO_CLK           RCC_AHB1Periph_GPIOC
N#define WM8978_MCLK_PORT            	 GPIOC
N#define WM8978_MCLK_PIN             	 GPIO_Pin_6
N#define WM8978_MCLK_AF                 GPIO_AF_SPI2
N#define WM8978_MCLK_SOURCE             GPIO_PinSource6
N
N#define I2Sx_DMA                       DMA1
N#define I2Sx_DMA_CLK                   RCC_AHB1Periph_DMA1
N#define I2Sx_TX_DMA_CHANNEL            DMA_Channel_0
N#define I2Sx_TX_DMA_STREAM             DMA1_Stream4
N#define I2Sx_TX_DMA_IT_TCIF            DMA_IT_TCIF4
N#define I2Sx_TX_DMA_STREAM_IRQn        DMA1_Stream4_IRQn 
N#define I2Sx_TX_DMA_STREAM_IRQFUN			 DMA1_Stream4_IRQHandler
N
N#define I2Sxext_RX_DMA_CHANNEL         DMA_Channel_3
N#define I2Sxext_RX_DMA_STREAM          DMA1_Stream3
N#define I2Sxext_RX_DMA_IT_TCIF         DMA_IT_TCIF3
N#define I2Sxext_RX_DMA_STREAM_IRQn     DMA1_Stream3_IRQn 
N#define I2Sxext_RX_DMA_STREAM_IRQFUN	 DMA1_Stream3_IRQHandler
N
Nextern void (*I2S_DMA_TX_Callback)(void);		//I2S DMA TX回调函数指针  
Nextern void (*I2S_DMA_RX_Callback)(void);	  //I2S DMA RX回调函数
N
Nvoid I2S_GPIO_Config(void);
Nvoid I2S_Stop(void);
Nvoid I2Sx_Mode_Config(const uint16_t _usStandard, const uint16_t _usWordLen,const uint32_t _usAudioFreq);
Nvoid I2Sx_TX_DMA_Init(const uint16_t *buffer0,const uint16_t *buffer1,const uint32_t num,int n);
Nvoid I2S_Play_Start(void);
Nvoid I2S_Play_Stop(void);
N
Nvoid I2Sxext_Mode_Config(const uint16_t _usStandard, const uint16_t _usWordLen,const uint32_t _usAudioFreq);
Nvoid I2Sxext_RX_DMA_Init(const uint16_t *buffer0,const uint16_t *buffer1,const uint32_t num);
Nvoid I2Sxext_Recorde_Start(void);
Nvoid I2Sxext_Recorde_Stop(void);
N#endif /* __WM8978_H__ */
L 45 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "./FATFS/ff.h" 
L 1 "..\..\Complex\./FATFS/ff.h" 1
N/*---------------------------------------------------------------------------/
N/  FatFs - FAT file system module include file  R0.10c    (C)ChaN, 2014
N/----------------------------------------------------------------------------/
N/ FatFs module is a generic FAT file system module for small embedded systems.
N/ This is a free software that opened for education, research and commercial
N/ developments under license policy of following terms.
N/
N/  Copyright (C) 2014, ChaN, all right reserved.
N/
N/ * The FatFs module is a free software and there is NO WARRANTY.
N/ * No restriction on use. You can use, modify and redistribute it for
N/   personal, non-profit or commercial product UNDER YOUR RESPONSIBILITY.
N/ * Redistributions of source code must retain the above copyright notice.
N/
N/----------------------------------------------------------------------------*/
N
N#ifndef _FATFS
N#define _FATFS	80376	/* Revision ID */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "integer.h"	/* Basic integer types */
L 1 "..\..\Complex\./FATFS/integer.h" 1
N/*-------------------------------------------*/
N/* Integer type definitions for FatFs module */
N/*-------------------------------------------*/
N
N#ifndef _FF_INTEGER
N#define _FF_INTEGER
N
N#ifdef _WIN32	/* FatFs development platform */
S
S#include <windows.h>
S#include <tchar.h>
S
N#else			/* Embedded platform */
N
N/* This type MUST be 8 bit */
Ntypedef unsigned char	BYTE;
N
N/* These types MUST be 16 bit */
Ntypedef short			SHORT;
Ntypedef unsigned short	WORD;
Ntypedef unsigned short	WCHAR;
N
N/* These types MUST be 16 bit or 32 bit */
Ntypedef int				INT;
Ntypedef unsigned int	UINT;
N
N/* These types MUST be 32 bit */
Ntypedef long			LONG;
Ntypedef unsigned long	DWORD;
N
N#endif
N
N#endif
L 25 "..\..\Complex\./FATFS/ff.h" 2
N#include "ffconf.h"		/* FatFs configuration options */
L 1 "..\..\Complex\./FATFS/ffconf.h" 1
N/*---------------------------------------------------------------------------/
N/  FatFs - FAT file system module configuration file  R0.10c (C)ChaN, 2014
N/---------------------------------------------------------------------------*/
N
N#ifndef _FF_FFCONF
N#define _FF_FFCONF
N
N#define _FFCONF 80376	/* Revision ID */
N
N/*---------------------------------------------------------------------------/
N/ Functions and Buffer Configurations
N/---------------------------------------------------------------------------*/
N
N#define	_FS_TINY		0
N/* This option switches tiny buffer configuration. (0:Normal or 1:Tiny)
N/  At the tiny configuration, size of the file object (FIL) is reduced _MAX_SS
N/  bytes. Instead of private sector buffer eliminated from the file object,
N/  common sector buffer in the file system object (FATFS) is used for the file
N/  data transfer. */
N
N
N#define _FS_READONLY	0
N/* This option switches read-only configuration. (0:Read/Write or 1:Read-only)
N/  Read-only configuration removes basic writing API functions, f_write(),
N/  f_sync(), f_unlink(), f_mkdir(), f_chmod(), f_rename(), f_truncate(),
N/  f_getfree() and optional writing functions as well. */
N
N
N#define _FS_MINIMIZE	0
N/* This option defines minimization level to remove some API functions.
N/
N/   0: All basic functions are enabled.
N/   1: f_stat(), f_getfree(), f_unlink(), f_mkdir(), f_chmod(), f_utime(),
N/      f_truncate() and f_rename() function are removed.
N/   2: f_opendir(), f_readdir() and f_closedir() are removed in addition to 1.
N/   3: f_lseek() function is removed in addition to 2. */
N
N
N#define	_USE_STRFUNC	2
N/* This option switches string functions, f_gets(), f_putc(), f_puts() and
N/  f_printf().
N/
N/  0: Disable string functions.
N/  1: Enable without LF-CRLF conversion.
N/  2: Enable with LF-CRLF conversion. */
N
N
N#define	_USE_MKFS		1
N/* This option switches f_mkfs() function. (0:Disable or 1:Enable)
N/  To enable it, also _FS_READONLY need to be set to 0. */
N
N
N#define	_USE_FASTSEEK	0
N/* This option switches fast seek feature. (0:Disable or 1:Enable) */
N
N
N#define _USE_LABEL		1
N/* This option switches volume label functions, f_getlabel() and f_setlabel().
N/  (0:Disable or 1:Enable) */
N
N
N#define	_USE_FORWARD	0
N/* This option switches f_forward() function. (0:Disable or 1:Enable) */
N/* To enable it, also _FS_TINY need to be set to 1. */
N
N
N/*---------------------------------------------------------------------------/
N/ Locale and Namespace Configurations
N/---------------------------------------------------------------------------*/
N
N#define _CODE_PAGE	936
N/* This option specifies the OEM code page to be used on the target system.
N/  Incorrect setting of the code page can cause a file open failure.
N/
N/   932  - Japanese Shift_JIS (DBCS, OEM, Windows)
N/   936  - Simplified Chinese GBK (DBCS, OEM, Windows)
N/   949  - Korean (DBCS, OEM, Windows)
N/   950  - Traditional Chinese Big5 (DBCS, OEM, Windows)
N/   1250 - Central Europe (Windows)
N/   1251 - Cyrillic (Windows)
N/   1252 - Latin 1 (Windows)
N/   1253 - Greek (Windows)
N/   1254 - Turkish (Windows)
N/   1255 - Hebrew (Windows)
N/   1256 - Arabic (Windows)
N/   1257 - Baltic (Windows)
N/   1258 - Vietnam (OEM, Windows)
N/   437  - U.S. (OEM)
N/   720  - Arabic (OEM)
N/   737  - Greek (OEM)
N/   775  - Baltic (OEM)
N/   850  - Multilingual Latin 1 (OEM)
N/   858  - Multilingual Latin 1 + Euro (OEM)
N/   852  - Latin 2 (OEM)
N/   855  - Cyrillic (OEM)
N/   866  - Russian (OEM)
N/   857  - Turkish (OEM)
N/   862  - Hebrew (OEM)
N/   874  - Thai (OEM, Windows)
N/   1    - ASCII (No extended character. Valid for only non-LFN configuration.) */
N
N
N#define	_USE_LFN	2
N#define	_MAX_LFN	255
N/* The _USE_LFN option switches the LFN feature.
N/
N/   0: Disable LFN feature. _MAX_LFN has no effect.
N/   1: Enable LFN with static working buffer on the BSS. Always NOT thread-safe.
N/   2: Enable LFN with dynamic working buffer on the STACK.
N/   3: Enable LFN with dynamic working buffer on the HEAP.
N/
N/  When enable the LFN feature, Unicode handling functions (option/unicode.c) must
N/  be added to the project. The LFN working buffer occupies (_MAX_LFN + 1) * 2 bytes.
N/  When use stack for the working buffer, take care on stack overflow. When use heap
N/  memory for the working buffer, memory management functions, ff_memalloc() and
N/  ff_memfree(), must be added to the project. */
N
N
N#define	_LFN_UNICODE	0
N/* This option switches character encoding on the API. (0:ANSI/OEM or 1:Unicode)
N/  To use Unicode string for the path name, enable LFN feature and set _LFN_UNICODE
N/  to 1. This option also affects behavior of string I/O functions. */
N
N
N#define _STRF_ENCODE	3
N/* When _LFN_UNICODE is 1, this option selects the character encoding on the file to
N/  be read/written via string I/O functions, f_gets(), f_putc(), f_puts and f_printf().
N/
N/  0: ANSI/OEM
N/  1: UTF-16LE
N/  2: UTF-16BE
N/  3: UTF-8
N/
N/  When _LFN_UNICODE is 0, this option has no effect. */
N
N
N#define _FS_RPATH	1
N/* This option configures relative path feature.
N/
N/   0: Disable relative path feature and remove related functions.
N/   1: Enable relative path feature. f_chdir() and f_chdrive() are available.
N/   2: f_getcwd() function is available in addition to 1.
N/
N/  Note that directory items read via f_readdir() are affected by this option. */
N
N
N/*---------------------------------------------------------------------------/
N/ Drive/Volume Configurations
N/---------------------------------------------------------------------------*/
N
N#define _VOLUMES	2
N/* Number of volumes (logical drives) to be used. */
N
N
N#define _STR_VOLUME_ID	0
N#define _VOLUME_STRS	"RAM","NAND","CF","SD1","SD2","USB1","USB2","USB3"
N/* _STR_VOLUME_ID option switches string volume ID feature.
N/  When _STR_VOLUME_ID is set to 1, also pre-defined strings can be used as drive
N/  number in the path name. _VOLUME_STRS defines the drive ID strings for each
N/  logical drives. Number of items must be equal to _VOLUMES. Valid characters for
N/  the drive ID strings are: A-Z and 0-9. */
N
N
N#define	_MULTI_PARTITION	0
N/* This option switches multi-partition feature. By default (0), each logical drive
N/  number is bound to the same physical drive number and only an FAT volume found on
N/  the physical drive will be mounted. When multi-partition feature is enabled (1),
N/  each logical drive number is bound to arbitrary physical drive and partition
N/  listed in the VolToPart[]. Also f_fdisk() funciton will be enabled. */
N
N
N#define	_MIN_SS		512
N#define	_MAX_SS		4096
N/* These options configure the range of sector size to be supported. (512, 1024,
N/  2048 or 4096) Always set both 512 for most systems, all type of memory cards and
N/  harddisk. But a larger value may be required for on-board flash memory and some
N/  type of optical media. When _MAX_SS is larger than _MIN_SS, FatFs is configured
N/  to variable sector size and GET_SECTOR_SIZE command must be implemented to the
N/  disk_ioctl() function. */
N
N
N#define	_USE_TRIM	0
N/* This option switches ATA-TRIM feature. (0:Disable or 1:Enable)
N/  To enable Trim feature, also CTRL_TRIM command should be implemented to the
N/  disk_ioctl() function. */
N
N
N#define _FS_NOFSINFO	0
N/* If you need to know correct free space on the FAT32 volume, set bit 0 of this
N/  option, and f_getfree() function at first time after volume mount will force
N/  a full FAT scan. Bit 1 controls the use of last allocated cluster number.
N/
N/  bit0=0: Use free cluster count in the FSINFO if available.
N/  bit0=1: Do not trust free cluster count in the FSINFO.
N/  bit1=0: Use last allocated cluster number in the FSINFO if available.
N/  bit1=1: Do not trust last allocated cluster number in the FSINFO.
N*/
N
N
N
N/*---------------------------------------------------------------------------/
N/ System Configurations
N/---------------------------------------------------------------------------*/
N
N#define _FS_NORTC	0
N#define _NORTC_MON	11
N#define _NORTC_MDAY	9
N#define _NORTC_YEAR	2014
N/* The _FS_NORTC option switches timestamp feature. If the system does not have
N/  an RTC function or valid timestamp is not needed, set _FS_NORTC to 1 to disable
N/  the timestamp feature. All objects modified by FatFs will have a fixed timestamp
N/  defined by _NORTC_MON, _NORTC_MDAY and _NORTC_YEAR.
N/  When timestamp feature is enabled (_FS_NORTC	== 0), get_fattime() function need
N/  to be added to the project to read current time form RTC. _NORTC_MON,
N/  _NORTC_MDAY and _NORTC_YEAR have no effect. 
N/  These options have no effect at read-only configuration (_FS_READONLY == 1). */
N
N
N#define	_FS_LOCK	0
N/* The _FS_LOCK option switches file lock feature to control duplicated file open
N/  and illegal operation to open objects. This option must be 0 when _FS_READONLY
N/  is 1.
N/
N/  0:  Disable file lock feature. To avoid volume corruption, application program
N/      should avoid illegal open, remove and rename to the open objects.
N/  >0: Enable file lock feature. The value defines how many files/sub-directories
N/      can be opened simultaneously under file lock control. Note that the file
N/      lock feature is independent of re-entrancy. */
N
N
N#define _FS_REENTRANT	0
N#define _FS_TIMEOUT		1000
N#define	_SYNC_t			HANDLE
N/* The _FS_REENTRANT option switches the re-entrancy (thread safe) of the FatFs
N/  module itself. Note that regardless of this option, file access to different
N/  volume is always re-entrant and volume control functions, f_mount(), f_mkfs()
N/  and f_fdisk() function, are always not re-entrant. Only file/directory access
N/  to the same volume is under control of this feature.
N/
N/   0: Disable re-entrancy. _FS_TIMEOUT and _SYNC_t have no effect.
N/   1: Enable re-entrancy. Also user provided synchronization handlers,
N/      ff_req_grant(), ff_rel_grant(), ff_del_syncobj() and ff_cre_syncobj()
N/      function, must be added to the project. Samples are available in
N/      option/syscall.c.
N/
N/  The _FS_TIMEOUT defines timeout period in unit of time tick.
N/  The _SYNC_t defines O/S dependent sync object type. e.g. HANDLE, ID, OS_EVENT*,
N/  SemaphoreHandle_t and etc.. */
N
N
N#define _WORD_ACCESS	0
N/* The _WORD_ACCESS option is an only platform dependent option. It defines
N/  which access method is used to the word data on the FAT volume.
N/
N/   0: Byte-by-byte access. Always compatible with all platforms.
N/   1: Word access. Do not choose this unless under both the following conditions.
N/
N/  * Address misaligned memory access is always allowed to ALL instructions.
N/  * Byte order on the memory is little-endian.
N/
N/  If it is the case, _WORD_ACCESS can also be set to 1 to reduce code size.
N/  Following table shows allowable settings of some processor types.
N/
N/   ARM7TDMI    0           ColdFire    0           V850E       0
N/   Cortex-M3   0           Z80         0/1         V850ES      0/1
N/   Cortex-M0   0           x86         0/1         TLCS-870    0/1
N/   AVR         0/1         RX600(LE)   0/1         TLCS-900    0/1
N/   AVR32       0           RL78        0           R32C        0
N/   PIC18       0/1         SH-2        0           M16C        0/1
N/   PIC24       0           H8S         0           MSP430      0
N/   PIC32       0           H8/300H     0           8051        0/1
N*/
N#endif
L 26 "..\..\Complex\./FATFS/ff.h" 2
N#if _FATFS != _FFCONF
X#if 80376 != 80376
S#error Wrong configuration file (ffconf.h).
N#endif
N
N
N
N/* Definitions of volume management */
N
N#if _MULTI_PARTITION		/* Multiple partition configuration */
X#if 0		 
Stypedef struct {
S	BYTE pd;	/* Physical drive number */
S	BYTE pt;	/* Partition: 0:Auto detect, 1-4:Forced partition) */
S} PARTITION;
Sextern PARTITION VolToPart[];	/* Volume - Partition resolution table */
S#define LD2PD(vol) (VolToPart[vol].pd)	/* Get physical drive number */
S#define LD2PT(vol) (VolToPart[vol].pt)	/* Get partition index */
S
N#else							/* Single partition configuration */
N#define LD2PD(vol) (BYTE)(vol)	/* Each logical drive is bound to the same physical drive number */
N#define LD2PT(vol) 0			/* Find first valid partition or in SFD */
N
N#endif
N
N
N
N/* Type of path name strings on FatFs API */
N
N#if _LFN_UNICODE			/* Unicode string */
X#if 0			 
S#if !_USE_LFN
S#error _LFN_UNICODE must be 0 at non-LFN cfg.
S#endif
S#ifndef _INC_TCHAR
Stypedef WCHAR TCHAR;
S#define _T(x) L ## x
S#define _TEXT(x) L ## x
S#endif
S
N#else						/* ANSI/OEM string */
N#ifndef _INC_TCHAR
Ntypedef char TCHAR;
N#define _T(x) x
N#define _TEXT(x) x
N#endif
N
N#endif
N
N
N
N/* File system object structure (FATFS) */
N
Ntypedef struct {
N	BYTE	fs_type;		/* FAT sub-type (0:Not mounted) */
N	BYTE	drv;			/* Physical drive number */
N	BYTE	csize;			/* Sectors per cluster (1,2,4...128) */
N	BYTE	n_fats;			/* Number of FAT copies (1 or 2) */
N	BYTE	wflag;			/* win[] flag (b0:dirty) */
N	BYTE	fsi_flag;		/* FSINFO flags (b7:disabled, b0:dirty) */
N	WORD	id;				/* File system mount ID */
N	WORD	n_rootdir;		/* Number of root directory entries (FAT12/16) */
N#if _MAX_SS != _MIN_SS
X#if 4096 != 512
N	WORD	ssize;			/* Bytes per sector (512, 1024, 2048 or 4096) */
N#endif
N#if _FS_REENTRANT
X#if 0
S	_SYNC_t	sobj;			/* Identifier of sync object */
N#endif
N#if !_FS_READONLY
X#if !0
N	DWORD	last_clust;		/* Last allocated cluster */
N	DWORD	free_clust;		/* Number of free clusters */
N#endif
N#if _FS_RPATH
X#if 1
N	DWORD	cdir;			/* Current directory start cluster (0:root) */
N#endif
N	DWORD	n_fatent;		/* Number of FAT entries, = number of clusters + 2 */
N	DWORD	fsize;			/* Sectors per FAT */
N	DWORD	volbase;		/* Volume start sector */
N	DWORD	fatbase;		/* FAT start sector */
N	DWORD	dirbase;		/* Root directory start sector (FAT32:Cluster#) */
N	DWORD	database;		/* Data start sector */
N	DWORD	winsect;		/* Current sector appearing in the win[] */
N	BYTE	win[_MAX_SS];	/* Disk access window for Directory, FAT (and file data at tiny cfg) */
X	BYTE	win[4096];	 
N} FATFS;
N
N
N
N/* File object structure (FIL) */
N
Ntypedef struct {
N	FATFS*	fs;				/* Pointer to the related file system object (**do not change order**) */
N	WORD	id;				/* Owner file system mount ID (**do not change order**) */
N	BYTE	flag;			/* Status flags */
N	BYTE	err;			/* Abort flag (error code) */
N	DWORD	fptr;			/* File read/write pointer (Zeroed on file open) */
N	DWORD	fsize;			/* File size */
N	DWORD	sclust;			/* File start cluster (0:no cluster chain, always 0 when fsize is 0) */
N	DWORD	clust;			/* Current cluster of fpter (not valid when fprt is 0) */
N	DWORD	dsect;			/* Sector number appearing in buf[] (0:invalid) */
N#if !_FS_READONLY
X#if !0
N	DWORD	dir_sect;		/* Sector number containing the directory entry */
N	BYTE*	dir_ptr;		/* Pointer to the directory entry in the win[] */
N#endif
N#if _USE_FASTSEEK
X#if 0
S	DWORD*	cltbl;			/* Pointer to the cluster link map table (Nulled on file open) */
N#endif
N#if _FS_LOCK
X#if 0
S	UINT	lockid;			/* File lock ID origin from 1 (index of file semaphore table Files[]) */
N#endif
N#if !_FS_TINY
X#if !0
N	BYTE	buf[_MAX_SS];	/* File private data read/write window */
X	BYTE	buf[4096];	 
N#endif
N} FIL;
N
N
N
N/* Directory object structure (DIR) */
N
Ntypedef struct {
N	FATFS*	fs;				/* Pointer to the owner file system object (**do not change order**) */
N	WORD	id;				/* Owner file system mount ID (**do not change order**) */
N	WORD	index;			/* Current read/write index number */
N	DWORD	sclust;			/* Table start cluster (0:Root dir) */
N	DWORD	clust;			/* Current cluster */
N	DWORD	sect;			/* Current sector */
N	BYTE*	dir;			/* Pointer to the current SFN entry in the win[] */
N	BYTE*	fn;				/* Pointer to the SFN (in/out) {file[8],ext[3],status[1]} */
N#if _FS_LOCK
X#if 0
S	UINT	lockid;			/* File lock ID (index of file semaphore table Files[]) */
N#endif
N#if _USE_LFN
X#if 2
N	WCHAR*	lfn;			/* Pointer to the LFN working buffer */
N	WORD	lfn_idx;		/* Last matched LFN index number (0xFFFF:No LFN) */
N#endif
N} DIR;
N
N
N
N/* File status structure (FILINFO) */
N
Ntypedef struct {
N	DWORD	fsize;			/* File size */
N	WORD	fdate;			/* Last modified date */
N	WORD	ftime;			/* Last modified time */
N	BYTE	fattrib;		/* Attribute */
N	TCHAR	fname[13];		/* Short file name (8.3 format) */
N#if _USE_LFN
X#if 2
N	TCHAR*	lfname;			/* Pointer to the LFN buffer */
N	UINT 	lfsize;			/* Size of LFN buffer in TCHAR */
N#endif
N} FILINFO;
N
N
N
N/* File function return code (FRESULT) */
N
Ntypedef enum {
N	FR_OK = 0,				/* (0) Succeeded */
N	FR_DISK_ERR,			/* (1) A hard error occurred in the low level disk I/O layer */
N	FR_INT_ERR,				/* (2) Assertion failed */
N	FR_NOT_READY,			/* (3) The physical drive cannot work */
N	FR_NO_FILE,				/* (4) Could not find the file */
N	FR_NO_PATH,				/* (5) Could not find the path */
N	FR_INVALID_NAME,		/* (6) The path name format is invalid */
N	FR_DENIED,				/* (7) Access denied due to prohibited access or directory full */
N	FR_EXIST,				/* (8) Access denied due to prohibited access */
N	FR_INVALID_OBJECT,		/* (9) The file/directory object is invalid */
N	FR_WRITE_PROTECTED,		/* (10) The physical drive is write protected */
N	FR_INVALID_DRIVE,		/* (11) The logical drive number is invalid */
N	FR_NOT_ENABLED,			/* (12) The volume has no work area */
N	FR_NO_FILESYSTEM,		/* (13) There is no valid FAT volume */
N	FR_MKFS_ABORTED,		/* (14) The f_mkfs() aborted due to any parameter error */
N	FR_TIMEOUT,				/* (15) Could not get a grant to access the volume within defined period */
N	FR_LOCKED,				/* (16) The operation is rejected according to the file sharing policy */
N	FR_NOT_ENOUGH_CORE,		/* (17) LFN working buffer could not be allocated */
N	FR_TOO_MANY_OPEN_FILES,	/* (18) Number of open files > _FS_SHARE */
N	FR_INVALID_PARAMETER	/* (19) Given parameter is invalid */
N} FRESULT;
N
N
N
N/*--------------------------------------------------------------*/
N/* FatFs module application interface                           */
N
NFRESULT f_open (FIL* fp, const TCHAR* path, BYTE mode);				/* Open or create a file */
NFRESULT f_close (FIL* fp);											/* Close an open file object */
NFRESULT f_read (FIL* fp, void* buff, UINT btr, UINT* br);			/* Read data from a file */
NFRESULT f_write (FIL* fp, const void* buff, UINT btw, UINT* bw);	/* Write data to a file */
NFRESULT f_forward (FIL* fp, UINT(*func)(const BYTE*,UINT), UINT btf, UINT* bf);	/* Forward data to the stream */
NFRESULT f_lseek (FIL* fp, DWORD ofs);								/* Move file pointer of a file object */
NFRESULT f_truncate (FIL* fp);										/* Truncate file */
NFRESULT f_sync (FIL* fp);											/* Flush cached data of a writing file */
NFRESULT f_opendir (DIR* dp, const TCHAR* path);						/* Open a directory */
NFRESULT f_closedir (DIR* dp);										/* Close an open directory */
NFRESULT f_readdir (DIR* dp, FILINFO* fno);							/* Read a directory item */
NFRESULT f_mkdir (const TCHAR* path);								/* Create a sub directory */
NFRESULT f_unlink (const TCHAR* path);								/* Delete an existing file or directory */
NFRESULT f_rename (const TCHAR* path_old, const TCHAR* path_new);	/* Rename/Move a file or directory */
NFRESULT f_stat (const TCHAR* path, FILINFO* fno);					/* Get file status */
NFRESULT f_chmod (const TCHAR* path, BYTE value, BYTE mask);			/* Change attribute of the file/dir */
NFRESULT f_utime (const TCHAR* path, const FILINFO* fno);			/* Change times-tamp of the file/dir */
NFRESULT f_chdir (const TCHAR* path);								/* Change current directory */
NFRESULT f_chdrive (const TCHAR* path);								/* Change current drive */
NFRESULT f_getcwd (TCHAR* buff, UINT len);							/* Get current directory */
NFRESULT f_getfree (const TCHAR* path, DWORD* nclst, FATFS** fatfs);	/* Get number of free clusters on the drive */
NFRESULT f_getlabel (const TCHAR* path, TCHAR* label, DWORD* vsn);	/* Get volume label */
NFRESULT f_setlabel (const TCHAR* label);							/* Set volume label */
NFRESULT f_mount (FATFS* fs, const TCHAR* path, BYTE opt);			/* Mount/Unmount a logical drive */
NFRESULT f_mkfs (const TCHAR* path, BYTE sfd, UINT au);				/* Create a file system on the volume */
NFRESULT f_fdisk (BYTE pdrv, const DWORD szt[], void* work);			/* Divide a physical drive into some partitions */
Nint f_putc (TCHAR c, FIL* fp);										/* Put a character to the file */
Nint f_puts (const TCHAR* str, FIL* cp);								/* Put a string to the file */
Nint f_printf (FIL* fp, const TCHAR* str, ...);						/* Put a formatted string to the file */
NTCHAR* f_gets (TCHAR* buff, int len, FIL* fp);						/* Get a string from the file */
N
N#define f_eof(fp) ((int)((fp)->fptr == (fp)->fsize))
N#define f_error(fp) ((fp)->err)
N#define f_tell(fp) ((fp)->fptr)
N#define f_size(fp) ((fp)->fsize)
N
N#ifndef EOF
S#define EOF (-1)
N#endif
N
N
N
N
N/*--------------------------------------------------------------*/
N/* Additional user defined functions                            */
N
N/* RTC function */
N#if !_FS_READONLY && !_FS_NORTC
X#if !0 && !0
NDWORD get_fattime (void);
N#endif
N
N/* Unicode support functions */
N#if _USE_LFN							/* Unicode - OEM code conversion */
X#if 2							 
NWCHAR ff_convert (WCHAR chr, UINT dir);	/* OEM-Unicode bidirectional conversion */
NWCHAR ff_wtoupper (WCHAR chr);			/* Unicode upper-case conversion */
N#if _USE_LFN == 3						/* Memory functions */
X#if 2 == 3						 
Svoid* ff_memalloc (UINT msize);			/* Allocate memory block */
Svoid ff_memfree (void* mblock);			/* Free memory block */
N#endif
N#endif
N
N/* Sync functions */
N#if _FS_REENTRANT
X#if 0
Sint ff_cre_syncobj (BYTE vol, _SYNC_t* sobj);	/* Create a sync object */
Sint ff_req_grant (_SYNC_t sobj);				/* Lock sync object */
Svoid ff_rel_grant (_SYNC_t sobj);				/* Unlock sync object */
Sint ff_del_syncobj (_SYNC_t sobj);				/* Delete a sync object */
N#endif
N
N
N
N
N/*--------------------------------------------------------------*/
N/* Flags and offset address                                     */
N
N
N/* File access control and file status flags (FIL.flag) */
N
N#define	FA_READ				0x01
N#define	FA_OPEN_EXISTING	0x00  //默认打开，不存在则失败
N
N#if !_FS_READONLY
X#if !0
N#define	FA_WRITE			0x02 
N#define	FA_CREATE_NEW		0x04      //单纯的新建，
N#define	FA_CREATE_ALWAYS	0x08   //打开，没有则创建
N#define	FA_OPEN_ALWAYS		0x10   //打开和截断；
N#define FA__WRITTEN			0x20
N#define FA__DIRTY			0x40
N#endif
N
N
N/* FAT sub type (FATFS.fs_type) */
N
N#define FS_FAT12	1
N#define FS_FAT16	2
N#define FS_FAT32	3
N
N
N/* File attribute bits for directory entry */
N
N#define	AM_RDO	0x01	/* Read only */
N#define	AM_HID	0x02	/* Hidden */
N#define	AM_SYS	0x04	/* System */
N#define	AM_VOL	0x08	/* Volume label */
N#define AM_LFN	0x0F	/* LFN entry */
N#define AM_DIR	0x10	/* Directory */
N#define AM_ARC	0x20	/* Archive */
N#define AM_MASK	0x3F	/* Mask of defined bits */
N
N
N/* Fast seek feature */
N#define CREATE_LINKMAP	0xFFFFFFFF
N
N
N
N/*--------------------------------*/
N/* Multi-byte word access macros  */
N
N#if _WORD_ACCESS == 1	/* Enable word access to the FAT structure */
X#if 0 == 1	 
S#define	LD_WORD(ptr)		(WORD)(*(WORD*)(BYTE*)(ptr))
S#define	LD_DWORD(ptr)		(DWORD)(*(DWORD*)(BYTE*)(ptr))
S#define	ST_WORD(ptr,val)	*(WORD*)(BYTE*)(ptr)=(WORD)(val)
S#define	ST_DWORD(ptr,val)	*(DWORD*)(BYTE*)(ptr)=(DWORD)(val)
N#else					/* Use byte-by-byte access to the FAT structure */
N#define	LD_WORD(ptr)		(WORD)(((WORD)*((BYTE*)(ptr)+1)<<8)|(WORD)*(BYTE*)(ptr))
N#define	LD_DWORD(ptr)		(DWORD)(((DWORD)*((BYTE*)(ptr)+3)<<24)|((DWORD)*((BYTE*)(ptr)+2)<<16)|((WORD)*((BYTE*)(ptr)+1)<<8)|*(BYTE*)(ptr))
N#define	ST_WORD(ptr,val)	*(BYTE*)(ptr)=(BYTE)(val); *((BYTE*)(ptr)+1)=(BYTE)((WORD)(val)>>8)
N#define	ST_DWORD(ptr,val)	*(BYTE*)(ptr)=(BYTE)(val); *((BYTE*)(ptr)+1)=(BYTE)((WORD)(val)>>8); *((BYTE*)(ptr)+2)=(BYTE)((DWORD)(val)>>16); *((BYTE*)(ptr)+3)=(BYTE)((DWORD)(val)>>24)
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* _FATFS */
L 46 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "./AudioIO/AudioIO.h"
L 1 "..\..\Complex\./AudioIO/AudioIO.h" 1
N#ifndef __AUDIO_H__
N#define __AUDIO_H__
N
N#include <inttypes.h>
N#include "Include.h"
N
N/* RECBUFFER_SIZE决定两个缓存区大小，实际每个缓存区占用RAM空间字节数为：RECBUFFER_SIZE*2
N * 对于选择I2S_AudioFreq_16k采样率使用RECBUFFER_SIZE为1024*4，就可保证录音及放音效果流畅，
N * 如果选择其他更高采样率需要适当调整用RECBUFFER_SIZE大小，比如当选择择I2S_AudioFreq_44k
N * 是设置RECBUFFER_SIZE为1024*8
N * 另外，SD卡本身的读写速度也在一定性能上影响录音效果
N */
N#define RECBUFFER_SIZE  	2048
N
N/*STM32数据传输IIS、DMA配置*/
N#define AUDIO_PLAY_START    I2S_Play_Start();//开启DMA TX
N#define AUDIO_PLAY_STOP    	I2S_Play_Stop();//关闭DMA TX
N
N/* 音频芯片接口配置 */
N#define AUDIO_PLAY_POWEROFF    wm8978_PowerDown();//关闭power 
N//驱动芯片播放设置,配置为扬声器输出,菲利普格式,16bit采样
N#define AUDIO_DRIVERCHIP_PLAYCONFIG		wm8978_CfgAudioPath(0x10,0x04);\
N										wm8978_CfgAudioIF((uint16_t)0x0000,16);\
N										wm8978_SetOUT2Volume(50);
X#define AUDIO_DRIVERCHIP_PLAYCONFIG		wm8978_CfgAudioPath(0x10,0x04);										wm8978_CfgAudioIF((uint16_t)0x0000,16);										wm8978_SetOUT2Volume(50);
N/* 文件系统接口配置 */
N#define AUDIO_PLAY_FOPEN(x,y,z)		f_open(x,y,z)	
N#define AUDIO_PLAY_FCLOSE(x)		f_close(x)
N#define AUDIO_PLAY_FREAD(x,y,z,m)	f_read(x,y,z,m)
N
N/* 播放器待播放音频文件类型 */
Ntypedef enum
N{
N	AudioIO_Empty = 0,	/* 空文件 */
N	AudioIO_FireAlarm,	/* 消防警报 */
N	AudioIO_BonVoyage,	/* 一路顺风 */
N	AudioIO_WelBack,	/*  欢迎回家  */
N	AudioIO_ErrKey,		/*  error key  */
N	AudioIO_ConfDevice,	/*  刷卡配置设备  */
N	AudioIO_ConfSuccess,	/*  配置设备成功  */
N	AudioIO_CardInvalid,	/*  卡片无效  */
N	AudioIO_zero,	/*  数字0  */
N	AudioIO_one,	/*  数字1  */
N	AudioIO_two,	/*  数字2  */
N	AudioIO_three,	/*  数字3  */
N	AudioIO_four,	/*  数字4  */
N	AudioIO_five,	/*  数字5  */
N	AudioIO_six,	/*  数字6  */
N	AudioIO_seven,	/*  数字7  */
N	AudioIO_eight,	/*  数字8  */
N	AudioIO_nine,	/*  数字9  */
N	AudioIO_cancel	/*  取消   */
N}Audio_PlayFile;
N
Ntypedef union
N{
N	uint16_t  wBrdcast[RECBUFFER_SIZE];			/* 播音数据缓存区，存放发送给WM8978的音频数据*/
X	uint16_t  wBrdcast[2048];			 
N	uint8_t   cBrdcast[RECBUFFER_SIZE*2];			/* 播音数据缓存区，存放发送给WM8978的音频数据*/
X	uint8_t   cBrdcast[2048*2];			 
N}Recorder_Brdcast;	
N
N
Ntypedef struct
N{
N	uint8_t ucInput;			/* 输入源：0:MIC, 1:线输入 */
N	uint8_t ucFmtIdx;			/* 音频格式：标准、位长、采样频率 */
N	uint8_t ucVolume;			/* 当前放音音量 */
N	uint8_t ucGain;			  /* 当前增益 */	
N	uint8_t ucStatus;			/* 录音机状态，0表示待机，1表示录音中，2表示播放中 */	
N}REC_TYPE;	
N
N/* WAV文件头格式 */
Ntypedef __packed struct
N{ 
N	uint32_t	riff;							/* = "RIFF"	0x46464952*/
N	uint32_t	size_8;						/* 从下个地址开始到文件尾的总字节数	*/
N	uint32_t	wave;							/* = "WAVE" 0x45564157*/
N	
N	uint32_t	fmt;							/* = "fmt " 0x20746d66*/
N	uint32_t	fmtSize;					/* 下一个结构体的大小(一般为16) */
N	uint16_t	wFormatTag;				/* 编码方式,一般为1	*/
N	uint16_t	wChannels;				/* 通道数，单声道为1，立体声为2 */
N	uint32_t	dwSamplesPerSec;	/* 采样率 */
N	uint32_t	dwAvgBytesPerSec;	/* 每秒字节数(= 采样率 × 每个采样点字节数) */
N	uint16_t	wBlockAlign;			/* 每个采样点字节数(=量化比特数/8*通道数) */
N	uint16_t	wBitsPerSample;		/* 量化比特数(每个采样需要的bit数) */
N																			  
N	uint32_t	data;							/* = "data" 0x61746164*/
N	uint32_t	datasize;					/* 纯数据长度 */
N} WavHead;	
N
N/* API接口 */
Nextern void InitAudioIO_playconfig(void);
Nextern void TskAudioIO_MainFunction(void);
Nextern void SetAudioIO_PlayFile(uint8_t Le_u_File);
Nextern uint8_t GetAudioIO_u_PlaySt(void);
N#endif  /* __RECORD_H__   */
N
L 47 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "./timeStamp/time_stamp.h"
N#include "./FATFS/tm_stm32f4_fatfs.h"
L 1 "..\..\Complex\./FATFS/tm_stm32f4_fatfs.h" 1
N/**
N * Fatfs implementation for STM32F4xx devices
N *
N * This library uses Chan's Fatfs implementation.
N * 
N * This library is only for communication. To work with files, you have to look at Chan's FatFs manual, link below:
N * http://elm-chan.org/fsw/ff/00index_e.html
N *
N * You can work with SPI or SDIO protocol to interface SDcard.
N *
N * For more details look at link below
N *
N *	@author 	Tilen Majerle
N *	@email		tilen@majerle.eu
N *	@website	http://stm32f4-discovery.com
N *	@link		http://stm32f4-discovery.com/2014/07/library-21-read-sd-card-fatfs-stm32f4xx-devices/
N *	@link		http://stm32f4-discovery.com/2014/08/library-29-usb-msc-host-usb-flash-drive-stm32f4xx-devices
N *	@version 	v1.4
N *	@ide		Keil uVision
N *	@license	GNU GPL v3
N *	
N * |----------------------------------------------------------------------
N * | Copyright (C) Tilen Majerle, 2014
N * | 
N * | This program is free software: you can redistribute it and/or modify
N * | it under the terms of the GNU General Public License as published by
N * | the Free Software Foundation, either version 3 of the License, or
N * | any later version.
N * |  
N * | This program is distributed in the hope that it will be useful,
N * | but WITHOUT ANY WARRANTY; without even the implied warranty of
N * | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N * | GNU General Public License for more details.
N * | 
N * | You should have received a copy of the GNU General Public License
N * | along with this program.  If not, see <http://www.gnu.org/licenses/>.
N * |----------------------------------------------------------------------
N *	
N * Version 1.4
N *	- December 29, 2014
N *	- Support for truncate file from beginning
N *
N * Version 1.3
N *	- December 06, 2014
N *	- FatFs R0.10C supported
N 
N * Version 1.2
N *	- August 28, 2014
N *	- Added support for USB
N *
N *
N * -----------------------------------------------------------------------------------------
N * Library works with SPI or SDIO mode. Also, when in SDIO mode, you can set to 1- or 4-bit mode.
N * By default, SDIO with 4-bit mode is used, so you will look into right column on table below.
N * 
N * SD CARD PINS
N * 	   _________________
N * 	  / 1 2 3 4 5 6 7 8 |
N * 	 /					|
N *  / 9					|
N *  | 					|
N *	|					|
N *	|					|
N *	|					|
N *	|   SD CARD Pinout	|
N *	|					|
N *	|					|
N *	|					|
N *	|					|
N *	|___________________|
N *	
N *	
N * Default pinout for SD card
N * 
N *	NR	|SDIO INTERFACE										|SPI INTERFACE
N *		|NAME		STM32F4XX		DESCRIPTION				|NAME	STM32F4XX	DESCRIPTION
N *		|			4-BIT	1-BIT							|
N *		|													|
N *	1	|CD/DAT3	PC11	-		Connector data line 3	|CS		PB5			Chip select for SPI
N *	2	|CMD		PD2		PD2		Command/Response line	|MOSI	PA7			Data input for SPI
N *	3	|VSS1		GND		GND		GND						|VSS1	GND			GND
N *	4	|VDD		3.3V	3.3V	3.3V Power supply		|VDD	3.3V		3.3V Power supply
N *	5	|CLK		PC12	PC12	Clock					|SCK	PA5			Clock for SPI
N *	6	|VSS2		GND		GND		GND						|VSS2	GND			GND
N *	7	|DAT0		PC8		PC8		Connector data line 0	|MISO	PA6			Data output for SPI
N *	8	|DAT1		PC9		-		Connector data line 1	|-		-			-
N *	9	|DAT2		PC10	-		Connector data line 2	|-		-			-
N *	
N *	
N * SDIO Communication
N * 
N * By default, SDIO with 4-bit communication is used.
N * If you want to use SDIO 1-bit communication, set defines below in your defines.h file:
N * 
N *	//Set SDIO with 1-bit communication
N * 	#define FATFS_SDIO_4BIT		0
N * 
N * Files needed for SDIO
N * 		- tm_stm32f4_fatfs.h
N *		- tm_stm32f4_fatfs.c
N *		- fatfs/diskio.h
N *		- fatfs/diskio.c
N *		- fatfs/ff.h
N *		- fatfs/ff.c
N *		- fatfs/ffconf.h
N *		- fatfs/integer.h
N *		- fatfs/option/syscall.c
N *		- fatfs/option/unicode.c
N *		- fatfs/drivers/fatfs_sd_sdio.h
N *		- fatfs/drivers/fatfs_sd_sdio.c
N * 
N * SPI Communication
N * 
N * Or, if you want to use SPI communication, you have to add lines below in your defines.h file
N *	
N *	//Enable SPI communication, disable SDIO
N *	#define FATFS_USE_SDIO		0
N *	
N * Files, needed for SPI
N * 		- tm_stm32f4_fatfs.h
N *		- tm_stm32f4_fatfs.c
N *		- fatfs/diskio.h
N *		- fatfs/diskio.c
N *		- fatfs/ff.h
N *		- fatfs/ff.c
N *		- fatfs/ffconf.h
N *		- fatfs/integer.h
N *		- fatfs/option/syscall.c
N *		- fatfs/option/unicode.c
N *		- fatfs/drivers/fatfs_sd.h
N *		- fatfs/drivers/fatfs_sd.c
N * 
N * Overwriting default pinout:
N * 
N * SDIO interface pins are fixed, and can not be changed.
N * If you want to change SPI pins, you have to set this defines in your defines.h file
N * 
N *	//Set your SPI, for corresponsing pins look at TM SPI
N *	#define FATFS_SPI							SPI1
N *	#define FATFS_SPI_PINSPACK					TM_SPI_PinsPack_1
N *	
N *	//Set your CS pin for SPI
N *	#define FATFS_CS_RCC						RCC_AHB1Periph_GPIOB			
N *	#define FATFS_CS_PORT						GPIOB
N *	#define FATFS_CS_PIN						GPIO_Pin_5
N *
N * Also, library has support for Write protect and Card detect pins.
N * This two pins are by default on pins below.
N * They are the same for any communication used, and are disabled by default
N * WP and CD Pinout
N * 
N * 	NAME	STM32F4XX	DESCRIPTION
N * 	
N *	WP		PB7			Write protect pin. Pin low when write is enabled
N *	CD		PB6			Card detect pin. Pin low when card detected
N *	
N * Like I said before, these 2 pins are disabled by default. If you want to use it, you have to add 2 lines in your defines.h file
N *	
N *	//Enable Card detect pin
N *	#define FATFS_USE_DETECT_PIN				1
N *
N *	//Enable Write protect pin
N *	#define FATFS_USE_WRITEPROTECT_PIN			1
N *	
N *	Add lines below to your defines.h file only if you want to overwrite default pin settings
N *	//Default CD pin
N *	#define FATFS_USE_DETECT_PIN_RCC			RCC_AHB1Periph_GPIOB			
N *	#define FATFS_USE_DETECT_PIN_PORT			GPIOB
N *	#define FATFS_USE_DETECT_PIN_PIN			GPIO_Pin_6
N *	//Default WP pin
N *	#define FATFS_USE_WRITEPROTECT_PIN_RCC		RCC_AHB1Periph_GPIOB			
N *	#define FATFS_USE_WRITEPROTECT_PIN_PORT		GPIOB
N *	#define FATFS_USE_WRITEPROTECT_PIN_PIN		GPIO_Pin_7
N *
N * 
N * get_fattime() time function for FatFs
N * 
N * FatFs uses function for time, to set timestamp for files, when they were edited or created.
N * 
N * By default, function returns 0, but if you want to create your own function, you have to set defines in defines.h file:
N * 
N * 	//Use custom get_fattime() function
N * 	#define FATFS_CUSTOM_FATTIME	1
N *
N * And then somewhere in your project, add function like below:
N * 
N * 	//Use custom get_fattime function
N * 	//Implement RTC get time here if you need it
N * 	DWORD get_fattime (void) {
N * 		//Get your time from RTC or something like that
N * 		
N * 		return	  ((DWORD)(2014 - 1980) << 25)	// Year 2014
N * 				| ((DWORD)7 << 21)				// Month 7
N * 				| ((DWORD)10 << 16)				// Mday 10
N * 				| ((DWORD)16 << 11)				// Hour 16
N * 				| ((DWORD)0 << 5)				// Min 0
N * 				| ((DWORD)0 >> 1);				// Sec 0
N * 	}
N * 
N * 
N * -------------------------------------------------------------------------------------------
N * 	Version v1.2
N * -------------------------------------------------------------------------------------------
N * 
N * Added support for USB MSC HOST interface with FatFS library.
N * More about, how to configure USB MSC HOST to work properly, you should take a look at 
N * my library tm_stm32f4_usb_msc_host.h. There is also default pinout for USB and other stuff.
N * 
N * I will explain here, how to properly set FatFS library to work with USB.
N * 
N * Files, needed for USB communication and FatFS
N * 		- tm_stm32f4_fatfs.h
N *		- tm_stm32f4_fatfs.c
N *		- fatfs/diskio.h
N *		- fatfs/diskio.c
N *		- fatfs/ff.h
N *		- fatfs/ff.c
N *		- fatfs/ffconf.h
N *		- fatfs/integer.h
N *		- fatfs/option/syscall.c
N *		- fatfs/option/unicode.c
N *		- fatfs/drivers/fatfs_usb.h
N *		- fatfs/drivers/fatfs_usb.c
N * 
N * After you have your files included in project, open project's defines.h file and add line below:
N * 
N * //Enable USB in FatFS library
N * #define FATFS_USE_USB		1
N * 
N * This will enable USB functions to work with FatFS module.
N * Also, when you make define 2 lines above, SD card settings become inactive.
N * If you want to use SD card and USB storage at the same time for some reason, you have to enable SD card
N * functionality. Add lines below in your defines.h file:
N * 
N * 	//Enable SDIO communication for SD card
N *	#define FATFS_USE_SDIO		1
N * 
N * 	//Enable SPI communication for SD card
N *	#define FATFS_USE_SDIO		0
N *	
N * And also, you should know, that USB has 1: partition and SD card has 0: partition.
N * So when you mount SD card, you should use:
N * 
N *	//Mount SD card
N * 	f_mount(&sd_fs, "0:", 1);
N * 	
N * 	//Mount USB storage
N * 	f_mount(&usb_fs, "1:", 1);
N * 
N * This allows you to copy data from one SD card to USB and back too.
N */
N#ifndef TM_FATFS_H
N#define TM_FATFS_H	140
N/**
N * Dependencies
N *	- STM32F4xx
N *	- STM32F4xx RCC
N *	- STM32F4xx GPIO
N *	- STM32Fx44 SPI		(only when SPI)
N *	- STM32F4xx DMA		(only when SDIO)
N *	- STM32Fx44 SDIO	(only when SDIO)
N *	- MISC				(only when SDIO)
N *	- defines.h
N *	- tm_stm32f4_spi	(only when SPI)
N *	- tm_stm32f4_delay	(only when SPI)
N *	- FatFS by chan
N */
N/**
N * Includes
N */
N#include "stm32f4xx.h"
N#include "stm32f4xx_rcc.h"
N#include "stm32f4xx_gpio.h"
N//#include "defines.h"
N#include "ff.h"
N
N/* Default truncate buffer size in bytes */
N#ifndef FATFS_TRUNCATE_BUFFER_SIZE
N#define FATFS_TRUNCATE_BUFFER_SIZE	256
N#endif
N
N/**
N * Get SD card drive size
N *
N * Parameters:
N * 	- uint32_t* total:
N *		Pointer to variable to store total size of card
N * 	- uint32_t* free:
N *		Pointer to variable to store free space on card
N *
N * Returns FRESULT struct members. If data are valid, FR_OK is returned.
N */
NFRESULT TM_FATFS_DriveSize(uint32_t* total, uint32_t* free);
N
N/**
N * Get SD card drive size
N *
N * Parameters:
N * 	- uint32_t* total:
N *		Pointer to variable to store total size of card
N * 	- uint32_t* free:
N *		Pointer to variable to store free space on card
N *
N * Returns FRESULT struct members. If data are valid, FR_OK is returned.
N */
NFRESULT TM_FATFS_USBDriveSize(uint32_t* total, uint32_t* free);
N
N/**
N * Truncate beginning of file
N *
N * Parameters:
N * 	- FIL* fil: 
N *		Pointer to already opened file
N * 	- uint32_t index:
N *		Number of characters that will be truncated from beginning.
N *		If index is more than file size, everything will be truncated, but file will not be deleted
N *		
N * Example
N *	- You have a file, it's content is: "abcdefghijklmnoprstuvwxyz",
N *	- You want to truncate first 5 bytes,
N *	- Call TM_FATFS_TruncateBeginning(&opened_file, 5);
N *	- You will get new file data: "fghijklmnoprstuvwxyz"
N *
N * Returns FRESULT struct members. If everything ok, FR_OK is returned.
N */
NFRESULT TM_FATFS_TruncateBeginning(FIL* fil, uint32_t index);
N
N#endif
N
L 49 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "./FATFS/diskio.h"	
L 1 "..\..\Complex\./FATFS/diskio.h" 1
N/*-----------------------------------------------------------------------/
N/  Low level disk interface modlue include file   (C)ChaN, 2013          /
N/-----------------------------------------------------------------------*/
N
N#ifndef _DISKIO_DEFINED
N#define _DISKIO_DEFINED
N
N#define _USE_WRITE	1	/* 1: Enable disk_write function */
N#define _USE_IOCTL	1	/* 1: Enable disk_ioctl fucntion */
N
N#include "./FATFS/integer.h"
N//#include "defines.h"
N#include "./FATFS/attributes.h"
L 1 "..\..\Complex\./FATFS/attributes.h" 1
N/**
N *  Attributes for different compilers
N * 
N *	@author 	Tilen Majerle
N *	@email		tilen@majerle.eu
N *	@website	http://stm32f4-discovery.com
N *	@version 	v1.0
N *	@ide		Keil uVision 5
N *	@license	GNU GPL v3
N *	
N * |----------------------------------------------------------------------
N * | Copyright (C) Tilen Majerle, 2014
N * | 
N * | This program is free software: you can redistribute it and/or modify
N * | it under the terms of the GNU General Public License as published by
N * | the Free Software Foundation, either version 3 of the License, or
N * | any later version.
N * |  
N * | This program is distributed in the hope that it will be useful,
N * | but WITHOUT ANY WARRANTY; without even the implied warranty of
N * | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N * | GNU General Public License for more details.
N * | 
N * | You should have received a copy of the GNU General Public License
N * | along with this program.  If not, see <http://www.gnu.org/licenses/>.
N * |----------------------------------------------------------------------
N *
N * Different compilers uses different special keywords for functions/variables. etc.
N * For this purpose that file has been made. On one place to all possible attributes used in my libs.
N */
N#ifndef TM_ATTRIBUTES_H
N#define TM_ATTRIBUTES_H
N
N/* Check for GNUC */
N#if defined (__GNUC__)
X#if 0L
S	#ifndef __weak		
S		#define __weak   	__attribute__((weak))
S	#endif	/* Weak attribute */
S	#ifndef __packed	
S		#define __packed 	__attribute__((__packed__))
S	#endif	/* Packed attribute */
N#endif
N
N#endif
L 14 "..\..\Complex\./FATFS/diskio.h" 2
N
N/* Status of Disk Functions */
Ntypedef BYTE	DSTATUS;
N
N/* Results of Disk Functions */
Ntypedef enum {
N	RES_OK = 0,		/* 0: Successful */
N	RES_ERROR,		/* 1: R/W Error */
N	RES_WRPRT,		/* 2: Write Protected */
N	RES_NOTRDY,		/* 3: Not Ready */
N	RES_PARERR		/* 4: Invalid Parameter */
N} DRESULT;
N
N
N//#define FATFS_DEBUG_SEND_USART(x)	TM_USART_Puts(USART6, x); TM_USART_Puts(USART6, "\n");
N#define FATFS_DEBUG_SEND_USART(x)
N
N/*---------------------------------------*/
N/* Prototypes for disk control functions */
N
NDSTATUS disk_initialize (BYTE pdrv);
NDSTATUS disk_status (BYTE pdrv);
NDRESULT disk_read (BYTE pdrv, BYTE* buff, DWORD sector, UINT count);
NDRESULT disk_write (BYTE pdrv, const BYTE* buff, DWORD sector, UINT count);
NDRESULT disk_ioctl (BYTE pdrv, BYTE cmd, void* buff);
N
N/* Disk Status Bits (DSTATUS) */
N
N#define STA_NOINIT		0x01	/* Drive not initialized */
N#define STA_NODISK		0x02	/* No medium in the drive */
N#define STA_PROTECT		0x04	/* Write protected */
N
N
N/* Command code for disk_ioctrl fucntion */
N
N/* Generic command (used by FatFs) */
N#define CTRL_SYNC			0	/* Flush disk cache (for write functions) */
N#define GET_SECTOR_COUNT	1	/* Get media size (for only f_mkfs()) */
N#define GET_SECTOR_SIZE		2	/* Get sector size (for multiple sector size (_MAX_SS >= 1024)) */
N#define GET_BLOCK_SIZE		3	/* Get erase block size (for only f_mkfs()) */
N#define CTRL_ERASE_SECTOR	4	/* Force erased a block of sectors (for only _USE_ERASE) */
N
N/* Generic command (not used by FatFs) */
N#define CTRL_POWER			5	/* Get/Set power status */
N#define CTRL_LOCK			6	/* Lock/Unlock media removal */
N#define CTRL_EJECT			7	/* Eject media */
N#define CTRL_FORMAT			8	/* Create physical format on the media */
N
N/* MMC/SDC specific ioctl command */
N#define MMC_GET_TYPE		10	/* Get card type */
N#define MMC_GET_CSD			11	/* Get CSD */
N#define MMC_GET_CID			12	/* Get CID */
N#define MMC_GET_OCR			13	/* Get OCR */
N#define MMC_GET_SDSTAT		14	/* Get SD status */
N
N/* ATA/CF specific ioctl command */
N#define ATA_GET_REV			20	/* Get F/W revision */
N#define ATA_GET_MODEL		21	/* Get model name */
N#define ATA_GET_SN			22	/* Get serial number */
N
N/* MMC card type flags (MMC_GET_TYPE) */
N#define CT_MMC		0x01		/* MMC ver 3 */
N#define CT_SD1		0x02		/* SD ver 1 */
N#define CT_SD2		0x04		/* SD ver 2 */
N#define CT_SDC		(CT_SD1|CT_SD2)	/* SD */
N#define CT_BLOCK	0x08		/* Block addressing */
N
N#endif
L 50 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "./flash/fatfs_flash_spi.h"
L 1 "..\..\Complex\./flash/fatfs_flash_spi.h" 1
N#ifndef __SPI_FLASH_H
N#define __SPI_FLASH_H
N
N#include "stm32f4xx.h"
N#include <stdio.h>
N
N#include "./FATFS/diskio.h"
N#include "./FATFS/integer.h"
N
N
N
N
N
N#define USB_SPI_TIMEOUT
N
N//#define  sFLASH_ID                        0xEF3015     //W25X16
N//#define  sFLASH_ID                        0xEF4015	   //W25Q16
N//#define  sFLASH_ID                        0XEF4017     //W25Q64
N#define  sFLASH_ID                          0XEF4018     //W25Q128
N
N/* Private typedef -----------------------------------------------------------*/
N//#define SPI_FLASH_PageSize                4096
N#define SPI_FLASH_PageSize                  256
N#define SPI_FLASH_PerWritePageSize          256
N
N/* Private define ------------------------------------------------------------*/
N#define W25X_WriteEnable		                0x06 
N#define W25X_WriteDisable		                0x04 
N#define W25X_ReadStatusReg		              0x05 
N#define W25X_ReadStatusRegTwo		          0x35 
N#define W25X_ReadStatusRegThr		          0x15 
N#define W25X_WriteStatusReg		              0x01 
N#define W25X_ReadData			                  0x03 
N#define W25X_FastReadData		                0x0B 
N#define W25X_FastReadDual		                0x3B 
N#define W25X_PageProgram		                0x02 
N#define W25X_BlockErase			                0xD8 
N#define W25X_SectorErase		                0x20 
N#define W25X_ChipErase			                0xC7 
N#define W25X_PowerDown			                0xB9 
N#define W25X_ReleasePowerDown	              0xAB 
N#define W25X_DeviceID			                  0xAB 
N#define W25X_ManufactDeviceID   	          0x90 
N#define W25X_JedecDeviceID		              0x9F 
N
N#define W25X_EnableReset   	          0x66
N#define W25X_Reset		              0x99 
N
N#define WIP_Flag                            0x01  /* Write In Progress (WIP) flag */
N
N#define Dummy_Byte                          0xFF
N
N
N/*SPI接口定义-开头****************************/
N#define FLASH_SPI                           SPI1
N#define FLASH_SPI_CLK                       RCC_APB2Periph_SPI1
N#define FLASH_SPI_CLK_INIT                  RCC_APB2PeriphClockCmd
N
N#define FLASH_SPI_SCK_PIN                   GPIO_Pin_3                  
N#define FLASH_SPI_SCK_GPIO_PORT             GPIOB                       
N#define FLASH_SPI_SCK_GPIO_CLK              RCC_AHB1Periph_GPIOB
N#define FLASH_SPI_SCK_PINSOURCE             GPIO_PinSource3
N#define FLASH_SPI_SCK_AF                    GPIO_AF_SPI1
N
N#define FLASH_SPI_MISO_PIN                  GPIO_Pin_4                
N#define FLASH_SPI_MISO_GPIO_PORT            GPIOB                   
N#define FLASH_SPI_MISO_GPIO_CLK             RCC_AHB1Periph_GPIOB
N#define FLASH_SPI_MISO_PINSOURCE            GPIO_PinSource4
N#define FLASH_SPI_MISO_AF                   GPIO_AF_SPI1
N
N#define FLASH_SPI_MOSI_PIN                  GPIO_Pin_5                
N#define FLASH_SPI_MOSI_GPIO_PORT            GPIOB                     
N#define FLASH_SPI_MOSI_GPIO_CLK             RCC_AHB1Periph_GPIOB
N#define FLASH_SPI_MOSI_PINSOURCE            GPIO_PinSource5
N#define FLASH_SPI_MOSI_AF                   GPIO_AF_SPI1
N
N#define FLASH_CS_PIN                        GPIO_Pin_6               
N#define FLASH_CS_GPIO_PORT                  GPIOG                     
N#define FLASH_CS_GPIO_CLK                   RCC_AHB1Periph_GPIOG
N
N#define SPI_FLASH_CS_LOW()      {FLASH_CS_GPIO_PORT->BSRRH=FLASH_CS_PIN;}
N#define SPI_FLASH_CS_HIGH()     {FLASH_CS_GPIO_PORT->BSRRL=FLASH_CS_PIN;}
N/*SPI接口定义-结尾****************************/
N
N/*等待超时时间*/
N#ifdef  USB_SPI_TIMEOUT
N#define SPIT_FLAG_TIMEOUT         ((uint32_t)0x1000)
N#define SPIT_LONG_TIMEOUT         ((uint32_t)(10 * SPIT_FLAG_TIMEOUT))
N#endif
N
N/*信息输出*/
N#define FLASH_DEBUG_ON         0
N#define FLASH_DEBUG_FUNC_ON    0
N
N#define FLASH_INFO(fmt,arg...)           printf("<<-FLASH-INFO->> "fmt"\n",##arg)
N#define FLASH_ERROR(fmt,arg...)          printf("<<-FLASH-ERROR->> "fmt"\n",##arg)
N#define FLASH_DEBUG(fmt,arg...)          do{\
N                                          if(FLASH_DEBUG_ON)\
N                                          printf("<<-FLASH-DEBUG->> [%d]"fmt"\n",__LINE__, ##arg);\
N                                          }while(0)
X#define FLASH_DEBUG(fmt,arg...)          do{                                          if(FLASH_DEBUG_ON)                                          printf("<<-FLASH-DEBUG->> [%d]"fmt"\n",__LINE__, ##arg);                                          }while(0)
N
N#define FLASH_DEBUG_FUNC()               do{\
N                                         if(FLASH_DEBUG_FUNC_ON)\
N                                         printf("<<-FLASH-FUNC->> Func:%s@Line:%d\n",__func__,__LINE__);\
N                                       }while(0)
X#define FLASH_DEBUG_FUNC()               do{                                         if(FLASH_DEBUG_FUNC_ON)                                         printf("<<-FLASH-FUNC->> Func:%s@Line:%d\n",__func__,__LINE__);                                       }while(0)
N
N
N
NDSTATUS TM_FATFS_FLASH_SPI_disk_initialize(void);
NDSTATUS TM_FATFS_FLASH_SPI_disk_status(void) ;
NDRESULT TM_FATFS_FLASH_SPI_disk_ioctl(BYTE cmd, char *buff) ;
NDRESULT TM_FATFS_FLASH_SPI_disk_read(BYTE *buff, DWORD sector, UINT count) ;
NDRESULT TM_FATFS_FLASH_SPI_disk_write(BYTE *buff, DWORD sector, UINT count) ;
N
Nextern void SPI_FLASH_SectorErase(u32 SectorAddr);
Nextern void SPI_FLASH_BulkErase(void);
Nextern void SPI_FLASH_PageWrite(u8* pBuffer, u32 WriteAddr, u16 NumByteToWrite);
Nextern void SPI_FLASH_BufferWrite(u8* pBuffer, u32 WriteAddr, u16 NumByteToWrite);
Nextern void SPI_FLASH_BufferRead(u8* pBuffer, u32 ReadAddr, uint32_t NumByteToRead);
Nextern u32 SPI_FLASH_ReadID(void);
Nextern u32 SPI_FLASH_ReadDeviceID(void);
Nextern void SPI_FLASH_StartReadSequence(u32 ReadAddr);
Nextern void SPI_Flash_PowerDown(void);
Nextern void SPI_Flash_WAKEUP(void);
Nextern void SPI_Flash_Reset(void);
Nextern u8 SPI_FLASH_WrInProgStatus(void);
Nextern u8 SPI_FLASH_ReadByte(void);
Nextern u8 SPI_FLASH_SendByte(u8 byte);
Nextern u16 SPI_FLASH_SendHalfWord(u16 HalfWord);
Nextern void SPI_FLASH_WriteEnable(void);
Nextern void SPI_FLASH_WaitForWriteEnd(void);
Nextern void W25QXX_Write_Enable(void);
Nextern void W25QXX_Write_Disable(void);
Nextern void W25QXX_Write_SR(u8 sr);
Nextern u8 W25QXX_ReadSR(u8 StatusReg);
N#endif /* __SPI_FLASH_H */
N
L 51 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "./adc/bsp_adc.h"
L 1 "..\..\Complex\./adc/bsp_adc.h" 1
N#ifndef __BSP_ADC_H
N#define	__BSP_ADC_H
N
N#include "stm32f4xx.h"
N#include "stm32f4xx_adc.h"
N#include "stm32f4xx_dma.h"
N
N// ADC GPIO 宏定义
N#define RHEOSTAT_ADC_GPIO_PORT    GPIOB
N#define RHEOSTAT_ADC_GPIO_PIN     GPIO_Pin_1
N#define RHEOSTAT_ADC_GPIO_CLK     RCC_AHB1Periph_GPIOB
N
N// ADC 序号宏定义
N#define RHEOSTAT_ADC              ADC1
N#define RHEOSTAT_ADC_CLK          RCC_APB2Periph_ADC1
N#define RHEOSTAT_ADC_CHANNEL      ADC_Channel_9
N
N// ADC DR寄存器宏定义，ADC转换后的数字值则存放在这里
N#define RHEOSTAT_ADC_DR_ADDR    ((u32)ADC1+0x4c)
N
N// ADC DMA 通道宏定义，这里我们使用DMA传输
N#define RHEOSTAT_ADC_DMA_CLK      RCC_AHB1Periph_DMA2
N#define RHEOSTAT_ADC_DMA_CHANNEL  DMA_Channel_0
N#define RHEOSTAT_ADC_DMA_STREAM   DMA2_Stream0
N
Nextern __IO uint16_t ADC_ConvertedValue;//ADC1
Xextern volatile uint16_t ADC_ConvertedValue;
N
Nvoid Rheostat_Init(void);
N
N#endif /* __BSP_ADC_H */
N
N
N
L 52 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "./wdata/wdata.h" 
N#include "./iwdg/bsp_iwdg.h"   
L 1 "..\..\Complex\./iwdg/bsp_iwdg.h" 1
N#ifndef __IWDG_H
N#define	__IWDG_H
N
N#include "stm32f4xx.h"
N
N
Nvoid IWDG_Config(uint8_t prv ,uint16_t rlv);
Nvoid IWDG_Feed(void);
N
N#endif /* __IWDG_H */
N
L 54 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "./rcc/bsp_clkconfig.h"
L 1 "..\..\Complex\./rcc/bsp_clkconfig.h" 1
N#ifndef __CLKCONFIG_H
N#define	__CLKCONFIG_H
N
N
N#include "stm32f4xx.h"
Nvoid HSE_SetSysClock(uint32_t m, uint32_t n, uint32_t p, uint32_t q);
Nvoid HSI_SetSysClock(uint32_t m, uint32_t n, uint32_t p, uint32_t q);
Nvoid MCO1_GPIO_Config(void);
Nvoid MCO2_GPIO_Config(void);
N
N#endif /* __CLKCONFIG_H */
L 55 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "stm32f4xx_iwdg.h"
N
N/*STM32库文件*/
N#include "stm32f4xx.h"
N#include "stm32f4xx_it.h"
L 1 "..\..\Service\stm32f4xx_it.h" 1
N/**
N  ******************************************************************************
N  * @file    Project/STM32F4xx_StdPeriph_Templates/stm32f4xx_it.h 
N  * @author  MCD Application Team
N  * @version V1.5.0
N  * @date    06-March-2015
N  * @brief   This file contains the headers of the interrupt handlers.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2015 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F4xx_IT_H
N#define __STM32F4xx_IT_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N/* Includes ------------------------------------------------------------------*/
N#include "Include.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N 
N//#define USART_PRINTF
N#define FREE_RTOS  1
N 
N 
N
Nextern u8 volatile receive_flag;
Nextern uint8_t volatile update_sec;
Nextern uint32_t ulong;
N
N
N
Nvoid NMI_Handler(void);
Nvoid HardFault_Handler(void);
Nvoid MemManage_Handler(void);
Nvoid BusFault_Handler(void);
Nvoid UsageFault_Handler(void);
Nvoid DebugMon_Handler(void);
N#if (0 == FREE_RTOS)
X#if (0 == 1)
Svoid SVC_Handler(void);
Svoid PendSV_Handler(void);
Svoid SysTick_Handler(void);
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F4xx_IT_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 60 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "stm32f4xx_usart.h"
N#include "stm32f4xx_exti.h"
N#include "stm32f429_eth.h"
L 1 "..\..\Lwip\Bsp\LAN8742A\stm32f429_eth.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4x7_eth.h
N  * @author  MCD Application Team
N  * @version V1.1.0
N  * @date    31-July-2013
N  * @brief   This file contains all the functions prototypes for the Ethernet
N  *          firmware driver.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F429_ETH_H
N#define __STM32F429_ETH_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f429_eth_conf.h"
L 1 "..\..\Lwip\Bsp\LAN8742A\stm32f429_eth_conf.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4x7_eth_conf_template.h
N  * @author  MCD Application Team
N  * @version V1.1.0
N  * @date    31-July-2013
N  * @brief   Configuration file for the STM32F4x7xx Ethernet driver.
N  *          This file should be copied to the application folder and renamed to
N  *          stm32f4x7_eth_conf.h    
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F429_ETH_CONF_H
N#define __STM32F429_ETH_CONF_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f4xx.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/* Uncomment the line below when using time stamping and/or IPv4 checksum offload */
N#define USE_ENHANCED_DMA_DESCRIPTORS
N
N/* Uncomment the line below if you want to use user defined Delay function
N   (for precise timing), otherwise default _eth_delay_ function defined within
N   the Ethernet driver is used (less precise timing) */
N//#define USE_Delay
N
N#ifdef USE_Delay
S  #include "./Bsp/systick/bsp_SysTick.h"                /* Header file where the Delay function prototype is exported */  
S  #define _eth_delay_    Delay_10ms     /* User can provide more timing precise _eth_delay_ function
S                                      ex. use Systick with time base of 10 ms (as done in the provided 
S                                      STM32F4x7xx demonstrations) */
N#else
N  extern void ETH_Delay(__IO uint32_t nCount);
X  extern void ETH_Delay(volatile uint32_t nCount);
N  #define _eth_delay_    ETH_Delay /* Default _eth_delay_ function with less precise timing */
N#endif
N
N/* Uncomment the line below to allow custom configuration of the Ethernet driver buffers */    
N#define CUSTOM_DRIVER_BUFFERS_CONFIG   
N
N#ifdef  CUSTOM_DRIVER_BUFFERS_CONFIG
N/* Redefinition of the Ethernet driver buffers size and count */   
N #define ETH_RX_BUF_SIZE    1524 /* buffer size for receive */
N #define ETH_TX_BUF_SIZE    1524 /* buffer size for transmit */
N #define ETH_RXBUFNB        16                  /* 16 Rx buffers of size ETH_RX_BUF_SIZE */
N #define ETH_TXBUFNB        8                   /* 8  Tx buffers of size ETH_TX_BUF_SIZE */
N#endif
N
N
N/* PHY configuration section **************************************************/
N#ifdef USE_Delay
S/* PHY Reset delay */ 
S#define PHY_RESET_DELAY         ((uint32_t)0x000000FF)
S/* PHY Configuration delay */
S#define PHY_CONFIG_DELAY        ((uint32_t)0x00000FFF)
S/* Delay when writing to Ethernet registers*/
S#define ETH_REG_WRITE_DELAY     ((uint32_t)0x00000001)
S/* LAN8742A Reset delay */ 
S#define LAN8742A_RESET_DELAY    ((uint32_t)0x00000005)
N#else
N/* PHY Reset delay */ 
N#define PHY_RESET_DELAY         ((uint32_t)0x000FFFFF)
N/* PHY Configuration delay */ 
N#define PHY_CONFIG_DELAY        ((uint32_t)0x00FFFFFF)
N/* Delay when writing to Ethernet registers*/
N#define ETH_REG_WRITE_DELAY     ((uint32_t)0x0000FFFF)
N/* LAN8742A Reset delay */ 
N#define LAN8742A_RESET_DELAY    ((uint32_t)0x00FFFFFF)
N#endif
N
N/*******************  PHY Extended Registers section : ************************/
N
N/* These values are relatives to LAN8742A PHY and change from PHY to another,
N   so the user have to update this value depending on the used external PHY */   
N
N/* The LAN8742A PHY status register  */
N#define PHY_SR                 ((uint16_t)0x001F) /* PHY status register Offset */
N#define PHY_SPEED_STATUS       ((uint16_t)0x0004) /* PHY Speed mask  1:10Mb/s       0:100Mb/s*/
N#define PHY_DUPLEX_STATUS      ((uint16_t)0x0010) /* PHY Duplex mask 1:Full duplex  0:Half duplex*/
N
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F429_ETH_CONF_H */
N
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 39 "..\..\Lwip\Bsp\LAN8742A\stm32f429_eth.h" 2
N
N/** @defgroup ETH_Exported_Types
N  * @{
N  */
N
N/** 
N  * @brief  ETH MAC Init structure definition
N  * @note   The user should not configure all the ETH_InitTypeDef structure's fields. 
N  *   By calling the ETH_StructInit function the structures fields are set to their default values.
N  *   Only the parameters that will be set to a non-default value should be configured.  
N  */ 
Ntypedef struct {
N/** 
N  * @brief / * MAC  
N  */ 
N  uint32_t             ETH_AutoNegotiation;           /*!< Selects or not the AutoNegotiation mode for the external PHY
N                                                           The AutoNegotiation allows an automatic setting of the Speed (10/100Mbps)
N                                                           and the mode (half/full-duplex).
N                                                           This parameter can be a value of @ref ETH_AutoNegotiation */
N
N  uint32_t             ETH_Watchdog;                  /*!< Selects or not the Watchdog timer
N                                                           When enabled, the MAC allows no more then 2048 bytes to be received.
N                                                           When disabled, the MAC can receive up to 16384 bytes.
N                                                           This parameter can be a value of @ref ETH_watchdog */  
N
N  uint32_t             ETH_Jabber;                    /*!< Selects or not Jabber timer
N                                                           When enabled, the MAC allows no more then 2048 bytes to be sent.
N                                                           When disabled, the MAC can send up to 16384 bytes.
N                                                           This parameter can be a value of @ref ETH_Jabber */
N
N  uint32_t             ETH_InterFrameGap;             /*!< Selects the minimum IFG between frames during transmission
N                                                           This parameter can be a value of @ref ETH_Inter_Frame_Gap */   
N
N  uint32_t             ETH_CarrierSense;              /*!< Selects or not the Carrier Sense
N                                                           This parameter can be a value of @ref ETH_Carrier_Sense */
N
N  uint32_t             ETH_Speed;                     /*!< Sets the Ethernet speed: 10/100 Mbps
N                                                           This parameter can be a value of @ref ETH_Speed */
N
N  uint32_t             ETH_ReceiveOwn;                /*!< Selects or not the ReceiveOwn
N                                                           ReceiveOwn allows the reception of frames when the TX_EN signal is asserted
N                                                           in Half-Duplex mode
N                                                           This parameter can be a value of @ref ETH_Receive_Own */  
N
N  uint32_t             ETH_LoopbackMode;              /*!< Selects or not the internal MAC MII Loopback mode
N                                                           This parameter can be a value of @ref ETH_Loop_Back_Mode */  
N
N  uint32_t             ETH_Mode;                      /*!< Selects the MAC duplex mode: Half-Duplex or Full-Duplex mode
N                                                           This parameter can be a value of @ref ETH_Duplex_Mode */  
N
N  uint32_t             ETH_ChecksumOffload;           /*!< Selects or not the IPv4 checksum checking for received frame payloads' TCP/UDP/ICMP headers.
N                                                           This parameter can be a value of @ref ETH_Checksum_Offload */    
N
N  uint32_t             ETH_RetryTransmission;         /*!< Selects or not the MAC attempt retries transmission, based on the settings of BL,
N                                                           when a collision occurs (Half-Duplex mode)
N                                                           This parameter can be a value of @ref ETH_Retry_Transmission */
N
N  uint32_t             ETH_AutomaticPadCRCStrip;      /*!< Selects or not the Automatic MAC Pad/CRC Stripping
N                                                           This parameter can be a value of @ref ETH_Automatic_Pad_CRC_Strip */ 
N
N  uint32_t             ETH_BackOffLimit;              /*!< Selects the BackOff limit value
N                                                           This parameter can be a value of @ref ETH_Back_Off_Limit */
N
N  uint32_t             ETH_DeferralCheck;             /*!< Selects or not the deferral check function (Half-Duplex mode)
N                                                           This parameter can be a value of @ref ETH_Deferral_Check */                                                                                                        
N
N  uint32_t             ETH_ReceiveAll;                /*!< Selects or not all frames reception by the MAC (No filtering)
N                                                           This parameter can be a value of @ref ETH_Receive_All */   
N
N  uint32_t             ETH_SourceAddrFilter;          /*!< Selects the Source Address Filter mode                                                           
N                                                           This parameter can be a value of @ref ETH_Source_Addr_Filter */                  
N
N  uint32_t             ETH_PassControlFrames;         /*!< Sets the forwarding mode of the control frames (including unicast and multicast PAUSE frames)                                                          
N                                                           This parameter can be a value of @ref ETH_Pass_Control_Frames */ 
N
N  uint32_t             ETH_BroadcastFramesReception;  /*!< Selects or not the reception of Broadcast Frames
N                                                           This parameter can be a value of @ref ETH_Broadcast_Frames_Reception */
N
N  uint32_t             ETH_DestinationAddrFilter;     /*!< Sets the destination filter mode for both unicast and multicast frames
N                                                           This parameter can be a value of @ref ETH_Destination_Addr_Filter */ 
N
N  uint32_t             ETH_PromiscuousMode;           /*!< Selects or not the Promiscuous Mode
N                                                           This parameter can be a value of @ref ETH_Promiscuous_Mode */
N
N  uint32_t             ETH_MulticastFramesFilter;     /*!< Selects the Multicast Frames filter mode: None/HashTableFilter/PerfectFilter/PerfectHashTableFilter
N                                                           This parameter can be a value of @ref ETH_Multicast_Frames_Filter */ 
N
N  uint32_t             ETH_UnicastFramesFilter;       /*!< Selects the Unicast Frames filter mode: HashTableFilter/PerfectFilter/PerfectHashTableFilter
N                                                           This parameter can be a value of @ref ETH_Unicast_Frames_Filter */ 
N
N  uint32_t             ETH_HashTableHigh;             /*!< This field holds the higher 32 bits of Hash table.  */    
N
N  uint32_t             ETH_HashTableLow;              /*!< This field holds the lower 32 bits of Hash table.  */    
N
N  uint32_t             ETH_PauseTime;                 /*!< This field holds the value to be used in the Pause Time field in the
N                                                           transmit control frame */
N
N  uint32_t             ETH_ZeroQuantaPause;           /*!< Selects or not the automatic generation of Zero-Quanta Pause Control frames
N                                                           This parameter can be a value of @ref ETH_Zero_Quanta_Pause */  
N
N  uint32_t             ETH_PauseLowThreshold;         /*!< This field configures the threshold of the PAUSE to be checked for
N                                                           automatic retransmission of PAUSE Frame
N                                                           This parameter can be a value of @ref ETH_Pause_Low_Threshold */
N                                                           
N  uint32_t             ETH_UnicastPauseFrameDetect;   /*!< Selects or not the MAC detection of the Pause frames (with MAC Address0
N                                                           unicast address and unique multicast address)
N                                                           This parameter can be a value of @ref ETH_Unicast_Pause_Frame_Detect */  
N
N  uint32_t             ETH_ReceiveFlowControl;        /*!< Enables or disables the MAC to decode the received Pause frame and
N                                                           disable its transmitter for a specified time (Pause Time)
N                                                           This parameter can be a value of @ref ETH_Receive_Flow_Control */
N
N  uint32_t             ETH_TransmitFlowControl;       /*!< Enables or disables the MAC to transmit Pause frames (Full-Duplex mode)
N                                                           or the MAC back-pressure operation (Half-Duplex mode)
N                                                           This parameter can be a value of @ref ETH_Transmit_Flow_Control */     
N
N  uint32_t             ETH_VLANTagComparison;         /*!< Selects the 12-bit VLAN identifier or the complete 16-bit VLAN tag for
N                                                           comparison and filtering
N                                                           This parameter can be a value of @ref ETH_VLAN_Tag_Comparison */ 
N
N  uint32_t             ETH_VLANTagIdentifier;         /*!< Holds the VLAN tag identifier for receive frames */
N
N/** 
N  * @brief / * DMA  
N  */ 
N
N  uint32_t             ETH_DropTCPIPChecksumErrorFrame; /*!< Selects or not the Dropping of TCP/IP Checksum Error Frames
N                                                             This parameter can be a value of @ref ETH_Drop_TCP_IP_Checksum_Error_Frame */ 
N
N  uint32_t             ETH_ReceiveStoreForward;         /*!< Enables or disables the Receive store and forward mode
N                                                             This parameter can be a value of @ref ETH_Receive_Store_Forward */ 
N
N  uint32_t             ETH_FlushReceivedFrame;          /*!< Enables or disables the flushing of received frames
N                                                             This parameter can be a value of @ref ETH_Flush_Received_Frame */ 
N
N  uint32_t             ETH_TransmitStoreForward;        /*!< Enables or disables Transmit store and forward mode
N                                                             This parameter can be a value of @ref ETH_Transmit_Store_Forward */ 
N
N  uint32_t             ETH_TransmitThresholdControl;    /*!< Selects or not the Transmit Threshold Control
N                                                             This parameter can be a value of @ref ETH_Transmit_Threshold_Control */
N
N  uint32_t             ETH_ForwardErrorFrames;          /*!< Selects or not the forward to the DMA of erroneous frames
N                                                             This parameter can be a value of @ref ETH_Forward_Error_Frames */
N
N  uint32_t             ETH_ForwardUndersizedGoodFrames; /*!< Enables or disables the Rx FIFO to forward Undersized frames (frames with no Error
N                                                             and length less than 64 bytes) including pad-bytes and CRC)
N                                                             This parameter can be a value of @ref ETH_Forward_Undersized_Good_Frames */
N
N  uint32_t             ETH_ReceiveThresholdControl;     /*!< Selects the threshold level of the Receive FIFO
N                                                             This parameter can be a value of @ref ETH_Receive_Threshold_Control */
N
N  uint32_t             ETH_SecondFrameOperate;          /*!< Selects or not the Operate on second frame mode, which allows the DMA to process a second
N                                                             frame of Transmit data even before obtaining the status for the first frame.
N                                                             This parameter can be a value of @ref ETH_Second_Frame_Operate */
N
N  uint32_t             ETH_AddressAlignedBeats;         /*!< Enables or disables the Address Aligned Beats
N                                                             This parameter can be a value of @ref ETH_Address_Aligned_Beats */
N
N  uint32_t             ETH_FixedBurst;                  /*!< Enables or disables the AHB Master interface fixed burst transfers
N                                                             This parameter can be a value of @ref ETH_Fixed_Burst */
N                       
N  uint32_t             ETH_RxDMABurstLength;            /*!< Indicates the maximum number of beats to be transferred in one Rx DMA transaction
N                                                             This parameter can be a value of @ref ETH_Rx_DMA_Burst_Length */ 
N
N  uint32_t             ETH_TxDMABurstLength;            /*!< Indicates the maximum number of beats to be transferred in one Tx DMA transaction
N                                                             This parameter can be a value of @ref ETH_Tx_DMA_Burst_Length */                                                   
N
N  uint32_t             ETH_DescriptorSkipLength;        /*!< Specifies the number of word to skip between two unchained descriptors (Ring mode) */                                                             
N
N  uint32_t             ETH_DMAArbitration;              /*!< Selects the DMA Tx/Rx arbitration
N                                                             This parameter can be a value of @ref ETH_DMA_Arbitration */  
N}ETH_InitTypeDef;
N
N/**--------------------------------------------------------------------------**/
N/** 
N  * @brief                           DMA descriptors types
N  */ 
N/**--------------------------------------------------------------------------**/
N
N/** 
N  * @brief  ETH DMA Descriptors data structure definition
N  */ 
Ntypedef struct  {
N  __IO uint32_t   Status;                /*!< Status */
X  volatile uint32_t   Status;                 
N  uint32_t   ControlBufferSize;     /*!< Control and Buffer1, Buffer2 lengths */
N  uint32_t   Buffer1Addr;           /*!< Buffer1 address pointer */
N  uint32_t   Buffer2NextDescAddr;   /*!< Buffer2 or next descriptor address pointer */
N/* Enhanced ETHERNET DMA PTP Descriptors */
N#ifdef USE_ENHANCED_DMA_DESCRIPTORS
N  uint32_t   ExtendedStatus;        /* Extended status for PTP receive descriptor */
N  uint32_t   Reserved1;             /* Reserved */
N  uint32_t   TimeStampLow;          /* Time Stamp Low value for transmit and receive */
N  uint32_t   TimeStampHigh;         /* Time Stamp High value for transmit and receive */
N#endif /* USE_ENHANCED_DMA_DESCRIPTORS */
N} ETH_DMADESCTypeDef;
N
N
Ntypedef struct{
N  u32 length;
N  u32 buffer;
N  __IO ETH_DMADESCTypeDef *descriptor;
X  volatile ETH_DMADESCTypeDef *descriptor;
N}FrameTypeDef;
N
N
Ntypedef struct  {
N  __IO ETH_DMADESCTypeDef *FS_Rx_Desc;          /*!< First Segment Rx Desc */
X  volatile ETH_DMADESCTypeDef *FS_Rx_Desc;           
N  __IO ETH_DMADESCTypeDef *LS_Rx_Desc;          /*!< Last Segment Rx Desc */
X  volatile ETH_DMADESCTypeDef *LS_Rx_Desc;           
N  __IO uint32_t  Seg_Count;                     /*!< Segment count */
X  volatile uint32_t  Seg_Count;                      
N} ETH_DMA_Rx_Frame_infos;
N  
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Exported_Constants
N  * @{
N  */ 
N 
N/**--------------------------------------------------------------------------**/
N/** 
N  * @brief                          ETH Frames defines
N  */ 
N/**--------------------------------------------------------------------------**/
N
N/** @defgroup ENET_Buffers_setting 
N  * @{
N  */ 
N#define ETH_MAX_PACKET_SIZE    1524    /*!< ETH_HEADER + ETH_EXTRA + VLAN_TAG + MAX_ETH_PAYLOAD + ETH_CRC */
N#define ETH_HEADER               14    /*!< 6 byte Dest addr, 6 byte Src addr, 2 byte length/type */
N#define ETH_CRC                   4    /*!< Ethernet CRC */
N#define ETH_EXTRA                 2    /*!< Extra bytes in some cases */   
N#define VLAN_TAG                  4    /*!< optional 802.1q VLAN Tag */
N#define MIN_ETH_PAYLOAD          46    /*!< Minimum Ethernet payload size */
N#define MAX_ETH_PAYLOAD        1500    /*!< Maximum Ethernet payload size */
N#define JUMBO_FRAME_PAYLOAD    9000    /*!< Jumbo frame payload size */      
N
N /* Ethernet driver receive buffers are organized in a chained linked-list, when
N    an ethernet packet is received, the Rx-DMA will transfer the packet from RxFIFO
N    to the driver receive buffers memory.
N    
N    Depending on the size of the received ethernet packet and the size of 
N    each ethernet driver receive buffer, the received packet can take one or more
N    ethernet driver receive buffer. 
N    
N    In below are defined the size of one ethernet driver receive buffer ETH_RX_BUF_SIZE 
N    and the total count of the driver receive buffers ETH_RXBUFNB.
N    
N    The configured value for ETH_RX_BUF_SIZE and ETH_RXBUFNB are only provided as 
N    example, they can be reconfigured in the application layer to fit the application 
N    needs */ 
N   
N/* Here we configure each Ethernet driver receive buffer to fit the Max size Ethernet
N   packet */    
N#ifndef ETH_RX_BUF_SIZE
S #define ETH_RX_BUF_SIZE         ETH_MAX_PACKET_SIZE 
N#endif
N
N/* 5 Ethernet driver receive buffers are used (in a chained linked list)*/ 
N#ifndef ETH_RXBUFNB
S #define ETH_RXBUFNB             5     /*  5 Rx buffers of size ETH_RX_BUF_SIZE */
N#endif
N
N
N /* Ethernet driver transmit buffers are organized in a chained linked-list, when
N    an ethernet packet is transmitted, Tx-DMA will transfer the packet from the 
N    driver transmit buffers memory to the TxFIFO.
N    
N    Depending on the size of the Ethernet packet to be transmitted and the size of 
N    each ethernet driver transmit buffer, the packet to be transmitted can take 
N    one or more ethernet driver transmit buffer. 
N    
N    In below are defined the size of one ethernet driver transmit buffer ETH_TX_BUF_SIZE 
N    and the total count of the driver transmit buffers ETH_TXBUFNB.
N    
N    The configured value for ETH_TX_BUF_SIZE and ETH_TXBUFNB are only provided as 
N    example, they can be reconfigured in the application layer to fit the application 
N    needs */ 
N   
N/* Here we configure each Ethernet driver transmit buffer to fit the Max size Ethernet
N   packet */  
N#ifndef ETH_TX_BUF_SIZE 
S #define ETH_TX_BUF_SIZE         ETH_MAX_PACKET_SIZE
N#endif
N
N/* 5 ethernet driver transmit buffers are used (in a chained linked list)*/ 
N#ifndef ETH_TXBUFNB
S #define ETH_TXBUFNB             5      /* 5  Tx buffers of size ETH_TX_BUF_SIZE */
N#endif
N
N#define  ETH_DMARxDesc_FrameLengthShift           16
N
N/**--------------------------------------------------------------------------**/
N/** 
N  * @brief                 Ethernet DMA descriptors registers bits definition
N  */ 
N/**--------------------------------------------------------------------------**/
N
N/**
N@code 
N   DMA Tx Desciptor
N  -----------------------------------------------------------------------------------------------
N  TDES0 | OWN(31) | CTRL[30:26] | Reserved[25:24] | CTRL[23:20] | Reserved[19:17] | Status[16:0] |
N  -----------------------------------------------------------------------------------------------
N  TDES1 | Reserved[31:29] | Buffer2 ByteCount[28:16] | Reserved[15:13] | Buffer1 ByteCount[12:0] |
N  -----------------------------------------------------------------------------------------------
N  TDES2 |                         Buffer1 Address [31:0]                                         |
N  -----------------------------------------------------------------------------------------------
N  TDES3 |                   Buffer2 Address [31:0] / Next Descriptor Address [31:0]              |
N  -----------------------------------------------------------------------------------------------
N@endcode
N*/
N
N/** 
N  * @brief  Bit definition of TDES0 register: DMA Tx descriptor status register
N  */ 
N#define ETH_DMATxDesc_OWN                     ((uint32_t)0x80000000)  /*!< OWN bit: descriptor is owned by DMA engine */
N#define ETH_DMATxDesc_IC                      ((uint32_t)0x40000000)  /*!< Interrupt on Completion */
N#define ETH_DMATxDesc_LS                      ((uint32_t)0x20000000)  /*!< Last Segment */
N#define ETH_DMATxDesc_FS                      ((uint32_t)0x10000000)  /*!< First Segment */
N#define ETH_DMATxDesc_DC                      ((uint32_t)0x08000000)  /*!< Disable CRC */
N#define ETH_DMATxDesc_DP                      ((uint32_t)0x04000000)  /*!< Disable Padding */
N#define ETH_DMATxDesc_TTSE                    ((uint32_t)0x02000000)  /*!< Transmit Time Stamp Enable */
N#define ETH_DMATxDesc_CIC                     ((uint32_t)0x00C00000)  /*!< Checksum Insertion Control: 4 cases */
N#define ETH_DMATxDesc_CIC_ByPass              ((uint32_t)0x00000000)  /*!< Do Nothing: Checksum Engine is bypassed */ 
N#define ETH_DMATxDesc_CIC_IPV4Header          ((uint32_t)0x00400000)  /*!< IPV4 header Checksum Insertion */ 
N#define ETH_DMATxDesc_CIC_TCPUDPICMP_Segment  ((uint32_t)0x00800000)  /*!< TCP/UDP/ICMP Checksum Insertion calculated over segment only */ 
N#define ETH_DMATxDesc_CIC_TCPUDPICMP_Full     ((uint32_t)0x00C00000)  /*!< TCP/UDP/ICMP Checksum Insertion fully calculated */ 
N#define ETH_DMATxDesc_TER                     ((uint32_t)0x00200000)  /*!< Transmit End of Ring */
N#define ETH_DMATxDesc_TCH                     ((uint32_t)0x00100000)  /*!< Second Address Chained */
N#define ETH_DMATxDesc_TTSS                    ((uint32_t)0x00020000)  /*!< Tx Time Stamp Status */
N#define ETH_DMATxDesc_IHE                     ((uint32_t)0x00010000)  /*!< IP Header Error */
N#define ETH_DMATxDesc_ES                      ((uint32_t)0x00008000)  /*!< Error summary: OR of the following bits: UE || ED || EC || LCO || NC || LCA || FF || JT */
N#define ETH_DMATxDesc_JT                      ((uint32_t)0x00004000)  /*!< Jabber Timeout */
N#define ETH_DMATxDesc_FF                      ((uint32_t)0x00002000)  /*!< Frame Flushed: DMA/MTL flushed the frame due to SW flush */
N#define ETH_DMATxDesc_PCE                     ((uint32_t)0x00001000)  /*!< Payload Checksum Error */
N#define ETH_DMATxDesc_LCA                     ((uint32_t)0x00000800)  /*!< Loss of Carrier: carrier lost during transmission */
N#define ETH_DMATxDesc_NC                      ((uint32_t)0x00000400)  /*!< No Carrier: no carrier signal from the transceiver */
N#define ETH_DMATxDesc_LCO                     ((uint32_t)0x00000200)  /*!< Late Collision: transmission aborted due to collision */
N#define ETH_DMATxDesc_EC                      ((uint32_t)0x00000100)  /*!< Excessive Collision: transmission aborted after 16 collisions */
N#define ETH_DMATxDesc_VF                      ((uint32_t)0x00000080)  /*!< VLAN Frame */
N#define ETH_DMATxDesc_CC                      ((uint32_t)0x00000078)  /*!< Collision Count */
N#define ETH_DMATxDesc_ED                      ((uint32_t)0x00000004)  /*!< Excessive Deferral */
N#define ETH_DMATxDesc_UF                      ((uint32_t)0x00000002)  /*!< Underflow Error: late data arrival from the memory */
N#define ETH_DMATxDesc_DB                      ((uint32_t)0x00000001)  /*!< Deferred Bit */
N
N/** 
N  * @brief  Bit definition of TDES1 register
N  */ 
N#define ETH_DMATxDesc_TBS2  ((uint32_t)0x1FFF0000)  /*!< Transmit Buffer2 Size */
N#define ETH_DMATxDesc_TBS1  ((uint32_t)0x00001FFF)  /*!< Transmit Buffer1 Size */
N
N/** 
N  * @brief  Bit definition of TDES2 register
N  */ 
N#define ETH_DMATxDesc_B1AP  ((uint32_t)0xFFFFFFFF)  /*!< Buffer1 Address Pointer */
N
N/** 
N  * @brief  Bit definition of TDES3 register
N  */ 
N#define ETH_DMATxDesc_B2AP  ((uint32_t)0xFFFFFFFF)  /*!< Buffer2 Address Pointer */
N
N  /*---------------------------------------------------------------------------------------------
N  TDES6 |                         Transmit Time Stamp Low [31:0]                                 |
N  -----------------------------------------------------------------------------------------------
N  TDES7 |                         Transmit Time Stamp High [31:0]                                |
N  ----------------------------------------------------------------------------------------------*/
N
N/* Bit definition of TDES6 register */
N #define ETH_DMAPTPTxDesc_TTSL  ((uint32_t)0xFFFFFFFF)  /* Transmit Time Stamp Low */
N
N/* Bit definition of TDES7 register */
N #define ETH_DMAPTPTxDesc_TTSH  ((uint32_t)0xFFFFFFFF)  /* Transmit Time Stamp High */
N
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DMA_Rx_descriptor 
N  * @{
N  */
N
N/**
N@code 
N  DMA Rx Descriptor
N  --------------------------------------------------------------------------------------------------------------------
N  RDES0 | OWN(31) |                                             Status [30:0]                                          |
N  ---------------------------------------------------------------------------------------------------------------------
N  RDES1 | CTRL(31) | Reserved[30:29] | Buffer2 ByteCount[28:16] | CTRL[15:14] | Reserved(13) | Buffer1 ByteCount[12:0] |
N  ---------------------------------------------------------------------------------------------------------------------
N  RDES2 |                                       Buffer1 Address [31:0]                                                 |
N  ---------------------------------------------------------------------------------------------------------------------
N  RDES3 |                          Buffer2 Address [31:0] / Next Descriptor Address [31:0]                             |
N  ---------------------------------------------------------------------------------------------------------------------
N@endcode
N*/
N
N/** 
N  * @brief  Bit definition of RDES0 register: DMA Rx descriptor status register
N  */ 
N#define ETH_DMARxDesc_OWN         ((uint32_t)0x80000000)  /*!< OWN bit: descriptor is owned by DMA engine  */
N#define ETH_DMARxDesc_AFM         ((uint32_t)0x40000000)  /*!< DA Filter Fail for the rx frame  */
N#define ETH_DMARxDesc_FL          ((uint32_t)0x3FFF0000)  /*!< Receive descriptor frame length  */
N#define ETH_DMARxDesc_ES          ((uint32_t)0x00008000)  /*!< Error summary: OR of the following bits: DE || OE || IPC || LC || RWT || RE || CE */
N#define ETH_DMARxDesc_DE          ((uint32_t)0x00004000)  /*!< Descriptor error: no more descriptors for receive frame  */
N#define ETH_DMARxDesc_SAF         ((uint32_t)0x00002000)  /*!< SA Filter Fail for the received frame */
N#define ETH_DMARxDesc_LE          ((uint32_t)0x00001000)  /*!< Frame size not matching with length field */
N#define ETH_DMARxDesc_OE          ((uint32_t)0x00000800)  /*!< Overflow Error: Frame was damaged due to buffer overflow */
N#define ETH_DMARxDesc_VLAN        ((uint32_t)0x00000400)  /*!< VLAN Tag: received frame is a VLAN frame */
N#define ETH_DMARxDesc_FS          ((uint32_t)0x00000200)  /*!< First descriptor of the frame  */
N#define ETH_DMARxDesc_LS          ((uint32_t)0x00000100)  /*!< Last descriptor of the frame  */ 
N#define ETH_DMARxDesc_IPV4HCE     ((uint32_t)0x00000080)  /*!< IPC Checksum Error: Rx Ipv4 header checksum error   */    
N#define ETH_DMARxDesc_LC          ((uint32_t)0x00000040)  /*!< Late collision occurred during reception   */
N#define ETH_DMARxDesc_FT          ((uint32_t)0x00000020)  /*!< Frame type - Ethernet, otherwise 802.3    */
N#define ETH_DMARxDesc_RWT         ((uint32_t)0x00000010)  /*!< Receive Watchdog Timeout: watchdog timer expired during reception    */
N#define ETH_DMARxDesc_RE          ((uint32_t)0x00000008)  /*!< Receive error: error reported by MII interface  */
N#define ETH_DMARxDesc_DBE         ((uint32_t)0x00000004)  /*!< Dribble bit error: frame contains non int multiple of 8 bits  */
N#define ETH_DMARxDesc_CE          ((uint32_t)0x00000002)  /*!< CRC error */
N#define ETH_DMARxDesc_MAMPCE      ((uint32_t)0x00000001)  /*!< Rx MAC Address/Payload Checksum Error: Rx MAC address matched/ Rx Payload Checksum Error */
N
N/** 
N  * @brief  Bit definition of RDES1 register
N  */ 
N#define ETH_DMARxDesc_DIC   ((uint32_t)0x80000000)  /*!< Disable Interrupt on Completion */
N#define ETH_DMARxDesc_RBS2  ((uint32_t)0x1FFF0000)  /*!< Receive Buffer2 Size */
N#define ETH_DMARxDesc_RER   ((uint32_t)0x00008000)  /*!< Receive End of Ring */
N#define ETH_DMARxDesc_RCH   ((uint32_t)0x00004000)  /*!< Second Address Chained */
N#define ETH_DMARxDesc_RBS1  ((uint32_t)0x00001FFF)  /*!< Receive Buffer1 Size */
N
N/** 
N  * @brief  Bit definition of RDES2 register  
N  */ 
N#define ETH_DMARxDesc_B1AP  ((uint32_t)0xFFFFFFFF)  /*!< Buffer1 Address Pointer */
N
N/** 
N  * @brief  Bit definition of RDES3 register  
N  */ 
N#define ETH_DMARxDesc_B2AP  ((uint32_t)0xFFFFFFFF)  /*!< Buffer2 Address Pointer */
N
N/*---------------------------------------------------------------------------------------------------------------------
N  RDES4 |                   Reserved[31:15]              |             Extended Status [14:0]                          |
N  ---------------------------------------------------------------------------------------------------------------------
N  RDES5 |                                            Reserved[31:0]                                                    |
N  ---------------------------------------------------------------------------------------------------------------------
N  RDES6 |                                       Receive Time Stamp Low [31:0]                                          |
N  ---------------------------------------------------------------------------------------------------------------------
N  RDES7 |                                       Receive Time Stamp High [31:0]                                         |
N  --------------------------------------------------------------------------------------------------------------------*/
N
N/* Bit definition of RDES4 register */
N#define ETH_DMAPTPRxDesc_PTPV     ((uint32_t)0x00002000)  /* PTP Version */
N#define ETH_DMAPTPRxDesc_PTPFT    ((uint32_t)0x00001000)  /* PTP Frame Type */
N#define ETH_DMAPTPRxDesc_PTPMT    ((uint32_t)0x00000F00)  /* PTP Message Type */
N  #define ETH_DMAPTPRxDesc_PTPMT_Sync                      ((uint32_t)0x00000100)  /* SYNC message (all clock types) */
N  #define ETH_DMAPTPRxDesc_PTPMT_FollowUp                  ((uint32_t)0x00000200)  /* FollowUp message (all clock types) */ 
N  #define ETH_DMAPTPRxDesc_PTPMT_DelayReq                  ((uint32_t)0x00000300)  /* DelayReq message (all clock types) */ 
N  #define ETH_DMAPTPRxDesc_PTPMT_DelayResp                 ((uint32_t)0x00000400)  /* DelayResp message (all clock types) */ 
N  #define ETH_DMAPTPRxDesc_PTPMT_PdelayReq_Announce        ((uint32_t)0x00000500)  /* PdelayReq message (peer-to-peer transparent clock) or Announce message (Ordinary or Boundary clock) */ 
N  #define ETH_DMAPTPRxDesc_PTPMT_PdelayResp_Manag          ((uint32_t)0x00000600)  /* PdelayResp message (peer-to-peer transparent clock) or Management message (Ordinary or Boundary clock)  */ 
N  #define ETH_DMAPTPRxDesc_PTPMT_PdelayRespFollowUp_Signal ((uint32_t)0x00000700)  /* PdelayRespFollowUp message (peer-to-peer transparent clock) or Signaling message (Ordinary or Boundary clock) */           
N#define ETH_DMAPTPRxDesc_IPV6PR   ((uint32_t)0x00000080)  /* IPv6 Packet Received */
N#define ETH_DMAPTPRxDesc_IPV4PR   ((uint32_t)0x00000040)  /* IPv4 Packet Received */
N#define ETH_DMAPTPRxDesc_IPCB  ((uint32_t)0x00000020)  /* IP Checksum Bypassed */
N#define ETH_DMAPTPRxDesc_IPPE  ((uint32_t)0x00000010)  /* IP Payload Error */
N#define ETH_DMAPTPRxDesc_IPHE  ((uint32_t)0x00000008)  /* IP Header Error */
N#define ETH_DMAPTPRxDesc_IPPT  ((uint32_t)0x00000007)  /* IP Payload Type */
N  #define ETH_DMAPTPRxDesc_IPPT_UDP                 ((uint32_t)0x00000001)  /* UDP payload encapsulated in the IP datagram */
N  #define ETH_DMAPTPRxDesc_IPPT_TCP                 ((uint32_t)0x00000002)  /* TCP payload encapsulated in the IP datagram */ 
N  #define ETH_DMAPTPRxDesc_IPPT_ICMP                ((uint32_t)0x00000003)  /* ICMP payload encapsulated in the IP datagram */
N
N/* Bit definition of RDES6 register */
N#define ETH_DMAPTPRxDesc_RTSL  ((uint32_t)0xFFFFFFFF)  /* Receive Time Stamp Low */
N
N/* Bit definition of RDES7 register */
N#define ETH_DMAPTPRxDesc_RTSH  ((uint32_t)0xFFFFFFFF)  /* Receive Time Stamp High */
N
N
N/**--------------------------------------------------------------------------**/
N/** 
N  * @brief                     Description of common PHY registers
N  */ 
N/**--------------------------------------------------------------------------**/
N
N/**
N  * @}
N  */
N
N/** @defgroup PHY_Read_write_Timeouts 
N  * @{
N  */ 
N#define PHY_READ_TO                     ((uint32_t)0x0004FFFF)
N#define PHY_WRITE_TO                    ((uint32_t)0x0004FFFF)
N
N/**
N  * @}
N  */
N
N/** @defgroup PHY_Register_address 
N  * @{
N  */ 
N#define PHY_BCR                          0          /*!< Transceiver Basic Control Register */
N#define PHY_BSR                          1          /*!< Transceiver Basic Status Register */
N
N#define IS_ETH_PHY_ADDRESS(ADDRESS) ((ADDRESS) <= 0x20)
N#define IS_ETH_PHY_REG(REG) (((REG) == PHY_BCR) || \
N                             ((REG) == PHY_BSR) || \
N                             ((REG) == PHY_SR))
X#define IS_ETH_PHY_REG(REG) (((REG) == PHY_BCR) ||                              ((REG) == PHY_BSR) ||                              ((REG) == PHY_SR))
N/**
N  * @}
N  */
N
N/** @defgroup PHY_basic_Control_register 
N  * @{
N  */ 
N#define PHY_Reset                       ((uint16_t)0x8000)      /*!< PHY Reset */
N#define PHY_Loopback                    ((uint16_t)0x4000)      /*!< Select loop-back mode */
N#define PHY_FULLDUPLEX_100M             ((uint16_t)0x2100)      /*!< Set the full-duplex mode at 100 Mb/s */
N#define PHY_HALFDUPLEX_100M             ((uint16_t)0x2000)      /*!< Set the half-duplex mode at 100 Mb/s */
N#define PHY_FULLDUPLEX_10M              ((uint16_t)0x0100)      /*!< Set the full-duplex mode at 10 Mb/s */
N#define PHY_HALFDUPLEX_10M              ((uint16_t)0x0000)      /*!< Set the half-duplex mode at 10 Mb/s */
N#define PHY_AutoNegotiation             ((uint16_t)0x1000)      /*!< Enable auto-negotiation function */
N#define PHY_Restart_AutoNegotiation     ((uint16_t)0x0200)      /*!< Restart auto-negotiation function */
N#define PHY_Powerdown                   ((uint16_t)0x0800)      /*!< Select the power down mode */
N#define PHY_Isolate                     ((uint16_t)0x0400)      /*!< Isolate PHY from MII */
N
N/**
N  * @}
N  */
N
N/** @defgroup PHY_basic_status_register 
N  * @{
N  */ 
N#define PHY_AutoNego_Complete           ((uint16_t)0x0020)      /*!< Auto-Negotiation process completed */
N#define PHY_Linked_Status               ((uint16_t)0x0004)      /*!< Valid link established */
N#define PHY_Jabber_detection            ((uint16_t)0x0002)      /*!< Jabber condition detected */
N
N/**
N  * @}
N  */
N
N/**--------------------------------------------------------------------------**/
N/** 
N  * @brief                                  MAC defines
N  */ 
N/**--------------------------------------------------------------------------**/
N
N/** @defgroup ETH_AutoNegotiation 
N  * @{
N  */ 
N#define ETH_AutoNegotiation_Enable     ((uint32_t)0x00000001)
N#define ETH_AutoNegotiation_Disable    ((uint32_t)0x00000000)
N#define IS_ETH_AUTONEGOTIATION(CMD) (((CMD) == ETH_AutoNegotiation_Enable) || \
N                                     ((CMD) == ETH_AutoNegotiation_Disable))
X#define IS_ETH_AUTONEGOTIATION(CMD) (((CMD) == ETH_AutoNegotiation_Enable) ||                                      ((CMD) == ETH_AutoNegotiation_Disable))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_watchdog 
N  * @{
N  */ 
N#define ETH_Watchdog_Enable       ((uint32_t)0x00000000)
N#define ETH_Watchdog_Disable      ((uint32_t)0x00800000)
N#define IS_ETH_WATCHDOG(CMD) (((CMD) == ETH_Watchdog_Enable) || \
N                              ((CMD) == ETH_Watchdog_Disable))
X#define IS_ETH_WATCHDOG(CMD) (((CMD) == ETH_Watchdog_Enable) ||                               ((CMD) == ETH_Watchdog_Disable))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Jabber 
N  * @{
N  */ 
N#define ETH_Jabber_Enable    ((uint32_t)0x00000000)
N#define ETH_Jabber_Disable   ((uint32_t)0x00400000)
N#define IS_ETH_JABBER(CMD) (((CMD) == ETH_Jabber_Enable) || \
N                            ((CMD) == ETH_Jabber_Disable))
X#define IS_ETH_JABBER(CMD) (((CMD) == ETH_Jabber_Enable) ||                             ((CMD) == ETH_Jabber_Disable))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Inter_Frame_Gap 
N  * @{
N  */ 
N#define ETH_InterFrameGap_96Bit   ((uint32_t)0x00000000)  /*!< minimum IFG between frames during transmission is 96Bit */
N#define ETH_InterFrameGap_88Bit   ((uint32_t)0x00020000)  /*!< minimum IFG between frames during transmission is 88Bit */
N#define ETH_InterFrameGap_80Bit   ((uint32_t)0x00040000)  /*!< minimum IFG between frames during transmission is 80Bit */
N#define ETH_InterFrameGap_72Bit   ((uint32_t)0x00060000)  /*!< minimum IFG between frames during transmission is 72Bit */
N#define ETH_InterFrameGap_64Bit   ((uint32_t)0x00080000)  /*!< minimum IFG between frames during transmission is 64Bit */
N#define ETH_InterFrameGap_56Bit   ((uint32_t)0x000A0000)  /*!< minimum IFG between frames during transmission is 56Bit */
N#define ETH_InterFrameGap_48Bit   ((uint32_t)0x000C0000)  /*!< minimum IFG between frames during transmission is 48Bit */
N#define ETH_InterFrameGap_40Bit   ((uint32_t)0x000E0000)  /*!< minimum IFG between frames during transmission is 40Bit */
N#define IS_ETH_INTER_FRAME_GAP(GAP) (((GAP) == ETH_InterFrameGap_96Bit) || \
N                                     ((GAP) == ETH_InterFrameGap_88Bit) || \
N                                     ((GAP) == ETH_InterFrameGap_80Bit) || \
N                                     ((GAP) == ETH_InterFrameGap_72Bit) || \
N                                     ((GAP) == ETH_InterFrameGap_64Bit) || \
N                                     ((GAP) == ETH_InterFrameGap_56Bit) || \
N                                     ((GAP) == ETH_InterFrameGap_48Bit) || \
N                                     ((GAP) == ETH_InterFrameGap_40Bit))
X#define IS_ETH_INTER_FRAME_GAP(GAP) (((GAP) == ETH_InterFrameGap_96Bit) ||                                      ((GAP) == ETH_InterFrameGap_88Bit) ||                                      ((GAP) == ETH_InterFrameGap_80Bit) ||                                      ((GAP) == ETH_InterFrameGap_72Bit) ||                                      ((GAP) == ETH_InterFrameGap_64Bit) ||                                      ((GAP) == ETH_InterFrameGap_56Bit) ||                                      ((GAP) == ETH_InterFrameGap_48Bit) ||                                      ((GAP) == ETH_InterFrameGap_40Bit))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Carrier_Sense 
N  * @{
N  */ 
N#define ETH_CarrierSense_Enable   ((uint32_t)0x00000000)
N#define ETH_CarrierSense_Disable  ((uint32_t)0x00010000)
N#define IS_ETH_CARRIER_SENSE(CMD) (((CMD) == ETH_CarrierSense_Enable) || \
N                                   ((CMD) == ETH_CarrierSense_Disable))
X#define IS_ETH_CARRIER_SENSE(CMD) (((CMD) == ETH_CarrierSense_Enable) ||                                    ((CMD) == ETH_CarrierSense_Disable))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Speed 
N  * @{
N  */ 
N#define ETH_Speed_10M        ((uint32_t)0x00000000)
N#define ETH_Speed_100M       ((uint32_t)0x00004000)
N#define IS_ETH_SPEED(SPEED) (((SPEED) == ETH_Speed_10M) || \
N                             ((SPEED) == ETH_Speed_100M))
X#define IS_ETH_SPEED(SPEED) (((SPEED) == ETH_Speed_10M) ||                              ((SPEED) == ETH_Speed_100M))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Receive_Own 
N  * @{
N  */ 
N#define ETH_ReceiveOwn_Enable     ((uint32_t)0x00000000)
N#define ETH_ReceiveOwn_Disable    ((uint32_t)0x00002000)
N#define IS_ETH_RECEIVE_OWN(CMD) (((CMD) == ETH_ReceiveOwn_Enable) || \
N                                 ((CMD) == ETH_ReceiveOwn_Disable))
X#define IS_ETH_RECEIVE_OWN(CMD) (((CMD) == ETH_ReceiveOwn_Enable) ||                                  ((CMD) == ETH_ReceiveOwn_Disable))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Loop_Back_Mode 
N  * @{
N  */ 
N#define ETH_LoopbackMode_Enable        ((uint32_t)0x00001000)
N#define ETH_LoopbackMode_Disable       ((uint32_t)0x00000000)
N#define IS_ETH_LOOPBACK_MODE(CMD) (((CMD) == ETH_LoopbackMode_Enable) || \
N                                   ((CMD) == ETH_LoopbackMode_Disable))
X#define IS_ETH_LOOPBACK_MODE(CMD) (((CMD) == ETH_LoopbackMode_Enable) ||                                    ((CMD) == ETH_LoopbackMode_Disable))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Duplex_Mode 
N  * @{
N  */ 
N#define ETH_Mode_FullDuplex       ((uint32_t)0x00000800)
N#define ETH_Mode_HalfDuplex       ((uint32_t)0x00000000)
N#define IS_ETH_DUPLEX_MODE(MODE) (((MODE) == ETH_Mode_FullDuplex) || \
N                                  ((MODE) == ETH_Mode_HalfDuplex))
X#define IS_ETH_DUPLEX_MODE(MODE) (((MODE) == ETH_Mode_FullDuplex) ||                                   ((MODE) == ETH_Mode_HalfDuplex))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Checksum_Offload 
N  * @{
N  */ 
N#define ETH_ChecksumOffload_Enable     ((uint32_t)0x00000400)
N#define ETH_ChecksumOffload_Disable    ((uint32_t)0x00000000)
N#define IS_ETH_CHECKSUM_OFFLOAD(CMD) (((CMD) == ETH_ChecksumOffload_Enable) || \
N                                      ((CMD) == ETH_ChecksumOffload_Disable))
X#define IS_ETH_CHECKSUM_OFFLOAD(CMD) (((CMD) == ETH_ChecksumOffload_Enable) ||                                       ((CMD) == ETH_ChecksumOffload_Disable))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Retry_Transmission 
N  * @{
N  */ 
N#define ETH_RetryTransmission_Enable   ((uint32_t)0x00000000)
N#define ETH_RetryTransmission_Disable  ((uint32_t)0x00000200)
N#define IS_ETH_RETRY_TRANSMISSION(CMD) (((CMD) == ETH_RetryTransmission_Enable) || \
N                                        ((CMD) == ETH_RetryTransmission_Disable))
X#define IS_ETH_RETRY_TRANSMISSION(CMD) (((CMD) == ETH_RetryTransmission_Enable) ||                                         ((CMD) == ETH_RetryTransmission_Disable))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Automatic_Pad_CRC_Strip 
N  * @{
N  */ 
N#define ETH_AutomaticPadCRCStrip_Enable     ((uint32_t)0x00000080)
N#define ETH_AutomaticPadCRCStrip_Disable    ((uint32_t)0x00000000)
N#define IS_ETH_AUTOMATIC_PADCRC_STRIP(CMD) (((CMD) == ETH_AutomaticPadCRCStrip_Enable) || \
N                                            ((CMD) == ETH_AutomaticPadCRCStrip_Disable))
X#define IS_ETH_AUTOMATIC_PADCRC_STRIP(CMD) (((CMD) == ETH_AutomaticPadCRCStrip_Enable) ||                                             ((CMD) == ETH_AutomaticPadCRCStrip_Disable))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Back_Off_Limit 
N  * @{
N  */ 
N#define ETH_BackOffLimit_10  ((uint32_t)0x00000000)
N#define ETH_BackOffLimit_8   ((uint32_t)0x00000020)
N#define ETH_BackOffLimit_4   ((uint32_t)0x00000040)
N#define ETH_BackOffLimit_1   ((uint32_t)0x00000060)
N#define IS_ETH_BACKOFF_LIMIT(LIMIT) (((LIMIT) == ETH_BackOffLimit_10) || \
N                                     ((LIMIT) == ETH_BackOffLimit_8) || \
N                                     ((LIMIT) == ETH_BackOffLimit_4) || \
N                                     ((LIMIT) == ETH_BackOffLimit_1))
X#define IS_ETH_BACKOFF_LIMIT(LIMIT) (((LIMIT) == ETH_BackOffLimit_10) ||                                      ((LIMIT) == ETH_BackOffLimit_8) ||                                      ((LIMIT) == ETH_BackOffLimit_4) ||                                      ((LIMIT) == ETH_BackOffLimit_1))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Deferral_Check 
N  * @{
N  */
N#define ETH_DeferralCheck_Enable       ((uint32_t)0x00000010)
N#define ETH_DeferralCheck_Disable      ((uint32_t)0x00000000)
N#define IS_ETH_DEFERRAL_CHECK(CMD) (((CMD) == ETH_DeferralCheck_Enable) || \
N                                    ((CMD) == ETH_DeferralCheck_Disable))
X#define IS_ETH_DEFERRAL_CHECK(CMD) (((CMD) == ETH_DeferralCheck_Enable) ||                                     ((CMD) == ETH_DeferralCheck_Disable))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Receive_All 
N  * @{
N  */ 
N#define ETH_ReceiveAll_Enable     ((uint32_t)0x80000000)
N#define ETH_ReceiveAll_Disable    ((uint32_t)0x00000000)
N#define IS_ETH_RECEIVE_ALL(CMD) (((CMD) == ETH_ReceiveAll_Enable) || \
N                                 ((CMD) == ETH_ReceiveAll_Disable))
X#define IS_ETH_RECEIVE_ALL(CMD) (((CMD) == ETH_ReceiveAll_Enable) ||                                  ((CMD) == ETH_ReceiveAll_Disable))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Source_Addr_Filter 
N  * @{
N  */ 
N#define ETH_SourceAddrFilter_Normal_Enable       ((uint32_t)0x00000200)
N#define ETH_SourceAddrFilter_Inverse_Enable      ((uint32_t)0x00000300)
N#define ETH_SourceAddrFilter_Disable             ((uint32_t)0x00000000)
N#define IS_ETH_SOURCE_ADDR_FILTER(CMD) (((CMD) == ETH_SourceAddrFilter_Normal_Enable) || \
N                                        ((CMD) == ETH_SourceAddrFilter_Inverse_Enable) || \
N                                        ((CMD) == ETH_SourceAddrFilter_Disable))
X#define IS_ETH_SOURCE_ADDR_FILTER(CMD) (((CMD) == ETH_SourceAddrFilter_Normal_Enable) ||                                         ((CMD) == ETH_SourceAddrFilter_Inverse_Enable) ||                                         ((CMD) == ETH_SourceAddrFilter_Disable))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Pass_Control_Frames 
N  * @{
N  */ 
N#define ETH_PassControlFrames_BlockAll                ((uint32_t)0x00000040)  /*!< MAC filters all control frames from reaching the application */
N#define ETH_PassControlFrames_ForwardAll              ((uint32_t)0x00000080)  /*!< MAC forwards all control frames to application even if they fail the Address Filter */
N#define ETH_PassControlFrames_ForwardPassedAddrFilter ((uint32_t)0x000000C0)  /*!< MAC forwards control frames that pass the Address Filter. */ 
N#define IS_ETH_CONTROL_FRAMES(PASS) (((PASS) == ETH_PassControlFrames_BlockAll) || \
N                                     ((PASS) == ETH_PassControlFrames_ForwardAll) || \
N                                     ((PASS) == ETH_PassControlFrames_ForwardPassedAddrFilter))
X#define IS_ETH_CONTROL_FRAMES(PASS) (((PASS) == ETH_PassControlFrames_BlockAll) ||                                      ((PASS) == ETH_PassControlFrames_ForwardAll) ||                                      ((PASS) == ETH_PassControlFrames_ForwardPassedAddrFilter))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Broadcast_Frames_Reception 
N  * @{
N  */ 
N#define ETH_BroadcastFramesReception_Enable      ((uint32_t)0x00000000)
N#define ETH_BroadcastFramesReception_Disable     ((uint32_t)0x00000020)
N#define IS_ETH_BROADCAST_FRAMES_RECEPTION(CMD) (((CMD) == ETH_BroadcastFramesReception_Enable) || \
N                                                ((CMD) == ETH_BroadcastFramesReception_Disable))
X#define IS_ETH_BROADCAST_FRAMES_RECEPTION(CMD) (((CMD) == ETH_BroadcastFramesReception_Enable) ||                                                 ((CMD) == ETH_BroadcastFramesReception_Disable))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Destination_Addr_Filter 
N  * @{
N  */ 
N#define ETH_DestinationAddrFilter_Normal    ((uint32_t)0x00000000)
N#define ETH_DestinationAddrFilter_Inverse   ((uint32_t)0x00000008)
N#define IS_ETH_DESTINATION_ADDR_FILTER(FILTER) (((FILTER) == ETH_DestinationAddrFilter_Normal) || \
N                                                ((FILTER) == ETH_DestinationAddrFilter_Inverse))
X#define IS_ETH_DESTINATION_ADDR_FILTER(FILTER) (((FILTER) == ETH_DestinationAddrFilter_Normal) ||                                                 ((FILTER) == ETH_DestinationAddrFilter_Inverse))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Promiscuous_Mode 
N  * @{
N  */ 
N#define ETH_PromiscuousMode_Enable     ((uint32_t)0x00000001)
N#define ETH_PromiscuousMode_Disable    ((uint32_t)0x00000000)
N#define IS_ETH_PROMISCUOUS_MODE(CMD) (((CMD) == ETH_PromiscuousMode_Enable) || \
N                                      ((CMD) == ETH_PromiscuousMode_Disable))
X#define IS_ETH_PROMISCUOUS_MODE(CMD) (((CMD) == ETH_PromiscuousMode_Enable) ||                                       ((CMD) == ETH_PromiscuousMode_Disable))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Multicast_Frames_Filter 
N  * @{
N  */ 
N#define ETH_MulticastFramesFilter_PerfectHashTable    ((uint32_t)0x00000404)
N#define ETH_MulticastFramesFilter_HashTable           ((uint32_t)0x00000004)
N#define ETH_MulticastFramesFilter_Perfect             ((uint32_t)0x00000000)
N#define ETH_MulticastFramesFilter_None                ((uint32_t)0x00000010)
N#define IS_ETH_MULTICAST_FRAMES_FILTER(FILTER) (((FILTER) == ETH_MulticastFramesFilter_PerfectHashTable) || \
N                                                ((FILTER) == ETH_MulticastFramesFilter_HashTable) || \
N                                                ((FILTER) == ETH_MulticastFramesFilter_Perfect) || \
N                                                ((FILTER) == ETH_MulticastFramesFilter_None))
X#define IS_ETH_MULTICAST_FRAMES_FILTER(FILTER) (((FILTER) == ETH_MulticastFramesFilter_PerfectHashTable) ||                                                 ((FILTER) == ETH_MulticastFramesFilter_HashTable) ||                                                 ((FILTER) == ETH_MulticastFramesFilter_Perfect) ||                                                 ((FILTER) == ETH_MulticastFramesFilter_None))
N                                                     
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Unicast_Frames_Filter 
N  * @{
N  */ 
N#define ETH_UnicastFramesFilter_PerfectHashTable ((uint32_t)0x00000402)
N#define ETH_UnicastFramesFilter_HashTable        ((uint32_t)0x00000002)
N#define ETH_UnicastFramesFilter_Perfect          ((uint32_t)0x00000000)
N#define IS_ETH_UNICAST_FRAMES_FILTER(FILTER) (((FILTER) == ETH_UnicastFramesFilter_PerfectHashTable) || \
N                                              ((FILTER) == ETH_UnicastFramesFilter_HashTable) || \
N                                              ((FILTER) == ETH_UnicastFramesFilter_Perfect))
X#define IS_ETH_UNICAST_FRAMES_FILTER(FILTER) (((FILTER) == ETH_UnicastFramesFilter_PerfectHashTable) ||                                               ((FILTER) == ETH_UnicastFramesFilter_HashTable) ||                                               ((FILTER) == ETH_UnicastFramesFilter_Perfect))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Pause_Time 
N  * @{
N  */ 
N#define IS_ETH_PAUSE_TIME(TIME) ((TIME) <= 0xFFFF)
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Zero_Quanta_Pause 
N  * @{
N  */ 
N#define ETH_ZeroQuantaPause_Enable     ((uint32_t)0x00000000)
N#define ETH_ZeroQuantaPause_Disable    ((uint32_t)0x00000080)
N#define IS_ETH_ZEROQUANTA_PAUSE(CMD)   (((CMD) == ETH_ZeroQuantaPause_Enable) || \
N                                        ((CMD) == ETH_ZeroQuantaPause_Disable))
X#define IS_ETH_ZEROQUANTA_PAUSE(CMD)   (((CMD) == ETH_ZeroQuantaPause_Enable) ||                                         ((CMD) == ETH_ZeroQuantaPause_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Pause_Low_Threshold 
N  * @{
N  */ 
N#define ETH_PauseLowThreshold_Minus4        ((uint32_t)0x00000000)  /*!< Pause time minus 4 slot times */
N#define ETH_PauseLowThreshold_Minus28       ((uint32_t)0x00000010)  /*!< Pause time minus 28 slot times */
N#define ETH_PauseLowThreshold_Minus144      ((uint32_t)0x00000020)  /*!< Pause time minus 144 slot times */
N#define ETH_PauseLowThreshold_Minus256      ((uint32_t)0x00000030)  /*!< Pause time minus 256 slot times */
N#define IS_ETH_PAUSE_LOW_THRESHOLD(THRESHOLD) (((THRESHOLD) == ETH_PauseLowThreshold_Minus4) || \
N                                               ((THRESHOLD) == ETH_PauseLowThreshold_Minus28) || \
N                                               ((THRESHOLD) == ETH_PauseLowThreshold_Minus144) || \
N                                               ((THRESHOLD) == ETH_PauseLowThreshold_Minus256))
X#define IS_ETH_PAUSE_LOW_THRESHOLD(THRESHOLD) (((THRESHOLD) == ETH_PauseLowThreshold_Minus4) ||                                                ((THRESHOLD) == ETH_PauseLowThreshold_Minus28) ||                                                ((THRESHOLD) == ETH_PauseLowThreshold_Minus144) ||                                                ((THRESHOLD) == ETH_PauseLowThreshold_Minus256))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Unicast_Pause_Frame_Detect 
N  * @{
N  */ 
N#define ETH_UnicastPauseFrameDetect_Enable  ((uint32_t)0x00000008)
N#define ETH_UnicastPauseFrameDetect_Disable ((uint32_t)0x00000000)
N#define IS_ETH_UNICAST_PAUSE_FRAME_DETECT(CMD) (((CMD) == ETH_UnicastPauseFrameDetect_Enable) || \
N                                                ((CMD) == ETH_UnicastPauseFrameDetect_Disable))
X#define IS_ETH_UNICAST_PAUSE_FRAME_DETECT(CMD) (((CMD) == ETH_UnicastPauseFrameDetect_Enable) ||                                                 ((CMD) == ETH_UnicastPauseFrameDetect_Disable))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Receive_Flow_Control 
N  * @{
N  */ 
N#define ETH_ReceiveFlowControl_Enable       ((uint32_t)0x00000004)
N#define ETH_ReceiveFlowControl_Disable      ((uint32_t)0x00000000)
N#define IS_ETH_RECEIVE_FLOWCONTROL(CMD) (((CMD) == ETH_ReceiveFlowControl_Enable) || \
N                                         ((CMD) == ETH_ReceiveFlowControl_Disable))
X#define IS_ETH_RECEIVE_FLOWCONTROL(CMD) (((CMD) == ETH_ReceiveFlowControl_Enable) ||                                          ((CMD) == ETH_ReceiveFlowControl_Disable))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Transmit_Flow_Control 
N  * @{
N  */ 
N#define ETH_TransmitFlowControl_Enable      ((uint32_t)0x00000002)
N#define ETH_TransmitFlowControl_Disable     ((uint32_t)0x00000000)
N#define IS_ETH_TRANSMIT_FLOWCONTROL(CMD) (((CMD) == ETH_TransmitFlowControl_Enable) || \
N                                          ((CMD) == ETH_TransmitFlowControl_Disable))
X#define IS_ETH_TRANSMIT_FLOWCONTROL(CMD) (((CMD) == ETH_TransmitFlowControl_Enable) ||                                           ((CMD) == ETH_TransmitFlowControl_Disable))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_VLAN_Tag_Comparison 
N  * @{
N  */ 
N#define ETH_VLANTagComparison_12Bit    ((uint32_t)0x00010000)
N#define ETH_VLANTagComparison_16Bit    ((uint32_t)0x00000000)
N#define IS_ETH_VLAN_TAG_COMPARISON(COMPARISON) (((COMPARISON) == ETH_VLANTagComparison_12Bit) || \
N                                                ((COMPARISON) == ETH_VLANTagComparison_16Bit))
X#define IS_ETH_VLAN_TAG_COMPARISON(COMPARISON) (((COMPARISON) == ETH_VLANTagComparison_12Bit) ||                                                 ((COMPARISON) == ETH_VLANTagComparison_16Bit))
N#define IS_ETH_VLAN_TAG_IDENTIFIER(IDENTIFIER) ((IDENTIFIER) <= 0xFFFF)
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_MAC_Flags 
N  * @{
N  */ 
N#define ETH_MAC_FLAG_TST     ((uint32_t)0x00000200)  /*!< Time stamp trigger flag (on MAC) */
N#define ETH_MAC_FLAG_MMCT    ((uint32_t)0x00000040)  /*!< MMC transmit flag  */
N#define ETH_MAC_FLAG_MMCR    ((uint32_t)0x00000020)  /*!< MMC receive flag */
N#define ETH_MAC_FLAG_MMC     ((uint32_t)0x00000010)  /*!< MMC flag (on MAC) */
N#define ETH_MAC_FLAG_PMT     ((uint32_t)0x00000008)  /*!< PMT flag (on MAC) */
N#define IS_ETH_MAC_GET_FLAG(FLAG) (((FLAG) == ETH_MAC_FLAG_TST) || ((FLAG) == ETH_MAC_FLAG_MMCT) || \
N                                   ((FLAG) == ETH_MAC_FLAG_MMCR) || ((FLAG) == ETH_MAC_FLAG_MMC) || \
N                                   ((FLAG) == ETH_MAC_FLAG_PMT))
X#define IS_ETH_MAC_GET_FLAG(FLAG) (((FLAG) == ETH_MAC_FLAG_TST) || ((FLAG) == ETH_MAC_FLAG_MMCT) ||                                    ((FLAG) == ETH_MAC_FLAG_MMCR) || ((FLAG) == ETH_MAC_FLAG_MMC) ||                                    ((FLAG) == ETH_MAC_FLAG_PMT))
N/**
N  * @}
N  */
N
N/** @defgroup ETH_MAC_Interrupts 
N  * @{
N  */ 
N#define ETH_MAC_IT_TST       ((uint32_t)0x00000200)  /*!< Time stamp trigger interrupt (on MAC) */
N#define ETH_MAC_IT_MMCT      ((uint32_t)0x00000040)  /*!< MMC transmit interrupt */
N#define ETH_MAC_IT_MMCR      ((uint32_t)0x00000020)  /*!< MMC receive interrupt */
N#define ETH_MAC_IT_MMC       ((uint32_t)0x00000010)  /*!< MMC interrupt (on MAC) */
N#define ETH_MAC_IT_PMT       ((uint32_t)0x00000008)  /*!< PMT interrupt (on MAC) */
N#define IS_ETH_MAC_IT(IT) ((((IT) & (uint32_t)0xFFFFFDF7) == 0x00) && ((IT) != 0x00))
N#define IS_ETH_MAC_GET_IT(IT) (((IT) == ETH_MAC_IT_TST) || ((IT) == ETH_MAC_IT_MMCT) || \
N                               ((IT) == ETH_MAC_IT_MMCR) || ((IT) == ETH_MAC_IT_MMC) || \
N                               ((IT) == ETH_MAC_IT_PMT))
X#define IS_ETH_MAC_GET_IT(IT) (((IT) == ETH_MAC_IT_TST) || ((IT) == ETH_MAC_IT_MMCT) ||                                ((IT) == ETH_MAC_IT_MMCR) || ((IT) == ETH_MAC_IT_MMC) ||                                ((IT) == ETH_MAC_IT_PMT))
N/**
N  * @}
N  */
N
N/** @defgroup ETH_MAC_addresses 
N  * @{
N  */ 
N#define ETH_MAC_Address0     ((uint32_t)0x00000000)
N#define ETH_MAC_Address1     ((uint32_t)0x00000008)
N#define ETH_MAC_Address2     ((uint32_t)0x00000010)
N#define ETH_MAC_Address3     ((uint32_t)0x00000018)
N#define IS_ETH_MAC_ADDRESS0123(ADDRESS) (((ADDRESS) == ETH_MAC_Address0) || \
N                                         ((ADDRESS) == ETH_MAC_Address1) || \
N                                         ((ADDRESS) == ETH_MAC_Address2) || \
N                                         ((ADDRESS) == ETH_MAC_Address3))
X#define IS_ETH_MAC_ADDRESS0123(ADDRESS) (((ADDRESS) == ETH_MAC_Address0) ||                                          ((ADDRESS) == ETH_MAC_Address1) ||                                          ((ADDRESS) == ETH_MAC_Address2) ||                                          ((ADDRESS) == ETH_MAC_Address3))
N#define IS_ETH_MAC_ADDRESS123(ADDRESS) (((ADDRESS) == ETH_MAC_Address1) || \
N                                        ((ADDRESS) == ETH_MAC_Address2) || \
N                                        ((ADDRESS) == ETH_MAC_Address3))
X#define IS_ETH_MAC_ADDRESS123(ADDRESS) (((ADDRESS) == ETH_MAC_Address1) ||                                         ((ADDRESS) == ETH_MAC_Address2) ||                                         ((ADDRESS) == ETH_MAC_Address3))
N/**
N  * @}
N  */
N
N/** @defgroup ETH_MAC_addresses_filter_SA_DA_filed_of_received_frames 
N  * @{
N  */ 
N#define ETH_MAC_AddressFilter_SA       ((uint32_t)0x00000000)
N#define ETH_MAC_AddressFilter_DA       ((uint32_t)0x00000008)
N#define IS_ETH_MAC_ADDRESS_FILTER(FILTER) (((FILTER) == ETH_MAC_AddressFilter_SA) || \
N                                           ((FILTER) == ETH_MAC_AddressFilter_DA))
X#define IS_ETH_MAC_ADDRESS_FILTER(FILTER) (((FILTER) == ETH_MAC_AddressFilter_SA) ||                                            ((FILTER) == ETH_MAC_AddressFilter_DA))
N/**
N  * @}
N  */
N
N/** @defgroup ETH_MAC_addresses_filter_Mask_bytes 
N  * @{
N  */ 
N#define ETH_MAC_AddressMask_Byte6      ((uint32_t)0x20000000)  /*!< Mask MAC Address high reg bits [15:8] */
N#define ETH_MAC_AddressMask_Byte5      ((uint32_t)0x10000000)  /*!< Mask MAC Address high reg bits [7:0] */
N#define ETH_MAC_AddressMask_Byte4      ((uint32_t)0x08000000)  /*!< Mask MAC Address low reg bits [31:24] */
N#define ETH_MAC_AddressMask_Byte3      ((uint32_t)0x04000000)  /*!< Mask MAC Address low reg bits [23:16] */
N#define ETH_MAC_AddressMask_Byte2      ((uint32_t)0x02000000)  /*!< Mask MAC Address low reg bits [15:8] */
N#define ETH_MAC_AddressMask_Byte1      ((uint32_t)0x01000000)  /*!< Mask MAC Address low reg bits [70] */
N#define IS_ETH_MAC_ADDRESS_MASK(MASK) (((MASK) == ETH_MAC_AddressMask_Byte6) || \
N                                       ((MASK) == ETH_MAC_AddressMask_Byte5) || \
N                                       ((MASK) == ETH_MAC_AddressMask_Byte4) || \
N                                       ((MASK) == ETH_MAC_AddressMask_Byte3) || \
N                                       ((MASK) == ETH_MAC_AddressMask_Byte2) || \
N                                       ((MASK) == ETH_MAC_AddressMask_Byte1))
X#define IS_ETH_MAC_ADDRESS_MASK(MASK) (((MASK) == ETH_MAC_AddressMask_Byte6) ||                                        ((MASK) == ETH_MAC_AddressMask_Byte5) ||                                        ((MASK) == ETH_MAC_AddressMask_Byte4) ||                                        ((MASK) == ETH_MAC_AddressMask_Byte3) ||                                        ((MASK) == ETH_MAC_AddressMask_Byte2) ||                                        ((MASK) == ETH_MAC_AddressMask_Byte1))
N
N/**--------------------------------------------------------------------------**/
N/** 
N  * @brief                      Ethernet DMA Descriptors defines
N  */ 
N/**--------------------------------------------------------------------------**/
N/**
N  * @}
N  */
N
N/** @defgroup ETH_DMA_Tx_descriptor_flags
N  * @{
N  */ 
N#define IS_ETH_DMATxDESC_GET_FLAG(FLAG) (((FLAG) == ETH_DMATxDesc_OWN) || \
N                                         ((FLAG) == ETH_DMATxDesc_IC) || \
N                                         ((FLAG) == ETH_DMATxDesc_LS) || \
N                                         ((FLAG) == ETH_DMATxDesc_FS) || \
N                                         ((FLAG) == ETH_DMATxDesc_DC) || \
N                                         ((FLAG) == ETH_DMATxDesc_DP) || \
N                                         ((FLAG) == ETH_DMATxDesc_TTSE) || \
N                                         ((FLAG) == ETH_DMATxDesc_TER) || \
N                                         ((FLAG) == ETH_DMATxDesc_TCH) || \
N                                         ((FLAG) == ETH_DMATxDesc_TTSS) || \
N                                         ((FLAG) == ETH_DMATxDesc_IHE) || \
N                                         ((FLAG) == ETH_DMATxDesc_ES) || \
N                                         ((FLAG) == ETH_DMATxDesc_JT) || \
N                                         ((FLAG) == ETH_DMATxDesc_FF) || \
N                                         ((FLAG) == ETH_DMATxDesc_PCE) || \
N                                         ((FLAG) == ETH_DMATxDesc_LCA) || \
N                                         ((FLAG) == ETH_DMATxDesc_NC) || \
N                                         ((FLAG) == ETH_DMATxDesc_LCO) || \
N                                         ((FLAG) == ETH_DMATxDesc_EC) || \
N                                         ((FLAG) == ETH_DMATxDesc_VF) || \
N                                         ((FLAG) == ETH_DMATxDesc_CC) || \
N                                         ((FLAG) == ETH_DMATxDesc_ED) || \
N                                         ((FLAG) == ETH_DMATxDesc_UF) || \
N                                         ((FLAG) == ETH_DMATxDesc_DB))
X#define IS_ETH_DMATxDESC_GET_FLAG(FLAG) (((FLAG) == ETH_DMATxDesc_OWN) ||                                          ((FLAG) == ETH_DMATxDesc_IC) ||                                          ((FLAG) == ETH_DMATxDesc_LS) ||                                          ((FLAG) == ETH_DMATxDesc_FS) ||                                          ((FLAG) == ETH_DMATxDesc_DC) ||                                          ((FLAG) == ETH_DMATxDesc_DP) ||                                          ((FLAG) == ETH_DMATxDesc_TTSE) ||                                          ((FLAG) == ETH_DMATxDesc_TER) ||                                          ((FLAG) == ETH_DMATxDesc_TCH) ||                                          ((FLAG) == ETH_DMATxDesc_TTSS) ||                                          ((FLAG) == ETH_DMATxDesc_IHE) ||                                          ((FLAG) == ETH_DMATxDesc_ES) ||                                          ((FLAG) == ETH_DMATxDesc_JT) ||                                          ((FLAG) == ETH_DMATxDesc_FF) ||                                          ((FLAG) == ETH_DMATxDesc_PCE) ||                                          ((FLAG) == ETH_DMATxDesc_LCA) ||                                          ((FLAG) == ETH_DMATxDesc_NC) ||                                          ((FLAG) == ETH_DMATxDesc_LCO) ||                                          ((FLAG) == ETH_DMATxDesc_EC) ||                                          ((FLAG) == ETH_DMATxDesc_VF) ||                                          ((FLAG) == ETH_DMATxDesc_CC) ||                                          ((FLAG) == ETH_DMATxDesc_ED) ||                                          ((FLAG) == ETH_DMATxDesc_UF) ||                                          ((FLAG) == ETH_DMATxDesc_DB))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_DMA_Tx_descriptor_segment 
N  * @{
N  */ 
N#define ETH_DMATxDesc_LastSegment      ((uint32_t)0x40000000)  /*!< Last Segment */
N#define ETH_DMATxDesc_FirstSegment     ((uint32_t)0x20000000)  /*!< First Segment */
N#define IS_ETH_DMA_TXDESC_SEGMENT(SEGMENT) (((SEGMENT) == ETH_DMATxDesc_LastSegment) || \
N                                            ((SEGMENT) == ETH_DMATxDesc_FirstSegment))
X#define IS_ETH_DMA_TXDESC_SEGMENT(SEGMENT) (((SEGMENT) == ETH_DMATxDesc_LastSegment) ||                                             ((SEGMENT) == ETH_DMATxDesc_FirstSegment))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_DMA_Tx_descriptor_Checksum_Insertion_Control
N  * @{
N  */ 
N#define ETH_DMATxDesc_ChecksumByPass             ((uint32_t)0x00000000)   /*!< Checksum engine bypass */
N#define ETH_DMATxDesc_ChecksumIPV4Header         ((uint32_t)0x00400000)   /*!< IPv4 header checksum insertion  */
N#define ETH_DMATxDesc_ChecksumTCPUDPICMPSegment  ((uint32_t)0x00800000)   /*!< TCP/UDP/ICMP checksum insertion. Pseudo header checksum is assumed to be present */
N#define ETH_DMATxDesc_ChecksumTCPUDPICMPFull     ((uint32_t)0x00C00000)   /*!< TCP/UDP/ICMP checksum fully in hardware including pseudo header */
N#define IS_ETH_DMA_TXDESC_CHECKSUM(CHECKSUM) (((CHECKSUM) == ETH_DMATxDesc_ChecksumByPass) || \
N                                              ((CHECKSUM) == ETH_DMATxDesc_ChecksumIPV4Header) || \
N                                              ((CHECKSUM) == ETH_DMATxDesc_ChecksumTCPUDPICMPSegment) || \
N                                              ((CHECKSUM) == ETH_DMATxDesc_ChecksumTCPUDPICMPFull))
X#define IS_ETH_DMA_TXDESC_CHECKSUM(CHECKSUM) (((CHECKSUM) == ETH_DMATxDesc_ChecksumByPass) ||                                               ((CHECKSUM) == ETH_DMATxDesc_ChecksumIPV4Header) ||                                               ((CHECKSUM) == ETH_DMATxDesc_ChecksumTCPUDPICMPSegment) ||                                               ((CHECKSUM) == ETH_DMATxDesc_ChecksumTCPUDPICMPFull))
N/** 
N  * @brief  ETH DMA Tx Desciptor buffer size
N  */ 
N#define IS_ETH_DMATxDESC_BUFFER_SIZE(SIZE) ((SIZE) <= 0x1FFF)
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_DMA_Rx_descriptor_flags
N  * @{
N  */ 
N#define IS_ETH_DMARxDESC_GET_FLAG(FLAG) (((FLAG) == ETH_DMARxDesc_OWN) || \
N                                         ((FLAG) == ETH_DMARxDesc_AFM) || \
N                                         ((FLAG) == ETH_DMARxDesc_ES) || \
N                                         ((FLAG) == ETH_DMARxDesc_DE) || \
N                                         ((FLAG) == ETH_DMARxDesc_SAF) || \
N                                         ((FLAG) == ETH_DMARxDesc_LE) || \
N                                         ((FLAG) == ETH_DMARxDesc_OE) || \
N                                         ((FLAG) == ETH_DMARxDesc_VLAN) || \
N                                         ((FLAG) == ETH_DMARxDesc_FS) || \
N                                         ((FLAG) == ETH_DMARxDesc_LS) || \
N                                         ((FLAG) == ETH_DMARxDesc_IPV4HCE) || \
N                                         ((FLAG) == ETH_DMARxDesc_LC) || \
N                                         ((FLAG) == ETH_DMARxDesc_FT) || \
N                                         ((FLAG) == ETH_DMARxDesc_RWT) || \
N                                         ((FLAG) == ETH_DMARxDesc_RE) || \
N                                         ((FLAG) == ETH_DMARxDesc_DBE) || \
N                                         ((FLAG) == ETH_DMARxDesc_CE) || \
N                                         ((FLAG) == ETH_DMARxDesc_MAMPCE))
X#define IS_ETH_DMARxDESC_GET_FLAG(FLAG) (((FLAG) == ETH_DMARxDesc_OWN) ||                                          ((FLAG) == ETH_DMARxDesc_AFM) ||                                          ((FLAG) == ETH_DMARxDesc_ES) ||                                          ((FLAG) == ETH_DMARxDesc_DE) ||                                          ((FLAG) == ETH_DMARxDesc_SAF) ||                                          ((FLAG) == ETH_DMARxDesc_LE) ||                                          ((FLAG) == ETH_DMARxDesc_OE) ||                                          ((FLAG) == ETH_DMARxDesc_VLAN) ||                                          ((FLAG) == ETH_DMARxDesc_FS) ||                                          ((FLAG) == ETH_DMARxDesc_LS) ||                                          ((FLAG) == ETH_DMARxDesc_IPV4HCE) ||                                          ((FLAG) == ETH_DMARxDesc_LC) ||                                          ((FLAG) == ETH_DMARxDesc_FT) ||                                          ((FLAG) == ETH_DMARxDesc_RWT) ||                                          ((FLAG) == ETH_DMARxDesc_RE) ||                                          ((FLAG) == ETH_DMARxDesc_DBE) ||                                          ((FLAG) == ETH_DMARxDesc_CE) ||                                          ((FLAG) == ETH_DMARxDesc_MAMPCE))
N
N/* ETHERNET DMA PTP Rx descriptor extended flags  --------------------------------*/
N#define IS_ETH_DMAPTPRxDESC_GET_EXTENDED_FLAG(FLAG) (((FLAG) == ETH_DMAPTPRxDesc_PTPV) || \
N                                                     ((FLAG) == ETH_DMAPTPRxDesc_PTPFT) || \
N                                                     ((FLAG) == ETH_DMAPTPRxDesc_PTPMT) || \
N                                                     ((FLAG) == ETH_DMAPTPRxDesc_IPV6PR) || \
N                                                     ((FLAG) == ETH_DMAPTPRxDesc_IPV4PR) || \
N                                                     ((FLAG) == ETH_DMAPTPRxDesc_IPCB) || \
N                                                     ((FLAG) == ETH_DMAPTPRxDesc_IPPE) || \
N                                                     ((FLAG) == ETH_DMAPTPRxDesc_IPHE) || \
N                                                     ((FLAG) == ETH_DMAPTPRxDesc_IPPT))
X#define IS_ETH_DMAPTPRxDESC_GET_EXTENDED_FLAG(FLAG) (((FLAG) == ETH_DMAPTPRxDesc_PTPV) ||                                                      ((FLAG) == ETH_DMAPTPRxDesc_PTPFT) ||                                                      ((FLAG) == ETH_DMAPTPRxDesc_PTPMT) ||                                                      ((FLAG) == ETH_DMAPTPRxDesc_IPV6PR) ||                                                      ((FLAG) == ETH_DMAPTPRxDesc_IPV4PR) ||                                                      ((FLAG) == ETH_DMAPTPRxDesc_IPCB) ||                                                      ((FLAG) == ETH_DMAPTPRxDesc_IPPE) ||                                                      ((FLAG) == ETH_DMAPTPRxDesc_IPHE) ||                                                      ((FLAG) == ETH_DMAPTPRxDesc_IPPT))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_DMA_Rx_descriptor_buffers_ 
N  * @{
N  */ 
N#define ETH_DMARxDesc_Buffer1     ((uint32_t)0x00000000)  /*!< DMA Rx Desc Buffer1 */
N#define ETH_DMARxDesc_Buffer2     ((uint32_t)0x00000001)  /*!< DMA Rx Desc Buffer2 */
N#define IS_ETH_DMA_RXDESC_BUFFER(BUFFER) (((BUFFER) == ETH_DMARxDesc_Buffer1) || \
N                                          ((BUFFER) == ETH_DMARxDesc_Buffer2))
X#define IS_ETH_DMA_RXDESC_BUFFER(BUFFER) (((BUFFER) == ETH_DMARxDesc_Buffer1) ||                                           ((BUFFER) == ETH_DMARxDesc_Buffer2))
N
N/**--------------------------------------------------------------------------**/
N/** 
N  * @brief                           Ethernet DMA defines
N  */ 
N/**--------------------------------------------------------------------------**/
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Drop_TCP_IP_Checksum_Error_Frame 
N  * @{
N  */ 
N#define ETH_DropTCPIPChecksumErrorFrame_Enable   ((uint32_t)0x00000000)
N#define ETH_DropTCPIPChecksumErrorFrame_Disable  ((uint32_t)0x04000000)
N#define IS_ETH_DROP_TCPIP_CHECKSUM_FRAME(CMD) (((CMD) == ETH_DropTCPIPChecksumErrorFrame_Enable) || \
N                                               ((CMD) == ETH_DropTCPIPChecksumErrorFrame_Disable))
X#define IS_ETH_DROP_TCPIP_CHECKSUM_FRAME(CMD) (((CMD) == ETH_DropTCPIPChecksumErrorFrame_Enable) ||                                                ((CMD) == ETH_DropTCPIPChecksumErrorFrame_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Receive_Store_Forward 
N  * @{
N  */ 
N#define ETH_ReceiveStoreForward_Enable      ((uint32_t)0x02000000)
N#define ETH_ReceiveStoreForward_Disable     ((uint32_t)0x00000000)
N#define IS_ETH_RECEIVE_STORE_FORWARD(CMD) (((CMD) == ETH_ReceiveStoreForward_Enable) || \
N                                           ((CMD) == ETH_ReceiveStoreForward_Disable))
X#define IS_ETH_RECEIVE_STORE_FORWARD(CMD) (((CMD) == ETH_ReceiveStoreForward_Enable) ||                                            ((CMD) == ETH_ReceiveStoreForward_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Flush_Received_Frame 
N  * @{
N  */ 
N#define ETH_FlushReceivedFrame_Enable       ((uint32_t)0x00000000)
N#define ETH_FlushReceivedFrame_Disable      ((uint32_t)0x01000000)
N#define IS_ETH_FLUSH_RECEIVE_FRAME(CMD) (((CMD) == ETH_FlushReceivedFrame_Enable) || \
N                                         ((CMD) == ETH_FlushReceivedFrame_Disable))
X#define IS_ETH_FLUSH_RECEIVE_FRAME(CMD) (((CMD) == ETH_FlushReceivedFrame_Enable) ||                                          ((CMD) == ETH_FlushReceivedFrame_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Transmit_Store_Forward 
N  * @{
N  */ 
N#define ETH_TransmitStoreForward_Enable     ((uint32_t)0x00200000)
N#define ETH_TransmitStoreForward_Disable    ((uint32_t)0x00000000)
N#define IS_ETH_TRANSMIT_STORE_FORWARD(CMD) (((CMD) == ETH_TransmitStoreForward_Enable) || \
N                                            ((CMD) == ETH_TransmitStoreForward_Disable))
X#define IS_ETH_TRANSMIT_STORE_FORWARD(CMD) (((CMD) == ETH_TransmitStoreForward_Enable) ||                                             ((CMD) == ETH_TransmitStoreForward_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Transmit_Threshold_Control 
N  * @{
N  */ 
N#define ETH_TransmitThresholdControl_64Bytes     ((uint32_t)0x00000000)  /*!< threshold level of the MTL Transmit FIFO is 64 Bytes */
N#define ETH_TransmitThresholdControl_128Bytes    ((uint32_t)0x00004000)  /*!< threshold level of the MTL Transmit FIFO is 128 Bytes */
N#define ETH_TransmitThresholdControl_192Bytes    ((uint32_t)0x00008000)  /*!< threshold level of the MTL Transmit FIFO is 192 Bytes */
N#define ETH_TransmitThresholdControl_256Bytes    ((uint32_t)0x0000C000)  /*!< threshold level of the MTL Transmit FIFO is 256 Bytes */
N#define ETH_TransmitThresholdControl_40Bytes     ((uint32_t)0x00010000)  /*!< threshold level of the MTL Transmit FIFO is 40 Bytes */
N#define ETH_TransmitThresholdControl_32Bytes     ((uint32_t)0x00014000)  /*!< threshold level of the MTL Transmit FIFO is 32 Bytes */
N#define ETH_TransmitThresholdControl_24Bytes     ((uint32_t)0x00018000)  /*!< threshold level of the MTL Transmit FIFO is 24 Bytes */
N#define ETH_TransmitThresholdControl_16Bytes     ((uint32_t)0x0001C000)  /*!< threshold level of the MTL Transmit FIFO is 16 Bytes */
N#define IS_ETH_TRANSMIT_THRESHOLD_CONTROL(THRESHOLD) (((THRESHOLD) == ETH_TransmitThresholdControl_64Bytes) || \
N                                                      ((THRESHOLD) == ETH_TransmitThresholdControl_128Bytes) || \
N                                                      ((THRESHOLD) == ETH_TransmitThresholdControl_192Bytes) || \
N                                                      ((THRESHOLD) == ETH_TransmitThresholdControl_256Bytes) || \
N                                                      ((THRESHOLD) == ETH_TransmitThresholdControl_40Bytes) || \
N                                                      ((THRESHOLD) == ETH_TransmitThresholdControl_32Bytes) || \
N                                                      ((THRESHOLD) == ETH_TransmitThresholdControl_24Bytes) || \
N                                                      ((THRESHOLD) == ETH_TransmitThresholdControl_16Bytes))
X#define IS_ETH_TRANSMIT_THRESHOLD_CONTROL(THRESHOLD) (((THRESHOLD) == ETH_TransmitThresholdControl_64Bytes) ||                                                       ((THRESHOLD) == ETH_TransmitThresholdControl_128Bytes) ||                                                       ((THRESHOLD) == ETH_TransmitThresholdControl_192Bytes) ||                                                       ((THRESHOLD) == ETH_TransmitThresholdControl_256Bytes) ||                                                       ((THRESHOLD) == ETH_TransmitThresholdControl_40Bytes) ||                                                       ((THRESHOLD) == ETH_TransmitThresholdControl_32Bytes) ||                                                       ((THRESHOLD) == ETH_TransmitThresholdControl_24Bytes) ||                                                       ((THRESHOLD) == ETH_TransmitThresholdControl_16Bytes))
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Forward_Error_Frames 
N  * @{
N  */ 
N#define ETH_ForwardErrorFrames_Enable       ((uint32_t)0x00000080)
N#define ETH_ForwardErrorFrames_Disable      ((uint32_t)0x00000000)
N#define IS_ETH_FORWARD_ERROR_FRAMES(CMD) (((CMD) == ETH_ForwardErrorFrames_Enable) || \
N                                          ((CMD) == ETH_ForwardErrorFrames_Disable))
X#define IS_ETH_FORWARD_ERROR_FRAMES(CMD) (((CMD) == ETH_ForwardErrorFrames_Enable) ||                                           ((CMD) == ETH_ForwardErrorFrames_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Forward_Undersized_Good_Frames 
N  * @{
N  */ 
N#define ETH_ForwardUndersizedGoodFrames_Enable   ((uint32_t)0x00000040)
N#define ETH_ForwardUndersizedGoodFrames_Disable  ((uint32_t)0x00000000)     
N#define IS_ETH_FORWARD_UNDERSIZED_GOOD_FRAMES(CMD) (((CMD) == ETH_ForwardUndersizedGoodFrames_Enable) || \
N                                                    ((CMD) == ETH_ForwardUndersizedGoodFrames_Disable))
X#define IS_ETH_FORWARD_UNDERSIZED_GOOD_FRAMES(CMD) (((CMD) == ETH_ForwardUndersizedGoodFrames_Enable) ||                                                     ((CMD) == ETH_ForwardUndersizedGoodFrames_Disable))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Receive_Threshold_Control 
N  * @{
N  */ 
N#define ETH_ReceiveThresholdControl_64Bytes      ((uint32_t)0x00000000)  /*!< threshold level of the MTL Receive FIFO is 64 Bytes */
N#define ETH_ReceiveThresholdControl_32Bytes      ((uint32_t)0x00000008)  /*!< threshold level of the MTL Receive FIFO is 32 Bytes */
N#define ETH_ReceiveThresholdControl_96Bytes      ((uint32_t)0x00000010)  /*!< threshold level of the MTL Receive FIFO is 96 Bytes */
N#define ETH_ReceiveThresholdControl_128Bytes     ((uint32_t)0x00000018)  /*!< threshold level of the MTL Receive FIFO is 128 Bytes */
N#define IS_ETH_RECEIVE_THRESHOLD_CONTROL(THRESHOLD) (((THRESHOLD) == ETH_ReceiveThresholdControl_64Bytes) || \
N                                                     ((THRESHOLD) == ETH_ReceiveThresholdControl_32Bytes) || \
N                                                     ((THRESHOLD) == ETH_ReceiveThresholdControl_96Bytes) || \
N                                                     ((THRESHOLD) == ETH_ReceiveThresholdControl_128Bytes))
X#define IS_ETH_RECEIVE_THRESHOLD_CONTROL(THRESHOLD) (((THRESHOLD) == ETH_ReceiveThresholdControl_64Bytes) ||                                                      ((THRESHOLD) == ETH_ReceiveThresholdControl_32Bytes) ||                                                      ((THRESHOLD) == ETH_ReceiveThresholdControl_96Bytes) ||                                                      ((THRESHOLD) == ETH_ReceiveThresholdControl_128Bytes))
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Second_Frame_Operate 
N  * @{
N  */ 
N#define ETH_SecondFrameOperate_Enable       ((uint32_t)0x00000004)
N#define ETH_SecondFrameOperate_Disable      ((uint32_t)0x00000000)  
N#define IS_ETH_SECOND_FRAME_OPERATE(CMD) (((CMD) == ETH_SecondFrameOperate_Enable) || \
N                                          ((CMD) == ETH_SecondFrameOperate_Disable))
X#define IS_ETH_SECOND_FRAME_OPERATE(CMD) (((CMD) == ETH_SecondFrameOperate_Enable) ||                                           ((CMD) == ETH_SecondFrameOperate_Disable))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Address_Aligned_Beats 
N  * @{
N  */ 
N#define ETH_AddressAlignedBeats_Enable      ((uint32_t)0x02000000)
N#define ETH_AddressAlignedBeats_Disable     ((uint32_t)0x00000000) 
N#define IS_ETH_ADDRESS_ALIGNED_BEATS(CMD) (((CMD) == ETH_AddressAlignedBeats_Enable) || \
N                                           ((CMD) == ETH_AddressAlignedBeats_Disable))
X#define IS_ETH_ADDRESS_ALIGNED_BEATS(CMD) (((CMD) == ETH_AddressAlignedBeats_Enable) ||                                            ((CMD) == ETH_AddressAlignedBeats_Disable))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Fixed_Burst 
N  * @{
N  */ 
N#define ETH_FixedBurst_Enable     ((uint32_t)0x00010000)
N#define ETH_FixedBurst_Disable    ((uint32_t)0x00000000) 
N#define IS_ETH_FIXED_BURST(CMD) (((CMD) == ETH_FixedBurst_Enable) || \
N                                 ((CMD) == ETH_FixedBurst_Disable))
X#define IS_ETH_FIXED_BURST(CMD) (((CMD) == ETH_FixedBurst_Enable) ||                                  ((CMD) == ETH_FixedBurst_Disable))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Rx_DMA_Burst_Length 
N  * @{
N  */ 
N#define ETH_RxDMABurstLength_1Beat          ((uint32_t)0x00020000)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 1 */
N#define ETH_RxDMABurstLength_2Beat          ((uint32_t)0x00040000)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 2 */
N#define ETH_RxDMABurstLength_4Beat          ((uint32_t)0x00080000)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 4 */
N#define ETH_RxDMABurstLength_8Beat          ((uint32_t)0x00100000)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 8 */
N#define ETH_RxDMABurstLength_16Beat         ((uint32_t)0x00200000)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 16 */
N#define ETH_RxDMABurstLength_32Beat         ((uint32_t)0x00400000)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 32 */                
N#define ETH_RxDMABurstLength_4xPBL_4Beat    ((uint32_t)0x01020000)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 4 */
N#define ETH_RxDMABurstLength_4xPBL_8Beat    ((uint32_t)0x01040000)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 8 */
N#define ETH_RxDMABurstLength_4xPBL_16Beat   ((uint32_t)0x01080000)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 16 */
N#define ETH_RxDMABurstLength_4xPBL_32Beat   ((uint32_t)0x01100000)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 32 */
N#define ETH_RxDMABurstLength_4xPBL_64Beat   ((uint32_t)0x01200000)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 64 */
N#define ETH_RxDMABurstLength_4xPBL_128Beat  ((uint32_t)0x01400000)  /*!< maximum number of beats to be transferred in one RxDMA transaction is 128 */
N
N#define IS_ETH_RXDMA_BURST_LENGTH(LENGTH) (((LENGTH) == ETH_RxDMABurstLength_1Beat) || \
N                                           ((LENGTH) == ETH_RxDMABurstLength_2Beat) || \
N                                           ((LENGTH) == ETH_RxDMABurstLength_4Beat) || \
N                                           ((LENGTH) == ETH_RxDMABurstLength_8Beat) || \
N                                           ((LENGTH) == ETH_RxDMABurstLength_16Beat) || \
N                                           ((LENGTH) == ETH_RxDMABurstLength_32Beat) || \
N                                           ((LENGTH) == ETH_RxDMABurstLength_4xPBL_4Beat) || \
N                                           ((LENGTH) == ETH_RxDMABurstLength_4xPBL_8Beat) || \
N                                           ((LENGTH) == ETH_RxDMABurstLength_4xPBL_16Beat) || \
N                                           ((LENGTH) == ETH_RxDMABurstLength_4xPBL_32Beat) || \
N                                           ((LENGTH) == ETH_RxDMABurstLength_4xPBL_64Beat) || \
N                                           ((LENGTH) == ETH_RxDMABurstLength_4xPBL_128Beat))
X#define IS_ETH_RXDMA_BURST_LENGTH(LENGTH) (((LENGTH) == ETH_RxDMABurstLength_1Beat) ||                                            ((LENGTH) == ETH_RxDMABurstLength_2Beat) ||                                            ((LENGTH) == ETH_RxDMABurstLength_4Beat) ||                                            ((LENGTH) == ETH_RxDMABurstLength_8Beat) ||                                            ((LENGTH) == ETH_RxDMABurstLength_16Beat) ||                                            ((LENGTH) == ETH_RxDMABurstLength_32Beat) ||                                            ((LENGTH) == ETH_RxDMABurstLength_4xPBL_4Beat) ||                                            ((LENGTH) == ETH_RxDMABurstLength_4xPBL_8Beat) ||                                            ((LENGTH) == ETH_RxDMABurstLength_4xPBL_16Beat) ||                                            ((LENGTH) == ETH_RxDMABurstLength_4xPBL_32Beat) ||                                            ((LENGTH) == ETH_RxDMABurstLength_4xPBL_64Beat) ||                                            ((LENGTH) == ETH_RxDMABurstLength_4xPBL_128Beat))
N 
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Tx_DMA_Burst_Length 
N  * @{
N  */ 
N#define ETH_TxDMABurstLength_1Beat          ((uint32_t)0x00000100)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 1 */
N#define ETH_TxDMABurstLength_2Beat          ((uint32_t)0x00000200)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 2 */
N#define ETH_TxDMABurstLength_4Beat          ((uint32_t)0x00000400)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */
N#define ETH_TxDMABurstLength_8Beat          ((uint32_t)0x00000800)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */
N#define ETH_TxDMABurstLength_16Beat         ((uint32_t)0x00001000)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */
N#define ETH_TxDMABurstLength_32Beat         ((uint32_t)0x00002000)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */                
N#define ETH_TxDMABurstLength_4xPBL_4Beat    ((uint32_t)0x01000100)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */
N#define ETH_TxDMABurstLength_4xPBL_8Beat    ((uint32_t)0x01000200)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */
N#define ETH_TxDMABurstLength_4xPBL_16Beat   ((uint32_t)0x01000400)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */
N#define ETH_TxDMABurstLength_4xPBL_32Beat   ((uint32_t)0x01000800)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */
N#define ETH_TxDMABurstLength_4xPBL_64Beat   ((uint32_t)0x01001000)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 64 */
N#define ETH_TxDMABurstLength_4xPBL_128Beat  ((uint32_t)0x01002000)  /*!< maximum number of beats to be transferred in one TxDMA (or both) transaction is 128 */
N
N#define IS_ETH_TXDMA_BURST_LENGTH(LENGTH) (((LENGTH) == ETH_TxDMABurstLength_1Beat) || \
N                                           ((LENGTH) == ETH_TxDMABurstLength_2Beat) || \
N                                           ((LENGTH) == ETH_TxDMABurstLength_4Beat) || \
N                                           ((LENGTH) == ETH_TxDMABurstLength_8Beat) || \
N                                           ((LENGTH) == ETH_TxDMABurstLength_16Beat) || \
N                                           ((LENGTH) == ETH_TxDMABurstLength_32Beat) || \
N                                           ((LENGTH) == ETH_TxDMABurstLength_4xPBL_4Beat) || \
N                                           ((LENGTH) == ETH_TxDMABurstLength_4xPBL_8Beat) || \
N                                           ((LENGTH) == ETH_TxDMABurstLength_4xPBL_16Beat) || \
N                                           ((LENGTH) == ETH_TxDMABurstLength_4xPBL_32Beat) || \
N                                           ((LENGTH) == ETH_TxDMABurstLength_4xPBL_64Beat) || \
N                                           ((LENGTH) == ETH_TxDMABurstLength_4xPBL_128Beat))
X#define IS_ETH_TXDMA_BURST_LENGTH(LENGTH) (((LENGTH) == ETH_TxDMABurstLength_1Beat) ||                                            ((LENGTH) == ETH_TxDMABurstLength_2Beat) ||                                            ((LENGTH) == ETH_TxDMABurstLength_4Beat) ||                                            ((LENGTH) == ETH_TxDMABurstLength_8Beat) ||                                            ((LENGTH) == ETH_TxDMABurstLength_16Beat) ||                                            ((LENGTH) == ETH_TxDMABurstLength_32Beat) ||                                            ((LENGTH) == ETH_TxDMABurstLength_4xPBL_4Beat) ||                                            ((LENGTH) == ETH_TxDMABurstLength_4xPBL_8Beat) ||                                            ((LENGTH) == ETH_TxDMABurstLength_4xPBL_16Beat) ||                                            ((LENGTH) == ETH_TxDMABurstLength_4xPBL_32Beat) ||                                            ((LENGTH) == ETH_TxDMABurstLength_4xPBL_64Beat) ||                                            ((LENGTH) == ETH_TxDMABurstLength_4xPBL_128Beat))
N/** 
N  * @brief  ETH DMA Descriptor SkipLength  
N  */ 
N#define IS_ETH_DMA_DESC_SKIP_LENGTH(LENGTH) ((LENGTH) <= 0x1F)
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_DMA_Arbitration 
N  * @{
N  */ 
N#define ETH_DMAArbitration_RoundRobin_RxTx_1_1   ((uint32_t)0x00000000)
N#define ETH_DMAArbitration_RoundRobin_RxTx_2_1   ((uint32_t)0x00004000)
N#define ETH_DMAArbitration_RoundRobin_RxTx_3_1   ((uint32_t)0x00008000)
N#define ETH_DMAArbitration_RoundRobin_RxTx_4_1   ((uint32_t)0x0000C000)
N#define ETH_DMAArbitration_RxPriorTx             ((uint32_t)0x00000002)
N#define IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(RATIO) (((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_1_1) || \
N                                                       ((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_2_1) || \
N                                                       ((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_3_1) || \
N                                                       ((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_4_1) || \
N                                                       ((RATIO) == ETH_DMAArbitration_RxPriorTx))
X#define IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(RATIO) (((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_1_1) ||                                                        ((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_2_1) ||                                                        ((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_3_1) ||                                                        ((RATIO) == ETH_DMAArbitration_RoundRobin_RxTx_4_1) ||                                                        ((RATIO) == ETH_DMAArbitration_RxPriorTx))
N/**
N  * @}
N  */
N
N/** @defgroup ETH_DMA_Flags 
N  * @{
N  */ 
N#define ETH_DMA_FLAG_TST               ((uint32_t)0x20000000)  /*!< Time-stamp trigger interrupt (on DMA) */
N#define ETH_DMA_FLAG_PMT               ((uint32_t)0x10000000)  /*!< PMT interrupt (on DMA) */
N#define ETH_DMA_FLAG_MMC               ((uint32_t)0x08000000)  /*!< MMC interrupt (on DMA) */
N#define ETH_DMA_FLAG_DataTransferError ((uint32_t)0x00800000)  /*!< Error bits 0-Rx DMA, 1-Tx DMA */
N#define ETH_DMA_FLAG_ReadWriteError    ((uint32_t)0x01000000)  /*!< Error bits 0-write trnsf, 1-read transfr */
N#define ETH_DMA_FLAG_AccessError       ((uint32_t)0x02000000)  /*!< Error bits 0-data buffer, 1-desc. access */
N#define ETH_DMA_FLAG_NIS               ((uint32_t)0x00010000)  /*!< Normal interrupt summary flag */
N#define ETH_DMA_FLAG_AIS               ((uint32_t)0x00008000)  /*!< Abnormal interrupt summary flag */
N#define ETH_DMA_FLAG_ER                ((uint32_t)0x00004000)  /*!< Early receive flag */
N#define ETH_DMA_FLAG_FBE               ((uint32_t)0x00002000)  /*!< Fatal bus error flag */
N#define ETH_DMA_FLAG_ET                ((uint32_t)0x00000400)  /*!< Early transmit flag */
N#define ETH_DMA_FLAG_RWT               ((uint32_t)0x00000200)  /*!< Receive watchdog timeout flag */
N#define ETH_DMA_FLAG_RPS               ((uint32_t)0x00000100)  /*!< Receive process stopped flag */
N#define ETH_DMA_FLAG_RBU               ((uint32_t)0x00000080)  /*!< Receive buffer unavailable flag */
N#define ETH_DMA_FLAG_R                 ((uint32_t)0x00000040)  /*!< Receive flag */
N#define ETH_DMA_FLAG_TU                ((uint32_t)0x00000020)  /*!< Underflow flag */
N#define ETH_DMA_FLAG_RO                ((uint32_t)0x00000010)  /*!< Overflow flag */
N#define ETH_DMA_FLAG_TJT               ((uint32_t)0x00000008)  /*!< Transmit jabber timeout flag */
N#define ETH_DMA_FLAG_TBU               ((uint32_t)0x00000004)  /*!< Transmit buffer unavailable flag */
N#define ETH_DMA_FLAG_TPS               ((uint32_t)0x00000002)  /*!< Transmit process stopped flag */
N#define ETH_DMA_FLAG_T                 ((uint32_t)0x00000001)  /*!< Transmit flag */
N
N#define IS_ETH_DMA_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFFFE1800) == 0x00) && ((FLAG) != 0x00)) 
N#define IS_ETH_DMA_GET_FLAG(FLAG) (((FLAG) == ETH_DMA_FLAG_TST) || ((FLAG) == ETH_DMA_FLAG_PMT) || \
N                                   ((FLAG) == ETH_DMA_FLAG_MMC) || ((FLAG) == ETH_DMA_FLAG_DataTransferError) || \
N                                   ((FLAG) == ETH_DMA_FLAG_ReadWriteError) || ((FLAG) == ETH_DMA_FLAG_AccessError) || \
N                                   ((FLAG) == ETH_DMA_FLAG_NIS) || ((FLAG) == ETH_DMA_FLAG_AIS) || \
N                                   ((FLAG) == ETH_DMA_FLAG_ER) || ((FLAG) == ETH_DMA_FLAG_FBE) || \
N                                   ((FLAG) == ETH_DMA_FLAG_ET) || ((FLAG) == ETH_DMA_FLAG_RWT) || \
N                                   ((FLAG) == ETH_DMA_FLAG_RPS) || ((FLAG) == ETH_DMA_FLAG_RBU) || \
N                                   ((FLAG) == ETH_DMA_FLAG_R) || ((FLAG) == ETH_DMA_FLAG_TU) || \
N                                   ((FLAG) == ETH_DMA_FLAG_RO) || ((FLAG) == ETH_DMA_FLAG_TJT) || \
N                                   ((FLAG) == ETH_DMA_FLAG_TBU) || ((FLAG) == ETH_DMA_FLAG_TPS) || \
N                                   ((FLAG) == ETH_DMA_FLAG_T))
X#define IS_ETH_DMA_GET_FLAG(FLAG) (((FLAG) == ETH_DMA_FLAG_TST) || ((FLAG) == ETH_DMA_FLAG_PMT) ||                                    ((FLAG) == ETH_DMA_FLAG_MMC) || ((FLAG) == ETH_DMA_FLAG_DataTransferError) ||                                    ((FLAG) == ETH_DMA_FLAG_ReadWriteError) || ((FLAG) == ETH_DMA_FLAG_AccessError) ||                                    ((FLAG) == ETH_DMA_FLAG_NIS) || ((FLAG) == ETH_DMA_FLAG_AIS) ||                                    ((FLAG) == ETH_DMA_FLAG_ER) || ((FLAG) == ETH_DMA_FLAG_FBE) ||                                    ((FLAG) == ETH_DMA_FLAG_ET) || ((FLAG) == ETH_DMA_FLAG_RWT) ||                                    ((FLAG) == ETH_DMA_FLAG_RPS) || ((FLAG) == ETH_DMA_FLAG_RBU) ||                                    ((FLAG) == ETH_DMA_FLAG_R) || ((FLAG) == ETH_DMA_FLAG_TU) ||                                    ((FLAG) == ETH_DMA_FLAG_RO) || ((FLAG) == ETH_DMA_FLAG_TJT) ||                                    ((FLAG) == ETH_DMA_FLAG_TBU) || ((FLAG) == ETH_DMA_FLAG_TPS) ||                                    ((FLAG) == ETH_DMA_FLAG_T))
N/**
N  * @}
N  */
N
N/** @defgroup ETH_DMA_Interrupts 
N  * @{
N  */ 
N#define ETH_DMA_IT_TST       ((uint32_t)0x20000000)  /*!< Time-stamp trigger interrupt (on DMA) */
N#define ETH_DMA_IT_PMT       ((uint32_t)0x10000000)  /*!< PMT interrupt (on DMA) */
N#define ETH_DMA_IT_MMC       ((uint32_t)0x08000000)  /*!< MMC interrupt (on DMA) */
N#define ETH_DMA_IT_NIS       ((uint32_t)0x00010000)  /*!< Normal interrupt summary */
N#define ETH_DMA_IT_AIS       ((uint32_t)0x00008000)  /*!< Abnormal interrupt summary */
N#define ETH_DMA_IT_ER        ((uint32_t)0x00004000)  /*!< Early receive interrupt */
N#define ETH_DMA_IT_FBE       ((uint32_t)0x00002000)  /*!< Fatal bus error interrupt */
N#define ETH_DMA_IT_ET        ((uint32_t)0x00000400)  /*!< Early transmit interrupt */
N#define ETH_DMA_IT_RWT       ((uint32_t)0x00000200)  /*!< Receive watchdog timeout interrupt */
N#define ETH_DMA_IT_RPS       ((uint32_t)0x00000100)  /*!< Receive process stopped interrupt */
N#define ETH_DMA_IT_RBU       ((uint32_t)0x00000080)  /*!< Receive buffer unavailable interrupt */
N#define ETH_DMA_IT_R         ((uint32_t)0x00000040)  /*!< Receive interrupt */
N#define ETH_DMA_IT_TU        ((uint32_t)0x00000020)  /*!< Underflow interrupt */
N#define ETH_DMA_IT_RO        ((uint32_t)0x00000010)  /*!< Overflow interrupt */
N#define ETH_DMA_IT_TJT       ((uint32_t)0x00000008)  /*!< Transmit jabber timeout interrupt */
N#define ETH_DMA_IT_TBU       ((uint32_t)0x00000004)  /*!< Transmit buffer unavailable interrupt */
N#define ETH_DMA_IT_TPS       ((uint32_t)0x00000002)  /*!< Transmit process stopped interrupt */
N#define ETH_DMA_IT_T         ((uint32_t)0x00000001)  /*!< Transmit interrupt */
N
N#define IS_ETH_DMA_IT(IT) ((((IT) & (uint32_t)0xFFFE1800) == 0x00) && ((IT) != 0x00))
N#define IS_ETH_DMA_GET_IT(IT) (((IT) == ETH_DMA_IT_TST) || ((IT) == ETH_DMA_IT_PMT) || \
N                               ((IT) == ETH_DMA_IT_MMC) || ((IT) == ETH_DMA_IT_NIS) || \
N                               ((IT) == ETH_DMA_IT_AIS) || ((IT) == ETH_DMA_IT_ER) || \
N                               ((IT) == ETH_DMA_IT_FBE) || ((IT) == ETH_DMA_IT_ET) || \
N                               ((IT) == ETH_DMA_IT_RWT) || ((IT) == ETH_DMA_IT_RPS) || \
N                               ((IT) == ETH_DMA_IT_RBU) || ((IT) == ETH_DMA_IT_R) || \
N                               ((IT) == ETH_DMA_IT_TU) || ((IT) == ETH_DMA_IT_RO) || \
N                               ((IT) == ETH_DMA_IT_TJT) || ((IT) == ETH_DMA_IT_TBU) || \
N                               ((IT) == ETH_DMA_IT_TPS) || ((IT) == ETH_DMA_IT_T))
X#define IS_ETH_DMA_GET_IT(IT) (((IT) == ETH_DMA_IT_TST) || ((IT) == ETH_DMA_IT_PMT) ||                                ((IT) == ETH_DMA_IT_MMC) || ((IT) == ETH_DMA_IT_NIS) ||                                ((IT) == ETH_DMA_IT_AIS) || ((IT) == ETH_DMA_IT_ER) ||                                ((IT) == ETH_DMA_IT_FBE) || ((IT) == ETH_DMA_IT_ET) ||                                ((IT) == ETH_DMA_IT_RWT) || ((IT) == ETH_DMA_IT_RPS) ||                                ((IT) == ETH_DMA_IT_RBU) || ((IT) == ETH_DMA_IT_R) ||                                ((IT) == ETH_DMA_IT_TU) || ((IT) == ETH_DMA_IT_RO) ||                                ((IT) == ETH_DMA_IT_TJT) || ((IT) == ETH_DMA_IT_TBU) ||                                ((IT) == ETH_DMA_IT_TPS) || ((IT) == ETH_DMA_IT_T))
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_DMA_transmit_process_state_ 
N  * @{
N  */ 
N#define ETH_DMA_TransmitProcess_Stopped     ((uint32_t)0x00000000)  /*!< Stopped - Reset or Stop Tx Command issued */
N#define ETH_DMA_TransmitProcess_Fetching    ((uint32_t)0x00100000)  /*!< Running - fetching the Tx descriptor */
N#define ETH_DMA_TransmitProcess_Waiting     ((uint32_t)0x00200000)  /*!< Running - waiting for status */
N#define ETH_DMA_TransmitProcess_Reading     ((uint32_t)0x00300000)  /*!< Running - reading the data from host memory */
N#define ETH_DMA_TransmitProcess_Suspended   ((uint32_t)0x00600000)  /*!< Suspended - Tx Descriptor unavailable */
N#define ETH_DMA_TransmitProcess_Closing     ((uint32_t)0x00700000)  /*!< Running - closing Rx descriptor */
N
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ETH_DMA_receive_process_state_ 
N  * @{
N  */ 
N#define ETH_DMA_ReceiveProcess_Stopped      ((uint32_t)0x00000000)  /*!< Stopped - Reset or Stop Rx Command issued */
N#define ETH_DMA_ReceiveProcess_Fetching     ((uint32_t)0x00020000)  /*!< Running - fetching the Rx descriptor */
N#define ETH_DMA_ReceiveProcess_Waiting      ((uint32_t)0x00060000)  /*!< Running - waiting for packet */
N#define ETH_DMA_ReceiveProcess_Suspended    ((uint32_t)0x00080000)  /*!< Suspended - Rx Descriptor unavailable */
N#define ETH_DMA_ReceiveProcess_Closing      ((uint32_t)0x000A0000)  /*!< Running - closing descriptor */
N#define ETH_DMA_ReceiveProcess_Queuing      ((uint32_t)0x000E0000)  /*!< Running - queuing the receive frame into host memory */
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_DMA_overflow_ 
N  * @{
N  */ 
N#define ETH_DMA_Overflow_RxFIFOCounter      ((uint32_t)0x10000000)  /*!< Overflow bit for FIFO overflow counter */
N#define ETH_DMA_Overflow_MissedFrameCounter ((uint32_t)0x00010000)  /*!< Overflow bit for missed frame counter */
N#define IS_ETH_DMA_GET_OVERFLOW(OVERFLOW) (((OVERFLOW) == ETH_DMA_Overflow_RxFIFOCounter) || \
N                                           ((OVERFLOW) == ETH_DMA_Overflow_MissedFrameCounter))
X#define IS_ETH_DMA_GET_OVERFLOW(OVERFLOW) (((OVERFLOW) == ETH_DMA_Overflow_RxFIFOCounter) ||                                            ((OVERFLOW) == ETH_DMA_Overflow_MissedFrameCounter))
N
N/**--------------------------------------------------------------------------**/
N/** 
N  * @brief                           Ethernet PMT defines
N  */ 
N/**--------------------------------------------------------------------------**/
N/**
N  * @}
N  */
N
N/** @defgroup ETH_PMT_Flags 
N  * @{
N  */ 
N#define ETH_PMT_FLAG_WUFFRPR      ((uint32_t)0x80000000)  /*!< Wake-Up Frame Filter Register Pointer Reset */
N#define ETH_PMT_FLAG_WUFR         ((uint32_t)0x00000040)  /*!< Wake-Up Frame Received */
N#define ETH_PMT_FLAG_MPR          ((uint32_t)0x00000020)  /*!< Magic Packet Received */
N#define IS_ETH_PMT_GET_FLAG(FLAG) (((FLAG) == ETH_PMT_FLAG_WUFR) || \
N                                   ((FLAG) == ETH_PMT_FLAG_MPR))
X#define IS_ETH_PMT_GET_FLAG(FLAG) (((FLAG) == ETH_PMT_FLAG_WUFR) ||                                    ((FLAG) == ETH_PMT_FLAG_MPR))
N
N/**--------------------------------------------------------------------------**/
N/** 
N  * @brief                           Ethernet MMC defines
N  */ 
N/**--------------------------------------------------------------------------**/
N/**
N  * @}
N  */
N
N/** @defgroup ETH_MMC_Tx_Interrupts 
N  * @{
N  */ 
N#define ETH_MMC_IT_TGF       ((uint32_t)0x00200000)  /*!< When Tx good frame counter reaches half the maximum value */
N#define ETH_MMC_IT_TGFMSC    ((uint32_t)0x00008000)  /*!< When Tx good multi col counter reaches half the maximum value */
N#define ETH_MMC_IT_TGFSC     ((uint32_t)0x00004000)  /*!< When Tx good single col counter reaches half the maximum value */
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_MMC_Rx_Interrupts 
N  * @{
N  */
N#define ETH_MMC_IT_RGUF      ((uint32_t)0x10020000)  /*!< When Rx good unicast frames counter reaches half the maximum value */
N#define ETH_MMC_IT_RFAE      ((uint32_t)0x10000040)  /*!< When Rx alignment error counter reaches half the maximum value */
N#define ETH_MMC_IT_RFCE      ((uint32_t)0x10000020)  /*!< When Rx crc error counter reaches half the maximum value */
N#define IS_ETH_MMC_IT(IT) (((((IT) & (uint32_t)0xFFDF3FFF) == 0x00) || (((IT) & (uint32_t)0xEFFDFF9F) == 0x00)) && \
N                           ((IT) != 0x00))
X#define IS_ETH_MMC_IT(IT) (((((IT) & (uint32_t)0xFFDF3FFF) == 0x00) || (((IT) & (uint32_t)0xEFFDFF9F) == 0x00)) &&                            ((IT) != 0x00))
N#define IS_ETH_MMC_GET_IT(IT) (((IT) == ETH_MMC_IT_TGF) || ((IT) == ETH_MMC_IT_TGFMSC) || \
N                               ((IT) == ETH_MMC_IT_TGFSC) || ((IT) == ETH_MMC_IT_RGUF) || \
N                               ((IT) == ETH_MMC_IT_RFAE) || ((IT) == ETH_MMC_IT_RFCE))
X#define IS_ETH_MMC_GET_IT(IT) (((IT) == ETH_MMC_IT_TGF) || ((IT) == ETH_MMC_IT_TGFMSC) ||                                ((IT) == ETH_MMC_IT_TGFSC) || ((IT) == ETH_MMC_IT_RGUF) ||                                ((IT) == ETH_MMC_IT_RFAE) || ((IT) == ETH_MMC_IT_RFCE))
N/**
N  * @}
N  */
N
N/** @defgroup ETH_MMC_Registers 
N  * @{
N  */ 
N#define ETH_MMCCR            ((uint32_t)0x00000100)  /*!< MMC CR register */
N#define ETH_MMCRIR           ((uint32_t)0x00000104)  /*!< MMC RIR register */
N#define ETH_MMCTIR           ((uint32_t)0x00000108)  /*!< MMC TIR register */
N#define ETH_MMCRIMR          ((uint32_t)0x0000010C)  /*!< MMC RIMR register */
N#define ETH_MMCTIMR          ((uint32_t)0x00000110)  /*!< MMC TIMR register */ 
N#define ETH_MMCTGFSCCR       ((uint32_t)0x0000014C)  /*!< MMC TGFSCCR register */
N#define ETH_MMCTGFMSCCR      ((uint32_t)0x00000150)  /*!< MMC TGFMSCCR register */ 
N#define ETH_MMCTGFCR         ((uint32_t)0x00000168)  /*!< MMC TGFCR register */
N#define ETH_MMCRFCECR        ((uint32_t)0x00000194)  /*!< MMC RFCECR register */
N#define ETH_MMCRFAECR        ((uint32_t)0x00000198)  /*!< MMC RFAECR register */
N#define ETH_MMCRGUFCR        ((uint32_t)0x000001C4)  /*!< MMC RGUFCR register */
N
N/** 
N  * @brief  ETH MMC registers  
N  */ 
N#define IS_ETH_MMC_REGISTER(REG) (((REG) == ETH_MMCCR)  || ((REG) == ETH_MMCRIR) || \
N                                  ((REG) == ETH_MMCTIR)  || ((REG) == ETH_MMCRIMR) || \
N                                  ((REG) == ETH_MMCTIMR) || ((REG) == ETH_MMCTGFSCCR) || \
N                                  ((REG) == ETH_MMCTGFMSCCR) || ((REG) == ETH_MMCTGFCR) || \
N                                  ((REG) == ETH_MMCRFCECR) || ((REG) == ETH_MMCRFAECR) || \
N                                  ((REG) == ETH_MMCRGUFCR)) 
X#define IS_ETH_MMC_REGISTER(REG) (((REG) == ETH_MMCCR)  || ((REG) == ETH_MMCRIR) ||                                   ((REG) == ETH_MMCTIR)  || ((REG) == ETH_MMCRIMR) ||                                   ((REG) == ETH_MMCTIMR) || ((REG) == ETH_MMCTGFSCCR) ||                                   ((REG) == ETH_MMCTGFMSCCR) || ((REG) == ETH_MMCTGFCR) ||                                   ((REG) == ETH_MMCRFCECR) || ((REG) == ETH_MMCRFAECR) ||                                   ((REG) == ETH_MMCRGUFCR)) 
N
N/**--------------------------------------------------------------------------**/
N/** 
N  * @brief                           Ethernet PTP defines
N  */ 
N/**--------------------------------------------------------------------------**/
N/**
N  * @}
N  */
N
N/** @defgroup ETH_PTP_time_update_method 
N  * @{
N  */ 
N#define ETH_PTP_FineUpdate        ((uint32_t)0x00000001)  /*!< Fine Update method */
N#define ETH_PTP_CoarseUpdate      ((uint32_t)0x00000000)  /*!< Coarse Update method */
N#define IS_ETH_PTP_UPDATE(UPDATE) (((UPDATE) == ETH_PTP_FineUpdate) || \
N                                   ((UPDATE) == ETH_PTP_CoarseUpdate))
X#define IS_ETH_PTP_UPDATE(UPDATE) (((UPDATE) == ETH_PTP_FineUpdate) ||                                    ((UPDATE) == ETH_PTP_CoarseUpdate))
N
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ETH_PTP_Flags 
N  * @{
N  */ 
N#define ETH_PTP_FLAG_TSARU        ((uint32_t)0x00000020)  /*!< Addend Register Update */
N#define ETH_PTP_FLAG_TSITE        ((uint32_t)0x00000010)  /*!< Time Stamp Interrupt Trigger */
N#define ETH_PTP_FLAG_TSSTU        ((uint32_t)0x00000008)  /*!< Time Stamp Update */
N#define ETH_PTP_FLAG_TSSTI        ((uint32_t)0x00000004)  /*!< Time Stamp Initialize */
N
N#define ETH_PTP_FLAG_TSTTR        ((uint32_t)0x10000002)  /* Time stamp target time reached */
N#define ETH_PTP_FLAG_TSSO         ((uint32_t)0x10000001)  /* Time stamp seconds overflow */
N
N#define IS_ETH_PTP_GET_FLAG(FLAG) (((FLAG) == ETH_PTP_FLAG_TSARU) || \
N                                    ((FLAG) == ETH_PTP_FLAG_TSITE) || \
N                                    ((FLAG) == ETH_PTP_FLAG_TSSTU) || \
N                                    ((FLAG) == ETH_PTP_FLAG_TSSTI) || \
N                                    ((FLAG) == ETH_PTP_FLAG_TSTTR) || \
N                                    ((FLAG) == ETH_PTP_FLAG_TSSO)) 
X#define IS_ETH_PTP_GET_FLAG(FLAG) (((FLAG) == ETH_PTP_FLAG_TSARU) ||                                     ((FLAG) == ETH_PTP_FLAG_TSITE) ||                                     ((FLAG) == ETH_PTP_FLAG_TSSTU) ||                                     ((FLAG) == ETH_PTP_FLAG_TSSTI) ||                                     ((FLAG) == ETH_PTP_FLAG_TSTTR) ||                                     ((FLAG) == ETH_PTP_FLAG_TSSO)) 
N
N/** 
N  * @brief  ETH PTP subsecond increment  
N  */ 
N#define IS_ETH_PTP_SUBSECOND_INCREMENT(SUBSECOND) ((SUBSECOND) <= 0xFF)
N
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ETH_PTP_time_sign 
N  * @{
N  */ 
N#define ETH_PTP_PositiveTime      ((uint32_t)0x00000000)  /*!< Positive time value */
N#define ETH_PTP_NegativeTime      ((uint32_t)0x80000000)  /*!< Negative time value */
N#define IS_ETH_PTP_TIME_SIGN(SIGN) (((SIGN) == ETH_PTP_PositiveTime) || \
N                                    ((SIGN) == ETH_PTP_NegativeTime))
X#define IS_ETH_PTP_TIME_SIGN(SIGN) (((SIGN) == ETH_PTP_PositiveTime) ||                                     ((SIGN) == ETH_PTP_NegativeTime))
N
N/** 
N  * @brief  ETH PTP time stamp low update  
N  */ 
N#define IS_ETH_PTP_TIME_STAMP_UPDATE_SUBSECOND(SUBSECOND) ((SUBSECOND) <= 0x7FFFFFFF)
N
N/** 
N  * @brief  ETH PTP registers  
N  */ 
N#define ETH_PTPTSCR     ((uint32_t)0x00000700)  /*!< PTP TSCR register */
N#define ETH_PTPSSIR     ((uint32_t)0x00000704)  /*!< PTP SSIR register */
N#define ETH_PTPTSHR     ((uint32_t)0x00000708)  /*!< PTP TSHR register */
N#define ETH_PTPTSLR     ((uint32_t)0x0000070C)  /*!< PTP TSLR register */
N#define ETH_PTPTSHUR    ((uint32_t)0x00000710)  /*!< PTP TSHUR register */
N#define ETH_PTPTSLUR    ((uint32_t)0x00000714)  /*!< PTP TSLUR register */
N#define ETH_PTPTSAR     ((uint32_t)0x00000718)  /*!< PTP TSAR register */
N#define ETH_PTPTTHR     ((uint32_t)0x0000071C)  /*!< PTP TTHR register */
N#define ETH_PTPTTLR     ((uint32_t)0x00000720)  /* PTP TTLR register */
N
N#define ETH_PTPTSSR     ((uint32_t)0x00000728)  /* PTP TSSR register */
N
N#define IS_ETH_PTP_REGISTER(REG) (((REG) == ETH_PTPTSCR) || ((REG) == ETH_PTPSSIR) || \
N                                   ((REG) == ETH_PTPTSHR) || ((REG) == ETH_PTPTSLR) || \
N                                   ((REG) == ETH_PTPTSHUR) || ((REG) == ETH_PTPTSLUR) || \
N                                   ((REG) == ETH_PTPTSAR) || ((REG) == ETH_PTPTTHR) || \
N                                   ((REG) == ETH_PTPTTLR) || ((REG) == ETH_PTPTSSR)) 
X#define IS_ETH_PTP_REGISTER(REG) (((REG) == ETH_PTPTSCR) || ((REG) == ETH_PTPSSIR) ||                                    ((REG) == ETH_PTPTSHR) || ((REG) == ETH_PTPTSLR) ||                                    ((REG) == ETH_PTPTSHUR) || ((REG) == ETH_PTPTSLUR) ||                                    ((REG) == ETH_PTPTSAR) || ((REG) == ETH_PTPTTHR) ||                                    ((REG) == ETH_PTPTTLR) || ((REG) == ETH_PTPTSSR)) 
N
N/** 
N  * @brief  ETHERNET PTP clock  
N  */ 
N#define ETH_PTP_OrdinaryClock               ((uint32_t)0x00000000)  /* Ordinary Clock */
N#define ETH_PTP_BoundaryClock               ((uint32_t)0x00010000)  /* Boundary Clock */
N#define ETH_PTP_EndToEndTransparentClock    ((uint32_t)0x00020000)  /* End To End Transparent Clock */
N#define ETH_PTP_PeerToPeerTransparentClock  ((uint32_t)0x00030000)  /* Peer To Peer Transparent Clock */
N
N#define IS_ETH_PTP_TYPE_CLOCK(CLOCK) (((CLOCK) == ETH_PTP_OrdinaryClock) || \
N                          ((CLOCK) == ETH_PTP_BoundaryClock) || \
N                          ((CLOCK) == ETH_PTP_EndToEndTransparentClock) || \
N                                      ((CLOCK) == ETH_PTP_PeerToPeerTransparentClock))
X#define IS_ETH_PTP_TYPE_CLOCK(CLOCK) (((CLOCK) == ETH_PTP_OrdinaryClock) ||                           ((CLOCK) == ETH_PTP_BoundaryClock) ||                           ((CLOCK) == ETH_PTP_EndToEndTransparentClock) ||                                       ((CLOCK) == ETH_PTP_PeerToPeerTransparentClock))
N/** 
N  * @brief  ETHERNET snapshot
N  */
N#define ETH_PTP_SnapshotMasterMessage          ((uint32_t)0x00008000)  /* Time stamp snapshot for message relevant to master enable */
N#define ETH_PTP_SnapshotEventMessage           ((uint32_t)0x00004000)  /* Time stamp snapshot for event message enable */
N#define ETH_PTP_SnapshotIPV4Frames             ((uint32_t)0x00002000)  /* Time stamp snapshot for IPv4 frames enable */
N#define ETH_PTP_SnapshotIPV6Frames             ((uint32_t)0x00001000)  /* Time stamp snapshot for IPv6 frames enable */
N#define ETH_PTP_SnapshotPTPOverEthernetFrames  ((uint32_t)0x00000800)  /* Time stamp snapshot for PTP over ethernet frames enable */
N#define ETH_PTP_SnapshotAllReceivedFrames      ((uint32_t)0x00000100)  /* Time stamp snapshot for all received frames enable */
N
N#define IS_ETH_PTP_SNAPSHOT(SNAPSHOT) (((SNAPSHOT) == ETH_PTP_SnapshotMasterMessage) || \
N                           ((SNAPSHOT) == ETH_PTP_SnapshotEventMessage) || \
N                           ((SNAPSHOT) == ETH_PTP_SnapshotIPV4Frames) || \
N                           ((SNAPSHOT) == ETH_PTP_SnapshotIPV6Frames) || \
N                           ((SNAPSHOT) == ETH_PTP_SnapshotPTPOverEthernetFrames) || \
N                           ((SNAPSHOT) == ETH_PTP_SnapshotAllReceivedFrames))
X#define IS_ETH_PTP_SNAPSHOT(SNAPSHOT) (((SNAPSHOT) == ETH_PTP_SnapshotMasterMessage) ||                            ((SNAPSHOT) == ETH_PTP_SnapshotEventMessage) ||                            ((SNAPSHOT) == ETH_PTP_SnapshotIPV4Frames) ||                            ((SNAPSHOT) == ETH_PTP_SnapshotIPV6Frames) ||                            ((SNAPSHOT) == ETH_PTP_SnapshotPTPOverEthernetFrames) ||                            ((SNAPSHOT) == ETH_PTP_SnapshotAllReceivedFrames))
N
N/**
N  * @}
N  */ 
N/* ETHERNET MAC address offsets */
N#define ETH_MAC_ADDR_HBASE   (ETH_MAC_BASE + 0x40)  /* ETHERNET MAC address high offset */
N#define ETH_MAC_ADDR_LBASE    (ETH_MAC_BASE + 0x44)  /* ETHERNET MAC address low offset */
N
N/* ETHERNET MACMIIAR register Mask */
N#define MACMIIAR_CR_MASK    ((uint32_t)0xFFFFFFE3)
N
N/* ETHERNET MACCR register Mask */
N#define MACCR_CLEAR_MASK    ((uint32_t)0xFF20810F)  
N
N/* ETHERNET MACFCR register Mask */
N#define MACFCR_CLEAR_MASK   ((uint32_t)0x0000FF41)
N
N
N/* ETHERNET DMAOMR register Mask */
N#define DMAOMR_CLEAR_MASK   ((uint32_t)0xF8DE3F23)
N
N
N/* ETHERNET Remote Wake-up frame register length */
N#define ETH_WAKEUP_REGISTER_LENGTH      8
N
N/* ETHERNET Missed frames counter Shift */
N#define  ETH_DMA_RX_OVERFLOW_MISSEDFRAMES_COUNTERSHIFT     17
N
N/* ETHERNET DMA Tx descriptors Collision Count Shift */
N#define  ETH_DMATXDESC_COLLISION_COUNTSHIFT        3
N
N/* ETHERNET DMA Tx descriptors Buffer2 Size Shift */
N#define  ETH_DMATXDESC_BUFFER2_SIZESHIFT           16
N
N/* ETHERNET DMA Rx descriptors Frame Length Shift */
N#define  ETH_DMARXDESC_FRAME_LENGTHSHIFT           16
N
N/* ETHERNET DMA Rx descriptors Buffer2 Size Shift */
N#define  ETH_DMARXDESC_BUFFER2_SIZESHIFT           16
N
N/* ETHERNET errors */
N#define  ETH_ERROR              ((uint32_t)0)
N#define  ETH_SUCCESS            ((uint32_t)1)
N
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Exported_Macros
N  * @{
N  */ 
N/**
N  * @}
N  */
N
N/** @defgroup ETH_Exported_Functions
N  * @{
N  */ 
Nvoid ETH_DeInit(void);
Nuint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct, uint16_t PHYAddress);
Nvoid ETH_StructInit(ETH_InitTypeDef* ETH_InitStruct);
Nvoid ETH_SoftwareReset(void);
NFlagStatus ETH_GetSoftwareResetStatus(void);
Nvoid  ETH_Start(void);
Nvoid  ETH_Stop(void);
Nuint32_t ETH_GetRxPktSize(ETH_DMADESCTypeDef *DMARxDesc);
N
N
N#ifdef USE_ENHANCED_DMA_DESCRIPTORS
N void ETH_EnhancedDescriptorCmd(FunctionalState NewState);
N#endif /* USE_ENHANCED_DMA_DESCRIPTORS */
N
N/** 
N  * @brief  PHY  
N  */ 
Nuint16_t ETH_ReadPHYRegister(uint16_t PHYAddress, uint16_t PHYReg);
Nuint32_t ETH_WritePHYRegister(uint16_t PHYAddress, uint16_t PHYReg, uint16_t PHYValue);
Nuint32_t ETH_PHYLoopBackCmd(uint16_t PHYAddress, FunctionalState NewState);
N
N/** 
N  * @brief  MAC  
N  */ 
Nvoid ETH_MACTransmissionCmd(FunctionalState NewState);
Nvoid ETH_MACReceptionCmd(FunctionalState NewState);
NFlagStatus ETH_GetFlowControlBusyStatus(void);
Nvoid ETH_InitiatePauseControlFrame(void);  
Nvoid ETH_BackPressureActivationCmd(FunctionalState NewState); 
NFlagStatus ETH_GetMACFlagStatus(uint32_t ETH_MAC_FLAG);  
NITStatus ETH_GetMACITStatus(uint32_t ETH_MAC_IT);
Nvoid ETH_MACITConfig(uint32_t ETH_MAC_IT, FunctionalState NewState);
Nvoid ETH_MACAddressConfig(uint32_t MacAddr, uint8_t *Addr);
Nvoid ETH_GetMACAddress(uint32_t MacAddr, uint8_t *Addr);
Nvoid ETH_MACAddressPerfectFilterCmd(uint32_t MacAddr, FunctionalState NewState);
Nvoid ETH_MACAddressFilterConfig(uint32_t MacAddr, uint32_t Filter);
Nvoid ETH_MACAddressMaskBytesFilterConfig(uint32_t MacAddr, uint32_t MaskByte);
N
N/** 
N  * @brief  DMA Tx/Rx descriptors  
N  */ 
Nvoid ETH_DMARxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff, uint32_t RxBuffCount);
Nvoid ETH_DMATxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, uint8_t* TxBuff, uint32_t TxBuffCount);
Nuint32_t ETH_CheckFrameReceived(void);
Nuint32_t ETH_Prepare_Transmit_Descriptors(u16 FrameLength);
NFrameTypeDef ETH_Get_Received_Frame(void);
NFlagStatus ETH_GetDMATxDescFlagStatus(ETH_DMADESCTypeDef *DMATxDesc, uint32_t ETH_DMATxDescFlag);
Nuint32_t ETH_GetDMATxDescCollisionCount(ETH_DMADESCTypeDef *DMATxDesc);
Nvoid ETH_SetDMATxDescOwnBit(ETH_DMADESCTypeDef *DMATxDesc);
Nvoid ETH_DMATxDescTransmitITConfig(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState);
Nvoid ETH_DMATxDescFrameSegmentConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_FrameSegment);
Nvoid ETH_DMATxDescChecksumInsertionConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_Checksum);
Nvoid ETH_DMATxDescCRCCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState);
Nvoid ETH_DMATxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState);
Nvoid ETH_DMATxDescShortFramePaddingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState);
Nvoid ETH_DMATxDescBufferSizeConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t BufferSize1, uint32_t BufferSize2);
NFlagStatus ETH_GetDMARxDescFlagStatus(ETH_DMADESCTypeDef *DMARxDesc, uint32_t ETH_DMARxDescFlag);
N#ifdef USE_ENHANCED_DMA_DESCRIPTORS
N FlagStatus ETH_GetDMAPTPRxDescExtendedFlagStatus(ETH_DMADESCTypeDef *DMAPTPRxDesc, uint32_t ETH_DMAPTPRxDescExtendedFlag);
N#endif /* USE_ENHANCED_DMA_DESCRIPTORS */
Nvoid ETH_SetDMARxDescOwnBit(ETH_DMADESCTypeDef *DMARxDesc);
Nuint32_t ETH_GetDMARxDescFrameLength(ETH_DMADESCTypeDef *DMARxDesc);
Nvoid ETH_DMARxDescReceiveITConfig(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState);
Nvoid ETH_DMARxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState);
Nuint32_t ETH_GetDMARxDescBufferSize(ETH_DMADESCTypeDef *DMARxDesc, uint32_t DMARxDesc_Buffer);
NFrameTypeDef ETH_Get_Received_Frame_interrupt(void);
N/** 
N  * @brief  DMA
N  */ 
NFlagStatus ETH_GetDMAFlagStatus(uint32_t ETH_DMA_FLAG);
Nvoid ETH_DMAClearFlag(uint32_t ETH_DMA_FLAG);
NITStatus ETH_GetDMAITStatus(uint32_t ETH_DMA_IT);
Nvoid ETH_DMAClearITPendingBit(uint32_t ETH_DMA_IT);
Nuint32_t ETH_GetTransmitProcessState(void);
Nuint32_t ETH_GetReceiveProcessState(void);
Nvoid ETH_FlushTransmitFIFO(void);
NFlagStatus ETH_GetFlushTransmitFIFOStatus(void);
Nvoid ETH_DMATransmissionCmd(FunctionalState NewState);
Nvoid ETH_DMAReceptionCmd(FunctionalState NewState);
Nvoid ETH_DMAITConfig(uint32_t ETH_DMA_IT, FunctionalState NewState);
NFlagStatus ETH_GetDMAOverflowStatus(uint32_t ETH_DMA_Overflow);
Nuint32_t ETH_GetRxOverflowMissedFrameCounter(void);
Nuint32_t ETH_GetBufferUnavailableMissedFrameCounter(void);
Nuint32_t ETH_GetCurrentTxDescStartAddress(void);
Nuint32_t ETH_GetCurrentRxDescStartAddress(void);
Nuint32_t ETH_GetCurrentTxBufferAddress(void);
Nuint32_t ETH_GetCurrentRxBufferAddress(void);
Nvoid ETH_ResumeDMATransmission(void);
Nvoid ETH_ResumeDMAReception(void);
Nvoid ETH_SetReceiveWatchdogTimer(uint8_t Value);
N
N
N/** 
N  * @brief  PMT  
N  */ 
Nvoid ETH_ResetWakeUpFrameFilterRegisterPointer(void);
Nvoid ETH_SetWakeUpFrameFilterRegister(uint32_t *Buffer);
Nvoid ETH_GlobalUnicastWakeUpCmd(FunctionalState NewState);
NFlagStatus ETH_GetPMTFlagStatus(uint32_t ETH_PMT_FLAG);
Nvoid ETH_WakeUpFrameDetectionCmd(FunctionalState NewState);
Nvoid ETH_MagicPacketDetectionCmd(FunctionalState NewState);
Nvoid ETH_PowerDownCmd(FunctionalState NewState);
N
N/** 
N  * @brief  MMC  
N  */ 
Nvoid ETH_MMCCounterFullPreset(void);
Nvoid ETH_MMCCounterHalfPreset(void);
Nvoid ETH_MMCCounterFreezeCmd(FunctionalState NewState);
Nvoid ETH_MMCResetOnReadCmd(FunctionalState NewState);
Nvoid ETH_MMCCounterRolloverCmd(FunctionalState NewState);
Nvoid ETH_MMCCountersReset(void);
Nvoid ETH_MMCITConfig(uint32_t ETH_MMC_IT, FunctionalState NewState);
NITStatus ETH_GetMMCITStatus(uint32_t ETH_MMC_IT);
Nuint32_t ETH_GetMMCRegister(uint32_t ETH_MMCReg);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F429_ETH_H */
N/**
N  * @}
N  */ 
N
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 63 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "LAN8742A.h"
L 1 "..\..\Lwip\Bsp\LAN8742A\LAN8742A.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f4x7_eth_bsp.h
N  * @author  MCD Application Team
N  * @version V1.1.0
N  * @date    31-July-2013 
N  * @brief   Header for stm32f4x7_eth_bsp.c file.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F429_ETH_BSP_H
N#define __STM32F429_ETH_BSP_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N#include "stm32f429_eth.h"
N#include "netif.h"
L 1 "..\..\Lwip\lwip-1.4.1\src\include\lwip\netif.h" 1
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_NETIF_H__
N#define __LWIP_NETIF_H__
N
N#include "lwip/opt.h"
L 1 "..\..\Lwip\lwip-1.4.1\src\include\lwip/opt.h" 1
N/**
N * @file
N *
N * lwIP Options Configuration
N */
N
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_OPT_H__
N#define __LWIP_OPT_H__
N
N/*
N * Include user defined options first. Anything not defined in these files
N * will be set to standard values. Override anything you dont like!
N */
N#include "lwipopts.h"
L 1 "..\..\Lwip\App\lwipopts.h" 1
N/**
N  ******************************************************************************
N  * @file    lwipopts.h
N  * @author  MCD Application Team
N  * @version V1.1.0
N  * @date    31-July-2013
N  * @brief   lwIP Options Configuration.
N  *          This file is based on Utilities\lwip_v1.4.1\src\include\lwip\opt.h 
N  *          and contains the lwIP configuration for the STM32F4x7 demonstration.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N#ifndef __LWIPOPTS_H__
N#define __LWIPOPTS_H__
N
N/**
N * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
N * critical regions during buffer allocation, deallocation and memory
N * allocation and deallocation.
N */
N#define SYS_LIGHTWEIGHT_PROT    0
N
N/**
N * NO_SYS==1: Provides VERY minimal functionality. Otherwise,
N * use lwIP facilities.
N */
N#define NO_SYS                  1
N
N/**
N * NO_SYS_NO_TIMERS==1: Drop support for sys_timeout when NO_SYS==1
N * Mainly for compatibility to old versions.
N */
N#define NO_SYS_NO_TIMERS        1
N
N/* ---------- Memory options ---------- */
N/* MEM_ALIGNMENT: should be set to the alignment of the CPU for which
N   lwIP is compiled. 4 byte alignment -> define MEM_ALIGNMENT to 4, 2
N   byte alignment -> define MEM_ALIGNMENT to 2. */
N#define MEM_ALIGNMENT           4
N
N/* MEM_SIZE: the size of the heap memory. If the application will send
Na lot of data that needs to be copied, this should be set high. */
N#define MEM_SIZE                (20*1024)
N
N/* MEMP_NUM_PBUF: the number of memp struct pbufs. If the application
N   sends a lot of data out of ROM (or other static memory), this
N   should be set high. */
N//#define MEMP_NUM_PBUF           100
N/* MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
N   per active UDP "connection". */
N#define MEMP_NUM_UDP_PCB        12
N/* MEMP_NUM_TCP_PCB: the number of simulatenously active TCP
N   connections. */
N#define MEMP_NUM_TCP_PCB        6
N/* MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP
N   connections. */
N#define MEMP_NUM_TCP_PCB_LISTEN  1
N/* MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP
N   segments. */
N#define MEMP_NUM_TCP_SEG        40
N/* MEMP_NUM_SYS_TIMEOUT: the number of simulateously active
N   timeouts. */
N#define MEMP_NUM_SYS_TIMEOUT    10
N
N
N/* ---------- Pbuf options ---------- */
N/* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */
N#define PBUF_POOL_SIZE          8
N
N/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
N#define PBUF_POOL_BUFSIZE       (1500 - 40)/* TCP_MSS = (Ethernet MTU - IP header size - TCP header size) */
N
N#define LWIP_DNS                 1
N
N/* ---------- TCP options ---------- */
N#define LWIP_TCP                1
N#define TCP_TTL                 255
N
N/* Controls if TCP should queue segments that arrive out of
N   order. Define to 0 if your device is low on memory. */
N#define TCP_QUEUE_OOSEQ         1
N
N/* TCP Maximum segment size. */
N#define TCP_MSS                 (1500 - 140)/* TCP_MSS = (Ethernet MTU - IP header size - TCP header size) */
N
N/* TCP sender buffer space (bytes). */
N#define TCP_SND_BUF             (4*TCP_MSS)
N
N/*  TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least
N  as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work. */
N
N#define TCP_SND_QUEUELEN        (4* TCP_SND_BUF/TCP_MSS)
N
N/* TCP receive window. */
N#define TCP_WND                 (2*TCP_MSS)
N
N
N/* ---------- ICMP options ---------- */
N#define LWIP_ICMP                       1
N
N#define LWIP_ARP                  1 //值1使能
N/* ---------- DHCP options ---------- */
N/* Define LWIP_DHCP to 1 if you want DHCP configuration of
N   interfaces. DHCP is not implemented in lwIP 0.5.1, however, so
N   turning this on does currently not work. */
N#define LWIP_DHCP               1
N
N
N/* ---------- UDP options ---------- */
N#define LWIP_UDP                1
N#define UDP_TTL                 255
N/* ---------- DNS options ---------- */
N#define DNS_TABLE_SIZE               10
N#define DNS_LOCAL_HOSTLIST_IS_DYNAMIC   1
N#define DNS_MAX_TTL               604800//最大生存时间
N/* ---------- Statistics options ---------- */
N#define LWIP_STATS 0
N#define LWIP_PROVIDE_ERRNO     1
N
N/* ---------- link callback options ---------- */
N/* LWIP_NETIF_LINK_CALLBACK==1: Support a callback function from an interface
N * whenever the link changes (i.e., link down)
N */
N#define LWIP_NETIF_LINK_CALLBACK        1
N
N/*
N   --------------------------------------
N   ---------- Checksum options ----------
N   --------------------------------------
N*/
N
N/* 
NThe STM32F4x7 allows computing and verifying the IP, UDP, TCP and ICMP checksums by hardware:
N - To use this feature let the following define uncommented.
N - To disable it and process by CPU comment the  the checksum.
N*/
N#define CHECKSUM_BY_HARDWARE 
N
N
N#ifdef CHECKSUM_BY_HARDWARE
N  /* CHECKSUM_GEN_IP==0: Generate checksums by hardware for outgoing IP packets.*/
N  #define CHECKSUM_GEN_IP                 0
N  /* CHECKSUM_GEN_UDP==0: Generate checksums by hardware for outgoing UDP packets.*/
N  #define CHECKSUM_GEN_UDP                0
N  /* CHECKSUM_GEN_TCP==0: Generate checksums by hardware for outgoing TCP packets.*/
N  #define CHECKSUM_GEN_TCP                0 
N  /* CHECKSUM_CHECK_IP==0: Check checksums by hardware for incoming IP packets.*/
N  #define CHECKSUM_CHECK_IP               0
N  /* CHECKSUM_CHECK_UDP==0: Check checksums by hardware for incoming UDP packets.*/
N  #define CHECKSUM_CHECK_UDP              0
N  /* CHECKSUM_CHECK_TCP==0: Check checksums by hardware for incoming TCP packets.*/
N  #define CHECKSUM_CHECK_TCP              0
N  /* CHECKSUM_CHECK_ICMP==0: Check checksums by hardware for incoming ICMP packets.*/
N  #define CHECKSUM_GEN_ICMP               0
N#else
S  /* CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.*/
S  #define CHECKSUM_GEN_IP                 1
S  /* CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.*/
S  #define CHECKSUM_GEN_UDP                1
S  /* CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.*/
S  #define CHECKSUM_GEN_TCP                1
S  /* CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.*/
S  #define CHECKSUM_CHECK_IP               1
S  /* CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.*/
S  #define CHECKSUM_CHECK_UDP              1
S  /* CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.*/
S  #define CHECKSUM_CHECK_TCP              1
S  /* CHECKSUM_CHECK_ICMP==1: Check checksums by hardware for incoming ICMP packets.*/
S  #define CHECKSUM_GEN_ICMP               1
N#endif
N
N
N/*
N   ----------------------------------------------
N   ---------- Sequential layer options ----------
N   ----------------------------------------------
N*/
N/**
N * LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c)
N */
N#define LWIP_NETCONN                    0
N
N/*
N   ------------------------------------
N   ---------- Socket options ----------
N   ------------------------------------
N*/
N/**
N * LWIP_SOCKET==1: Enable Socket API (require to use sockets.c)
N */
N#define LWIP_SOCKET                     0
N
N#if 0
S/*
S   ----------------------------------------
S   ---------- Lwip Debug options ----------
S   ----------------------------------------
S*/
S//#define LWIP_DEBUG                      1
S#ifndef U8_F
S#define U8_F "c"
S#endif
S
S#ifndef S8_F
S#define S8_F "c"
S#endif
S
S#ifndef X8_F
S#define X8_F "x"
S#endif
S
S#ifndef U16_F
S#define U16_F "u"
S#endif
S
S#ifndef S16_F
S#define S16_F "d"
S#endif
S
S#ifndef X16_F
S#define X16_F "x"
S#endif
S#ifndef U32_F
S#define U32_F "u"
S#endif
S#ifndef S32_F
S#define S32_F "d"
S#endif
S#ifndef X32_F
S#define X32_F "x"
S#endif
S
S
S//extern void UARTprintf(const char *pcString, ...);
S#define LWIP_PLATFORM_DIAG(x) {printf(x);}
S#define LWIP_DEBUG
S
S
S
S#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_OFF
S//#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_WARNING
S//#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_SERIOUS
S//#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_SEVERE
S
S//#define LWIP_DBG_TYPES_ON               LWIP_DBG_ON
S#define LWIP_DBG_TYPES_ON               (LWIP_DBG_ON|LWIP_DBG_TRACE|LWIP_DBG_STATE|LWIP_DBG_FRESH)
S
S//#define ETHARP_DEBUG                    LWIP_DBG_ON     
S//#define NETIF_DEBUG                     LWIP_DBG_ON     
S//#define PBUF_DEBUG                      LWIP_DBG_ON
S//#define API_LIB_DEBUG                   LWIP_DBG_ON
S//#define API_MSG_DEBUG                   LWIP_DBG_ON
S//#define SOCKETS_DEBUG                   LWIP_DBG_ON
S//#define ICMP_DEBUG                      LWIP_DBG_ON
S//#define IGMP_DEBUG                      LWIP_DBG_ON
S//#define INET_DEBUG                      LWIP_DBG_ON
S#define IP_DEBUG                        LWIP_DBG_ON     
S//#define IP_REASS_DEBUG                  LWIP_DBG_ON
S//#define RAW_DEBUG                       LWIP_DBG_ON
S//#define MEM_DEBUG                       LWIP_DBG_ON
S//#define MEMP_DEBUG                      LWIP_DBG_ON
S//#define SYS_DEBUG                       LWIP_DBG_ON
S#define TCP_DEBUG                       LWIP_DBG_ON
S//#define TCP_INPUT_DEBUG                 LWIP_DBG_ON
S//#define TCP_FR_DEBUG                    LWIP_DBG_ON
S//#define TCP_RTO_DEBUG                   LWIP_DBG_ON
S//#define TCP_CWND_DEBUG                  LWIP_DBG_ON
S//#define TCP_WND_DEBUG                   LWIP_DBG_ON
S#define TCP_OUTPUT_DEBUG                LWIP_DBG_ON
S//#define TCP_RST_DEBUG                   LWIP_DBG_ON
S//#define TCP_QLEN_DEBUG                  LWIP_DBG_ON
S//#define UDP_DEBUG                       LWIP_DBG_ON     
S//#define TCPIP_DEBUG                     LWIP_DBG_ON
S//#define PPP_DEBUG                       LWIP_DBG_ON
S//#define SLIP_DEBUG                      LWIP_DBG_ON
S//#define DHCP_DEBUG                      LWIP_DBG_ON     
S//#define AUTOIP_DEBUG                    LWIP_DBG_ON
S//#define SNMP_MSG_DEBUG                  LWIP_DBG_ON
S//#define SNMP_MIB_DEBUG                  LWIP_DBG_ON
S//#define DNS_DEBUG                       LWIP_DBG_ON
N#endif
N#endif /* __LWIPOPTS_H__ */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 46 "..\..\Lwip\lwip-1.4.1\src\include\lwip/opt.h" 2
N#include "lwip/debug.h"
L 1 "..\..\Lwip\lwip-1.4.1\src\include\lwip/debug.h" 1
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_DEBUG_H__
N#define __LWIP_DEBUG_H__
N
N#include "lwip/arch.h"
L 1 "..\..\Lwip\lwip-1.4.1\src\include\lwip/arch.h" 1
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_ARCH_H__
N#define __LWIP_ARCH_H__
N
N#ifndef LITTLE_ENDIAN
N#define LITTLE_ENDIAN 1234
N#endif
N
N#ifndef BIG_ENDIAN
N#define BIG_ENDIAN 4321
N#endif
N
N#include "arch/cc.h"
L 1 "..\..\Lwip\lwip-1.4.1\port\arch/cc.h" 1
N/*
N * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __CC_H__
N#define __CC_H__
N
N#include "cpu.h"
L 1 "..\..\Lwip\lwip-1.4.1\port\arch/cpu.h" 1
N/*
N * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __CPU_H__
N#define __CPU_H__
N
N#define BYTE_ORDER LITTLE_ENDIAN
N
N#endif /* __CPU_H__ */
L 36 "..\..\Lwip\lwip-1.4.1\port\arch/cc.h" 2
N
Ntypedef unsigned   char    u8_t;
Ntypedef signed     char    s8_t;
Ntypedef unsigned   short   u16_t;
Ntypedef signed     short   s16_t;
Ntypedef unsigned   long    u32_t;
Ntypedef signed     long    s32_t;
Ntypedef u32_t mem_ptr_t;
Ntypedef int sys_prot_t;
N
N#ifndef U16_F
N#define U16_F "hu"
N#endif
N
N#ifndef S16_F
N#define S16_F "d"
N#endif
N
N#ifndef X16_F
N#define X16_F "hx"
N#endif
N
N#ifndef U32_F
N#define U32_F "u"
N#endif
N
N#ifndef S32_F
N#define S32_F "d"
N#endif
N
N#ifndef X32_F
N#define X32_F "x"
N#endif
N
N#ifndef SZT_F
N#define SZT_F "uz" 
N#endif
N
N
N
N
N
N
N
N
N
N/* define compiler specific symbols */
N#if defined (__ICCARM__)
X#if 0L
S
S#define PACK_STRUCT_BEGIN
S#define PACK_STRUCT_STRUCT 
S#define PACK_STRUCT_END
S#define PACK_STRUCT_FIELD(x) x
S#define PACK_STRUCT_USE_INCLUDES
S
N#elif defined (__CC_ARM)
X#elif 1L
N
N#define PACK_STRUCT_BEGIN __packed
N#define PACK_STRUCT_STRUCT 
N#define PACK_STRUCT_END
N#define PACK_STRUCT_FIELD(x) x
N
N#elif defined (__GNUC__)
S
S#define PACK_STRUCT_BEGIN
S#define PACK_STRUCT_STRUCT __attribute__ ((__packed__))
S#define PACK_STRUCT_END
S#define PACK_STRUCT_FIELD(x) x
S
S#elif defined (__TASKING__)
S
S#define PACK_STRUCT_BEGIN
S#define PACK_STRUCT_STRUCT
S#define PACK_STRUCT_END
S#define PACK_STRUCT_FIELD(x) x
S
N#endif
N
N#define LWIP_PLATFORM_ASSERT(x) printf(x)
N
N#endif /* __CC_H__ */
L 44 "..\..\Lwip\lwip-1.4.1\src\include\lwip/arch.h" 2
N
N/** Temporary: define format string for size_t if not defined in cc.h */
N#ifndef SZT_F
S#define SZT_F U32_F
N#endif /* SZT_F */
N/** Temporary upgrade helper: define format string for u8_t as hex if not
N    defined in cc.h */
N#ifndef X8_F
N#define X8_F  "02x"
N#endif /* X8_F */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#ifndef PACK_STRUCT_BEGIN
S#define PACK_STRUCT_BEGIN
N#endif /* PACK_STRUCT_BEGIN */
N
N#ifndef PACK_STRUCT_END
S#define PACK_STRUCT_END
N#endif /* PACK_STRUCT_END */
N
N#ifndef PACK_STRUCT_FIELD
S#define PACK_STRUCT_FIELD(x) x
N#endif /* PACK_STRUCT_FIELD */
N
N
N#ifndef LWIP_UNUSED_ARG
N#define LWIP_UNUSED_ARG(x) (void)x
N#endif /* LWIP_UNUSED_ARG */ 
N
N
N#ifdef LWIP_PROVIDE_ERRNO
N
N#define  EPERM         1  /* Operation not permitted */
N#define  ENOENT        2  /* No such file or directory */
N#define  ESRCH         3  /* No such process */
N#define  EINTR         4  /* Interrupted system call */
N#define  EIO           5  /* I/O error */
N#define  ENXIO         6  /* No such device or address */
N#define  E2BIG         7  /* Arg list too long */
N#define  ENOEXEC       8  /* Exec format error */
N#define  EBADF         9  /* Bad file number */
N#define  ECHILD       10  /* No child processes */
N#define  EAGAIN       11  /* Try again */
N#define  ENOMEM       12  /* Out of memory */
N#define  EACCES       13  /* Permission denied */
N#define  EFAULT       14  /* Bad address */
N#define  ENOTBLK      15  /* Block device required */
N#define  EBUSY        16  /* Device or resource busy */
N#define  EEXIST       17  /* File exists */
N#define  EXDEV        18  /* Cross-device link */
N#define  ENODEV       19  /* No such device */
N#define  ENOTDIR      20  /* Not a directory */
N#define  EISDIR       21  /* Is a directory */
N#define  EINVAL       22  /* Invalid argument */
N#define  ENFILE       23  /* File table overflow */
N#define  EMFILE       24  /* Too many open files */
N#define  ENOTTY       25  /* Not a typewriter */
N#define  ETXTBSY      26  /* Text file busy */
N#define  EFBIG        27  /* File too large */
N#define  ENOSPC       28  /* No space left on device */
N#define  ESPIPE       29  /* Illegal seek */
N#define  EROFS        30  /* Read-only file system */
N#define  EMLINK       31  /* Too many links */
N#define  EPIPE        32  /* Broken pipe */
N#define  EDOM         33  /* Math argument out of domain of func */
N#define  ERANGE       34  /* Math result not representable */
N#define  EDEADLK      35  /* Resource deadlock would occur */
N#define  ENAMETOOLONG 36  /* File name too long */
N#define  ENOLCK       37  /* No record locks available */
N#define  ENOSYS       38  /* Function not implemented */
N#define  ENOTEMPTY    39  /* Directory not empty */
N#define  ELOOP        40  /* Too many symbolic links encountered */
N#define  EWOULDBLOCK  EAGAIN  /* Operation would block */
N#define  ENOMSG       42  /* No message of desired type */
N#define  EIDRM        43  /* Identifier removed */
N#define  ECHRNG       44  /* Channel number out of range */
N#define  EL2NSYNC     45  /* Level 2 not synchronized */
N#define  EL3HLT       46  /* Level 3 halted */
N#define  EL3RST       47  /* Level 3 reset */
N#define  ELNRNG       48  /* Link number out of range */
N#define  EUNATCH      49  /* Protocol driver not attached */
N#define  ENOCSI       50  /* No CSI structure available */
N#define  EL2HLT       51  /* Level 2 halted */
N#define  EBADE        52  /* Invalid exchange */
N#define  EBADR        53  /* Invalid request descriptor */
N#define  EXFULL       54  /* Exchange full */
N#define  ENOANO       55  /* No anode */
N#define  EBADRQC      56  /* Invalid request code */
N#define  EBADSLT      57  /* Invalid slot */
N
N#define  EDEADLOCK    EDEADLK
N
N#define  EBFONT       59  /* Bad font file format */
N#define  ENOSTR       60  /* Device not a stream */
N#define  ENODATA      61  /* No data available */
N#define  ETIME        62  /* Timer expired */
N#define  ENOSR        63  /* Out of streams resources */
N#define  ENONET       64  /* Machine is not on the network */
N#define  ENOPKG       65  /* Package not installed */
N#define  EREMOTE      66  /* Object is remote */
N#define  ENOLINK      67  /* Link has been severed */
N#define  EADV         68  /* Advertise error */
N#define  ESRMNT       69  /* Srmount error */
N#define  ECOMM        70  /* Communication error on send */
N#define  EPROTO       71  /* Protocol error */
N#define  EMULTIHOP    72  /* Multihop attempted */
N#define  EDOTDOT      73  /* RFS specific error */
N#define  EBADMSG      74  /* Not a data message */
N#define  EOVERFLOW    75  /* Value too large for defined data type */
N#define  ENOTUNIQ     76  /* Name not unique on network */
N#define  EBADFD       77  /* File descriptor in bad state */
N#define  EREMCHG      78  /* Remote address changed */
N#define  ELIBACC      79  /* Can not access a needed shared library */
N#define  ELIBBAD      80  /* Accessing a corrupted shared library */
N#define  ELIBSCN      81  /* .lib section in a.out corrupted */
N#define  ELIBMAX      82  /* Attempting to link in too many shared libraries */
N#define  ELIBEXEC     83  /* Cannot exec a shared library directly */
N#define  EILSEQ       84  /* Illegal byte sequence */
N#define  ERESTART     85  /* Interrupted system call should be restarted */
N#define  ESTRPIPE     86  /* Streams pipe error */
N#define  EUSERS       87  /* Too many users */
N#define  ENOTSOCK     88  /* Socket operation on non-socket */
N#define  EDESTADDRREQ 89  /* Destination address required */
N#define  EMSGSIZE     90  /* Message too long */
N#define  EPROTOTYPE   91  /* Protocol wrong type for socket */
N#define  ENOPROTOOPT  92  /* Protocol not available */
N#define  EPROTONOSUPPORT 93  /* Protocol not supported */
N#define  ESOCKTNOSUPPORT 94  /* Socket type not supported */
N#define  EOPNOTSUPP      95  /* Operation not supported on transport endpoint */
N#define  EPFNOSUPPORT    96  /* Protocol family not supported */
N#define  EAFNOSUPPORT    97  /* Address family not supported by protocol */
N#define  EADDRINUSE      98  /* Address already in use */
N#define  EADDRNOTAVAIL   99  /* Cannot assign requested address */
N#define  ENETDOWN       100  /* Network is down */
N#define  ENETUNREACH    101  /* Network is unreachable */
N#define  ENETRESET      102  /* Network dropped connection because of reset */
N#define  ECONNABORTED   103  /* Software caused connection abort */
N#define  ECONNRESET     104  /* Connection reset by peer */
N#define  ENOBUFS        105  /* No buffer space available */
N#define  EISCONN        106  /* Transport endpoint is already connected */
N#define  ENOTCONN       107  /* Transport endpoint is not connected */
N#define  ESHUTDOWN      108  /* Cannot send after transport endpoint shutdown */
N#define  ETOOMANYREFS   109  /* Too many references: cannot splice */
N#define  ETIMEDOUT      110  /* Connection timed out */
N#define  ECONNREFUSED   111  /* Connection refused */
N#define  EHOSTDOWN      112  /* Host is down */
N#define  EHOSTUNREACH   113  /* No route to host */
N#define  EALREADY       114  /* Operation already in progress */
N#define  EINPROGRESS    115  /* Operation now in progress */
N#define  ESTALE         116  /* Stale NFS file handle */
N#define  EUCLEAN        117  /* Structure needs cleaning */
N#define  ENOTNAM        118  /* Not a XENIX named type file */
N#define  ENAVAIL        119  /* No XENIX semaphores available */
N#define  EISNAM         120  /* Is a named type file */
N#define  EREMOTEIO      121  /* Remote I/O error */
N#define  EDQUOT         122  /* Quota exceeded */
N
N#define  ENOMEDIUM      123  /* No medium found */
N#define  EMEDIUMTYPE    124  /* Wrong medium type */
N
N#ifndef errno
Nextern int errno;
N#endif
N
N#endif /* LWIP_PROVIDE_ERRNO */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __LWIP_ARCH_H__ */
L 36 "..\..\Lwip\lwip-1.4.1\src\include\lwip/debug.h" 2
N//#include "opt.h"
N/*C标准库文件*/
N#include <string.h>
N#include <stdlib.h>
N#include <stdio.h>
N#include "lwipopts.h"
N
N//#define TCP_DEBUG_USART_PRINTF_S(x)    printf("%s\n",x)
N#define TCP_DEBUG_USART_PRINTF_S(x) 
N
N/** lower two bits indicate debug level
N * - 0 all
N * - 1 warning
N * - 2 serious
N * - 3 severe
N */
N#define LWIP_DBG_LEVEL_ALL     0x00
N#define LWIP_DBG_LEVEL_OFF     LWIP_DBG_LEVEL_ALL /* compatibility define only */
N#define LWIP_DBG_LEVEL_WARNING 0x01 /* bad checksums, dropped packets, ... */
N#define LWIP_DBG_LEVEL_SERIOUS 0x02 /* memory allocation failures, ... */
N#define LWIP_DBG_LEVEL_SEVERE  0x03
N#define LWIP_DBG_MASK_LEVEL    0x03
N
N/** flag for LWIP_DEBUGF to enable that debug message */
N#define LWIP_DBG_ON            0x80U
N/** flag for LWIP_DEBUGF to disable that debug message */
N#define LWIP_DBG_OFF           0x00U
N
N/** flag for LWIP_DEBUGF indicating a tracing message (to follow program flow) */
N#define LWIP_DBG_TRACE         0x40U
N/** flag for LWIP_DEBUGF indicating a state debug message (to follow module states) */
N#define LWIP_DBG_STATE         0x20U
N/** flag for LWIP_DEBUGF indicating newly added code, not thoroughly tested yet */
N#define LWIP_DBG_FRESH         0x10U
N/** flag for LWIP_DEBUGF to halt after printing this debug message */
N#define LWIP_DBG_HALT          0x08U
N
N#ifndef LWIP_NOASSERT
N#define LWIP_ASSERT(message, assertion) do { if(!(assertion)) \
N  LWIP_PLATFORM_ASSERT(message); } while(0)
X#define LWIP_ASSERT(message, assertion) do { if(!(assertion))   LWIP_PLATFORM_ASSERT(message); } while(0)
N#else  /* LWIP_NOASSERT */
S#define LWIP_ASSERT(message, assertion) 
N#endif /* LWIP_NOASSERT */
N
N/** if "expression" isn't true, then print "message" and execute "handler" expression */
N#ifndef LWIP_ERROR
N#define LWIP_ERROR(message, expression, handler) do { if (!(expression)) { \
N  LWIP_PLATFORM_ASSERT(message); handler;}} while(0)
X#define LWIP_ERROR(message, expression, handler) do { if (!(expression)) {   LWIP_PLATFORM_ASSERT(message); handler;}} while(0)
N#endif /* LWIP_ERROR */
N
N
N
N//#define LWIP_DEBUG
N#ifdef LWIP_DEBUG
S/** print debug message only if debug message type is enabled...
S *  AND is of correct type AND is at least LWIP_DBG_LEVEL
S */
S#ifndef U8_F
S#define U8_F "c"
S#endif
S
S#ifndef S8_F
S#define S8_F "c"
S#endif
S
S#ifndef X8_F
S#define X8_F "x"
S#endif
S
S#ifndef U16_F
S#define U16_F "u"
S#endif
S
S#ifndef S16_F
S#define S16_F "d"
S#endif
S
S#ifndef X16_F
S#define X16_F "x"
S#endif
S#ifndef U32_F
S#define U32_F "u"
S#endif
S#ifndef S32_F
S#define S32_F "d"
S#endif
S#ifndef X32_F
S#define X32_F "x"
S#endif
S
S#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_OFF
S//#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_WARNING
S//#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_SERIOUS
S//#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_SEVERE
S
S#define LWIP_DBG_TYPES_ON               (LWIP_DBG_ON|LWIP_DBG_TRACE|LWIP_DBG_STATE|LWIP_DBG_FRESH)
S//#define ETHARP_DEBUG                    LWIP_DBG_ON     
S//#define NETIF_DEBUG                     LWIP_DBG_ON     
S//#define PBUF_DEBUG                      LWIP_DBG_ON
S//#define API_LIB_DEBUG                   LWIP_DBG_ON
S//#define API_MSG_DEBUG                   LWIP_DBG_ON
S//#define SOCKETS_DEBUG                   LWIP_DBG_ON
S//#define ICMP_DEBUG                      LWIP_DBG_ON
S//#define IGMP_DEBUG                      LWIP_DBG_ON
S//#define INET_DEBUG                      LWIP_DBG_ON
S//#define IP_DEBUG                        LWIP_DBG_ON     
S//#define IP_REASS_DEBUG                  LWIP_DBG_ON
S#define RAW_DEBUG                       LWIP_DBG_ON
S//#define MEM_DEBUG                       LWIP_DBG_ON
S//#define MEMP_DEBUG                      LWIP_DBG_ON
S//#define SYS_DEBUG                       LWIP_DBG_ON
S#define TCP_DEBUG                       LWIP_DBG_ON
S#define TCP_INPUT_DEBUG                 LWIP_DBG_ON
S#define TCP_FR_DEBUG                    LWIP_DBG_ON
S#define TCP_RTO_DEBUG                   LWIP_DBG_ON
S#define TCP_CWND_DEBUG                  LWIP_DBG_ON
S#define TCP_WND_DEBUG                   LWIP_DBG_ON
S#define TCP_OUTPUT_DEBUG                LWIP_DBG_ON
S#define TCP_RST_DEBUG                   LWIP_DBG_ON
S#define TCP_QLEN_DEBUG                  LWIP_DBG_ON
S//#define UDP_DEBUG                       LWIP_DBG_ON     
S//#define TCPIP_DEBUG                     LWIP_DBG_ON
S//#define PPP_DEBUG                       LWIP_DBG_ON
S//#define SLIP_DEBUG                      LWIP_DBG_ON
S//#define DHCP_DEBUG                      LWIP_DBG_ON     
S//#define AUTOIP_DEBUG                    LWIP_DBG_ON
S//#define SNMP_MSG_DEBUG                  LWIP_DBG_ON
S//#define SNMP_MIB_DEBUG                  LWIP_DBG_ON
S//#define DNS_DEBUG                       LWIP_DBG_ON
S
S#define LWIP_PLATFORM_DIAG printf
S#define LWIP_DEBUGF(debug, message) do { \
S                               if ( \
S                                   ((debug) & LWIP_DBG_ON) && \
S                                   ((debug) & LWIP_DBG_TYPES_ON) && \
S                                   ((s16_t)((debug) & LWIP_DBG_MASK_LEVEL) >= LWIP_DBG_MIN_LEVEL)) { \
S                                 LWIP_PLATFORM_DIAG message; \
S                                 if ((debug) & LWIP_DBG_HALT) { \
S                                   while(1); \
S                                 } \
S                               } \
S                             } while(0)
X#define LWIP_DEBUGF(debug, message) do {                                if (                                    ((debug) & LWIP_DBG_ON) &&                                    ((debug) & LWIP_DBG_TYPES_ON) &&                                    ((s16_t)((debug) & LWIP_DBG_MASK_LEVEL) >= LWIP_DBG_MIN_LEVEL)) {                                  LWIP_PLATFORM_DIAG message;                                  if ((debug) & LWIP_DBG_HALT) {                                    while(1);                                  }                                }                              } while(0)
S
N#else  /* LWIP_DEBUG */
N#define LWIP_DEBUGF(debug, message) 
N#endif /* LWIP_DEBUG */
N
N#endif /* __LWIP_DEBUG_H__ */
N
L 47 "..\..\Lwip\lwip-1.4.1\src\include\lwip/opt.h" 2
N
N/*
N   -----------------------------------------------
N   ---------- Platform specific locking ----------
N   -----------------------------------------------
N*/
N
N/**
N * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
N * critical regions during buffer allocation, deallocation and memory
N * allocation and deallocation.
N */
N#ifndef SYS_LIGHTWEIGHT_PROT
S#define SYS_LIGHTWEIGHT_PROT            0
N#endif
N
N/** 
N * NO_SYS==1: Provides VERY minimal functionality. Otherwise,
N * use lwIP facilities.
N */
N#ifndef NO_SYS
S#define NO_SYS                          0
N#endif
N
N/**
N * NO_SYS_NO_TIMERS==1: Drop support for sys_timeout when NO_SYS==1
N * Mainly for compatibility to old versions.
N */
N#ifndef NO_SYS_NO_TIMERS
S#define NO_SYS_NO_TIMERS                0
N#endif
N
N/**
N * MEMCPY: override this if you have a faster implementation at hand than the
N * one included in your C library
N */
N#ifndef MEMCPY
N#define MEMCPY(dst,src,len)             memcpy(dst,src,len)
N#endif
N
N/**
N * SMEMCPY: override this with care! Some compilers (e.g. gcc) can inline a
N * call to memcpy() if the length is known at compile time and is small.
N */
N#ifndef SMEMCPY
N#define SMEMCPY(dst,src,len)            memcpy(dst,src,len)
N#endif
N
N/*
N   ------------------------------------
N   ---------- Memory options ----------
N   ------------------------------------
N*/
N/**
N * MEM_LIBC_MALLOC==1: Use malloc/free/realloc provided by your C-library
N * instead of the lwip internal allocator. Can save code size if you
N * already use it.
N */
N#ifndef MEM_LIBC_MALLOC
N#define MEM_LIBC_MALLOC                 0
N#endif
N
N/**
N* MEMP_MEM_MALLOC==1: Use mem_malloc/mem_free instead of the lwip pool allocator.
N* Especially useful with MEM_LIBC_MALLOC but handle with care regarding execution
N* speed and usage from interrupts!
N*/
N#ifndef MEMP_MEM_MALLOC
N#define MEMP_MEM_MALLOC                 0
N#endif
N
N/**
N * MEM_ALIGNMENT: should be set to the alignment of the CPU
N *    4 byte alignment -> #define MEM_ALIGNMENT 4
N *    2 byte alignment -> #define MEM_ALIGNMENT 2
N */
N#ifndef MEM_ALIGNMENT
S#define MEM_ALIGNMENT                   1
N#endif
N
N/**
N * MEM_SIZE: the size of the heap memory. If the application will send
N * a lot of data that needs to be copied, this should be set high.
N */
N#ifndef MEM_SIZE
S#define MEM_SIZE                        1600
N#endif
N
N/**
N * MEMP_SEPARATE_POOLS: if defined to 1, each pool is placed in its own array.
N * This can be used to individually change the location of each pool.
N * Default is one big array for all pools
N */
N#ifndef MEMP_SEPARATE_POOLS
N#define MEMP_SEPARATE_POOLS             0
N#endif
N
N/**
N * MEMP_OVERFLOW_CHECK: memp overflow protection reserves a configurable
N * amount of bytes before and after each memp element in every pool and fills
N * it with a prominent default value.
N *    MEMP_OVERFLOW_CHECK == 0 no checking
N *    MEMP_OVERFLOW_CHECK == 1 checks each element when it is freed
N *    MEMP_OVERFLOW_CHECK >= 2 checks each element in every pool every time
N *      memp_malloc() or memp_free() is called (useful but slow!)
N */
N#ifndef MEMP_OVERFLOW_CHECK
N#define MEMP_OVERFLOW_CHECK             0
N#endif
N
N/**
N * MEMP_SANITY_CHECK==1: run a sanity check after each memp_free() to make
N * sure that there are no cycles in the linked lists.
N */
N#ifndef MEMP_SANITY_CHECK
N#define MEMP_SANITY_CHECK               0
N#endif
N
N/**
N * MEM_USE_POOLS==1: Use an alternative to malloc() by allocating from a set
N * of memory pools of various sizes. When mem_malloc is called, an element of
N * the smallest pool that can provide the length needed is returned.
N * To use this, MEMP_USE_CUSTOM_POOLS also has to be enabled.
N */
N#ifndef MEM_USE_POOLS
N#define MEM_USE_POOLS                   0
N#endif
N
N/**
N * MEM_USE_POOLS_TRY_BIGGER_POOL==1: if one malloc-pool is empty, try the next
N * bigger pool - WARNING: THIS MIGHT WASTE MEMORY but it can make a system more
N * reliable. */
N#ifndef MEM_USE_POOLS_TRY_BIGGER_POOL
N#define MEM_USE_POOLS_TRY_BIGGER_POOL   0
N#endif
N
N/**
N * MEMP_USE_CUSTOM_POOLS==1: whether to include a user file lwippools.h
N * that defines additional pools beyond the "standard" ones required
N * by lwIP. If you set this to 1, you must have lwippools.h in your 
N * inlude path somewhere. 
N */
N#ifndef MEMP_USE_CUSTOM_POOLS
N#define MEMP_USE_CUSTOM_POOLS           0
N#endif
N
N/**
N * Set this to 1 if you want to free PBUF_RAM pbufs (or call mem_free()) from
N * interrupt context (or another context that doesn't allow waiting for a
N * semaphore).
N * If set to 1, mem_malloc will be protected by a semaphore and SYS_ARCH_PROTECT,
N * while mem_free will only use SYS_ARCH_PROTECT. mem_malloc SYS_ARCH_UNPROTECTs
N * with each loop so that mem_free can run.
N *
N * ATTENTION: As you can see from the above description, this leads to dis-/
N * enabling interrupts often, which can be slow! Also, on low memory, mem_malloc
N * can need longer.
N *
N * If you don't want that, at least for NO_SYS=0, you can still use the following
N * functions to enqueue a deallocation call which then runs in the tcpip_thread
N * context:
N * - pbuf_free_callback(p);
N * - mem_free_callback(m);
N */
N#ifndef LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
N#define LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT 0
N#endif
N
N/*
N   ------------------------------------------------
N   ---------- Internal Memory Pool Sizes ----------
N   ------------------------------------------------
N*/
N/**
N * MEMP_NUM_PBUF: the number of memp struct pbufs (used for PBUF_ROM and PBUF_REF).
N * If the application sends a lot of data out of ROM (or other static memory),
N * this should be set high.
N */
N#ifndef MEMP_NUM_PBUF
N#define MEMP_NUM_PBUF                   16
N#endif
N
N/**
N * MEMP_NUM_RAW_PCB: Number of raw connection PCBs
N * (requires the LWIP_RAW option)
N */
N#ifndef MEMP_NUM_RAW_PCB
N#define MEMP_NUM_RAW_PCB                4
N#endif
N
N/**
N * MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
N * per active UDP "connection".
N * (requires the LWIP_UDP option)
N */
N#ifndef MEMP_NUM_UDP_PCB
S#define MEMP_NUM_UDP_PCB                4
N#endif
N
N/**
N * MEMP_NUM_TCP_PCB: the number of simulatenously active TCP connections.
N * (requires the LWIP_TCP option)
N */
N#ifndef MEMP_NUM_TCP_PCB
S#define MEMP_NUM_TCP_PCB                5
N#endif
N
N/**
N * MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP connections.
N * (requires the LWIP_TCP option)
N */
N#ifndef MEMP_NUM_TCP_PCB_LISTEN
S#define MEMP_NUM_TCP_PCB_LISTEN         8
N#endif
N
N/**
N * MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP segments.
N * (requires the LWIP_TCP option)
N */
N#ifndef MEMP_NUM_TCP_SEG
S#define MEMP_NUM_TCP_SEG                16
N#endif
N
N/**
N * MEMP_NUM_REASSDATA: the number of IP packets simultaneously queued for
N * reassembly (whole packets, not fragments!)
N */
N#ifndef MEMP_NUM_REASSDATA
N#define MEMP_NUM_REASSDATA              5
N#endif
N
N/**
N * MEMP_NUM_FRAG_PBUF: the number of IP fragments simultaneously sent
N * (fragments, not whole packets!).
N * This is only used with IP_FRAG_USES_STATIC_BUF==0 and
N * LWIP_NETIF_TX_SINGLE_PBUF==0 and only has to be > 1 with DMA-enabled MACs
N * where the packet is not yet sent when netif->output returns.
N */
N#ifndef MEMP_NUM_FRAG_PBUF
N#define MEMP_NUM_FRAG_PBUF              15
N#endif
N
N/**
N * MEMP_NUM_ARP_QUEUE: the number of simulateously queued outgoing
N * packets (pbufs) that are waiting for an ARP request (to resolve
N * their destination address) to finish.
N * (requires the ARP_QUEUEING option)
N */
N#ifndef MEMP_NUM_ARP_QUEUE
N#define MEMP_NUM_ARP_QUEUE              30
N#endif
N
N/**
N * MEMP_NUM_IGMP_GROUP: The number of multicast groups whose network interfaces
N * can be members et the same time (one per netif - allsystems group -, plus one
N * per netif membership).
N * (requires the LWIP_IGMP option)
N */
N#ifndef MEMP_NUM_IGMP_GROUP
N#define MEMP_NUM_IGMP_GROUP             8
N#endif
N
N/**
N * MEMP_NUM_SYS_TIMEOUT: the number of simulateously active timeouts.
N * (requires NO_SYS==0)
N * The default number of timeouts is calculated here for all enabled modules.
N * The formula expects settings to be either '0' or '1'.
N */
N#ifndef MEMP_NUM_SYS_TIMEOUT
S#define MEMP_NUM_SYS_TIMEOUT            (LWIP_TCP + IP_REASSEMBLY + LWIP_ARP + (2*LWIP_DHCP) + LWIP_AUTOIP + LWIP_IGMP + LWIP_DNS + PPP_SUPPORT)
N#endif
N
N/**
N * MEMP_NUM_NETBUF: the number of struct netbufs.
N * (only needed if you use the sequential API, like api_lib.c)
N */
N#ifndef MEMP_NUM_NETBUF
N#define MEMP_NUM_NETBUF                 2
N#endif
N
N/**
N * MEMP_NUM_NETCONN: the number of struct netconns.
N * (only needed if you use the sequential API, like api_lib.c)
N */
N#ifndef MEMP_NUM_NETCONN
N#define MEMP_NUM_NETCONN                4
N#endif
N
N/**
N * MEMP_NUM_TCPIP_MSG_API: the number of struct tcpip_msg, which are used
N * for callback/timeout API communication. 
N * (only needed if you use tcpip.c)
N */
N#ifndef MEMP_NUM_TCPIP_MSG_API
N#define MEMP_NUM_TCPIP_MSG_API          8
N#endif
N
N/**
N * MEMP_NUM_TCPIP_MSG_INPKT: the number of struct tcpip_msg, which are used
N * for incoming packets. 
N * (only needed if you use tcpip.c)
N */
N#ifndef MEMP_NUM_TCPIP_MSG_INPKT
N#define MEMP_NUM_TCPIP_MSG_INPKT        8
N#endif
N
N/**
N * MEMP_NUM_SNMP_NODE: the number of leafs in the SNMP tree.
N */
N#ifndef MEMP_NUM_SNMP_NODE
N#define MEMP_NUM_SNMP_NODE              50
N#endif
N
N/**
N * MEMP_NUM_SNMP_ROOTNODE: the number of branches in the SNMP tree.
N * Every branch has one leaf (MEMP_NUM_SNMP_NODE) at least!
N */
N#ifndef MEMP_NUM_SNMP_ROOTNODE
N#define MEMP_NUM_SNMP_ROOTNODE          30
N#endif
N
N/**
N * MEMP_NUM_SNMP_VARBIND: the number of concurrent requests (does not have to
N * be changed normally) - 2 of these are used per request (1 for input,
N * 1 for output)
N */
N#ifndef MEMP_NUM_SNMP_VARBIND
N#define MEMP_NUM_SNMP_VARBIND           2
N#endif
N
N/**
N * MEMP_NUM_SNMP_VALUE: the number of OID or values concurrently used
N * (does not have to be changed normally) - 3 of these are used per request
N * (1 for the value read and 2 for OIDs - input and output)
N */
N#ifndef MEMP_NUM_SNMP_VALUE
N#define MEMP_NUM_SNMP_VALUE             3
N#endif
N
N/**
N * MEMP_NUM_NETDB: the number of concurrently running lwip_addrinfo() calls
N * (before freeing the corresponding memory using lwip_freeaddrinfo()).
N */
N#ifndef MEMP_NUM_NETDB
N#define MEMP_NUM_NETDB                  1
N#endif
N
N/**
N * MEMP_NUM_LOCALHOSTLIST: the number of host entries in the local host list
N * if DNS_LOCAL_HOSTLIST_IS_DYNAMIC==1.
N */
N#ifndef MEMP_NUM_LOCALHOSTLIST
N#define MEMP_NUM_LOCALHOSTLIST          1
N#endif
N
N/**
N * MEMP_NUM_PPPOE_INTERFACES: the number of concurrently active PPPoE
N * interfaces (only used with PPPOE_SUPPORT==1)
N */
N#ifndef MEMP_NUM_PPPOE_INTERFACES
N#define MEMP_NUM_PPPOE_INTERFACES       1
N#endif
N
N/**
N * PBUF_POOL_SIZE: the number of buffers in the pbuf pool. 
N */
N#ifndef PBUF_POOL_SIZE
S#define PBUF_POOL_SIZE                  16
N#endif
N
N/*
N   ---------------------------------
N   ---------- ARP options ----------
N   ---------------------------------
N*/
N/**
N * LWIP_ARP==1: Enable ARP functionality.
N */
N#ifndef LWIP_ARP
S#define LWIP_ARP                        1
N#endif
N
N/**
N * ARP_TABLE_SIZE: Number of active MAC-IP address pairs cached.
N */
N#ifndef ARP_TABLE_SIZE
N#define ARP_TABLE_SIZE                  10
N#endif
N
N/**
N * ARP_QUEUEING==1: Multiple outgoing packets are queued during hardware address
N * resolution. By default, only the most recent packet is queued per IP address.
N * This is sufficient for most protocols and mainly reduces TCP connection
N * startup time. Set this to 1 if you know your application sends more than one
N * packet in a row to an IP address that is not in the ARP cache.
N */
N#ifndef ARP_QUEUEING
N#define ARP_QUEUEING                    0
N#endif
N
N/**
N * ETHARP_TRUST_IP_MAC==1: Incoming IP packets cause the ARP table to be
N * updated with the source MAC and IP addresses supplied in the packet.
N * You may want to disable this if you do not trust LAN peers to have the
N * correct addresses, or as a limited approach to attempt to handle
N * spoofing. If disabled, lwIP will need to make a new ARP request if
N * the peer is not already in the ARP table, adding a little latency.
N * The peer *is* in the ARP table if it requested our address before.
N * Also notice that this slows down input processing of every IP packet!
N */
N#ifndef ETHARP_TRUST_IP_MAC
N#define ETHARP_TRUST_IP_MAC             0
N#endif
N
N/**
N * ETHARP_SUPPORT_VLAN==1: support receiving ethernet packets with VLAN header.
N * Additionally, you can define ETHARP_VLAN_CHECK to an u16_t VLAN ID to check.
N * If ETHARP_VLAN_CHECK is defined, only VLAN-traffic for this VLAN is accepted.
N * If ETHARP_VLAN_CHECK is not defined, all traffic is accepted.
N * Alternatively, define a function/define ETHARP_VLAN_CHECK_FN(eth_hdr, vlan)
N * that returns 1 to accept a packet or 0 to drop a packet.
N */
N#ifndef ETHARP_SUPPORT_VLAN
N#define ETHARP_SUPPORT_VLAN             0
N#endif
N
N/** LWIP_ETHERNET==1: enable ethernet support for PPPoE even though ARP
N * might be disabled
N */
N#ifndef LWIP_ETHERNET
N#define LWIP_ETHERNET                   (LWIP_ARP || PPPOE_SUPPORT)
N#endif
N
N/** ETH_PAD_SIZE: number of bytes added before the ethernet header to ensure
N * alignment of payload after that header. Since the header is 14 bytes long,
N * without this padding e.g. addresses in the IP header will not be aligned
N * on a 32-bit boundary, so setting this to 2 can speed up 32-bit-platforms.
N */
N#ifndef ETH_PAD_SIZE
N#define ETH_PAD_SIZE                    0
N#endif
N
N/** ETHARP_SUPPORT_STATIC_ENTRIES==1: enable code to support static ARP table
N * entries (using etharp_add_static_entry/etharp_remove_static_entry).
N */
N#ifndef ETHARP_SUPPORT_STATIC_ENTRIES
N#define ETHARP_SUPPORT_STATIC_ENTRIES   0
N#endif
N
N
N/*
N   --------------------------------
N   ---------- IP options ----------
N   --------------------------------
N*/
N/**
N * IP_FORWARD==1: Enables the ability to forward IP packets across network
N * interfaces. If you are going to run lwIP on a device with only one network
N * interface, define this to 0.
N */
N#ifndef IP_FORWARD
N#define IP_FORWARD                      0
N#endif
N
N/**
N * IP_OPTIONS_ALLOWED: Defines the behavior for IP options.
N *      IP_OPTIONS_ALLOWED==0: All packets with IP options are dropped.
N *      IP_OPTIONS_ALLOWED==1: IP options are allowed (but not parsed).
N */
N#ifndef IP_OPTIONS_ALLOWED
N#define IP_OPTIONS_ALLOWED              1
N#endif
N
N/**
N * IP_REASSEMBLY==1: Reassemble incoming fragmented IP packets. Note that
N * this option does not affect outgoing packet sizes, which can be controlled
N * via IP_FRAG.
N */
N#ifndef IP_REASSEMBLY
N#define IP_REASSEMBLY                   1
N#endif
N
N/**
N * IP_FRAG==1: Fragment outgoing IP packets if their size exceeds MTU. Note
N * that this option does not affect incoming packet sizes, which can be
N * controlled via IP_REASSEMBLY.
N */
N#ifndef IP_FRAG
N#define IP_FRAG                         1
N#endif
N
N/**
N * IP_REASS_MAXAGE: Maximum time (in multiples of IP_TMR_INTERVAL - so seconds, normally)
N * a fragmented IP packet waits for all fragments to arrive. If not all fragments arrived
N * in this time, the whole packet is discarded.
N */
N#ifndef IP_REASS_MAXAGE
N#define IP_REASS_MAXAGE                 3
N#endif
N
N/**
N * IP_REASS_MAX_PBUFS: Total maximum amount of pbufs waiting to be reassembled.
N * Since the received pbufs are enqueued, be sure to configure
N * PBUF_POOL_SIZE > IP_REASS_MAX_PBUFS so that the stack is still able to receive
N * packets even if the maximum amount of fragments is enqueued for reassembly!
N */
N#ifndef IP_REASS_MAX_PBUFS
N#define IP_REASS_MAX_PBUFS              10
N#endif
N
N/**
N * IP_FRAG_USES_STATIC_BUF==1: Use a static MTU-sized buffer for IP
N * fragmentation. Otherwise pbufs are allocated and reference the original
N * packet data to be fragmented (or with LWIP_NETIF_TX_SINGLE_PBUF==1,
N * new PBUF_RAM pbufs are used for fragments).
N * ATTENTION: IP_FRAG_USES_STATIC_BUF==1 may not be used for DMA-enabled MACs!
N */
N#ifndef IP_FRAG_USES_STATIC_BUF
N#define IP_FRAG_USES_STATIC_BUF         0
N#endif
N
N/**
N * IP_FRAG_MAX_MTU: Assumed max MTU on any interface for IP frag buffer
N * (requires IP_FRAG_USES_STATIC_BUF==1)
N */
N#if IP_FRAG_USES_STATIC_BUF && !defined(IP_FRAG_MAX_MTU)
X#if 0 && !0L
S#define IP_FRAG_MAX_MTU                 1500
N#endif
N
N/**
N * IP_DEFAULT_TTL: Default value for Time-To-Live used by transport layers.
N */
N#ifndef IP_DEFAULT_TTL
N#define IP_DEFAULT_TTL                  255
N#endif
N
N/**
N * IP_SOF_BROADCAST=1: Use the SOF_BROADCAST field to enable broadcast
N * filter per pcb on udp and raw send operations. To enable broadcast filter
N * on recv operations, you also have to set IP_SOF_BROADCAST_RECV=1.
N */
N#ifndef IP_SOF_BROADCAST
N#define IP_SOF_BROADCAST                0
N#endif
N
N/**
N * IP_SOF_BROADCAST_RECV (requires IP_SOF_BROADCAST=1) enable the broadcast
N * filter on recv operations.
N */
N#ifndef IP_SOF_BROADCAST_RECV
N#define IP_SOF_BROADCAST_RECV           0
N#endif
N
N/**
N * IP_FORWARD_ALLOW_TX_ON_RX_NETIF==1: allow ip_forward() to send packets back
N * out on the netif where it was received. This should only be used for
N * wireless networks.
N * ATTENTION: When this is 1, make sure your netif driver correctly marks incoming
N * link-layer-broadcast/multicast packets as such using the corresponding pbuf flags!
N */
N#ifndef IP_FORWARD_ALLOW_TX_ON_RX_NETIF
N#define IP_FORWARD_ALLOW_TX_ON_RX_NETIF 0
N#endif
N
N/**
N * LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS==1: randomize the local port for the first
N * local TCP/UDP pcb (default==0). This can prevent creating predictable port
N * numbers after booting a device.
N */
N#ifndef LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS
N#define LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS 0
N#endif
N
N/*
N   ----------------------------------
N   ---------- ICMP options ----------
N   ----------------------------------
N*/
N/**
N * LWIP_ICMP==1: Enable ICMP module inside the IP stack.
N * Be careful, disable that make your product non-compliant to RFC1122
N */
N#ifndef LWIP_ICMP
S#define LWIP_ICMP                       1
N#endif
N
N/**
N * ICMP_TTL: Default value for Time-To-Live used by ICMP packets.
N */
N#ifndef ICMP_TTL
N#define ICMP_TTL                       (IP_DEFAULT_TTL)
N#endif
N
N/**
N * LWIP_BROADCAST_PING==1: respond to broadcast pings (default is unicast only)
N */
N#ifndef LWIP_BROADCAST_PING
N#define LWIP_BROADCAST_PING             0
N#endif
N
N/**
N * LWIP_MULTICAST_PING==1: respond to multicast pings (default is unicast only)
N */
N#ifndef LWIP_MULTICAST_PING
N#define LWIP_MULTICAST_PING             0
N#endif
N
N/*
N   ---------------------------------
N   ---------- RAW options ----------
N   ---------------------------------
N*/
N/**
N * LWIP_RAW==1: Enable application layer to hook into the IP layer itself.
N */
N#ifndef LWIP_RAW
N#define LWIP_RAW                        1
N#endif
N
N/**
N * LWIP_RAW==1: Enable application layer to hook into the IP layer itself.
N */
N#ifndef RAW_TTL
N#define RAW_TTL                        (IP_DEFAULT_TTL)
N#endif
N
N/*
N   ----------------------------------
N   ---------- DHCP options ----------
N   ----------------------------------
N*/
N/**
N * LWIP_DHCP==1: Enable DHCP module.
N */
N#ifndef LWIP_DHCP
S#define LWIP_DHCP                       0
N#endif
N
N/**
N * DHCP_DOES_ARP_CHECK==1: Do an ARP check on the offered address.
N */
N#ifndef DHCP_DOES_ARP_CHECK
N#define DHCP_DOES_ARP_CHECK             ((LWIP_DHCP) && (LWIP_ARP))
N#endif
N
N/*
N   ------------------------------------
N   ---------- AUTOIP options ----------
N   ------------------------------------
N*/
N/**
N * LWIP_AUTOIP==1: Enable AUTOIP module.
N */
N#ifndef LWIP_AUTOIP
N#define LWIP_AUTOIP                     0
N#endif
N
N/**
N * LWIP_DHCP_AUTOIP_COOP==1: Allow DHCP and AUTOIP to be both enabled on
N * the same interface at the same time.
N */
N#ifndef LWIP_DHCP_AUTOIP_COOP
N#define LWIP_DHCP_AUTOIP_COOP           0
N#endif
N
N/**
N * LWIP_DHCP_AUTOIP_COOP_TRIES: Set to the number of DHCP DISCOVER probes
N * that should be sent before falling back on AUTOIP. This can be set
N * as low as 1 to get an AutoIP address very quickly, but you should
N * be prepared to handle a changing IP address when DHCP overrides
N * AutoIP.
N */
N#ifndef LWIP_DHCP_AUTOIP_COOP_TRIES
N#define LWIP_DHCP_AUTOIP_COOP_TRIES     9
N#endif
N
N/*
N   ----------------------------------
N   ---------- SNMP options ----------
N   ----------------------------------
N*/
N/**
N * LWIP_SNMP==1: Turn on SNMP module. UDP must be available for SNMP
N * transport.
N */
N#ifndef LWIP_SNMP
N#define LWIP_SNMP                       0
N#endif
N
N/**
N * SNMP_CONCURRENT_REQUESTS: Number of concurrent requests the module will
N * allow. At least one request buffer is required.
N * Does not have to be changed unless external MIBs answer request asynchronously
N */
N#ifndef SNMP_CONCURRENT_REQUESTS
N#define SNMP_CONCURRENT_REQUESTS        1
N#endif
N
N/**
N * SNMP_TRAP_DESTINATIONS: Number of trap destinations. At least one trap
N * destination is required
N */
N#ifndef SNMP_TRAP_DESTINATIONS
N#define SNMP_TRAP_DESTINATIONS          1
N#endif
N
N/**
N * SNMP_PRIVATE_MIB: 
N * When using a private MIB, you have to create a file 'private_mib.h' that contains
N * a 'struct mib_array_node mib_private' which contains your MIB.
N */
N#ifndef SNMP_PRIVATE_MIB
N#define SNMP_PRIVATE_MIB                0
N#endif
N
N/**
N * Only allow SNMP write actions that are 'safe' (e.g. disabeling netifs is not
N * a safe action and disabled when SNMP_SAFE_REQUESTS = 1).
N * Unsafe requests are disabled by default!
N */
N#ifndef SNMP_SAFE_REQUESTS
N#define SNMP_SAFE_REQUESTS              1
N#endif
N
N/**
N * The maximum length of strings used. This affects the size of
N * MEMP_SNMP_VALUE elements.
N */
N#ifndef SNMP_MAX_OCTET_STRING_LEN
N#define SNMP_MAX_OCTET_STRING_LEN       127
N#endif
N
N/**
N * The maximum depth of the SNMP tree.
N * With private MIBs enabled, this depends on your MIB!
N * This affects the size of MEMP_SNMP_VALUE elements.
N */
N#ifndef SNMP_MAX_TREE_DEPTH
N#define SNMP_MAX_TREE_DEPTH             15
N#endif
N
N/**
N * The size of the MEMP_SNMP_VALUE elements, normally calculated from
N * SNMP_MAX_OCTET_STRING_LEN and SNMP_MAX_TREE_DEPTH.
N */
N#ifndef SNMP_MAX_VALUE_SIZE
N#define SNMP_MAX_VALUE_SIZE             LWIP_MAX((SNMP_MAX_OCTET_STRING_LEN)+1, sizeof(s32_t)*(SNMP_MAX_TREE_DEPTH))
N#endif
N
N/*
N   ----------------------------------
N   ---------- IGMP options ----------
N   ----------------------------------
N*/
N/**
N * LWIP_IGMP==1: Turn on IGMP module. 
N */
N#ifndef LWIP_IGMP
N#define LWIP_IGMP                       0
N#endif
N
N/*
N   ----------------------------------
N   ---------- DNS options -----------
N   ----------------------------------
N*/
N/**
N * LWIP_DNS==1: Turn on DNS module. UDP must be available for DNS
N * transport.
N */
N#ifndef LWIP_DNS
S#define LWIP_DNS                        0
N#endif
N
N/** DNS maximum number of entries to maintain locally. */
N#ifndef DNS_TABLE_SIZE
S#define DNS_TABLE_SIZE                  4
N#endif
N
N/** DNS maximum host name length supported in the name table. */
N#ifndef DNS_MAX_NAME_LENGTH
N#define DNS_MAX_NAME_LENGTH             256
N#endif
N
N/** The maximum of DNS servers */
N#ifndef DNS_MAX_SERVERS
N#define DNS_MAX_SERVERS                 2
N#endif
N
N/** DNS do a name checking between the query and the response. */
N#ifndef DNS_DOES_NAME_CHECK
N#define DNS_DOES_NAME_CHECK             1
N#endif
N
N/** DNS message max. size. Default value is RFC compliant. */
N#ifndef DNS_MSG_SIZE
N#define DNS_MSG_SIZE                    512
N#endif
N
N/** DNS_LOCAL_HOSTLIST: Implements a local host-to-address list. If enabled,
N *  you have to define
N *    #define DNS_LOCAL_HOSTLIST_INIT {{"host1", 0x123}, {"host2", 0x234}}
N *  (an array of structs name/address, where address is an u32_t in network
N *  byte order).
N *
N *  Instead, you can also use an external function:
N *  #define DNS_LOOKUP_LOCAL_EXTERN(x) extern u32_t my_lookup_function(const char *name)
N *  that returns the IP address or INADDR_NONE if not found.
N */
N#ifndef DNS_LOCAL_HOSTLIST
N#define DNS_LOCAL_HOSTLIST              0
N#endif /* DNS_LOCAL_HOSTLIST */
N
N/** If this is turned on, the local host-list can be dynamically changed
N *  at runtime. */
N#ifndef DNS_LOCAL_HOSTLIST_IS_DYNAMIC
S#define DNS_LOCAL_HOSTLIST_IS_DYNAMIC   0
N#endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
N
N/*
N   ---------------------------------
N   ---------- UDP options ----------
N   ---------------------------------
N*/
N/**
N * LWIP_UDP==1: Turn on UDP.
N */
N#ifndef LWIP_UDP
S#define LWIP_UDP                        1
N#endif
N
N/**
N * LWIP_UDPLITE==1: Turn on UDP-Lite. (Requires LWIP_UDP)
N */
N#ifndef LWIP_UDPLITE
N#define LWIP_UDPLITE                    0
N#endif
N
N/**
N * UDP_TTL: Default Time-To-Live value.
N */
N#ifndef UDP_TTL
S#define UDP_TTL                         (IP_DEFAULT_TTL)
N#endif
N
N/**
N * LWIP_NETBUF_RECVINFO==1: append destination addr and port to every netbuf.
N */
N#ifndef LWIP_NETBUF_RECVINFO
N#define LWIP_NETBUF_RECVINFO            0
N#endif
N
N/*
N   ---------------------------------
N   ---------- TCP options ----------
N   ---------------------------------
N*/
N/**
N * LWIP_TCP==1: Turn on TCP.
N */
N#ifndef LWIP_TCP
S#define LWIP_TCP                        1
N#endif
N
N/**
N * TCP_TTL: Default Time-To-Live value.
N */
N#ifndef TCP_TTL
S#define TCP_TTL                         (IP_DEFAULT_TTL)
N#endif
N
N/**
N * TCP_WND: The size of a TCP window.  This must be at least 
N * (2 * TCP_MSS) for things to work well
N */
N#ifndef TCP_WND
S#define TCP_WND                         (4 * TCP_MSS)
N#endif 
N
N/**
N * TCP_MAXRTX: Maximum number of retransmissions of data segments.
N */
N#ifndef TCP_MAXRTX
N#define TCP_MAXRTX                      12
N#endif
N
N/**
N * TCP_SYNMAXRTX: Maximum number of retransmissions of SYN segments.
N */
N#ifndef TCP_SYNMAXRTX
N#define TCP_SYNMAXRTX                   6
N#endif
N
N/**
N * TCP_QUEUE_OOSEQ==1: TCP will queue segments that arrive out of order.
N * Define to 0 if your device is low on memory.
N */
N#ifndef TCP_QUEUE_OOSEQ
S#define TCP_QUEUE_OOSEQ                 (LWIP_TCP)
N#endif
N
N/**
N * TCP_MSS: TCP Maximum segment size. (default is 536, a conservative default,
N * you might want to increase this.)
N * For the receive side, this MSS is advertised to the remote side
N * when opening a connection. For the transmit size, this MSS sets
N * an upper limit on the MSS advertised by the remote host.
N */
N#ifndef TCP_MSS
S#define TCP_MSS                         536
N#endif
N
N/**
N * TCP_CALCULATE_EFF_SEND_MSS: "The maximum size of a segment that TCP really
N * sends, the 'effective send MSS,' MUST be the smaller of the send MSS (which
N * reflects the available reassembly buffer size at the remote host) and the
N * largest size permitted by the IP layer" (RFC 1122)
N * Setting this to 1 enables code that checks TCP_MSS against the MTU of the
N * netif used for a connection and limits the MSS if it would be too big otherwise.
N */
N#ifndef TCP_CALCULATE_EFF_SEND_MSS
N#define TCP_CALCULATE_EFF_SEND_MSS      1
N#endif
N
N
N/**
N * TCP_SND_BUF: TCP sender buffer space (bytes).
N * To achieve good performance, this should be at least 2 * TCP_MSS.
N */
N#ifndef TCP_SND_BUF
S#define TCP_SND_BUF                     (2 * TCP_MSS)
N#endif
N
N/**
N * TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least
N * as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work.
N */
N#ifndef TCP_SND_QUEUELEN
S#define TCP_SND_QUEUELEN                ((4 * (TCP_SND_BUF) + (TCP_MSS - 1))/(TCP_MSS))
N#endif
N
N/**
N * TCP_SNDLOWAT: TCP writable space (bytes). This must be less than
N * TCP_SND_BUF. It is the amount of space which must be available in the
N * TCP snd_buf for select to return writable (combined with TCP_SNDQUEUELOWAT).
N */
N#ifndef TCP_SNDLOWAT
N#define TCP_SNDLOWAT                    LWIP_MIN(LWIP_MAX(((TCP_SND_BUF)/2), (2 * TCP_MSS) + 1), (TCP_SND_BUF) - 1)
N#endif
N
N/**
N * TCP_SNDQUEUELOWAT: TCP writable bufs (pbuf count). This must be less
N * than TCP_SND_QUEUELEN. If the number of pbufs queued on a pcb drops below
N * this number, select returns writable (combined with TCP_SNDLOWAT).
N */
N#ifndef TCP_SNDQUEUELOWAT
N#define TCP_SNDQUEUELOWAT               LWIP_MAX(((TCP_SND_QUEUELEN)/2), 5)
N#endif
N
N/**
N * TCP_OOSEQ_MAX_BYTES: The maximum number of bytes queued on ooseq per pcb.
N * Default is 0 (no limit). Only valid for TCP_QUEUE_OOSEQ==0.
N */
N#ifndef TCP_OOSEQ_MAX_BYTES
N#define TCP_OOSEQ_MAX_BYTES             0
N#endif
N
N/**
N * TCP_OOSEQ_MAX_PBUFS: The maximum number of pbufs queued on ooseq per pcb.
N * Default is 0 (no limit). Only valid for TCP_QUEUE_OOSEQ==0.
N */
N#ifndef TCP_OOSEQ_MAX_PBUFS
N#define TCP_OOSEQ_MAX_PBUFS             0
N#endif
N
N/**
N * TCP_LISTEN_BACKLOG: Enable the backlog option for tcp listen pcb.
N */
N#ifndef TCP_LISTEN_BACKLOG
N#define TCP_LISTEN_BACKLOG              0
N#endif
N
N/**
N * The maximum allowed backlog for TCP listen netconns.
N * This backlog is used unless another is explicitly specified.
N * 0xff is the maximum (u8_t).
N */
N#ifndef TCP_DEFAULT_LISTEN_BACKLOG
N#define TCP_DEFAULT_LISTEN_BACKLOG      0xff
N#endif
N
N/**
N * TCP_OVERSIZE: The maximum number of bytes that tcp_write may
N * allocate ahead of time in an attempt to create shorter pbuf chains
N * for transmission. The meaningful range is 0 to TCP_MSS. Some
N * suggested values are:
N *
N * 0:         Disable oversized allocation. Each tcp_write() allocates a new
N              pbuf (old behaviour).
N * 1:         Allocate size-aligned pbufs with minimal excess. Use this if your
N *            scatter-gather DMA requires aligned fragments.
N * 128:       Limit the pbuf/memory overhead to 20%.
N * TCP_MSS:   Try to create unfragmented TCP packets.
N * TCP_MSS/4: Try to create 4 fragments or less per TCP packet.
N */
N#ifndef TCP_OVERSIZE
N#define TCP_OVERSIZE                    TCP_MSS
N#endif
N
N/**
N * LWIP_TCP_TIMESTAMPS==1: support the TCP timestamp option.
N */
N#ifndef LWIP_TCP_TIMESTAMPS
N#define LWIP_TCP_TIMESTAMPS             0
N#endif
N
N/**
N * TCP_WND_UPDATE_THRESHOLD: difference in window to trigger an
N * explicit window update
N */
N#ifndef TCP_WND_UPDATE_THRESHOLD
N#define TCP_WND_UPDATE_THRESHOLD   (TCP_WND / 4)
N#endif
N
N/**
N * LWIP_EVENT_API and LWIP_CALLBACK_API: Only one of these should be set to 1.
N *     LWIP_EVENT_API==1: The user defines lwip_tcp_event() to receive all
N *         events (accept, sent, etc) that happen in the system.
N *     LWIP_CALLBACK_API==1: The PCB callback function is called directly
N *         for the event. This is the default.
N */
N#if !defined(LWIP_EVENT_API) && !defined(LWIP_CALLBACK_API)
X#if !0L && !0L
N#define LWIP_EVENT_API                  0
N#define LWIP_CALLBACK_API               1
N#endif
N
N
N/*
N   ----------------------------------
N   ---------- Pbuf options ----------
N   ----------------------------------
N*/
N/**
N * PBUF_LINK_HLEN: the number of bytes that should be allocated for a
N * link level header. The default is 14, the standard value for
N * Ethernet.
N */
N#ifndef PBUF_LINK_HLEN
N#define PBUF_LINK_HLEN                  (14 + ETH_PAD_SIZE)
N#endif
N
N/**
N * PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. The default is
N * designed to accomodate single full size TCP frame in one pbuf, including
N * TCP_MSS, IP header, and link header.
N */
N#ifndef PBUF_POOL_BUFSIZE
S#define PBUF_POOL_BUFSIZE               LWIP_MEM_ALIGN_SIZE(TCP_MSS+40+PBUF_LINK_HLEN)
N#endif
N
N/*
N   ------------------------------------------------
N   ---------- Network Interfaces options ----------
N   ------------------------------------------------
N*/
N/**
N * LWIP_NETIF_HOSTNAME==1: use DHCP_OPTION_HOSTNAME with netif's hostname
N * field.
N */
N#ifndef LWIP_NETIF_HOSTNAME
N#define LWIP_NETIF_HOSTNAME             0
N#endif
N
N/**
N * LWIP_NETIF_API==1: Support netif api (in netifapi.c)
N */
N#ifndef LWIP_NETIF_API
N#define LWIP_NETIF_API                  0
N#endif
N
N/**
N * LWIP_NETIF_STATUS_CALLBACK==1: Support a callback function whenever an interface
N * changes its up/down status (i.e., due to DHCP IP acquistion)
N */
N#ifndef LWIP_NETIF_STATUS_CALLBACK
N#define LWIP_NETIF_STATUS_CALLBACK      0
N#endif
N
N/**
N * LWIP_NETIF_LINK_CALLBACK==1: Support a callback function from an interface
N * whenever the link changes (i.e., link down)
N */
N#ifndef LWIP_NETIF_LINK_CALLBACK
S#define LWIP_NETIF_LINK_CALLBACK        0
N#endif
N
N/**
N * LWIP_NETIF_REMOVE_CALLBACK==1: Support a callback function that is called
N * when a netif has been removed
N */
N#ifndef LWIP_NETIF_REMOVE_CALLBACK
N#define LWIP_NETIF_REMOVE_CALLBACK      0
N#endif
N
N/**
N * LWIP_NETIF_HWADDRHINT==1: Cache link-layer-address hints (e.g. table
N * indices) in struct netif. TCP and UDP can make use of this to prevent
N * scanning the ARP table for every sent packet. While this is faster for big
N * ARP tables or many concurrent connections, it might be counterproductive
N * if you have a tiny ARP table or if there never are concurrent connections.
N */
N#ifndef LWIP_NETIF_HWADDRHINT
N#define LWIP_NETIF_HWADDRHINT           0
N#endif
N
N/**
N * LWIP_NETIF_LOOPBACK==1: Support sending packets with a destination IP
N * address equal to the netif IP address, looping them back up the stack.
N */
N#ifndef LWIP_NETIF_LOOPBACK
N#define LWIP_NETIF_LOOPBACK             0
N#endif
N
N/**
N * LWIP_LOOPBACK_MAX_PBUFS: Maximum number of pbufs on queue for loopback
N * sending for each netif (0 = disabled)
N */
N#ifndef LWIP_LOOPBACK_MAX_PBUFS
N#define LWIP_LOOPBACK_MAX_PBUFS         0
N#endif
N
N/**
N * LWIP_NETIF_LOOPBACK_MULTITHREADING: Indicates whether threading is enabled in
N * the system, as netifs must change how they behave depending on this setting
N * for the LWIP_NETIF_LOOPBACK option to work.
N * Setting this is needed to avoid reentering non-reentrant functions like
N * tcp_input().
N *    LWIP_NETIF_LOOPBACK_MULTITHREADING==1: Indicates that the user is using a
N *       multithreaded environment like tcpip.c. In this case, netif->input()
N *       is called directly.
N *    LWIP_NETIF_LOOPBACK_MULTITHREADING==0: Indicates a polling (or NO_SYS) setup.
N *       The packets are put on a list and netif_poll() must be called in
N *       the main application loop.
N */
N#ifndef LWIP_NETIF_LOOPBACK_MULTITHREADING
N#define LWIP_NETIF_LOOPBACK_MULTITHREADING    (!NO_SYS)
N#endif
N
N/**
N * LWIP_NETIF_TX_SINGLE_PBUF: if this is set to 1, lwIP tries to put all data
N * to be sent into one single pbuf. This is for compatibility with DMA-enabled
N * MACs that do not support scatter-gather.
N * Beware that this might involve CPU-memcpy before transmitting that would not
N * be needed without this flag! Use this only if you need to!
N *
N * @todo: TCP and IP-frag do not work with this, yet:
N */
N#ifndef LWIP_NETIF_TX_SINGLE_PBUF
N#define LWIP_NETIF_TX_SINGLE_PBUF             0
N#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
N
N/*
N   ------------------------------------
N   ---------- LOOPIF options ----------
N   ------------------------------------
N*/
N/**
N * LWIP_HAVE_LOOPIF==1: Support loop interface (127.0.0.1) and loopif.c
N */
N#ifndef LWIP_HAVE_LOOPIF
N#define LWIP_HAVE_LOOPIF                0
N#endif
N
N/*
N   ------------------------------------
N   ---------- SLIPIF options ----------
N   ------------------------------------
N*/
N/**
N * LWIP_HAVE_SLIPIF==1: Support slip interface and slipif.c
N */
N#ifndef LWIP_HAVE_SLIPIF
N#define LWIP_HAVE_SLIPIF                0
N#endif
N
N/*
N   ------------------------------------
N   ---------- Thread options ----------
N   ------------------------------------
N*/
N/**
N * TCPIP_THREAD_NAME: The name assigned to the main tcpip thread.
N */
N#ifndef TCPIP_THREAD_NAME
N#define TCPIP_THREAD_NAME              "tcpip_thread"
N#endif
N
N/**
N * TCPIP_THREAD_STACKSIZE: The stack size used by the main tcpip thread.
N * The stack size value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef TCPIP_THREAD_STACKSIZE
N#define TCPIP_THREAD_STACKSIZE          0
N#endif
N
N/**
N * TCPIP_THREAD_PRIO: The priority assigned to the main tcpip thread.
N * The priority value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef TCPIP_THREAD_PRIO
N#define TCPIP_THREAD_PRIO               1
N#endif
N
N/**
N * TCPIP_MBOX_SIZE: The mailbox size for the tcpip thread messages
N * The queue size value itself is platform-dependent, but is passed to
N * sys_mbox_new() when tcpip_init is called.
N */
N#ifndef TCPIP_MBOX_SIZE
N#define TCPIP_MBOX_SIZE                 0
N#endif
N
N/**
N * SLIPIF_THREAD_NAME: The name assigned to the slipif_loop thread.
N */
N#ifndef SLIPIF_THREAD_NAME
N#define SLIPIF_THREAD_NAME             "slipif_loop"
N#endif
N
N/**
N * SLIP_THREAD_STACKSIZE: The stack size used by the slipif_loop thread.
N * The stack size value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef SLIPIF_THREAD_STACKSIZE
N#define SLIPIF_THREAD_STACKSIZE         0
N#endif
N
N/**
N * SLIPIF_THREAD_PRIO: The priority assigned to the slipif_loop thread.
N * The priority value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef SLIPIF_THREAD_PRIO
N#define SLIPIF_THREAD_PRIO              1
N#endif
N
N/**
N * PPP_THREAD_NAME: The name assigned to the pppInputThread.
N */
N#ifndef PPP_THREAD_NAME
N#define PPP_THREAD_NAME                "pppInputThread"
N#endif
N
N/**
N * PPP_THREAD_STACKSIZE: The stack size used by the pppInputThread.
N * The stack size value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef PPP_THREAD_STACKSIZE
N#define PPP_THREAD_STACKSIZE            0
N#endif
N
N/**
N * PPP_THREAD_PRIO: The priority assigned to the pppInputThread.
N * The priority value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef PPP_THREAD_PRIO
N#define PPP_THREAD_PRIO                 1
N#endif
N
N/**
N * DEFAULT_THREAD_NAME: The name assigned to any other lwIP thread.
N */
N#ifndef DEFAULT_THREAD_NAME
N#define DEFAULT_THREAD_NAME            "lwIP"
N#endif
N
N/**
N * DEFAULT_THREAD_STACKSIZE: The stack size used by any other lwIP thread.
N * The stack size value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef DEFAULT_THREAD_STACKSIZE
N#define DEFAULT_THREAD_STACKSIZE        0
N#endif
N
N/**
N * DEFAULT_THREAD_PRIO: The priority assigned to any other lwIP thread.
N * The priority value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef DEFAULT_THREAD_PRIO
N#define DEFAULT_THREAD_PRIO             1
N#endif
N
N/**
N * DEFAULT_RAW_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
N * NETCONN_RAW. The queue size value itself is platform-dependent, but is passed
N * to sys_mbox_new() when the recvmbox is created.
N */
N#ifndef DEFAULT_RAW_RECVMBOX_SIZE
N#define DEFAULT_RAW_RECVMBOX_SIZE       0
N#endif
N
N/**
N * DEFAULT_UDP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
N * NETCONN_UDP. The queue size value itself is platform-dependent, but is passed
N * to sys_mbox_new() when the recvmbox is created.
N */
N#ifndef DEFAULT_UDP_RECVMBOX_SIZE
N#define DEFAULT_UDP_RECVMBOX_SIZE       0
N#endif
N
N/**
N * DEFAULT_TCP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
N * NETCONN_TCP. The queue size value itself is platform-dependent, but is passed
N * to sys_mbox_new() when the recvmbox is created.
N */
N#ifndef DEFAULT_TCP_RECVMBOX_SIZE
N#define DEFAULT_TCP_RECVMBOX_SIZE       0
N#endif
N
N/**
N * DEFAULT_ACCEPTMBOX_SIZE: The mailbox size for the incoming connections.
N * The queue size value itself is platform-dependent, but is passed to
N * sys_mbox_new() when the acceptmbox is created.
N */
N#ifndef DEFAULT_ACCEPTMBOX_SIZE
N#define DEFAULT_ACCEPTMBOX_SIZE         0
N#endif
N
N/*
N   ----------------------------------------------
N   ---------- Sequential layer options ----------
N   ----------------------------------------------
N*/
N/**
N * LWIP_TCPIP_CORE_LOCKING: (EXPERIMENTAL!)
N * Don't use it if you're not an active lwIP project member
N */
N#ifndef LWIP_TCPIP_CORE_LOCKING
N#define LWIP_TCPIP_CORE_LOCKING         0
N#endif
N
N/**
N * LWIP_TCPIP_CORE_LOCKING_INPUT: (EXPERIMENTAL!)
N * Don't use it if you're not an active lwIP project member
N */
N#ifndef LWIP_TCPIP_CORE_LOCKING_INPUT
N#define LWIP_TCPIP_CORE_LOCKING_INPUT   0
N#endif
N
N/**
N * LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c)
N */
N#ifndef LWIP_NETCONN
S#define LWIP_NETCONN                    1
N#endif
N
N/** LWIP_TCPIP_TIMEOUT==1: Enable tcpip_timeout/tcpip_untimeout tod create
N * timers running in tcpip_thread from another thread.
N */
N#ifndef LWIP_TCPIP_TIMEOUT
N#define LWIP_TCPIP_TIMEOUT              1
N#endif
N
N/*
N   ------------------------------------
N   ---------- Socket options ----------
N   ------------------------------------
N*/
N/**
N * LWIP_SOCKET==1: Enable Socket API (require to use sockets.c)
N */
N#ifndef LWIP_SOCKET
S#define LWIP_SOCKET                     1
N#endif
N
N/**
N * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
N * (only used if you use sockets.c)
N */
N#ifndef LWIP_COMPAT_SOCKETS
N#define LWIP_COMPAT_SOCKETS             1
N#endif
N
N/**
N * LWIP_POSIX_SOCKETS_IO_NAMES==1: Enable POSIX-style sockets functions names.
N * Disable this option if you use a POSIX operating system that uses the same
N * names (read, write & close). (only used if you use sockets.c)
N */
N#ifndef LWIP_POSIX_SOCKETS_IO_NAMES
N#define LWIP_POSIX_SOCKETS_IO_NAMES     1
N#endif
N
N/**
N * LWIP_TCP_KEEPALIVE==1: Enable TCP_KEEPIDLE, TCP_KEEPINTVL and TCP_KEEPCNT
N * options processing. Note that TCP_KEEPIDLE and TCP_KEEPINTVL have to be set
N * in seconds. (does not require sockets.c, and will affect tcp.c)
N */
N#ifndef LWIP_TCP_KEEPALIVE
N#define LWIP_TCP_KEEPALIVE              0
N#endif
N
N/**
N * LWIP_SO_SNDTIMEO==1: Enable send timeout for sockets/netconns and
N * SO_SNDTIMEO processing.
N */
N#ifndef LWIP_SO_SNDTIMEO
N#define LWIP_SO_SNDTIMEO                0
N#endif
N
N/**
N * LWIP_SO_RCVTIMEO==1: Enable receive timeout for sockets/netconns and
N * SO_RCVTIMEO processing.
N */
N#ifndef LWIP_SO_RCVTIMEO
N#define LWIP_SO_RCVTIMEO                0
N#endif
N
N/**
N * LWIP_SO_RCVBUF==1: Enable SO_RCVBUF processing.
N */
N#ifndef LWIP_SO_RCVBUF
N#define LWIP_SO_RCVBUF                  0
N#endif
N
N/**
N * If LWIP_SO_RCVBUF is used, this is the default value for recv_bufsize.
N */
N#ifndef RECV_BUFSIZE_DEFAULT
N#define RECV_BUFSIZE_DEFAULT            INT_MAX
N#endif
N
N/**
N * SO_REUSE==1: Enable SO_REUSEADDR option.
N */
N#ifndef SO_REUSE
N#define SO_REUSE                        0
N#endif
N
N/**
N * SO_REUSE_RXTOALL==1: Pass a copy of incoming broadcast/multicast packets
N * to all local matches if SO_REUSEADDR is turned on.
N * WARNING: Adds a memcpy for every packet if passing to more than one pcb!
N */
N#ifndef SO_REUSE_RXTOALL
N#define SO_REUSE_RXTOALL                0
N#endif
N
N/*
N   ----------------------------------------
N   ---------- Statistics options ----------
N   ----------------------------------------
N*/
N/**
N * LWIP_STATS==1: Enable statistics collection in lwip_stats.
N */
N#ifndef LWIP_STATS
S#define LWIP_STATS                      1
N#endif
N
N#if LWIP_STATS
X#if 0
S
S/**
S * LWIP_STATS_DISPLAY==1: Compile in the statistics output functions.
S */
S#ifndef LWIP_STATS_DISPLAY
S#define LWIP_STATS_DISPLAY              0
S#endif
S
S/**
S * LINK_STATS==1: Enable link stats.
S */
S#ifndef LINK_STATS
S#define LINK_STATS                      1
S#endif
S
S/**
S * ETHARP_STATS==1: Enable etharp stats.
S */
S#ifndef ETHARP_STATS
S#define ETHARP_STATS                    (LWIP_ARP)
S#endif
S
S/**
S * IP_STATS==1: Enable IP stats.
S */
S#ifndef IP_STATS
S#define IP_STATS                        1
S#endif
S
S/**
S * IPFRAG_STATS==1: Enable IP fragmentation stats. Default is
S * on if using either frag or reass.
S */
S#ifndef IPFRAG_STATS
S#define IPFRAG_STATS                    (IP_REASSEMBLY || IP_FRAG)
S#endif
S
S/**
S * ICMP_STATS==1: Enable ICMP stats.
S */
S#ifndef ICMP_STATS
S#define ICMP_STATS                      1
S#endif
S
S/**
S * IGMP_STATS==1: Enable IGMP stats.
S */
S#ifndef IGMP_STATS
S#define IGMP_STATS                      (LWIP_IGMP)
S#endif
S
S/**
S * UDP_STATS==1: Enable UDP stats. Default is on if
S * UDP enabled, otherwise off.
S */
S#ifndef UDP_STATS
S#define UDP_STATS                       (LWIP_UDP)
S#endif
S
S/**
S * TCP_STATS==1: Enable TCP stats. Default is on if TCP
S * enabled, otherwise off.
S */
S#ifndef TCP_STATS
S#define TCP_STATS                       (LWIP_TCP)
S#endif
S
S/**
S * MEM_STATS==1: Enable mem.c stats.
S */
S#ifndef MEM_STATS
S#define MEM_STATS                       ((MEM_LIBC_MALLOC == 0) && (MEM_USE_POOLS == 0))
S#endif
S
S/**
S * MEMP_STATS==1: Enable memp.c pool stats.
S */
S#ifndef MEMP_STATS
S#define MEMP_STATS                      (MEMP_MEM_MALLOC == 0)
S#endif
S
S/**
S * SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
S */
S#ifndef SYS_STATS
S#define SYS_STATS                       (NO_SYS == 0)
S#endif
S
N#else
N
N#define LINK_STATS                      0
N#define IP_STATS                        0
N#define IPFRAG_STATS                    0
N#define ICMP_STATS                      0
N#define IGMP_STATS                      0
N#define UDP_STATS                       0
N#define TCP_STATS                       0
N#define MEM_STATS                       0
N#define MEMP_STATS                      0
N#define SYS_STATS                       0
N#define LWIP_STATS_DISPLAY              0
N
N#endif /* LWIP_STATS */
N
N/*
N   ---------------------------------
N   ---------- PPP options ----------
N   ---------------------------------
N*/
N/**
N * PPP_SUPPORT==1: Enable PPP.
N */
N#ifndef PPP_SUPPORT
N#define PPP_SUPPORT                     0
N#endif
N
N/**
N * PPPOE_SUPPORT==1: Enable PPP Over Ethernet
N */
N#ifndef PPPOE_SUPPORT
N#define PPPOE_SUPPORT                   0
N#endif
N
N/**
N * PPPOS_SUPPORT==1: Enable PPP Over Serial
N */
N#ifndef PPPOS_SUPPORT
N#define PPPOS_SUPPORT                   PPP_SUPPORT
N#endif
N
N#if PPP_SUPPORT
X#if 0
S
S/**
S * NUM_PPP: Max PPP sessions.
S */
S#ifndef NUM_PPP
S#define NUM_PPP                         1
S#endif
S
S/**
S * PAP_SUPPORT==1: Support PAP.
S */
S#ifndef PAP_SUPPORT
S#define PAP_SUPPORT                     0
S#endif
S
S/**
S * CHAP_SUPPORT==1: Support CHAP.
S */
S#ifndef CHAP_SUPPORT
S#define CHAP_SUPPORT                    0
S#endif
S
S/**
S * MSCHAP_SUPPORT==1: Support MSCHAP. CURRENTLY NOT SUPPORTED! DO NOT SET!
S */
S#ifndef MSCHAP_SUPPORT
S#define MSCHAP_SUPPORT                  0
S#endif
S
S/**
S * CBCP_SUPPORT==1: Support CBCP. CURRENTLY NOT SUPPORTED! DO NOT SET!
S */
S#ifndef CBCP_SUPPORT
S#define CBCP_SUPPORT                    0
S#endif
S
S/**
S * CCP_SUPPORT==1: Support CCP. CURRENTLY NOT SUPPORTED! DO NOT SET!
S */
S#ifndef CCP_SUPPORT
S#define CCP_SUPPORT                     0
S#endif
S
S/**
S * VJ_SUPPORT==1: Support VJ header compression.
S */
S#ifndef VJ_SUPPORT
S#define VJ_SUPPORT                      0
S#endif
S
S/**
S * MD5_SUPPORT==1: Support MD5 (see also CHAP).
S */
S#ifndef MD5_SUPPORT
S#define MD5_SUPPORT                     0
S#endif
S
S/*
S * Timeouts
S */
S#ifndef FSM_DEFTIMEOUT
S#define FSM_DEFTIMEOUT                  6       /* Timeout time in seconds */
S#endif
S
S#ifndef FSM_DEFMAXTERMREQS
S#define FSM_DEFMAXTERMREQS              2       /* Maximum Terminate-Request transmissions */
S#endif
S
S#ifndef FSM_DEFMAXCONFREQS
S#define FSM_DEFMAXCONFREQS              10      /* Maximum Configure-Request transmissions */
S#endif
S
S#ifndef FSM_DEFMAXNAKLOOPS
S#define FSM_DEFMAXNAKLOOPS              5       /* Maximum number of nak loops */
S#endif
S
S#ifndef UPAP_DEFTIMEOUT
S#define UPAP_DEFTIMEOUT                 6       /* Timeout (seconds) for retransmitting req */
S#endif
S
S#ifndef UPAP_DEFREQTIME
S#define UPAP_DEFREQTIME                 30      /* Time to wait for auth-req from peer */
S#endif
S
S#ifndef CHAP_DEFTIMEOUT
S#define CHAP_DEFTIMEOUT                 6       /* Timeout time in seconds */
S#endif
S
S#ifndef CHAP_DEFTRANSMITS
S#define CHAP_DEFTRANSMITS               10      /* max # times to send challenge */
S#endif
S
S/* Interval in seconds between keepalive echo requests, 0 to disable. */
S#ifndef LCP_ECHOINTERVAL
S#define LCP_ECHOINTERVAL                0
S#endif
S
S/* Number of unanswered echo requests before failure. */
S#ifndef LCP_MAXECHOFAILS
S#define LCP_MAXECHOFAILS                3
S#endif
S
S/* Max Xmit idle time (in jiffies) before resend flag char. */
S#ifndef PPP_MAXIDLEFLAG
S#define PPP_MAXIDLEFLAG                 100
S#endif
S
S/*
S * Packet sizes
S *
S * Note - lcp shouldn't be allowed to negotiate stuff outside these
S *    limits.  See lcp.h in the pppd directory.
S * (XXX - these constants should simply be shared by lcp.c instead
S *    of living in lcp.h)
S */
S#define PPP_MTU                         1500     /* Default MTU (size of Info field) */
S#ifndef PPP_MAXMTU
S/* #define PPP_MAXMTU  65535 - (PPP_HDRLEN + PPP_FCSLEN) */
S#define PPP_MAXMTU                      1500 /* Largest MTU we allow */
S#endif
S#define PPP_MINMTU                      64
S#define PPP_MRU                         1500     /* default MRU = max length of info field */
S#define PPP_MAXMRU                      1500     /* Largest MRU we allow */
S#ifndef PPP_DEFMRU
S#define PPP_DEFMRU                      296             /* Try for this */
S#endif
S#define PPP_MINMRU                      128             /* No MRUs below this */
S
S#ifndef MAXNAMELEN
S#define MAXNAMELEN                      256     /* max length of hostname or name for auth */
S#endif
S#ifndef MAXSECRETLEN
S#define MAXSECRETLEN                    256     /* max length of password or secret */
S#endif
S
N#endif /* PPP_SUPPORT */
N
N/*
N   --------------------------------------
N   ---------- Checksum options ----------
N   --------------------------------------
N*/
N/**
N * CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.
N */
N#ifndef CHECKSUM_GEN_IP
S#define CHECKSUM_GEN_IP                 1
N#endif
N 
N/**
N * CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.
N */
N#ifndef CHECKSUM_GEN_UDP
S#define CHECKSUM_GEN_UDP                1
N#endif
N 
N/**
N * CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.
N */
N#ifndef CHECKSUM_GEN_TCP
S#define CHECKSUM_GEN_TCP                1
N#endif
N
N/**
N * CHECKSUM_GEN_ICMP==1: Generate checksums in software for outgoing ICMP packets.
N */
N#ifndef CHECKSUM_GEN_ICMP
S#define CHECKSUM_GEN_ICMP               1
N#endif
N 
N/**
N * CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.
N */
N#ifndef CHECKSUM_CHECK_IP
S#define CHECKSUM_CHECK_IP               1
N#endif
N 
N/**
N * CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.
N */
N#ifndef CHECKSUM_CHECK_UDP
S#define CHECKSUM_CHECK_UDP              1
N#endif
N
N/**
N * CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.
N */
N#ifndef CHECKSUM_CHECK_TCP
S#define CHECKSUM_CHECK_TCP              1
N#endif
N
N/**
N * LWIP_CHECKSUM_ON_COPY==1: Calculate checksum when copying data from
N * application buffers to pbufs.
N */
N#ifndef LWIP_CHECKSUM_ON_COPY
N#define LWIP_CHECKSUM_ON_COPY           0
N#endif
N
N/*
N   ---------------------------------------
N   ---------- Hook options ---------------
N   ---------------------------------------
N*/
N
N/* Hooks are undefined by default, define them to a function if you need them. */
N
N/**
N * LWIP_HOOK_IP4_INPUT(pbuf, input_netif):
N * - called from ip_input() (IPv4)
N * - pbuf: received struct pbuf passed to ip_input()
N * - input_netif: struct netif on which the packet has been received
N * Return values:
N * - 0: Hook has not consumed the packet, packet is processed as normal
N * - != 0: Hook has consumed the packet.
N * If the hook consumed the packet, 'pbuf' is in the responsibility of the hook
N * (i.e. free it when done).
N */
N
N/**
N * LWIP_HOOK_IP4_ROUTE(dest):
N * - called from ip_route() (IPv4)
N * - dest: destination IPv4 address
N * Returns the destination netif or NULL if no destination netif is found. In
N * that case, ip_route() continues as normal.
N */
N
N/*
N   ---------------------------------------
N   ---------- Debugging options ----------
N   ---------------------------------------
N*/
N/**
N * LWIP_DBG_MIN_LEVEL: After masking, the value of the debug is
N * compared against this value. If it is smaller, then debugging
N * messages are written.
N */
N#ifndef LWIP_DBG_MIN_LEVEL
N#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_ALL
N#endif
N
N/**
N * LWIP_DBG_TYPES_ON: A mask that can be used to globally enable/disable
N * debug messages of certain types.
N */
N#ifndef LWIP_DBG_TYPES_ON
N#define LWIP_DBG_TYPES_ON               LWIP_DBG_ON
N#endif
N
N/**
N * ETHARP_DEBUG: Enable debugging in etharp.c.
N */
N#ifndef ETHARP_DEBUG
N#define ETHARP_DEBUG                    LWIP_DBG_OFF
N#endif
N
N/**
N * NETIF_DEBUG: Enable debugging in netif.c.
N */
N#ifndef NETIF_DEBUG
N#define NETIF_DEBUG                     LWIP_DBG_OFF
N#endif
N
N/**
N * PBUF_DEBUG: Enable debugging in pbuf.c.
N */
N#ifndef PBUF_DEBUG
N#define PBUF_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * API_LIB_DEBUG: Enable debugging in api_lib.c.
N */
N#ifndef API_LIB_DEBUG
N#define API_LIB_DEBUG                   LWIP_DBG_OFF
N#endif
N
N/**
N * API_MSG_DEBUG: Enable debugging in api_msg.c.
N */
N#ifndef API_MSG_DEBUG
N#define API_MSG_DEBUG                   LWIP_DBG_OFF
N#endif
N
N/**
N * SOCKETS_DEBUG: Enable debugging in sockets.c.
N */
N#ifndef SOCKETS_DEBUG
N#define SOCKETS_DEBUG                   LWIP_DBG_OFF
N#endif
N
N/**
N * ICMP_DEBUG: Enable debugging in icmp.c.
N */
N#ifndef ICMP_DEBUG
N#define ICMP_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * IGMP_DEBUG: Enable debugging in igmp.c.
N */
N#ifndef IGMP_DEBUG
N#define IGMP_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * INET_DEBUG: Enable debugging in inet.c.
N */
N#ifndef INET_DEBUG
N#define INET_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * IP_DEBUG: Enable debugging for IP.
N */
N#ifndef IP_DEBUG
N#define IP_DEBUG                        LWIP_DBG_OFF
N#endif
N
N/**
N * IP_REASS_DEBUG: Enable debugging in ip_frag.c for both frag & reass.
N */
N#ifndef IP_REASS_DEBUG
N#define IP_REASS_DEBUG                  LWIP_DBG_OFF
N#endif
N
N/**
N * RAW_DEBUG: Enable debugging in raw.c.
N */
N#ifndef RAW_DEBUG
N#define RAW_DEBUG                       LWIP_DBG_OFF
N#endif
N
N/**
N * MEM_DEBUG: Enable debugging in mem.c.
N */
N#ifndef MEM_DEBUG
N#define MEM_DEBUG                       LWIP_DBG_OFF
N#endif
N
N/**
N * MEMP_DEBUG: Enable debugging in memp.c.
N */
N#ifndef MEMP_DEBUG
N#define MEMP_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * SYS_DEBUG: Enable debugging in sys.c.
N */
N#ifndef SYS_DEBUG
N#define SYS_DEBUG                       LWIP_DBG_OFF
N#endif
N
N/**
N * TIMERS_DEBUG: Enable debugging in timers.c.
N */
N#ifndef TIMERS_DEBUG
N#define TIMERS_DEBUG                    LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_DEBUG: Enable debugging for TCP.
N */
N#ifndef TCP_DEBUG
N#define TCP_DEBUG                       LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_INPUT_DEBUG: Enable debugging in tcp_in.c for incoming debug.
N */
N#ifndef TCP_INPUT_DEBUG
N#define TCP_INPUT_DEBUG                 LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_FR_DEBUG: Enable debugging in tcp_in.c for fast retransmit.
N */
N#ifndef TCP_FR_DEBUG
N#define TCP_FR_DEBUG                    LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_RTO_DEBUG: Enable debugging in TCP for retransmit
N * timeout.
N */
N#ifndef TCP_RTO_DEBUG
N#define TCP_RTO_DEBUG                   LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_CWND_DEBUG: Enable debugging for TCP congestion window.
N */
N#ifndef TCP_CWND_DEBUG
N#define TCP_CWND_DEBUG                  LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_WND_DEBUG: Enable debugging in tcp_in.c for window updating.
N */
N#ifndef TCP_WND_DEBUG
N#define TCP_WND_DEBUG                   LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_OUTPUT_DEBUG: Enable debugging in tcp_out.c output functions.
N */
N#ifndef TCP_OUTPUT_DEBUG
N#define TCP_OUTPUT_DEBUG                LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_RST_DEBUG: Enable debugging for TCP with the RST message.
N */
N#ifndef TCP_RST_DEBUG
N#define TCP_RST_DEBUG                   LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_QLEN_DEBUG: Enable debugging for TCP queue lengths.
N */
N#ifndef TCP_QLEN_DEBUG
N#define TCP_QLEN_DEBUG                  LWIP_DBG_OFF
N#endif
N
N/**
N * UDP_DEBUG: Enable debugging in UDP.
N */
N#ifndef UDP_DEBUG
N#define UDP_DEBUG                       LWIP_DBG_OFF
N#endif
N
N/**
N * TCPIP_DEBUG: Enable debugging in tcpip.c.
N */
N#ifndef TCPIP_DEBUG
N#define TCPIP_DEBUG                     LWIP_DBG_OFF
N#endif
N
N/**
N * PPP_DEBUG: Enable debugging for PPP.
N */
N#ifndef PPP_DEBUG
N#define PPP_DEBUG                       LWIP_DBG_OFF
N#endif
N
N/**
N * SLIP_DEBUG: Enable debugging in slipif.c.
N */
N#ifndef SLIP_DEBUG
N#define SLIP_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * DHCP_DEBUG: Enable debugging in dhcp.c.
N */
N#ifndef DHCP_DEBUG
N#define DHCP_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * AUTOIP_DEBUG: Enable debugging in autoip.c.
N */
N#ifndef AUTOIP_DEBUG
N#define AUTOIP_DEBUG                    LWIP_DBG_OFF
N#endif
N
N/**
N * SNMP_MSG_DEBUG: Enable debugging for SNMP messages.
N */
N#ifndef SNMP_MSG_DEBUG
N#define SNMP_MSG_DEBUG                  LWIP_DBG_OFF
N#endif
N
N/**
N * SNMP_MIB_DEBUG: Enable debugging for SNMP MIBs.
N */
N#ifndef SNMP_MIB_DEBUG
N#define SNMP_MIB_DEBUG                  LWIP_DBG_OFF
N#endif
N
N/**
N * DNS_DEBUG: Enable debugging for DNS.
N */
N#ifndef DNS_DEBUG
N#define DNS_DEBUG                       LWIP_DBG_OFF
N#endif
N
N#endif /* __LWIP_OPT_H__ */
L 36 "..\..\Lwip\lwip-1.4.1\src\include\lwip\netif.h" 2
N
N#define ENABLE_LOOPBACK (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF)
N
N#include "lwip/err.h"
L 1 "..\..\Lwip\lwip-1.4.1\src\include\lwip/err.h" 1
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_ERR_H__
N#define __LWIP_ERR_H__
N
N#include "lwip/opt.h"
N#include "lwip/arch.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** Define LWIP_ERR_T in cc.h if you want to use
N *  a different type for your platform (must be signed). */
N#ifdef LWIP_ERR_T
Stypedef LWIP_ERR_T err_t;
N#else /* LWIP_ERR_T */
Ntypedef s8_t err_t;
N#endif /* LWIP_ERR_T*/
N
N/* Definitions for error constants. */
N
N#define ERR_OK          0    /* No error, everything OK. */
N#define ERR_MEM        -1    /* Out of memory error.     */
N#define ERR_BUF        -2    /* Buffer error.            */
N#define ERR_TIMEOUT    -3    /* Timeout.                 */
N#define ERR_RTE        -4    /* Routing problem.         */
N#define ERR_INPROGRESS -5    /* Operation in progress    */
N#define ERR_VAL        -6    /* Illegal value.           */
N#define ERR_WOULDBLOCK -7    /* Operation would block.   */
N#define ERR_USE        -8    /* Address in use.          */
N#define ERR_ISCONN     -9    /* Already connected.       */
N
N#define ERR_IS_FATAL(e) ((e) < ERR_ISCONN)
N
N#define ERR_ABRT       -10   /* Connection aborted.      */
N#define ERR_RST        -11   /* Connection reset.        */
N#define ERR_CLSD       -12   /* Connection closed.       */
N#define ERR_CONN       -13   /* Not connected.           */
N
N#define ERR_ARG        -14   /* Illegal argument.        */
N
N#define ERR_IF         -15   /* Low-level netif error    */
N
N
N#ifdef LWIP_DEBUG
Sextern const char *lwip_strerr(err_t err);
N#else
N#define lwip_strerr(x) ""
N#endif /* LWIP_DEBUG */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __LWIP_ERR_H__ */
L 40 "..\..\Lwip\lwip-1.4.1\src\include\lwip\netif.h" 2
N
N#include "lwip/ip_addr.h"
L 1 "..\..\Lwip\lwip-1.4.1\src\include\ipv4\lwip/ip_addr.h" 1
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N *
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_IP_ADDR_H__
N#define __LWIP_IP_ADDR_H__
N
N#include "lwip/opt.h"
N#include "lwip/def.h"
L 1 "..\..\Lwip\lwip-1.4.1\src\include\lwip/def.h" 1
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_DEF_H__
N#define __LWIP_DEF_H__
N
N/* arch.h might define NULL already */
N#include "lwip/arch.h"
N#include "lwip/opt.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define LWIP_MAX(x , y)  (((x) > (y)) ? (x) : (y))
N#define LWIP_MIN(x , y)  (((x) < (y)) ? (x) : (y))
N
N#ifndef NULL
S#define NULL ((void *)0)
N#endif
N
N/* Endianess-optimized shifting of two u8_t to create one u16_t */
N#if BYTE_ORDER == LITTLE_ENDIAN
X#if 1234 == 1234
N#define LWIP_MAKE_U16(a, b) ((a << 8) | b)
N#else
S#define LWIP_MAKE_U16(a, b) ((b << 8) | a)
N#endif 
N
N#ifndef LWIP_PLATFORM_BYTESWAP
N#define LWIP_PLATFORM_BYTESWAP 0
N#endif
N
N#ifndef LWIP_PREFIX_BYTEORDER_FUNCS
N/* workaround for naming collisions on some platforms */
N
N#ifdef htons
S#undef htons
N#endif /* htons */
N#ifdef htonl
S#undef htonl
N#endif /* htonl */
N#ifdef ntohs
S#undef ntohs
N#endif /* ntohs */
N#ifdef ntohl
S#undef ntohl
N#endif /* ntohl */
N
N#define htons(x) lwip_htons(x)
N#define ntohs(x) lwip_ntohs(x)
N#define htonl(x) lwip_htonl(x)
N#define ntohl(x) lwip_ntohl(x)
N#endif /* LWIP_PREFIX_BYTEORDER_FUNCS */
N
N#if BYTE_ORDER == BIG_ENDIAN
X#if 1234 == 4321
S#define lwip_htons(x) (x)
S#define lwip_ntohs(x) (x)
S#define lwip_htonl(x) (x)
S#define lwip_ntohl(x) (x)
S#define PP_HTONS(x) (x)
S#define PP_NTOHS(x) (x)
S#define PP_HTONL(x) (x)
S#define PP_NTOHL(x) (x)
N#else /* BYTE_ORDER != BIG_ENDIAN */
N#if LWIP_PLATFORM_BYTESWAP
X#if 0
S#define lwip_htons(x) LWIP_PLATFORM_HTONS(x)
S#define lwip_ntohs(x) LWIP_PLATFORM_HTONS(x)
S#define lwip_htonl(x) LWIP_PLATFORM_HTONL(x)
S#define lwip_ntohl(x) LWIP_PLATFORM_HTONL(x)
N#else /* LWIP_PLATFORM_BYTESWAP */
Nu16_t lwip_htons(u16_t x);
Nu16_t lwip_ntohs(u16_t x);
Nu32_t lwip_htonl(u32_t x);
Nu32_t lwip_ntohl(u32_t x);
N#endif /* LWIP_PLATFORM_BYTESWAP */
N
N/* These macros should be calculated by the preprocessor and are used
N   with compile-time constants only (so that there is no little-endian
N   overhead at runtime). */
N#define PP_HTONS(x) ((((x) & 0xff) << 8) | (((x) & 0xff00) >> 8))
N#define PP_NTOHS(x) PP_HTONS(x)
N#define PP_HTONL(x) ((((x) & 0xff) << 24) | \
N                     (((x) & 0xff00) << 8) | \
N                     (((x) & 0xff0000UL) >> 8) | \
N                     (((x) & 0xff000000UL) >> 24))
X#define PP_HTONL(x) ((((x) & 0xff) << 24) |                      (((x) & 0xff00) << 8) |                      (((x) & 0xff0000UL) >> 8) |                      (((x) & 0xff000000UL) >> 24))
N#define PP_NTOHL(x) PP_HTONL(x)
N
N#endif /* BYTE_ORDER == BIG_ENDIAN */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __LWIP_DEF_H__ */
N
L 37 "..\..\Lwip\lwip-1.4.1\src\include\ipv4\lwip/ip_addr.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* This is the aligned version of ip_addr_t,
N   used as local variable, on the stack, etc. */
Nstruct ip_addr {
N  u32_t addr;
N};
N
N/* This is the packed version of ip_addr_t,
N   used in network headers that are itself packed */
N#ifdef PACK_STRUCT_USE_INCLUDES
S#  include "arch/bpstruct.h"
N#endif
NPACK_STRUCT_BEGIN
X__packed
Nstruct ip_addr_packed {
N  PACK_STRUCT_FIELD(u32_t addr);
X  u32_t addr;
N} PACK_STRUCT_STRUCT;
X} ;
NPACK_STRUCT_END
X
N#ifdef PACK_STRUCT_USE_INCLUDES
S#  include "arch/epstruct.h"
N#endif
N
N/** ip_addr_t uses a struct for convenience only, so that the same defines can
N * operate both on ip_addr_t as well as on ip_addr_p_t. */
Ntypedef struct ip_addr ip_addr_t;
Ntypedef struct ip_addr_packed ip_addr_p_t;
N
N/*
N * struct ipaddr2 is used in the definition of the ARP packet format in
N * order to support compilers that don't have structure packing.
N */
N#ifdef PACK_STRUCT_USE_INCLUDES
S#  include "arch/bpstruct.h"
N#endif
NPACK_STRUCT_BEGIN
X__packed
Nstruct ip_addr2 {
N  PACK_STRUCT_FIELD(u16_t addrw[2]);
X  u16_t addrw[2];
N} PACK_STRUCT_STRUCT;
X} ;
NPACK_STRUCT_END
X
N#ifdef PACK_STRUCT_USE_INCLUDES
S#  include "arch/epstruct.h"
N#endif
N
N/* Forward declaration to not include netif.h */
Nstruct netif;
N
Nextern const ip_addr_t ip_addr_any;
Nextern const ip_addr_t ip_addr_broadcast;
N
N/** IP_ADDR_ can be used as a fixed IP address
N *  for the wildcard and the broadcast address
N */
N#define IP_ADDR_ANY         ((ip_addr_t *)&ip_addr_any)
N#define IP_ADDR_BROADCAST   ((ip_addr_t *)&ip_addr_broadcast)
N
N/** 255.255.255.255 */
N#define IPADDR_NONE         ((u32_t)0xffffffffUL)
N/** 127.0.0.1 */
N#define IPADDR_LOOPBACK     ((u32_t)0x7f000001UL)
N/** 0.0.0.0 */
N#define IPADDR_ANY          ((u32_t)0x00000000UL)
N/** 255.255.255.255 */
N#define IPADDR_BROADCAST    ((u32_t)0xffffffffUL)
N
N/* Definitions of the bits in an Internet address integer.
N
N   On subnets, host and network parts are found according to
N   the subnet mask, not these masks.  */
N#define IP_CLASSA(a)        ((((u32_t)(a)) & 0x80000000UL) == 0)
N#define IP_CLASSA_NET       0xff000000
N#define IP_CLASSA_NSHIFT    24
N#define IP_CLASSA_HOST      (0xffffffff & ~IP_CLASSA_NET)
N#define IP_CLASSA_MAX       128
N
N#define IP_CLASSB(a)        ((((u32_t)(a)) & 0xc0000000UL) == 0x80000000UL)
N#define IP_CLASSB_NET       0xffff0000
N#define IP_CLASSB_NSHIFT    16
N#define IP_CLASSB_HOST      (0xffffffff & ~IP_CLASSB_NET)
N#define IP_CLASSB_MAX       65536
N
N#define IP_CLASSC(a)        ((((u32_t)(a)) & 0xe0000000UL) == 0xc0000000UL)
N#define IP_CLASSC_NET       0xffffff00
N#define IP_CLASSC_NSHIFT    8
N#define IP_CLASSC_HOST      (0xffffffff & ~IP_CLASSC_NET)
N
N#define IP_CLASSD(a)        (((u32_t)(a) & 0xf0000000UL) == 0xe0000000UL)
N#define IP_CLASSD_NET       0xf0000000          /* These ones aren't really */
N#define IP_CLASSD_NSHIFT    28                  /*   net and host fields, but */
N#define IP_CLASSD_HOST      0x0fffffff          /*   routing needn't know. */
N#define IP_MULTICAST(a)     IP_CLASSD(a)
N
N#define IP_EXPERIMENTAL(a)  (((u32_t)(a) & 0xf0000000UL) == 0xf0000000UL)
N#define IP_BADCLASS(a)      (((u32_t)(a) & 0xf0000000UL) == 0xf0000000UL)
N
N#define IP_LOOPBACKNET      127                 /* official! */
N
N
N#if BYTE_ORDER == BIG_ENDIAN
X#if 1234 == 4321
S/** Set an IP address given by the four byte-parts */
S#define IP4_ADDR(ipaddr, a,b,c,d) \
S        (ipaddr)->addr = ((u32_t)((a) & 0xff) << 24) | \
S                         ((u32_t)((b) & 0xff) << 16) | \
S                         ((u32_t)((c) & 0xff) << 8)  | \
S                          (u32_t)((d) & 0xff)
X#define IP4_ADDR(ipaddr, a,b,c,d)         (ipaddr)->addr = ((u32_t)((a) & 0xff) << 24) |                          ((u32_t)((b) & 0xff) << 16) |                          ((u32_t)((c) & 0xff) << 8)  |                           (u32_t)((d) & 0xff)
N#else
N/** Set an IP address given by the four byte-parts.
N    Little-endian version that prevents the use of htonl. */
N#define IP4_ADDR(ipaddr, a,b,c,d) \
N        (ipaddr)->addr = ((u32_t)((d) & 0xff) << 24) | \
N                         ((u32_t)((c) & 0xff) << 16) | \
N                         ((u32_t)((b) & 0xff) << 8)  | \
N                          (u32_t)((a) & 0xff)
X#define IP4_ADDR(ipaddr, a,b,c,d)         (ipaddr)->addr = ((u32_t)((d) & 0xff) << 24) |                          ((u32_t)((c) & 0xff) << 16) |                          ((u32_t)((b) & 0xff) << 8)  |                           (u32_t)((a) & 0xff)
N#endif
N
N/** MEMCPY-like copying of IP addresses where addresses are known to be
N * 16-bit-aligned if the port is correctly configured (so a port could define
N * this to copying 2 u16_t's) - no NULL-pointer-checking needed. */
N#ifndef IPADDR2_COPY
N#define IPADDR2_COPY(dest, src) SMEMCPY(dest, src, sizeof(ip_addr_t))
N#endif
N
N/** Copy IP address - faster than ip_addr_set: no NULL check */
N#define ip_addr_copy(dest, src) ((dest).addr = (src).addr)
N/** Safely copy one IP address to another (src may be NULL) */
N#define ip_addr_set(dest, src) ((dest)->addr = \
N                                    ((src) == NULL ? 0 : \
N                                    (src)->addr))
X#define ip_addr_set(dest, src) ((dest)->addr =                                     ((src) == NULL ? 0 :                                     (src)->addr))
N/** Set complete address to zero */
N#define ip_addr_set_zero(ipaddr)      ((ipaddr)->addr = 0)
N/** Set address to IPADDR_ANY (no need for htonl()) */
N#define ip_addr_set_any(ipaddr)       ((ipaddr)->addr = IPADDR_ANY)
N/** Set address to loopback address */
N#define ip_addr_set_loopback(ipaddr)  ((ipaddr)->addr = PP_HTONL(IPADDR_LOOPBACK))
N/** Safely copy one IP address to another and change byte order
N * from host- to network-order. */
N#define ip_addr_set_hton(dest, src) ((dest)->addr = \
N                               ((src) == NULL ? 0:\
N                               htonl((src)->addr)))
X#define ip_addr_set_hton(dest, src) ((dest)->addr =                                ((src) == NULL ? 0:                               htonl((src)->addr)))
N/** IPv4 only: set the IP address given as an u32_t */
N#define ip4_addr_set_u32(dest_ipaddr, src_u32) ((dest_ipaddr)->addr = (src_u32))
N/** IPv4 only: get the IP address as an u32_t */
N#define ip4_addr_get_u32(src_ipaddr) ((src_ipaddr)->addr)
N
N/** Get the network address by combining host address with netmask */
N#define ip_addr_get_network(target, host, netmask) ((target)->addr = ((host)->addr) & ((netmask)->addr))
N
N/**
N * Determine if two address are on the same network.
N *
N * @arg addr1 IP address 1
N * @arg addr2 IP address 2
N * @arg mask network identifier mask
N * @return !0 if the network identifiers of both address match
N */
N#define ip_addr_netcmp(addr1, addr2, mask) (((addr1)->addr & \
N                                              (mask)->addr) == \
N                                             ((addr2)->addr & \
N                                              (mask)->addr))
X#define ip_addr_netcmp(addr1, addr2, mask) (((addr1)->addr &                                               (mask)->addr) ==                                              ((addr2)->addr &                                               (mask)->addr))
N#define ip_addr_cmp(addr1, addr2) ((addr1)->addr == (addr2)->addr)
N
N#define ip_addr_isany(addr1) ((addr1) == NULL || (addr1)->addr == IPADDR_ANY)
N
N#define ip_addr_isbroadcast(ipaddr, netif) ip4_addr_isbroadcast((ipaddr)->addr, (netif))
Nu8_t ip4_addr_isbroadcast(u32_t addr, const struct netif *netif);
N
N#define ip_addr_netmask_valid(netmask) ip4_addr_netmask_valid((netmask)->addr)
Nu8_t ip4_addr_netmask_valid(u32_t netmask);
N
N#define ip_addr_ismulticast(addr1) (((addr1)->addr & PP_HTONL(0xf0000000UL)) == PP_HTONL(0xe0000000UL))
N
N#define ip_addr_islinklocal(addr1) (((addr1)->addr & PP_HTONL(0xffff0000UL)) == PP_HTONL(0xa9fe0000UL))
N
N#define ip_addr_debug_print(debug, ipaddr) \
N  LWIP_DEBUGF(debug, ("%"U16_F".%"U16_F".%"U16_F".%"U16_F,             \
N                      ipaddr != NULL ? ip4_addr1_16(ipaddr) : 0,       \
N                      ipaddr != NULL ? ip4_addr2_16(ipaddr) : 0,       \
N                      ipaddr != NULL ? ip4_addr3_16(ipaddr) : 0,       \
N                      ipaddr != NULL ? ip4_addr4_16(ipaddr) : 0))
X#define ip_addr_debug_print(debug, ipaddr)   LWIP_DEBUGF(debug, ("%"U16_F".%"U16_F".%"U16_F".%"U16_F,                                   ipaddr != NULL ? ip4_addr1_16(ipaddr) : 0,                             ipaddr != NULL ? ip4_addr2_16(ipaddr) : 0,                             ipaddr != NULL ? ip4_addr3_16(ipaddr) : 0,                             ipaddr != NULL ? ip4_addr4_16(ipaddr) : 0))
N
N/* Get one byte from the 4-byte address */
N#define ip4_addr1(ipaddr) (((u8_t*)(ipaddr))[0])
N#define ip4_addr2(ipaddr) (((u8_t*)(ipaddr))[1])
N#define ip4_addr3(ipaddr) (((u8_t*)(ipaddr))[2])
N#define ip4_addr4(ipaddr) (((u8_t*)(ipaddr))[3])
N/* These are cast to u16_t, with the intent that they are often arguments
N * to printf using the U16_F format from cc.h. */
N#define ip4_addr1_16(ipaddr) ((u16_t)ip4_addr1(ipaddr))
N#define ip4_addr2_16(ipaddr) ((u16_t)ip4_addr2(ipaddr))
N#define ip4_addr3_16(ipaddr) ((u16_t)ip4_addr3(ipaddr))
N#define ip4_addr4_16(ipaddr) ((u16_t)ip4_addr4(ipaddr))
N
N/** For backwards compatibility */
N#define ip_ntoa(ipaddr)  ipaddr_ntoa(ipaddr)
N
Nu32_t ipaddr_addr(const char *cp);
Nint ipaddr_aton(const char *cp, ip_addr_t *addr);
N/** returns ptr to static buffer; not reentrant! */
Nchar *ipaddr_ntoa(const ip_addr_t *addr);
Nchar *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __LWIP_IP_ADDR_H__ */
L 42 "..\..\Lwip\lwip-1.4.1\src\include\lwip\netif.h" 2
N
N#include "lwip/def.h"
N#include "lwip/pbuf.h"
L 1 "..\..\Lwip\lwip-1.4.1\src\include\lwip/pbuf.h" 1
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N
N#ifndef __LWIP_PBUF_H__
N#define __LWIP_PBUF_H__
N
N#include "lwip/opt.h"
N#include "lwip/err.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** Currently, the pbuf_custom code is only needed for one specific configuration
N * of IP_FRAG */
N#define LWIP_SUPPORT_CUSTOM_PBUF (IP_FRAG && !IP_FRAG_USES_STATIC_BUF && !LWIP_NETIF_TX_SINGLE_PBUF)
N
N#define PBUF_TRANSPORT_HLEN 20
N#define PBUF_IP_HLEN        20
N
Ntypedef enum {
N  PBUF_TRANSPORT,
N  PBUF_IP,
N  PBUF_LINK,
N  PBUF_RAW
N} pbuf_layer;
N
Ntypedef enum {
N  PBUF_RAM, /* pbuf data is stored in RAM */
N  PBUF_ROM, /* pbuf data is stored in ROM */
N  PBUF_REF, /* pbuf comes from the pbuf pool */
N  PBUF_POOL /* pbuf payload refers to RAM */
N} pbuf_type;
N
N
N/** indicates this packet's data should be immediately passed to the application */
N#define PBUF_FLAG_PUSH      0x01U
N/** indicates this is a custom pbuf: pbuf_free and pbuf_header handle such a
N    a pbuf differently */
N#define PBUF_FLAG_IS_CUSTOM 0x02U
N/** indicates this pbuf is UDP multicast to be looped back */
N#define PBUF_FLAG_MCASTLOOP 0x04U
N/** indicates this pbuf was received as link-level broadcast */
N#define PBUF_FLAG_LLBCAST   0x08U
N/** indicates this pbuf was received as link-level multicast */
N#define PBUF_FLAG_LLMCAST   0x10U
N/** indicates this pbuf includes a TCP FIN flag */
N#define PBUF_FLAG_TCP_FIN   0x20U
N
Nstruct pbuf {
N  /** next pbuf in singly linked pbuf chain */
N  struct pbuf *next;
N
N  /** pointer to the actual data in the buffer */
N  void *payload;
N
N  /**
N   * total length of this buffer and all next buffers in chain
N   * belonging to the same packet.
N   *
N   * For non-queue packet chains this is the invariant:
N   * p->tot_len == p->len + (p->next? p->next->tot_len: 0)
N   */
N  u16_t tot_len;
N
N  /** length of this buffer */
N  u16_t len;
N
N  /** pbuf_type as u8_t instead of enum to save space */
N  u8_t /*pbuf_type*/ type;
N
N  /** misc flags */
N  u8_t flags;
N
N  /**
N   * the reference count always equals the number of pointers
N   * that refer to this pbuf. This can be pointers from an application,
N   * the stack itself, or pbuf->next pointers from a chain.
N   */
N  u16_t ref;
N};
N
N#if LWIP_SUPPORT_CUSTOM_PBUF
X#if (1 && !0 && !0)
N/** Prototype for a function to free a custom pbuf */
Ntypedef void (*pbuf_free_custom_fn)(struct pbuf *p);
N
N/** A custom pbuf: like a pbuf, but following a function pointer to free it. */
Nstruct pbuf_custom {
N  /** The actual pbuf */
N  struct pbuf pbuf;
N  /** This function is called when pbuf_free deallocates this pbuf(_custom) */
N  pbuf_free_custom_fn custom_free_function;
N};
N#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
N
N#if LWIP_TCP && TCP_QUEUE_OOSEQ
X#if 1 && 1
N/** Define this to 0 to prevent freeing ooseq pbufs when the PBUF_POOL is empty */
N#ifndef PBUF_POOL_FREE_OOSEQ
N#define PBUF_POOL_FREE_OOSEQ 1
N#endif /* PBUF_POOL_FREE_OOSEQ */
N#if NO_SYS && PBUF_POOL_FREE_OOSEQ
X#if 1 && 1
Nextern volatile u8_t pbuf_free_ooseq_pending;
Nvoid pbuf_free_ooseq(void);
N/** When not using sys_check_timeouts(), call PBUF_CHECK_FREE_OOSEQ()
N    at regular intervals from main level to check if ooseq pbufs need to be
N    freed! */
N#define PBUF_CHECK_FREE_OOSEQ() do { if(pbuf_free_ooseq_pending) { \
N  /* pbuf_alloc() reported PBUF_POOL to be empty -> try to free some \
N     ooseq queued pbufs now */ \
N  pbuf_free_ooseq(); }}while(0)
X#define PBUF_CHECK_FREE_OOSEQ() do { if(pbuf_free_ooseq_pending) {       pbuf_free_ooseq(); }}while(0)
N#endif /* NO_SYS && PBUF_POOL_FREE_OOSEQ*/
N#endif /* LWIP_TCP && TCP_QUEUE_OOSEQ */
N
N/* Initializes the pbuf module. This call is empty for now, but may not be in future. */
N#define pbuf_init()
N
Nstruct pbuf *pbuf_alloc(pbuf_layer l, u16_t length, pbuf_type type);
N#if LWIP_SUPPORT_CUSTOM_PBUF
X#if (1 && !0 && !0)
Nstruct pbuf *pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type,
N                                 struct pbuf_custom *p, void *payload_mem,
N                                 u16_t payload_mem_len);
N#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
Nvoid pbuf_realloc(struct pbuf *p, u16_t size); 
Nu8_t pbuf_header(struct pbuf *p, s16_t header_size);
Nvoid pbuf_ref(struct pbuf *p);
Nu8_t pbuf_free(struct pbuf *p);
Nu8_t pbuf_clen(struct pbuf *p);  
Nvoid pbuf_cat(struct pbuf *head, struct pbuf *tail);
Nvoid pbuf_chain(struct pbuf *head, struct pbuf *tail);
Nstruct pbuf *pbuf_dechain(struct pbuf *p);
Nerr_t pbuf_copy(struct pbuf *p_to, struct pbuf *p_from);
Nu16_t pbuf_copy_partial(struct pbuf *p, void *dataptr, u16_t len, u16_t offset);
Nerr_t pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len);
Nstruct pbuf *pbuf_coalesce(struct pbuf *p, pbuf_layer layer);
N#if LWIP_CHECKSUM_ON_COPY
X#if 0
Serr_t pbuf_fill_chksum(struct pbuf *p, u16_t start_offset, const void *dataptr,
S                       u16_t len, u16_t *chksum);
N#endif /* LWIP_CHECKSUM_ON_COPY */
N
Nu8_t pbuf_get_at(struct pbuf* p, u16_t offset);
Nu16_t pbuf_memcmp(struct pbuf* p, u16_t offset, const void* s2, u16_t n);
Nu16_t pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset);
Nu16_t pbuf_strstr(struct pbuf* p, const char* substr);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __LWIP_PBUF_H__ */
L 45 "..\..\Lwip\lwip-1.4.1\src\include\lwip\netif.h" 2
N#if LWIP_DHCP
X#if 1
Nstruct dhcp;
N#endif
N#if LWIP_AUTOIP
X#if 0
Sstruct autoip;
N#endif
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Throughout this file, IP addresses are expected to be in
N * the same byte order as in IP_PCB. */
N
N/** must be the maximum of all used hardware address lengths
N    across all types of interfaces in use */
N#define NETIF_MAX_HWADDR_LEN 6U
N
N/** Whether the network interface is 'up'. This is
N * a software flag used to control whether this network
N * interface is enabled and processes traffic.
N * It is set by the startup code (for static IP configuration) or
N * by dhcp/autoip when an address has been assigned.
N */
N#define NETIF_FLAG_UP           0x01U
N/** If set, the netif has broadcast capability.
N * Set by the netif driver in its init function. */
N#define NETIF_FLAG_BROADCAST    0x02U
N/** If set, the netif is one end of a point-to-point connection.
N * Set by the netif driver in its init function. */
N#define NETIF_FLAG_POINTTOPOINT 0x04U
N/** If set, the interface is configured using DHCP.
N * Set by the DHCP code when starting or stopping DHCP. */
N#define NETIF_FLAG_DHCP         0x08U
N/** If set, the interface has an active link
N *  (set by the network interface driver).
N * Either set by the netif driver in its init function (if the link
N * is up at that time) or at a later point once the link comes up
N * (if link detection is supported by the hardware). */
N#define NETIF_FLAG_LINK_UP      0x10U
N/** If set, the netif is an ethernet device using ARP.
N * Set by the netif driver in its init function.
N * Used to check input packet types and use of DHCP. */
N#define NETIF_FLAG_ETHARP       0x20U
N/** If set, the netif is an ethernet device. It might not use
N * ARP or TCP/IP if it is used for PPPoE only.
N */
N#define NETIF_FLAG_ETHERNET     0x40U
N/** If set, the netif has IGMP capability.
N * Set by the netif driver in its init function. */
N#define NETIF_FLAG_IGMP         0x80U
N
N/** Function prototype for netif init functions. Set up flags and output/linkoutput
N * callback functions in this function.
N *
N * @param netif The netif to initialize
N */
Ntypedef err_t (*netif_init_fn)(struct netif *netif);
N/** Function prototype for netif->input functions. This function is saved as 'input'
N * callback function in the netif struct. Call it when a packet has been received.
N *
N * @param p The received packet, copied into a pbuf
N * @param inp The netif which received the packet
N */
Ntypedef err_t (*netif_input_fn)(struct pbuf *p, struct netif *inp);
N/** Function prototype for netif->output functions. Called by lwIP when a packet
N * shall be sent. For ethernet netif, set this to 'etharp_output' and set
N * 'linkoutput'.
N *
N * @param netif The netif which shall send a packet
N * @param p The packet to send (p->payload points to IP header)
N * @param ipaddr The IP address to which the packet shall be sent
N */
Ntypedef err_t (*netif_output_fn)(struct netif *netif, struct pbuf *p,
N       ip_addr_t *ipaddr);
N/** Function prototype for netif->linkoutput functions. Only used for ethernet
N * netifs. This function is called by ARP when a packet shall be sent.
N *
N * @param netif The netif which shall send a packet
N * @param p The packet to send (raw ethernet packet)
N */
Ntypedef err_t (*netif_linkoutput_fn)(struct netif *netif, struct pbuf *p);
N/** Function prototype for netif status- or link-callback functions. */
Ntypedef void (*netif_status_callback_fn)(struct netif *netif);
N/** Function prototype for netif igmp_mac_filter functions */
Ntypedef err_t (*netif_igmp_mac_filter_fn)(struct netif *netif,
N       ip_addr_t *group, u8_t action);
N
N/** Generic data structure used for all lwIP network interfaces.
N *  The following fields should be filled in by the initialization
N *  function for the device driver: hwaddr_len, hwaddr[], mtu, flags */
Nstruct netif {
N  /** pointer to next in linked list */
N  struct netif *next;
N
N  /** IP address configuration in network byte order */
N  ip_addr_t ip_addr;
N  ip_addr_t netmask;
N  ip_addr_t gw;
N
N  /** This function is called by the network device driver
N   *  to pass a packet up the TCP/IP stack. */
N  netif_input_fn input;
N  /** This function is called by the IP module when it wants
N   *  to send a packet on the interface. This function typically
N   *  first resolves the hardware address, then sends the packet. */
N  netif_output_fn output;
N  /** This function is called by the ARP module when it wants
N   *  to send a packet on the interface. This function outputs
N   *  the pbuf as-is on the link medium. */
N  netif_linkoutput_fn linkoutput;
N#if LWIP_NETIF_STATUS_CALLBACK
X#if 0
S  /** This function is called when the netif state is set to up or down
S   */
S  netif_status_callback_fn status_callback;
N#endif /* LWIP_NETIF_STATUS_CALLBACK */
N#if LWIP_NETIF_LINK_CALLBACK
X#if 1
N  /** This function is called when the netif link is set to up or down
N   */
N  netif_status_callback_fn link_callback;
N#endif /* LWIP_NETIF_LINK_CALLBACK */
N#if LWIP_NETIF_REMOVE_CALLBACK
X#if 0
S  /** This function is called when the netif has been removed */
S  netif_status_callback_fn remove_callback;
N#endif /* LWIP_NETIF_REMOVE_CALLBACK */
N  /** This field can be set by the device driver and could point
N   *  to state information for the device. */
N  void *state;
N#if LWIP_DHCP
X#if 1
N  /** the DHCP client state information for this netif */
N  struct dhcp *dhcp;
N#endif /* LWIP_DHCP */
N#if LWIP_AUTOIP
X#if 0
S  /** the AutoIP client state information for this netif */
S  struct autoip *autoip;
N#endif
N#if LWIP_NETIF_HOSTNAME
X#if 0
S  /* the hostname for this netif, NULL is a valid value */
S  char*  hostname;
N#endif /* LWIP_NETIF_HOSTNAME */
N  /** maximum transfer unit (in bytes) */
N  u16_t mtu;
N  /** number of bytes used in hwaddr */
N  u8_t hwaddr_len;
N  /** link level hardware address of this interface */
N  u8_t hwaddr[NETIF_MAX_HWADDR_LEN];
X  u8_t hwaddr[6U];
N  /** flags (see NETIF_FLAG_ above) */
N  u8_t flags;
N  /** descriptive abbreviation */
N  char name[2];
N  /** number of this interface */
N  u8_t num;
N#if LWIP_SNMP
X#if 0
S  /** link type (from "snmp_ifType" enum from snmp.h) */
S  u8_t link_type;
S  /** (estimate) link speed */
S  u32_t link_speed;
S  /** timestamp at last change made (up/down) */
S  u32_t ts;
S  /** counters */
S  u32_t ifinoctets;
S  u32_t ifinucastpkts;
S  u32_t ifinnucastpkts;
S  u32_t ifindiscards;
S  u32_t ifoutoctets;
S  u32_t ifoutucastpkts;
S  u32_t ifoutnucastpkts;
S  u32_t ifoutdiscards;
N#endif /* LWIP_SNMP */
N#if LWIP_IGMP
X#if 0
S  /** This function could be called to add or delete a entry in the multicast
S      filter table of the ethernet MAC.*/
S  netif_igmp_mac_filter_fn igmp_mac_filter;
N#endif /* LWIP_IGMP */
N#if LWIP_NETIF_HWADDRHINT
X#if 0
S  u8_t *addr_hint;
N#endif /* LWIP_NETIF_HWADDRHINT */
N#if ENABLE_LOOPBACK
X#if (0 || 0)
S  /* List of packets to be queued for ourselves. */
S  struct pbuf *loop_first;
S  struct pbuf *loop_last;
S#if LWIP_LOOPBACK_MAX_PBUFS
S  u16_t loop_cnt_current;
S#endif /* LWIP_LOOPBACK_MAX_PBUFS */
N#endif /* ENABLE_LOOPBACK */
N};
N
N#if LWIP_SNMP
X#if 0
S#define NETIF_INIT_SNMP(netif, type, speed) \
S  /* use "snmp_ifType" enum from snmp.h for "type", snmp_ifType_ethernet_csmacd by example */ \
S  (netif)->link_type = (type);    \
S  /* your link speed here (units: bits per second) */  \
S  (netif)->link_speed = (speed);  \
S  (netif)->ts = 0;              \
S  (netif)->ifinoctets = 0;      \
S  (netif)->ifinucastpkts = 0;   \
S  (netif)->ifinnucastpkts = 0;  \
S  (netif)->ifindiscards = 0;    \
S  (netif)->ifoutoctets = 0;     \
S  (netif)->ifoutucastpkts = 0;  \
S  (netif)->ifoutnucastpkts = 0; \
S  (netif)->ifoutdiscards = 0
X#define NETIF_INIT_SNMP(netif, type, speed)       (netif)->link_type = (type);           (netif)->link_speed = (speed);    (netif)->ts = 0;                (netif)->ifinoctets = 0;        (netif)->ifinucastpkts = 0;     (netif)->ifinnucastpkts = 0;    (netif)->ifindiscards = 0;      (netif)->ifoutoctets = 0;       (netif)->ifoutucastpkts = 0;    (netif)->ifoutnucastpkts = 0;   (netif)->ifoutdiscards = 0
N#else /* LWIP_SNMP */
N#define NETIF_INIT_SNMP(netif, type, speed)
N#endif /* LWIP_SNMP */
N
N
N/** The list of network interfaces. */
Nextern struct netif *netif_list;
N/** The default network interface. */
Nextern struct netif *netif_default;
N
Nvoid netif_init(void);
N
Nstruct netif *netif_add(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
N      ip_addr_t *gw, void *state, netif_init_fn init, netif_input_fn input);
N
Nvoid
Nnetif_set_addr(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
N      ip_addr_t *gw);
Nvoid netif_remove(struct netif * netif);
N
N/* Returns a network interface given its name. The name is of the form
N   "et0", where the first two letters are the "name" field in the
N   netif structure, and the digit is in the num field in the same
N   structure. */
Nstruct netif *netif_find(char *name);
N
Nvoid netif_set_default(struct netif *netif);
N
Nvoid netif_set_ipaddr(struct netif *netif, ip_addr_t *ipaddr);
Nvoid netif_set_netmask(struct netif *netif, ip_addr_t *netmask);
Nvoid netif_set_gw(struct netif *netif, ip_addr_t *gw);
N
Nvoid netif_set_up(struct netif *netif);
Nvoid netif_set_down(struct netif *netif);
N/** Ask if an interface is up */
N#define netif_is_up(netif) (((netif)->flags & NETIF_FLAG_UP) ? (u8_t)1 : (u8_t)0)
N
N#if LWIP_NETIF_STATUS_CALLBACK
X#if 0
Svoid netif_set_status_callback(struct netif *netif, netif_status_callback_fn status_callback);
N#endif /* LWIP_NETIF_STATUS_CALLBACK */
N#if LWIP_NETIF_REMOVE_CALLBACK
X#if 0
Svoid netif_set_remove_callback(struct netif *netif, netif_status_callback_fn remove_callback);
N#endif /* LWIP_NETIF_REMOVE_CALLBACK */
N
Nvoid netif_set_link_up(struct netif *netif);
Nvoid netif_set_link_down(struct netif *netif);
N/** Ask if a link is up */ 
N#define netif_is_link_up(netif) (((netif)->flags & NETIF_FLAG_LINK_UP) ? (u8_t)1 : (u8_t)0)
N
N#if LWIP_NETIF_LINK_CALLBACK
X#if 1
Nvoid netif_set_link_callback(struct netif *netif, netif_status_callback_fn link_callback);
N#endif /* LWIP_NETIF_LINK_CALLBACK */
N
N#if LWIP_NETIF_HOSTNAME
X#if 0
S#define netif_set_hostname(netif, name) do { if((netif) != NULL) { (netif)->hostname = name; }}while(0)
S#define netif_get_hostname(netif) (((netif) != NULL) ? ((netif)->hostname) : NULL)
N#endif /* LWIP_NETIF_HOSTNAME */
N
N#if LWIP_IGMP
X#if 0
S#define netif_set_igmp_mac_filter(netif, function) do { if((netif) != NULL) { (netif)->igmp_mac_filter = function; }}while(0)
S#define netif_get_igmp_mac_filter(netif) (((netif) != NULL) ? ((netif)->igmp_mac_filter) : NULL)
N#endif /* LWIP_IGMP */
N
N#if ENABLE_LOOPBACK
X#if (0 || 0)
Serr_t netif_loop_output(struct netif *netif, struct pbuf *p, ip_addr_t *dest_ip);
Svoid netif_poll(struct netif *netif);
S#if !LWIP_NETIF_LOOPBACK_MULTITHREADING
Svoid netif_poll_all(void);
S#endif /* !LWIP_NETIF_LOOPBACK_MULTITHREADING */
N#endif /* ENABLE_LOOPBACK */
N
N#if LWIP_NETIF_HWADDRHINT
X#if 0
S#define NETIF_SET_HWADDRHINT(netif, hint) ((netif)->addr_hint = (hint))
N#else /* LWIP_NETIF_HWADDRHINT */
N#define NETIF_SET_HWADDRHINT(netif, hint)
N#endif /* LWIP_NETIF_HWADDRHINT */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __LWIP_NETIF_H__ */
L 37 "..\..\Lwip\Bsp\LAN8742A\LAN8742A.h" 2
N
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* 站管理接口：SMI
N * 站管理接口(SMI)允许应用程序通过2条线：时钟(MDC)和数据线(MDIO)访问任意PHY寄存器。
N * 该接口支持访问多达32个PHY。应用程序可以从32个PHY中选择一个PHY，然后从任意PHY包
N * 含的32个寄存器中选择一个寄存器，发送控制数据或接收状态信息。任意给定时间内只能
N * 对一个PHY中的一个寄存器进行寻址。在MAC对PHY进行读写操作的时候，应用程序不能修改
N * MII的地址寄存器和MII的数据寄存器。在此期间对MII地址寄存器或MII数据寄存器执行的
N * 写操作将会被忽略。
N * 现在我们使用的LAN8742A芯片对应其中一个PHY，占用了其中一个地址
N * 关于这个地址确定方法可以参考LAN8742A手册“3.7.1 PHYAD[0]: PHY Address 
N * Configuration”说明。
N */
N#define ETHERNET_PHY_ADDRESS       0x00 /* Relative to STM324xG-EVAL Board */
N#define GET_PHY_LINK_STATUS()		(ETH_ReadPHYRegister(ETHERNET_PHY_ADDRESS, PHY_BSR) & 0x00000004)
N/*
N	ETH_MDIO -------------------------> PA2
N	ETH_MDC --------------------------> PC1
N	ETH_MII_RX_CLK/ETH_RMII_REF_CLK---> PA1
N	ETH_MII_RX_DV/ETH_RMII_CRS_DV ----> PA7
N	ETH_MII_RXD0/ETH_RMII_RXD0 -------> PC4
N	ETH_MII_RXD1/ETH_RMII_RXD1 -------> PC5
N	ETH_MII_TX_EN/ETH_RMII_TX_EN -----> PG11
N	ETH_MII_TXD0/ETH_RMII_TXD0 -------> PG13
N	ETH_MII_TXD1/ETH_RMII_TXD1 -------> PG14
N																						*/
N/* ETH_MDIO */
N#define ETH_MDIO_GPIO_CLK               RCC_AHB1Periph_GPIOA
N#define ETH_MDIO_PORT                   GPIOA
N#define ETH_MDIO_PIN                    GPIO_Pin_2
N#define ETH_MDIO_AF                     GPIO_AF_ETH
N#define ETH_MDIO_SOURCE                 GPIO_PinSource2
N
N/* ETH_MDC */
N#define ETH_MDC_GPIO_CLK                RCC_AHB1Periph_GPIOC
N#define ETH_MDC_PORT                    GPIOC
N#define ETH_MDC_PIN                     GPIO_Pin_1
N#define ETH_MDC_AF                      GPIO_AF_ETH
N#define ETH_MDC_SOURCE                  GPIO_PinSource1
N
N/* ETH_RMII_REF_CLK */
N#define ETH_RMII_REF_CLK_GPIO_CLK       RCC_AHB1Periph_GPIOA
N#define ETH_RMII_REF_CLK_PORT           GPIOA
N#define ETH_RMII_REF_CLK_PIN            GPIO_Pin_1
N#define ETH_RMII_REF_CLK_AF             GPIO_AF_ETH
N#define ETH_RMII_REF_CLK_SOURCE         GPIO_PinSource1
N
N/* ETH_RMII_CRS_DV */
N#define ETH_RMII_CRS_DV_GPIO_CLK        RCC_AHB1Periph_GPIOA
N#define ETH_RMII_CRS_DV_PORT            GPIOA
N#define ETH_RMII_CRS_DV_PIN             GPIO_Pin_7
N#define ETH_RMII_CRS_DV_AF              GPIO_AF_ETH
N#define ETH_RMII_CRS_DV_SOURCE          GPIO_PinSource7
N
N/* ETH_RMII_RXD0 */
N#define ETH_RMII_RXD0_GPIO_CLK          RCC_AHB1Periph_GPIOC
N#define ETH_RMII_RXD0_PORT              GPIOC
N#define ETH_RMII_RXD0_PIN               GPIO_Pin_4
N#define ETH_RMII_RXD0_AF                GPIO_AF_ETH
N#define ETH_RMII_RXD0_SOURCE            GPIO_PinSource4
N
N/* ETH_RMII_RXD1 */
N#define ETH_RMII_RXD1_GPIO_CLK          RCC_AHB1Periph_GPIOC
N#define ETH_RMII_RXD1_PORT              GPIOC
N#define ETH_RMII_RXD1_PIN               GPIO_Pin_5
N#define ETH_RMII_RXD1_AF                GPIO_AF_ETH
N#define ETH_RMII_RXD1_SOURCE            GPIO_PinSource5
N
N/* ETH_RMII_TX_EN */
N#define ETH_RMII_TX_EN_GPIO_CLK         RCC_AHB1Periph_GPIOG
N#define ETH_RMII_TX_EN_PORT             GPIOG
N#define ETH_RMII_TX_EN_PIN              GPIO_Pin_11
N#define ETH_RMII_TX_EN_AF               GPIO_AF_ETH
N#define ETH_RMII_TX_EN_SOURCE           GPIO_PinSource11
N
N/* ETH_RMII_TXD0 */
N#define ETH_RMII_TXD0_GPIO_CLK          RCC_AHB1Periph_GPIOG
N#define ETH_RMII_TXD0_PORT              GPIOG
N#define ETH_RMII_TXD0_PIN               GPIO_Pin_13
N#define ETH_RMII_TXD0_AF                GPIO_AF_ETH
N#define ETH_RMII_TXD0_SOURCE            GPIO_PinSource13
N
N/* ETH_RMII_TXD1 */
N#define ETH_RMII_TXD1_GPIO_CLK          RCC_AHB1Periph_GPIOG
N#define ETH_RMII_TXD1_PORT              GPIOG
N#define ETH_RMII_TXD1_PIN               GPIO_Pin_14
N#define ETH_RMII_TXD1_AF                GPIO_AF_ETH
N#define ETH_RMII_TXD1_SOURCE            GPIO_PinSource14
N
N/* Ethernet Flags for EthStatus variable */   
N#define ETH_INIT_FLAG           0x01 /* Ethernet Init Flag */
N#define ETH_LINK_FLAG           0x10 /* Ethernet Link Flag */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid  ETH_BSP_Config(void);
Nvoid ETH_EXTERN_GetSpeedAndDuplex(uint32_t PHYAddress, ETH_InitTypeDef* ETH_InitStruct);
Nvoid ETH_link_callback(struct netif *netif);
Nvoid ETH_CheckLinkStatus(uint16_t PHYAddress);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F429_ETH_BSP_H */
N
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 64 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "stm32f4xx_adc.h"
N#include "misc.h"
N/*用户文件*/
N//Ecal
N#include "MyType.h"
L 1 "..\..\..\ZR60_v1.0_freeRTOS\MyType.h" 1
N/******************************************************
N浠跺锛	Mytype.h
N
N杩帮
N
NData			  Vasion			author
N2018/1/4		  V1.0			    liujian
N*******************************************************/
N#ifndef		MYTYPE_H
N#define		MYTYPE_H
N/*******************************************************
Ndescription锛include the header file
N*******************************************************/
N
N/*******************************************************
Ndescription锛macro definitions
N*******************************************************/
N/**********瀹寮冲涔*******/
N
Ntypedef	unsigned  char			    uint8;
Ntypedef	signed  char			      int8;
Ntypedef	unsigned  short			      uint16;
Ntypedef			      short			      int16;
Ntypedef	unsigned  long 		  uint32;
Ntypedef			      long 		  int32;
N
Ntypedef unsigned long long int  uint64;
N
Ntypedef signed char SC; 	
Ntypedef unsigned char UC;	
Ntypedef short SS;	
Ntypedef unsigned short US;	
Ntypedef long SL;	
Ntypedef unsigned long UL;
Ntypedef unsigned int UI;
Ntypedef signed int SI;
N
N/*******************************************************
Ndescription：Often use of macro definitions
N*******************************************************/
N/************表示开/关状态***************/
N#ifndef   STD_ON
N#define		STD_ON		  1
N#endif
N
N#ifndef   STD_OFF
N#define		STD_OFF		0
N#endif
N/***********表示电平的高/低**************/
N#ifndef   STD_HIGH
N#define		STD_HIGH		1
N#endif
N
N#ifndef   STD_LOW
N#define		STD_LOW		0
N#endif
N
N/***********表示有效/无效***************/
N#ifndef   STD_ACTIVE
N#define		STD_ACTIVE		  1
N#endif
N
N#ifndef   STD_INACTIVE
N#define		STD_INACTIVE		0
N#endif
N
N/***********表示真/假***************/
N#ifndef   STD_TRUE
N#define		STD_TRUE			1
N#endif
N
N#ifndef   STD_FALSE
N#define		STD_FALSE		0
N#endif
N
N/***********表示清0***************/
N#ifndef   STD_NULL
N#define		STD_NULL		0
N#endif
N
N/***********空指针***************/
N#ifndef   STD_NULL_PTR
N#define   STD_NULL_PTR   ((void*)0)
N#endif
N
N
N/**********瀹甯搁瀹涔*******/
N
N
N
N/***********瀹芥*********/
N
N/*******************************************************
Ndescription锛struct definitions
N*******************************************************/
N
N/*******************************************************
Ndescription锛typedef definitions
N*******************************************************/
N/*****struct definitions*****/
N
N/******enum definitions******/
N
N/******union definitions*****/
N
N/*******************************************************
Ndescription锛variable External declaration
N*******************************************************/
N
N/*******************************************************
Ndescription锛function External declaration
N*******************************************************/
N
N#endif
L 69 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "Mcu_Init.h"
L 1 "..\..\Ecal\Mcu_Init\Mcu_Init.h" 1
N/******************************************************
N浠跺锛	Mcu_Init.h
N
N杩帮
N
NData			  Vasion			author
N2018/1/4		  V1.0			    liujian
N*******************************************************/
N#ifndef		MCU_INIT_H
N#define		MCU_INIT_H
N/*******************************************************
Ndescription锛include the header file
N*******************************************************/
N#include "Include.h"
N
N/*******************************************************
Ndescription锛macro definitions
N*******************************************************/
N/**********瀹寮冲涔*******/
N
N
N/**********瀹甯搁瀹涔*******/
N
N
N
N/***********瀹芥*********/
N
N/*******************************************************
Ndescription锛struct definitions
N*******************************************************/
N
N/*******************************************************
Ndescription锛typedef definitions
N*******************************************************/
N/*****struct definitions*****/
N
N/******enum definitions******/
N
N/******union definitions*****/
N
N/*******************************************************
Ndescription锛variable External declaration
N*******************************************************/
Nextern u8 volatile machine_type;  //机器类型
N
N/*******************************************************
Ndescription锛function External declaration
N*******************************************************/
Nextern void Mcu_Init(void);
N
N
N#endif
L 70 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "BtnFltr.h"
L 1 "..\..\Ecal\BtnFltr\BtnFltr.h" 1
N/******************************************************
N文件名：	BtnFltr
N
N描述：		
N
NData			  Vasion			author
N2017/7/22		   V1.0			    liujian
N*******************************************************/
N#ifndef		BTNFLTR_H
N#define		BTNFLTR_H
N/*******************************************************
Ndescription： include the header file
N*******************************************************/
N#include	"BtnFltr_Cfg.h"
L 1 "..\..\Ecal\BtnFltr\BtnFltr_Cfg.h" 1
N/******************************************************
N文件名：	BtnFltr
N
N描述：		 
N
NData			  Vasion			author
N2017/7/22		   V1.0			    liujian      
N*******************************************************/
N#ifndef		BTNFLTR_CFG_H
N#define		BTNFLTR_CFG_H
N/*******************************************************
Ndescription： include the header file
N*******************************************************/
N#include "Include.h"
N
N
N/*******************************************************
Ndescription： macro definitions
N*******************************************************/
N/**********宏开关定义*********/
N
N
N/**********宏常量定义*********/
N#define  BTNFLTR_BTN_NUM     3U/*按键数量*/
N
N
N
N#define  BTNFLTR_SHORTTIME   4U/*按键短按时间门限*/
N#define  BTNFLTR_LONGTIME    400U/*按键长按时间门限*/
N/***********宏函数***********/
N
N/*******************************************************
Ndescription： struct definitions
N*******************************************************/
N
N/*******************************************************
Ndescription： typedef definitions
N*******************************************************/
N/*****struct definitions*****/
Ntypedef struct
N{
N	uint8 e_u_BtnOldSt;	  /*按键前一次状态*/
N	uint8 e_u_BtnShrtSt;  /*按键短按触发状态*/
N	uint8 e_u_BtnShrtValid;  /*按键短按触发有效性*/
N	uint8 e_u_BtnLngSt;   /*按键长按触发状态*/
N	uint8 e_u_BtnLngValid;  /*按键长按触发有效性*/
N	uint8 e_u_BtnStuckSt; /*按键卡键状态*/
N	uint16 e_w_BtnFltrCnt;/*按键状态滤波计时器*/	
N}BtnFltrStruct;/*按键参数结构体*/
N
N
N/******enum definitions******/
Ntypedef enum
N{
N	Key_card_set = 0U,	  /*母卡设置*/
N	//Key_PasswodAuth,	  /*密码验证*/
N	Key_Unlock,	  /*门内开锁*/
N	Key_Alarm	  /*消防报警*/
N}BtnFltrEnum;
N
N/******union definitions*****/
N
N/*******************************************************
Ndescription： variable External declaration
N*******************************************************/
Nextern const uint8  CaBtnFltr_u_BtnActive[BTNFLTR_BTN_NUM];
Xextern const uint8  CaBtnFltr_u_BtnActive[3U];
Nextern const uint16 CaBtnFltr_w_BtnStuckThre[BTNFLTR_BTN_NUM];
Xextern const uint16 CaBtnFltr_w_BtnStuckThre[3U];
N
N
N/*******************************************************
Ndescription： function External declaration
N*******************************************************/
Nextern uint8 GetBtnFltrCfg_u_BtnRTSt(uint8 LeBtnFltr_u_Index);
N    
N#endif
N
L 15 "..\..\Ecal\BtnFltr\BtnFltr.h" 2
N
N/*******************************************************
Ndescription： macro definitions
N*******************************************************/
N/**********宏开关定义*********/
N
N
N/**********宏常量定义*********/
N
N
N/***********宏函数***********/
N
N/*******************************************************
Ndescription： struct definitions
N*******************************************************/
N
N/*******************************************************
Ndescription： typedef definitions
N*******************************************************/
N/*****struct definitions*****/
N
N/******enum definitions******/
N
N/******union definitions*****/
N
N/*******************************************************
Ndescription： variable External declaration
N*******************************************************/
N
N/*******************************************************
Ndescription： function External declaration
N*******************************************************/
Nextern void InitBtnFltr_Parameter(void);
Nextern void TskBtnFltr_MainFunction(void);
Nextern uint8 GetBtnFltr_u_BtnShrtValid(uint8 LeBtnFltr_u_Index);
Nextern uint8 GetBtnFltr_u_BtnShrtSt(uint8 LeBtnFltr_u_Index);
Nextern uint8 GetBtnFltr_u_BtnLngValid(uint8 LeBtnFltr_u_Index);
Nextern uint8 GetBtnFltr_u_BtnLngSt(uint8 LeBtnFltr_u_Index);
Nextern uint8 GetBtnFltr_u_BtnStuckSt(uint8 LeBtnFltr_u_Index);
Nextern void ClrBtnFltr_BtnLngValid(uint8 LeBtnFltr_u_Index);
Nextern void ClrBtnFltr_BtnShrtValid(uint8 LeBtnFltr_u_Index);
N
N#endif
L 71 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "UartCmn.h"
L 1 "..\..\Ecal\UartComn\UartCmn.h" 1
N/******************************************************
N文件名：	UartCmn
N
N描述：	半双工串口通信	
N
NData			  Vasion			author
N2018/04/1		  V1.0			    liujian
N*******************************************************/
N#ifndef		_UARTCMN_H
N#define		_UARTCMN_H
N/*******************************************************
Ndescription： include the header file
N*******************************************************/
N#include "Include.h"
N
N/*******************************************************
Ndescription： macro definitions
N*******************************************************/
N/**********宏开关定义*********/
N
N/**********宏常量定义*********/
N/*接收宏定义*/
N/*TX522B协议帧*/
N#define   UARTCMN_RX_HEADER    	    	0x20/*接收报文头起始符*/
N#define   UARTCMN_RX_PCKTHEAD_LNG       1U/*报文头长度（单位：字节）*/
N
N#define   UARTCMN_RX_PCKTHEAD_SEQNR     1U/*报文号长度（单位：字节）*/
N#define   UARTCMN_RX_PCKTHEAD_CMD     	1U/*报文命令字（单位：字节）*/
N#define   UARTCMN_RX_DATALNG_LNG        1U/*有效数据长度表示字节:无，配置0*/
N#define   UARTCMN_RX_PCKTDATA_LNG       56U/*报文有效数据最大长度*/
N#define   UARTCMN_RX_CHECK_LNG          1U/*报文校验字节长度*/
N#define   UARTCMN_RX_ETX_LNG            1U/*报文结束字节长度*/
N#define   UARTCMN_RX_ETC    	    	0x03/*接收报文终止符*/
N
N
N#define   UARTCMN_RX_SEQNR_STRTBYTE		UARTCMN_RX_PCKTHEAD_LNG 
N#define   UARTCMN_RX_DATALNG_STRTBYTE	(UARTCMN_RX_PCKTHEAD_LNG + UARTCMN_RX_PCKTHEAD_SEQNR + UARTCMN_RX_PCKTHEAD_CMD)/*报文有效数据长度表示字节开始字节*/
N#define   UARTCMN_RX_DATA_STRTBYTE      (UARTCMN_RX_PCKTHEAD_LNG + UARTCMN_RX_PCKTHEAD_SEQNR + UARTCMN_RX_PCKTHEAD_CMD + UARTCMN_RX_DATALNG_LNG)/*报文有效数据开始字节*/
N#define   UARTCMN_RX_CHCK_STRTBYTE      (UARTCMN_RX_PCKTHEAD_LNG + UARTCMN_RX_PCKTHEAD_SEQNR + UARTCMN_RX_PCKTHEAD_CMD + UARTCMN_RX_DATALNG_LNG + UARTCMN_RX_PCKTDATA_LNG)     /*报文校验字节起始位*/
N#define   UARTCMN_RX_SCLD_LNG           (UARTCMN_RX_PCKTHEAD_SEQNR + UARTCMN_RX_PCKTHEAD_CMD +UARTCMN_RX_DATALNG_LNG + UARTCMN_RX_PCKTDATA_LNG)/*包号+命令+有效数据长度字节+有效数据*/
N#define   UARTCMN_RX_PCKT_LNG           (UARTCMN_RX_CHCK_STRTBYTE + UARTCMN_RX_CHECK_LNG + UARTCMN_RX_ETX_LNG)/*报文总长*/
N/*发送宏定义*/
N#define   UARTCMN_TX_HEADER    	    	0x20/*报文头起始符*/
N#define   UARTCMN_TX_ETC    	    	0x03/*报文终止符*/
N#define   UARTCMN_TX_PCKT_LNG           72U/*发送报文总长最大长度*/
N
N
N
N
N/*SCI通道设置*/
N
N
N
N
N
N/***********宏函数***********/
N#define	 UARTCMN_USART		USART3
N#define  DISABLE_TIEN       USART_ITConfig(UART3_USART, USART_IT_TXE, DISABLE)/* 禁止发送寄存器空中断 */
N#define  ENABLE_TIEN	 	USART_ITConfig(UART3_USART, USART_IT_TXE, ENABLE)/* 使能发送寄存器空中断 */	
N
N#define  DISABLE_TEN    	(UARTCMN_USART->CR1 &= (uint8_t)(~USART_Mode_Tx))/* 禁止发送 */
N#define  ENABLE_TEN		    (UARTCMN_USART->CR1 |= (uint8_t)USART_Mode_Tx) /* 允许发送 */
N
N#define	 ENABLE_RIEN    	USART_ITConfig(UART3_USART, USART_IT_RXNE, ENABLE)/* 使能接收中断请求 */
N#define	 DISABLE_RIEN		USART_ITConfig(UART3_USART, USART_IT_RXNE, DISABLE)/* 关闭接收中断请求 */
N
N#define	 ENABLE_REN			(UARTCMN_USART->CR1 |= (uint8_t)USART_Mode_Rx) /* 允许接收 */	
N#define  DISABLE_REN		(UARTCMN_USART->CR1 &= (uint8_t)(~USART_Mode_Rx)) /* 禁止接收 */
N
N#define UartCmn_GetFlagStatus(flag)   	USART_GetFlagStatus(UARTCMN_USART,flag)     
N#define UartCmn_ReceiveData8()			USART_ReceiveData(UARTCMN_USART)
N#define	UartCmn_SendData8(data)			USART_SendData(UARTCMN_USART,data) 
N
N#define UARTCMN_FLAG_OE					USART_FLAG_ORE//帧错误标志
N#define	UARTCMN_FLAG_FE					USART_FLAG_FE//帧溢出标志
N#define	UARTCMN_FLAG_RXNE				USART_FLAG_RXNE//接收寄存器非空标志
N#define	UARTCMN_FLAG_TXE				USART_FLAG_TXE//发送寄存器空
N#define	UARTCMN_IT_TC					USART_IT_TC//传输完成
N/*******************************************************
Ndescription： struct definitions
N*******************************************************/
N
N/*******************************************************
Ndescription： typedef definitions
N*******************************************************/
N/*****struct definitions*****/
Ntypedef struct 
N{		
N	unsigned char UartRxNm;/* 接收数据下标 */
N	unsigned char UartRXFlag;/* 接收完成标志 */ 
N	unsigned char RxBusyFlg;/* 报文接收忙标志 */
N	unsigned char UartHeaderFlag;/* 报头接收完成标志 */
N	unsigned char UartNewFlag;/* 接受到新数据标志 */
N	union
N	{
N		unsigned char UartPckt[UARTCMN_RX_PCKT_LNG];/* 报文总长：报文头+数据+校验+帧结束 */
X		unsigned char UartPckt[((1U + 1U + 1U + 1U + 56U) + 1U + 1U)]; 
N		struct
N		{
N			unsigned char UartHeader[UARTCMN_RX_PCKTHEAD_LNG];/* 接收报头 */
X			unsigned char UartHeader[1U]; 
N			unsigned char UartSeqnr[UARTCMN_RX_PCKTHEAD_SEQNR];/* 接收帧包号*/
X			unsigned char UartSeqnr[1U]; 
N			unsigned char UartCmd[UARTCMN_RX_PCKTHEAD_CMD];/* 接收帧命令*/
X			unsigned char UartCmd[1U]; 
N			unsigned char UartRxDataLng[UARTCMN_RX_DATALNG_LNG];/* 接收有效数据段长度表示*/
X			unsigned char UartRxDataLng[1U]; 
N			unsigned char UartRxData[UARTCMN_RX_PCKTDATA_LNG];/* 接收的有效数据段：按最大长度定义存储空间*/
X			unsigned char UartRxData[56U]; 
N			unsigned char UartCheck[UARTCMN_RX_CHECK_LNG];/* 接收检验字节 */
X			unsigned char UartCheck[1U]; 
N			unsigned char UartETX[UARTCMN_RX_ETX_LNG];/* 帧结束*/
X			unsigned char UartETX[1U]; 
N		}Pckt;
N	}UartRx;
N}Uart_Rx_Msg; /*报文接收结构体*/ 
N
Ntypedef struct
N{
N    uint8  ucTxData[UARTCMN_TX_PCKT_LNG];/* 发送报文缓冲 */
X    uint8  ucTxData[72U]; 
N    uint8  ucLength;/* 报文长度 */
N    uint8  ucTxCnt;/*发送计数*/
N	uint8  ucTxFlg;/*发送标志：1―有数据需要或正在发送；0――没有数据发送*/
N}Uart_TX_Msg;/*报文发送结构体*/
N
N
N/******enum definitions******/
N
N/******union definitions*****/
N
N/*******************************************************
Ndescription： variable External declaration
N*******************************************************/
Nextern uint8_t volatile RcvFlag;
Nextern uint8_t volatile blenum;
Nextern uint8_t volatile ble_flag;
Nextern uint8_t volatile set_time_flag;
Nextern char  timelist[15];
Nextern char BleValue[6];
Nextern uint8_t Se_u_MacAddr[12U];//mac地址
Nextern uint8_t volatile Se_u_BleMacFlg;//获取蓝牙mac标志
Nextern uint8_t volatile Se_u_PhoneNum[12U];//手机号
Nextern uint8_t volatile Se_u_PhoneNumFlg;//获取手机号标志
N/*******************************************************
Ndescription： function External declaration
N*******************************************************/
Nextern void  InitUartCmn_parameter(void);
Nextern void  UartCmn_Rx_Msg(void);
Nextern void  UartCmn_Tx_Msg(void);
Nextern void  SetUartCmn_TxMsg(uint8* LeUartCmn_u_TxData,uint8 LeUartCmn_u_Lng);
Nextern uint8 GetUartCmn_u_RxMsgRenew(void);
Nextern void  GetUartCmn_u_RxMsg(uint8* LeUartCmn_RxData);
Nextern uint8 GetUartCmn_u_TxIdle(void);
Nextern uint8 GetUartCmn_u_RxIdle(void);
Nextern void Uart_Send(uint8* Data,uint8 Length);
Nextern void Uart_PrintStr(uint8* Str);
N
N
Nextern void SetUartCmn_BluetoothTxMsg(char* LeUartCmn_u_TxData,uint8 LeUartCmn_u_Lng);
Nextern void UartCmn_Tx_BluetoothMsg(void);
Nextern void UartCmn_Rx_BleMsg(void);
N#endif 
L 72 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "MemIf.h"
L 1 "..\..\Ecal\MemIf\MemIf.h" 1
N/******************************************************
N浠跺锛	MemIf.h
N
N杩帮	
N
NData			  Vasion			author
N2018/1/13		  V1.0			    liujian
N*******************************************************/
N#ifndef		MEMIF_H
N#define		MEMIF_H
N/*******************************************************
Ndescription锛include the header file
N*******************************************************/
N#include "MemIf_cfg.h"
L 1 "..\..\Ecal\MemIf\MemIf_cfg.h" 1
N/******************************************************
N文件名：	MemIf_cfg.h
N
N描述）
N
NData			  Vasion			author
N2018/04/06		  V1.0			    liujian
N*******************************************************/
N#ifndef		MEMIF_CFG_H
N#define		MEMIF_CFG_H
N/*******************************************************
Ndescription?nclude the header file
N*******************************************************/
N#include "Include.h"
N
N/*******************************************************
Ndescription?acro definitions
N*******************************************************/
N/**********宏开关定e*******/
N
N
N/**********宏常量定e*******/
N/********************************************************/
N#define EEPROM_SEC0_START_ADDR       	0x000000//EEPROM的起始地址:W25Q128 sector0起始地址
N#define EEPROM_SEC1_START_ADDR       	0x001000//EEPROM的起始地址:W25Q128 sector1起始地址
N#define EEPROM_SEC2_START_ADDR       	0x002000//EEPROM的起始地址:W25Q128 sector2起始地址
N#define EEPROM_SEC3_START_ADDR       	0x015000//EEPROM的起始地址:W25Q128 sector3起始地址
N#define EEPROM_SEC4_START_ADDR       	0x024000//EEPROM的起始地址:W25Q128 sector4起始地址
N#define EEPROM_SEC5_START_ADDR       	0x005000//EEPROM的起始地址:W25Q128 sector5起始地址
N#define EEPROM_SEC6_START_ADDR       	0x014000//EEPROM的起始地址:W25Q128 sector6起始地址
N#define EEPROM_SEC7_START_ADDR       	0x023000//EEPROM的起始地址:W25Q128 sector7起始地址
N
N#define EEPROM_SEC10_START_ADDR       	0x00A000//EEPROM的起始地址:W25Q128 sector10起始地址
N#define EEPROM_SEC11_START_ADDR       	0x00B000//EEPROM的起始地址:W25Q128 sector11起始地址
N#define EEPROM_SEC12_START_ADDR       	0x00C000//EEPROM的起始地址:W25Q128 sector12起始地址
N#define EEPROM_SEC13_START_ADDR       	0x00D000//EEPROM的起始地址:W25Q128 sector13起始地址
N#define EEPROM_SEC14_START_ADDR       	0x00E000//EEPROM的起始地址:W25Q128 sector14起始地址
N#define EEPROM_SEC15_START_ADDR       	0x00F000//EEPROM的起始地址:W25Q128 sector15起始地址
N#define EEPROM_SEC16_START_ADDR       	0x010000//EEPROM的起始地址:W25Q128 sector16起始地址
N#define EEPROM_SEC17_START_ADDR       	0x011000//EEPROM的起始地址:W25Q128 sector17起始地址
N#define EEPROM_SEC18_START_ADDR       	0x012000//EEPROM的起始地址:W25Q128 sector18起始地址
N#define EEPROM_SEC19_START_ADDR       	0x013000//EEPROM的起始地址:W25Q128 sector19起始地址
N//#define EEPROM_SEC2_START_ADDR       	0x002000//EEPROM的起始地址:W25Q128 sector2起始地址
N/********************************************************/
N//#define EE_DEBUG
N
N#define EE_IDLE          	0U//空闲
N#define EE_ERASE          	1U//擦除
N#define EE_WR          		2U//写
N
N#define EE_VALID_FIELD_VALUE    0x55//数据有效时写入有效字段的值
N#define EE_CHECKSUM_OBJ_NUM    6U//校验和对象数
N
N#define EE_CARD_SET_OFFSET     	3U//卡片配置信息地址相对于EE起始地址偏移量(addr[0]写数据有效性标志；addr[1]addr[2]数据长度信息)
N#define EE_CARD_SET_ADDR       (EEPROM_SEC5_START_ADDR +EE_CARD_SET_OFFSET)//卡片配置信息数据段起始地址
N#define EE_CARD_SET_BACKUPONE  (EEPROM_SEC6_START_ADDR +EE_CARD_SET_OFFSET)//卡片配置信息数据段起始地址
N#define EE_CARD_SET_BACKUPTWO  (EEPROM_SEC7_START_ADDR +EE_CARD_SET_OFFSET)//卡片配置信息数据段起始地址
N
N#define EE_MAC_INFO_OFFSET     	3U//mac地址信息地址相对于EE起始地址偏移量(addr[0]写数据有效性标志；addr[1]addr[2]数据长度信息)
N#define EE_MAC_INFO_ADDR       (EEPROM_SEC1_START_ADDR +EE_MAC_INFO_OFFSET)//mac地址信息数据段起始地址
N#define EE_MAC_INFO_BACKUPONE  (EEPROM_SEC3_START_ADDR +EE_MAC_INFO_OFFSET)//mac地址信息数据段起始地址
N#define EE_MAC_INFO_BACKUPTWO  (EEPROM_SEC4_START_ADDR +EE_MAC_INFO_OFFSET)//mac地址信息数据段起始地址
N
N#define EE_BLIST_TIMESTAMP_PAGE_OFFSET     	3U//黑名单时间戳，页码信息地址相对于EE起始地址偏移量(addr[0]写数据有效性标志；addr[1]addr[2]数据长度信息)
N#define EE_BLIST_TIMESTAMP_PAGE_ADDR       (EEPROM_SEC2_START_ADDR +EE_BLIST_TIMESTAMP_PAGE_OFFSET)//黑名单时间戳，页码信息数据段起始地址
N
N#define EE_BLIST_NO1_OFFSET     	3U//黑名单卡号信息地址相对于EE起始地址偏移量(addr[0]写数据有效性标志；addr[1]addr[2]数据长度信息)
N#define EE_BLIST_NO1_ADDR       	(EEPROM_SEC10_START_ADDR +EE_BLIST_NO1_OFFSET)//黑名单卡号数据段起始地址
N#define EE_BLIST_NO2_OFFSET     	3U//黑名单卡号信息地址相对于EE起始地址偏移量(addr[0]写数据有效性标志；addr[1]addr[2]数据长度信息)
N#define EE_BLIST_NO2_ADDR       	(EEPROM_SEC11_START_ADDR +EE_BLIST_NO2_OFFSET)//黑名单卡号数据段起始地址
N#define EE_BLIST_NO3_OFFSET     	3U//黑名单卡号信息地址相对于EE起始地址偏移量(addr[0]写数据有效性标志；addr[1]addr[2]数据长度信息)
N#define EE_BLIST_NO3_ADDR       	(EEPROM_SEC12_START_ADDR +EE_BLIST_NO3_OFFSET)//黑名单卡号数据段起始地址
N#define EE_BLIST_NO4_OFFSET     	3U//黑名单卡号信息地址相对于EE起始地址偏移量(addr[0]写数据有效性标志；addr[1]addr[2]数据长度信息)
N#define EE_BLIST_NO4_ADDR       	(EEPROM_SEC13_START_ADDR +EE_BLIST_NO4_OFFSET)//黑名单卡号数据段起始地址
N#define EE_BLIST_NO5_OFFSET     	3U//黑名单卡号信息地址相对于EE起始地址偏移量(addr[0]写数据有效性标志；addr[1]addr[2]数据长度信息)
N#define EE_BLIST_NO5_ADDR       	(EEPROM_SEC14_START_ADDR +EE_BLIST_NO5_OFFSET)//黑名单卡号数据段起始地址
N#define EE_BLIST_NO6_OFFSET     	3U//黑名单卡号信息地址相对于EE起始地址偏移量(addr[0]写数据有效性标志；addr[1]addr[2]数据长度信息)
N#define EE_BLIST_NO6_ADDR       	(EEPROM_SEC15_START_ADDR +EE_BLIST_NO6_OFFSET)//黑名单卡号数据段起始地址
N#define EE_BLIST_NO7_OFFSET     	3U//黑名单卡号信息地址相对于EE起始地址偏移量(addr[0]写数据有效性标志；addr[1]addr[2]数据长度信息)
N#define EE_BLIST_NO7_ADDR       	(EEPROM_SEC16_START_ADDR +EE_BLIST_NO7_OFFSET)//黑名单卡号数据段起始地址
N#define EE_BLIST_NO8_OFFSET     	3U//黑名单卡号信息地址相对于EE起始地址偏移量(addr[0]写数据有效性标志；addr[1]addr[2]数据长度信息)
N#define EE_BLIST_NO8_ADDR       	(EEPROM_SEC17_START_ADDR +EE_BLIST_NO8_OFFSET)//黑名单卡号数据段起始地址
N#define EE_BLIST_NO9_OFFSET     	3U//黑名单卡号信息地址相对于EE起始地址偏移量(addr[0]写数据有效性标志；addr[1]addr[2]数据长度信息)
N#define EE_BLIST_NO9_ADDR       	(EEPROM_SEC18_START_ADDR +EE_BLIST_NO9_OFFSET)//黑名单卡号数据段起始地址
N#define EE_BLIST_NO10_OFFSET     	3U//黑名单卡号信息地址相对于EE起始地址偏移量(addr[0]写数据有效性标志；addr[1]addr[2]数据长度信息)
N#define EE_BLIST_NO10_ADDR       	(EEPROM_SEC19_START_ADDR +EE_BLIST_NO10_OFFSET)//黑名单卡号数据段起始地址
N
N
N/***********宏函*********/
N
N/*******************************************************
Ndescription?truct definitions
N*******************************************************/
N
N/*******************************************************
Ndescription?ypedef definitions
N*******************************************************/
N/*****struct definitions*****/
Ntypedef struct
N{
N	uint8  Space;/*访问的存储位置：片内或片外*/
N	uint32 SecAddr;/*扇区首地址*/	
N	uint32 DtAddr;/*有效数据首地址*/
N	//void*  Lng;/*分配的数据段长度*/
N	void*  Data;/*数据指针*/
N}EepromCfg_ConfStruct;
N
N/******enum definitions******/
Ntypedef enum 
N{
N	EepromCfg_CardInfo = 0U,/*母卡配置信息*/
N	EepromCfg_Blist_one, /*已注销卡号信息:黑名单1*/
N	EepromCfg_MacInfo, /*mac地址信息*/
N	EepromCfg_Blist_two, /*已注销卡号信息:黑名单2*/
N	EepromCfg_Blist_three, /*已注销卡号信息:黑名单3*/
N	EepromCfg_Blist_four, /*已注销卡号信息:黑名单4*/
N	EepromCfg_Blist_five, /*已注销卡号信息:黑名单5*/
N	EepromCfg_Blist_six, /*已注销卡号信息:黑名单6*/
N	EepromCfg_Blist_seven, /*已注销卡号信息:黑名单7*/
N	EepromCfg_Blist_eight, /*已注销卡号信息:黑名单8*/
N	EepromCfg_Blist_nine, /*已注销卡号信息:黑名单9*/
N	EepromCfg_Blist_ten, /*已注销卡号信息:黑名单10*/
N	EepromCfg_timestamp_page, /*黑名单时间戳、页码*/
N	EepromCfg_CardInfoBkUpOne,/*母卡配置信息,备份*/
N	EepromCfg_CardInfoBkUpTwo,/*母卡配置信息,备份*/
N	EepromCfg_MacInfoBkUpOne, /*mac地址信息,备份*/
N	EepromCfg_MacInfoBkUpTwo, /*mac地址信息,备份*/
N	EE_OBJECT_NUM
N}EepromCfg_StrgObject;
N
Ntypedef enum 
N{
N	EepromCfg_IntEE = 0U,/*片内EE*/
N	EepromCfg_ExtEE = 1U/*片外EE*/
N}EepromCfg_EE_Index;
N/******union definitions*****/
N
N
N
N
N/*******************************************************
Ndescription?ariable External declaration
N*******************************************************/
Nextern const EepromCfg_ConfStruct    CaEepromCfg_Conf[EE_OBJECT_NUM];
Nextern const uint8  CaEepromCfg_CheckSumObj[EE_CHECKSUM_OBJ_NUM];/*需要周期性校验flash中的数据正确性的数据对象*/
Xextern const uint8  CaEepromCfg_CheckSumObj[6U]; 
Nextern const uint8  CaEepromCfg_ObjDtLng[EE_CHECKSUM_OBJ_NUM];/*需要周期性校验flash中的数据正确性的数据对象数据长度*/
Xextern const uint8  CaEepromCfg_ObjDtLng[6U]; 
N/*******************************************************
Ndescription?unction External declaration
N*******************************************************/
Nextern uint8  MemIfCfg_WriteEE(uint32 Le_u_Addr,uint8* Le_u_Data,uint8 Le_u_Lng);
Nextern uint8  MemIfCfg_ReadEE(uint32 Le_u_Addr,uint8* Le_u_Data,uint8 Le_u_Lng);
Nextern void  MemIfCfg_FLASH_Unlock(void);
Nextern void  MemIfCfg_FLASH_Lock(void);
Nextern void  MemIfCfg_FLASH_ProgramByte(uint32 Address, uint8 Data);
Nextern uint8 MemIfCfg_FLASH_ReadByte(uint32 Le_u_Addr);
Nextern void MemIfCfg_FLASH_SectorErase(uint32 Le_u_Addr);
Nextern uint8 MemIfCfg_FLASH_IDLE(void);
N#endif
L 15 "..\..\Ecal\MemIf\MemIf.h" 2
N
N
N/*******************************************************
Ndescription锛macro definitions
N*******************************************************/
N/**********瀹寮冲涔********/
N
N/**********瀹甯搁瀹涔********/
N
N
N
N/***********瀹芥**********/
N
N/*******************************************************
Ndescription锛struct definitions
N*******************************************************/
N
N/*******************************************************
Ndescription锛typedef definitions
N*******************************************************/
N/*****struct definitions*****/
N
N/******enum definitions******/
N
N/******union definitions*****/
N
N/*******************************************************
Ndescription锛variable External declaration
N*******************************************************/
N
N/*******************************************************
Ndescription锛function External declaration
N*******************************************************/
Nextern void  MemIf_Init(void);
Nextern void  TskMemIf_MainFunction(void);
Nextern uint8 MemIf_ReadEE(uint8 Le_u_Object,uint8* Le_u_Data,uint16 Le_w_Lng);
Nextern uint8 MemIf_WriteEE(uint8 Le_u_Object,void* Le_u_Data,uint16 Le_w_Lng);
Nextern uint8 GetMemIf_u_EEVild(uint8 Object);
Nextern uint8 GetMemIf_u_Idle(void);
Nextern void SetMemIf_EEVild(uint8 Object);
Nextern uint8 GetMemIf_u_DtVild(uint8 Obj);
Nextern uint16 GetMemIf_w_DtLng(uint8 Obj);
Nextern void MemIf_Timer(void);
N#ifdef EE_DEBUG
Sextern void MemIf_TestEE(void);
N#endif
N#endif
L 73 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "./BListCache/BListCache.h"
L 1 "..\..\Ecal\./BListCache/BListCache.h" 1
N/******************************************************
N文件名：	BListCache
N
N描述：		
N
NData			  Vasion			author
N2017/7/22		   V1.0			    liujian
N*******************************************************/
N#ifndef		BLISTCACHE_H
N#define		BLISTCACHE_H
N/*******************************************************
Ndescription： include the header file
N*******************************************************/
N#include	"Include.h"
N
N/*******************************************************
Ndescription： macro definitions
N*******************************************************/
N/**********宏开关定义*********/
N
N
N/**********宏常量定义*********/
N#define BLISTCACHE_QUEUE_LNG  100U/*数据队列长,队列长设为一次拉取黑名单最大个数的2倍，防止短时间连续拉取2次黑名单时缓存队列溢出*/
N#define BLISTCACHE_DATA_LNG   4U/*数据长*/
N/***********宏函数***********/
N
N/*******************************************************
Ndescription： struct definitions
N*******************************************************/
N
N/*******************************************************
Ndescription： typedef definitions
N*******************************************************/
N/*****struct definitions*****/
Ntypedef struct
N{
N	uint8  e_u_NonEmptyFlg;	/*数据非空标志*/
N	uint8  e_u_Data[BLISTCACHE_DATA_LNG];/*数据*/
X	uint8  e_u_Data[4U]; 
N}BListCacheStruct;/*按键信号数据队列结构体*/
N
N
N/******enum definitions******/
N
N/******union definitions*****/
N
N/*******************************************************
Ndescription： variable External declaration
N*******************************************************/
N
N/*******************************************************
Ndescription： function External declaration
N*******************************************************/
Nextern void InitBListCache_Parameter(void);
Nextern void WrBListCache_BListQueue(const uint8* LeBListCache_u_data);
Nextern uint8 GetBListCache_u_BListValidity(void);
Nextern uint32 GetBListCache_dw_BlistData(void);
Nextern void ClrBListCache_Queue(void);
N
N#endif
L 74 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "./UnlockLogCache/UnlockLogCache.h"
L 1 "..\..\Ecal\./UnlockLogCache/UnlockLogCache.h" 1
N/******************************************************
N文件名：	UnlockLogCache
N
N描述：		
N
NData			  Vasion			author
N2017/7/22		   V1.0			    liujian
N*******************************************************/
N#ifndef		UNLOCKLOGCACHE_H
N#define		UNLOCKLOGCACHE_H
N/*******************************************************
Ndescription： include the header file
N*******************************************************/
N#include "stm32f4xx.h"
N#include "MyType.h"
N
N/*******************************************************
Ndescription： macro definitions
N*******************************************************/
N/**********宏开关定义*********/
N
N
N/**********宏常量定义*********/
N#define UnlockLogCache_QUEUE_LNG  100U/*数据队列长*/
N//#define UnlockLogCache_TIME_LNG  4U/*时间数据长*/
N#define UnlockLogCache_ID_LNG  32U/*开锁信息数据长*/
N//#define UnlockLogCache_EVENT_LNG  4U/*事件数据长*/
N/***********宏函数***********/
N
N/*******************************************************
Ndescription： struct definitions
N*******************************************************/
N
N/*******************************************************
Ndescription： typedef definitions
N*******************************************************/
N/*****struct definitions*****/
N/*
N0表示未知，1表示门卡开锁，2表示呼叫开锁，
N3表示密码开锁，4表示手机NFC开锁，5表示近距离wifi开锁，
N6表示近距离蓝牙开锁，7表示远距离开锁，8表示微信开锁，
N9表示临时密码开锁，10表示人脸识别开锁，11表示二维码开锁，
N12表示快照开锁，13身份证开锁，14声波,15门内开关,16消防警报
N*/
N/*
N刷卡：卡id ; 呼叫开锁：房号、管理员、手机号 ; 
N密码开锁：房号 ; NFC开锁：暂定 ; 近距离wifi：房间号，已弃用 ; 
N蓝牙开锁：手机号 ; 远距离开锁：手机号、中心机id ; 微信开锁：open_id ; 
N临时密码开锁：未知 ; 人脸识别：类似{"user_id":"0001_1024_666_18183037622","face_token":"c48a71f1fff887617cd4528b531cb4d9"} ; 
N二维码开锁: 楼栋号_房间号/未知 ; 快照开锁：楼栋号_房间号/手机号 ; 身份证开锁：身份证卡号
N*/
N#define UNLOCKLOGCACHE_UNKNOW   	0U
N#define UNLOCKLOGCACHE_CARD     	1U
N#define UNLOCKLOGCACHE_CALL   		2U
N#define UNLOCKLOGCACHE_PASSWORD   	3U
N#define UNLOCKLOGCACHE_NFC     		4U
N#define UNLOCKLOGCACHE_WIFI         5U
N#define UNLOCKLOGCACHE_BLE         	6U
N#define UNLOCKLOGCACHE_REMOTE         7U
N#define UNLOCKLOGCACHE_WECHAT         	8U
N#define UNLOCKLOGCACHE_TEMPPSWORD     	9U
N#define UNLOCKLOGCACHE_FACE         	10U
N#define UNLOCKLOGCACHE_TWODIME         	11U
N#define UNLOCKLOGCACHE_SNAP         	12U
N#define UNLOCKLOGCACHE_IDCARD         	13U
N#define UNLOCKLOGCACHE_DOORSWITCH       14U
N#define UNLOCKLOGCACHE_FIREALARM        15U
N#define UNLOCKLOGCACHE_SOUNDWAVE        16U
N
N
Ntypedef struct
N{
N	uint8  e_u_NonEmptyFlg;	/*数据非空标志*/
N	uint64_t  e_u_Time;    /*时间*/
N	char  e_u_ID[UnlockLogCache_ID_LNG];/*开锁信息*/
X	char  e_u_ID[32U]; 
N	uint8  e_u_Event;/*开锁方式*/
N}UnlockLogCacheStruct;/*按键信号数据队列结构体*/
N
N
N/******enum definitions******/
N
N/******union definitions*****/
N
N/*******************************************************
Ndescription： variable External declaration
N*******************************************************/
N
N/*******************************************************
Ndescription： function External declaration
N*******************************************************/
Nextern void InitUnlockLogCache_Parameter(void);
Nextern void WrUnlockLogCache_Queue(uint64_t* Time,char* Id,uint8 Event);
Nextern uint8 GetUnlockLogCache_u_LogAvild(void);
Nextern void GetUnlockLogCache_doorLog(UnlockLogCacheStruct* UnlockLog);
Nextern void ClrUnlockLogCache_Queue(void);
N
N#endif
L 75 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "tcp_client_ShortConnect.h"
L 1 "..\..\Lwip\App\tcp_client_ShortConnect.h" 1
N/**
N  ******************************************************************************
N  * @file    tcp_echoclient.h
N  * @author  MCD Application Team
N  * @version V1.1.0
N  * @date    31-July-2013 
N  * @brief   Header file for tcp_echoclient.c
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TCP_ECHOCLIENT_H__
N#define __TCP_ECHOCLIENT_H__
N#include "./ZR60_Ctrl/ZR60_Ctrl.h"
L 1 "..\..\APP\./ZR60_Ctrl/ZR60_Ctrl.h" 1
N/******************************************************
N文件名：	ZR60_Ctrl
N
N描述：		
N
NData			  Vasion			author
N2018/04/7		  V1.0			    liujian
N*******************************************************/
N#ifndef		_ZR60_CTRL_H
N#define		_ZR60_CTRL_H
N/*******************************************************
Ndescription： include the header file
N*******************************************************/
N#include "Include.h"
N#include "tcp_client_LngConnect.h"
L 1 "..\..\Lwip\App\tcp_client_LngConnect.h" 1
N/**
N  ******************************************************************************
N  * @file    tcp_client_LngConnect.h
N  * @author  MCD Application Team
N  * @version V1.1.0
N  * @date    31-July-2013 
N  * @brief   Header file for tcp_client_LngConnect.c
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TCP_CLIENT_H__
N#define __TCP_CLIENT_H__
N#include	"Include.h"
N#include	"netconf.h"
L 1 "..\..\Lwip\App\netconf.h" 1
N/**
N  ******************************************************************************
N  * @file    netconf.h
N  * @author  MCD Application Team
N  * @version V1.1.0
N  * @date    31-July-2013 
N  * @brief   This file contains all the functions prototypes for the netconf.c 
N  *          file.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __NETCONF_H
N#define __NETCONF_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N	 
N#include "stm32f4xx.h"
N/* Includes ------------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N#define DHCP_START                    1
N#define DHCP_WAIT_ADDRESS             2
N#define DHCP_ADDRESS_ASSIGNED         3
N#define DHCP_TIMEOUT                  4
N#define DHCP_LINK_DOWN                5
N
N#define USE_DHCP       /* enable DHCP, if disabled static address is used */
N
N/* Uncomment SERIAL_DEBUG to enables retarget of printf to  serial port (COM1 on STM32 evalboard)
N   for debug purpose */   
N#define SERIAL_DEBUG 
N
N#define DEST_IP_ADDR0               172
N#define DEST_IP_ADDR1               16
N#define DEST_IP_ADDR2                 1
N#define DEST_IP_ADDR3               179
N
N#define DEST_PORT                  6000
N
N#define UDP_SERVER_PORT            5000   /* define the UDP local connection port */
N#define UDP_CLIENT_PORT            6000   /* define the UDP remote connection port */
N
N/* MAC ADDRESS: MAC_ADDR0:MAC_ADDR1:MAC_ADDR2:MAC_ADDR3:MAC_ADDR4:MAC_ADDR5 */
N#define MAC_ADDR0                     18
N#define MAC_ADDR1                     0
N#define MAC_ADDR2                     0
N#define MAC_ADDR3                     0
N#define MAC_ADDR4                     0
N#define MAC_ADDR5                     1
N
N/*Static IP ADDRESS: IP_ADDR0.IP_ADDR1.IP_ADDR2.IP_ADDR3 */
N#define IP_ADDR0                    10
N#define IP_ADDR1                    0
N#define IP_ADDR2                    0
N#define IP_ADDR3                    6
N
N/*NETMASK*/
N#define NETMASK_ADDR0               255
N#define NETMASK_ADDR1               255
N#define NETMASK_ADDR2               255
N#define NETMASK_ADDR3                 0
N
N/*Gateway Address*/
N#define GW_ADDR0                    10
N#define GW_ADDR1                    0
N#define GW_ADDR2                    0
N#define GW_ADDR3                    1
N
N/**
N * @brief  Number of milliseconds when to check for link status from PHY
N */
N#ifndef LINK_TIMER_INTERVAL
N#define LINK_TIMER_INTERVAL        1000
N#endif
N
N/* MII and RMII mode selection, for STM324xG-EVAL Board(MB786) RevB ***********/
N#define RMII_MODE  // User have to provide the 50 MHz clock by soldering a 50 MHz
N                     // oscillator (ref SM7745HEV-50.0M or equivalent) on the U3
N                     // footprint located under CN3 and also removing jumper on JP5.
N                     // This oscillator is not provided with the board. 
N                     // For more details, please refer to STM3240G-EVAL evaluation
N                     // board User manual (UM1461).
N
N//#define MII_MODE
N
N/* Uncomment the define below to clock the PHY from external 25MHz crystal (only for MII mode) */
N#ifdef 	MII_MODE
S #define PHY_CLOCK_MCO
N#endif
N
Nextern uint32_t IPaddress;
Nextern __IO uint8_t DHCP_state;
Xextern volatile uint8_t DHCP_state;
N 
N/* STM324xG-EVAL jumpers setting
N    +==========================================================================================+
N    +  Jumper |       MII mode configuration            |      RMII mode configuration         +
N    +==========================================================================================+
N    +  JP5    | 2-3 provide 25MHz clock by MCO(PA8)     |  Not fitted                          +
N    +         | 1-2 provide 25MHz clock by ext. Crystal |                                      +
N    + -----------------------------------------------------------------------------------------+
N    +  JP6    |          2-3                            |  1-2                                 +
N    + -----------------------------------------------------------------------------------------+
N    +  JP8    |          Open                           |  Close                               +
N    +==========================================================================================+
N  */
N
N/* Exported constants --------------------------------------------------------*/	 
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid LwIP_Init(void);
Nvoid LwIP_Pkt_Handle(void);
Nvoid LwIP_Periodic_Handle(__IO uint64_t localtime);
Xvoid LwIP_Periodic_Handle(volatile uint64_t localtime);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __NETCONF_H */
N
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 33 "..\..\Lwip\App\tcp_client_LngConnect.h" 2
N#include "STM8_FM17550_iap.h"
L 1 "..\..\Lwip\App\STM8_FM17550_iap.h" 1
N/**
N  ******************************************************************************
N  * @file    STM8_FM17550_iap.h
N  * @author  MCD Application Team
N  * @version V1.1.0
N  * @date    31-July-2013 
N  * @brief   Header file for http_client_iap.c
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __HTTP_STM8_FM17550_IAP_H__
N#define __HTTP_STM8_FM17550_IAP_H__
N#include <stdio.h>
N#include <stdlib.h>
N#include <string.h>
N#include "MyType.h"
N#include "stm32f4xx_flash.h"
N#include "dnsAnalysis.h"
L 1 "..\..\Lwip\App\dnsAnalysis.h" 1
N/******************************************************
N文件名：	dnsAnalysis
N
N描述：		
N
NData			  Vasion			author
N2018/04/12		  V1.0			    liujian
N*******************************************************/
N#ifndef		_DNS_ANALYSIS_H
S#define		_DNS_ANALYSIS_H
S/*******************************************************
Sdescription： include the header file
S*******************************************************/
S#include "Include.h"
S
S/*******************************************************
Sdescription： macro definitions
S*******************************************************/
S/**********宏开关定义*********/
S
S/**********宏常量定义*********/
S#define DNS_ANALYSIS_TASK_PERIOD   5000U//大概30s
S
S
S#ifdef USE_DHCP
S#define DNS_DHCP_STATE    DHCP_state
S#else
S#define DNS_DHCP_STATE    DHCP_ADDRESS_ASSIGNED
S#endif
S/***********宏函数***********/
S
S
S/*******************************************************
Sdescription： struct definitions
S*******************************************************/
S
S/*******************************************************
Sdescription： typedef definitions
S*******************************************************/
S/*****struct definitions*****/
Stypedef struct
S{
S	char* name;
S}dnsAnalysis_Struct;
S
S/******enum definitions******/
Stypedef enum
S{
S	ShortConnect = 0U,	  /*短连接*/
S	LngConnect,	  /*长连接*/
S	ntp_one,	  /*ntp服务器*/
S	ntp_two,	  /*ntp服务器*/
S	ntp_three,	  /*ntp服务器*/
S	ntp_four,	  /*ntp服务器*/
S	ntp_five,	  /*ntp服务器*/
S	ntp_six,	  /*ntp服务器*/
S	http_download,	  /*http文件下载服务器*/
S	//ntp_eight,	  /*ntp服务器*/
S	domainNum
S}dnsAnalysis_Enum;
S/******union definitions*****/
S
S/*******************************************************
Sdescription： variable External declaration
S*******************************************************/
S
S
S
S/*******************************************************
Sdescription： function External declaration
S*******************************************************/
Sextern void InitdnsAnalysis_parameter(void);
Sextern void TskdnsAnalysis_MainFunction(void);
Sextern void GetdnsAnalysis_ipAddr(uint8 index, struct ip_addr *ipaddr);
Sextern uint8 GetdnsAnalysis_u_ipValidity(uint8 index);
Sextern void SetdnsAnalysis_ipUpdate(uint8 index);
N#endif 
L 37 "..\..\Lwip\App\STM8_FM17550_iap.h" 2
N/*Lwip库文件*/
N#include "lwip/init.h"
L 1 "..\..\Lwip\lwip-1.4.1\src\include\lwip/init.h" 1
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_INIT_H__
N#define __LWIP_INIT_H__
N
N#include "lwip/opt.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** X.x.x: Major version of the stack */
N#define LWIP_VERSION_MAJOR      1U
N/** x.X.x: Minor version of the stack */
N#define LWIP_VERSION_MINOR      4U
N/** x.x.X: Revision of the stack */
N#define LWIP_VERSION_REVISION   1U
N/** For release candidates, this is set to 1..254
N  * For official releases, this is set to 255 (LWIP_RC_RELEASE)
N  * For development versions (CVS), this is set to 0 (LWIP_RC_DEVELOPMENT) */
N#define LWIP_VERSION_RC         255U
N
N/** LWIP_VERSION_RC is set to LWIP_RC_RELEASE for official releases */
N#define LWIP_RC_RELEASE         255U
N/** LWIP_VERSION_RC is set to LWIP_RC_DEVELOPMENT for CVS versions */
N#define LWIP_RC_DEVELOPMENT     0U
N
N#define LWIP_VERSION_IS_RELEASE     (LWIP_VERSION_RC == LWIP_RC_RELEASE)
N#define LWIP_VERSION_IS_DEVELOPMENT (LWIP_VERSION_RC == LWIP_RC_DEVELOPMENT)
N#define LWIP_VERSION_IS_RC          ((LWIP_VERSION_RC != LWIP_RC_RELEASE) && (LWIP_VERSION_RC != LWIP_RC_DEVELOPMENT))
N
N/** Provides the version of the stack */
N#define LWIP_VERSION   (LWIP_VERSION_MAJOR << 24   | LWIP_VERSION_MINOR << 16 | \
N                        LWIP_VERSION_REVISION << 8 | LWIP_VERSION_RC)
X#define LWIP_VERSION   (LWIP_VERSION_MAJOR << 24   | LWIP_VERSION_MINOR << 16 |                         LWIP_VERSION_REVISION << 8 | LWIP_VERSION_RC)
N
N/* Modules initialization */
Nvoid lwip_init(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __LWIP_INIT_H__ */
L 39 "..\..\Lwip\App\STM8_FM17550_iap.h" 2
N#include "lwip/tcp.h"
L 1 "..\..\Lwip\lwip-1.4.1\src\include\lwip/tcp.h" 1
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_TCP_H__
N#define __LWIP_TCP_H__
N
N#include "lwip/opt.h"
N
N#if LWIP_TCP /* don't build if not configured for use in lwipopts.h */
X#if 1  
N
N#include "lwip/mem.h"
L 1 "..\..\Lwip\lwip-1.4.1\src\include\lwip/mem.h" 1
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_MEM_H__
N#define __LWIP_MEM_H__
N
N#include "lwip/opt.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#if MEM_LIBC_MALLOC
X#if 0
S
S#include <stddef.h> /* for size_t */
S
Stypedef size_t mem_size_t;
S#define MEM_SIZE_F SZT_F
S
S/* aliases for C library malloc() */
S#define mem_init()
S/* in case C library malloc() needs extra protection,
S * allow these defines to be overridden.
S */
S#ifndef mem_free
S#define mem_free free
S#endif
S#ifndef mem_malloc
S#define mem_malloc malloc
S#endif
S#ifndef mem_calloc
S#define mem_calloc calloc
S#endif
S/* Since there is no C library allocation function to shrink memory without
S   moving it, define this to nothing. */
S#ifndef mem_trim
S#define mem_trim(mem, size) (mem)
S#endif
N#else /* MEM_LIBC_MALLOC */
N
N/* MEM_SIZE would have to be aligned, but using 64000 here instead of
N * 65535 leaves some room for alignment...
N */
N#if MEM_SIZE > 64000L
X#if (20*1024) > 64000L
Stypedef u32_t mem_size_t;
S#define MEM_SIZE_F U32_F
N#else
Ntypedef u16_t mem_size_t;
N#define MEM_SIZE_F U16_F
N#endif /* MEM_SIZE > 64000 */
N
N#if MEM_USE_POOLS
X#if 0
S/** mem_init is not used when using pools instead of a heap */
S#define mem_init()
S/** mem_trim is not used when using pools instead of a heap:
S    we can't free part of a pool element and don't want to copy the rest */
S#define mem_trim(mem, size) (mem)
N#else /* MEM_USE_POOLS */
N/* lwIP alternative malloc */
Nvoid  mem_init(void);
Nvoid *mem_trim(void *mem, mem_size_t size);
N#endif /* MEM_USE_POOLS */
Nvoid *mem_malloc(mem_size_t size);
Nvoid *mem_calloc(mem_size_t count, mem_size_t size);
Nvoid  mem_free(void *mem);
N#endif /* MEM_LIBC_MALLOC */
N
N/** Calculate memory size for an aligned buffer - returns the next highest
N * multiple of MEM_ALIGNMENT (e.g. LWIP_MEM_ALIGN_SIZE(3) and
N * LWIP_MEM_ALIGN_SIZE(4) will both yield 4 for MEM_ALIGNMENT == 4).
N */
N#ifndef LWIP_MEM_ALIGN_SIZE
N#define LWIP_MEM_ALIGN_SIZE(size) (((size) + MEM_ALIGNMENT - 1) & ~(MEM_ALIGNMENT-1))
N#endif
N
N/** Calculate safe memory size for an aligned buffer when using an unaligned
N * type as storage. This includes a safety-margin on (MEM_ALIGNMENT - 1) at the
N * start (e.g. if buffer is u8_t[] and actual data will be u32_t*)
N */
N#ifndef LWIP_MEM_ALIGN_BUFFER
N#define LWIP_MEM_ALIGN_BUFFER(size) (((size) + MEM_ALIGNMENT - 1))
N#endif
N
N/** Align a memory pointer to the alignment defined by MEM_ALIGNMENT
N * so that ADDR % MEM_ALIGNMENT == 0
N */
N#ifndef LWIP_MEM_ALIGN
N#define LWIP_MEM_ALIGN(addr) ((void *)(((mem_ptr_t)(addr) + MEM_ALIGNMENT - 1) & ~(mem_ptr_t)(MEM_ALIGNMENT-1)))
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __LWIP_MEM_H__ */
L 40 "..\..\Lwip\lwip-1.4.1\src\include\lwip/tcp.h" 2
N#include "lwip/pbuf.h"
N#include "lwip/ip.h"
L 1 "..\..\Lwip\lwip-1.4.1\src\include\ipv4\lwip/ip.h" 1
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_IP_H__
N#define __LWIP_IP_H__
N
N#include "lwip/opt.h"
N
N#include "lwip/def.h"
N#include "lwip/pbuf.h"
N#include "lwip/ip_addr.h"
N#include "lwip/err.h"
N#include "lwip/netif.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** Currently, the function ip_output_if_opt() is only used with IGMP */
N#define IP_OPTIONS_SEND   LWIP_IGMP
N
N#define IP_HLEN 20
N
N#define IP_PROTO_ICMP    1
N#define IP_PROTO_IGMP    2
N#define IP_PROTO_UDP     17
N#define IP_PROTO_UDPLITE 136
N#define IP_PROTO_TCP     6
N
N/* This is passed as the destination address to ip_output_if (not
N   to ip_output), meaning that an IP header already is constructed
N   in the pbuf. This is used when TCP retransmits. */
N#ifdef IP_HDRINCL
S#undef IP_HDRINCL
N#endif /* IP_HDRINCL */
N#define IP_HDRINCL  NULL
N
N#if LWIP_NETIF_HWADDRHINT
X#if 0
S#define IP_PCB_ADDRHINT ;u8_t addr_hint
N#else
N#define IP_PCB_ADDRHINT
N#endif /* LWIP_NETIF_HWADDRHINT */
N
N/* This is the common part of all PCB types. It needs to be at the
N   beginning of a PCB type definition. It is located here so that
N   changes to this common part are made in one location instead of
N   having to change all PCB structs. */
N#define IP_PCB \
N  /* ip addresses in network byte order */ \
N  ip_addr_t local_ip; \
N  ip_addr_t remote_ip; \
N   /* Socket options */  \
N  u8_t so_options;      \
N   /* Type Of Service */ \
N  u8_t tos;              \
N  /* Time To Live */     \
N  u8_t ttl               \
N  /* link layer address resolution hint */ \
N  IP_PCB_ADDRHINT
X#define IP_PCB       ip_addr_t local_ip;   ip_addr_t remote_ip;         u8_t so_options;             u8_t tos;                        u8_t ttl                     IP_PCB_ADDRHINT
N
Nstruct ip_pcb {
N/* Common members of all PCB types */
N  IP_PCB;
X  ip_addr_t local_ip; ip_addr_t remote_ip; u8_t so_options; u8_t tos; u8_t ttl ;
N};
N
N/*
N * Option flags per-socket. These are the same like SO_XXX.
N */
N/*#define SOF_DEBUG       0x01U     Unimplemented: turn on debugging info recording */
N#define SOF_ACCEPTCONN    0x02U  /* socket has had listen() */
N#define SOF_REUSEADDR     0x04U  /* allow local address reuse */
N#define SOF_KEEPALIVE     0x08U  /* keep connections alive */
N/*#define SOF_DONTROUTE   0x10U     Unimplemented: just use interface addresses */
N#define SOF_BROADCAST     0x20U  /* permit to send and to receive broadcast messages (see IP_SOF_BROADCAST option) */
N/*#define SOF_USELOOPBACK 0x40U     Unimplemented: bypass hardware when possible */
N#define SOF_LINGER        0x80U  /* linger on close if data present */
N/*#define SOF_OOBINLINE   0x0100U   Unimplemented: leave received OOB data in line */
N/*#define SOF_REUSEPORT   0x0200U   Unimplemented: allow local address & port reuse */
N
N/* These flags are inherited (e.g. from a listen-pcb to a connection-pcb): */
N#define SOF_INHERITED   (SOF_REUSEADDR|SOF_KEEPALIVE|SOF_LINGER/*|SOF_DEBUG|SOF_DONTROUTE|SOF_OOBINLINE*/)
N
N
N#ifdef PACK_STRUCT_USE_INCLUDES
S#  include "arch/bpstruct.h"
N#endif
NPACK_STRUCT_BEGIN
X__packed
Nstruct ip_hdr {
N  /* version / header length */
N  PACK_STRUCT_FIELD(u8_t _v_hl);
X  u8_t _v_hl;
N  /* type of service */
N  PACK_STRUCT_FIELD(u8_t _tos);
X  u8_t _tos;
N  /* total length */
N  PACK_STRUCT_FIELD(u16_t _len);
X  u16_t _len;
N  /* identification */
N  PACK_STRUCT_FIELD(u16_t _id);
X  u16_t _id;
N  /* fragment offset field */
N  PACK_STRUCT_FIELD(u16_t _offset);
X  u16_t _offset;
N#define IP_RF 0x8000U        /* reserved fragment flag */
N#define IP_DF 0x4000U        /* dont fragment flag */
N#define IP_MF 0x2000U        /* more fragments flag */
N#define IP_OFFMASK 0x1fffU   /* mask for fragmenting bits */
N  /* time to live */
N  PACK_STRUCT_FIELD(u8_t _ttl);
X  u8_t _ttl;
N  /* protocol*/
N  PACK_STRUCT_FIELD(u8_t _proto);
X  u8_t _proto;
N  /* checksum */
N  PACK_STRUCT_FIELD(u16_t _chksum);
X  u16_t _chksum;
N  /* source and destination IP addresses */
N  PACK_STRUCT_FIELD(ip_addr_p_t src);
X  ip_addr_p_t src;
N  PACK_STRUCT_FIELD(ip_addr_p_t dest); 
X  ip_addr_p_t dest; 
N} PACK_STRUCT_STRUCT;
X} ;
NPACK_STRUCT_END
X
N#ifdef PACK_STRUCT_USE_INCLUDES
S#  include "arch/epstruct.h"
N#endif
N
N#define IPH_V(hdr)  ((hdr)->_v_hl >> 4)
N#define IPH_HL(hdr) ((hdr)->_v_hl & 0x0f)
N#define IPH_TOS(hdr) ((hdr)->_tos)
N#define IPH_LEN(hdr) ((hdr)->_len)
N#define IPH_ID(hdr) ((hdr)->_id)
N#define IPH_OFFSET(hdr) ((hdr)->_offset)
N#define IPH_TTL(hdr) ((hdr)->_ttl)
N#define IPH_PROTO(hdr) ((hdr)->_proto)
N#define IPH_CHKSUM(hdr) ((hdr)->_chksum)
N
N#define IPH_VHL_SET(hdr, v, hl) (hdr)->_v_hl = (((v) << 4) | (hl))
N#define IPH_TOS_SET(hdr, tos) (hdr)->_tos = (tos)
N#define IPH_LEN_SET(hdr, len) (hdr)->_len = (len)
N#define IPH_ID_SET(hdr, id) (hdr)->_id = (id)
N#define IPH_OFFSET_SET(hdr, off) (hdr)->_offset = (off)
N#define IPH_TTL_SET(hdr, ttl) (hdr)->_ttl = (u8_t)(ttl)
N#define IPH_PROTO_SET(hdr, proto) (hdr)->_proto = (u8_t)(proto)
N#define IPH_CHKSUM_SET(hdr, chksum) (hdr)->_chksum = (chksum)
N
N/** The interface that provided the packet for the current callback invocation. */
Nextern struct netif *current_netif;
N/** Header of the input packet currently being processed. */
Nextern const struct ip_hdr *current_header;
N/** Source IP address of current_header */
Nextern ip_addr_t current_iphdr_src;
N/** Destination IP address of current_header */
Nextern ip_addr_t current_iphdr_dest;
N
N#define ip_init() /* Compatibility define, not init needed. */
Nstruct netif *ip_route(ip_addr_t *dest);
Nerr_t ip_input(struct pbuf *p, struct netif *inp);
Nerr_t ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
N       u8_t ttl, u8_t tos, u8_t proto);
Nerr_t ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
N       u8_t ttl, u8_t tos, u8_t proto,
N       struct netif *netif);
N#if LWIP_NETIF_HWADDRHINT
X#if 0
Serr_t ip_output_hinted(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
S       u8_t ttl, u8_t tos, u8_t proto, u8_t *addr_hint);
N#endif /* LWIP_NETIF_HWADDRHINT */
N#if IP_OPTIONS_SEND
X#if 0
Serr_t ip_output_if_opt(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
S       u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
S       u16_t optlen);
N#endif /* IP_OPTIONS_SEND */
N/** Get the interface that received the current packet.
N * This function must only be called from a receive callback (udp_recv,
N * raw_recv, tcp_accept). It will return NULL otherwise. */
N#define ip_current_netif()  (current_netif)
N/** Get the IP header of the current packet.
N * This function must only be called from a receive callback (udp_recv,
N * raw_recv, tcp_accept). It will return NULL otherwise. */
N#define ip_current_header() (current_header)
N/** Source IP address of current_header */
N#define ip_current_src_addr()  (&current_iphdr_src)
N/** Destination IP address of current_header */
N#define ip_current_dest_addr() (&current_iphdr_dest)
N
N/** Gets an IP pcb option (SOF_* flags) */
N#define ip_get_option(pcb, opt)   ((pcb)->so_options & (opt))
N/** Sets an IP pcb option (SOF_* flags) */
N#define ip_set_option(pcb, opt)   ((pcb)->so_options |= (opt))
N/** Resets an IP pcb option (SOF_* flags) */
N#define ip_reset_option(pcb, opt) ((pcb)->so_options &= ~(opt))
N
N#if IP_DEBUG
X#if 0x00U
Svoid ip_debug_print(struct pbuf *p);
N#else
N#define ip_debug_print(p)
N#endif /* IP_DEBUG */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __LWIP_IP_H__ */
N
N
L 42 "..\..\Lwip\lwip-1.4.1\src\include\lwip/tcp.h" 2
N#include "lwip/icmp.h"
L 1 "..\..\Lwip\lwip-1.4.1\src\include\ipv4\lwip/icmp.h" 1
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_ICMP_H__
N#define __LWIP_ICMP_H__
N
N#include "lwip/opt.h"
N#include "lwip/pbuf.h"
N#include "lwip/ip_addr.h"
N#include "lwip/netif.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define ICMP_ER   0    /* echo reply */
N#define ICMP_DUR  3    /* destination unreachable */
N#define ICMP_SQ   4    /* source quench */
N#define ICMP_RD   5    /* redirect */
N#define ICMP_ECHO 8    /* echo */
N#define ICMP_TE  11    /* time exceeded */
N#define ICMP_PP  12    /* parameter problem */
N#define ICMP_TS  13    /* timestamp */
N#define ICMP_TSR 14    /* timestamp reply */
N#define ICMP_IRQ 15    /* information request */
N#define ICMP_IR  16    /* information reply */
N
Nenum icmp_dur_type {
N  ICMP_DUR_NET   = 0,  /* net unreachable */
N  ICMP_DUR_HOST  = 1,  /* host unreachable */
N  ICMP_DUR_PROTO = 2,  /* protocol unreachable */
N  ICMP_DUR_PORT  = 3,  /* port unreachable */
N  ICMP_DUR_FRAG  = 4,  /* fragmentation needed and DF set */
N  ICMP_DUR_SR    = 5   /* source route failed */
N};
N
Nenum icmp_te_type {
N  ICMP_TE_TTL  = 0,    /* time to live exceeded in transit */
N  ICMP_TE_FRAG = 1     /* fragment reassembly time exceeded */
N};
N
N#ifdef PACK_STRUCT_USE_INCLUDES
S#  include "arch/bpstruct.h"
N#endif
N/** This is the standard ICMP header only that the u32_t data
N *  is splitted to two u16_t like ICMP echo needs it.
N *  This header is also used for other ICMP types that do not
N *  use the data part.
N */
NPACK_STRUCT_BEGIN
X__packed
Nstruct icmp_echo_hdr {
N  PACK_STRUCT_FIELD(u8_t type);
X  u8_t type;
N  PACK_STRUCT_FIELD(u8_t code);
X  u8_t code;
N  PACK_STRUCT_FIELD(u16_t chksum);
X  u16_t chksum;
N  PACK_STRUCT_FIELD(u16_t id);
X  u16_t id;
N  PACK_STRUCT_FIELD(u16_t seqno);
X  u16_t seqno;
N} PACK_STRUCT_STRUCT;
X} ;
NPACK_STRUCT_END
X
N#ifdef PACK_STRUCT_USE_INCLUDES
S#  include "arch/epstruct.h"
N#endif
N
N#define ICMPH_TYPE(hdr) ((hdr)->type)
N#define ICMPH_CODE(hdr) ((hdr)->code)
N
N/** Combines type and code to an u16_t */
N#define ICMPH_TYPE_SET(hdr, t) ((hdr)->type = (t))
N#define ICMPH_CODE_SET(hdr, c) ((hdr)->code = (c))
N
N
N#if LWIP_ICMP /* don't build if not configured for use in lwipopts.h */
X#if 1  
N
Nvoid icmp_input(struct pbuf *p, struct netif *inp);
Nvoid icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t);
Nvoid icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t);
N
N#endif /* LWIP_ICMP */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __LWIP_ICMP_H__ */
L 43 "..\..\Lwip\lwip-1.4.1\src\include\lwip/tcp.h" 2
N#include "lwip/err.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
Nstruct tcp_pcb;
N
N/** Function prototype for tcp accept callback functions. Called when a new
N * connection can be accepted on a listening pcb.
N *
N * @param arg Additional argument to pass to the callback function (@see tcp_arg())
N * @param newpcb The new connection pcb
N * @param err An error code if there has been an error accepting.
N *            Only return ERR_ABRT if you have called tcp_abort from within the
N *            callback function!
N */
Ntypedef err_t (*tcp_accept_fn)(void *arg, struct tcp_pcb *newpcb, err_t err);
N
N/** Function prototype for tcp receive callback functions. Called when data has
N * been received.
N *
N * @param arg Additional argument to pass to the callback function (@see tcp_arg())
N * @param tpcb The connection pcb which received data
N * @param p The received data (or NULL when the connection has been closed!)
N * @param err An error code if there has been an error receiving
N *            Only return ERR_ABRT if you have called tcp_abort from within the
N *            callback function!
N */
Ntypedef err_t (*tcp_recv_fn)(void *arg, struct tcp_pcb *tpcb,
N                             struct pbuf *p, err_t err);
N
N/** Function prototype for tcp sent callback functions. Called when sent data has
N * been acknowledged by the remote side. Use it to free corresponding resources.
N * This also means that the pcb has now space available to send new data.
N *
N * @param arg Additional argument to pass to the callback function (@see tcp_arg())
N * @param tpcb The connection pcb for which data has been acknowledged
N * @param len The amount of bytes acknowledged
N * @return ERR_OK: try to send some data by calling tcp_output
N *            Only return ERR_ABRT if you have called tcp_abort from within the
N *            callback function!
N */
Ntypedef err_t (*tcp_sent_fn)(void *arg, struct tcp_pcb *tpcb,
N                              u16_t len);
N
N/** Function prototype for tcp poll callback functions. Called periodically as
N * specified by @see tcp_poll.
N *
N * @param arg Additional argument to pass to the callback function (@see tcp_arg())
N * @param tpcb tcp pcb
N * @return ERR_OK: try to send some data by calling tcp_output
N *            Only return ERR_ABRT if you have called tcp_abort from within the
N *            callback function!
N */
Ntypedef err_t (*tcp_poll_fn)(void *arg, struct tcp_pcb *tpcb);
N
N/** Function prototype for tcp error callback functions. Called when the pcb
N * receives a RST or is unexpectedly closed for any other reason.
N *
N * @note The corresponding pcb is already freed when this callback is called!
N *
N * @param arg Additional argument to pass to the callback function (@see tcp_arg())
N * @param err Error code to indicate why the pcb has been closed
N *            ERR_ABRT: aborted through tcp_abort or by a TCP timer
N *            ERR_RST: the connection was reset by the remote host
N */
Ntypedef void  (*tcp_err_fn)(void *arg, err_t err);
N
N/** Function prototype for tcp connected callback functions. Called when a pcb
N * is connected to the remote side after initiating a connection attempt by
N * calling tcp_connect().
N *
N * @param arg Additional argument to pass to the callback function (@see tcp_arg())
N * @param tpcb The connection pcb which is connected
N * @param err An unused error code, always ERR_OK currently ;-) TODO!
N *            Only return ERR_ABRT if you have called tcp_abort from within the
N *            callback function!
N *
N * @note When a connection attempt fails, the error callback is currently called!
N */
Ntypedef err_t (*tcp_connected_fn)(void *arg, struct tcp_pcb *tpcb, err_t err);
N
Nenum tcp_state {
N  CLOSED      = 0,
N  LISTEN      = 1,
N  SYN_SENT    = 2,
N  SYN_RCVD    = 3,
N  ESTABLISHED = 4,
N  FIN_WAIT_1  = 5,
N  FIN_WAIT_2  = 6,
N  CLOSE_WAIT  = 7,
N  CLOSING     = 8,
N  LAST_ACK    = 9,
N  TIME_WAIT   = 10
N};
N
N#if LWIP_CALLBACK_API
X#if 1
N  /* Function to call when a listener has been connected.
N   * @param arg user-supplied argument (tcp_pcb.callback_arg)
N   * @param pcb a new tcp_pcb that now is connected
N   * @param err an error argument (TODO: that is current always ERR_OK?)
N   * @return ERR_OK: accept the new connection,
N   *                 any other err_t abortsthe new connection
N   */
N#define DEF_ACCEPT_CALLBACK  tcp_accept_fn accept;
N#else /* LWIP_CALLBACK_API */
S#define DEF_ACCEPT_CALLBACK
N#endif /* LWIP_CALLBACK_API */
N
N/**
N * members common to struct tcp_pcb and struct tcp_listen_pcb
N */
N#define TCP_PCB_COMMON(type) \
N  type *next; /* for the linked list */ \
N  void *callback_arg; \
N  /* the accept callback for listen- and normal pcbs, if LWIP_CALLBACK_API */ \
N  DEF_ACCEPT_CALLBACK \
N  enum tcp_state state; /* TCP state */ \
N  u8_t prio; \
N  /* ports are in host byte order */ \
N  u16_t local_port
X#define TCP_PCB_COMMON(type)   type *next;     void *callback_arg;       DEF_ACCEPT_CALLBACK   enum tcp_state state;     u8_t prio;       u16_t local_port
N
N
N/* the TCP protocol control block */
Nstruct tcp_pcb {
N/** common PCB members */
N  IP_PCB;
X  ip_addr_t local_ip; ip_addr_t remote_ip; u8_t so_options; u8_t tos; u8_t ttl ;
N/** protocol specific PCB members */
N  TCP_PCB_COMMON(struct tcp_pcb);
X  struct tcp_pcb *next; void *callback_arg; tcp_accept_fn accept; enum tcp_state state; u8_t prio; u16_t local_port;
N
N  /* ports are in host byte order */
N  u16_t remote_port;
N  
N  u8_t flags;
N#define TF_ACK_DELAY   ((u8_t)0x01U)   /* Delayed ACK. */
N#define TF_ACK_NOW     ((u8_t)0x02U)   /* Immediate ACK. */
N#define TF_INFR        ((u8_t)0x04U)   /* In fast recovery. */
N#define TF_TIMESTAMP   ((u8_t)0x08U)   /* Timestamp option enabled */
N#define TF_RXCLOSED    ((u8_t)0x10U)   /* rx closed by tcp_shutdown */
N#define TF_FIN         ((u8_t)0x20U)   /* Connection was closed locally (FIN segment enqueued). */
N#define TF_NODELAY     ((u8_t)0x40U)   /* Disable Nagle algorithm */
N#define TF_NAGLEMEMERR ((u8_t)0x80U)   /* nagle enabled, memerr, try to output to prevent delayed ACK to happen */
N
N  /* the rest of the fields are in host byte order
N     as we have to do some math with them */
N
N  /* Timers */
N  u8_t polltmr, pollinterval;
N  u8_t last_timer;
N  u32_t tmr;
N
N  /* receiver variables */
N  u32_t rcv_nxt;   /* next seqno expected */
N  u16_t rcv_wnd;   /* receiver window available */
N  u16_t rcv_ann_wnd; /* receiver window to announce */
N  u32_t rcv_ann_right_edge; /* announced right edge of window */
N
N  /* Retransmission timer. */
N  s16_t rtime;
N
N  u16_t mss;   /* maximum segment size */
N
N  /* RTT (round trip time) estimation variables */
N  u32_t rttest; /* RTT estimate in 500ms ticks */
N  u32_t rtseq;  /* sequence number being timed */
N  s16_t sa, sv; /* @todo document this */
N
N  s16_t rto;    /* retransmission time-out */
N  u8_t nrtx;    /* number of retransmissions */
N
N  /* fast retransmit/recovery */
N  u8_t dupacks;
N  u32_t lastack; /* Highest acknowledged seqno. */
N
N  /* congestion avoidance/control variables */
N  u16_t cwnd;
N  u16_t ssthresh;
N
N  /* sender variables */
N  u32_t snd_nxt;   /* next new seqno to be sent */
N  u32_t snd_wl1, snd_wl2; /* Sequence and acknowledgement numbers of last
N                             window update. */
N  u32_t snd_lbb;       /* Sequence number of next byte to be buffered. */
N  u16_t snd_wnd;   /* sender window */
N  u16_t snd_wnd_max; /* the maximum sender window announced by the remote host */
N
N  u16_t acked;
N
N  u16_t snd_buf;   /* Available buffer space for sending (in bytes). */
N#define TCP_SNDQUEUELEN_OVERFLOW (0xffffU-3)
N  u16_t snd_queuelen; /* Available buffer space for sending (in tcp_segs). */
N
N#if TCP_OVERSIZE
X#if (1500 - 140)
N  /* Extra bytes available at the end of the last pbuf in unsent. */
N  u16_t unsent_oversize;
N#endif /* TCP_OVERSIZE */ 
N
N  /* These are ordered by sequence number: */
N  struct tcp_seg *unsent;   /* Unsent (queued) segments. */
N  struct tcp_seg *unacked;  /* Sent but unacknowledged segments. */
N#if TCP_QUEUE_OOSEQ  
X#if 1  
N  struct tcp_seg *ooseq;    /* Received out of sequence segments. */
N#endif /* TCP_QUEUE_OOSEQ */
N
N  struct pbuf *refused_data; /* Data previously received but not yet taken by upper layer */
N
N#if LWIP_CALLBACK_API
X#if 1
N  /* Function to be called when more send buffer space is available. */
N  tcp_sent_fn sent;
N  /* Function to be called when (in-sequence) data has arrived. */
N  tcp_recv_fn recv;
N  /* Function to be called when a connection has been set up. */
N  tcp_connected_fn connected;
N  /* Function which is called periodically. */
N  tcp_poll_fn poll;
N  /* Function to be called whenever a fatal error occurs. */
N  tcp_err_fn errf;
N#endif /* LWIP_CALLBACK_API */
N
N#if LWIP_TCP_TIMESTAMPS
X#if 0
S  u32_t ts_lastacksent;
S  u32_t ts_recent;
N#endif /* LWIP_TCP_TIMESTAMPS */
N
N  /* idle time before KEEPALIVE is sent */
N  u32_t keep_idle;
N#if LWIP_TCP_KEEPALIVE
X#if 0
S  u32_t keep_intvl;
S  u32_t keep_cnt;
N#endif /* LWIP_TCP_KEEPALIVE */
N  
N  /* Persist timer counter */
N  u8_t persist_cnt;
N  /* Persist timer back-off */
N  u8_t persist_backoff;
N
N  /* KEEPALIVE counter */
N  u8_t keep_cnt_sent;
N};
N
Nstruct tcp_pcb_listen {  
N/* Common members of all PCB types */
N  IP_PCB;
X  ip_addr_t local_ip; ip_addr_t remote_ip; u8_t so_options; u8_t tos; u8_t ttl ;
N/* Protocol specific PCB members */
N  TCP_PCB_COMMON(struct tcp_pcb_listen);
X  struct tcp_pcb_listen *next; void *callback_arg; tcp_accept_fn accept; enum tcp_state state; u8_t prio; u16_t local_port;
N
N#if TCP_LISTEN_BACKLOG
X#if 0
S  u8_t backlog;
S  u8_t accepts_pending;
N#endif /* TCP_LISTEN_BACKLOG */
N};
N
N#if LWIP_EVENT_API
X#if 0
S
Senum lwip_event {
S  LWIP_EVENT_ACCEPT,
S  LWIP_EVENT_SENT,
S  LWIP_EVENT_RECV,
S  LWIP_EVENT_CONNECTED,
S  LWIP_EVENT_POLL,
S  LWIP_EVENT_ERR
S};
S
Serr_t lwip_tcp_event(void *arg, struct tcp_pcb *pcb,
S         enum lwip_event,
S         struct pbuf *p,
S         u16_t size,
S         err_t err);
S
N#endif /* LWIP_EVENT_API */
N
N/* Application program's interface: */
Nstruct tcp_pcb * tcp_new     (void);
N
Nvoid             tcp_arg     (struct tcp_pcb *pcb, void *arg);
Nvoid             tcp_accept  (struct tcp_pcb *pcb, tcp_accept_fn accept);
Nvoid             tcp_recv    (struct tcp_pcb *pcb, tcp_recv_fn recv);
Nvoid             tcp_sent    (struct tcp_pcb *pcb, tcp_sent_fn sent);
Nvoid             tcp_poll    (struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval);
Nvoid             tcp_err     (struct tcp_pcb *pcb, tcp_err_fn err);
N
N#define          tcp_mss(pcb)             (((pcb)->flags & TF_TIMESTAMP) ? ((pcb)->mss - 12)  : (pcb)->mss)
N#define          tcp_sndbuf(pcb)          ((pcb)->snd_buf)
N#define          tcp_sndqueuelen(pcb)     ((pcb)->snd_queuelen)
N#define          tcp_nagle_disable(pcb)   ((pcb)->flags |= TF_NODELAY)
N#define          tcp_nagle_enable(pcb)    ((pcb)->flags &= ~TF_NODELAY)
N#define          tcp_nagle_disabled(pcb)  (((pcb)->flags & TF_NODELAY) != 0)
N
N#if TCP_LISTEN_BACKLOG
X#if 0
S#define          tcp_accepted(pcb) do { \
S  LWIP_ASSERT("pcb->state == LISTEN (called for wrong pcb?)", pcb->state == LISTEN); \
S  (((struct tcp_pcb_listen *)(pcb))->accepts_pending--); } while(0)
X#define          tcp_accepted(pcb) do {   LWIP_ASSERT("pcb->state == LISTEN (called for wrong pcb?)", pcb->state == LISTEN);   (((struct tcp_pcb_listen *)(pcb))->accepts_pending--); } while(0)
N#else  /* TCP_LISTEN_BACKLOG */
N#define          tcp_accepted(pcb) LWIP_ASSERT("pcb->state == LISTEN (called for wrong pcb?)", \
N                                               (pcb)->state == LISTEN)
X#define          tcp_accepted(pcb) LWIP_ASSERT("pcb->state == LISTEN (called for wrong pcb?)",                                                (pcb)->state == LISTEN)
N#endif /* TCP_LISTEN_BACKLOG */
N
Nvoid             tcp_recved  (struct tcp_pcb *pcb, u16_t len);
Nerr_t            tcp_bind    (struct tcp_pcb *pcb, ip_addr_t *ipaddr,
N                              u16_t port);
Nerr_t            tcp_connect (struct tcp_pcb *pcb, ip_addr_t *ipaddr,
N                              u16_t port, tcp_connected_fn connected);
N
Nstruct tcp_pcb * tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog);
N#define          tcp_listen(pcb) tcp_listen_with_backlog(pcb, TCP_DEFAULT_LISTEN_BACKLOG)
N
Nvoid             tcp_abort (struct tcp_pcb *pcb);
Nerr_t            tcp_close   (struct tcp_pcb *pcb);
Nerr_t            tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx);
N
N/* Flags for "apiflags" parameter in tcp_write */
N#define TCP_WRITE_FLAG_COPY 0x01
N#define TCP_WRITE_FLAG_MORE 0x02
N
Nerr_t            tcp_write   (struct tcp_pcb *pcb, const void *dataptr, u16_t len,
N                              u8_t apiflags);
N
Nvoid             tcp_setprio (struct tcp_pcb *pcb, u8_t prio);
N
N#define TCP_PRIO_MIN    1
N#define TCP_PRIO_NORMAL 64
N#define TCP_PRIO_MAX    127
N
Nerr_t            tcp_output  (struct tcp_pcb *pcb);
N
N
Nconst char* tcp_debug_state_str(enum tcp_state s);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* LWIP_TCP */
N
N#endif /* __LWIP_TCP_H__ */
L 40 "..\..\Lwip\App\STM8_FM17550_iap.h" 2
N#include "lwip/udp.h"
L 1 "..\..\Lwip\lwip-1.4.1\src\include\lwip/udp.h" 1
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_UDP_H__
N#define __LWIP_UDP_H__
N
N#include "lwip/opt.h"
N
N#if LWIP_UDP /* don't build if not configured for use in lwipopts.h */
X#if 1  
N
N#include "lwip/pbuf.h"
N#include "lwip/netif.h"
N#include "lwip/ip_addr.h"
N#include "lwip/ip.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define UDP_HLEN 8
N
N/* Fields are (of course) in network byte order. */
N#ifdef PACK_STRUCT_USE_INCLUDES
S#  include "arch/bpstruct.h"
N#endif
NPACK_STRUCT_BEGIN
X__packed
Nstruct udp_hdr {
N  PACK_STRUCT_FIELD(u16_t src);
X  u16_t src;
N  PACK_STRUCT_FIELD(u16_t dest);  /* src/dest UDP ports */
X  u16_t dest;   
N  PACK_STRUCT_FIELD(u16_t len);
X  u16_t len;
N  PACK_STRUCT_FIELD(u16_t chksum);
X  u16_t chksum;
N} PACK_STRUCT_STRUCT;
X} ;
NPACK_STRUCT_END
X
N#ifdef PACK_STRUCT_USE_INCLUDES
S#  include "arch/epstruct.h"
N#endif
N
N#define UDP_FLAGS_NOCHKSUM       0x01U
N#define UDP_FLAGS_UDPLITE        0x02U
N#define UDP_FLAGS_CONNECTED      0x04U
N#define UDP_FLAGS_MULTICAST_LOOP 0x08U
N
Nstruct udp_pcb;
N
N/** Function prototype for udp pcb receive callback functions
N * addr and port are in same byte order as in the pcb
N * The callback is responsible for freeing the pbuf
N * if it's not used any more.
N *
N * ATTENTION: Be aware that 'addr' points into the pbuf 'p' so freeing this pbuf
N *            makes 'addr' invalid, too.
N *
N * @param arg user supplied argument (udp_pcb.recv_arg)
N * @param pcb the udp_pcb which received data
N * @param p the packet buffer that was received
N * @param addr the remote IP address from which the packet was received
N * @param port the remote port from which the packet was received
N */
Ntypedef void (*udp_recv_fn)(void *arg, struct udp_pcb *pcb, struct pbuf *p,
N    ip_addr_t *addr, u16_t port);
N
N
Nstruct udp_pcb {
N/* Common members of all PCB types */
N  IP_PCB;
X  ip_addr_t local_ip; ip_addr_t remote_ip; u8_t so_options; u8_t tos; u8_t ttl ;
N
N/* Protocol specific PCB members */
N
N  struct udp_pcb *next;
N
N  u8_t flags;
N  /** ports are in host byte order */
N  u16_t local_port, remote_port;
N
N#if LWIP_IGMP
X#if 0
S  /** outgoing network interface for multicast packets */
S  ip_addr_t multicast_ip;
N#endif /* LWIP_IGMP */
N
N#if LWIP_UDPLITE
X#if 0
S  /** used for UDP_LITE only */
S  u16_t chksum_len_rx, chksum_len_tx;
N#endif /* LWIP_UDPLITE */
N
N  /** receive callback function */
N  udp_recv_fn recv;
N  /** user-supplied argument for the recv callback */
N  void *recv_arg;  
N};
N/* udp_pcbs export for exernal reference (e.g. SNMP agent) */
Nextern struct udp_pcb *udp_pcbs;
N
N/* The following functions is the application layer interface to the
N   UDP code. */
Nstruct udp_pcb * udp_new        (void);
Nvoid             udp_remove     (struct udp_pcb *pcb);
Nerr_t            udp_bind       (struct udp_pcb *pcb, ip_addr_t *ipaddr,
N                                 u16_t port);
Nerr_t            udp_connect    (struct udp_pcb *pcb, ip_addr_t *ipaddr,
N                                 u16_t port);
Nvoid             udp_disconnect (struct udp_pcb *pcb);
Nvoid             udp_recv       (struct udp_pcb *pcb, udp_recv_fn recv,
N                                 void *recv_arg);
Nerr_t            udp_sendto_if  (struct udp_pcb *pcb, struct pbuf *p,
N                                 ip_addr_t *dst_ip, u16_t dst_port,
N                                 struct netif *netif);
Nerr_t            udp_sendto     (struct udp_pcb *pcb, struct pbuf *p,
N                                 ip_addr_t *dst_ip, u16_t dst_port);
Nerr_t            udp_send       (struct udp_pcb *pcb, struct pbuf *p);
N
N#if LWIP_CHECKSUM_ON_COPY
X#if 0
Serr_t            udp_sendto_if_chksum(struct udp_pcb *pcb, struct pbuf *p,
S                                 ip_addr_t *dst_ip, u16_t dst_port,
S                                 struct netif *netif, u8_t have_chksum,
S                                 u16_t chksum);
Serr_t            udp_sendto_chksum(struct udp_pcb *pcb, struct pbuf *p,
S                                 ip_addr_t *dst_ip, u16_t dst_port,
S                                 u8_t have_chksum, u16_t chksum);
Serr_t            udp_send_chksum(struct udp_pcb *pcb, struct pbuf *p,
S                                 u8_t have_chksum, u16_t chksum);
N#endif /* LWIP_CHECKSUM_ON_COPY */
N
N#define          udp_flags(pcb) ((pcb)->flags)
N#define          udp_setflags(pcb, f)  ((pcb)->flags = (f))
N
N/* The following functions are the lower layer interface to UDP. */
Nvoid             udp_input      (struct pbuf *p, struct netif *inp);
N
Nvoid             udp_init       (void);
N
N#if UDP_DEBUG
X#if 0x00U
Svoid udp_debug_print(struct udp_hdr *udphdr);
N#else
N#define udp_debug_print(udphdr)
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* LWIP_UDP */
N
N#endif /* __LWIP_UDP_H__ */
L 41 "..\..\Lwip\App\STM8_FM17550_iap.h" 2
N#include "netconf.h"
N#include "lwip/pbuf.h"
N//#include "lwipopts.h"
N//#include "lwip/opt.h"
N#include "lwip/ip_addr.h"
N#include "lwip/ip.h"
N#include "lwip/igmp.h"
L 1 "..\..\Lwip\lwip-1.4.1\src\include\ipv4\lwip/igmp.h" 1
N/*
N * Copyright (c) 2002 CITEL Technologies Ltd.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without 
N * modification, are permitted provided that the following conditions 
N * are met: 
N * 1. Redistributions of source code must retain the above copyright 
N *    notice, this list of conditions and the following disclaimer. 
N * 2. Redistributions in binary form must reproduce the above copyright 
N *    notice, this list of conditions and the following disclaimer in the 
N *    documentation and/or other materials provided with the distribution. 
N * 3. Neither the name of CITEL Technologies Ltd nor the names of its contributors 
N *    may be used to endorse or promote products derived from this software 
N *    without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY CITEL TECHNOLOGIES AND CONTRIBUTORS ``AS IS''
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
N * ARE DISCLAIMED.  IN NO EVENT SHALL CITEL TECHNOLOGIES OR CONTRIBUTORS BE LIABLE 
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
N * SUCH DAMAGE. 
N *
N * This file is a contribution to the lwIP TCP/IP stack.
N * The Swedish Institute of Computer Science and Adam Dunkels
N * are specifically granted permission to redistribute this
N * source code.
N*/
N
N#ifndef __LWIP_IGMP_H__
N#define __LWIP_IGMP_H__
N
N#include "lwip/opt.h"
N#include "lwip/ip_addr.h"
N#include "lwip/netif.h"
N#include "lwip/pbuf.h"
N
N#if LWIP_IGMP /* don't build if not configured for use in lwipopts.h */
X#if 0  
S
S#ifdef __cplusplus
Sextern "C" {
S#endif
S
S
S/* IGMP timer */
S#define IGMP_TMR_INTERVAL              100 /* Milliseconds */
S#define IGMP_V1_DELAYING_MEMBER_TMR   (1000/IGMP_TMR_INTERVAL)
S#define IGMP_JOIN_DELAYING_MEMBER_TMR (500 /IGMP_TMR_INTERVAL)
S
S/* MAC Filter Actions, these are passed to a netif's
S * igmp_mac_filter callback function. */
S#define IGMP_DEL_MAC_FILTER            0
S#define IGMP_ADD_MAC_FILTER            1
S
S
S/**
S * igmp group structure - there is
S * a list of groups for each interface
S * these should really be linked from the interface, but
S * if we keep them separate we will not affect the lwip original code
S * too much
S * 
S * There will be a group for the all systems group address but this 
S * will not run the state machine as it is used to kick off reports
S * from all the other groups
S */
Sstruct igmp_group {
S  /** next link */
S  struct igmp_group *next;
S  /** interface on which the group is active */
S  struct netif      *netif;
S  /** multicast address */
S  ip_addr_t          group_address;
S  /** signifies we were the last person to report */
S  u8_t               last_reporter_flag;
S  /** current state of the group */
S  u8_t               group_state;
S  /** timer for reporting, negative is OFF */
S  u16_t              timer;
S  /** counter of simultaneous uses */
S  u8_t               use;
S};
S
S/*  Prototypes */
Svoid   igmp_init(void);
Serr_t  igmp_start(struct netif *netif);
Serr_t  igmp_stop(struct netif *netif);
Svoid   igmp_report_groups(struct netif *netif);
Sstruct igmp_group *igmp_lookfor_group(struct netif *ifp, ip_addr_t *addr);
Svoid   igmp_input(struct pbuf *p, struct netif *inp, ip_addr_t *dest);
Serr_t  igmp_joingroup(ip_addr_t *ifaddr, ip_addr_t *groupaddr);
Serr_t  igmp_leavegroup(ip_addr_t *ifaddr, ip_addr_t *groupaddr);
Svoid   igmp_tmr(void);
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* LWIP_IGMP */
N
N#endif /* __LWIP_IGMP_H__ */
L 48 "..\..\Lwip\App\STM8_FM17550_iap.h" 2
N#include "lwip/dns.h"
L 1 "..\..\Lwip\lwip-1.4.1\src\include\lwip/dns.h" 1
N/**
N * lwip DNS resolver header file.
N
N * Author: Jim Pettinato 
N *   April 2007
N
N * ported from uIP resolv.c Copyright (c) 2002-2003, Adam Dunkels.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote
N *    products derived from this software without specific prior
N *    written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
N * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
N * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
N * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
N * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N */
N
N#ifndef __LWIP_DNS_H__
N#define __LWIP_DNS_H__
N
N#include "lwip/opt.h"
N
N#if LWIP_DNS /* don't build if not configured for use in lwipopts.h */
X#if 1  
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** DNS timer period */
N#define DNS_TMR_INTERVAL          1000
N
N/** DNS field TYPE used for "Resource Records" */
N#define DNS_RRTYPE_A              1     /* a host address */
N#define DNS_RRTYPE_NS             2     /* an authoritative name server */
N#define DNS_RRTYPE_MD             3     /* a mail destination (Obsolete - use MX) */
N#define DNS_RRTYPE_MF             4     /* a mail forwarder (Obsolete - use MX) */
N#define DNS_RRTYPE_CNAME          5     /* the canonical name for an alias */
N#define DNS_RRTYPE_SOA            6     /* marks the start of a zone of authority */
N#define DNS_RRTYPE_MB             7     /* a mailbox domain name (EXPERIMENTAL) */
N#define DNS_RRTYPE_MG             8     /* a mail group member (EXPERIMENTAL) */
N#define DNS_RRTYPE_MR             9     /* a mail rename domain name (EXPERIMENTAL) */
N#define DNS_RRTYPE_NULL           10    /* a null RR (EXPERIMENTAL) */
N#define DNS_RRTYPE_WKS            11    /* a well known service description */
N#define DNS_RRTYPE_PTR            12    /* a domain name pointer */
N#define DNS_RRTYPE_HINFO          13    /* host information */
N#define DNS_RRTYPE_MINFO          14    /* mailbox or mail list information */
N#define DNS_RRTYPE_MX             15    /* mail exchange */
N#define DNS_RRTYPE_TXT            16    /* text strings */
N
N/** DNS field CLASS used for "Resource Records" */
N#define DNS_RRCLASS_IN            1     /* the Internet */
N#define DNS_RRCLASS_CS            2     /* the CSNET class (Obsolete - used only for examples in some obsolete RFCs) */
N#define DNS_RRCLASS_CH            3     /* the CHAOS class */
N#define DNS_RRCLASS_HS            4     /* Hesiod [Dyer 87] */
N#define DNS_RRCLASS_FLUSH         0x800 /* Flush bit */
N
N/* The size used for the next line is rather a hack, but it prevents including socket.h in all files
N   that include memp.h, and that would possibly break portability (since socket.h defines some types
N   and constants possibly already define by the OS).
N   Calculation rule:
N   sizeof(struct addrinfo) + sizeof(struct sockaddr_in) + DNS_MAX_NAME_LENGTH + 1 byte zero-termination */
N#define NETDB_ELEM_SIZE           (32 + 16 + DNS_MAX_NAME_LENGTH + 1)
N
N#if DNS_LOCAL_HOSTLIST
X#if 0
S/** struct used for local host-list */
Sstruct local_hostlist_entry {
S  /** static hostname */
S  const char *name;
S  /** static host address in network byteorder */
S  ip_addr_t addr;
S  struct local_hostlist_entry *next;
S};
S#if DNS_LOCAL_HOSTLIST_IS_DYNAMIC
S#ifndef DNS_LOCAL_HOSTLIST_MAX_NAMELEN
S#define DNS_LOCAL_HOSTLIST_MAX_NAMELEN  DNS_MAX_NAME_LENGTH
S#endif
S#define LOCALHOSTLIST_ELEM_SIZE ((sizeof(struct local_hostlist_entry) + DNS_LOCAL_HOSTLIST_MAX_NAMELEN + 1))
S#endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
N#endif /* DNS_LOCAL_HOSTLIST */
N
N/** Callback which is invoked when a hostname is found.
N * A function of this type must be implemented by the application using the DNS resolver.
N * @param name pointer to the name that was looked up.
N * @param ipaddr pointer to an ip_addr_t containing the IP address of the hostname,
N *        or NULL if the name could not be found (or on any other error).
N * @param callback_arg a user-specified callback argument passed to dns_gethostbyname
N*/
Ntypedef void (*dns_found_callback)(const char *name, ip_addr_t *ipaddr, void *callback_arg);
N
Nvoid           dns_init(void);
Nvoid           dns_tmr(void);
Nvoid           dns_setserver(u8_t numdns, ip_addr_t *dnsserver);
Nip_addr_t      dns_getserver(u8_t numdns);
Nerr_t          dns_gethostbyname(const char *hostname, ip_addr_t *addr,
N                                 dns_found_callback found, void *callback_arg);
N
N#if DNS_LOCAL_HOSTLIST && DNS_LOCAL_HOSTLIST_IS_DYNAMIC
X#if 0 && 1
Sint            dns_local_removehost(const char *hostname, const ip_addr_t *addr);
Serr_t          dns_local_addhost(const char *hostname, const ip_addr_t *addr);
N#endif /* DNS_LOCAL_HOSTLIST && DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* LWIP_DNS */
N
N#endif /* __LWIP_DNS_H__ */
L 49 "..\..\Lwip\App\STM8_FM17550_iap.h" 2
N#include "lwip/debug.h"
N#include "lwip/stats.h"
L 1 "..\..\Lwip\lwip-1.4.1\src\include\lwip/stats.h" 1
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_STATS_H__
N#define __LWIP_STATS_H__
N
N#include "lwip/opt.h"
N
N#include "lwip/mem.h"
N#include "lwip/memp.h"
L 1 "..\..\Lwip\lwip-1.4.1\src\include\lwip/memp.h" 1
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N
N#ifndef __LWIP_MEMP_H__
N#define __LWIP_MEMP_H__
N
N#include "lwip/opt.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Create the list of all memory pools managed by memp. MEMP_MAX represents a NULL pool at the end */
Ntypedef enum {
N#define LWIP_MEMPOOL(name,num,size,desc)  MEMP_##name,
N#include "lwip/memp_std.h"
L 1 "..\..\Lwip\lwip-1.4.1\src\include\lwip/memp_std.h" 1
N/*
N * SETUP: Make sure we define everything we will need.
N *
N * We have create three types of pools:
N *   1) MEMPOOL - standard pools
N *   2) MALLOC_MEMPOOL - to be used by mem_malloc in mem.c
N *   3) PBUF_MEMPOOL - a mempool of pbuf's, so include space for the pbuf struct
N *
N * If the include'r doesn't require any special treatment of each of the types
N * above, then will declare #2 & #3 to be just standard mempools.
N */
N#ifndef LWIP_MALLOC_MEMPOOL
N/* This treats "malloc pools" just like any other pool.
N   The pools are a little bigger to provide 'size' as the amount of user data. */
N#define LWIP_MALLOC_MEMPOOL(num, size) LWIP_MEMPOOL(POOL_##size, num, (size + sizeof(struct memp_malloc_helper)), "MALLOC_"#size)
N#define LWIP_MALLOC_MEMPOOL_START
N#define LWIP_MALLOC_MEMPOOL_END
N#endif /* LWIP_MALLOC_MEMPOOL */ 
N
N#ifndef LWIP_PBUF_MEMPOOL
N/* This treats "pbuf pools" just like any other pool.
N * Allocates buffers for a pbuf struct AND a payload size */
N#define LWIP_PBUF_MEMPOOL(name, num, payload, desc) LWIP_MEMPOOL(name, num, (MEMP_ALIGN_SIZE(sizeof(struct pbuf)) + MEMP_ALIGN_SIZE(payload)), desc)
N#endif /* LWIP_PBUF_MEMPOOL */
N
N
N/*
N * A list of internal pools used by LWIP.
N *
N * LWIP_MEMPOOL(pool_name, number_elements, element_size, pool_description)
N *     creates a pool name MEMP_pool_name. description is used in stats.c
N */
N#if LWIP_RAW
X#if 1
NLWIP_MEMPOOL(RAW_PCB,        MEMP_NUM_RAW_PCB,         sizeof(struct raw_pcb),        "RAW_PCB")
XMEMP_RAW_PCB,
N#endif /* LWIP_RAW */
N
N#if LWIP_UDP
X#if 1
NLWIP_MEMPOOL(UDP_PCB,        MEMP_NUM_UDP_PCB,         sizeof(struct udp_pcb),        "UDP_PCB")
XMEMP_UDP_PCB,
N#endif /* LWIP_UDP */
N
N#if LWIP_TCP
X#if 1
NLWIP_MEMPOOL(TCP_PCB,        MEMP_NUM_TCP_PCB,         sizeof(struct tcp_pcb),        "TCP_PCB")
XMEMP_TCP_PCB,
NLWIP_MEMPOOL(TCP_PCB_LISTEN, MEMP_NUM_TCP_PCB_LISTEN,  sizeof(struct tcp_pcb_listen), "TCP_PCB_LISTEN")
XMEMP_TCP_PCB_LISTEN,
NLWIP_MEMPOOL(TCP_SEG,        MEMP_NUM_TCP_SEG,         sizeof(struct tcp_seg),        "TCP_SEG")
XMEMP_TCP_SEG,
N#endif /* LWIP_TCP */
N
N#if IP_REASSEMBLY
X#if 1
NLWIP_MEMPOOL(REASSDATA,      MEMP_NUM_REASSDATA,       sizeof(struct ip_reassdata),   "REASSDATA")
XMEMP_REASSDATA,
N#endif /* IP_REASSEMBLY */
N#if IP_FRAG && !IP_FRAG_USES_STATIC_BUF && !LWIP_NETIF_TX_SINGLE_PBUF
X#if 1 && !0 && !0
NLWIP_MEMPOOL(FRAG_PBUF,      MEMP_NUM_FRAG_PBUF,       sizeof(struct pbuf_custom_ref),"FRAG_PBUF")
XMEMP_FRAG_PBUF,
N#endif /* IP_FRAG && !IP_FRAG_USES_STATIC_BUF && !LWIP_NETIF_TX_SINGLE_PBUF */
N
N#if LWIP_NETCONN
X#if 0
SLWIP_MEMPOOL(NETBUF,         MEMP_NUM_NETBUF,          sizeof(struct netbuf),         "NETBUF")
SLWIP_MEMPOOL(NETCONN,        MEMP_NUM_NETCONN,         sizeof(struct netconn),        "NETCONN")
N#endif /* LWIP_NETCONN */
N
N#if NO_SYS==0
X#if 1==0
SLWIP_MEMPOOL(TCPIP_MSG_API,  MEMP_NUM_TCPIP_MSG_API,   sizeof(struct tcpip_msg),      "TCPIP_MSG_API")
S#if !LWIP_TCPIP_CORE_LOCKING_INPUT
SLWIP_MEMPOOL(TCPIP_MSG_INPKT,MEMP_NUM_TCPIP_MSG_INPKT, sizeof(struct tcpip_msg),      "TCPIP_MSG_INPKT")
S#endif /* !LWIP_TCPIP_CORE_LOCKING_INPUT */
N#endif /* NO_SYS==0 */
N
N#if LWIP_ARP && ARP_QUEUEING
X#if 1 && 0
SLWIP_MEMPOOL(ARP_QUEUE,      MEMP_NUM_ARP_QUEUE,       sizeof(struct etharp_q_entry), "ARP_QUEUE")
N#endif /* LWIP_ARP && ARP_QUEUEING */
N
N#if LWIP_IGMP
X#if 0
SLWIP_MEMPOOL(IGMP_GROUP,     MEMP_NUM_IGMP_GROUP,      sizeof(struct igmp_group),     "IGMP_GROUP")
N#endif /* LWIP_IGMP */
N
N#if (!NO_SYS || (NO_SYS && !NO_SYS_NO_TIMERS)) /* LWIP_TIMERS */
X#if (!1 || (1 && !1))  
SLWIP_MEMPOOL(SYS_TIMEOUT,    MEMP_NUM_SYS_TIMEOUT,     sizeof(struct sys_timeo),      "SYS_TIMEOUT")
N#endif /* LWIP_TIMERS */
N
N#if LWIP_SNMP
X#if 0
SLWIP_MEMPOOL(SNMP_ROOTNODE,  MEMP_NUM_SNMP_ROOTNODE,   sizeof(struct mib_list_rootnode), "SNMP_ROOTNODE")
SLWIP_MEMPOOL(SNMP_NODE,      MEMP_NUM_SNMP_NODE,       sizeof(struct mib_list_node),     "SNMP_NODE")
SLWIP_MEMPOOL(SNMP_VARBIND,   MEMP_NUM_SNMP_VARBIND,    sizeof(struct snmp_varbind),      "SNMP_VARBIND")
SLWIP_MEMPOOL(SNMP_VALUE,     MEMP_NUM_SNMP_VALUE,      SNMP_MAX_VALUE_SIZE,              "SNMP_VALUE")
N#endif /* LWIP_SNMP */
N#if LWIP_DNS && LWIP_SOCKET
X#if 1 && 0
SLWIP_MEMPOOL(NETDB,          MEMP_NUM_NETDB,           NETDB_ELEM_SIZE,               "NETDB")
N#endif /* LWIP_DNS && LWIP_SOCKET */
N#if LWIP_DNS && DNS_LOCAL_HOSTLIST && DNS_LOCAL_HOSTLIST_IS_DYNAMIC
X#if 1 && 0 && 1
SLWIP_MEMPOOL(LOCALHOSTLIST,  MEMP_NUM_LOCALHOSTLIST,   LOCALHOSTLIST_ELEM_SIZE,       "LOCALHOSTLIST")
N#endif /* LWIP_DNS && DNS_LOCAL_HOSTLIST && DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
N#if PPP_SUPPORT && PPPOE_SUPPORT
X#if 0 && 0
SLWIP_MEMPOOL(PPPOE_IF,      MEMP_NUM_PPPOE_INTERFACES, sizeof(struct pppoe_softc),    "PPPOE_IF")
N#endif /* PPP_SUPPORT && PPPOE_SUPPORT */
N
N/*
N * A list of pools of pbuf's used by LWIP.
N *
N * LWIP_PBUF_MEMPOOL(pool_name, number_elements, pbuf_payload_size, pool_description)
N *     creates a pool name MEMP_pool_name. description is used in stats.c
N *     This allocates enough space for the pbuf struct and a payload.
N *     (Example: pbuf_payload_size=0 allocates only size for the struct)
N */
NLWIP_PBUF_MEMPOOL(PBUF,      MEMP_NUM_PBUF,            0,                             "PBUF_REF/ROM")
XMEMP_PBUF,
NLWIP_PBUF_MEMPOOL(PBUF_POOL, PBUF_POOL_SIZE,           PBUF_POOL_BUFSIZE,             "PBUF_POOL")
XMEMP_PBUF_POOL,
N
N
N/*
N * Allow for user-defined pools; this must be explicitly set in lwipopts.h
N * since the default is to NOT look for lwippools.h
N */
N#if MEMP_USE_CUSTOM_POOLS
X#if 0
S#include "lwippools.h"
N#endif /* MEMP_USE_CUSTOM_POOLS */
N
N/*
N * REQUIRED CLEANUP: Clear up so we don't get "multiply defined" error later
N * (#undef is ignored for something that is not defined)
N */
N#undef LWIP_MEMPOOL
N#undef LWIP_MALLOC_MEMPOOL
N#undef LWIP_MALLOC_MEMPOOL_START
N#undef LWIP_MALLOC_MEMPOOL_END
N#undef LWIP_PBUF_MEMPOOL
L 46 "..\..\Lwip\lwip-1.4.1\src\include\lwip/memp.h" 2
N  MEMP_MAX
N} memp_t;
N
N#if MEM_USE_POOLS
X#if 0
S/* Use a helper type to get the start and end of the user "memory pools" for mem_malloc */
Stypedef enum {
S    /* Get the first (via:
S       MEMP_POOL_HELPER_START = ((u8_t) 1*MEMP_POOL_A + 0*MEMP_POOL_B + 0*MEMP_POOL_C + 0)*/
S    MEMP_POOL_HELPER_FIRST = ((u8_t)
S#define LWIP_MEMPOOL(name,num,size,desc)
S#define LWIP_MALLOC_MEMPOOL_START 1
S#define LWIP_MALLOC_MEMPOOL(num, size) * MEMP_POOL_##size + 0
S#define LWIP_MALLOC_MEMPOOL_END
S#include "lwip/memp_std.h"
S    ) ,
S    /* Get the last (via:
S       MEMP_POOL_HELPER_END = ((u8_t) 0 + MEMP_POOL_A*0 + MEMP_POOL_B*0 + MEMP_POOL_C*1) */
S    MEMP_POOL_HELPER_LAST = ((u8_t)
S#define LWIP_MEMPOOL(name,num,size,desc)
S#define LWIP_MALLOC_MEMPOOL_START
S#define LWIP_MALLOC_MEMPOOL(num, size) 0 + MEMP_POOL_##size *
S#define LWIP_MALLOC_MEMPOOL_END 1
S#include "lwip/memp_std.h"
S    )
S} memp_pool_helper_t;
S
S/* The actual start and stop values are here (cast them over)
S   We use this helper type and these defines so we can avoid using const memp_t values */
S#define MEMP_POOL_FIRST ((memp_t) MEMP_POOL_HELPER_FIRST)
S#define MEMP_POOL_LAST   ((memp_t) MEMP_POOL_HELPER_LAST)
N#endif /* MEM_USE_POOLS */
N
N#if MEMP_MEM_MALLOC || MEM_USE_POOLS
X#if 0 || 0
Sextern const u16_t memp_sizes[MEMP_MAX];
N#endif /* MEMP_MEM_MALLOC || MEM_USE_POOLS */
N
N#if MEMP_MEM_MALLOC
X#if 0
S
S#include "mem.h"
S
S#define memp_init()
S#define memp_malloc(type)     mem_malloc(memp_sizes[type])
S#define memp_free(type, mem)  mem_free(mem)
S
N#else /* MEMP_MEM_MALLOC */
N
N#if MEM_USE_POOLS
X#if 0
S/** This structure is used to save the pool one element came from. */
Sstruct memp_malloc_helper
S{
S   memp_t poolnr;
S};
N#endif /* MEM_USE_POOLS */
N
Nvoid  memp_init(void);
N
N#if MEMP_OVERFLOW_CHECK
X#if 0
Svoid *memp_malloc_fn(memp_t type, const char* file, const int line);
S#define memp_malloc(t) memp_malloc_fn((t), __FILE__, __LINE__)
N#else
Nvoid *memp_malloc(memp_t type);
N#endif
Nvoid  memp_free(memp_t type, void *mem);
N
N#endif /* MEMP_MEM_MALLOC */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __LWIP_MEMP_H__ */
L 39 "..\..\Lwip\lwip-1.4.1\src\include\lwip/stats.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#if LWIP_STATS
X#if 0
S
S#ifndef LWIP_STATS_LARGE
S#define LWIP_STATS_LARGE 0
S#endif
S
S#if LWIP_STATS_LARGE
S#define STAT_COUNTER     u32_t
S#define STAT_COUNTER_F   U32_F
S#else
S#define STAT_COUNTER     u16_t
S#define STAT_COUNTER_F   U16_F
S#endif 
S
Sstruct stats_proto {
S  STAT_COUNTER xmit;             /* Transmitted packets. */
S  STAT_COUNTER recv;             /* Received packets. */
S  STAT_COUNTER fw;               /* Forwarded packets. */
S  STAT_COUNTER drop;             /* Dropped packets. */
S  STAT_COUNTER chkerr;           /* Checksum error. */
S  STAT_COUNTER lenerr;           /* Invalid length error. */
S  STAT_COUNTER memerr;           /* Out of memory error. */
S  STAT_COUNTER rterr;            /* Routing error. */
S  STAT_COUNTER proterr;          /* Protocol error. */
S  STAT_COUNTER opterr;           /* Error in options. */
S  STAT_COUNTER err;              /* Misc error. */
S  STAT_COUNTER cachehit;
S};
S
Sstruct stats_igmp {
S  STAT_COUNTER xmit;             /* Transmitted packets. */
S  STAT_COUNTER recv;             /* Received packets. */
S  STAT_COUNTER drop;             /* Dropped packets. */
S  STAT_COUNTER chkerr;           /* Checksum error. */
S  STAT_COUNTER lenerr;           /* Invalid length error. */
S  STAT_COUNTER memerr;           /* Out of memory error. */
S  STAT_COUNTER proterr;          /* Protocol error. */
S  STAT_COUNTER rx_v1;            /* Received v1 frames. */
S  STAT_COUNTER rx_group;         /* Received group-specific queries. */
S  STAT_COUNTER rx_general;       /* Received general queries. */
S  STAT_COUNTER rx_report;        /* Received reports. */
S  STAT_COUNTER tx_join;          /* Sent joins. */
S  STAT_COUNTER tx_leave;         /* Sent leaves. */
S  STAT_COUNTER tx_report;        /* Sent reports. */
S};
S
Sstruct stats_mem {
S#ifdef LWIP_DEBUG
S  const char *name;
S#endif /* LWIP_DEBUG */
S  mem_size_t avail;
S  mem_size_t used;
S  mem_size_t max;
S  STAT_COUNTER err;
S  STAT_COUNTER illegal;
S};
S
Sstruct stats_syselem {
S  STAT_COUNTER used;
S  STAT_COUNTER max;
S  STAT_COUNTER err;
S};
S
Sstruct stats_sys {
S  struct stats_syselem sem;
S  struct stats_syselem mutex;
S  struct stats_syselem mbox;
S};
S
Sstruct stats_ {
S#if LINK_STATS
S  struct stats_proto link;
S#endif
S#if ETHARP_STATS
S  struct stats_proto etharp;
S#endif
S#if IPFRAG_STATS
S  struct stats_proto ip_frag;
S#endif
S#if IP_STATS
S  struct stats_proto ip;
S#endif
S#if ICMP_STATS
S  struct stats_proto icmp;
S#endif
S#if IGMP_STATS
S  struct stats_igmp igmp;
S#endif
S#if UDP_STATS
S  struct stats_proto udp;
S#endif
S#if TCP_STATS
S  struct stats_proto tcp;
S#endif
S#if MEM_STATS
S  struct stats_mem mem;
S#endif
S#if MEMP_STATS
S  struct stats_mem memp[MEMP_MAX];
S#endif
S#if SYS_STATS
S  struct stats_sys sys;
S#endif
S};
S
Sextern struct stats_ lwip_stats;
S
Svoid stats_init(void);
S
S#define STATS_INC(x) ++lwip_stats.x
S#define STATS_DEC(x) --lwip_stats.x
S#define STATS_INC_USED(x, y) do { lwip_stats.x.used += y; \
S                                if (lwip_stats.x.max < lwip_stats.x.used) { \
S                                    lwip_stats.x.max = lwip_stats.x.used; \
S                                } \
S                             } while(0)
X#define STATS_INC_USED(x, y) do { lwip_stats.x.used += y;                                 if (lwip_stats.x.max < lwip_stats.x.used) {                                     lwip_stats.x.max = lwip_stats.x.used;                                 }                              } while(0)
N#else /* LWIP_STATS */
N#define stats_init()
N#define STATS_INC(x)
N#define STATS_DEC(x)
N#define STATS_INC_USED(x)
N#endif /* LWIP_STATS */
N
N#if TCP_STATS
X#if 0
S#define TCP_STATS_INC(x) STATS_INC(x)
S#define TCP_STATS_DISPLAY() stats_display_proto(&lwip_stats.tcp, "TCP")
N#else
N#define TCP_STATS_INC(x)
N#define TCP_STATS_DISPLAY()
N#endif
N
N#if UDP_STATS
X#if 0
S#define UDP_STATS_INC(x) STATS_INC(x)
S#define UDP_STATS_DISPLAY() stats_display_proto(&lwip_stats.udp, "UDP")
N#else
N#define UDP_STATS_INC(x)
N#define UDP_STATS_DISPLAY()
N#endif
N
N#if ICMP_STATS
X#if 0
S#define ICMP_STATS_INC(x) STATS_INC(x)
S#define ICMP_STATS_DISPLAY() stats_display_proto(&lwip_stats.icmp, "ICMP")
N#else
N#define ICMP_STATS_INC(x)
N#define ICMP_STATS_DISPLAY()
N#endif
N
N#if IGMP_STATS
X#if 0
S#define IGMP_STATS_INC(x) STATS_INC(x)
S#define IGMP_STATS_DISPLAY() stats_display_igmp(&lwip_stats.igmp)
N#else
N#define IGMP_STATS_INC(x)
N#define IGMP_STATS_DISPLAY()
N#endif
N
N#if IP_STATS
X#if 0
S#define IP_STATS_INC(x) STATS_INC(x)
S#define IP_STATS_DISPLAY() stats_display_proto(&lwip_stats.ip, "IP")
N#else
N#define IP_STATS_INC(x)
N#define IP_STATS_DISPLAY()
N#endif
N
N#if IPFRAG_STATS
X#if 0
S#define IPFRAG_STATS_INC(x) STATS_INC(x)
S#define IPFRAG_STATS_DISPLAY() stats_display_proto(&lwip_stats.ip_frag, "IP_FRAG")
N#else
N#define IPFRAG_STATS_INC(x)
N#define IPFRAG_STATS_DISPLAY()
N#endif
N
N#if ETHARP_STATS
S#define ETHARP_STATS_INC(x) STATS_INC(x)
S#define ETHARP_STATS_DISPLAY() stats_display_proto(&lwip_stats.etharp, "ETHARP")
N#else
N#define ETHARP_STATS_INC(x)
N#define ETHARP_STATS_DISPLAY()
N#endif
N
N#if LINK_STATS
X#if 0
S#define LINK_STATS_INC(x) STATS_INC(x)
S#define LINK_STATS_DISPLAY() stats_display_proto(&lwip_stats.link, "LINK")
N#else
N#define LINK_STATS_INC(x)
N#define LINK_STATS_DISPLAY()
N#endif
N
N#if MEM_STATS
X#if 0
S#define MEM_STATS_AVAIL(x, y) lwip_stats.mem.x = y
S#define MEM_STATS_INC(x) STATS_INC(mem.x)
S#define MEM_STATS_INC_USED(x, y) STATS_INC_USED(mem, y)
S#define MEM_STATS_DEC_USED(x, y) lwip_stats.mem.x -= y
S#define MEM_STATS_DISPLAY() stats_display_mem(&lwip_stats.mem, "HEAP")
N#else
N#define MEM_STATS_AVAIL(x, y)
N#define MEM_STATS_INC(x)
N#define MEM_STATS_INC_USED(x, y)
N#define MEM_STATS_DEC_USED(x, y)
N#define MEM_STATS_DISPLAY()
N#endif
N
N#if MEMP_STATS
X#if 0
S#define MEMP_STATS_AVAIL(x, i, y) lwip_stats.memp[i].x = y
S#define MEMP_STATS_INC(x, i) STATS_INC(memp[i].x)
S#define MEMP_STATS_DEC(x, i) STATS_DEC(memp[i].x)
S#define MEMP_STATS_INC_USED(x, i) STATS_INC_USED(memp[i], 1)
S#define MEMP_STATS_DISPLAY(i) stats_display_memp(&lwip_stats.memp[i], i)
N#else
N#define MEMP_STATS_AVAIL(x, i, y)
N#define MEMP_STATS_INC(x, i)
N#define MEMP_STATS_DEC(x, i)
N#define MEMP_STATS_INC_USED(x, i)
N#define MEMP_STATS_DISPLAY(i)
N#endif
N
N#if SYS_STATS
X#if 0
S#define SYS_STATS_INC(x) STATS_INC(sys.x)
S#define SYS_STATS_DEC(x) STATS_DEC(sys.x)
S#define SYS_STATS_INC_USED(x) STATS_INC_USED(sys.x, 1)
S#define SYS_STATS_DISPLAY() stats_display_sys(&lwip_stats.sys)
N#else
N#define SYS_STATS_INC(x)
N#define SYS_STATS_DEC(x)
N#define SYS_STATS_INC_USED(x)
N#define SYS_STATS_DISPLAY()
N#endif
N
N/* Display of statistics */
N#if LWIP_STATS_DISPLAY
X#if 0
Svoid stats_display(void);
Svoid stats_display_proto(struct stats_proto *proto, const char *name);
Svoid stats_display_igmp(struct stats_igmp *igmp);
Svoid stats_display_mem(struct stats_mem *mem, const char *name);
Svoid stats_display_memp(struct stats_mem *mem, int index);
Svoid stats_display_sys(struct stats_sys *sys);
N#else /* LWIP_STATS_DISPLAY */
N#define stats_display()
N#define stats_display_proto(proto, name)
N#define stats_display_igmp(igmp)
N#define stats_display_mem(mem, name)
N#define stats_display_memp(mem, index)
N#define stats_display_sys(sys)
N#endif /* LWIP_STATS_DISPLAY */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __LWIP_STATS_H__ */
L 51 "..\..\Lwip\App\STM8_FM17550_iap.h" 2
N#include "netconf.h"
N#include "LAN8742A.h"
N#include "memp.h"
N#include "./crc32/crc32.h"
L 1 "..\..\Ecal\./crc32/crc32.h" 1
N/******************************************************
N浠跺锛	crc32.h
N
N杩帮	
N
NData			  Vasion			author
N2018/7/13		  V1.0			    liujian
N*******************************************************/
N#ifndef		_CRC32_H
N#define		_CRC32_H
N/*******************************************************
Ndescription锛include the header file
N*******************************************************/
N#include "Include.h"
N
N
N/*******************************************************
Ndescription锛macro definitions
N*******************************************************/
N/**********瀹寮冲涔********/
N
N/**********瀹甯搁瀹涔********/
N
N
N
N/***********瀹芥**********/
N
N/*******************************************************
Ndescription锛struct definitions
N*******************************************************/
N
N/*******************************************************
Ndescription锛typedef definitions
N*******************************************************/
N/*****struct definitions*****/
N
N/******enum definitions******/
N
N/******union definitions*****/
N
N/*******************************************************
Ndescription锛variable External declaration
N*******************************************************/
N
N/*******************************************************
Ndescription锛function External declaration
N*******************************************************/
Nextern uint32 crc32(uint32 Le_dw_crc,uint8* Le_u_Dt, uint32 Le_dw_Lng);
N
N#endif
L 55 "..\..\Lwip\App\STM8_FM17550_iap.h" 2
N#include "tcp_client_ShortConnect.h"
L 1 "..\..\Lwip\App\tcp_client_ShortConnect.h" 1
N/**
N  ******************************************************************************
N  * @file    tcp_echoclient.h
N  * @author  MCD Application Team
N  * @version V1.1.0
N  * @date    31-July-2013 
N  * @brief   Header file for tcp_echoclient.c
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __TCP_ECHOCLIENT_H__
S#define __TCP_ECHOCLIENT_H__
S#include "./ZR60_Ctrl/ZR60_Ctrl.h"
S#include "./PeriStFliter/PSFltr.h"
S#include "Include.h"
S#include "STM8_FM17550_iap.h"
S#include "http_client_iap.h"
S//#define SHORTCNNT_HEART  //定义时，短连接需要发送心跳
S
S#define  CLIENT_SHORTCNNT_CARDNUM_LNG     4U
S#define  CLIENT_SHORTCNNT_LNG   	      1000U//发送数据长度
S#define  CLIENT_LOGRECORD_PERIOD   	  	  1150U//开锁记录周期，5s
S#define  CLIENT_DOORST_PERIOD   	  	  6000U//门锁状态上报周期30s
S#define  CLIENT_HEART_PERIOD   	  	  	  6000U//心跳周期，30s
S#define  CLIENT_LOGRECORD_NUM   	      5U//一次上报的log记录条数
S#define  SHORTCNNT_PULLBLIST_PERIOD   	  360000U//增量拉取黑名单周期,0.5h
S#define  SHORTCNNT_BLIST_PULLNUM   	  	  65//默认1次最多拉取卡号数量
S
S
S#define  CLIENT_SHORTCNNT_IDLE   	      0U
S#define  CLIENT_SHORTCNNT_WAIT 			  1U
S#define  CLIENT_SHORTCNNT_TXPCKT 		  2U//数据发送状态
S#define  CLIENT_SHORTCNNT_DISCNNT         3U
S
S#define  CLIENT_SHORTCNNT_REMOTEPORT     8090
S
S
S#ifdef USE_DHCP
S#define CLIENT_SHORTCNNT_DHCP_STATE    DHCP_state
S#else
S#define CLIENT_SHORTCNNT_DHCP_STATE    DHCP_ADDRESS_ASSIGNED
S#endif
S
S//宏函数定义
S#define Gettcp_client_u_DoorSt       GetPSFltr_u_PeriSt(DoorLock)
S#define Gettcp_client_u_LogAvild     GetUnlockLogCache_u_LogAvild()
S#define Gettcp_client_doorLog(x)     GetUnlockLogCache_doorLog(x)
S#define GetShortCnnt_PerformCondition     ((Gethttp_CnntTxSt() ==  0U) && (GetStm8_fm17550_iapIdle() == 1))
S
S
S#define tcp_client_BleMacFlg    Se_u_BleMacFlg//获取蓝牙mac标志
S
Stypedef enum
S{
S	Pckt_Unknow = 0U,/*未知类型*/
S	Pckt_Init,/*设备初始化信息*/
S#ifdef SHORTCNNT_HEART
S	Pckt_Heart,/*心跳*/
S#endif
S	Pckt_TempBuf,/*临时缓存区*/
S	Pckt_DoorSt,/*门锁状态*/
S	Pckt_OpenReport,/*开门记录*/
S	Pckt_BList/*拉取黑名单*/
S}tcp_client_TxPcktType;//当前发送的报文类型
S
S
Stypedef struct
S{
S	char TskFlag;//建立短连接任务标志
S	char InitFlag;//上报初始化信息上报任务执行标志
S#ifdef SHORTCNNT_HEART
S	char HeartFlag;//
S#endif
S	char DoorStFlag;//门锁状态上报任务执行标志
S	char ReportFlag;//开门记录上报任务执行标志
S	char BListFlag;//拉取黑名单任务执行标志
S	char EchoFlag;//报文响应标志：0--报文未发送；1--等待响应；2--响应成功
S	char BusyFlag;//忙标志
S	char PcktType;//当前正在发送的数据报文类型:见tcp_client_TxPcktType定义
S	char tokenOverdueFlag;//token过期标志
S}tcp_client_TxFlagStruct;
S
Stypedef struct
S{
S	char token[40];
S	char Listtype;//名单类型
S	uint64_t timestamp;//时间戳
S	uint64_t Oldtimestamp;//旧时间戳
S	uint32_t page;//页码
S	uint32_t Oldpage;//旧页码
S	uint16_t pageSize;//页码
S	uint8_t  UpdataFlag;//更新标志：0--全量更新；1--增量更新
S}tcp_client_BListPullStruct;
S
Stypedef struct
S{
S	char token[40];
S	char state;//门锁状态
S}tcp_client_doorStStruct;
S
Stypedef struct
S{
S	char doorID[33U];//门id,多出1字节存放'\0'
S	char mac[18U];//stm32 mac地址,12个字节存放地址字符，5个字节存放'：'，多出1字节存放'\0'
S	char addrtype;//地址类型信息：是无线的MAC地址，0不是无线的MAC地址
S	char Blemac[18U];//蓝牙mac地址,12个字节存放地址字符，5个字节存放'：'，多出1字节存放'\0'
S	char addrRecombineFlg;//地址重组标志：112233445566重组为11:22:33:44:55:66标志置位
S}tcp_client_DeviceInitStruct;
S
S
Stypedef struct
S{
S	char data[CLIENT_SHORTCNNT_LNG];//临时数据缓存buf
S	u16_t lng;//数据长度
S	char dtAlidity;//数据有效性
S	char txflag;//临时数据发送标志
S}tcp_client_TxTempBufStruct;
S
Stypedef struct
S{
S	char token[40];
S	char LogNum;//当前上报的开门记录条数
S	UnlockLogCacheStruct  Log[CLIENT_LOGRECORD_NUM];//开门记录缓存区
S}tcp_client_OpenLogStruct;
S
S
Stypedef struct 
S{
S	int sec;
S	int min;
S	int hour;
S	unsigned int  Timer;
S	char flag;
S}tcp_client_UpdateBListStruct;
S
Sextern tcp_client_BListPullStruct BListPull;
Sextern tcp_client_DeviceInitStruct  DeviceInit;
S
S/* Includes ------------------------------------------------------------------*/
S/* Exported types ------------------------------------------------------------*/
S/* Exported constants --------------------------------------------------------*/
S/* Exported macro ------------------------------------------------------------*/
S/* Exported functions ------------------------------------------------------- */
Sextern void tcp_ShortConnect_parameter(void);
Sextern void tcp_ShortConnect_MainFunction(void);
Sextern char tcp_ShortConnect_connect(void);
Sextern void tcp_ShortConnect_disconnect(void);
Sextern void tcp_ShortConnect_sendMsg(char* data,u16_t len);
Sextern u8_t Gettcp_shortCnntTxSt(void);
Sextern uint8_t tcp_client_BListUpdataSt(void);
N#endif /*  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 56 "..\..\Lwip\App\STM8_FM17550_iap.h" 2
N
N#define  STM8_FM17550_TXBUF   	      200U//发送数据长度
N
N#define  STM8_FM17550_IDLE   	     0U
N#define  STM8_FM17550_WAIT 			 1U
N#define  STM8_FM17550_LOADPCKT 		 2U//数据下载
N#define  STM8_FM17550_DISCNNT         3U
N
N#define  STM8_FM17550_DOWNLOAD_IDLE   	     0U
N#define  STM8_FM17550_DOWNLOAD_UNDERWAY 	 1U
N#define  STM8_FM17550_DOWNLOAD_FINISH 		 2U//数据下载完成
N
N#define  STM8_FM17550_NNT_REMOTEPORT     	 80
N
N
N#ifdef USE_DHCP
N#define STM8_FM17550_DHCP_STATE    DHCP_state
N#else
S#define STM8_FM17550_DHCP_STATE    DHCP_ADDRESS_ASSIGNED
N#endif
N
N/* Base address of the STM32 Flash sectors 以下是stm32的片上flash扇区基地址，不可修改*/
N#define ADDR_FLASH_SECTOR_0     ((uint32_t)0x08000000) /* Base @ of Sector 0, 16 Kbytes */
N#define ADDR_FLASH_SECTOR_1     ((uint32_t)0x08004000) /* Base @ of Sector 1, 16 Kbytes */
N#define ADDR_FLASH_SECTOR_2     ((uint32_t)0x08008000) /* Base @ of Sector 2, 16 Kbytes */
N#define ADDR_FLASH_SECTOR_3     ((uint32_t)0x0800C000) /* Base @ of Sector 3, 16 Kbytes */
N#define ADDR_FLASH_SECTOR_4     ((uint32_t)0x08010000) /* Base @ of Sector 4, 64 Kbytes */
N#define ADDR_FLASH_SECTOR_5     ((uint32_t)0x08020000) /* Base @ of Sector 5, 128 Kbytes */
N#define ADDR_FLASH_SECTOR_6     ((uint32_t)0x08040000) /* Base @ of Sector 6, 128 Kbytes */
N#define ADDR_FLASH_SECTOR_7     ((uint32_t)0x08060000) /* Base @ of Sector 7, 128 Kbytes */
N#define ADDR_FLASH_SECTOR_8     ((uint32_t)0x08080000) /* Base @ of Sector 8, 128 Kbytes */
N#define ADDR_FLASH_SECTOR_9     ((uint32_t)0x080A0000) /* Base @ of Sector 9, 128 Kbytes */
N#define ADDR_FLASH_SECTOR_10    ((uint32_t)0x080C0000) /* Base @ of Sector 10, 128 Kbytes */
N#define ADDR_FLASH_SECTOR_11    ((uint32_t)0x080E0000) /* Base @ of Sector 11, 128 Kbytes */
N
N#define STM8_FM17550_CODE_SEC  ADDR_FLASH_SECTOR_3//读卡器模块升级固件下载存放的扇区基地址
N//#define HTTP_CLIENT_UPLOAD_INFO_SEC ADDR_FLASH_SECTOR_3//读卡器模块升级固件下载存放的扇区基地址
N
N
N
N
N#define  STM8_FM17550_DOWNLOAD_DATA_LNG   	      (16*1024)//下载区大小（字节数）
N#define  STM8_FM17550_DOWNLOAD_TIMEOUT   	      6000//下载超时时间
N
N//宏函数定义
N#define stm8_fm17550_PerformCondition  (0U == Gettcp_shortCnntTxSt())
N
N
Ntypedef struct
N{
N	char TskFlag;//建立短连接任务标志
N	char downloadFlag;//下载任务执行标志
N	char EchoFlag;//usart发送指令/数据响应标志
N	char SlaveRxSt;//从机数据接收状态：0--ok
N	char TxBusyFlag;//主机<->从机，忙标志
N}stm8_fm17550_IapFlagStruct;//在线升级标志结构体
N
N
N#if 0
Stypedef struct
S{
S	char data[STM8_FM17550_TXBUF];//临时数据缓存buf
S	u16_t lng;//数据长度
S	char dtAlidity;//数据有效性
S	char txflag;//临时数据发送标志
S}stm8_fm17550_TxTempBufStruct;
N#endif
N
Ntypedef struct
N{
N	//uint32 Xor;/*本段数据异或取反校验和*/
N	uint32 DtFirstAddr;/*数据段首地址*/
N	//uint32 DtendAddr;/*数据段末地址*/
N	uint32 Lng;/*数据长度*/
N	uint32 CheckSum;/*升级区数据校验和*/
N	uint32 Cnt;/*字节计数器*/
N}stm8_fm17550_UpdataInfoStruct;//升级信息
N
Ntypedef union
N{
N	unsigned char FrmTx[70U];
N	struct
N	{
N		unsigned char Header;//帧头
N		unsigned char Seqnr;//数据帧包序号
N		unsigned char Cmd;//数据长度,0－数据，1－终止
N		unsigned char Lng;//数据长度
N		unsigned char Data[64];//数据
N		unsigned char CC;//校验和
N		unsigned char ETX;//结束字符
N	}Frame;
N}stm8_fm17550_Frame_Tx;
N
N
N/* Includes ------------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nextern void stm8_fm17550_iap_parameter(void);
Nextern void stm8_fm17550_iap_MainFunction(void);
Nextern void Setstm8_fm17550_SlaveReplySt(u8_t Le_u_St);
Nextern uint8_t GetStm8_fm17550_iapIdle(void);
N#endif /*  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 34 "..\..\Lwip\App\tcp_client_LngConnect.h" 2
N#include "http_client_iap.h"
L 1 "..\..\Lwip\App\http_client_iap.h" 1
N/**
N  ******************************************************************************
N  * @file    http_client_iap.h
N  * @author  MCD Application Team
N  * @version V1.1.0
N  * @date    31-July-2013 
N  * @brief   Header file for http_client_iap.c
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __HTTP_CLIENT_IAP_H__
N#define __HTTP_CLIENT_IAP_H__
N#include <stdio.h>
N#include <stdlib.h>
N#include <string.h>
N#include "MyType.h"
N#include "stm32f4xx_flash.h"
N#include "dnsAnalysis.h"
N/*Lwip库文件*/
N#include "lwip/init.h"
N#include "lwip/tcp.h"
N#include "lwip/udp.h"
N#include "netconf.h"
N#include "lwip/pbuf.h"
N//#include "lwipopts.h"
N//#include "lwip/opt.h"
N#include "lwip/ip_addr.h"
N#include "lwip/ip.h"
N#include "lwip/igmp.h"
N#include "lwip/dns.h"
N#include "lwip/debug.h"
N#include "lwip/stats.h"
N#include "netconf.h"
N#include "LAN8742A.h"
N#include "memp.h"
N#include "tcp_client_ShortConnect.h"
N
N#define  CLIENT_CNNT_LNG   	      200U//发送数据长度
N
N#define  CLIENT_CNNT_IDLE   	     0U
N#define  CLIENT_CNNT_WAIT 			 1U
N#define  CLIENT_CNNT_LOADPCKT 		 2U//数据下载
N#define  CLIENT_CNNT_DISCNNT         3U
N
N#define  DOWNLOAD_IDLE   	     0U
N#define  DOWNLOAD_UNDERWAY 		 1U
N#define  DOWNLOAD_FINISH 		 2U//数据下载完成
N
N#define  CLIENT_CNNT_REMOTEPORT     80
N
N
N#ifdef USE_DHCP
N#define CLIENT_CNNT_DHCP_STATE    DHCP_state
N#else
S#define CLIENT_CNNT_DHCP_STATE    DHCP_ADDRESS_ASSIGNED
N#endif
N
N/* Base address of the STM32 Flash sectors 以下是stm32的片上flash扇区基地址，不可修改*/
N#define ADDR_FLASH_SECTOR_0     ((uint32_t)0x08000000) /* Base @ of Sector 0, 16 Kbytes */
N#define ADDR_FLASH_SECTOR_1     ((uint32_t)0x08004000) /* Base @ of Sector 1, 16 Kbytes */
N#define ADDR_FLASH_SECTOR_2     ((uint32_t)0x08008000) /* Base @ of Sector 2, 16 Kbytes */
N#define ADDR_FLASH_SECTOR_3     ((uint32_t)0x0800C000) /* Base @ of Sector 3, 16 Kbytes */
N#define ADDR_FLASH_SECTOR_4     ((uint32_t)0x08010000) /* Base @ of Sector 4, 64 Kbytes */
N#define ADDR_FLASH_SECTOR_5     ((uint32_t)0x08020000) /* Base @ of Sector 5, 128 Kbytes */
N#define ADDR_FLASH_SECTOR_6     ((uint32_t)0x08040000) /* Base @ of Sector 6, 128 Kbytes */
N#define ADDR_FLASH_SECTOR_7     ((uint32_t)0x08060000) /* Base @ of Sector 7, 128 Kbytes */
N#define ADDR_FLASH_SECTOR_8     ((uint32_t)0x08080000) /* Base @ of Sector 8, 128 Kbytes */
N#define ADDR_FLASH_SECTOR_9     ((uint32_t)0x080A0000) /* Base @ of Sector 9, 128 Kbytes */
N#define ADDR_FLASH_SECTOR_10    ((uint32_t)0x080C0000) /* Base @ of Sector 10, 128 Kbytes */
N#define ADDR_FLASH_SECTOR_11    ((uint32_t)0x080E0000) /* Base @ of Sector 11, 128 Kbytes */
N
N#define HTTP_CLIENT_UPLOAD_INFO_SEC ADDR_FLASH_SECTOR_2//升级信息存放的扇区基地址
N#define HTTP_CLIENT_USERCODE_SEC1 ADDR_FLASH_SECTOR_9//用户下载代码存放的扇区基地址
N#define HTTP_CLIENT_USERCODE_SEC2 ADDR_FLASH_SECTOR_10//用户下载代码存放的扇区基地址
N#define HTTP_CLIENT_USERCODE_SEC3 ADDR_FLASH_SECTOR_11//用户下载代码存放的扇区基地址
N
N
N#define  CLIENT_DOWNLOAD_DATA_LNG   	      (128*3*1024)//下载区大小（字节数）
N
N//宏函数定义
N#define http_Client_PerformCondition (0U == Gettcp_shortCnntTxSt())
N
N
Ntypedef struct
N{
N	char TskFlag;//建立短连接任务标志
N	char downloadFlag;//下载任务执行标志
N}http_client_TxFlagStruct;
N
N
N#if 0
Stypedef struct
S{
S	char data[CLIENT_CNNT_LNG];//临时数据缓存buf
S	u16_t lng;//数据长度
S	char dtAlidity;//数据有效性
S	char txflag;//临时数据发送标志
S}http_client_TxTempBufStruct;
N#endif
N
Ntypedef struct
N{
N	uint32 Xor;/*本段数据异或取反校验和*/
N	uint32 DtFirstAddr;/*数据段首地址*/
N	uint32 DtendAddr;/*数据段末地址*/
N	uint32 Lng;/*数据长度*/
N	uint32 CheckSum;/*升级区数据校验和*/
N	uint32 IapFlag;/*在线升级标志*/
N}http_client_UpdataInfoStruct;//升级信息
N
N
N/* Includes ------------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nextern void http_client_iap_parameter(void);
Nextern void http_client_iap_MainFunction(void);
Nextern char http_client_iap_connect(void);
Nextern void http_client_iap_disconnect(void);
Nextern void http_client_iap_sendMsg(char* data,u16_t len);
Nextern u8_t Gethttp_CnntTxSt(void);
N#endif /*  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 35 "..\..\Lwip\App\tcp_client_LngConnect.h" 2
N#define  CLIENT_LNGCNNT_PERIOD   	      6600U
N
N
N#define  CLIENT_LNGCNNT_IDLE   	   0U
N#define  CLIENT_LNGCNNT_CNNT       1U
N#define  CLIENT_LNGCNNT_DISCNNT    2U
N
N
N#define CLIENT_LNGCNNT_DEVICETYPE   machine_type
N#ifdef USE_DHCP
N#define CLIENT_LNGCNNT_DHCP_STATE    DHCP_state
N#else
S#define CLIENT_LNGCNNT_DHCP_STATE    DHCP_ADDRESS_ASSIGNED
N#endif
N
N
N#define GetLngCnnt_PerformCondition     ((Gethttp_CnntTxSt() ==  0U) && (GetStm8_fm17550_iapIdle() == 1))
N
Ntypedef struct
N{
N	char Alias[38U];//别名
N	unsigned char lng;//有效位长度
N}tcp_client_Struct;
N
Nextern tcp_client_Struct  Setcp_Alias;
Nextern u8_t  volatile Setcp_client_u_Open;//远程开锁标志
N/* Includes ------------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nextern void tcp_LngConnect_Parameter(void);
Nextern void tcp_LngConnect_MainFunction(void);
Nextern char tcp_LngConnect_Connect(void);
Nextern void tcp_LngConnect_disconnect(void);
Nextern void tcp_LngConnect_sendMsg(char* data,u16_t len);
Nextern uint8 Gettcp_u_LngConnect_Timeout(void);
N#endif /**/
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 16 "..\..\APP\./ZR60_Ctrl/ZR60_Ctrl.h" 2
N/*******************************************************
Ndescription： macro definitions
N*******************************************************/
N/**********宏开关定义*********/
N
N/**********宏常量定义*********/
N/*接收宏定义*/
N//#define	 UARTCMN_USART		USART3
N
N#define ZR60_CTRL_REMOTE_UNLOCK    Setcp_client_u_Open
N
N#define ZR60_CTRL_AUTOSEARCHCARD   isSectedCard_flag
N#define ZR60_CTRL_SETKEY   		   Sereadcard_SetKeyflag
N
N#define ZR60_CTRL_SETCARD          setcard
N
N/***********宏函数***********/
N
N
N/*******************************************************
Ndescription： struct definitions
N*******************************************************/
N
N/*******************************************************
Ndescription： typedef definitions
N*******************************************************/
N/*****struct definitions*****/
N
N
N/******enum definitions******/
N
N/******union definitions*****/
N
N/*******************************************************
Ndescription： variable External declaration
N*******************************************************/
Nextern struct sm3_info sm;
Nextern struct rtc_time Ve_h_tm;
Nextern const char CeZR60Ctrl_u_SoftVersion[10U];//软件版本
N/*******************************************************
Ndescription： function External declaration
N*******************************************************/
Nextern void  InitZR60Ctrl_parameter(void);
Nextern void  TskZR60Ctrl_MainFunction(void);
Nextern uint8_t	GetZR60Ctrl_u_Alarm(void);
Nextern uint8_t	GetZR60Ctrl_u_CardSetSt(void);
Nextern void SetZR60Ctrl_u_PasswordKey(void);
Nextern void ClrZR60Ctrl_BleSt(void);
Nextern void ClrZR60Ctrl_BleCnntTimeout(void);
Nextern char ZR60Ctrl_u_ArrayCmp(unsigned char *a,unsigned char *b, unsigned int len);
N#endif 
L 32 "..\..\Lwip\App\tcp_client_ShortConnect.h" 2
N#include "./PeriStFliter/PSFltr.h"
L 1 "..\..\Ecal\./PeriStFliter/PSFltr.h" 1
N/******************************************************
N文件名：	PSFltr
N
N描述：		
N
NData			  Vasion			author
N2018/6/28		   V1.0			    liujian
N*******************************************************/
N#ifndef		PSFLTR_H
N#define		PSFLTR_H
N/*******************************************************
Ndescription： include the header file
N*******************************************************/
N#include	"PSFltr_Cfg.h"
L 1 "..\..\Ecal\./PeriStFliter/PSFltr_Cfg.h" 1
N/******************************************************
N文件名：	PSFltr_Cfg
N
N描述：		 
N
NData			  Vasion			author
N2018/6/28		   V1.0			    liujian      
N*******************************************************/
N#ifndef		PSFLTR_CFG_H
N#define		PSFLTR_CFG_H
N/*******************************************************
Ndescription： include the header file
N*******************************************************/
N#include "Include.h"
N
N
N/*******************************************************
Ndescription： macro definitions
N*******************************************************/
N/**********宏开关定义*********/
N
N
N/**********宏常量定义*********/
N#define  PSFLTR_NUM     	1U/*外设数量*/
N
N
N
N#define  PSFLTR_FLTRTIME   10U/*外设开关状态滤波时间门限*/
N
N
N/***********宏函数***********/
N
N/*******************************************************
Ndescription： struct definitions
N*******************************************************/
N
N/*******************************************************
Ndescription： typedef definitions
N*******************************************************/
N/*****struct definitions*****/
Ntypedef struct
N{
N	uint8 e_u_PSt;/*外设开/关状态*/
N	uint8 e_u_OnFltrCnt;/*开/关开启状态滤波计时器*/
N	uint8 e_u_OffFltrCnt;/*开/关关闭状态滤波计时器*/
N}PSFltrStruct;
N
N
N/******enum definitions******/
Ntypedef enum
N{
N	DoorLock	  /*门锁*/
N}PSFltrEnum;
N
N/******union definitions*****/
N
N/*******************************************************
Ndescription： variable External declaration
N*******************************************************/
Nextern const uint8  CaPSFltr_u_Active[PSFLTR_NUM];
Xextern const uint8  CaPSFltr_u_Active[1U];
N
N
N/*******************************************************
Ndescription： function External declaration
N*******************************************************/
Nextern uint8 GetPSFltrCfg_u_RTSt(uint8 LePSFltr_u_Index);
N    
N#endif
N
L 15 "..\..\Ecal\./PeriStFliter/PSFltr.h" 2
N
N/*******************************************************
Ndescription： macro definitions
N*******************************************************/
N/**********宏开关定义*********/
N
N
N/**********宏常量定义*********/
N
N
N/***********宏函数***********/
N
N/*******************************************************
Ndescription： struct definitions
N*******************************************************/
N
N/*******************************************************
Ndescription： typedef definitions
N*******************************************************/
N/*****struct definitions*****/
N
N/******enum definitions******/
N
N/******union definitions*****/
N
N/*******************************************************
Ndescription： variable External declaration
N*******************************************************/
N
N/*******************************************************
Ndescription： function External declaration
N*******************************************************/
Nextern void InitPSFltr_Parameter(void);
Nextern void TskPSFltr_MainFunction(void);
Nextern uint8 GetPSFltr_u_PeriSt(uint8 LePSFltr_u_Index);
N#endif
L 33 "..\..\Lwip\App\tcp_client_ShortConnect.h" 2
N#include "Include.h"
N#include "STM8_FM17550_iap.h"
N#include "http_client_iap.h"
N//#define SHORTCNNT_HEART  //定义时，短连接需要发送心跳
N
N#define  CLIENT_SHORTCNNT_CARDNUM_LNG     4U
N#define  CLIENT_SHORTCNNT_LNG   	      1000U//发送数据长度
N#define  CLIENT_LOGRECORD_PERIOD   	  	  1150U//开锁记录周期，5s
N#define  CLIENT_DOORST_PERIOD   	  	  6000U//门锁状态上报周期30s
N#define  CLIENT_HEART_PERIOD   	  	  	  6000U//心跳周期，30s
N#define  CLIENT_LOGRECORD_NUM   	      5U//一次上报的log记录条数
N#define  SHORTCNNT_PULLBLIST_PERIOD   	  360000U//增量拉取黑名单周期,0.5h
N#define  SHORTCNNT_BLIST_PULLNUM   	  	  65//默认1次最多拉取卡号数量
N
N
N#define  CLIENT_SHORTCNNT_IDLE   	      0U
N#define  CLIENT_SHORTCNNT_WAIT 			  1U
N#define  CLIENT_SHORTCNNT_TXPCKT 		  2U//数据发送状态
N#define  CLIENT_SHORTCNNT_DISCNNT         3U
N
N#define  CLIENT_SHORTCNNT_REMOTEPORT     8090
N
N
N#ifdef USE_DHCP
N#define CLIENT_SHORTCNNT_DHCP_STATE    DHCP_state
N#else
S#define CLIENT_SHORTCNNT_DHCP_STATE    DHCP_ADDRESS_ASSIGNED
N#endif
N
N//宏函数定义
N#define Gettcp_client_u_DoorSt       GetPSFltr_u_PeriSt(DoorLock)
N#define Gettcp_client_u_LogAvild     GetUnlockLogCache_u_LogAvild()
N#define Gettcp_client_doorLog(x)     GetUnlockLogCache_doorLog(x)
N#define GetShortCnnt_PerformCondition     ((Gethttp_CnntTxSt() ==  0U) && (GetStm8_fm17550_iapIdle() == 1))
N
N
N#define tcp_client_BleMacFlg    Se_u_BleMacFlg//获取蓝牙mac标志
N
Ntypedef enum
N{
N	Pckt_Unknow = 0U,/*未知类型*/
N	Pckt_Init,/*设备初始化信息*/
N#ifdef SHORTCNNT_HEART
S	Pckt_Heart,/*心跳*/
N#endif
N	Pckt_TempBuf,/*临时缓存区*/
N	Pckt_DoorSt,/*门锁状态*/
N	Pckt_OpenReport,/*开门记录*/
N	Pckt_BList/*拉取黑名单*/
N}tcp_client_TxPcktType;//当前发送的报文类型
N
N
Ntypedef struct
N{
N	char TskFlag;//建立短连接任务标志
N	char InitFlag;//上报初始化信息上报任务执行标志
N#ifdef SHORTCNNT_HEART
S	char HeartFlag;//
N#endif
N	char DoorStFlag;//门锁状态上报任务执行标志
N	char ReportFlag;//开门记录上报任务执行标志
N	char BListFlag;//拉取黑名单任务执行标志
N	char EchoFlag;//报文响应标志：0--报文未发送；1--等待响应；2--响应成功
N	char BusyFlag;//忙标志
N	char PcktType;//当前正在发送的数据报文类型:见tcp_client_TxPcktType定义
N	char tokenOverdueFlag;//token过期标志
N}tcp_client_TxFlagStruct;
N
Ntypedef struct
N{
N	char token[40];
N	char Listtype;//名单类型
N	uint64_t timestamp;//时间戳
N	uint64_t Oldtimestamp;//旧时间戳
N	uint32_t page;//页码
N	uint32_t Oldpage;//旧页码
N	uint16_t pageSize;//页码
N	uint8_t  UpdataFlag;//更新标志：0--全量更新；1--增量更新
N}tcp_client_BListPullStruct;
N
Ntypedef struct
N{
N	char token[40];
N	char state;//门锁状态
N}tcp_client_doorStStruct;
N
Ntypedef struct
N{
N	char doorID[33U];//门id,多出1字节存放'\0'
N	char mac[18U];//stm32 mac地址,12个字节存放地址字符，5个字节存放'：'，多出1字节存放'\0'
N	char addrtype;//地址类型信息：是无线的MAC地址，0不是无线的MAC地址
N	char Blemac[18U];//蓝牙mac地址,12个字节存放地址字符，5个字节存放'：'，多出1字节存放'\0'
N	char addrRecombineFlg;//地址重组标志：112233445566重组为11:22:33:44:55:66标志置位
N}tcp_client_DeviceInitStruct;
N
N
Ntypedef struct
N{
N	char data[CLIENT_SHORTCNNT_LNG];//临时数据缓存buf
X	char data[1000U];
N	u16_t lng;//数据长度
N	char dtAlidity;//数据有效性
N	char txflag;//临时数据发送标志
N}tcp_client_TxTempBufStruct;
N
Ntypedef struct
N{
N	char token[40];
N	char LogNum;//当前上报的开门记录条数
N	UnlockLogCacheStruct  Log[CLIENT_LOGRECORD_NUM];//开门记录缓存区
X	UnlockLogCacheStruct  Log[5U];
N}tcp_client_OpenLogStruct;
N
N
Ntypedef struct 
N{
N	int sec;
N	int min;
N	int hour;
N	unsigned int  Timer;
N	char flag;
N}tcp_client_UpdateBListStruct;
N
Nextern tcp_client_BListPullStruct BListPull;
Nextern tcp_client_DeviceInitStruct  DeviceInit;
N
N/* Includes ------------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nextern void tcp_ShortConnect_parameter(void);
Nextern void tcp_ShortConnect_MainFunction(void);
Nextern char tcp_ShortConnect_connect(void);
Nextern void tcp_ShortConnect_disconnect(void);
Nextern void tcp_ShortConnect_sendMsg(char* data,u16_t len);
Nextern u8_t Gettcp_shortCnntTxSt(void);
Nextern uint8_t tcp_client_BListUpdataSt(void);
N#endif /*  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 76 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "tcp_client_LngConnect.h"
N#include "dnsAnalysis.h"
N#include "ntpclient.h"
L 1 "..\..\Lwip\App\ntpclient.h" 1
N/******************************************************
N文件名：	ntpclient
N
N描述：		
N
NData			  Vasion			author
N2018/6/12		V1.0			  liujian
N*******************************************************/
N#ifndef		NTPCLIENT_H
N#define		NTPCLIENT_H
N/*******************************************************
Ndescription： include the header file
N*******************************************************/
N#include	"Include.h"
N
N/*******************************************************
Ndescription： macro definitions
N*******************************************************/
N/**********宏开关定义*********/
N#define NTPCLIENT_TSK_PERIOD        750000U//大概1h
N
N#define NTPCLIENT_SRC_PORT          0
N#define NTPCLIENT_REMOTE_PORT       123//ntp服务器对应的udp端口号
N#define NTPCLIENT_SEVER_NUM         6//ntp服务器数
N
N#define NTP_PKT_LEN        		    48   //48bytes
N#define NTP_LI_NO_WARNING          (0x00<<6) //no warning
N#define NTP_VERSION                (4/* NTP Version 4*/<<3) 
N#define NTP_MODE_CLIENT            0x03
N#define NTP_MODE_SERVER            0x04
N#define NTP_MODE_BROADCAST         0x05
N#define NTP_MODE_MASK              0x07
N#define RECEIVE_TS_OFFSET          32 // Receive_Timestamp offset
N#define TRANSMIT_TS_OFFSET         40 //Transmit_Timestamp offset
N/* number of seconds between 1900 and 1970 */
N#define DIFF_SEC_1900_1970         (2208988800)
N#define SEC_TIME_ZONE              + (8*60*60) //Beijing,GMT+8
N
N#define UDP_FLAGS_UNCONNECTED  0U
N#define  NTP_FLGS_CONNECTED    0x04U
N#define  NTP_CONNECT_TIMEOUT   500
N
N
N#ifdef USE_DHCP
N#define NTP_DHCP_STATE    DHCP_state
N#else
S#define NTP_DHCP_STATE    DHCP_ADDRESS_ASSIGNED
N#endif
N/**********宏常量定义*********/
N
N
N/***********宏函数***********/
N
N/*******************************************************
Ndescription： struct definitions
N*******************************************************/
Ntypedef struct
N{
N	char SubsIndex;//下标索引
N	struct ip_addr SrcIP;//源IP
N	struct ip_addr remoteIP;//目的IP
N	char TxBusyFlag;//发送忙标志:0--空闲；1--忙
N	char echoFlag;//响应标志：0--空闲；1--等待回应；2--收到回应
N}ntpclient_struct;
N
N
Ntypedef struct
N{
N
N    uint8_t li_vn_mode;      // Eight bits. li, vn, and mode.
N	// li.   Two bits.   Leap indicator.
N	// vn.   Three bits. Version number of the protocol.
N	// mode. Three bits. Client will pick mode 3 for client.
N
N    uint8_t stratum;         // Eight bits. Stratum level of the local clock.
N    uint8_t poll;            // Eight bits. Maximum interval between successive messages.
N    uint8_t precision;       // Eight bits. Precision of the local clock.
N
N    uint32_t rootDelay;      // 32 bits. Total round trip delay time.
N    uint32_t rootDispersion; // 32 bits. Max error aloud from primary clock source.
N    uint32_t refId;          // 32 bits. Reference clock identifier.
N
N    uint32_t refTm_s;        // 32 bits. Reference time-stamp seconds.
N    uint32_t refTm_f;        // 32 bits. Reference time-stamp fraction of a second.
N
N    uint32_t origTm_s;       // 32 bits. Originate time-stamp seconds.
N    uint32_t origTm_f;       // 32 bits. Originate time-stamp fraction of a second.
N
N    uint32_t rxTm_s;         // 32 bits. Received time-stamp seconds.
N    uint32_t rxTm_f;         // 32 bits. Received time-stamp fraction of a second.
N
N    uint32_t txTm_s;         // 32 bits and the most important field the client cares about. Transmit time-stamp seconds.
N    uint32_t txTm_f;         // 32 bits. Transmit time-stamp fraction of a second.
N
N} ntp_packet;              // Total: 384 bits or 48 bytes.
N
N
N
N
N/*******************************************************
Ndescription： typedef definitions
N*******************************************************/
N/*****struct definitions*****/
N
N/******enum definitions******/
N
N/******union definitions*****/
N
N/*******************************************************
Ndescription： variable External declaration
N*******************************************************/
N
N/*******************************************************
Ndescription： function External declaration
N*******************************************************/
Nextern void Initntpclient_Pramater(void);
Nextern void Tskntpclient_MainFunction(void);
Nextern void ntpclient_breakTimer(void);
Nextern uint8 Getntpclient_u_TSUpdate(void);
Nextern uint32 Getntpclient_dw_NetTimestamp(void);
N#endif
L 79 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "dhcpClient.h"
L 1 "..\..\Lwip\App\dhcpClient.h" 1
N/******************************************************
N文件名：	dhcpClient
N
N描述：		
N
NData			  Vasion			author
N2018/06/25		  V1.0			    liujian
N*******************************************************/
N#ifndef		_DHCP_CLIENT_H
N#define		_DHCP_CLIENT_H
N/*******************************************************
Ndescription： include the header file
N*******************************************************/
N#include "Include.h"
N
N/*******************************************************
Ndescription： macro definitions
N*******************************************************/
N/**********宏开关定义*********/
N
N/**********宏常量定义*********/
N
N
N/***********宏函数***********/
N
N
N/*******************************************************
Ndescription： struct definitions
N*******************************************************/
N
N/*******************************************************
Ndescription： typedef definitions
N*******************************************************/
N/*****struct definitions*****/
N
N/******union definitions*****/
N
N/*******************************************************
Ndescription： variable External declaration
N*******************************************************/
N
N
N
N/*******************************************************
Ndescription： function External declaration
N*******************************************************/
Nextern void InitdhcpClient_parameter(void);
Nextern void TskdhcpClient_MainFunction(void);
N
N#endif 
L 80 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "JsonIf.h"
L 1 "..\..\Ecal\JsonIf\JsonIf.h" 1
N/******************************************************
N文件名：	Json
N
N描述：		
N
NData			  Vasion			author
N2017/7/22		   V1.0			    liujian
N*******************************************************/
N#ifndef		_JSON_H
N#define		_JSON_H
N/*******************************************************
Ndescription： include the header file
N*******************************************************/
N#include	"Include.h"
N
N/*******************************************************
Ndescription： macro definitions
N*******************************************************/
N/**********宏开关定义*********/
N
N
N/**********宏常量定义*********/
N#define JSON_HEART_BEAT     0U
N#define JSON_GET_BLIST      1U
N#define JSON_REPORT_DOORST  2U
N#define JSON_REPORT_UNLOCKLOG  3U
N#define JSON_DEVICE_INIT  4U
N#define JSON_DEVICE_ECHO_REMOTEUNLOCK  5U
N
N/***********宏函数***********/
N
N/*******************************************************
Ndescription： struct definitions
N*******************************************************/
N
N/*******************************************************
Ndescription： typedef definitions
N*******************************************************/
N/*****struct definitions*****/
N
N/******enum definitions******/
N
N/******union definitions*****/
N
N/*******************************************************
Ndescription： variable External declaration
N*******************************************************/
N
N/*******************************************************
Ndescription： function External declaration
N*******************************************************/
Nextern void Json_HexToJson(void *Le_u_in,uint16* Len,unsigned char type, char *Le_u_out);
Nextern void Json_HexToStr(char *pszDest, unsigned char *pbSrc, int nLen);
Nextern uint32 Json_DecNumber(const char* str);
N#endif
L 81 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "cJSON.h"
L 1 "..\..\Ecal\JsonIf\cJSON.h" 1
N/*
N  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors
N
N  Permission is hereby granted, free of charge, to any person obtaining a copy
N  of this software and associated documentation files (the "Software"), to deal
N  in the Software without restriction, including without limitation the rights
N  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N  copies of the Software, and to permit persons to whom the Software is
N  furnished to do so, subject to the following conditions:
N
N  The above copyright notice and this permission notice shall be included in
N  all copies or substantial portions of the Software.
N
N  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
N  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
N  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
N  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
N  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
N  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
N  THE SOFTWARE.
N*/
N
N#ifndef cJSON__h
N#define cJSON__h
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* project version */
N#define CJSON_VERSION_MAJOR 1
N#define CJSON_VERSION_MINOR 7
N#define CJSON_VERSION_PATCH 6
N
N#include <stddef.h>
L 1 "d:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199901L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 37 "..\..\Ecal\JsonIf\cJSON.h" 2
N
N/* cJSON Types: */
N#define cJSON_Invalid (0)
N#define cJSON_False  (1 << 0)
N#define cJSON_True   (1 << 1)
N#define cJSON_NULL   (1 << 2)
N#define cJSON_Number (1 << 3)
N#define cJSON_String (1 << 4)
N#define cJSON_Array  (1 << 5)
N#define cJSON_Object (1 << 6)
N#define cJSON_Raw    (1 << 7) /* raw json */
N
N#define cJSON_IsReference 256
N#define cJSON_StringIsConst 512
N
N/* The cJSON structure: */
Ntypedef struct cJSON
N{
N    /* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */
N    struct cJSON *next;
N    struct cJSON *prev;
N    /* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */
N    struct cJSON *child;
N
N    /* The type of the item, as above. */
N    int type;
N
N    /* The item's string, if type==cJSON_String  and type == cJSON_Raw */
N    char *valuestring;
N    /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */
N    int valueint;
N    /* The item's number, if type==cJSON_Number */
N    double valuedouble;
N
N    /* The item's name string, if this item is the child of, or is in the list of subitems of an object. */
N    char *string;
N} cJSON;
N
Ntypedef struct cJSON_Hooks
N{
N      void *(*malloc_fn)(size_t sz);
N      void (*free_fn)(void *ptr);
N} cJSON_Hooks;
N
Ntypedef int cJSON_bool;
N
N#if !defined(__WINDOWS__) && (defined(WIN32) || defined(WIN64) || defined(_MSC_VER) || defined(_WIN32))
X#if !0L && (0L || 0L || 0L || 0L)
S#define __WINDOWS__
N#endif
N#ifdef __WINDOWS__
S
S/* When compiling for windows, we specify a specific calling convention to avoid issues where we are being called from a project with a different default calling convention.  For windows you have 2 define options:
S
SCJSON_HIDE_SYMBOLS - Define this in the case where you don't want to ever dllexport symbols
SCJSON_EXPORT_SYMBOLS - Define this on library build when you want to dllexport symbols (default)
SCJSON_IMPORT_SYMBOLS - Define this if you want to dllimport symbol
S
SFor *nix builds that support visibility attribute, you can define similar behavior by
S
Ssetting default visibility to hidden by adding
S-fvisibility=hidden (for gcc)
Sor
S-xldscope=hidden (for sun cc)
Sto CFLAGS
S
Sthen using the CJSON_API_VISIBILITY flag to "export" the same symbols the way CJSON_EXPORT_SYMBOLS does
S
S*/
S
S/* export symbols by default, this is necessary for copy pasting the C and header file */
S#if !defined(CJSON_HIDE_SYMBOLS) && !defined(CJSON_IMPORT_SYMBOLS) && !defined(CJSON_EXPORT_SYMBOLS)
S#define CJSON_EXPORT_SYMBOLS
S#endif
S
S#if defined(CJSON_HIDE_SYMBOLS)
S#define CJSON_PUBLIC(type)   type __stdcall
S#elif defined(CJSON_EXPORT_SYMBOLS)
S#define CJSON_PUBLIC(type)   __declspec(dllexport) type __stdcall
S#elif defined(CJSON_IMPORT_SYMBOLS)
S#define CJSON_PUBLIC(type)   __declspec(dllimport) type __stdcall
S#endif
N#else /* !WIN32 */
N#if (defined(__GNUC__) || defined(__SUNPRO_CC) || defined (__SUNPRO_C)) && defined(CJSON_API_VISIBILITY)
X#if (0L || 0L || 0L) && 0L
S#define CJSON_PUBLIC(type)   __attribute__((visibility("default"))) type
N#else
N#define CJSON_PUBLIC(type) type
N#endif
N#endif
N
N/* Limits how deeply nested arrays/objects can be before cJSON rejects to parse them.
N * This is to prevent stack overflows. */
N#ifndef CJSON_NESTING_LIMIT
N#define CJSON_NESTING_LIMIT 1000
N#endif
N
N/* returns the version of cJSON as a string */
NCJSON_PUBLIC(const char*) cJSON_Version(void);
Xconst char* cJSON_Version(void);
N
N/* Supply malloc, realloc and free functions to cJSON */
NCJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks);
Xvoid cJSON_InitHooks(cJSON_Hooks* hooks);
N
N/* Memory Management: the caller is always responsible to free the results from all variants of cJSON_Parse (with cJSON_Delete) and cJSON_Print (with stdlib free, cJSON_Hooks.free_fn, or cJSON_free as appropriate). The exception is cJSON_PrintPreallocated, where the caller has full responsibility of the buffer. */
N/* Supply a block of JSON, and this returns a cJSON object you can interrogate. */
NCJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value);
XcJSON * cJSON_Parse(const char *value);
N/* ParseWithOpts allows you to require (and check) that the JSON is null terminated, and to retrieve the pointer to the final byte parsed. */
N/* If you supply a ptr in return_parse_end and parsing fails, then return_parse_end will contain a pointer to the error so will match cJSON_GetErrorPtr(). */
NCJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated);
XcJSON * cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated);
N
N/* Render a cJSON entity to text for transfer/storage. */
NCJSON_PUBLIC(char *) cJSON_Print(const cJSON *item);
Xchar * cJSON_Print(const cJSON *item);
N/* Render a cJSON entity to text for transfer/storage without any formatting. */
NCJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item);
Xchar * cJSON_PrintUnformatted(const cJSON *item);
N/* Render a cJSON entity to text using a buffered strategy. prebuffer is a guess at the final size. guessing well reduces reallocation. fmt=0 gives unformatted, =1 gives formatted */
NCJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt);
Xchar * cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt);
N/* Render a cJSON entity to text using a buffer already allocated in memory with given length. Returns 1 on success and 0 on failure. */
N/* NOTE: cJSON is not always 100% accurate in estimating how much memory it will use, so to be safe allocate 5 bytes more than you actually need */
NCJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format);
XcJSON_bool cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format);
N/* Delete a cJSON entity and all subentities. */
NCJSON_PUBLIC(void) cJSON_Delete(cJSON *c);
Xvoid cJSON_Delete(cJSON *c);
N
N/* Returns the number of items in an array (or object). */
NCJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array);
Xint cJSON_GetArraySize(const cJSON *array);
N/* Retrieve item number "item" from array "array". Returns NULL if unsuccessful. */
NCJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index);
XcJSON * cJSON_GetArrayItem(const cJSON *array, int index);
N/* Get item "string" from object. Case insensitive. */
NCJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string);
XcJSON * cJSON_GetObjectItem(const cJSON * const object, const char * const string);
NCJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string);
XcJSON * cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string);
NCJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string);
XcJSON_bool cJSON_HasObjectItem(const cJSON *object, const char *string);
N/* For analysing failed parses. This returns a pointer to the parse error. You'll probably need to look a few chars back to make sense of it. Defined when cJSON_Parse() returns 0. 0 when cJSON_Parse() succeeds. */
NCJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void);
Xconst char * cJSON_GetErrorPtr(void);
N
N/* Check if the item is a string and return its valuestring */
NCJSON_PUBLIC(char *) cJSON_GetStringValue(cJSON *item);
Xchar * cJSON_GetStringValue(cJSON *item);
N
N/* These functions check the type of an item */
NCJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item);
XcJSON_bool cJSON_IsInvalid(const cJSON * const item);
NCJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item);
XcJSON_bool cJSON_IsFalse(const cJSON * const item);
NCJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item);
XcJSON_bool cJSON_IsTrue(const cJSON * const item);
NCJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item);
XcJSON_bool cJSON_IsBool(const cJSON * const item);
NCJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item);
XcJSON_bool cJSON_IsNull(const cJSON * const item);
NCJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item);
XcJSON_bool cJSON_IsNumber(const cJSON * const item);
NCJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item);
XcJSON_bool cJSON_IsString(const cJSON * const item);
NCJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item);
XcJSON_bool cJSON_IsArray(const cJSON * const item);
NCJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item);
XcJSON_bool cJSON_IsObject(const cJSON * const item);
NCJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON * const item);
XcJSON_bool cJSON_IsRaw(const cJSON * const item);
N
N/* These calls create a cJSON item of the appropriate type. */
NCJSON_PUBLIC(cJSON *) cJSON_CreateNull(void);
XcJSON * cJSON_CreateNull(void);
NCJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void);
XcJSON * cJSON_CreateTrue(void);
NCJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void);
XcJSON * cJSON_CreateFalse(void);
NCJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool boolean);
XcJSON * cJSON_CreateBool(cJSON_bool boolean);
NCJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num);
XcJSON * cJSON_CreateNumber(double num);
NCJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string);
XcJSON * cJSON_CreateString(const char *string);
N/* raw json */
NCJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char *raw);
XcJSON * cJSON_CreateRaw(const char *raw);
NCJSON_PUBLIC(cJSON *) cJSON_CreateArray(void);
XcJSON * cJSON_CreateArray(void);
NCJSON_PUBLIC(cJSON *) cJSON_CreateObject(void);
XcJSON * cJSON_CreateObject(void);
N
N/* Create a string where valuestring references a string so
N * it will not be freed by cJSON_Delete */
NCJSON_PUBLIC(cJSON *) cJSON_CreateStringReference(const char *string);
XcJSON * cJSON_CreateStringReference(const char *string);
N/* Create an object/arrray that only references it's elements so
N * they will not be freed by cJSON_Delete */
NCJSON_PUBLIC(cJSON *) cJSON_CreateObjectReference(const cJSON *child);
XcJSON * cJSON_CreateObjectReference(const cJSON *child);
NCJSON_PUBLIC(cJSON *) cJSON_CreateArrayReference(const cJSON *child);
XcJSON * cJSON_CreateArrayReference(const cJSON *child);
N
N/* These utilities create an Array of count items. */
NCJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count);
XcJSON * cJSON_CreateIntArray(const int *numbers, int count);
NCJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count);
XcJSON * cJSON_CreateFloatArray(const float *numbers, int count);
NCJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count);
XcJSON * cJSON_CreateDoubleArray(const double *numbers, int count);
NCJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char **strings, int count);
XcJSON * cJSON_CreateStringArray(const char **strings, int count);
N
N/* Append item to the specified array/object. */
NCJSON_PUBLIC(void) cJSON_AddItemToArray(cJSON *array, cJSON *item);
Xvoid cJSON_AddItemToArray(cJSON *array, cJSON *item);
NCJSON_PUBLIC(void) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item);
Xvoid cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item);
N/* Use this when string is definitely const (i.e. a literal, or as good as), and will definitely survive the cJSON object.
N * WARNING: When this function was used, make sure to always check that (item->type & cJSON_StringIsConst) is zero before
N * writing to `item->string` */
NCJSON_PUBLIC(void) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item);
Xvoid cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item);
N/* Append reference to item to the specified array/object. Use this when you want to add an existing cJSON to a new cJSON, but don't want to corrupt your existing cJSON. */
NCJSON_PUBLIC(void) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item);
Xvoid cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item);
NCJSON_PUBLIC(void) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item);
Xvoid cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item);
N
N/* Remove/Detatch items from Arrays/Objects. */
NCJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item);
XcJSON * cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item);
NCJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which);
XcJSON * cJSON_DetachItemFromArray(cJSON *array, int which);
NCJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which);
Xvoid cJSON_DeleteItemFromArray(cJSON *array, int which);
NCJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string);
XcJSON * cJSON_DetachItemFromObject(cJSON *object, const char *string);
NCJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string);
XcJSON * cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string);
NCJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string);
Xvoid cJSON_DeleteItemFromObject(cJSON *object, const char *string);
NCJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string);
Xvoid cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string);
N
N/* Update array items. */
NCJSON_PUBLIC(void) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem); /* Shifts pre-existing items to the right. */
Xvoid cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem);  
NCJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement);
XcJSON_bool cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement);
NCJSON_PUBLIC(void) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem);
Xvoid cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem);
NCJSON_PUBLIC(void) cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);
Xvoid cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);
NCJSON_PUBLIC(void) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object,const char *string,cJSON *newitem);
Xvoid cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object,const char *string,cJSON *newitem);
N
N/* Duplicate a cJSON item */
NCJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse);
XcJSON * cJSON_Duplicate(const cJSON *item, cJSON_bool recurse);
N/* Duplicate will create a new, identical cJSON item to the one you pass, in new memory that will
Nneed to be released. With recurse!=0, it will duplicate any children connected to the item.
NThe item->next and ->prev pointers are always zero on return from Duplicate. */
N/* Recursively compare two cJSON items for equality. If either a or b is NULL or invalid, they will be considered unequal.
N * case_sensitive determines if object keys are treated case sensitive (1) or case insensitive (0) */
NCJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive);
XcJSON_bool cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive);
N
N
NCJSON_PUBLIC(void) cJSON_Minify(char *json);
Xvoid cJSON_Minify(char *json);
N
N/* Helper functions for creating and adding items to an object at the same time.
N * They return the added item or NULL on failure. */
NCJSON_PUBLIC(cJSON*) cJSON_AddNullToObject(cJSON * const object, const char * const name);
XcJSON* cJSON_AddNullToObject(cJSON * const object, const char * const name);
NCJSON_PUBLIC(cJSON*) cJSON_AddTrueToObject(cJSON * const object, const char * const name);
XcJSON* cJSON_AddTrueToObject(cJSON * const object, const char * const name);
NCJSON_PUBLIC(cJSON*) cJSON_AddFalseToObject(cJSON * const object, const char * const name);
XcJSON* cJSON_AddFalseToObject(cJSON * const object, const char * const name);
NCJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean);
XcJSON* cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean);
NCJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number);
XcJSON* cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number);
NCJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string);
XcJSON* cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string);
NCJSON_PUBLIC(cJSON*) cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw);
XcJSON* cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw);
NCJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name);
XcJSON* cJSON_AddObjectToObject(cJSON * const object, const char * const name);
NCJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name);
XcJSON* cJSON_AddArrayToObject(cJSON * const object, const char * const name);
N
N/* When assigning an integer value, it needs to be propagated to valuedouble too. */
N#define cJSON_SetIntValue(object, number) ((object) ? (object)->valueint = (object)->valuedouble = (number) : (number))
N/* helper for the cJSON_SetNumberValue macro */
NCJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number);
Xdouble cJSON_SetNumberHelper(cJSON *object, double number);
N#define cJSON_SetNumberValue(object, number) ((object != NULL) ? cJSON_SetNumberHelper(object, (double)number) : (number))
N
N/* Macro for iterating over an array or object */
N#define cJSON_ArrayForEach(element, array) for(element = (array != NULL) ? (array)->child : NULL; element != NULL; element = element->next)
N
N/* malloc/free objects using the malloc/free functions that have been set with cJSON_InitHooks */
NCJSON_PUBLIC(void *) cJSON_malloc(size_t size);
Xvoid * cJSON_malloc(size_t size);
NCJSON_PUBLIC(void) cJSON_free(void *object);
Xvoid cJSON_free(void *object);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 82 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "./STD_ADFliter/STD_ADFliter.h"
L 1 "..\..\Ecal\./STD_ADFliter/STD_ADFliter.h" 1
N/******************************************************
N文件名：	STD_ADFliter
N
N描述：		
N
NData			  Vasion			author
N2018/6/27		V1.0			  liujian
N*******************************************************/
N#ifndef		STD_ADFLITER_H
N#define		STD_ADFLITER_H
N/*******************************************************
Ndescription： include the header file
N*******************************************************/
N#include	"STD_ADFliterCfg.h"
L 1 "..\..\Ecal\./STD_ADFliter/STD_ADFliterCfg.h" 1
N/******************************************************
N文件名：	STD_ADFliterCfg
N
N描述：		 
N
NData			  Vasion			author
N2018/6/27		V1.0			  liujian         
N*******************************************************/
N#ifndef		STD_ADFLITER_CFG_H
N#define		STD_ADFLITER_CFG_H
N/*******************************************************
Ndescription： include the header file
N*******************************************************/
N#include	"STD_ADFliterTypes.h"
L 1 "..\..\Ecal\./STD_ADFliter/STD_ADFliterTypes.h" 1
N/******************************************************
N文件名：	STD_ADFliterTypes
N
N描述：		
N
NData			  Vasion			author
N2018/6/27		V1.0			  liujian
N*******************************************************/
N#ifndef		STD_ADFLITER_TYPES_H
N#define		STD_ADFLITER_TYPES_H
N/*******************************************************
Ndescription： include the header file
N*******************************************************/
N#include	"Include.h"
N
N/*******************************************************
Ndescription： macro definitions
N*******************************************************/
N/**********宏开关定义*********/
N
N
N/**********宏常量定义*********/
N#define  ADFLITERTYPES_PWRONFASTFLITER      0//上电快速滤波状态机
N#define  ADFLITERTYPES_NORMALFLITER         1//上电完毕正常滤波状态机
N
N
N/***********宏函数***********/
N
N/*******************************************************
Ndescription： struct definitions
N*******************************************************/
N
N/*******************************************************
Ndescription： typedef definitions
N*******************************************************/
N/*****struct definitions*****/
N
N/******enum definitions******/
N
N/******union definitions*****/
N
N/*******************************************************
Ndescription： variable External declaration
N*******************************************************/
N
N/*******************************************************
Ndescription： function External declaration
N*******************************************************/
N
N
N#endif
L 15 "..\..\Ecal\./STD_ADFliter/STD_ADFliterCfg.h" 2
N
N/*******************************************************
Ndescription： macro definitions
N*******************************************************/
N/**********宏开关定义*********/
N
N
N/**********宏常量定义*********/
N#define   ADFLITERCFG_ADARRAYLENGTH_MAX      	10//存储AD数值的数组最大长度
N#define   ADFLITERCFG_CHANNELNUM             	1//AD通道数
N
N/***********宏函数***********/
N #define   GetADFliter_sw_ADSampleData(ADChannelIndex)    ADC_ConvertedValue
N/*******************************************************
Ndescription： struct definitions
N*******************************************************/
N
N/*******************************************************
Ndescription： typedef definitions
N*******************************************************/
N/*****struct definitions*****/
Ntypedef struct 
N{
N  uint8 e_u_FliterArrayFullFlag;//滤波数组填充满标志
N  int 	e_sw_ADData[ADFLITERCFG_ADARRAYLENGTH_MAX];//存储AD值的数组
X  int 	e_sw_ADData[10];
N  uint8 e_u_ADDataCnt;//AD滤波数组填充计数器
N  int16 e_sw_ADResult; //滤波处理的结果  
N}TsADFliter_h_FliterParm;//AD滤波参数
N
N
N/******enum definitions******/
N//typedef enum
N//{
N  
N//}
N
N/******union definitions*****/
N
N/*******************************************************
Ndescription： variable External declaration
N*******************************************************/
Nextern const uint8 CaADFliter_u_ADChannelIndex[ADFLITERCFG_CHANNELNUM];//从底层获获取AD采样值的通道索引
Xextern const uint8 CaADFliter_u_ADChannelIndex[1];
Nextern const int16 CaADFliter_sw_DefaultADResult[ADFLITERCFG_CHANNELNUM]; //上电缺省AD值
Xextern const int16 CaADFliter_sw_DefaultADResult[1]; 
Nextern const uint8 CaADFliter_u_ADDataSampleNum[ADFLITERCFG_CHANNELNUM]; //各滤波数组中存储的AD数据采样个数
Xextern const uint8 CaADFliter_u_ADDataSampleNum[1]; 
Nextern const uint8 CaADFliter_u_GetADTimeReach;   //获取AD数据的延时时间到
N/*******************************************************
Ndescription： function External declaration
N*******************************************************/
N
N    
N#endif
N
L 15 "..\..\Ecal\./STD_ADFliter/STD_ADFliter.h" 2
N
N/*******************************************************
Ndescription： macro definitions
N*******************************************************/
N/**********宏开关定义*********/
N
N
N/**********宏常量定义*********/
N
N
N/***********宏函数***********/
N
N/*******************************************************
Ndescription： struct definitions
N*******************************************************/
N
N/*******************************************************
Ndescription： typedef definitions
N*******************************************************/
N/*****struct definitions*****/
N
N/******enum definitions******/
N
N/******union definitions*****/
N
N/*******************************************************
Ndescription： variable External declaration
N*******************************************************/
N
N/*******************************************************
Ndescription： function External declaration
N*******************************************************/
Nextern void InitADFliter_parameter(void);
Nextern void MngADFliter_mainFunction(void);
Nextern int16 GetADFliter_ADFliterResult(uint8 LeADFliter_u_IndexCH);
N
N#endif
L 83 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "./PeriStFliter/PSFltr.h"
N#include "./crc32/crc32.h"
N#include "http_client_iap.h"
N#include "STM8_FM17550_iap.h"
N
N//App
N#include "./ZR60_Ctrl/ZR60_Ctrl.h"
N#include "BListMng.h"
L 1 "..\..\APP\BlackListMng\BListMng.h" 1
N/******************************************************
N浠跺锛	BListMng.h
N
N杩帮	
N
NData			  Vasion			author
N2018/4/12		  V1.0			    liujian
N*******************************************************/
N#ifndef		BLISTMNG_H
N#define		BLISTMNG_H
N/*******************************************************
Ndescription锛include the header file
N*******************************************************/
N#include "BListMng_cfg.h"
L 1 "..\..\APP\BlackListMng\BListMng_cfg.h" 1
N/******************************************************
N文件名：	BListMng_cfg.h
N
N描述）
N
NData			  Vasion			author
N2018/04/12		  V1.0			    liujian
N*******************************************************/
N#ifndef		BLISTMNG_CFG_H
N#define		BLISTMNG_CFG_H
N/*******************************************************
Ndescription?nclude the header file
N*******************************************************/
N#include "Include.h"
N
N/*******************************************************
Ndescription?acro definitions
N*******************************************************/
N/**********宏开关定e*******/
N//#define TEST
N//#define BLISTMNG_SAVEPOWEROFF
N
N/**********宏常量定e*******/
N/********************************************************/
N//设计支持的黑名单卡号数量2000，卡号分到10个数据块存储
N
N
N#define BLISTMNG_CARD_NO_LNG     4//卡号长度
N#define BLISTMNG_CARD_NUM        200//卡号数据RAM缓存区大小
N
N
N#define BLISTMNG_BLIST_NUM      	 10U//黑名单数据块数量
N
N
N/********************************************************/
N
N
N/***********宏函*********/
N
N/*******************************************************
Ndescription?truct definitions
N*******************************************************/
N
N/*******************************************************
Ndescription?ypedef definitions
N*******************************************************/
N/*****struct definitions*****/
Ntypedef struct 
N{
N	uint8   CardNum[BLISTMNG_CARD_NO_LNG];/*卡号*/
X	uint8   CardNum[4]; 
N}BListMng_cardNumStruct;
N
N
Ntypedef struct 
N{
N	uint8  validity;
N	uint16  lng;
N	BListMng_cardNumStruct  CardNumArray[BLISTMNG_CARD_NUM];
X	BListMng_cardNumStruct  CardNumArray[200];
N}BListMng_Struct;
N
N/******enum definitions******/
N
N
N
N/******union definitions*****/
N
N
N
N
N/*******************************************************
Ndescription?ariable External declaration
N*******************************************************/
Nextern BListMng_Struct  CardNumCache[BLISTMNG_BLIST_NUM];
Xextern BListMng_Struct  CardNumCache[10U];
Nextern BListMng_Struct  CardNumCacheBkUp[BLISTMNG_BLIST_NUM];
Xextern BListMng_Struct  CardNumCacheBkUp[10U];
Nextern const uint8 CeBListMng_u_BlockIndex[BLISTMNG_BLIST_NUM];
Xextern const uint8 CeBListMng_u_BlockIndex[10U];
Nextern BListMng_cardNumStruct CARD_Array[BLISTMNG_CARD_NUM];
Xextern BListMng_cardNumStruct CARD_Array[200];
N/*******************************************************
Ndescription?unction External declaration
N*******************************************************/
Nextern void BListMngCfg_WrEE(uint8 Le_u_Obj,uint8* Le_u_Data,uint16 Le_w_Lng);
Nextern void BListMngCfg_RdEE(uint8 Le_u_Obj,uint8* Le_u_Data,uint16 Le_w_Lng);
Nextern uint8  GetBListMngCfg_EEIdle(void);
Nextern uint8  GetBListMngCfg_u_DtVild(uint8 Obj);
Nextern uint16 GetBListMngCfg_w_DtLng(uint8 Obj);
N#endif
L 15 "..\..\APP\BlackListMng\BListMng.h" 2
N#include "MyType.h"
N#include "stm32f4xx.h"
N
N/*******************************************************
Ndescription锛macro definitions
N*******************************************************/
N/**********瀹寮冲涔********/
N
N/**********瀹甯搁瀹涔********/
N
N
N
N/***********瀹芥**********/
N
N/*******************************************************
Ndescription锛struct definitions
N*******************************************************/
N
N
N/*******************************************************
Ndescription锛typedef definitions
N*******************************************************/
N/*****struct definitions*****/
N
N/******enum definitions******/
N
N/******union definitions*****/
N
N/*******************************************************
Ndescription锛variable External declaration
N*******************************************************/
N
N
N/*******************************************************
Ndescription锛function External declaration
N*******************************************************/
Nextern void BListMng_Init(void);
Nextern void TskBListMng_MainFunction(void);
Nextern uint8 BListMng_u_ContrastBList(uint32 Le_dw_data);
Nextern void ClrBListMng_ListData(void);
N#endif
L 91 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "./readcard/readcard.h"
L 1 "..\..\APP\./readcard/readcard.h" 1
N#ifndef __READCARD_H
N#define	__READCARD_H
N
N
N
N#include "stm32f4xx.h"
N#include <stdio.h>
N#include "./wdata/wdata.h"
N#include "Include.h"
N
N
N#define OK  			0x00//正确获取卡号
N
N#define QUIT  0x1e           // 上一次发送命令时被打断
N#define COMM_ERR  0xff       // 串行通信错误
N#define NO_TAG_ERR  0x01     // 在有效期内没有卡
N#define CRC_ERR  2           // 从卡中接收到了错误的CRC校验和
N#define NOT_AUTH_ERR  0x0a   // 卡没有验证
N#define PARITY_ERR  5        // 从卡中接收到了错误的效验位
N#define BIT_COUNT_ERR  0x0b  // 从卡中接收到了错误数量的位
N
N
N
N #define On_Card  0x00
N        /**
N         * 加载key
N         */
N#define Load_Key  0x01
N
N        /**
N         * 激活卡片并获取卡片号
N         */
N#define Get_CardSnr  0x02
N
N        /**
N         * 设置为主动检查卡片模式 IDLE模式
N         */
N#define SetDetectCard_ALL  0x03
N
N        /**
N         * 扇区0x14 存储了小区ID信息communityId
N         */
N#define Block_0x14  0x14
N
N        /**
N         * 扇区0x15 存储了楼栋编号信息buildNum1
N         */
N#define Block_0x15  0x15
N
N        /**
N         * 扇区0x16 村粗了楼栋编号信息buildNum2
N         */
N#define Block_0x16  0x16
N
N/**
N * 扇区0x18 楼栋id
N */
N#define Block_0x18  0x18
N
N/**
N * 扇区0x19 门id
N */
N#define Block_0x19  0x19
N
N/**
N * 扇区0x20 下标
N */
N#define Block_0x1A  0x1a
N
N        /**
N         * 数据块10, 旧IC卡存储用户ID块
N         */
N#define Block_0x10  0x10
N
N        /**
N         * 数据块11, 旧IC卡存储手机号码的块
N         */
N#define Block_0x11 0x11
N
N#define ReadCard_VrfyCardNumber(x)  BListMng_u_ContrastBList(x)
N#define ReadCard_CardSetSt   GetZR60Ctrl_u_CardSetSt
N
N#define ReadCard_DEVICE_TYPE  machine_type
N
Ntypedef struct 
N{		
N	char CardID[4U];//卡号
N	char lng;//卡号长
N}CardNumInfo; /*卡号信息结构体*/ 
N
N
N
Ntypedef struct 
N{		
N	union
N	{
N		unsigned char Block[59];/*接收数据数*/
N		struct
N		{
N			unsigned char Seqnr;/* 接收帧包号*/
N			unsigned char St;/* 状态*/
N			unsigned char DtLng;/* 接收有效数据段长度表示*/
N			unsigned char ValidDt[56];/* 接收的有效数据段：按最大长度定义存储空间*/
N		}DtSrt;
N	}Dt;
N}RebackInfo; /*报文接收结构体*/ 
N
N
Nextern uint8_t volatile Sereadcard_SetKeyflag;
Nextern uint8_t volatile open_door;
Nextern uint8_t volatile setcard ;
Nextern uint8_t volatile isSectedCard_flag;
Nextern struct comm_info sminfo;
Nextern struct comm_info sminfo1;
Nextern RebackInfo  rebackinfo;
Nextern CardNumInfo SeReadcard_h_CardID;//当前开门使用的ic卡卡号
N
N
Nextern void handleMsg(RebackInfo rebackInfo);
Nextern void Setreadcard_AutoSearchCard(void);
Nextern void Setreadcard_Key(void);
N
N#endif
L 92 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N
N/*Lwip库文件*/
N#include "lwip/init.h"
N#include "lwip/tcp.h"
N#include "lwip/udp.h"
N#include "netconf.h"
N#include "lwip/pbuf.h"
N//#include "lwipopts.h"
N//#include "lwip/opt.h"
N#include "lwip/ip_addr.h"
N#include "lwip/ip.h"
N#include "lwip/igmp.h"
N#include "lwip/dns.h"
N
N//freeRTOS
N#include "FreeRTOS.h"
L 1 "..\..\FreeRTOS\Source\include\FreeRTOS.h" 1
N/*
N    FreeRTOS V8.2.2 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef INC_FREERTOS_H
N#define INC_FREERTOS_H
N
N/*
N * Include the generic headers required for the FreeRTOS port being used.
N */
N#include <stddef.h>
N
N/*
N * If stdint.h cannot be located then:
N *   + If using GCC ensure the -nostdint options is *not* being used.
N *   + Ensure the project's include path includes the directory in which your
N *     compiler stores stdint.h.
N *   + Set any compiler options necessary for it to support C99, as technically
N *     stdint.h is only mandatory with C99 (FreeRTOS does not require C99 in any
N *     other way).
N *   + The FreeRTOS download includes a simple stdint.h definition that can be
N *     used in cases where none is provided by the compiler.  The files only
N *     contains the typedefs required to build FreeRTOS.  Read the instructions
N *     in FreeRTOS/source/stdint.readme for more information.
N */
N#include <stdint.h> /* READ COMMENT ABOVE. */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Application specific configuration options. */
N#include "FreeRTOSConfig.h"
L 1 "..\..\FreeRTOS\FreeRTOSConfig.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N    This file is part of the FreeRTOS distribution.
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N    1 tab == 4 spaces!
N*/
N 
N 
N#ifndef FREERTOS_CONFIG_H
N#define FREERTOS_CONFIG_H
N 
N/*-----------------------------------------------------------
N * Application specific definitions.
N *
N * These definitions should be adjusted for your particular hardware and
N * application requirements.
N *
N * THESE PARAMETERS ARE DESCRIBED WITHIN THE 'CONFIGURATION' SECTION OF THE
N * FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE.
N *
N * See http://www.freertos.org/a00110.html.
N *----------------------------------------------------------*/
N 
N/* Ensure stdint is only used by the compiler, and not the assembler. */
N#if defined(__ICCARM__) || defined(__CC_ARM) ||defined(__GUNC__)
X#if 0L || 1L ||0L
N#include <stdint.h>
Nextern uint32_t SystemCoreClock;
N#endif
N 
N#define configUSE_PREEMPTION			1
N#define configUSE_IDLE_HOOK				0
N#define configUSE_TICK_HOOK				0
N#define configCPU_CLOCK_HZ				( (uint32_t) 168000000)
N#define configTICK_RATE_HZ				( ( TickType_t ) 1000 )
N#define configMAX_PRIORITIES			( 5 )
N#define configMINIMAL_STACK_SIZE		( ( unsigned short ) 128 )
N#define configTOTAL_HEAP_SIZE			( ( size_t ) ( 20 * 1024 ) )
N#define configMAX_TASK_NAME_LEN			( 16 )
N#define configUSE_16_BIT_TICKS			0
N#define configIDLE_SHOULD_YIELD			1
N#define configUSE_MUTEXES				1
N//#define configQUEUE_REGISTRY_SIZE		8
N#define configCHECK_FOR_STACK_OVERFLOW	0
N//#define configUSE_RECURSIVE_MUTEXES		1
N#define configUSE_MALLOC_FAILED_HOOK	0
N//#define configUSE_APPLICATION_TASK_TAG	0
N#define configUSE_COUNTING_SEMAPHORES	1
N
N
N#define configGENERATE_RUN_TIME_STATS	0
N#define configUSE_TRACE_FACILITY		0
N#define configUSE_STATS_FORMATTING_FUNCTIONS 0
N#if freeRTOS_RUN_DEBUG
Sextern volatile uint64_t ulHighFrequencyTimerTicks ;
S#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()     (ulHighFrequencyTimerTicks = 0ul) 
S#define portGET_RUN_TIME_COUNTER_VALUE()             ulHighFrequencyTimerTicks
N#endif 
N
N/* Co-routine definitions. */
N#define configUSE_CO_ROUTINES 		0
N#define configMAX_CO_ROUTINE_PRIORITIES ( 2 )
N 
N 
N/* Set the following definitions to 1 to include the API function, or zero
Nto exclude the API function. */
N#define INCLUDE_vTaskPrioritySet		1
N#define INCLUDE_uxTaskPriorityGet		1
N#define INCLUDE_vTaskDelete				1
N#define INCLUDE_vTaskCleanUpResources	1
N#define INCLUDE_vTaskSuspend			1
N#define INCLUDE_vTaskDelayUntil			1
N#define INCLUDE_vTaskDelay				1
N 
N#define INCLUDE_xEventGroupSetBitsFromISR						1
N#define INCLUDE_xTimerPendFunctionCall							1
N 
N/* Cortex-M specific definitions. */
N#ifdef __NVIC_PRIO_BITS
N	/* __BVIC_PRIO_BITS will be specified when CMSIS is being used. */
N	#define configPRIO_BITS       		__NVIC_PRIO_BITS
N#else
S	#define configPRIO_BITS       		4        /* 15 priority levels */
N#endif
N 
N/* The lowest interrupt priority that can be used in a call to a "set priority"
Nfunction. */
N#define configLIBRARY_LOWEST_INTERRUPT_PRIORITY			0xf
N 
N/* The highest interrupt priority that can be used by any interrupt service
Nroutine that makes calls to interrupt safe FreeRTOS API functions.  DO NOT CALL
NINTERRUPT SAFE FREERTOS API FUNCTIONS FROM ANY INTERRUPT THAT HAS A HIGHER
NPRIORITY THAN THIS! (higher priorities are lower numeric values. */
N#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY	0x01//表示用户可以在抢占式优先级为 1 到 15 的中断里面调用 FreeRTOS 的 API 函数
N 
N/* Interrupt priorities used by the kernel port layer itself.  These are generic
Nto all Cortex-M ports, and do not rely on any particular library functions. */
N#define configKERNEL_INTERRUPT_PRIORITY 		( configLIBRARY_LOWEST_INTERRUPT_PRIORITY << (8 - configPRIO_BITS) )
N/* !!!! configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero !!!!
NSee http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. */
N#define configMAX_SYSCALL_INTERRUPT_PRIORITY 	( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY << (8 - configPRIO_BITS) )
N	
N/* Normal assert() semantics without relying on the provision of an assert.h
Nheader file. */
N//#define configASSERT( x ) if( ( x ) == 0 ) { taskDISABLE_INTERRUPTS(); for( ;; ); }	
N 
N/* used by software timers */
N#define configUSE_TIMERS          0
N#define configSUPPORT_DYNAMIC_ALLOCATION 1
N#define configTIMER_TASK_PRIORITY  2
N#define configTIMER_QUEUE_LENGTH   10
N#define configTIMER_TASK_STACK_DEPTH        configMINIMAL_STACK_SIZE
N/* used by software timers */
N 
N	
N/* Definitions that map the FreeRTOS port interrupt handlers to their CMSIS
Nstandard names. */
N#define vPortSVCHandler SVC_Handler
N#define xPortPendSVHandler PendSV_Handler
N#define xPortSysTickHandler SysTick_Handler
N 
N#endif /* FREERTOS_CONFIG_H */
L 99 "..\..\FreeRTOS\Source\include\FreeRTOS.h" 2
N
N/* Basic FreeRTOS definitions. */
N#include "projdefs.h"
L 1 "..\..\FreeRTOS\Source\include\projdefs.h" 1
N/*
N    FreeRTOS V8.2.2 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef PROJDEFS_H
N#define PROJDEFS_H
N
N/*
N * Defines the prototype to which task functions must conform.  Defined in this
N * file to ensure the type is known before portable.h is included.
N */
Ntypedef void (*TaskFunction_t)( void * );
N
N/* Converts a time in milliseconds to a time in ticks. */
N#define pdMS_TO_TICKS( xTimeInMs ) ( ( TickType_t ) ( ( ( TickType_t ) ( xTimeInMs ) * ( TickType_t ) configTICK_RATE_HZ ) / ( TickType_t ) 1000 ) )
N
N#define pdFALSE			( ( BaseType_t ) 0 )
N#define pdTRUE			( ( BaseType_t ) 1 )
N
N#define pdPASS			( pdTRUE )
N#define pdFAIL			( pdFALSE )
N#define errQUEUE_EMPTY	( ( BaseType_t ) 0 )
N#define errQUEUE_FULL	( ( BaseType_t ) 0 )
N
N/* FreeRTOS error definitions. */
N#define errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY	( -1 )
N#define errQUEUE_BLOCKED						( -4 )
N#define errQUEUE_YIELD							( -5 )
N
N/* Macros used for basic data corruption checks. */
N#ifndef configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES
N	#define configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES 0
N#endif
N
N#if( configUSE_16_BIT_TICKS == 1 )
X#if( 0 == 1 )
S	#define pdINTEGRITY_CHECK_VALUE 0x5a5a
N#else
N	#define pdINTEGRITY_CHECK_VALUE 0x5a5a5a5aUL
N#endif
N
N/* The following errno values are used by FreeRTOS+ components, not FreeRTOS
Nitself. */
N#define pdFREERTOS_ERRNO_NONE			0	/* No errors */
N#define	pdFREERTOS_ERRNO_ENOENT			2	/* No such file or directory */
N#define	pdFREERTOS_ERRNO_EIO			5	/* I/O error */
N#define	pdFREERTOS_ERRNO_ENXIO			6	/* No such device or address */
N#define	pdFREERTOS_ERRNO_EBADF			9	/* Bad file number */
N#define	pdFREERTOS_ERRNO_EAGAIN			11	/* No more processes */
N#define	pdFREERTOS_ERRNO_EWOULDBLOCK	11	/* Operation would block */
N#define	pdFREERTOS_ERRNO_ENOMEM			12	/* Not enough memory */
N#define	pdFREERTOS_ERRNO_EACCES			13	/* Permission denied */
N#define	pdFREERTOS_ERRNO_EFAULT			14	/* Bad address */
N#define	pdFREERTOS_ERRNO_EBUSY			16	/* Mount device busy */
N#define	pdFREERTOS_ERRNO_EEXIST			17	/* File exists */
N#define	pdFREERTOS_ERRNO_EXDEV			18	/* Cross-device link */
N#define	pdFREERTOS_ERRNO_ENODEV			19	/* No such device */
N#define	pdFREERTOS_ERRNO_ENOTDIR		20	/* Not a directory */
N#define	pdFREERTOS_ERRNO_EISDIR			21	/* Is a directory */
N#define	pdFREERTOS_ERRNO_EINVAL			22	/* Invalid argument */
N#define	pdFREERTOS_ERRNO_ENOSPC			28	/* No space left on device */
N#define	pdFREERTOS_ERRNO_ESPIPE			29	/* Illegal seek */
N#define	pdFREERTOS_ERRNO_EROFS			30	/* Read only file system */
N#define	pdFREERTOS_ERRNO_EUNATCH		42	/* Protocol driver not attached */
N#define	pdFREERTOS_ERRNO_EBADE			50	/* Invalid exchange */
N#define	pdFREERTOS_ERRNO_EFTYPE			79	/* Inappropriate file type or format */
N#define	pdFREERTOS_ERRNO_ENMFILE		89	/* No more files */
N#define	pdFREERTOS_ERRNO_ENOTEMPTY		90	/* Directory not empty */
N#define	pdFREERTOS_ERRNO_ENAMETOOLONG 	91	/* File or path name too long */
N#define	pdFREERTOS_ERRNO_EOPNOTSUPP		95	/* Operation not supported on transport endpoint */
N#define	pdFREERTOS_ERRNO_ENOBUFS		105	/* No buffer space available */
N#define	pdFREERTOS_ERRNO_ENOPROTOOPT	109	/* Protocol not available */
N#define	pdFREERTOS_ERRNO_EADDRINUSE		112	/* Address already in use */
N#define	pdFREERTOS_ERRNO_ETIMEDOUT		116	/* Connection timed out */
N#define	pdFREERTOS_ERRNO_EINPROGRESS	119	/* Connection already in progress */
N#define	pdFREERTOS_ERRNO_EALREADY		120	/* Socket already connected */
N#define	pdFREERTOS_ERRNO_EADDRNOTAVAIL 	125	/* Address not available */
N#define	pdFREERTOS_ERRNO_EISCONN		127	/* Socket is already connected */
N#define	pdFREERTOS_ERRNO_ENOTCONN		128	/* Socket is not connected */
N#define	pdFREERTOS_ERRNO_ENOMEDIUM		135	/* No medium inserted */
N#define	pdFREERTOS_ERRNO_EILSEQ			138	/* An invalid UTF-16 sequence was encountered. */
N#define	pdFREERTOS_ERRNO_ECANCELED		140	/* Operation canceled. */
N
N/* The following endian values are used by FreeRTOS+ components, not FreeRTOS
Nitself. */
N#define pdFREERTOS_LITTLE_ENDIAN	0
N#define pdFREERTOS_BIG_ENDIAN		1
N
N#endif /* PROJDEFS_H */
N
N
N
L 102 "..\..\FreeRTOS\Source\include\FreeRTOS.h" 2
N
N/* Definitions specific to the port being used. */
N#include "portable.h"
L 1 "..\..\FreeRTOS\Source\include\portable.h" 1
N/*
N    FreeRTOS V8.2.2 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N/*-----------------------------------------------------------
N * Portable layer API.  Each function must be defined for each port.
N *----------------------------------------------------------*/
N
N#ifndef PORTABLE_H
N#define PORTABLE_H
N
N/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
Npre-processor definition was used to ensure the pre-processor found the correct
Nportmacro.h file for the port being used.  That scheme was deprecated in favour
Nof setting the compiler's include path such that it found the correct
Nportmacro.h file - removing the need for the constant and allowing the
Nportmacro.h file to be located anywhere in relation to the port being used.
NPurely for reasons of backward compatibility the old method is still valid, but
Nto make it clear that new projects should not use it, support for the port
Nspecific constants has been moved into the deprecated_definitions.h header
Nfile. */
N#include "deprecated_definitions.h"
L 1 "..\..\FreeRTOS\Source\include\deprecated_definitions.h" 1
N/*
N    FreeRTOS V8.2.2 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef DEPRECATED_DEFINITIONS_H
N#define DEPRECATED_DEFINITIONS_H
N
N
N/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
Npre-processor definition was used to ensure the pre-processor found the correct
Nportmacro.h file for the port being used.  That scheme was deprecated in favour
Nof setting the compiler's include path such that it found the correct
Nportmacro.h file - removing the need for the constant and allowing the
Nportmacro.h file to be located anywhere in relation to the port being used.  The
Ndefinitions below remain in the code for backward compatibility only.  New
Nprojects should not use them. */
N
N#ifdef OPEN_WATCOM_INDUSTRIAL_PC_PORT
S	#include "..\..\Source\portable\owatcom\16bitdos\pc\portmacro.h"
S	typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef OPEN_WATCOM_FLASH_LITE_186_PORT
S	#include "..\..\Source\portable\owatcom\16bitdos\flsh186\portmacro.h"
S	typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef GCC_MEGA_AVR
S	#include "../portable/GCC/ATMega323/portmacro.h"
N#endif
N
N#ifdef IAR_MEGA_AVR
S	#include "../portable/IAR/ATMega323/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC24_PORT
S	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
N#endif
N
N#ifdef MPLAB_DSPIC_PORT
S	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC18F_PORT
S	#include "../../Source/portable/MPLAB/PIC18F/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC32MX_PORT
S	#include "../../Source/portable/MPLAB/PIC32MX/portmacro.h"
N#endif
N
N#ifdef _FEDPICC
S	#include "libFreeRTOS/Include/portmacro.h"
N#endif
N
N#ifdef SDCC_CYGNAL
S	#include "../../Source/portable/SDCC/Cygnal/portmacro.h"
N#endif
N
N#ifdef GCC_ARM7
S	#include "../../Source/portable/GCC/ARM7_LPC2000/portmacro.h"
N#endif
N
N#ifdef GCC_ARM7_ECLIPSE
S	#include "portmacro.h"
N#endif
N
N#ifdef ROWLEY_LPC23xx
S	#include "../../Source/portable/GCC/ARM7_LPC23xx/portmacro.h"
N#endif
N
N#ifdef IAR_MSP430
S	#include "..\..\Source\portable\IAR\MSP430\portmacro.h"
N#endif
N
N#ifdef GCC_MSP430
S	#include "../../Source/portable/GCC/MSP430F449/portmacro.h"
N#endif
N
N#ifdef ROWLEY_MSP430
S	#include "../../Source/portable/Rowley/MSP430F449/portmacro.h"
N#endif
N
N#ifdef ARM7_LPC21xx_KEIL_RVDS
S	#include "..\..\Source\portable\RVDS\ARM7_LPC21xx\portmacro.h"
N#endif
N
N#ifdef SAM7_GCC
S	#include "../../Source/portable/GCC/ARM7_AT91SAM7S/portmacro.h"
N#endif
N
N#ifdef SAM7_IAR
S	#include "..\..\Source\portable\IAR\AtmelSAM7S64\portmacro.h"
N#endif
N
N#ifdef SAM9XE_IAR
S	#include "..\..\Source\portable\IAR\AtmelSAM9XE\portmacro.h"
N#endif
N
N#ifdef LPC2000_IAR
S	#include "..\..\Source\portable\IAR\LPC2000\portmacro.h"
N#endif
N
N#ifdef STR71X_IAR
S	#include "..\..\Source\portable\IAR\STR71x\portmacro.h"
N#endif
N
N#ifdef STR75X_IAR
S	#include "..\..\Source\portable\IAR\STR75x\portmacro.h"
N#endif
N
N#ifdef STR75X_GCC
S	#include "..\..\Source\portable\GCC\STR75x\portmacro.h"
N#endif
N
N#ifdef STR91X_IAR
S	#include "..\..\Source\portable\IAR\STR91x\portmacro.h"
N#endif
N
N#ifdef GCC_H8S
S	#include "../../Source/portable/GCC/H8S2329/portmacro.h"
N#endif
N
N#ifdef GCC_AT91FR40008
S	#include "../../Source/portable/GCC/ARM7_AT91FR40008/portmacro.h"
N#endif
N
N#ifdef RVDS_ARMCM3_LM3S102
S	#include "../../Source/portable/RVDS/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef GCC_ARMCM3_LM3S102
S	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef GCC_ARMCM3
S	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef IAR_ARM_CM3
S	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef IAR_ARMCM3_LM
S	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef HCS12_CODE_WARRIOR
S	#include "../../Source/portable/CodeWarrior/HCS12/portmacro.h"
N#endif
N
N#ifdef MICROBLAZE_GCC
S	#include "../../Source/portable/GCC/MicroBlaze/portmacro.h"
N#endif
N
N#ifdef TERN_EE
S	#include "..\..\Source\portable\Paradigm\Tern_EE\small\portmacro.h"
N#endif
N
N#ifdef GCC_HCS12
S	#include "../../Source/portable/GCC/HCS12/portmacro.h"
N#endif
N
N#ifdef GCC_MCF5235
S    #include "../../Source/portable/GCC/MCF5235/portmacro.h"
N#endif
N
N#ifdef COLDFIRE_V2_GCC
S	#include "../../../Source/portable/GCC/ColdFire_V2/portmacro.h"
N#endif
N
N#ifdef COLDFIRE_V2_CODEWARRIOR
S	#include "../../Source/portable/CodeWarrior/ColdFire_V2/portmacro.h"
N#endif
N
N#ifdef GCC_PPC405
S	#include "../../Source/portable/GCC/PPC405_Xilinx/portmacro.h"
N#endif
N
N#ifdef GCC_PPC440
S	#include "../../Source/portable/GCC/PPC440_Xilinx/portmacro.h"
N#endif
N
N#ifdef _16FX_SOFTUNE
S	#include "..\..\Source\portable\Softune\MB96340\portmacro.h"
N#endif
N
N#ifdef BCC_INDUSTRIAL_PC_PORT
S	/* A short file name has to be used in place of the normal
S	FreeRTOSConfig.h when using the Borland compiler. */
S	#include "frconfig.h"
S	#include "..\portable\BCC\16BitDOS\PC\prtmacro.h"
S    typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef BCC_FLASH_LITE_186_PORT
S	/* A short file name has to be used in place of the normal
S	FreeRTOSConfig.h when using the Borland compiler. */
S	#include "frconfig.h"
S	#include "..\portable\BCC\16BitDOS\flsh186\prtmacro.h"
S    typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef __GNUC__
S   #ifdef __AVR32_AVR32A__
S	   #include "portmacro.h"
S   #endif
N#endif
N
N#ifdef __ICCAVR32__
S   #ifdef __CORE__
S      #if __CORE__ == __AVR32A__
S	      #include "portmacro.h"
S      #endif
S   #endif
N#endif
N
N#ifdef __91467D
S	#include "portmacro.h"
N#endif
N
N#ifdef __96340
S	#include "portmacro.h"
N#endif
N
N
N#ifdef __IAR_V850ES_Fx3__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx3__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx3_L__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx2__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Hx2__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_78K0R_Kx3__
S	#include "../../Source/portable/IAR/78K0R/portmacro.h"
N#endif
N
N#ifdef __IAR_78K0R_Kx3L__
S	#include "../../Source/portable/IAR/78K0R/portmacro.h"
N#endif
N
N#endif /* DEPRECATED_DEFINITIONS_H */
N
L 88 "..\..\FreeRTOS\Source\include\portable.h" 2
N
N/* If portENTER_CRITICAL is not defined then including deprecated_definitions.h
Ndid not result in a portmacro.h header file being included - and it should be
Nincluded here.  In this case the path to the correct portmacro.h header file
Nmust be set in the compiler's include path. */
N#ifndef portENTER_CRITICAL
N	#include "portmacro.h"
L 1 "..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F\portmacro.h" 1
N/*
N    FreeRTOS V8.2.2 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef PORTMACRO_H
N#define PORTMACRO_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*-----------------------------------------------------------
N * Port specific definitions.
N *
N * The settings in this file configure FreeRTOS correctly for the
N * given hardware and compiler.
N *
N * These settings should not be altered.
N *-----------------------------------------------------------
N */
N
N/* Type definitions. */
N#define portCHAR		char
N#define portFLOAT		float
N#define portDOUBLE		double
N#define portLONG		long
N#define portSHORT		short
N#define portSTACK_TYPE	uint32_t
N#define portBASE_TYPE	long
N
Ntypedef portSTACK_TYPE StackType_t;
Xtypedef uint32_t StackType_t;
Ntypedef long BaseType_t;
Ntypedef unsigned long UBaseType_t;
N
N#if( configUSE_16_BIT_TICKS == 1 )
X#if( 0 == 1 )
S	typedef uint16_t TickType_t;
S	#define portMAX_DELAY ( TickType_t ) 0xffff
N#else
N	typedef uint32_t TickType_t;
N	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
N
N	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
N	not need to be guarded with a critical section. */
N	#define portTICK_TYPE_IS_ATOMIC 1
N#endif
N/*-----------------------------------------------------------*/
N
N/* Architecture specifics. */
N#define portSTACK_GROWTH			( -1 )
N#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
N#define portBYTE_ALIGNMENT			8
N
N/* Constants used with memory barrier intrinsics. */
N#define portSY_FULL_READ_WRITE		( 15 )
N
N/*-----------------------------------------------------------*/
N
N/* Scheduler utilities. */
N#define portYIELD()																\
N{																				\
N	/* Set a PendSV to request a context switch. */								\
N	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
N																				\
N	/* Barriers are normally not required but do ensure the code is completely	\
N	within the specified behaviour for the architecture. */						\
N	__dsb( portSY_FULL_READ_WRITE );											\
N	__isb( portSY_FULL_READ_WRITE );											\
N}
X#define portYIELD()																{																					 									portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;																													 							__dsb( portSY_FULL_READ_WRITE );												__isb( portSY_FULL_READ_WRITE );											}
N/*-----------------------------------------------------------*/
N
N#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
N#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
N#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
N#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
N/*-----------------------------------------------------------*/
N
N/* Critical section management. */
Nextern void vPortEnterCritical( void );
Nextern void vPortExitCritical( void );
N
N#define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
N#define portENABLE_INTERRUPTS()					vPortSetBASEPRI( 0 )
N#define portENTER_CRITICAL()					vPortEnterCritical()
N#define portEXIT_CRITICAL()						vPortExitCritical()
N#define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
N#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
N
N/*-----------------------------------------------------------*/
N
N/* Tickless idle/low power functionality. */
N#ifndef portSUPPRESS_TICKS_AND_SLEEP
N	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
N	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
N#endif
N/*-----------------------------------------------------------*/
N
N/* Port specific optimisations. */
N#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
N	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
N#endif
N
N#if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
X#if 1 == 1
N
N	/* Check the configuration. */
N	#if( configMAX_PRIORITIES > 32 )
X	#if( ( 5 ) > 32 )
S		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
N	#endif
N
N	/* Store/clear the ready priorities in a bit map. */
N	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
N	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
N
N	/*-----------------------------------------------------------*/
N
N	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31 - __clz( ( uxReadyPriorities ) ) )
N
N#endif /* taskRECORD_READY_PRIORITY */
N/*-----------------------------------------------------------*/
N
N/* Task function macros as described on the FreeRTOS.org WEB site.  These are
Nnot necessary for to use this port.  They are defined so the common demo files
N(which build with all the ports) will build. */
N#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
N#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
N/*-----------------------------------------------------------*/
N
N#ifdef configASSERT
S	void vPortValidateInterruptPriority( void );
S	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
N#endif
N
N/* portNOP() is not required by this port. */
N#define portNOP()
N
N#ifndef portFORCE_INLINE
N	#define portFORCE_INLINE __forceinline
N#endif
N
N/*-----------------------------------------------------------*/
N
Nstatic portFORCE_INLINE void vPortSetBASEPRI( uint32_t ulBASEPRI )
Xstatic __forceinline void vPortSetBASEPRI( uint32_t ulBASEPRI )
N{
N	__asm
N	{
N		/* Barrier instructions are not used as this function is only used to
N		lower the BASEPRI value. */
N		msr basepri, ulBASEPRI
N	}
N}
N/*-----------------------------------------------------------*/
N
Nstatic portFORCE_INLINE void vPortRaiseBASEPRI( void )
Xstatic __forceinline void vPortRaiseBASEPRI( void )
N{
Nuint32_t ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;
Xuint32_t ulNewBASEPRI = ( 0x01 << (8 - 4) );
N
N	__asm
N	{
N		/* Set BASEPRI to the max syscall priority to effect a critical
N		section. */
N		msr basepri, ulNewBASEPRI
N		dsb
N		isb
N	}
N}
N/*-----------------------------------------------------------*/
N
Nstatic portFORCE_INLINE uint32_t ulPortRaiseBASEPRI( void )
Xstatic __forceinline uint32_t ulPortRaiseBASEPRI( void )
N{
Nuint32_t ulReturn, ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;
Xuint32_t ulReturn, ulNewBASEPRI = ( 0x01 << (8 - 4) );
N
N	__asm
N	{
N		/* Set BASEPRI to the max syscall priority to effect a critical
N		section. */
N		mrs ulReturn, basepri
N		msr basepri, ulNewBASEPRI
N		dsb
N		isb
N	}
N
N	return ulReturn;
N}
N/*-----------------------------------------------------------*/
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* PORTMACRO_H */
N
L 95 "..\..\FreeRTOS\Source\include\portable.h" 2
N#endif
N
N#if portBYTE_ALIGNMENT == 32
X#if 8 == 32
S	#define portBYTE_ALIGNMENT_MASK ( 0x001f )
N#endif
N
N#if portBYTE_ALIGNMENT == 16
X#if 8 == 16
S	#define portBYTE_ALIGNMENT_MASK ( 0x000f )
N#endif
N
N#if portBYTE_ALIGNMENT == 8
X#if 8 == 8
N	#define portBYTE_ALIGNMENT_MASK ( 0x0007 )
N#endif
N
N#if portBYTE_ALIGNMENT == 4
X#if 8 == 4
S	#define portBYTE_ALIGNMENT_MASK	( 0x0003 )
N#endif
N
N#if portBYTE_ALIGNMENT == 2
X#if 8 == 2
S	#define portBYTE_ALIGNMENT_MASK	( 0x0001 )
N#endif
N
N#if portBYTE_ALIGNMENT == 1
X#if 8 == 1
S	#define portBYTE_ALIGNMENT_MASK	( 0x0000 )
N#endif
N
N#ifndef portBYTE_ALIGNMENT_MASK
S	#error "Invalid portBYTE_ALIGNMENT definition"
N#endif
N
N#ifndef portNUM_CONFIGURABLE_REGIONS
N	#define portNUM_CONFIGURABLE_REGIONS 1
N#endif
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "mpu_wrappers.h"
L 1 "..\..\FreeRTOS\Source\include\mpu_wrappers.h" 1
N/*
N    FreeRTOS V8.2.2 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef MPU_WRAPPERS_H
N#define MPU_WRAPPERS_H
N
N/* This file redefines API functions to be called through a wrapper macro, but
Nonly for ports that are using the MPU. */
N#ifdef portUSING_MPU_WRAPPERS
S
S	/* MPU_WRAPPERS_INCLUDED_FROM_API_FILE will be defined when this file is
S	included from queue.c or task.c to prevent it from having an effect within
S	those files. */
S	#ifndef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
S
S		#define xTaskGenericCreate				MPU_xTaskGenericCreate
S		#define vTaskAllocateMPURegions			MPU_vTaskAllocateMPURegions
S		#define vTaskDelete						MPU_vTaskDelete
S		#define vTaskDelayUntil					MPU_vTaskDelayUntil
S		#define vTaskDelay						MPU_vTaskDelay
S		#define uxTaskPriorityGet				MPU_uxTaskPriorityGet
S		#define vTaskPrioritySet				MPU_vTaskPrioritySet
S		#define eTaskGetState					MPU_eTaskGetState
S		#define vTaskSuspend					MPU_vTaskSuspend
S		#define vTaskResume						MPU_vTaskResume
S		#define vTaskSuspendAll					MPU_vTaskSuspendAll
S		#define xTaskResumeAll					MPU_xTaskResumeAll
S		#define xTaskGetTickCount				MPU_xTaskGetTickCount
S		#define uxTaskGetNumberOfTasks			MPU_uxTaskGetNumberOfTasks
S		#define vTaskList						MPU_vTaskList
S		#define vTaskGetRunTimeStats			MPU_vTaskGetRunTimeStats
S		#define vTaskSetApplicationTaskTag		MPU_vTaskSetApplicationTaskTag
S		#define xTaskGetApplicationTaskTag		MPU_xTaskGetApplicationTaskTag
S		#define xTaskCallApplicationTaskHook	MPU_xTaskCallApplicationTaskHook
S		#define uxTaskGetStackHighWaterMark		MPU_uxTaskGetStackHighWaterMark
S		#define xTaskGetCurrentTaskHandle		MPU_xTaskGetCurrentTaskHandle
S		#define xTaskGetSchedulerState			MPU_xTaskGetSchedulerState
S		#define xTaskGetIdleTaskHandle			MPU_xTaskGetIdleTaskHandle
S		#define uxTaskGetSystemState			MPU_uxTaskGetSystemState
S		#define xTaskGenericNotify				MPU_xTaskGenericNotify
S		#define xTaskNotifyWait					MPU_xTaskNotifyWait
S		#define ulTaskNotifyTake				MPU_ulTaskNotifyTake
S
S		#define xQueueGenericCreate				MPU_xQueueGenericCreate
S		#define xQueueCreateMutex				MPU_xQueueCreateMutex
S		#define xQueueGiveMutexRecursive		MPU_xQueueGiveMutexRecursive
S		#define xQueueTakeMutexRecursive		MPU_xQueueTakeMutexRecursive
S		#define xQueueCreateCountingSemaphore	MPU_xQueueCreateCountingSemaphore
S		#define xQueueGenericSend				MPU_xQueueGenericSend
S		#define xQueueAltGenericSend			MPU_xQueueAltGenericSend
S		#define xQueueAltGenericReceive			MPU_xQueueAltGenericReceive
S		#define xQueueGenericReceive			MPU_xQueueGenericReceive
S		#define uxQueueMessagesWaiting			MPU_uxQueueMessagesWaiting
S		#define vQueueDelete					MPU_vQueueDelete
S		#define xQueueGenericReset				MPU_xQueueGenericReset
S		#define xQueueCreateSet					MPU_xQueueCreateSet
S		#define xQueueSelectFromSet				MPU_xQueueSelectFromSet
S		#define xQueueAddToSet					MPU_xQueueAddToSet
S		#define xQueueRemoveFromSet				MPU_xQueueRemoveFromSet
S		#define xQueueGetMutexHolder			MPU_xQueueGetMutexHolder
S		#define xQueueGetMutexHolder			MPU_xQueueGetMutexHolder
S
S		#define pvPortMalloc					MPU_pvPortMalloc
S		#define vPortFree						MPU_vPortFree
S		#define xPortGetFreeHeapSize			MPU_xPortGetFreeHeapSize
S		#define vPortInitialiseBlocks			MPU_vPortInitialiseBlocks
S		#define xPortGetMinimumEverFreeHeapSize	MPU_xPortGetMinimumEverFreeHeapSize
S
S		#if configQUEUE_REGISTRY_SIZE > 0
S			#define vQueueAddToRegistry				MPU_vQueueAddToRegistry
S			#define vQueueUnregisterQueue			MPU_vQueueUnregisterQueue
S		#endif
S
S		#define xTimerCreate					MPU_xTimerCreate
S		#define pvTimerGetTimerID				MPU_pvTimerGetTimerID
S		#define vTimerSetTimerID				MPU_vTimerSetTimerID
S		#define xTimerIsTimerActive				MPU_xTimerIsTimerActive
S		#define xTimerGetTimerDaemonTaskHandle	MPU_xTimerGetTimerDaemonTaskHandle
S		#define xTimerPendFunctionCall			MPU_xTimerPendFunctionCall
S		#define pcTimerGetTimerName				MPU_pcTimerGetTimerName
S		#define xTimerGenericCommand			MPU_xTimerGenericCommand
S
S		#define xEventGroupCreate				MPU_xEventGroupCreate
S		#define xEventGroupWaitBits				MPU_xEventGroupWaitBits
S		#define xEventGroupClearBits			MPU_xEventGroupClearBits
S		#define xEventGroupSetBits				MPU_xEventGroupSetBits
S		#define xEventGroupSync					MPU_xEventGroupSync
S		#define vEventGroupDelete				MPU_vEventGroupDelete
S
S		/* Remove the privileged function macro. */
S		#define PRIVILEGED_FUNCTION
S
S	#else /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
S
S		/* Ensure API functions go in the privileged execution section. */
S		#define PRIVILEGED_FUNCTION __attribute__((section("privileged_functions")))
S		#define PRIVILEGED_DATA __attribute__((section("privileged_data")))
S
S	#endif /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
S
N#else /* portUSING_MPU_WRAPPERS */
N
N	#define PRIVILEGED_FUNCTION
N	#define PRIVILEGED_DATA
N	#define portUSING_MPU_WRAPPERS 0
N
N#endif /* portUSING_MPU_WRAPPERS */
N
N
N#endif /* MPU_WRAPPERS_H */
N
L 134 "..\..\FreeRTOS\Source\include\portable.h" 2
N
N/*
N * Setup the stack of a new task so it is ready to be placed under the
N * scheduler control.  The registers have to be placed on the stack in
N * the order that the port expects to find them.
N *
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged ) PRIVILEGED_FUNCTION;
N#else
N	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) PRIVILEGED_FUNCTION;
X	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) ;
N#endif
N
N/* Used by heap_5.c. */
Ntypedef struct HeapRegion
N{
N	uint8_t *pucStartAddress;
N	size_t xSizeInBytes;
N} HeapRegion_t;
N
N/*
N * Used to define multiple heap regions for use by heap_5.c.  This function
N * must be called before any calls to pvPortMalloc() - not creating a task,
N * queue, semaphore, mutex, software timer, event group, etc. will result in
N * pvPortMalloc being called.
N *
N * pxHeapRegions passes in an array of HeapRegion_t structures - each of which
N * defines a region of memory that can be used as the heap.  The array is
N * terminated by a HeapRegions_t structure that has a size of 0.  The region
N * with the lowest start address must appear first in the array.
N */
Nvoid vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) PRIVILEGED_FUNCTION;
Xvoid vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) ;
N
N
N/*
N * Map to the memory management routines required for the port.
N */
Nvoid *pvPortMalloc( size_t xSize ) PRIVILEGED_FUNCTION;
Xvoid *pvPortMalloc( size_t xSize ) ;
Nvoid vPortFree( void *pv ) PRIVILEGED_FUNCTION;
Xvoid vPortFree( void *pv ) ;
Nvoid vPortInitialiseBlocks( void ) PRIVILEGED_FUNCTION;
Xvoid vPortInitialiseBlocks( void ) ;
Nsize_t xPortGetFreeHeapSize( void ) PRIVILEGED_FUNCTION;
Xsize_t xPortGetFreeHeapSize( void ) ;
Nsize_t xPortGetMinimumEverFreeHeapSize( void ) PRIVILEGED_FUNCTION;
Xsize_t xPortGetMinimumEverFreeHeapSize( void ) ;
N
N/*
N * Setup the hardware ready for the scheduler to take control.  This generally
N * sets up a tick interrupt and sets timers for the correct tick frequency.
N */
NBaseType_t xPortStartScheduler( void ) PRIVILEGED_FUNCTION;
XBaseType_t xPortStartScheduler( void ) ;
N
N/*
N * Undo any hardware/ISR setup that was performed by xPortStartScheduler() so
N * the hardware is left in its original condition after the scheduler stops
N * executing.
N */
Nvoid vPortEndScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vPortEndScheduler( void ) ;
N
N/*
N * The structures and methods of manipulating the MPU are contained within the
N * port layer.
N *
N * Fills the xMPUSettings structure with the memory region information
N * contained in xRegions.
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	struct xMEMORY_REGION;
S	void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint16_t usStackDepth ) PRIVILEGED_FUNCTION;
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* PORTABLE_H */
N
L 105 "..\..\FreeRTOS\Source\include\FreeRTOS.h" 2
N
N/*
N * Check all the required application specific macros have been defined.
N * These macros are application specific and (as downloaded) are defined
N * within FreeRTOSConfig.h.
N */
N
N#ifndef configMINIMAL_STACK_SIZE
S	#error Missing definition:  configMINIMAL_STACK_SIZE must be defined in FreeRTOSConfig.h.  configMINIMAL_STACK_SIZE defines the size (in words) of the stack allocated to the idle task.  Refer to the demo project provided for your port for a suitable value.
N#endif
N
N#ifndef configMAX_PRIORITIES
S	#error Missing definition:  configMAX_PRIORITIES must be defined in FreeRTOSConfig.h.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_PREEMPTION
S	#error Missing definition:  configUSE_PREEMPTION must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_IDLE_HOOK
S	#error Missing definition:  configUSE_IDLE_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_TICK_HOOK
S	#error Missing definition:  configUSE_TICK_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_vTaskPrioritySet
S	#error Missing definition:  INCLUDE_vTaskPrioritySet must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_uxTaskPriorityGet
S	#error Missing definition:  INCLUDE_uxTaskPriorityGet must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_vTaskDelete
S	#error Missing definition:  INCLUDE_vTaskDelete must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_vTaskSuspend
S	#error Missing definition:  INCLUDE_vTaskSuspend must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_vTaskDelayUntil
S	#error Missing definition:  INCLUDE_vTaskDelayUntil must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_vTaskDelay
S	#error Missing definition:  INCLUDE_vTaskDelay must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_16_BIT_TICKS
S	#error Missing definition:  configUSE_16_BIT_TICKS must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configMAX_PRIORITIES
S	#error configMAX_PRIORITIES must be defined to be greater than or equal to 1.
N#endif
N
N#ifndef configUSE_CO_ROUTINES
S	#define configUSE_CO_ROUTINES 0
N#endif
N
N#if configUSE_CO_ROUTINES != 0
X#if 0 != 0
S	#ifndef configMAX_CO_ROUTINE_PRIORITIES
S		#error configMAX_CO_ROUTINE_PRIORITIES must be greater than or equal to 1.
S	#endif
N#endif
N
N#ifndef INCLUDE_xTaskGetIdleTaskHandle
N	#define INCLUDE_xTaskGetIdleTaskHandle 0
N#endif
N
N#ifndef INCLUDE_xTimerGetTimerDaemonTaskHandle
N	#define INCLUDE_xTimerGetTimerDaemonTaskHandle 0
N#endif
N
N#ifndef INCLUDE_xQueueGetMutexHolder
N	#define INCLUDE_xQueueGetMutexHolder 0
N#endif
N
N#ifndef INCLUDE_xSemaphoreGetMutexHolder
N	#define INCLUDE_xSemaphoreGetMutexHolder INCLUDE_xQueueGetMutexHolder
N#endif
N
N#ifndef INCLUDE_pcTaskGetTaskName
N	#define INCLUDE_pcTaskGetTaskName 0
N#endif
N
N#ifndef configUSE_APPLICATION_TASK_TAG
N	#define configUSE_APPLICATION_TASK_TAG 0
N#endif
N
N#ifndef configNUM_THREAD_LOCAL_STORAGE_POINTERS
N	#define configNUM_THREAD_LOCAL_STORAGE_POINTERS 0
N#endif
N
N#ifndef INCLUDE_uxTaskGetStackHighWaterMark
N	#define INCLUDE_uxTaskGetStackHighWaterMark 0
N#endif
N
N#ifndef INCLUDE_eTaskGetState
N	#define INCLUDE_eTaskGetState 0
N#endif
N
N#ifndef configUSE_RECURSIVE_MUTEXES
N	#define configUSE_RECURSIVE_MUTEXES 0
N#endif
N
N#ifndef configUSE_MUTEXES
S	#define configUSE_MUTEXES 0
N#endif
N
N#ifndef configUSE_TIMERS
S	#define configUSE_TIMERS 0
N#endif
N
N#ifndef configUSE_COUNTING_SEMAPHORES
S	#define configUSE_COUNTING_SEMAPHORES 0
N#endif
N
N#ifndef configUSE_ALTERNATIVE_API
N	#define configUSE_ALTERNATIVE_API 0
N#endif
N
N#ifndef portCRITICAL_NESTING_IN_TCB
N	#define portCRITICAL_NESTING_IN_TCB 0
N#endif
N
N#ifndef configMAX_TASK_NAME_LEN
S	#define configMAX_TASK_NAME_LEN 16
N#endif
N
N#ifndef configIDLE_SHOULD_YIELD
S	#define configIDLE_SHOULD_YIELD		1
N#endif
N
N#if configMAX_TASK_NAME_LEN < 1
X#if ( 16 ) < 1
S	#error configMAX_TASK_NAME_LEN must be set to a minimum of 1 in FreeRTOSConfig.h
N#endif
N
N#ifndef INCLUDE_xTaskResumeFromISR
N	#define INCLUDE_xTaskResumeFromISR 1
N#endif
N
N#ifndef INCLUDE_xEventGroupSetBitFromISR
N	#define INCLUDE_xEventGroupSetBitFromISR 0
N#endif
N
N#ifndef INCLUDE_xTimerPendFunctionCall
S	#define INCLUDE_xTimerPendFunctionCall 0
N#endif
N
N#ifndef configASSERT
N	#define configASSERT( x )
N	#define configASSERT_DEFINED 0
N#else
S	#define configASSERT_DEFINED 1
N#endif
N
N/* The timers module relies on xTaskGetSchedulerState(). */
N#if configUSE_TIMERS == 1
X#if 0 == 1
S
S	#ifndef configTIMER_TASK_PRIORITY
S		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_PRIORITY must also be defined.
S	#endif /* configTIMER_TASK_PRIORITY */
S
S	#ifndef configTIMER_QUEUE_LENGTH
S		#error If configUSE_TIMERS is set to 1 then configTIMER_QUEUE_LENGTH must also be defined.
S	#endif /* configTIMER_QUEUE_LENGTH */
S
S	#ifndef configTIMER_TASK_STACK_DEPTH
S		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_STACK_DEPTH must also be defined.
S	#endif /* configTIMER_TASK_STACK_DEPTH */
S
N#endif /* configUSE_TIMERS */
N
N#ifndef INCLUDE_xTaskGetSchedulerState
N	#define INCLUDE_xTaskGetSchedulerState 0
N#endif
N
N#ifndef INCLUDE_xTaskGetCurrentTaskHandle
N	#define INCLUDE_xTaskGetCurrentTaskHandle 0
N#endif
N
N
N#ifndef portSET_INTERRUPT_MASK_FROM_ISR
S	#define portSET_INTERRUPT_MASK_FROM_ISR() 0
N#endif
N
N#ifndef portCLEAR_INTERRUPT_MASK_FROM_ISR
S	#define portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedStatusValue ) ( void ) uxSavedStatusValue
N#endif
N
N#ifndef portCLEAN_UP_TCB
N	#define portCLEAN_UP_TCB( pxTCB ) ( void ) pxTCB
N#endif
N
N#ifndef portPRE_TASK_DELETE_HOOK
N	#define portPRE_TASK_DELETE_HOOK( pvTaskToDelete, pxYieldPending )
N#endif
N
N#ifndef portSETUP_TCB
N	#define portSETUP_TCB( pxTCB ) ( void ) pxTCB
N#endif
N
N#ifndef configQUEUE_REGISTRY_SIZE
N	#define configQUEUE_REGISTRY_SIZE 0U
N#endif
N
N#if ( configQUEUE_REGISTRY_SIZE < 1 )
X#if ( 0U < 1 )
N	#define vQueueAddToRegistry( xQueue, pcName )
N	#define vQueueUnregisterQueue( xQueue )
N#endif
N
N#ifndef portPOINTER_SIZE_TYPE
N	#define portPOINTER_SIZE_TYPE uint32_t
N#endif
N
N/* Remove any unused trace macros. */
N#ifndef traceSTART
N	/* Used to perform any necessary initialisation - for example, open a file
N	into which trace is to be written. */
N	#define traceSTART()
N#endif
N
N#ifndef traceEND
N	/* Use to close a trace, for example close a file into which trace has been
N	written. */
N	#define traceEND()
N#endif
N
N#ifndef traceTASK_SWITCHED_IN
N	/* Called after a task has been selected to run.  pxCurrentTCB holds a pointer
N	to the task control block of the selected task. */
N	#define traceTASK_SWITCHED_IN()
N#endif
N
N#ifndef traceINCREASE_TICK_COUNT
N	/* Called before stepping the tick count after waking from tickless idle
N	sleep. */
N	#define traceINCREASE_TICK_COUNT( x )
N#endif
N
N#ifndef traceLOW_POWER_IDLE_BEGIN
N	/* Called immediately before entering tickless idle. */
N	#define traceLOW_POWER_IDLE_BEGIN()
N#endif
N
N#ifndef	traceLOW_POWER_IDLE_END
N	/* Called when returning to the Idle task after a tickless idle. */
N	#define traceLOW_POWER_IDLE_END()
N#endif
N
N#ifndef traceTASK_SWITCHED_OUT
N	/* Called before a task has been selected to run.  pxCurrentTCB holds a pointer
N	to the task control block of the task being switched out. */
N	#define traceTASK_SWITCHED_OUT()
N#endif
N
N#ifndef traceTASK_PRIORITY_INHERIT
N	/* Called when a task attempts to take a mutex that is already held by a
N	lower priority task.  pxTCBOfMutexHolder is a pointer to the TCB of the task
N	that holds the mutex.  uxInheritedPriority is the priority the mutex holder
N	will inherit (the priority of the task that is attempting to obtain the
N	muted. */
N	#define traceTASK_PRIORITY_INHERIT( pxTCBOfMutexHolder, uxInheritedPriority )
N#endif
N
N#ifndef traceTASK_PRIORITY_DISINHERIT
N	/* Called when a task releases a mutex, the holding of which had resulted in
N	the task inheriting the priority of a higher priority task.
N	pxTCBOfMutexHolder is a pointer to the TCB of the task that is releasing the
N	mutex.  uxOriginalPriority is the task's configured (base) priority. */
N	#define traceTASK_PRIORITY_DISINHERIT( pxTCBOfMutexHolder, uxOriginalPriority )
N#endif
N
N#ifndef traceBLOCKING_ON_QUEUE_RECEIVE
N	/* Task is about to block because it cannot read from a
N	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
N	upon which the read was attempted.  pxCurrentTCB points to the TCB of the
N	task that attempted the read. */
N	#define traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue )
N#endif
N
N#ifndef traceBLOCKING_ON_QUEUE_SEND
N	/* Task is about to block because it cannot write to a
N	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
N	upon which the write was attempted.  pxCurrentTCB points to the TCB of the
N	task that attempted the write. */
N	#define traceBLOCKING_ON_QUEUE_SEND( pxQueue )
N#endif
N
N#ifndef configCHECK_FOR_STACK_OVERFLOW
S	#define configCHECK_FOR_STACK_OVERFLOW 0
N#endif
N
N/* The following event macros are embedded in the kernel API calls. */
N
N#ifndef traceMOVED_TASK_TO_READY_STATE
N	#define traceMOVED_TASK_TO_READY_STATE( pxTCB )
N#endif
N
N#ifndef traceQUEUE_CREATE
N	#define traceQUEUE_CREATE( pxNewQueue )
N#endif
N
N#ifndef traceQUEUE_CREATE_FAILED
N	#define traceQUEUE_CREATE_FAILED( ucQueueType )
N#endif
N
N#ifndef traceCREATE_MUTEX
N	#define traceCREATE_MUTEX( pxNewQueue )
N#endif
N
N#ifndef traceCREATE_MUTEX_FAILED
N	#define traceCREATE_MUTEX_FAILED()
N#endif
N
N#ifndef traceGIVE_MUTEX_RECURSIVE
N	#define traceGIVE_MUTEX_RECURSIVE( pxMutex )
N#endif
N
N#ifndef traceGIVE_MUTEX_RECURSIVE_FAILED
N	#define traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex )
N#endif
N
N#ifndef traceTAKE_MUTEX_RECURSIVE
N	#define traceTAKE_MUTEX_RECURSIVE( pxMutex )
N#endif
N
N#ifndef traceTAKE_MUTEX_RECURSIVE_FAILED
N	#define traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex )
N#endif
N
N#ifndef traceCREATE_COUNTING_SEMAPHORE
N	#define traceCREATE_COUNTING_SEMAPHORE()
N#endif
N
N#ifndef traceCREATE_COUNTING_SEMAPHORE_FAILED
N	#define traceCREATE_COUNTING_SEMAPHORE_FAILED()
N#endif
N
N#ifndef traceQUEUE_SEND
N	#define traceQUEUE_SEND( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FAILED
N	#define traceQUEUE_SEND_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE
N	#define traceQUEUE_RECEIVE( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK
N	#define traceQUEUE_PEEK( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK_FROM_ISR
N	#define traceQUEUE_PEEK_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FAILED
N	#define traceQUEUE_RECEIVE_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FROM_ISR
N	#define traceQUEUE_SEND_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FROM_ISR_FAILED
N	#define traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FROM_ISR
N	#define traceQUEUE_RECEIVE_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FROM_ISR_FAILED
N	#define traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK_FROM_ISR_FAILED
N	#define traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_DELETE
N	#define traceQUEUE_DELETE( pxQueue )
N#endif
N
N#ifndef traceTASK_CREATE
N	#define traceTASK_CREATE( pxNewTCB )
N#endif
N
N#ifndef traceTASK_CREATE_FAILED
N	#define traceTASK_CREATE_FAILED()
N#endif
N
N#ifndef traceTASK_DELETE
N	#define traceTASK_DELETE( pxTaskToDelete )
N#endif
N
N#ifndef traceTASK_DELAY_UNTIL
N	#define traceTASK_DELAY_UNTIL()
N#endif
N
N#ifndef traceTASK_DELAY
N	#define traceTASK_DELAY()
N#endif
N
N#ifndef traceTASK_PRIORITY_SET
N	#define traceTASK_PRIORITY_SET( pxTask, uxNewPriority )
N#endif
N
N#ifndef traceTASK_SUSPEND
N	#define traceTASK_SUSPEND( pxTaskToSuspend )
N#endif
N
N#ifndef traceTASK_RESUME
N	#define traceTASK_RESUME( pxTaskToResume )
N#endif
N
N#ifndef traceTASK_RESUME_FROM_ISR
N	#define traceTASK_RESUME_FROM_ISR( pxTaskToResume )
N#endif
N
N#ifndef traceTASK_INCREMENT_TICK
N	#define traceTASK_INCREMENT_TICK( xTickCount )
N#endif
N
N#ifndef traceTIMER_CREATE
N	#define traceTIMER_CREATE( pxNewTimer )
N#endif
N
N#ifndef traceTIMER_CREATE_FAILED
N	#define traceTIMER_CREATE_FAILED()
N#endif
N
N#ifndef traceTIMER_COMMAND_SEND
N	#define traceTIMER_COMMAND_SEND( xTimer, xMessageID, xMessageValueValue, xReturn )
N#endif
N
N#ifndef traceTIMER_EXPIRED
N	#define traceTIMER_EXPIRED( pxTimer )
N#endif
N
N#ifndef traceTIMER_COMMAND_RECEIVED
N	#define traceTIMER_COMMAND_RECEIVED( pxTimer, xMessageID, xMessageValue )
N#endif
N
N#ifndef traceMALLOC
N    #define traceMALLOC( pvAddress, uiSize )
N#endif
N
N#ifndef traceFREE
N    #define traceFREE( pvAddress, uiSize )
N#endif
N
N#ifndef traceEVENT_GROUP_CREATE
N	#define traceEVENT_GROUP_CREATE( xEventGroup )
N#endif
N
N#ifndef traceEVENT_GROUP_CREATE_FAILED
N	#define traceEVENT_GROUP_CREATE_FAILED()
N#endif
N
N#ifndef traceEVENT_GROUP_SYNC_BLOCK
N	#define traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor )
N#endif
N
N#ifndef traceEVENT_GROUP_SYNC_END
N	#define traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
N#endif
N
N#ifndef traceEVENT_GROUP_WAIT_BITS_BLOCK
N	#define traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor )
N#endif
N
N#ifndef traceEVENT_GROUP_WAIT_BITS_END
N	#define traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
N#endif
N
N#ifndef traceEVENT_GROUP_CLEAR_BITS
N	#define traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear )
N#endif
N
N#ifndef traceEVENT_GROUP_CLEAR_BITS_FROM_ISR
N	#define traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear )
N#endif
N
N#ifndef traceEVENT_GROUP_SET_BITS
N	#define traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet )
N#endif
N
N#ifndef traceEVENT_GROUP_SET_BITS_FROM_ISR
N	#define traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet )
N#endif
N
N#ifndef traceEVENT_GROUP_DELETE
N	#define traceEVENT_GROUP_DELETE( xEventGroup )
N#endif
N
N#ifndef tracePEND_FUNC_CALL
N	#define tracePEND_FUNC_CALL(xFunctionToPend, pvParameter1, ulParameter2, ret)
N#endif
N
N#ifndef tracePEND_FUNC_CALL_FROM_ISR
N	#define tracePEND_FUNC_CALL_FROM_ISR(xFunctionToPend, pvParameter1, ulParameter2, ret)
N#endif
N
N#ifndef traceQUEUE_REGISTRY_ADD
N	#define traceQUEUE_REGISTRY_ADD(xQueue, pcQueueName)
N#endif
N
N#ifndef traceTASK_NOTIFY_TAKE_BLOCK
N	#define traceTASK_NOTIFY_TAKE_BLOCK()
N#endif
N
N#ifndef traceTASK_NOTIFY_TAKE
N	#define traceTASK_NOTIFY_TAKE()
N#endif
N
N#ifndef traceTASK_NOTIFY_WAIT_BLOCK
N	#define traceTASK_NOTIFY_WAIT_BLOCK()
N#endif
N
N#ifndef traceTASK_NOTIFY_WAIT
N	#define traceTASK_NOTIFY_WAIT()
N#endif
N
N#ifndef traceTASK_NOTIFY
N	#define traceTASK_NOTIFY()
N#endif
N
N#ifndef traceTASK_NOTIFY_FROM_ISR
N	#define traceTASK_NOTIFY_FROM_ISR()
N#endif
N
N#ifndef traceTASK_NOTIFY_GIVE_FROM_ISR
N	#define traceTASK_NOTIFY_GIVE_FROM_ISR()
N#endif
N
N#ifndef traceTASK_DELAY_SUSPEND
N	#define traceTASK_DELAY_SUSPEND( pxCurrentTCB )
N#endif
N
N#ifndef configGENERATE_RUN_TIME_STATS
S	#define configGENERATE_RUN_TIME_STATS 0
N#endif
N
N#if ( configGENERATE_RUN_TIME_STATS == 1 )
X#if ( 0 == 1 )
S
S	#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
S		#error If configGENERATE_RUN_TIME_STATS is defined then portCONFIGURE_TIMER_FOR_RUN_TIME_STATS must also be defined.  portCONFIGURE_TIMER_FOR_RUN_TIME_STATS should call a port layer function to setup a peripheral timer/counter that can then be used as the run time counter time base.
S	#endif /* portCONFIGURE_TIMER_FOR_RUN_TIME_STATS */
S
S	#ifndef portGET_RUN_TIME_COUNTER_VALUE
S		#ifndef portALT_GET_RUN_TIME_COUNTER_VALUE
S			#error If configGENERATE_RUN_TIME_STATS is defined then either portGET_RUN_TIME_COUNTER_VALUE or portALT_GET_RUN_TIME_COUNTER_VALUE must also be defined.  See the examples provided and the FreeRTOS web site for more information.
S		#endif /* portALT_GET_RUN_TIME_COUNTER_VALUE */
S	#endif /* portGET_RUN_TIME_COUNTER_VALUE */
S
N#endif /* configGENERATE_RUN_TIME_STATS */
N
N#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
N	#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()
N#endif
N
N#ifndef configUSE_MALLOC_FAILED_HOOK
S	#define configUSE_MALLOC_FAILED_HOOK 0
N#endif
N
N#ifndef portPRIVILEGE_BIT
N	#define portPRIVILEGE_BIT ( ( UBaseType_t ) 0x00 )
N#endif
N
N#ifndef portYIELD_WITHIN_API
N	#define portYIELD_WITHIN_API portYIELD
N#endif
N
N#ifndef pvPortMallocAligned
N	#define pvPortMallocAligned( x, puxStackBuffer ) ( ( ( puxStackBuffer ) == NULL ) ? ( pvPortMalloc( ( x ) ) ) : ( puxStackBuffer ) )
N#endif
N
N#ifndef vPortFreeAligned
N	#define vPortFreeAligned( pvBlockToFree ) vPortFree( pvBlockToFree )
N#endif
N
N#ifndef portSUPPRESS_TICKS_AND_SLEEP
S	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )
N#endif
N
N#ifndef configEXPECTED_IDLE_TIME_BEFORE_SLEEP
N	#define configEXPECTED_IDLE_TIME_BEFORE_SLEEP 2
N#endif
N
N#if configEXPECTED_IDLE_TIME_BEFORE_SLEEP < 2
X#if 2 < 2
S	#error configEXPECTED_IDLE_TIME_BEFORE_SLEEP must not be less than 2
N#endif
N
N#ifndef configUSE_TICKLESS_IDLE
N	#define configUSE_TICKLESS_IDLE 0
N#endif
N
N#ifndef configPRE_SLEEP_PROCESSING
N	#define configPRE_SLEEP_PROCESSING( x )
N#endif
N
N#ifndef configPOST_SLEEP_PROCESSING
N	#define configPOST_SLEEP_PROCESSING( x )
N#endif
N
N#ifndef configUSE_QUEUE_SETS
N	#define configUSE_QUEUE_SETS 0
N#endif
N
N#ifndef portTASK_USES_FLOATING_POINT
N	#define portTASK_USES_FLOATING_POINT()
N#endif
N
N#ifndef configUSE_TIME_SLICING
N	#define configUSE_TIME_SLICING 1
N#endif
N
N#ifndef configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS
N	#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0
N#endif
N
N#ifndef configUSE_NEWLIB_REENTRANT
N	#define configUSE_NEWLIB_REENTRANT 0
N#endif
N
N#ifndef configUSE_STATS_FORMATTING_FUNCTIONS
S	#define configUSE_STATS_FORMATTING_FUNCTIONS 0
N#endif
N
N#ifndef portASSERT_IF_INTERRUPT_PRIORITY_INVALID
N	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()
N#endif
N
N#ifndef configUSE_TRACE_FACILITY
S	#define configUSE_TRACE_FACILITY 0
N#endif
N
N#ifndef mtCOVERAGE_TEST_MARKER
N	#define mtCOVERAGE_TEST_MARKER()
N#endif
N
N#ifndef mtCOVERAGE_TEST_DELAY
N	#define mtCOVERAGE_TEST_DELAY()
N#endif
N
N#ifndef portASSERT_IF_IN_ISR
N	#define portASSERT_IF_IN_ISR()
N#endif
N
N#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
S	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0
N#endif
N
N#ifndef configAPPLICATION_ALLOCATED_HEAP
N	#define configAPPLICATION_ALLOCATED_HEAP 0
N#endif
N
N#ifndef configUSE_TASK_NOTIFICATIONS
N	#define configUSE_TASK_NOTIFICATIONS 1
N#endif
N
N#ifndef portTICK_TYPE_IS_ATOMIC
S	#define portTICK_TYPE_IS_ATOMIC 0
N#endif
N
N#if( portTICK_TYPE_IS_ATOMIC == 0 )
X#if( 1 == 0 )
S	/* Either variables of tick type cannot be read atomically, or
S	portTICK_TYPE_IS_ATOMIC was not set - map the critical sections used when
S	the tick count is returned to the standard critical section macros. */
S	#define portTICK_TYPE_ENTER_CRITICAL() portENTER_CRITICAL()
S	#define portTICK_TYPE_EXIT_CRITICAL() portEXIT_CRITICAL()
S	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
S	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( ( x ) )
N#else
N	/* The tick type can be read atomically, so critical sections used when the
N	tick count is returned can be defined away. */
N	#define portTICK_TYPE_ENTER_CRITICAL()
N	#define portTICK_TYPE_EXIT_CRITICAL()
N	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() 0
N	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) ( void ) x
N#endif
N
N/* Definitions to allow backward compatibility with FreeRTOS versions prior to
NV8 if desired. */
N#ifndef configENABLE_BACKWARD_COMPATIBILITY
N	#define configENABLE_BACKWARD_COMPATIBILITY 1
N#endif
N
N#if configENABLE_BACKWARD_COMPATIBILITY == 1
X#if 1 == 1
N	#define eTaskStateGet eTaskGetState
N	#define portTickType TickType_t
N	#define xTaskHandle TaskHandle_t
N	#define xQueueHandle QueueHandle_t
N	#define xSemaphoreHandle SemaphoreHandle_t
N	#define xQueueSetHandle QueueSetHandle_t
N	#define xQueueSetMemberHandle QueueSetMemberHandle_t
N	#define xTimeOutType TimeOut_t
N	#define xMemoryRegion MemoryRegion_t
N	#define xTaskParameters TaskParameters_t
N	#define xTaskStatusType	TaskStatus_t
N	#define xTimerHandle TimerHandle_t
N	#define xCoRoutineHandle CoRoutineHandle_t
N	#define pdTASK_HOOK_CODE TaskHookFunction_t
N	#define portTICK_RATE_MS portTICK_PERIOD_MS
N
N	/* Backward compatibility within the scheduler code only - these definitions
N	are not really required but are included for completeness. */
N	#define tmrTIMER_CALLBACK TimerCallbackFunction_t
N	#define pdTASK_CODE TaskFunction_t
N	#define xListItem ListItem_t
N	#define xList List_t
N#endif /* configENABLE_BACKWARD_COMPATIBILITY */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* INC_FREERTOS_H */
N
L 108 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "task.h"
L 1 "..\..\FreeRTOS\Source\include\task.h" 1
N/*
N    FreeRTOS V8.2.2 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef INC_TASK_H
N#define INC_TASK_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h must appear in source files before include task.h"
N#endif
N
N#include "list.h"
L 1 "..\..\FreeRTOS\Source\include\list.h" 1
N/*
N    FreeRTOS V8.2.2 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N/*
N * This is the list implementation used by the scheduler.  While it is tailored
N * heavily for the schedulers needs, it is also available for use by
N * application code.
N *
N * list_ts can only store pointers to list_item_ts.  Each ListItem_t contains a
N * numeric value (xItemValue).  Most of the time the lists are sorted in
N * descending item value order.
N *
N * Lists are created already containing one list item.  The value of this
N * item is the maximum possible that can be stored, it is therefore always at
N * the end of the list and acts as a marker.  The list member pxHead always
N * points to this marker - even though it is at the tail of the list.  This
N * is because the tail contains a wrap back pointer to the true head of
N * the list.
N *
N * In addition to it's value, each list item contains a pointer to the next
N * item in the list (pxNext), a pointer to the list it is in (pxContainer)
N * and a pointer to back to the object that contains it.  These later two
N * pointers are included for efficiency of list manipulation.  There is
N * effectively a two way link between the object containing the list item and
N * the list item itself.
N *
N *
N * \page ListIntroduction List Implementation
N * \ingroup FreeRTOSIntro
N */
N
N#ifndef INC_FREERTOS_H
S	#error FreeRTOS.h must be included before list.h
N#endif
N
N#ifndef LIST_H
N#define LIST_H
N
N/*
N * The list structure members are modified from within interrupts, and therefore
N * by rights should be declared volatile.  However, they are only modified in a
N * functionally atomic way (within critical sections of with the scheduler
N * suspended) and are either passed by reference into a function or indexed via
N * a volatile variable.  Therefore, in all use cases tested so far, the volatile
N * qualifier can be omitted in order to provide a moderate performance
N * improvement without adversely affecting functional behaviour.  The assembly
N * instructions generated by the IAR, ARM and GCC compilers when the respective
N * compiler's options were set for maximum optimisation has been inspected and
N * deemed to be as intended.  That said, as compiler technology advances, and
N * especially if aggressive cross module optimisation is used (a use case that
N * has not been exercised to any great extend) then it is feasible that the
N * volatile qualifier will be needed for correct optimisation.  It is expected
N * that a compiler removing essential code because, without the volatile
N * qualifier on the list structure members and with aggressive cross module
N * optimisation, the compiler deemed the code unnecessary will result in
N * complete and obvious failure of the scheduler.  If this is ever experienced
N * then the volatile qualifier can be inserted in the relevant places within the
N * list structures by simply defining configLIST_VOLATILE to volatile in
N * FreeRTOSConfig.h (as per the example at the bottom of this comment block).
N * If configLIST_VOLATILE is not defined then the preprocessor directives below
N * will simply #define configLIST_VOLATILE away completely.
N *
N * To use volatile list structure members then add the following line to
N * FreeRTOSConfig.h (without the quotes):
N * "#define configLIST_VOLATILE volatile"
N */
N#ifndef configLIST_VOLATILE
N	#define configLIST_VOLATILE
N#endif /* configSUPPORT_CROSS_MODULE_OPTIMISATION */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Macros that can be used to place known values within the list structures,
Nthen check that the known values do not get corrupted during the execution of
Nthe application.   These may catch the list data structures being overwritten in
Nmemory.  They will not catch data errors caused by incorrect configuration or
Nuse of FreeRTOS.*/
N#if( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 0 )
X#if( 0 == 0 )
N	/* Define the macros to do nothing. */
N	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE
N	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE
N	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE
N	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE
N	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
N	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
N	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )
N	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )
N	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )
N	#define listTEST_LIST_INTEGRITY( pxList )
N#else
S	/* Define macros that add new members into the list structures. */
S	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue1;
S	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue2;
S	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue1;
S	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue2;
S
S	/* Define macros that set the new structure members to known values. */
S	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )		( pxItem )->xListItemIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )	( pxItem )->xListItemIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )		( pxList )->xListIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )		( pxList )->xListIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
S
S	/* Define macros that will assert if one of the structure members does not
S	contain its expected value. */
S	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )		configASSERT( ( ( pxItem )->xListItemIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxItem )->xListItemIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
S	#define listTEST_LIST_INTEGRITY( pxList )			configASSERT( ( ( pxList )->xListIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxList )->xListIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
N#endif /* configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES */
N
N
N/*
N * Definition of the only type of object that a list can contain.
N */
Nstruct xLIST_ITEM
N{
N	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N	configLIST_VOLATILE TickType_t xItemValue;			/*< The value being listed.  In most cases this is used to sort the list in descending order. */
X	 TickType_t xItemValue;			 
N	struct xLIST_ITEM * configLIST_VOLATILE pxNext;		/*< Pointer to the next ListItem_t in the list. */
X	struct xLIST_ITEM *  pxNext;		 
N	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;	/*< Pointer to the previous ListItem_t in the list. */
X	struct xLIST_ITEM *  pxPrevious;	 
N	void * pvOwner;										/*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */
N	void * configLIST_VOLATILE pvContainer;				/*< Pointer to the list in which this list item is placed (if any). */
X	void *  pvContainer;				 
N	listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N};
Ntypedef struct xLIST_ITEM ListItem_t;					/* For some reason lint wants this as two separate definitions. */
N
Nstruct xMINI_LIST_ITEM
N{
N	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N	configLIST_VOLATILE TickType_t xItemValue;
X	 TickType_t xItemValue;
N	struct xLIST_ITEM * configLIST_VOLATILE pxNext;
X	struct xLIST_ITEM *  pxNext;
N	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;
X	struct xLIST_ITEM *  pxPrevious;
N};
Ntypedef struct xMINI_LIST_ITEM MiniListItem_t;
N
N/*
N * Definition of the type of queue used by the scheduler.
N */
Ntypedef struct xLIST
N{
N	listFIRST_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X					 
N	configLIST_VOLATILE UBaseType_t uxNumberOfItems;
X	 UBaseType_t uxNumberOfItems;
N	ListItem_t * configLIST_VOLATILE pxIndex;			/*< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). */
X	ListItem_t *  pxIndex;			 
N	MiniListItem_t xListEnd;							/*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */
N	listSECOND_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X					 
N} List_t;
N
N/*
N * Access macro to set the owner of a list item.  The owner of a list item
N * is the object (usually a TCB) that contains the list item.
N *
N * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
N * \ingroup LinkedList
N */
N#define listSET_LIST_ITEM_OWNER( pxListItem, pxOwner )		( ( pxListItem )->pvOwner = ( void * ) ( pxOwner ) )
N
N/*
N * Access macro to get the owner of a list item.  The owner of a list item
N * is the object (usually a TCB) that contains the list item.
N *
N * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
N * \ingroup LinkedList
N */
N#define listGET_LIST_ITEM_OWNER( pxListItem )	( ( pxListItem )->pvOwner )
N
N/*
N * Access macro to set the value of the list item.  In most cases the value is
N * used to sort the list in descending order.
N *
N * \page listSET_LIST_ITEM_VALUE listSET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listSET_LIST_ITEM_VALUE( pxListItem, xValue )	( ( pxListItem )->xItemValue = ( xValue ) )
N
N/*
N * Access macro to retrieve the value of the list item.  The value can
N * represent anything - for example the priority of a task, or the time at
N * which a task should be unblocked.
N *
N * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listGET_LIST_ITEM_VALUE( pxListItem )	( ( pxListItem )->xItemValue )
N
N/*
N * Access macro to retrieve the value of the list item at the head of a given
N * list.
N *
N * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext->xItemValue )
N
N/*
N * Return the list item at the head of the list.
N *
N * \page listGET_HEAD_ENTRY listGET_HEAD_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext )
N
N/*
N * Return the list item at the head of the list.
N *
N * \page listGET_NEXT listGET_NEXT
N * \ingroup LinkedList
N */
N#define listGET_NEXT( pxListItem )	( ( pxListItem )->pxNext )
N
N/*
N * Return the list item that marks the end of the list
N *
N * \page listGET_END_MARKER listGET_END_MARKER
N * \ingroup LinkedList
N */
N#define listGET_END_MARKER( pxList )	( ( ListItem_t const * ) ( &( ( pxList )->xListEnd ) ) )
N
N/*
N * Access macro to determine if a list contains any items.  The macro will
N * only have the value true if the list is empty.
N *
N * \page listLIST_IS_EMPTY listLIST_IS_EMPTY
N * \ingroup LinkedList
N */
N#define listLIST_IS_EMPTY( pxList )	( ( BaseType_t ) ( ( pxList )->uxNumberOfItems == ( UBaseType_t ) 0 ) )
N
N/*
N * Access macro to return the number of items in the list.
N */
N#define listCURRENT_LIST_LENGTH( pxList )	( ( pxList )->uxNumberOfItems )
N
N/*
N * Access function to obtain the owner of the next entry in a list.
N *
N * The list member pxIndex is used to walk through a list.  Calling
N * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list
N * and returns that entry's pxOwner parameter.  Using multiple calls to this
N * function it is therefore possible to move through every item contained in
N * a list.
N *
N * The pxOwner parameter of a list item is a pointer to the object that owns
N * the list item.  In the scheduler this is normally a task control block.
N * The pxOwner parameter effectively creates a two way link between the list
N * item and its owner.
N *
N * @param pxTCB pxTCB is set to the address of the owner of the next list item.
N * @param pxList The list from which the next item owner is to be returned.
N *
N * \page listGET_OWNER_OF_NEXT_ENTRY listGET_OWNER_OF_NEXT_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										\
N{																							\
NList_t * const pxConstList = ( pxList );													\
N	/* Increment the index to the next item and return the item, ensuring */				\
N	/* we don't return the marker used at the end of the list.  */							\
N	( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							\
N	if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )	\
N	{																						\
N		( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;						\
N	}																						\
N	( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											\
N}
X#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										{																							List_t * const pxConstList = ( pxList );														 					 								( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;								if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )		{																								( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							}																							( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											}
N
N
N/*
N * Access function to obtain the owner of the first entry in a list.  Lists
N * are normally sorted in ascending item value order.
N *
N * This function returns the pxOwner member of the first item in the list.
N * The pxOwner parameter of a list item is a pointer to the object that owns
N * the list item.  In the scheduler this is normally a task control block.
N * The pxOwner parameter effectively creates a two way link between the list
N * item and its owner.
N *
N * @param pxList The list from which the owner of the head item is to be
N * returned.
N *
N * \page listGET_OWNER_OF_HEAD_ENTRY listGET_OWNER_OF_HEAD_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_OWNER_OF_HEAD_ENTRY( pxList )  ( (&( ( pxList )->xListEnd ))->pxNext->pvOwner )
N
N/*
N * Check to see if a list item is within a list.  The list item maintains a
N * "container" pointer that points to the list it is in.  All this macro does
N * is check to see if the container and the list match.
N *
N * @param pxList The list we want to know if the list item is within.
N * @param pxListItem The list item we want to know if is in the list.
N * @return pdTRUE if the list item is in the list, otherwise pdFALSE.
N */
N#define listIS_CONTAINED_WITHIN( pxList, pxListItem ) ( ( BaseType_t ) ( ( pxListItem )->pvContainer == ( void * ) ( pxList ) ) )
N
N/*
N * Return the list a list item is contained within (referenced from).
N *
N * @param pxListItem The list item being queried.
N * @return A pointer to the List_t object that references the pxListItem
N */
N#define listLIST_ITEM_CONTAINER( pxListItem ) ( ( pxListItem )->pvContainer )
N
N/*
N * This provides a crude means of knowing if a list has been initialised, as
N * pxList->xListEnd.xItemValue is set to portMAX_DELAY by the vListInitialise()
N * function.
N */
N#define listLIST_IS_INITIALISED( pxList ) ( ( pxList )->xListEnd.xItemValue == portMAX_DELAY )
N
N/*
N * Must be called before a list is used!  This initialises all the members
N * of the list structure and inserts the xListEnd item into the list as a
N * marker to the back of the list.
N *
N * @param pxList Pointer to the list being initialised.
N *
N * \page vListInitialise vListInitialise
N * \ingroup LinkedList
N */
Nvoid vListInitialise( List_t * const pxList ) PRIVILEGED_FUNCTION;
Xvoid vListInitialise( List_t * const pxList ) ;
N
N/*
N * Must be called before a list item is used.  This sets the list container to
N * null so the item does not think that it is already contained in a list.
N *
N * @param pxItem Pointer to the list item being initialised.
N *
N * \page vListInitialiseItem vListInitialiseItem
N * \ingroup LinkedList
N */
Nvoid vListInitialiseItem( ListItem_t * const pxItem ) PRIVILEGED_FUNCTION;
Xvoid vListInitialiseItem( ListItem_t * const pxItem ) ;
N
N/*
N * Insert a list item into a list.  The item will be inserted into the list in
N * a position determined by its item value (descending item value order).
N *
N * @param pxList The list into which the item is to be inserted.
N *
N * @param pxNewListItem The item that is to be placed in the list.
N *
N * \page vListInsert vListInsert
N * \ingroup LinkedList
N */
Nvoid vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
Xvoid vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) ;
N
N/*
N * Insert a list item into a list.  The item will be inserted in a position
N * such that it will be the last item within the list returned by multiple
N * calls to listGET_OWNER_OF_NEXT_ENTRY.
N *
N * The list member pvIndex is used to walk through a list.  Calling
N * listGET_OWNER_OF_NEXT_ENTRY increments pvIndex to the next item in the list.
N * Placing an item in a list using vListInsertEnd effectively places the item
N * in the list position pointed to by pvIndex.  This means that every other
N * item within the list will be returned by listGET_OWNER_OF_NEXT_ENTRY before
N * the pvIndex parameter again points to the item being inserted.
N *
N * @param pxList The list into which the item is to be inserted.
N *
N * @param pxNewListItem The list item to be inserted into the list.
N *
N * \page vListInsertEnd vListInsertEnd
N * \ingroup LinkedList
N */
Nvoid vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
Xvoid vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) ;
N
N/*
N * Remove an item from a list.  The list item has a pointer to the list that
N * it is in, so only the list item need be passed into the function.
N *
N * @param uxListRemove The item to be removed.  The item will remove itself from
N * the list pointed to by it's pxContainer parameter.
N *
N * @return The number of items that remain in the list after the list item has
N * been removed.
N *
N * \page uxListRemove uxListRemove
N * \ingroup LinkedList
N */
NUBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) PRIVILEGED_FUNCTION;
XUBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) ;
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
L 79 "..\..\FreeRTOS\Source\include\task.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*-----------------------------------------------------------
N * MACROS AND DEFINITIONS
N *----------------------------------------------------------*/
N
N#define tskKERNEL_VERSION_NUMBER "V8.2.2"
N#define tskKERNEL_VERSION_MAJOR 8
N#define tskKERNEL_VERSION_MINOR 2
N#define tskKERNEL_VERSION_BUILD 2
N
N/**
N * task. h
N *
N * Type by which tasks are referenced.  For example, a call to xTaskCreate
N * returns (via a pointer parameter) an TaskHandle_t variable that can then
N * be used as a parameter to vTaskDelete to delete the task.
N *
N * \defgroup TaskHandle_t TaskHandle_t
N * \ingroup Tasks
N */
Ntypedef void * TaskHandle_t;
N
N/*
N * Defines the prototype to which the application task hook function must
N * conform.
N */
Ntypedef BaseType_t (*TaskHookFunction_t)( void * );
N
N/* Task states returned by eTaskGetState. */
Ntypedef enum
N{
N	eRunning = 0,	/* A task is querying the state of itself, so must be running. */
N	eReady,			/* The task being queried is in a read or pending ready list. */
N	eBlocked,		/* The task being queried is in the Blocked state. */
N	eSuspended,		/* The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */
N	eDeleted		/* The task being queried has been deleted, but its TCB has not yet been freed. */
N} eTaskState;
N
N/* Actions that can be performed when vTaskNotify() is called. */
Ntypedef enum
N{
N	eNoAction = 0,				/* Notify the task without updating its notify value. */
N	eSetBits,					/* Set bits in the task's notification value. */
N	eIncrement,					/* Increment the task's notification value. */
N	eSetValueWithOverwrite,		/* Set the task's notification value to a specific value even if the previous value has not yet been read by the task. */
N	eSetValueWithoutOverwrite	/* Set the task's notification value if the previous value has been read by the task. */
N} eNotifyAction;
N
N/*
N * Used internally only.
N */
Ntypedef struct xTIME_OUT
N{
N	BaseType_t xOverflowCount;
N	TickType_t xTimeOnEntering;
N} TimeOut_t;
N
N/*
N * Defines the memory ranges allocated to the task when an MPU is used.
N */
Ntypedef struct xMEMORY_REGION
N{
N	void *pvBaseAddress;
N	uint32_t ulLengthInBytes;
N	uint32_t ulParameters;
N} MemoryRegion_t;
N
N/*
N * Parameters required to create an MPU protected task.
N */
Ntypedef struct xTASK_PARAMETERS
N{
N	TaskFunction_t pvTaskCode;
N	const char * const pcName;	/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N	uint16_t usStackDepth;
N	void *pvParameters;
N	UBaseType_t uxPriority;
N	StackType_t *puxStackBuffer;
N	MemoryRegion_t xRegions[ portNUM_CONFIGURABLE_REGIONS ];
X	MemoryRegion_t xRegions[ 1 ];
N} TaskParameters_t;
N
N/* Used with the uxTaskGetSystemState() function to return the state of each task
Nin the system. */
Ntypedef struct xTASK_STATUS
N{
N	TaskHandle_t xHandle;			/* The handle of the task to which the rest of the information in the structure relates. */
N	const char *pcTaskName;			/* A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N	UBaseType_t xTaskNumber;		/* A number unique to the task. */
N	eTaskState eCurrentState;		/* The state in which the task existed when the structure was populated. */
N	UBaseType_t uxCurrentPriority;	/* The priority at which the task was running (may be inherited) when the structure was populated. */
N	UBaseType_t uxBasePriority;		/* The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. */
N	uint32_t ulRunTimeCounter;		/* The total run time allocated to the task so far, as defined by the run time stats clock.  See http://www.freertos.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. */
N	uint16_t usStackHighWaterMark;	/* The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. */
N} TaskStatus_t;
N
N/* Possible return values for eTaskConfirmSleepModeStatus(). */
Ntypedef enum
N{
N	eAbortSleep = 0,		/* A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. */
N	eStandardSleep,			/* Enter a sleep mode that will not last any longer than the expected idle time. */
N	eNoTasksWaitingTimeout	/* No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. */
N} eSleepModeStatus;
N
N
N/**
N * Defines the priority used by the idle task.  This must not be modified.
N *
N * \ingroup TaskUtils
N */
N#define tskIDLE_PRIORITY			( ( UBaseType_t ) 0U )
N
N/**
N * task. h
N *
N * Macro for forcing a context switch.
N *
N * \defgroup taskYIELD taskYIELD
N * \ingroup SchedulerControl
N */
N#define taskYIELD()					portYIELD()
N
N/**
N * task. h
N *
N * Macro to mark the start of a critical code region.  Preemptive context
N * switches cannot occur when in a critical region.
N *
N * NOTE: This may alter the stack (depending on the portable implementation)
N * so must be used with care!
N *
N * \defgroup taskENTER_CRITICAL taskENTER_CRITICAL
N * \ingroup SchedulerControl
N */
N#define taskENTER_CRITICAL()		portENTER_CRITICAL()
N#define taskENTER_CRITICAL_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
N
N/**
N * task. h
N *
N * Macro to mark the end of a critical code region.  Preemptive context
N * switches cannot occur when in a critical region.
N *
N * NOTE: This may alter the stack (depending on the portable implementation)
N * so must be used with care!
N *
N * \defgroup taskEXIT_CRITICAL taskEXIT_CRITICAL
N * \ingroup SchedulerControl
N */
N#define taskEXIT_CRITICAL()			portEXIT_CRITICAL()
N#define taskEXIT_CRITICAL_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( x )
N/**
N * task. h
N *
N * Macro to disable all maskable interrupts.
N *
N * \defgroup taskDISABLE_INTERRUPTS taskDISABLE_INTERRUPTS
N * \ingroup SchedulerControl
N */
N#define taskDISABLE_INTERRUPTS()	portDISABLE_INTERRUPTS()
N
N/**
N * task. h
N *
N * Macro to enable microcontroller interrupts.
N *
N * \defgroup taskENABLE_INTERRUPTS taskENABLE_INTERRUPTS
N * \ingroup SchedulerControl
N */
N#define taskENABLE_INTERRUPTS()		portENABLE_INTERRUPTS()
N
N/* Definitions returned by xTaskGetSchedulerState().  taskSCHEDULER_SUSPENDED is
N0 to generate more optimal code when configASSERT() is defined as the constant
Nis used in assert() statements. */
N#define taskSCHEDULER_SUSPENDED		( ( BaseType_t ) 0 )
N#define taskSCHEDULER_NOT_STARTED	( ( BaseType_t ) 1 )
N#define taskSCHEDULER_RUNNING		( ( BaseType_t ) 2 )
N
N
N/*-----------------------------------------------------------
N * TASK CREATION API
N *----------------------------------------------------------*/
N
N/**
N * task. h
N *<pre>
N BaseType_t xTaskCreate(
N							  TaskFunction_t pvTaskCode,
N							  const char * const pcName,
N							  uint16_t usStackDepth,
N							  void *pvParameters,
N							  UBaseType_t uxPriority,
N							  TaskHandle_t *pvCreatedTask
N						  );</pre>
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N *
N * xTaskCreate() can only be used to create a task that has unrestricted
N * access to the entire microcontroller memory map.  Systems that include MPU
N * support can alternatively create an MPU constrained task using
N * xTaskCreateRestricted().
N *
N * @param pvTaskCode Pointer to the task entry function.  Tasks
N * must be implemented to never return (i.e. continuous loop).
N *
N * @param pcName A descriptive name for the task.  This is mainly used to
N * facilitate debugging.  Max length defined by configMAX_TASK_NAME_LEN - default
N * is 16.
N *
N * @param usStackDepth The size of the task stack specified as the number of
N * variables the stack can hold - not the number of bytes.  For example, if
N * the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes
N * will be allocated for stack storage.
N *
N * @param pvParameters Pointer that will be used as the parameter for the task
N * being created.
N *
N * @param uxPriority The priority at which the task should run.  Systems that
N * include MPU support can optionally create tasks in a privileged (system)
N * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For
N * example, to create a privileged task at priority 2 the uxPriority parameter
N * should be set to ( 2 | portPRIVILEGE_BIT ).
N *
N * @param pvCreatedTask Used to pass back a handle by which the created task
N * can be referenced.
N *
N * @return pdPASS if the task was successfully created and added to a ready
N * list, otherwise an error code defined in the file projdefs.h
N *
N * Example usage:
N   <pre>
N // Task to be created.
N void vTaskCode( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N	 }
N }
N
N // Function that creates a task.
N void vOtherFunction( void )
N {
N static uint8_t ucParameterToPass;
N TaskHandle_t xHandle = NULL;
N
N	 // Create the task, storing the handle.  Note that the passed parameter ucParameterToPass
N	 // must exist for the lifetime of the task, so in this case is declared static.  If it was just an
N	 // an automatic stack variable it might no longer exist, or at least have been corrupted, by the time
N	 // the new task attempts to access it.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, &ucParameterToPass, tskIDLE_PRIORITY, &xHandle );
N     configASSERT( xHandle );
N
N	 // Use the handle to delete the task.
N     if( xHandle != NULL )
N     {
N	     vTaskDelete( xHandle );
N     }
N }
N   </pre>
N * \defgroup xTaskCreate xTaskCreate
N * \ingroup Tasks
N */
N#define xTaskCreate( pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask ) xTaskGenericCreate( ( pvTaskCode ), ( pcName ), ( usStackDepth ), ( pvParameters ), ( uxPriority ), ( pxCreatedTask ), ( NULL ), ( NULL ) )
N
N/**
N * task. h
N *<pre>
N BaseType_t xTaskCreateRestricted( TaskParameters_t *pxTaskDefinition, TaskHandle_t *pxCreatedTask );</pre>
N *
N * xTaskCreateRestricted() should only be used in systems that include an MPU
N * implementation.
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N * The function parameters define the memory regions and associated access
N * permissions allocated to the task.
N *
N * @param pxTaskDefinition Pointer to a structure that contains a member
N * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API
N * documentation) plus an optional stack buffer and the memory region
N * definitions.
N *
N * @param pxCreatedTask Used to pass back a handle by which the created task
N * can be referenced.
N *
N * @return pdPASS if the task was successfully created and added to a ready
N * list, otherwise an error code defined in the file projdefs.h
N *
N * Example usage:
N   <pre>
N// Create an TaskParameters_t structure that defines the task to be created.
Nstatic const TaskParameters_t xCheckTaskParameters =
N{
N	vATask,		// pvTaskCode - the function that implements the task.
N	"ATask",	// pcName - just a text name for the task to assist debugging.
N	100,		// usStackDepth	- the stack size DEFINED IN WORDS.
N	NULL,		// pvParameters - passed into the task function as the function parameters.
N	( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.
N	cStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.
N
N	// xRegions - Allocate up to three separate memory regions for access by
N	// the task, with appropriate access permissions.  Different processors have
N	// different memory alignment requirements - refer to the FreeRTOS documentation
N	// for full information.
N	{
N		// Base address					Length	Parameters
N        { cReadWriteArray,				32,		portMPU_REGION_READ_WRITE },
N        { cReadOnlyArray,				32,		portMPU_REGION_READ_ONLY },
N        { cPrivilegedOnlyAccessArray,	128,	portMPU_REGION_PRIVILEGED_READ_WRITE }
N	}
N};
N
Nint main( void )
N{
NTaskHandle_t xHandle;
N
N	// Create a task from the const structure defined above.  The task handle
N	// is requested (the second parameter is not NULL) but in this case just for
N	// demonstration purposes as its not actually used.
N	xTaskCreateRestricted( &xRegTest1Parameters, &xHandle );
N
N	// Start the scheduler.
N	vTaskStartScheduler();
N
N	// Will only get here if there was insufficient memory to create the idle
N	// and/or timer task.
N	for( ;; );
N}
N   </pre>
N * \defgroup xTaskCreateRestricted xTaskCreateRestricted
N * \ingroup Tasks
N */
N#define xTaskCreateRestricted( x, pxCreatedTask ) xTaskGenericCreate( ((x)->pvTaskCode), ((x)->pcName), ((x)->usStackDepth), ((x)->pvParameters), ((x)->uxPriority), (pxCreatedTask), ((x)->puxStackBuffer), ((x)->xRegions) )
N
N/**
N * task. h
N *<pre>
N void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions );</pre>
N *
N * Memory regions are assigned to a restricted task when the task is created by
N * a call to xTaskCreateRestricted().  These regions can be redefined using
N * vTaskAllocateMPURegions().
N *
N * @param xTask The handle of the task being updated.
N *
N * @param xRegions A pointer to an MemoryRegion_t structure that contains the
N * new memory region definitions.
N *
N * Example usage:
N   <pre>
N// Define an array of MemoryRegion_t structures that configures an MPU region
N// allowing read/write access for 1024 bytes starting at the beginning of the
N// ucOneKByte array.  The other two of the maximum 3 definable regions are
N// unused so set to zero.
Nstatic const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] =
N{
N	// Base address		Length		Parameters
N	{ ucOneKByte,		1024,		portMPU_REGION_READ_WRITE },
N	{ 0,				0,			0 },
N	{ 0,				0,			0 }
N};
N
Nvoid vATask( void *pvParameters )
N{
N	// This task was created such that it has access to certain regions of
N	// memory as defined by the MPU configuration.  At some point it is
N	// desired that these MPU regions are replaced with that defined in the
N	// xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()
N	// for this purpose.  NULL is used as the task handle to indicate that this
N	// function should modify the MPU regions of the calling task.
N	vTaskAllocateMPURegions( NULL, xAltRegions );
N
N	// Now the task can continue its function, but from this point on can only
N	// access its stack and the ucOneKByte array (unless any other statically
N	// defined or shared regions have been declared elsewhere).
N}
N   </pre>
N * \defgroup xTaskCreateRestricted xTaskCreateRestricted
N * \ingroup Tasks
N */
Nvoid vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) PRIVILEGED_FUNCTION;
Xvoid vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) ;
N
N/**
N * task. h
N * <pre>void vTaskDelete( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_vTaskDelete must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Remove a task from the RTOS real time kernel's management.  The task being
N * deleted will be removed from all ready, blocked, suspended and event lists.
N *
N * NOTE:  The idle task is responsible for freeing the kernel allocated
N * memory from tasks that have been deleted.  It is therefore important that
N * the idle task is not starved of microcontroller processing time if your
N * application makes any calls to vTaskDelete ().  Memory allocated by the
N * task code is not automatically freed, and should be freed before the task
N * is deleted.
N *
N * See the demo application file death.c for sample code that utilises
N * vTaskDelete ().
N *
N * @param xTask The handle of the task to be deleted.  Passing NULL will
N * cause the calling task to be deleted.
N *
N * Example usage:
N   <pre>
N void vOtherFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create the task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // Use the handle to delete the task.
N	 vTaskDelete( xHandle );
N }
N   </pre>
N * \defgroup vTaskDelete vTaskDelete
N * \ingroup Tasks
N */
Nvoid vTaskDelete( TaskHandle_t xTaskToDelete ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelete( TaskHandle_t xTaskToDelete ) ;
N
N/*-----------------------------------------------------------
N * TASK CONTROL API
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <pre>void vTaskDelay( const TickType_t xTicksToDelay );</pre>
N *
N * Delay a task for a given number of ticks.  The actual time that the
N * task remains blocked depends on the tick rate.  The constant
N * portTICK_PERIOD_MS can be used to calculate real time from the tick
N * rate - with the resolution of one tick period.
N *
N * INCLUDE_vTaskDelay must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N *
N * vTaskDelay() specifies a time at which the task wishes to unblock relative to
N * the time at which vTaskDelay() is called.  For example, specifying a block
N * period of 100 ticks will cause the task to unblock 100 ticks after
N * vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method
N * of controlling the frequency of a periodic task as the path taken through the
N * code, as well as other task and interrupt activity, will effect the frequency
N * at which vTaskDelay() gets called and therefore the time at which the task
N * next executes.  See vTaskDelayUntil() for an alternative API function designed
N * to facilitate fixed frequency execution.  It does this by specifying an
N * absolute time (rather than a relative time) at which the calling task should
N * unblock.
N *
N * @param xTicksToDelay The amount of time, in tick periods, that
N * the calling task should block.
N *
N * Example usage:
N
N void vTaskFunction( void * pvParameters )
N {
N // Block for 500ms.
N const TickType_t xDelay = 500 / portTICK_PERIOD_MS;
N
N	 for( ;; )
N	 {
N		 // Simply toggle the LED every 500ms, blocking between each toggle.
N		 vToggleLED();
N		 vTaskDelay( xDelay );
N	 }
N }
N
N * \defgroup vTaskDelay vTaskDelay
N * \ingroup TaskCtrl
N */
Nvoid vTaskDelay( const TickType_t xTicksToDelay ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelay( const TickType_t xTicksToDelay ) ;
N
N/**
N * task. h
N * <pre>void vTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement );</pre>
N *
N * INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Delay a task until a specified time.  This function can be used by periodic
N * tasks to ensure a constant execution frequency.
N *
N * This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will
N * cause a task to block for the specified number of ticks from the time vTaskDelay () is
N * called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed
N * execution frequency as the time between a task starting to execute and that task
N * calling vTaskDelay () may not be fixed [the task may take a different path though the
N * code between calls, or may get interrupted or preempted a different number of times
N * each time it executes].
N *
N * Whereas vTaskDelay () specifies a wake time relative to the time at which the function
N * is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to
N * unblock.
N *
N * The constant portTICK_PERIOD_MS can be used to calculate real time from the tick
N * rate - with the resolution of one tick period.
N *
N * @param pxPreviousWakeTime Pointer to a variable that holds the time at which the
N * task was last unblocked.  The variable must be initialised with the current time
N * prior to its first use (see the example below).  Following this the variable is
N * automatically updated within vTaskDelayUntil ().
N *
N * @param xTimeIncrement The cycle time period.  The task will be unblocked at
N * time *pxPreviousWakeTime + xTimeIncrement.  Calling vTaskDelayUntil with the
N * same xTimeIncrement parameter value will cause the task to execute with
N * a fixed interface period.
N *
N * Example usage:
N   <pre>
N // Perform an action every 10 ticks.
N void vTaskFunction( void * pvParameters )
N {
N TickType_t xLastWakeTime;
N const TickType_t xFrequency = 10;
N
N	 // Initialise the xLastWakeTime variable with the current time.
N	 xLastWakeTime = xTaskGetTickCount ();
N	 for( ;; )
N	 {
N		 // Wait for the next cycle.
N		 vTaskDelayUntil( &xLastWakeTime, xFrequency );
N
N		 // Perform action here.
N	 }
N }
N   </pre>
N * \defgroup vTaskDelayUntil vTaskDelayUntil
N * \ingroup TaskCtrl
N */
Nvoid vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) ;
N
N/**
N * task. h
N * <pre>UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Obtain the priority of any task.
N *
N * @param xTask Handle of the task to be queried.  Passing a NULL
N * handle results in the priority of the calling task being returned.
N *
N * @return The priority of xTask.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to obtain the priority of the created task.
N	 // It was created with tskIDLE_PRIORITY, but may have changed
N	 // it itself.
N	 if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )
N	 {
N		 // The task has changed it's priority.
N	 }
N
N	 // ...
N
N	 // Is our priority higher than the created task?
N	 if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )
N	 {
N		 // Our priority (obtained using NULL handle) is higher.
N	 }
N }
N   </pre>
N * \defgroup uxTaskPriorityGet uxTaskPriorityGet
N * \ingroup TaskCtrl
N */
NUBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask );</pre>
N *
N * A version of uxTaskPriorityGet() that can be used from an ISR.
N */
NUBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>eTaskState eTaskGetState( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_eTaskGetState must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Obtain the state of any task.  States are encoded by the eTaskState
N * enumerated type.
N *
N * @param xTask Handle of the task to be queried.
N *
N * @return The state of xTask at the time the function was called.  Note the
N * state of the task might change between the function being called, and the
N * functions return value being tested by the calling task.
N */
NeTaskState eTaskGetState( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XeTaskState eTaskGetState( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority );</pre>
N *
N * INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Set the priority of any task.
N *
N * A context switch will occur before the function returns if the priority
N * being set is higher than the currently executing task.
N *
N * @param xTask Handle to the task for which the priority is being set.
N * Passing a NULL handle results in the priority of the calling task being set.
N *
N * @param uxNewPriority The priority to which the task will be set.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to raise the priority of the created task.
N	 vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );
N
N	 // ...
N
N	 // Use a NULL handle to raise our priority to the same value.
N	 vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );
N }
N   </pre>
N * \defgroup vTaskPrioritySet vTaskPrioritySet
N * \ingroup TaskCtrl
N */
Nvoid vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) PRIVILEGED_FUNCTION;
Xvoid vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) ;
N
N/**
N * task. h
N * <pre>void vTaskSuspend( TaskHandle_t xTaskToSuspend );</pre>
N *
N * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Suspend any task.  When suspended a task will never get any microcontroller
N * processing time, no matter what its priority.
N *
N * Calls to vTaskSuspend are not accumulative -
N * i.e. calling vTaskSuspend () twice on the same task still only requires one
N * call to vTaskResume () to ready the suspended task.
N *
N * @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL
N * handle will cause the calling task to be suspended.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to suspend the created task.
N	 vTaskSuspend( xHandle );
N
N	 // ...
N
N	 // The created task will not run during this period, unless
N	 // another task calls vTaskResume( xHandle ).
N
N	 //...
N
N
N	 // Suspend ourselves.
N	 vTaskSuspend( NULL );
N
N	 // We cannot get here unless another task calls vTaskResume
N	 // with our handle as the parameter.
N }
N   </pre>
N * \defgroup vTaskSuspend vTaskSuspend
N * \ingroup TaskCtrl
N */
Nvoid vTaskSuspend( TaskHandle_t xTaskToSuspend ) PRIVILEGED_FUNCTION;
Xvoid vTaskSuspend( TaskHandle_t xTaskToSuspend ) ;
N
N/**
N * task. h
N * <pre>void vTaskResume( TaskHandle_t xTaskToResume );</pre>
N *
N * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Resumes a suspended task.
N *
N * A task that has been suspended by one or more calls to vTaskSuspend ()
N * will be made available for running again by a single call to
N * vTaskResume ().
N *
N * @param xTaskToResume Handle to the task being readied.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to suspend the created task.
N	 vTaskSuspend( xHandle );
N
N	 // ...
N
N	 // The created task will not run during this period, unless
N	 // another task calls vTaskResume( xHandle ).
N
N	 //...
N
N
N	 // Resume the suspended task ourselves.
N	 vTaskResume( xHandle );
N
N	 // The created task will once again get microcontroller processing
N	 // time in accordance with its priority within the system.
N }
N   </pre>
N * \defgroup vTaskResume vTaskResume
N * \ingroup TaskCtrl
N */
Nvoid vTaskResume( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
Xvoid vTaskResume( TaskHandle_t xTaskToResume ) ;
N
N/**
N * task. h
N * <pre>void xTaskResumeFromISR( TaskHandle_t xTaskToResume );</pre>
N *
N * INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be
N * available.  See the configuration section for more information.
N *
N * An implementation of vTaskResume() that can be called from within an ISR.
N *
N * A task that has been suspended by one or more calls to vTaskSuspend ()
N * will be made available for running again by a single call to
N * xTaskResumeFromISR ().
N *
N * xTaskResumeFromISR() should not be used to synchronise a task with an
N * interrupt if there is a chance that the interrupt could arrive prior to the
N * task being suspended - as this can lead to interrupts being missed. Use of a
N * semaphore as a synchronisation mechanism would avoid this eventuality.
N *
N * @param xTaskToResume Handle to the task being readied.
N *
N * @return pdTRUE if resuming the task should result in a context switch,
N * otherwise pdFALSE. This is used by the ISR to determine if a context switch
N * may be required following the ISR.
N *
N * \defgroup vTaskResumeFromISR vTaskResumeFromISR
N * \ingroup TaskCtrl
N */
NBaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) ;
N
N/*-----------------------------------------------------------
N * SCHEDULER CONTROL
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <pre>void vTaskStartScheduler( void );</pre>
N *
N * Starts the real time kernel tick processing.  After calling the kernel
N * has control over which tasks are executed and when.
N *
N * See the demo application file main.c for an example of creating
N * tasks and starting the kernel.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N	 // Create at least one task before starting the kernel.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
N
N	 // Start the real time kernel with preemption.
N	 vTaskStartScheduler ();
N
N	 // Will not get here unless a task calls vTaskEndScheduler ()
N }
N   </pre>
N *
N * \defgroup vTaskStartScheduler vTaskStartScheduler
N * \ingroup SchedulerControl
N */
Nvoid vTaskStartScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskStartScheduler( void ) ;
N
N/**
N * task. h
N * <pre>void vTaskEndScheduler( void );</pre>
N *
N * NOTE:  At the time of writing only the x86 real mode port, which runs on a PC
N * in place of DOS, implements this function.
N *
N * Stops the real time kernel tick.  All created tasks will be automatically
N * deleted and multitasking (either preemptive or cooperative) will
N * stop.  Execution then resumes from the point where vTaskStartScheduler ()
N * was called, as if vTaskStartScheduler () had just returned.
N *
N * See the demo application file main. c in the demo/PC directory for an
N * example that uses vTaskEndScheduler ().
N *
N * vTaskEndScheduler () requires an exit function to be defined within the
N * portable layer (see vPortEndScheduler () in port. c for the PC port).  This
N * performs hardware specific operations such as stopping the kernel tick.
N *
N * vTaskEndScheduler () will cause all of the resources allocated by the
N * kernel to be freed - but will not free resources allocated by application
N * tasks.
N *
N * Example usage:
N   <pre>
N void vTaskCode( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // At some point we want to end the real time kernel processing
N		 // so call ...
N		 vTaskEndScheduler ();
N	 }
N }
N
N void vAFunction( void )
N {
N	 // Create at least one task before starting the kernel.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
N
N	 // Start the real time kernel with preemption.
N	 vTaskStartScheduler ();
N
N	 // Will only get here when the vTaskCode () task has called
N	 // vTaskEndScheduler ().  When we get here we are back to single task
N	 // execution.
N }
N   </pre>
N *
N * \defgroup vTaskEndScheduler vTaskEndScheduler
N * \ingroup SchedulerControl
N */
Nvoid vTaskEndScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskEndScheduler( void ) ;
N
N/**
N * task. h
N * <pre>void vTaskSuspendAll( void );</pre>
N *
N * Suspends the scheduler without disabling interrupts.  Context switches will
N * not occur while the scheduler is suspended.
N *
N * After calling vTaskSuspendAll () the calling task will continue to execute
N * without risk of being swapped out until a call to xTaskResumeAll () has been
N * made.
N *
N * API functions that have the potential to cause a context switch (for example,
N * vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler
N * is suspended.
N *
N * Example usage:
N   <pre>
N void vTask1( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // ...
N
N		 // At some point the task wants to perform a long operation during
N		 // which it does not want to get swapped out.  It cannot use
N		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
N		 // operation may cause interrupts to be missed - including the
N		 // ticks.
N
N		 // Prevent the real time kernel swapping out the task.
N		 vTaskSuspendAll ();
N
N		 // Perform the operation here.  There is no need to use critical
N		 // sections as we have all the microcontroller processing time.
N		 // During this time interrupts will still operate and the kernel
N		 // tick count will be maintained.
N
N		 // ...
N
N		 // The operation is complete.  Restart the kernel.
N		 xTaskResumeAll ();
N	 }
N }
N   </pre>
N * \defgroup vTaskSuspendAll vTaskSuspendAll
N * \ingroup SchedulerControl
N */
Nvoid vTaskSuspendAll( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskSuspendAll( void ) ;
N
N/**
N * task. h
N * <pre>BaseType_t xTaskResumeAll( void );</pre>
N *
N * Resumes scheduler activity after it was suspended by a call to
N * vTaskSuspendAll().
N *
N * xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks
N * that were previously suspended by a call to vTaskSuspend().
N *
N * @return If resuming the scheduler caused a context switch then pdTRUE is
N *		  returned, otherwise pdFALSE is returned.
N *
N * Example usage:
N   <pre>
N void vTask1( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // ...
N
N		 // At some point the task wants to perform a long operation during
N		 // which it does not want to get swapped out.  It cannot use
N		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
N		 // operation may cause interrupts to be missed - including the
N		 // ticks.
N
N		 // Prevent the real time kernel swapping out the task.
N		 vTaskSuspendAll ();
N
N		 // Perform the operation here.  There is no need to use critical
N		 // sections as we have all the microcontroller processing time.
N		 // During this time interrupts will still operate and the real
N		 // time kernel tick count will be maintained.
N
N		 // ...
N
N		 // The operation is complete.  Restart the kernel.  We want to force
N		 // a context switch - but there is no point if resuming the scheduler
N		 // caused a context switch already.
N		 if( !xTaskResumeAll () )
N		 {
N			  taskYIELD ();
N		 }
N	 }
N }
N   </pre>
N * \defgroup xTaskResumeAll xTaskResumeAll
N * \ingroup SchedulerControl
N */
NBaseType_t xTaskResumeAll( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskResumeAll( void ) ;
N
N/*-----------------------------------------------------------
N * TASK UTILITIES
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <PRE>TickType_t xTaskGetTickCount( void );</PRE>
N *
N * @return The count of ticks since vTaskStartScheduler was called.
N *
N * \defgroup xTaskGetTickCount xTaskGetTickCount
N * \ingroup TaskUtils
N */
NTickType_t xTaskGetTickCount( void ) PRIVILEGED_FUNCTION;
XTickType_t xTaskGetTickCount( void ) ;
N
N/**
N * task. h
N * <PRE>TickType_t xTaskGetTickCountFromISR( void );</PRE>
N *
N * @return The count of ticks since vTaskStartScheduler was called.
N *
N * This is a version of xTaskGetTickCount() that is safe to be called from an
N * ISR - provided that TickType_t is the natural word size of the
N * microcontroller being used or interrupt nesting is either not supported or
N * not being used.
N *
N * \defgroup xTaskGetTickCountFromISR xTaskGetTickCountFromISR
N * \ingroup TaskUtils
N */
NTickType_t xTaskGetTickCountFromISR( void ) PRIVILEGED_FUNCTION;
XTickType_t xTaskGetTickCountFromISR( void ) ;
N
N/**
N * task. h
N * <PRE>uint16_t uxTaskGetNumberOfTasks( void );</PRE>
N *
N * @return The number of tasks that the real time kernel is currently managing.
N * This includes all ready, blocked and suspended tasks.  A task that
N * has been deleted but not yet freed by the idle task will also be
N * included in the count.
N *
N * \defgroup uxTaskGetNumberOfTasks uxTaskGetNumberOfTasks
N * \ingroup TaskUtils
N */
NUBaseType_t uxTaskGetNumberOfTasks( void ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetNumberOfTasks( void ) ;
N
N/**
N * task. h
N * <PRE>char *pcTaskGetTaskName( TaskHandle_t xTaskToQuery );</PRE>
N *
N * @return The text (human readable) name of the task referenced by the handle
N * xTaskToQuery.  A task can query its own name by either passing in its own
N * handle, or by setting xTaskToQuery to NULL.  INCLUDE_pcTaskGetTaskName must be
N * set to 1 in FreeRTOSConfig.h for pcTaskGetTaskName() to be available.
N *
N * \defgroup pcTaskGetTaskName pcTaskGetTaskName
N * \ingroup TaskUtils
N */
Nchar *pcTaskGetTaskName( TaskHandle_t xTaskToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xchar *pcTaskGetTaskName( TaskHandle_t xTaskToQuery ) ;  
N
N/**
N * task.h
N * <PRE>UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );</PRE>
N *
N * INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for
N * this function to be available.
N *
N * Returns the high water mark of the stack associated with xTask.  That is,
N * the minimum free stack space there has been (in words, so on a 32 bit machine
N * a value of 1 means 4 bytes) since the task started.  The smaller the returned
N * number the closer the task has come to overflowing its stack.
N *
N * @param xTask Handle of the task associated with the stack to be checked.
N * Set xTask to NULL to check the stack of the calling task.
N *
N * @return The smallest amount of free stack space there has been (in words, so
N * actual spaces on the stack rather than bytes) since the task referenced by
N * xTask was created.
N */
NUBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) ;
N
N/* When using trace macros it is sometimes necessary to include task.h before
NFreeRTOS.h.  When this is done TaskHookFunction_t will not yet have been defined,
Nso the following two prototypes will cause a compilation error.  This can be
Nfixed by simply guarding against the inclusion of these two prototypes unless
Nthey are explicitly required by the configUSE_APPLICATION_TASK_TAG configuration
Nconstant. */
N#ifdef configUSE_APPLICATION_TASK_TAG
N	#if configUSE_APPLICATION_TASK_TAG == 1
X	#if 0 == 1
S		/**
S		 * task.h
S		 * <pre>void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction );</pre>
S		 *
S		 * Sets pxHookFunction to be the task hook function used by the task xTask.
S		 * Passing xTask as NULL has the effect of setting the calling tasks hook
S		 * function.
S		 */
S		void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction ) PRIVILEGED_FUNCTION;
S
S		/**
S		 * task.h
S		 * <pre>void xTaskGetApplicationTaskTag( TaskHandle_t xTask );</pre>
S		 *
S		 * Returns the pxHookFunction value assigned to the task xTask.
S		 */
S		TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
N	#endif /* configUSE_APPLICATION_TASK_TAG ==1 */
N#endif /* ifdef configUSE_APPLICATION_TASK_TAG */
N
N#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
X#if( 0 > 0 )
S
S	/* Each task contains an array of pointers that is dimensioned by the
S	configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.  The
S	kernel does not use the pointers itself, so the application writer can use
S	the pointers for any purpose they wish.  The following two functions are
S	used to set and query a pointer respectively. */
S	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue ) PRIVILEGED_FUNCTION;
S	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex ) PRIVILEGED_FUNCTION;
S
N#endif
N
N/**
N * task.h
N * <pre>BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter );</pre>
N *
N * Calls the hook function associated with xTask.  Passing xTask as NULL has
N * the effect of calling the Running tasks (the calling task) hook function.
N *
N * pvParameter is passed to the hook function for the task to interpret as it
N * wants.  The return value is the value returned by the task hook function
N * registered by the user.
N */
NBaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) ;
N
N/**
N * xTaskGetIdleTaskHandle() is only available if
N * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.
N *
N * Simply returns the handle of the idle task.  It is not valid to call
N * xTaskGetIdleTaskHandle() before the scheduler has been started.
N */
NTaskHandle_t xTaskGetIdleTaskHandle( void ) PRIVILEGED_FUNCTION;
XTaskHandle_t xTaskGetIdleTaskHandle( void ) ;
N
N/**
N * configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for
N * uxTaskGetSystemState() to be available.
N *
N * uxTaskGetSystemState() populates an TaskStatus_t structure for each task in
N * the system.  TaskStatus_t structures contain, among other things, members
N * for the task handle, task name, task priority, task state, and total amount
N * of run time consumed by the task.  See the TaskStatus_t structure
N * definition in this file for the full member list.
N *
N * NOTE:  This function is intended for debugging use only as its use results in
N * the scheduler remaining suspended for an extended period.
N *
N * @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures.
N * The array must contain at least one TaskStatus_t structure for each task
N * that is under the control of the RTOS.  The number of tasks under the control
N * of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.
N *
N * @param uxArraySize The size of the array pointed to by the pxTaskStatusArray
N * parameter.  The size is specified as the number of indexes in the array, or
N * the number of TaskStatus_t structures contained in the array, not by the
N * number of bytes in the array.
N *
N * @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in
N * FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the
N * total run time (as defined by the run time stats clock, see
N * http://www.freertos.org/rtos-run-time-stats.html) since the target booted.
N * pulTotalRunTime can be set to NULL to omit the total run time information.
N *
N * @return The number of TaskStatus_t structures that were populated by
N * uxTaskGetSystemState().  This should equal the number returned by the
N * uxTaskGetNumberOfTasks() API function, but will be zero if the value passed
N * in the uxArraySize parameter was too small.
N *
N * Example usage:
N   <pre>
N    // This example demonstrates how a human readable table of run time stats
N	// information is generated from raw data provided by uxTaskGetSystemState().
N	// The human readable table is written to pcWriteBuffer
N	void vTaskGetRunTimeStats( char *pcWriteBuffer )
N	{
N	TaskStatus_t *pxTaskStatusArray;
N	volatile UBaseType_t uxArraySize, x;
N	uint32_t ulTotalRunTime, ulStatsAsPercentage;
N
N		// Make sure the write buffer does not contain a string.
N		*pcWriteBuffer = 0x00;
N
N		// Take a snapshot of the number of tasks in case it changes while this
N		// function is executing.
N		uxArraySize = uxTaskGetNumberOfTasks();
N
N		// Allocate a TaskStatus_t structure for each task.  An array could be
N		// allocated statically at compile time.
N		pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );
N
N		if( pxTaskStatusArray != NULL )
N		{
N			// Generate raw status information about each task.
N			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );
N
N			// For percentage calculations.
N			ulTotalRunTime /= 100UL;
N
N			// Avoid divide by zero errors.
N			if( ulTotalRunTime > 0 )
N			{
N				// For each populated position in the pxTaskStatusArray array,
N				// format the raw data as human readable ASCII data
N				for( x = 0; x < uxArraySize; x++ )
N				{
N					// What percentage of the total run time has the task used?
N					// This will always be rounded down to the nearest integer.
N					// ulTotalRunTimeDiv100 has already been divided by 100.
N					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;
N
N					if( ulStatsAsPercentage > 0UL )
N					{
N						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
N					}
N					else
N					{
N						// If the percentage is zero here then the task has
N						// consumed less than 1% of the total run time.
N						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );
N					}
N
N					pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );
N				}
N			}
N
N			// The array is no longer needed, free the memory it consumes.
N			vPortFree( pxTaskStatusArray );
N		}
N	}
N	</pre>
N */
NUBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) ;
N
N/**
N * task. h
N * <PRE>void vTaskList( char *pcWriteBuffer );</PRE>
N *
N * configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must
N * both be defined as 1 for this function to be available.  See the
N * configuration section of the FreeRTOS.org website for more information.
N *
N * NOTE 1: This function will disable interrupts for its duration.  It is
N * not intended for normal application runtime use but as a debug aid.
N *
N * Lists all the current tasks, along with their current state and stack
N * usage high water mark.
N *
N * Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or
N * suspended ('S').
N *
N * PLEASE NOTE:
N *
N * This function is provided for convenience only, and is used by many of the
N * demo applications.  Do not consider it to be part of the scheduler.
N *
N * vTaskList() calls uxTaskGetSystemState(), then formats part of the
N * uxTaskGetSystemState() output into a human readable table that displays task
N * names, states and stack usage.
N *
N * vTaskList() has a dependency on the sprintf() C library function that might
N * bloat the code size, use a lot of stack, and provide different results on
N * different platforms.  An alternative, tiny, third party, and limited
N * functionality implementation of sprintf() is provided in many of the
N * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
N * printf-stdarg.c does not provide a full snprintf() implementation!).
N *
N * It is recommended that production systems call uxTaskGetSystemState()
N * directly to get access to raw stats data, rather than indirectly through a
N * call to vTaskList().
N *
N * @param pcWriteBuffer A buffer into which the above mentioned details
N * will be written, in ASCII form.  This buffer is assumed to be large
N * enough to contain the generated report.  Approximately 40 bytes per
N * task should be sufficient.
N *
N * \defgroup vTaskList vTaskList
N * \ingroup TaskUtils
N */
Nvoid vTaskList( char * pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xvoid vTaskList( char * pcWriteBuffer ) ;  
N
N/**
N * task. h
N * <PRE>void vTaskGetRunTimeStats( char *pcWriteBuffer );</PRE>
N *
N * configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS
N * must both be defined as 1 for this function to be available.  The application
N * must also then provide definitions for
N * portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()
N * to configure a peripheral timer/counter and return the timers current count
N * value respectively.  The counter should be at least 10 times the frequency of
N * the tick count.
N *
N * NOTE 1: This function will disable interrupts for its duration.  It is
N * not intended for normal application runtime use but as a debug aid.
N *
N * Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total
N * accumulated execution time being stored for each task.  The resolution
N * of the accumulated time value depends on the frequency of the timer
N * configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.
N * Calling vTaskGetRunTimeStats() writes the total execution time of each
N * task into a buffer, both as an absolute count value and as a percentage
N * of the total system execution time.
N *
N * NOTE 2:
N *
N * This function is provided for convenience only, and is used by many of the
N * demo applications.  Do not consider it to be part of the scheduler.
N *
N * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the
N * uxTaskGetSystemState() output into a human readable table that displays the
N * amount of time each task has spent in the Running state in both absolute and
N * percentage terms.
N *
N * vTaskGetRunTimeStats() has a dependency on the sprintf() C library function
N * that might bloat the code size, use a lot of stack, and provide different
N * results on different platforms.  An alternative, tiny, third party, and
N * limited functionality implementation of sprintf() is provided in many of the
N * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
N * printf-stdarg.c does not provide a full snprintf() implementation!).
N *
N * It is recommended that production systems call uxTaskGetSystemState() directly
N * to get access to raw stats data, rather than indirectly through a call to
N * vTaskGetRunTimeStats().
N *
N * @param pcWriteBuffer A buffer into which the execution times will be
N * written, in ASCII form.  This buffer is assumed to be large enough to
N * contain the generated report.  Approximately 40 bytes per task should
N * be sufficient.
N *
N * \defgroup vTaskGetRunTimeStats vTaskGetRunTimeStats
N * \ingroup TaskUtils
N */
Nvoid vTaskGetRunTimeStats( char *pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xvoid vTaskGetRunTimeStats( char *pcWriteBuffer ) ;  
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param ulValue Data that can be sent with the notification.  How the data is
N * used depends on the value of the eAction parameter.
N *
N * @param eAction Specifies how the notification updates the task's notification
N * value, if at all.  Valid values for eAction are as follows:
N *
N * eSetBits -
N * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
N * always returns pdPASS in this case.
N *
N * eIncrement -
N * The task's notification value is incremented.  ulValue is not used and
N * xTaskNotify() always returns pdPASS in this case.
N *
N * eSetValueWithOverwrite -
N * The task's notification value is set to the value of ulValue, even if the
N * task being notified had not yet processed the previous notification (the
N * task already had a notification pending).  xTaskNotify() always returns
N * pdPASS in this case.
N *
N * eSetValueWithoutOverwrite -
N * If the task being notified did not already have a notification pending then
N * the task's notification value is set to ulValue and xTaskNotify() will
N * return pdPASS.  If the task being notified already had a notification
N * pending then no action is performed and pdFAIL is returned.
N *
N * eNoAction -
N * The task receives a notification without its notification value being
N * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
N * this case.
N *
N *  pulPreviousNotificationValue -
N *  Can be used to pass out the subject task's notification value before any
N *  bits are modified by the notify function.
N *
N * @return Dependent on the value of eAction.  See the description of the
N * eAction parameter.
N *
N * \defgroup xTaskNotify xTaskNotify
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) ;
N#define xTaskNotify( xTaskToNotify, ulValue, eAction ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL )
N#define xTaskNotifyAndQuery( xTaskToNotify, ulValue, eAction, pulPreviousNotifyValue ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotifyValue ) )
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * A version of xTaskNotify() that can be used from an interrupt service routine
N * (ISR).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param ulValue Data that can be sent with the notification.  How the data is
N * used depends on the value of the eAction parameter.
N *
N * @param eAction Specifies how the notification updates the task's notification
N * value, if at all.  Valid values for eAction are as follows:
N *
N * eSetBits -
N * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
N * always returns pdPASS in this case.
N *
N * eIncrement -
N * The task's notification value is incremented.  ulValue is not used and
N * xTaskNotify() always returns pdPASS in this case.
N *
N * eSetValueWithOverwrite -
N * The task's notification value is set to the value of ulValue, even if the
N * task being notified had not yet processed the previous notification (the
N * task already had a notification pending).  xTaskNotify() always returns
N * pdPASS in this case.
N *
N * eSetValueWithoutOverwrite -
N * If the task being notified did not already have a notification pending then
N * the task's notification value is set to ulValue and xTaskNotify() will
N * return pdPASS.  If the task being notified already had a notification
N * pending then no action is performed and pdFAIL is returned.
N *
N * eNoAction -
N * The task receives a notification without its notification value being
N * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
N * this case.
N *
N * @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
N * task to which the notification was sent to leave the Blocked state, and the
N * unblocked task has a priority higher than the currently running task.  If
N * xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should
N * be requested before the interrupt is exited.  How a context switch is
N * requested from an ISR is dependent on the port - see the documentation page
N * for the port in use.
N *
N * @return Dependent on the value of eAction.  See the description of the
N * eAction parameter.
N *
N * \defgroup xTaskNotify xTaskNotify
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) ;
N#define xTaskNotifyFromISR( xTaskToNotify, ulValue, eAction, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL, ( pxHigherPriorityTaskWoken ) )
N#define xTaskNotifyAndQueryFromISR( xTaskToNotify, ulValue, eAction, pulPreviousNotificationValue, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotificationValue ), ( pxHigherPriorityTaskWoken ) )
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );</pre>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value
N * will be cleared in the calling task's notification value before the task
N * checks to see if any notifications are pending, and optionally blocks if no
N * notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if
N * limits.h is included) or 0xffffffffUL (if limits.h is not included) will have
N * the effect of resetting the task's notification value to 0.  Setting
N * ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged.
N *
N * @param ulBitsToClearOnExit If a notification is pending or received before
N * the calling task exits the xTaskNotifyWait() function then the task's
N * notification value (see the xTaskNotify() API function) is passed out using
N * the pulNotificationValue parameter.  Then any bits that are set in
N * ulBitsToClearOnExit will be cleared in the task's notification value (note
N * *pulNotificationValue is set before any bits are cleared).  Setting
N * ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL
N * (if limits.h is not included) will have the effect of resetting the task's
N * notification value to 0 before the function exits.  Setting
N * ulBitsToClearOnExit to 0 will leave the task's notification value unchanged
N * when the function exits (in which case the value passed out in
N * pulNotificationValue will match the task's notification value).
N *
N * @param pulNotificationValue Used to pass the task's notification value out
N * of the function.  Note the value passed out will not be effected by the
N * clearing of any bits caused by ulBitsToClearOnExit being non-zero.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait in
N * the Blocked state for a notification to be received, should a notification
N * not already be pending when xTaskNotifyWait() was called.  The task
N * will not consume any processing time while it is in the Blocked state.  This
N * is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be
N * used to convert a time specified in milliseconds to a time specified in
N * ticks.
N *
N * @return If a notification was received (including notifications that were
N * already pending when xTaskNotifyWait was called) then pdPASS is
N * returned.  Otherwise pdFAIL is returned.
N *
N * \defgroup xTaskNotifyWait xTaskNotifyWait
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) ;
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyGive( TaskHandle_t xTaskToNotify );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
N * to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * xTaskNotifyGive() is a helper macro intended for use when task notifications
N * are used as light weight and faster binary or counting semaphore equivalents.
N * Actual FreeRTOS semaphores are given using the xSemaphoreGive() API function,
N * the equivalent action that instead uses a task notification is
N * xTaskNotifyGive().
N *
N * When task notifications are being used as a binary or counting semaphore
N * equivalent then the task being notified should wait for the notification
N * using the ulTaskNotificationTake() API function rather than the
N * xTaskNotifyWait() API function.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @return xTaskNotifyGive() is a macro that calls xTaskNotify() with the
N * eAction parameter set to eIncrement - so pdPASS is always returned.
N *
N * \defgroup xTaskNotifyGive xTaskNotifyGive
N * \ingroup TaskNotifications
N */
N#define xTaskNotifyGive( xTaskToNotify ) xTaskGenericNotify( ( xTaskToNotify ), ( 0 ), eIncrement, NULL )
N
N/**
N * task. h
N * <PRE>void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
N * to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * A version of xTaskNotifyGive() that can be called from an interrupt service
N * routine (ISR).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * vTaskNotifyGiveFromISR() is intended for use when task notifications are
N * used as light weight and faster binary or counting semaphore equivalents.
N * Actual FreeRTOS semaphores are given from an ISR using the
N * xSemaphoreGiveFromISR() API function, the equivalent action that instead uses
N * a task notification is vTaskNotifyGiveFromISR().
N *
N * When task notifications are being used as a binary or counting semaphore
N * equivalent then the task being notified should wait for the notification
N * using the ulTaskNotificationTake() API function rather than the
N * xTaskNotifyWait() API function.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
N * task to which the notification was sent to leave the Blocked state, and the
N * unblocked task has a priority higher than the currently running task.  If
N * vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch
N * should be requested before the interrupt is exited.  How a context switch is
N * requested from an ISR is dependent on the port - see the documentation page
N * for the port in use.
N *
N * \defgroup xTaskNotifyWait xTaskNotifyWait
N * \ingroup TaskNotifications
N */
Nvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
Xvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) ;
N
N/**
N * task. h
N * <PRE>uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );</pre>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * ulTaskNotifyTake() is intended for use when a task notification is used as a
N * faster and lighter weight binary or counting semaphore alternative.  Actual
N * FreeRTOS semaphores are taken using the xSemaphoreTake() API function, the
N * equivalent action that instead uses a task notification is
N * ulTaskNotifyTake().
N *
N * When a task is using its notification value as a binary or counting semaphore
N * other tasks should send notifications to it using the xTaskNotifyGive()
N * macro, or xTaskNotify() function with the eAction parameter set to
N * eIncrement.
N *
N * ulTaskNotifyTake() can either clear the task's notification value to
N * zero on exit, in which case the notification value acts like a binary
N * semaphore, or decrement the task's notification value on exit, in which case
N * the notification value acts like a counting semaphore.
N *
N * A task can use ulTaskNotifyTake() to [optionally] block to wait for a
N * the task's notification value to be non-zero.  The task does not consume any
N * CPU time while it is in the Blocked state.
N *
N * Where as xTaskNotifyWait() will return when a notification is pending,
N * ulTaskNotifyTake() will return when the task's notification value is
N * not zero.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's
N * notification value is decremented when the function exits.  In this way the
N * notification value acts like a counting semaphore.  If xClearCountOnExit is
N * not pdFALSE then the task's notification value is cleared to zero when the
N * function exits.  In this way the notification value acts like a binary
N * semaphore.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait in
N * the Blocked state for the task's notification value to be greater than zero,
N * should the count not already be greater than zero when
N * ulTaskNotifyTake() was called.  The task will not consume any processing
N * time while it is in the Blocked state.  This is specified in kernel ticks,
N * the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time
N * specified in milliseconds to a time specified in ticks.
N *
N * @return The task's notification count before it is either cleared to zero or
N * decremented (see the xClearCountOnExit parameter).
N *
N * \defgroup ulTaskNotifyTake ulTaskNotifyTake
N * \ingroup TaskNotifications
N */
Nuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) ;
N
N/*-----------------------------------------------------------
N * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
N *----------------------------------------------------------*/
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
N * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
N * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * Called from the real time kernel tick (either preemptive or cooperative),
N * this increments the tick count and checks if any tasks that are blocked
N * for a finite period required removing from a blocked list and placing on
N * a ready list.  If a non-zero value is returned then a context switch is
N * required because either:
N *   + A task was removed from a blocked list because its timeout had expired,
N *     or
N *   + Time slicing is in use and there is a task of equal priority to the
N *     currently running task.
N */
NBaseType_t xTaskIncrementTick( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskIncrementTick( void ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * Removes the calling task from the ready list and places it both
N * on the list of tasks waiting for a particular event, and the
N * list of delayed tasks.  The task will be removed from both lists
N * and replaced on the ready list should either the event occur (and
N * there be no higher priority tasks waiting on the same event) or
N * the delay period expires.
N *
N * The 'unordered' version replaces the event list item value with the
N * xItemValue value, and inserts the list item at the end of the list.
N *
N * The 'ordered' version uses the existing event list item value (which is the
N * owning tasks priority) to insert the list item into the event list is task
N * priority order.
N *
N * @param pxEventList The list containing tasks that are blocked waiting
N * for the event to occur.
N *
N * @param xItemValue The item value to use for the event list item when the
N * event list is not ordered by task priority.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait
N * for the event to occur.  This is specified in kernel ticks,the constant
N * portTICK_PERIOD_MS can be used to convert kernel ticks into a real time
N * period.
N */
Nvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) ;
Nvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * This function performs nearly the same function as vTaskPlaceOnEventList().
N * The difference being that this function does not permit tasks to block
N * indefinitely, whereas vTaskPlaceOnEventList() does.
N *
N */
Nvoid vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * Removes a task from both the specified event list and the list of blocked
N * tasks, and places it on a ready queue.
N *
N * xTaskRemoveFromEventList()/xTaskRemoveFromUnorderedEventList() will be called
N * if either an event occurs to unblock a task, or the block timeout period
N * expires.
N *
N * xTaskRemoveFromEventList() is used when the event list is in task priority
N * order.  It removes the list item from the head of the event list as that will
N * have the highest priority owning task of all the tasks on the event list.
N * xTaskRemoveFromUnorderedEventList() is used when the event list is not
N * ordered and the event list items hold something other than the owning tasks
N * priority.  In this case the event list item value is updated to the value
N * passed in the xItemValue parameter.
N *
N * @return pdTRUE if the task being removed has a higher priority than the task
N * making the call, otherwise pdFALSE.
N */
NBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) ;
NBaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
N * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
N * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * Sets the pointer to the current TCB to the TCB of the highest priority task
N * that is ready to run.
N */
Nvoid vTaskSwitchContext( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskSwitchContext( void ) ;
N
N/*
N * THESE FUNCTIONS MUST NOT BE USED FROM APPLICATION CODE.  THEY ARE USED BY
N * THE EVENT BITS MODULE.
N */
NTickType_t uxTaskResetEventItemValue( void ) PRIVILEGED_FUNCTION;
XTickType_t uxTaskResetEventItemValue( void ) ;
N
N/*
N * Return the handle of the calling task.
N */
NTaskHandle_t xTaskGetCurrentTaskHandle( void ) PRIVILEGED_FUNCTION;
XTaskHandle_t xTaskGetCurrentTaskHandle( void ) ;
N
N/*
N * Capture the current time status for future reference.
N */
Nvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;
Xvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) ;
N
N/*
N * Compare the time status now with that previously captured to see if the
N * timeout has expired.
N */
NBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) ;
N
N/*
N * Shortcut used by the queue implementation to prevent unnecessary call to
N * taskYIELD();
N */
Nvoid vTaskMissedYield( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskMissedYield( void ) ;
N
N/*
N * Returns the scheduler state as taskSCHEDULER_RUNNING,
N * taskSCHEDULER_NOT_STARTED or taskSCHEDULER_SUSPENDED.
N */
NBaseType_t xTaskGetSchedulerState( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGetSchedulerState( void ) ;
N
N/*
N * Raises the priority of the mutex holder to that of the calling task should
N * the mutex holder have a priority less than the calling task.
N */
Nvoid vTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
Xvoid vTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) ;
N
N/*
N * Set the priority of a task back to its proper priority in the case that it
N * inherited a higher priority while it was holding a semaphore.
N */
NBaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) ;
N
N/*
N * Generic version of the task creation function which is in turn called by the
N * xTaskCreate() and xTaskCreateRestricted() macros.
N */
NBaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
XBaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) ;  
N
N/*
N * Get the uxTCBNumber assigned to the task referenced by the xTask parameter.
N */
NUBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) ;
N
N/*
N * Set the uxTaskNumber of the task referenced by the xTask parameter to
N * uxHandle.
N */
Nvoid vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) PRIVILEGED_FUNCTION;
Xvoid vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) ;
N
N/*
N * Only available when configUSE_TICKLESS_IDLE is set to 1.
N * If tickless mode is being used, or a low power mode is implemented, then
N * the tick interrupt will not execute during idle periods.  When this is the
N * case, the tick count value maintained by the scheduler needs to be kept up
N * to date with the actual execution time by being skipped forward by a time
N * equal to the idle period.
N */
Nvoid vTaskStepTick( const TickType_t xTicksToJump ) PRIVILEGED_FUNCTION;
Xvoid vTaskStepTick( const TickType_t xTicksToJump ) ;
N
N/*
N * Only avilable when configUSE_TICKLESS_IDLE is set to 1.
N * Provided for use within portSUPPRESS_TICKS_AND_SLEEP() to allow the port
N * specific sleep function to determine if it is ok to proceed with the sleep,
N * and if it is ok to proceed, if it is ok to sleep indefinitely.
N *
N * This function is necessary because portSUPPRESS_TICKS_AND_SLEEP() is only
N * called with the scheduler suspended, not from within a critical section.  It
N * is therefore possible for an interrupt to request a context switch between
N * portSUPPRESS_TICKS_AND_SLEEP() and the low power mode actually being
N * entered.  eTaskConfirmSleepModeStatus() should be called from a short
N * critical section between the timer being stopped and the sleep mode being
N * entered to ensure it is ok to proceed into the sleep mode.
N */
NeSleepModeStatus eTaskConfirmSleepModeStatus( void ) PRIVILEGED_FUNCTION;
XeSleepModeStatus eTaskConfirmSleepModeStatus( void ) ;
N
N/*
N * For internal use only.  Increment the mutex held count when a mutex is
N * taken and return the handle of the task that has taken the mutex.
N */
Nvoid *pvTaskIncrementMutexHeldCount( void ) PRIVILEGED_FUNCTION;
Xvoid *pvTaskIncrementMutexHeldCount( void ) ;
N
N#ifdef __cplusplus
S}
N#endif
N#endif /* INC_TASK_H */
N
N
N
L 109 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "queue.h"
L 1 "..\..\FreeRTOS\Source\include\queue.h" 1
N/*
N    FreeRTOS V8.2.2 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef QUEUE_H
N#define QUEUE_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h" must appear in source files before "include queue.h"
N#endif
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/**
N * Type by which queues are referenced.  For example, a call to xQueueCreate()
N * returns an QueueHandle_t variable that can then be used as a parameter to
N * xQueueSend(), xQueueReceive(), etc.
N */
Ntypedef void * QueueHandle_t;
N
N/**
N * Type by which queue sets are referenced.  For example, a call to
N * xQueueCreateSet() returns an xQueueSet variable that can then be used as a
N * parameter to xQueueSelectFromSet(), xQueueAddToSet(), etc.
N */
Ntypedef void * QueueSetHandle_t;
N
N/**
N * Queue sets can contain both queues and semaphores, so the
N * QueueSetMemberHandle_t is defined as a type to be used where a parameter or
N * return value can be either an QueueHandle_t or an SemaphoreHandle_t.
N */
Ntypedef void * QueueSetMemberHandle_t;
N
N/* For internal use only. */
N#define	queueSEND_TO_BACK		( ( BaseType_t ) 0 )
N#define	queueSEND_TO_FRONT		( ( BaseType_t ) 1 )
N#define queueOVERWRITE			( ( BaseType_t ) 2 )
N
N/* For internal use only.  These definitions *must* match those in queue.c. */
N#define queueQUEUE_TYPE_BASE				( ( uint8_t ) 0U )
N#define queueQUEUE_TYPE_SET					( ( uint8_t ) 0U )
N#define queueQUEUE_TYPE_MUTEX 				( ( uint8_t ) 1U )
N#define queueQUEUE_TYPE_COUNTING_SEMAPHORE	( ( uint8_t ) 2U )
N#define queueQUEUE_TYPE_BINARY_SEMAPHORE	( ( uint8_t ) 3U )
N#define queueQUEUE_TYPE_RECURSIVE_MUTEX		( ( uint8_t ) 4U )
N
N/**
N * queue. h
N * <pre>
N QueueHandle_t xQueueCreate(
N							  UBaseType_t uxQueueLength,
N							  UBaseType_t uxItemSize
N						  );
N * </pre>
N *
N * Creates a new queue instance.  This allocates the storage required by the
N * new queue and returns a handle for the queue.
N *
N * @param uxQueueLength The maximum number of items that the queue can contain.
N *
N * @param uxItemSize The number of bytes each item in the queue will require.
N * Items are queued by copy, not by reference, so this is the number of bytes
N * that will be copied for each posted item.  Each item on the queue must be
N * the same size.
N *
N * @return If the queue is successfully create then a handle to the newly
N * created queue is returned.  If the queue cannot be created then 0 is
N * returned.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N };
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N	if( xQueue1 == 0 )
N	{
N		// Queue was not created and must not be used.
N	}
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue2 == 0 )
N	{
N		// Queue was not created and must not be used.
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueCreate xQueueCreate
N * \ingroup QueueManagement
N */
N#define xQueueCreate( uxQueueLength, uxItemSize ) xQueueGenericCreate( uxQueueLength, uxItemSize, queueQUEUE_TYPE_BASE )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToToFront(
N								   QueueHandle_t	xQueue,
N								   const void		*pvItemToQueue,
N								   TickType_t		xTicksToWait
N							   );
N * </pre>
N *
N * This is a macro that calls xQueueGenericSend().
N *
N * Post an item to the front of a queue.  The item is queued by copy, not by
N * reference.  This function must not be called from an interrupt service
N * routine.  See xQueueSendFromISR () for an alternative which may be used
N * in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the
N * queue is full.  The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueSendToFront( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueSendToFront( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
N#define xQueueSendToFront( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_FRONT )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToBack(
N								   QueueHandle_t	xQueue,
N								   const void		*pvItemToQueue,
N								   TickType_t		xTicksToWait
N							   );
N * </pre>
N *
N * This is a macro that calls xQueueGenericSend().
N *
N * Post an item to the back of a queue.  The item is queued by copy, not by
N * reference.  This function must not be called from an interrupt service
N * routine.  See xQueueSendFromISR () for an alternative which may be used
N * in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the queue
N * is full.  The  time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueSendToBack( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueSendToBack( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
N#define xQueueSendToBack( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSend(
N							  QueueHandle_t xQueue,
N							  const void * pvItemToQueue,
N							  TickType_t xTicksToWait
N						 );
N * </pre>
N *
N * This is a macro that calls xQueueGenericSend().  It is included for
N * backward compatibility with versions of FreeRTOS.org that did not
N * include the xQueueSendToFront() and xQueueSendToBack() macros.  It is
N * equivalent to xQueueSendToBack().
N *
N * Post an item on a queue.  The item is queued by copy, not by reference.
N * This function must not be called from an interrupt service routine.
N * See xQueueSendFromISR () for an alternative which may be used in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the
N * queue is full.  The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
N#define xQueueSend( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueOverwrite(
N							  QueueHandle_t xQueue,
N							  const void * pvItemToQueue
N						 );
N * </pre>
N *
N * Only for use with queues that have a length of one - so the queue is either
N * empty or full.
N *
N * Post an item on a queue.  If the queue is already full then overwrite the
N * value held in the queue.  The item is queued by copy, not by reference.
N *
N * This function must not be called from an interrupt service routine.
N * See xQueueOverwriteFromISR () for an alternative which may be used in an ISR.
N *
N * @param xQueue The handle of the queue to which the data is being sent.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @return xQueueOverwrite() is a macro that calls xQueueGenericSend(), and
N * therefore has the same return values as xQueueSendToFront().  However, pdPASS
N * is the only value that can be returned because xQueueOverwrite() will write
N * to the queue even when the queue is already full.
N *
N * Example usage:
N   <pre>
N
N void vFunction( void *pvParameters )
N {
N QueueHandle_t xQueue;
N uint32_t ulVarToSend, ulValReceived;
N
N	// Create a queue to hold one uint32_t value.  It is strongly
N	// recommended *not* to use xQueueOverwrite() on queues that can
N	// contain more than one value, and doing so will trigger an assertion
N	// if configASSERT() is defined.
N	xQueue = xQueueCreate( 1, sizeof( uint32_t ) );
N
N	// Write the value 10 to the queue using xQueueOverwrite().
N	ulVarToSend = 10;
N	xQueueOverwrite( xQueue, &ulVarToSend );
N
N	// Peeking the queue should now return 10, but leave the value 10 in
N	// the queue.  A block time of zero is used as it is known that the
N	// queue holds a value.
N	ulValReceived = 0;
N	xQueuePeek( xQueue, &ulValReceived, 0 );
N
N	if( ulValReceived != 10 )
N	{
N		// Error unless the item was removed by a different task.
N	}
N
N	// The queue is still full.  Use xQueueOverwrite() to overwrite the
N	// value held in the queue with 100.
N	ulVarToSend = 100;
N	xQueueOverwrite( xQueue, &ulVarToSend );
N
N	// This time read from the queue, leaving the queue empty once more.
N	// A block time of 0 is used again.
N	xQueueReceive( xQueue, &ulValReceived, 0 );
N
N	// The value read should be the last value written, even though the
N	// queue was already full when the value was written.
N	if( ulValReceived != 100 )
N	{
N		// Error!
N	}
N
N	// ...
N}
N </pre>
N * \defgroup xQueueOverwrite xQueueOverwrite
N * \ingroup QueueManagement
N */
N#define xQueueOverwrite( xQueue, pvItemToQueue ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), 0, queueOVERWRITE )
N
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueGenericSend(
N									QueueHandle_t xQueue,
N									const void * pvItemToQueue,
N									TickType_t xTicksToWait
N									BaseType_t xCopyPosition
N								);
N * </pre>
N *
N * It is preferred that the macros xQueueSend(), xQueueSendToFront() and
N * xQueueSendToBack() are used in place of calling this function directly.
N *
N * Post an item on a queue.  The item is queued by copy, not by reference.
N * This function must not be called from an interrupt service routine.
N * See xQueueSendFromISR () for an alternative which may be used in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the
N * queue is full.  The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @param xCopyPosition Can take the value queueSEND_TO_BACK to place the
N * item at the back of the queue, or queueSEND_TO_FRONT to place the item
N * at the front of the queue (for high priority messages).
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueGenericSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10, queueSEND_TO_BACK ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueGenericSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0, queueSEND_TO_BACK );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
NBaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueuePeek(
N							 QueueHandle_t xQueue,
N							 void *pvBuffer,
N							 TickType_t xTicksToWait
N						 );</pre>
N *
N * This is a macro that calls the xQueueGenericReceive() function.
N *
N * Receive an item from a queue without removing the item from the queue.
N * The item is received by copy so a buffer of adequate size must be
N * provided.  The number of bytes copied into the buffer was defined when
N * the queue was created.
N *
N * Successfully received items remain on the queue so will be returned again
N * by the next call, or a call to xQueueReceive().
N *
N * This macro must not be used in an interrupt service routine.  See
N * xQueuePeekFromISR() for an alternative that can be called from an interrupt
N * service routine.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for an item to receive should the queue be empty at the time
N * of the call.	 The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N * xQueuePeek() will return immediately if xTicksToWait is 0 and the queue
N * is empty.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N QueueHandle_t xQueue;
N
N // Task to create a queue and post a value.
N void vATask( void *pvParameters )
N {
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Send a pointer to a struct AMessage object.  Don't block if the
N	// queue is already full.
N	pxMessage = & xMessage;
N	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
N
N	// ... Rest of task code.
N }
N
N // Task to peek the data from the queue.
N void vADifferentTask( void *pvParameters )
N {
N struct AMessage *pxRxedMessage;
N
N	if( xQueue != 0 )
N	{
N		// Peek a message on the created queue.  Block for 10 ticks if a
N		// message is not immediately available.
N		if( xQueuePeek( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
N		{
N			// pcRxedMessage now points to the struct AMessage variable posted
N			// by vATask, but the item still remains on the queue.
N		}
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueReceive xQueueReceive
N * \ingroup QueueManagement
N */
N#define xQueuePeek( xQueue, pvBuffer, xTicksToWait ) xQueueGenericReceive( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), pdTRUE )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueuePeekFromISR(
N									QueueHandle_t xQueue,
N									void *pvBuffer,
N								);</pre>
N *
N * A version of xQueuePeek() that can be called from an interrupt service
N * routine (ISR).
N *
N * Receive an item from a queue without removing the item from the queue.
N * The item is received by copy so a buffer of adequate size must be
N * provided.  The number of bytes copied into the buffer was defined when
N * the queue was created.
N *
N * Successfully received items remain on the queue so will be returned again
N * by the next call, or a call to xQueueReceive().
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * \defgroup xQueuePeekFromISR xQueuePeekFromISR
N * \ingroup QueueManagement
N */
NBaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void * const pvBuffer ) PRIVILEGED_FUNCTION;
XBaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void * const pvBuffer ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueReceive(
N								 QueueHandle_t xQueue,
N								 void *pvBuffer,
N								 TickType_t xTicksToWait
N							);</pre>
N *
N * This is a macro that calls the xQueueGenericReceive() function.
N *
N * Receive an item from a queue.  The item is received by copy so a buffer of
N * adequate size must be provided.  The number of bytes copied into the buffer
N * was defined when the queue was created.
N *
N * Successfully received items are removed from the queue.
N *
N * This function must not be used in an interrupt service routine.  See
N * xQueueReceiveFromISR for an alternative that can.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for an item to receive should the queue be empty at the time
N * of the call.	 xQueueReceive() will return immediately if xTicksToWait
N * is zero and the queue is empty.  The time is defined in tick periods so the
N * constant portTICK_PERIOD_MS should be used to convert to real time if this is
N * required.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N QueueHandle_t xQueue;
N
N // Task to create a queue and post a value.
N void vATask( void *pvParameters )
N {
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Send a pointer to a struct AMessage object.  Don't block if the
N	// queue is already full.
N	pxMessage = & xMessage;
N	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
N
N	// ... Rest of task code.
N }
N
N // Task to receive from the queue.
N void vADifferentTask( void *pvParameters )
N {
N struct AMessage *pxRxedMessage;
N
N	if( xQueue != 0 )
N	{
N		// Receive a message on the created queue.  Block for 10 ticks if a
N		// message is not immediately available.
N		if( xQueueReceive( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
N		{
N			// pcRxedMessage now points to the struct AMessage variable posted
N			// by vATask.
N		}
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueReceive xQueueReceive
N * \ingroup QueueManagement
N */
N#define xQueueReceive( xQueue, pvBuffer, xTicksToWait ) xQueueGenericReceive( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), pdFALSE )
N
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueGenericReceive(
N									   QueueHandle_t	xQueue,
N									   void	*pvBuffer,
N									   TickType_t	xTicksToWait
N									   BaseType_t	xJustPeek
N									);</pre>
N *
N * It is preferred that the macro xQueueReceive() be used rather than calling
N * this function directly.
N *
N * Receive an item from a queue.  The item is received by copy so a buffer of
N * adequate size must be provided.  The number of bytes copied into the buffer
N * was defined when the queue was created.
N *
N * This function must not be used in an interrupt service routine.  See
N * xQueueReceiveFromISR for an alternative that can.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for an item to receive should the queue be empty at the time
N * of the call.	 The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N * xQueueGenericReceive() will return immediately if the queue is empty and
N * xTicksToWait is 0.
N *
N * @param xJustPeek When set to true, the item received from the queue is not
N * actually removed from the queue - meaning a subsequent call to
N * xQueueReceive() will return the same item.  When set to false, the item
N * being received from the queue is also removed from the queue.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N QueueHandle_t xQueue;
N
N // Task to create a queue and post a value.
N void vATask( void *pvParameters )
N {
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Send a pointer to a struct AMessage object.  Don't block if the
N	// queue is already full.
N	pxMessage = & xMessage;
N	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
N
N	// ... Rest of task code.
N }
N
N // Task to receive from the queue.
N void vADifferentTask( void *pvParameters )
N {
N struct AMessage *pxRxedMessage;
N
N	if( xQueue != 0 )
N	{
N		// Receive a message on the created queue.  Block for 10 ticks if a
N		// message is not immediately available.
N		if( xQueueGenericReceive( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
N		{
N			// pcRxedMessage now points to the struct AMessage variable posted
N			// by vATask.
N		}
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueReceive xQueueReceive
N * \ingroup QueueManagement
N */
NBaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeek ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeek ) ;
N
N/**
N * queue. h
N * <pre>UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue );</pre>
N *
N * Return the number of messages stored in a queue.
N *
N * @param xQueue A handle to the queue being queried.
N *
N * @return The number of messages available in the queue.
N *
N * \defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting
N * \ingroup QueueManagement
N */
NUBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue ) ;
N
N/**
N * queue. h
N * <pre>UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue );</pre>
N *
N * Return the number of free spaces available in a queue.  This is equal to the
N * number of items that can be sent to the queue before the queue becomes full
N * if no items are removed.
N *
N * @param xQueue A handle to the queue being queried.
N *
N * @return The number of spaces available in the queue.
N *
N * \defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting
N * \ingroup QueueManagement
N */
NUBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue ) ;
N
N/**
N * queue. h
N * <pre>void vQueueDelete( QueueHandle_t xQueue );</pre>
N *
N * Delete a queue - freeing all the memory allocated for storing of items
N * placed on the queue.
N *
N * @param xQueue A handle to the queue to be deleted.
N *
N * \defgroup vQueueDelete vQueueDelete
N * \ingroup QueueManagement
N */
Nvoid vQueueDelete( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
Xvoid vQueueDelete( QueueHandle_t xQueue ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToFrontFromISR(
N										 QueueHandle_t xQueue,
N										 const void *pvItemToQueue,
N										 BaseType_t *pxHigherPriorityTaskWoken
N									  );
N </pre>
N *
N * This is a macro that calls xQueueGenericSendFromISR().
N *
N * Post an item to the front of a queue.  It is safe to use this macro from
N * within an interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueSendToFrontFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueSendToFromFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPrioritTaskWoken;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWoken = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post the byte.
N		xQueueSendToFrontFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.
N	if( xHigherPriorityTaskWoken )
N	{
N		taskYIELD ();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
N#define xQueueSendToFrontFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_FRONT )
N
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToBackFromISR(
N										 QueueHandle_t xQueue,
N										 const void *pvItemToQueue,
N										 BaseType_t *pxHigherPriorityTaskWoken
N									  );
N </pre>
N *
N * This is a macro that calls xQueueGenericSendFromISR().
N *
N * Post an item to the back of a queue.  It is safe to use this macro from
N * within an interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueSendToBackFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueSendToBackFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPriorityTaskWoken;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWoken = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post the byte.
N		xQueueSendToBackFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.
N	if( xHigherPriorityTaskWoken )
N	{
N		taskYIELD ();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
N#define xQueueSendToBackFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueOverwriteFromISR(
N							  QueueHandle_t xQueue,
N							  const void * pvItemToQueue,
N							  BaseType_t *pxHigherPriorityTaskWoken
N						 );
N * </pre>
N *
N * A version of xQueueOverwrite() that can be used in an interrupt service
N * routine (ISR).
N *
N * Only for use with queues that can hold a single item - so the queue is either
N * empty or full.
N *
N * Post an item on a queue.  If the queue is already full then overwrite the
N * value held in the queue.  The item is queued by copy, not by reference.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueOverwriteFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueOverwriteFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return xQueueOverwriteFromISR() is a macro that calls
N * xQueueGenericSendFromISR(), and therefore has the same return values as
N * xQueueSendToFrontFromISR().  However, pdPASS is the only value that can be
N * returned because xQueueOverwriteFromISR() will write to the queue even when
N * the queue is already full.
N *
N * Example usage:
N   <pre>
N
N QueueHandle_t xQueue;
N
N void vFunction( void *pvParameters )
N {
N 	// Create a queue to hold one uint32_t value.  It is strongly
N	// recommended *not* to use xQueueOverwriteFromISR() on queues that can
N	// contain more than one value, and doing so will trigger an assertion
N	// if configASSERT() is defined.
N	xQueue = xQueueCreate( 1, sizeof( uint32_t ) );
N}
N
Nvoid vAnInterruptHandler( void )
N{
N// xHigherPriorityTaskWoken must be set to pdFALSE before it is used.
NBaseType_t xHigherPriorityTaskWoken = pdFALSE;
Nuint32_t ulVarToSend, ulValReceived;
N
N	// Write the value 10 to the queue using xQueueOverwriteFromISR().
N	ulVarToSend = 10;
N	xQueueOverwriteFromISR( xQueue, &ulVarToSend, &xHigherPriorityTaskWoken );
N
N	// The queue is full, but calling xQueueOverwriteFromISR() again will still
N	// pass because the value held in the queue will be overwritten with the
N	// new value.
N	ulVarToSend = 100;
N	xQueueOverwriteFromISR( xQueue, &ulVarToSend, &xHigherPriorityTaskWoken );
N
N	// Reading from the queue will now return 100.
N
N	// ...
N
N	if( xHigherPrioritytaskWoken == pdTRUE )
N	{
N		// Writing to the queue caused a task to unblock and the unblocked task
N		// has a priority higher than or equal to the priority of the currently
N		// executing task (the task this interrupt interrupted).  Perform a context
N		// switch so this interrupt returns directly to the unblocked task.
N		portYIELD_FROM_ISR(); // or portEND_SWITCHING_ISR() depending on the port.
N	}
N}
N </pre>
N * \defgroup xQueueOverwriteFromISR xQueueOverwriteFromISR
N * \ingroup QueueManagement
N */
N#define xQueueOverwriteFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueOVERWRITE )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendFromISR(
N									 QueueHandle_t xQueue,
N									 const void *pvItemToQueue,
N									 BaseType_t *pxHigherPriorityTaskWoken
N								);
N </pre>
N *
N * This is a macro that calls xQueueGenericSendFromISR().  It is included
N * for backward compatibility with versions of FreeRTOS.org that did not
N * include the xQueueSendToBackFromISR() and xQueueSendToFrontFromISR()
N * macros.
N *
N * Post an item to the back of a queue.  It is safe to use this function from
N * within an interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueSendFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueSendFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPriorityTaskWoken;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWoken = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post the byte.
N		xQueueSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.
N	if( xHigherPriorityTaskWoken )
N	{
N		// Actual macro used here is port specific.
N		portYIELD_FROM_ISR ();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
N#define xQueueSendFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueGenericSendFromISR(
N										   QueueHandle_t		xQueue,
N										   const	void	*pvItemToQueue,
N										   BaseType_t	*pxHigherPriorityTaskWoken,
N										   BaseType_t	xCopyPosition
N									   );
N </pre>
N *
N * It is preferred that the macros xQueueSendFromISR(),
N * xQueueSendToFrontFromISR() and xQueueSendToBackFromISR() be used in place
N * of calling this function directly.  xQueueGiveFromISR() is an
N * equivalent for use by semaphores that don't actually copy any data.
N *
N * Post an item on a queue.  It is safe to use this function from within an
N * interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueGenericSendFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueGenericSendFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @param xCopyPosition Can take the value queueSEND_TO_BACK to place the
N * item at the back of the queue, or queueSEND_TO_FRONT to place the item
N * at the front of the queue (for high priority messages).
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPriorityTaskWokenByPost;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWokenByPost = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post each byte.
N		xQueueGenericSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWokenByPost, queueSEND_TO_BACK );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.  Note that the
N	// name of the yield function required is port specific.
N	if( xHigherPriorityTaskWokenByPost )
N	{
N		taskYIELD_YIELD_FROM_ISR();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
NBaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition ) ;
NBaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueReceiveFromISR(
N									   QueueHandle_t	xQueue,
N									   void	*pvBuffer,
N									   BaseType_t *pxTaskWoken
N								   );
N * </pre>
N *
N * Receive an item from a queue.  It is safe to use this function from within an
N * interrupt service routine.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param pxTaskWoken A task may be blocked waiting for space to become
N * available on the queue.  If xQueueReceiveFromISR causes such a task to
N * unblock *pxTaskWoken will get set to pdTRUE, otherwise *pxTaskWoken will
N * remain unchanged.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N
N QueueHandle_t xQueue;
N
N // Function to create a queue and post some values.
N void vAFunction( void *pvParameters )
N {
N char cValueToPost;
N const TickType_t xTicksToWait = ( TickType_t )0xff;
N
N	// Create a queue capable of containing 10 characters.
N	xQueue = xQueueCreate( 10, sizeof( char ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Post some characters that will be used within an ISR.  If the queue
N	// is full then this task will block for xTicksToWait ticks.
N	cValueToPost = 'a';
N	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
N	cValueToPost = 'b';
N	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
N
N	// ... keep posting characters ... this task may block when the queue
N	// becomes full.
N
N	cValueToPost = 'c';
N	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
N }
N
N // ISR that outputs all the characters received on the queue.
N void vISR_Routine( void )
N {
N BaseType_t xTaskWokenByReceive = pdFALSE;
N char cRxedChar;
N
N	while( xQueueReceiveFromISR( xQueue, ( void * ) &cRxedChar, &xTaskWokenByReceive) )
N	{
N		// A character was received.  Output the character now.
N		vOutputCharacter( cRxedChar );
N
N		// If removing the character from the queue woke the task that was
N		// posting onto the queue cTaskWokenByReceive will have been set to
N		// pdTRUE.  No matter how many times this loop iterates only one
N		// task will be woken.
N	}
N
N	if( cTaskWokenByPost != ( char ) pdFALSE;
N	{
N		taskYIELD ();
N	}
N }
N </pre>
N * \defgroup xQueueReceiveFromISR xQueueReceiveFromISR
N * \ingroup QueueManagement
N */
NBaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken ) ;
N
N/*
N * Utilities to query queues that are safe to use from an ISR.  These utilities
N * should be used only from witin an ISR, or within a critical section.
N */
NBaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue ) ;
NBaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue ) ;
NUBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue ) ;
N
N
N/*
N * xQueueAltGenericSend() is an alternative version of xQueueGenericSend().
N * Likewise xQueueAltGenericReceive() is an alternative version of
N * xQueueGenericReceive().
N *
N * The source code that implements the alternative (Alt) API is much
N * simpler	because it executes everything from within a critical section.
N * This is	the approach taken by many other RTOSes, but FreeRTOS.org has the
N * preferred fully featured API too.  The fully featured API has more
N * complex	code that takes longer to execute, but makes much less use of
N * critical sections.  Therefore the alternative API sacrifices interrupt
N * responsiveness to gain execution speed, whereas the fully featured API
N * sacrifices execution speed to ensure better interrupt responsiveness.
N */
NBaseType_t xQueueAltGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueAltGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, BaseType_t xCopyPosition ) ;
NBaseType_t xQueueAltGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, BaseType_t xJustPeeking ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueAltGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, BaseType_t xJustPeeking ) ;
N#define xQueueAltSendToFront( xQueue, pvItemToQueue, xTicksToWait ) xQueueAltGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_FRONT )
N#define xQueueAltSendToBack( xQueue, pvItemToQueue, xTicksToWait ) xQueueAltGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )
N#define xQueueAltReceive( xQueue, pvBuffer, xTicksToWait ) xQueueAltGenericReceive( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), pdFALSE )
N#define xQueueAltPeek( xQueue, pvBuffer, xTicksToWait ) xQueueAltGenericReceive( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), pdTRUE )
N
N/*
N * The functions defined above are for passing data to and from tasks.  The
N * functions below are the equivalents for passing data to and from
N * co-routines.
N *
N * These functions are called from the co-routine macro implementation and
N * should not be called directly from application code.  Instead use the macro
N * wrappers defined within croutine.h.
N */
NBaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken );
NBaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxTaskWoken );
NBaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait );
NBaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait );
N
N/*
N * For internal use only.  Use xSemaphoreCreateMutex(),
N * xSemaphoreCreateCounting() or xSemaphoreGetMutexHolder() instead of calling
N * these functions directly.
N */
NQueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType ) ;
NQueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount ) ;
Nvoid* xQueueGetMutexHolder( QueueHandle_t xSemaphore ) PRIVILEGED_FUNCTION;
Xvoid* xQueueGetMutexHolder( QueueHandle_t xSemaphore ) ;
N
N/*
N * For internal use only.  Use xSemaphoreTakeMutexRecursive() or
N * xSemaphoreGiveMutexRecursive() instead of calling these functions directly.
N */
NBaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait ) ;
NBaseType_t xQueueGiveMutexRecursive( QueueHandle_t pxMutex ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGiveMutexRecursive( QueueHandle_t pxMutex ) ;
N
N/*
N * Reset a queue back to its original empty state.  The return value is now
N * obsolete and is always set to pdPASS.
N */
N#define xQueueReset( xQueue ) xQueueGenericReset( xQueue, pdFALSE )
N
N/*
N * The registry is provided as a means for kernel aware debuggers to
N * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add
N * a queue, semaphore or mutex handle to the registry if you want the handle
N * to be available to a kernel aware debugger.  If you are not using a kernel
N * aware debugger then this function can be ignored.
N *
N * configQUEUE_REGISTRY_SIZE defines the maximum number of handles the
N * registry can hold.  configQUEUE_REGISTRY_SIZE must be greater than 0
N * within FreeRTOSConfig.h for the registry to be available.  Its value
N * does not effect the number of queues, semaphores and mutexes that can be
N * created - just the number that the registry can hold.
N *
N * @param xQueue The handle of the queue being added to the registry.  This
N * is the handle returned by a call to xQueueCreate().  Semaphore and mutex
N * handles can also be passed in here.
N *
N * @param pcName The name to be associated with the handle.  This is the
N * name that the kernel aware debugger will display.  The queue registry only
N * stores a pointer to the string - so the string must be persistent (global or
N * preferably in ROM/Flash), not on the stack.
N */
N#if configQUEUE_REGISTRY_SIZE > 0
X#if 0U > 0
S	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcName ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N#endif
N
N/*
N * The registry is provided as a means for kernel aware debuggers to
N * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add
N * a queue, semaphore or mutex handle to the registry if you want the handle
N * to be available to a kernel aware debugger, and vQueueUnregisterQueue() to
N * remove the queue, semaphore or mutex from the register.  If you are not using
N * a kernel aware debugger then this function can be ignored.
N *
N * @param xQueue The handle of the queue being removed from the registry.
N */
N#if configQUEUE_REGISTRY_SIZE > 0
X#if 0U > 0
S	void vQueueUnregisterQueue( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
N#endif
N
N/*
N * Generic version of the queue creation function, which is in turn called by
N * any queue, semaphore or mutex creation function or macro.
N */
NQueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType ) ;
N
N/*
N * Queue sets provide a mechanism to allow a task to block (pend) on a read
N * operation from multiple queues or semaphores simultaneously.
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * A queue set must be explicitly created using a call to xQueueCreateSet()
N * before it can be used.  Once created, standard FreeRTOS queues and semaphores
N * can be added to the set using calls to xQueueAddToSet().
N * xQueueSelectFromSet() is then used to determine which, if any, of the queues
N * or semaphores contained in the set is in a state where a queue read or
N * semaphore take operation would be successful.
N *
N * Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html
N * for reasons why queue sets are very rarely needed in practice as there are
N * simpler methods of blocking on multiple objects.
N *
N * Note 2:  Blocking on a queue set that contains a mutex will not cause the
N * mutex holder to inherit the priority of the blocked task.
N *
N * Note 3:  An additional 4 bytes of RAM is required for each space in a every
N * queue added to a queue set.  Therefore counting semaphores that have a high
N * maximum count value should not be added to a queue set.
N *
N * Note 4:  A receive (in the case of a queue) or take (in the case of a
N * semaphore) operation must not be performed on a member of a queue set unless
N * a call to xQueueSelectFromSet() has first returned a handle to that set member.
N *
N * @param uxEventQueueLength Queue sets store events that occur on
N * the queues and semaphores contained in the set.  uxEventQueueLength specifies
N * the maximum number of events that can be queued at once.  To be absolutely
N * certain that events are not lost uxEventQueueLength should be set to the
N * total sum of the length of the queues added to the set, where binary
N * semaphores and mutexes have a length of 1, and counting semaphores have a
N * length set by their maximum count value.  Examples:
N *  + If a queue set is to hold a queue of length 5, another queue of length 12,
N *    and a binary semaphore, then uxEventQueueLength should be set to
N *    (5 + 12 + 1), or 18.
N *  + If a queue set is to hold three binary semaphores then uxEventQueueLength
N *    should be set to (1 + 1 + 1 ), or 3.
N *  + If a queue set is to hold a counting semaphore that has a maximum count of
N *    5, and a counting semaphore that has a maximum count of 3, then
N *    uxEventQueueLength should be set to (5 + 3), or 8.
N *
N * @return If the queue set is created successfully then a handle to the created
N * queue set is returned.  Otherwise NULL is returned.
N */
NQueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength ) PRIVILEGED_FUNCTION;
XQueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength ) ;
N
N/*
N * Adds a queue or semaphore to a queue set that was previously created by a
N * call to xQueueCreateSet().
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * Note 1:  A receive (in the case of a queue) or take (in the case of a
N * semaphore) operation must not be performed on a member of a queue set unless
N * a call to xQueueSelectFromSet() has first returned a handle to that set member.
N *
N * @param xQueueOrSemaphore The handle of the queue or semaphore being added to
N * the queue set (cast to an QueueSetMemberHandle_t type).
N *
N * @param xQueueSet The handle of the queue set to which the queue or semaphore
N * is being added.
N *
N * @return If the queue or semaphore was successfully added to the queue set
N * then pdPASS is returned.  If the queue could not be successfully added to the
N * queue set because it is already a member of a different queue set then pdFAIL
N * is returned.
N */
NBaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) ;
N
N/*
N * Removes a queue or semaphore from a queue set.  A queue or semaphore can only
N * be removed from a set if the queue or semaphore is empty.
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * @param xQueueOrSemaphore The handle of the queue or semaphore being removed
N * from the queue set (cast to an QueueSetMemberHandle_t type).
N *
N * @param xQueueSet The handle of the queue set in which the queue or semaphore
N * is included.
N *
N * @return If the queue or semaphore was successfully removed from the queue set
N * then pdPASS is returned.  If the queue was not in the queue set, or the
N * queue (or semaphore) was not empty, then pdFAIL is returned.
N */
NBaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) ;
N
N/*
N * xQueueSelectFromSet() selects from the members of a queue set a queue or
N * semaphore that either contains data (in the case of a queue) or is available
N * to take (in the case of a semaphore).  xQueueSelectFromSet() effectively
N * allows a task to block (pend) on a read operation on all the queues and
N * semaphores in a queue set simultaneously.
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html
N * for reasons why queue sets are very rarely needed in practice as there are
N * simpler methods of blocking on multiple objects.
N *
N * Note 2:  Blocking on a queue set that contains a mutex will not cause the
N * mutex holder to inherit the priority of the blocked task.
N *
N * Note 3:  A receive (in the case of a queue) or take (in the case of a
N * semaphore) operation must not be performed on a member of a queue set unless
N * a call to xQueueSelectFromSet() has first returned a handle to that set member.
N *
N * @param xQueueSet The queue set on which the task will (potentially) block.
N *
N * @param xTicksToWait The maximum time, in ticks, that the calling task will
N * remain in the Blocked state (with other tasks executing) to wait for a member
N * of the queue set to be ready for a successful queue read or semaphore take
N * operation.
N *
N * @return xQueueSelectFromSet() will return the handle of a queue (cast to
N * a QueueSetMemberHandle_t type) contained in the queue set that contains data,
N * or the handle of a semaphore (cast to a QueueSetMemberHandle_t type) contained
N * in the queue set that is available, or NULL if no such queue or semaphore
N * exists before before the specified block time expires.
N */
NQueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XQueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait ) ;
N
N/*
N * A version of xQueueSelectFromSet() that can be used from an ISR.
N */
NQueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
XQueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet ) ;
N
N/* Not public API functions. */
Nvoid vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) PRIVILEGED_FUNCTION;
Xvoid vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) ;
NBaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue ) ;
Nvoid vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber ) PRIVILEGED_FUNCTION;
Xvoid vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber ) ;
NUBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue ) ;
Nuint8_t ucQueueGetQueueType( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
Xuint8_t ucQueueGetQueueType( QueueHandle_t xQueue ) ;
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* QUEUE_H */
N
L 110 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N#include "misc.h"
N#include "event_groups.h"
L 1 "..\..\FreeRTOS\Source\include\event_groups.h" 1
N/*
N    FreeRTOS V8.2.2 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef EVENT_GROUPS_H
N#define EVENT_GROUPS_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h" must appear in source files before "include event_groups.h"
N#endif
N
N#include "timers.h"
L 1 "..\..\FreeRTOS\Source\include\timers.h" 1
N/*
N    FreeRTOS V8.2.2 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef TIMERS_H
N#define TIMERS_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h must appear in source files before include timers.h"
N#endif
N
N/*lint -e537 This headers are only multiply included if the application code
Nhappens to also be including task.h. */
N#include "task.h"
N/*lint +e537 */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*-----------------------------------------------------------
N * MACROS AND DEFINITIONS
N *----------------------------------------------------------*/
N
N/* IDs for commands that can be sent/received on the timer queue.  These are to
Nbe used solely through the macros that make up the public software timer API,
Nas defined below.  The commands that are sent from interrupts must use the
Nhighest numbers as tmrFIRST_FROM_ISR_COMMAND is used to determine if the task
Nor interrupt version of the queue send function should be used. */
N#define tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR 	( ( BaseType_t ) -2 )
N#define tmrCOMMAND_EXECUTE_CALLBACK				( ( BaseType_t ) -1 )
N#define tmrCOMMAND_START_DONT_TRACE				( ( BaseType_t ) 0 )
N#define tmrCOMMAND_START					    ( ( BaseType_t ) 1 )
N#define tmrCOMMAND_RESET						( ( BaseType_t ) 2 )
N#define tmrCOMMAND_STOP							( ( BaseType_t ) 3 )
N#define tmrCOMMAND_CHANGE_PERIOD				( ( BaseType_t ) 4 )
N#define tmrCOMMAND_DELETE						( ( BaseType_t ) 5 )
N
N#define tmrFIRST_FROM_ISR_COMMAND				( ( BaseType_t ) 6 )
N#define tmrCOMMAND_START_FROM_ISR				( ( BaseType_t ) 6 )
N#define tmrCOMMAND_RESET_FROM_ISR				( ( BaseType_t ) 7 )
N#define tmrCOMMAND_STOP_FROM_ISR				( ( BaseType_t ) 8 )
N#define tmrCOMMAND_CHANGE_PERIOD_FROM_ISR		( ( BaseType_t ) 9 )
N
N
N/**
N * Type by which software timers are referenced.  For example, a call to
N * xTimerCreate() returns an TimerHandle_t variable that can then be used to
N * reference the subject timer in calls to other software timer API functions
N * (for example, xTimerStart(), xTimerReset(), etc.).
N */
Ntypedef void * TimerHandle_t;
N
N/*
N * Defines the prototype to which timer callback functions must conform.
N */
Ntypedef void (*TimerCallbackFunction_t)( TimerHandle_t xTimer );
N
N/*
N * Defines the prototype to which functions used with the
N * xTimerPendFunctionCallFromISR() function must conform.
N */
Ntypedef void (*PendedFunction_t)( void *, uint32_t );
N
N/**
N * TimerHandle_t xTimerCreate( 	const char * const pcTimerName,
N * 								TickType_t xTimerPeriodInTicks,
N * 								UBaseType_t uxAutoReload,
N * 								void * pvTimerID,
N * 								TimerCallbackFunction_t pxCallbackFunction );
N *
N * Creates a new software timer instance.  This allocates the storage required
N * by the new timer, initialises the new timers internal state, and returns a
N * handle by which the new timer can be referenced.
N *
N * Timers are created in the dormant state.  The xTimerStart(), xTimerReset(),
N * xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and
N * xTimerChangePeriodFromISR() API functions can all be used to transition a
N * timer into the active state.
N *
N * @param pcTimerName A text name that is assigned to the timer.  This is done
N * purely to assist debugging.  The kernel itself only ever references a timer
N * by its handle, and never by its name.
N *
N * @param xTimerPeriodInTicks The timer period.  The time is defined in tick
N * periods so the constant portTICK_PERIOD_MS can be used to convert a time that
N * has been specified in milliseconds.  For example, if the timer must expire
N * after 100 ticks, then xTimerPeriodInTicks should be set to 100.
N * Alternatively, if the timer must expire after 500ms, then xPeriod can be set
N * to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or
N * equal to 1000.
N *
N * @param uxAutoReload If uxAutoReload is set to pdTRUE then the timer will
N * expire repeatedly with a frequency set by the xTimerPeriodInTicks parameter.
N * If uxAutoReload is set to pdFALSE then the timer will be a one-shot timer and
N * enter the dormant state after it expires.
N *
N * @param pvTimerID An identifier that is assigned to the timer being created.
N * Typically this would be used in the timer callback function to identify which
N * timer expired when the same callback function is assigned to more than one
N * timer.
N *
N * @param pxCallbackFunction The function to call when the timer expires.
N * Callback functions must have the prototype defined by TimerCallbackFunction_t,
N * which is	"void vCallbackFunction( TimerHandle_t xTimer );".
N *
N * @return If the timer is successfully created then a handle to the newly
N * created timer is returned.  If the timer cannot be created (because either
N * there is insufficient FreeRTOS heap remaining to allocate the timer
N * structures, or the timer period was set to 0) then NULL is returned.
N *
N * Example usage:
N * @verbatim
N * #define NUM_TIMERS 5
N *
N * // An array to hold handles to the created timers.
N * TimerHandle_t xTimers[ NUM_TIMERS ];
N *
N * // An array to hold a count of the number of times each timer expires.
N * int32_t lExpireCounters[ NUM_TIMERS ] = { 0 };
N *
N * // Define a callback function that will be used by multiple timer instances.
N * // The callback function does nothing but count the number of times the
N * // associated timer expires, and stop the timer once the timer has expired
N * // 10 times.
N * void vTimerCallback( TimerHandle_t pxTimer )
N * {
N * int32_t lArrayIndex;
N * const int32_t xMaxExpiryCountBeforeStopping = 10;
N *
N * 	   // Optionally do something if the pxTimer parameter is NULL.
N * 	   configASSERT( pxTimer );
N *
N *     // Which timer expired?
N *     lArrayIndex = ( int32_t ) pvTimerGetTimerID( pxTimer );
N *
N *     // Increment the number of times that pxTimer has expired.
N *     lExpireCounters[ lArrayIndex ] += 1;
N *
N *     // If the timer has expired 10 times then stop it from running.
N *     if( lExpireCounters[ lArrayIndex ] == xMaxExpiryCountBeforeStopping )
N *     {
N *         // Do not use a block time if calling a timer API function from a
N *         // timer callback function, as doing so could cause a deadlock!
N *         xTimerStop( pxTimer, 0 );
N *     }
N * }
N *
N * void main( void )
N * {
N * int32_t x;
N *
N *     // Create then start some timers.  Starting the timers before the scheduler
N *     // has been started means the timers will start running immediately that
N *     // the scheduler starts.
N *     for( x = 0; x < NUM_TIMERS; x++ )
N *     {
N *         xTimers[ x ] = xTimerCreate(    "Timer",       // Just a text name, not used by the kernel.
N *                                         ( 100 * x ),   // The timer period in ticks.
N *                                         pdTRUE,        // The timers will auto-reload themselves when they expire.
N *                                         ( void * ) x,  // Assign each timer a unique id equal to its array index.
N *                                         vTimerCallback // Each timer calls the same callback when it expires.
N *                                     );
N *
N *         if( xTimers[ x ] == NULL )
N *         {
N *             // The timer was not created.
N *         }
N *         else
N *         {
N *             // Start the timer.  No block time is specified, and even if one was
N *             // it would be ignored because the scheduler has not yet been
N *             // started.
N *             if( xTimerStart( xTimers[ x ], 0 ) != pdPASS )
N *             {
N *                 // The timer could not be set into the Active state.
N *             }
N *         }
N *     }
N *
N *     // ...
N *     // Create tasks here.
N *     // ...
N *
N *     // Starting the scheduler will start the timers running as they have already
N *     // been set into the active state.
N *     xTaskStartScheduler();
N *
N *     // Should not reach here.
N *     for( ;; );
N * }
N * @endverbatim
N */
NTimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
XTimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) ;  
N
N/**
N * void *pvTimerGetTimerID( TimerHandle_t xTimer );
N *
N * Returns the ID assigned to the timer.
N *
N * IDs are assigned to timers using the pvTimerID parameter of the call to
N * xTimerCreated() that was used to create the timer, and by calling the
N * vTimerSetTimerID() API function.
N *
N * If the same callback function is assigned to multiple timers then the timer
N * ID can be used as time specific (timer local) storage.
N *
N * @param xTimer The timer being queried.
N *
N * @return The ID assigned to the timer being queried.
N *
N * Example usage:
N *
N * See the xTimerCreate() API function example usage scenario.
N */
Nvoid *pvTimerGetTimerID( const TimerHandle_t xTimer ) PRIVILEGED_FUNCTION;
Xvoid *pvTimerGetTimerID( const TimerHandle_t xTimer ) ;
N
N/**
N * void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID );
N *
N * Sets the ID assigned to the timer.
N *
N * IDs are assigned to timers using the pvTimerID parameter of the call to
N * xTimerCreated() that was used to create the timer.
N *
N * If the same callback function is assigned to multiple timers then the timer
N * ID can be used as time specific (timer local) storage.
N *
N * @param xTimer The timer being updated.
N *
N * @param pvNewID The ID to assign to the timer.
N *
N * Example usage:
N *
N * See the xTimerCreate() API function example usage scenario.
N */
Nvoid vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID ) PRIVILEGED_FUNCTION;
Xvoid vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID ) ;
N
N/**
N * BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer );
N *
N * Queries a timer to see if it is active or dormant.
N *
N * A timer will be dormant if:
N *     1) It has been created but not started, or
N *     2) It is an expired one-shot timer that has not been restarted.
N *
N * Timers are created in the dormant state.  The xTimerStart(), xTimerReset(),
N * xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and
N * xTimerChangePeriodFromISR() API functions can all be used to transition a timer into the
N * active state.
N *
N * @param xTimer The timer being queried.
N *
N * @return pdFALSE will be returned if the timer is dormant.  A value other than
N * pdFALSE will be returned if the timer is active.
N *
N * Example usage:
N * @verbatim
N * // This function assumes xTimer has already been created.
N * void vAFunction( TimerHandle_t xTimer )
N * {
N *     if( xTimerIsTimerActive( xTimer ) != pdFALSE ) // or more simply and equivalently "if( xTimerIsTimerActive( xTimer ) )"
N *     {
N *         // xTimer is active, do something.
N *     }
N *     else
N *     {
N *         // xTimer is not active, do something else.
N *     }
N * }
N * @endverbatim
N */
NBaseType_t xTimerIsTimerActive( TimerHandle_t xTimer ) PRIVILEGED_FUNCTION;
XBaseType_t xTimerIsTimerActive( TimerHandle_t xTimer ) ;
N
N/**
N * TaskHandle_t xTimerGetTimerDaemonTaskHandle( void );
N *
N * xTimerGetTimerDaemonTaskHandle() is only available if
N * INCLUDE_xTimerGetTimerDaemonTaskHandle is set to 1 in FreeRTOSConfig.h.
N *
N * Simply returns the handle of the timer service/daemon task.  It it not valid
N * to call xTimerGetTimerDaemonTaskHandle() before the scheduler has been started.
N */
NTaskHandle_t xTimerGetTimerDaemonTaskHandle( void ) PRIVILEGED_FUNCTION;
XTaskHandle_t xTimerGetTimerDaemonTaskHandle( void ) ;
N
N/**
N * BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xTicksToWait );
N *
N * Timer functionality is provided by a timer service/daemon task.  Many of the
N * public FreeRTOS timer API functions send commands to the timer service task
N * through a queue called the timer command queue.  The timer command queue is
N * private to the kernel itself and is not directly accessible to application
N * code.  The length of the timer command queue is set by the
N * configTIMER_QUEUE_LENGTH configuration constant.
N *
N * xTimerStart() starts a timer that was previously created using the
N * xTimerCreate() API function.  If the timer had already been started and was
N * already in the active state, then xTimerStart() has equivalent functionality
N * to the xTimerReset() API function.
N *
N * Starting a timer ensures the timer is in the active state.  If the timer
N * is not stopped, deleted, or reset in the mean time, the callback function
N * associated with the timer will get called 'n' ticks after xTimerStart() was
N * called, where 'n' is the timers defined period.
N *
N * It is valid to call xTimerStart() before the scheduler has been started, but
N * when this is done the timer will not actually start until the scheduler is
N * started, and the timers expiry time will be relative to when the scheduler is
N * started, not relative to when xTimerStart() was called.
N *
N * The configUSE_TIMERS configuration constant must be set to 1 for xTimerStart()
N * to be available.
N *
N * @param xTimer The handle of the timer being started/restarted.
N *
N * @param xTicksToWait Specifies the time, in ticks, that the calling task should
N * be held in the Blocked state to wait for the start command to be successfully
N * sent to the timer command queue, should the queue already be full when
N * xTimerStart() was called.  xTicksToWait is ignored if xTimerStart() is called
N * before the scheduler is started.
N *
N * @return pdFAIL will be returned if the start command could not be sent to
N * the timer command queue even after xTicksToWait ticks had passed.  pdPASS will
N * be returned if the command was successfully sent to the timer command queue.
N * When the command is actually processed will depend on the priority of the
N * timer service/daemon task relative to other tasks in the system, although the
N * timers expiry time is relative to when xTimerStart() is actually called.  The
N * timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY
N * configuration constant.
N *
N * Example usage:
N *
N * See the xTimerCreate() API function example usage scenario.
N *
N */
N#define xTimerStart( xTimer, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_START, ( xTaskGetTickCount() ), NULL, ( xTicksToWait ) )
N
N/**
N * BaseType_t xTimerStop( TimerHandle_t xTimer, TickType_t xTicksToWait );
N *
N * Timer functionality is provided by a timer service/daemon task.  Many of the
N * public FreeRTOS timer API functions send commands to the timer service task
N * through a queue called the timer command queue.  The timer command queue is
N * private to the kernel itself and is not directly accessible to application
N * code.  The length of the timer command queue is set by the
N * configTIMER_QUEUE_LENGTH configuration constant.
N *
N * xTimerStop() stops a timer that was previously started using either of the
N * The xTimerStart(), xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(),
N * xTimerChangePeriod() or xTimerChangePeriodFromISR() API functions.
N *
N * Stopping a timer ensures the timer is not in the active state.
N *
N * The configUSE_TIMERS configuration constant must be set to 1 for xTimerStop()
N * to be available.
N *
N * @param xTimer The handle of the timer being stopped.
N *
N * @param xTicksToWait Specifies the time, in ticks, that the calling task should
N * be held in the Blocked state to wait for the stop command to be successfully
N * sent to the timer command queue, should the queue already be full when
N * xTimerStop() was called.  xTicksToWait is ignored if xTimerStop() is called
N * before the scheduler is started.
N *
N * @return pdFAIL will be returned if the stop command could not be sent to
N * the timer command queue even after xTicksToWait ticks had passed.  pdPASS will
N * be returned if the command was successfully sent to the timer command queue.
N * When the command is actually processed will depend on the priority of the
N * timer service/daemon task relative to other tasks in the system.  The timer
N * service/daemon task priority is set by the configTIMER_TASK_PRIORITY
N * configuration constant.
N *
N * Example usage:
N *
N * See the xTimerCreate() API function example usage scenario.
N *
N */
N#define xTimerStop( xTimer, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_STOP, 0U, NULL, ( xTicksToWait ) )
N
N/**
N * BaseType_t xTimerChangePeriod( 	TimerHandle_t xTimer,
N *										TickType_t xNewPeriod,
N *										TickType_t xTicksToWait );
N *
N * Timer functionality is provided by a timer service/daemon task.  Many of the
N * public FreeRTOS timer API functions send commands to the timer service task
N * through a queue called the timer command queue.  The timer command queue is
N * private to the kernel itself and is not directly accessible to application
N * code.  The length of the timer command queue is set by the
N * configTIMER_QUEUE_LENGTH configuration constant.
N *
N * xTimerChangePeriod() changes the period of a timer that was previously
N * created using the xTimerCreate() API function.
N *
N * xTimerChangePeriod() can be called to change the period of an active or
N * dormant state timer.
N *
N * The configUSE_TIMERS configuration constant must be set to 1 for
N * xTimerChangePeriod() to be available.
N *
N * @param xTimer The handle of the timer that is having its period changed.
N *
N * @param xNewPeriod The new period for xTimer. Timer periods are specified in
N * tick periods, so the constant portTICK_PERIOD_MS can be used to convert a time
N * that has been specified in milliseconds.  For example, if the timer must
N * expire after 100 ticks, then xNewPeriod should be set to 100.  Alternatively,
N * if the timer must expire after 500ms, then xNewPeriod can be set to
N * ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than
N * or equal to 1000.
N *
N * @param xTicksToWait Specifies the time, in ticks, that the calling task should
N * be held in the Blocked state to wait for the change period command to be
N * successfully sent to the timer command queue, should the queue already be
N * full when xTimerChangePeriod() was called.  xTicksToWait is ignored if
N * xTimerChangePeriod() is called before the scheduler is started.
N *
N * @return pdFAIL will be returned if the change period command could not be
N * sent to the timer command queue even after xTicksToWait ticks had passed.
N * pdPASS will be returned if the command was successfully sent to the timer
N * command queue.  When the command is actually processed will depend on the
N * priority of the timer service/daemon task relative to other tasks in the
N * system.  The timer service/daemon task priority is set by the
N * configTIMER_TASK_PRIORITY configuration constant.
N *
N * Example usage:
N * @verbatim
N * // This function assumes xTimer has already been created.  If the timer
N * // referenced by xTimer is already active when it is called, then the timer
N * // is deleted.  If the timer referenced by xTimer is not active when it is
N * // called, then the period of the timer is set to 500ms and the timer is
N * // started.
N * void vAFunction( TimerHandle_t xTimer )
N * {
N *     if( xTimerIsTimerActive( xTimer ) != pdFALSE ) // or more simply and equivalently "if( xTimerIsTimerActive( xTimer ) )"
N *     {
N *         // xTimer is already active - delete it.
N *         xTimerDelete( xTimer );
N *     }
N *     else
N *     {
N *         // xTimer is not active, change its period to 500ms.  This will also
N *         // cause the timer to start.  Block for a maximum of 100 ticks if the
N *         // change period command cannot immediately be sent to the timer
N *         // command queue.
N *         if( xTimerChangePeriod( xTimer, 500 / portTICK_PERIOD_MS, 100 ) == pdPASS )
N *         {
N *             // The command was successfully sent.
N *         }
N *         else
N *         {
N *             // The command could not be sent, even after waiting for 100 ticks
N *             // to pass.  Take appropriate action here.
N *         }
N *     }
N * }
N * @endverbatim
N */
N #define xTimerChangePeriod( xTimer, xNewPeriod, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_CHANGE_PERIOD, ( xNewPeriod ), NULL, ( xTicksToWait ) )
N
N/**
N * BaseType_t xTimerDelete( TimerHandle_t xTimer, TickType_t xTicksToWait );
N *
N * Timer functionality is provided by a timer service/daemon task.  Many of the
N * public FreeRTOS timer API functions send commands to the timer service task
N * through a queue called the timer command queue.  The timer command queue is
N * private to the kernel itself and is not directly accessible to application
N * code.  The length of the timer command queue is set by the
N * configTIMER_QUEUE_LENGTH configuration constant.
N *
N * xTimerDelete() deletes a timer that was previously created using the
N * xTimerCreate() API function.
N *
N * The configUSE_TIMERS configuration constant must be set to 1 for
N * xTimerDelete() to be available.
N *
N * @param xTimer The handle of the timer being deleted.
N *
N * @param xTicksToWait Specifies the time, in ticks, that the calling task should
N * be held in the Blocked state to wait for the delete command to be
N * successfully sent to the timer command queue, should the queue already be
N * full when xTimerDelete() was called.  xTicksToWait is ignored if xTimerDelete()
N * is called before the scheduler is started.
N *
N * @return pdFAIL will be returned if the delete command could not be sent to
N * the timer command queue even after xTicksToWait ticks had passed.  pdPASS will
N * be returned if the command was successfully sent to the timer command queue.
N * When the command is actually processed will depend on the priority of the
N * timer service/daemon task relative to other tasks in the system.  The timer
N * service/daemon task priority is set by the configTIMER_TASK_PRIORITY
N * configuration constant.
N *
N * Example usage:
N *
N * See the xTimerChangePeriod() API function example usage scenario.
N */
N#define xTimerDelete( xTimer, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_DELETE, 0U, NULL, ( xTicksToWait ) )
N
N/**
N * BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xTicksToWait );
N *
N * Timer functionality is provided by a timer service/daemon task.  Many of the
N * public FreeRTOS timer API functions send commands to the timer service task
N * through a queue called the timer command queue.  The timer command queue is
N * private to the kernel itself and is not directly accessible to application
N * code.  The length of the timer command queue is set by the
N * configTIMER_QUEUE_LENGTH configuration constant.
N *
N * xTimerReset() re-starts a timer that was previously created using the
N * xTimerCreate() API function.  If the timer had already been started and was
N * already in the active state, then xTimerReset() will cause the timer to
N * re-evaluate its expiry time so that it is relative to when xTimerReset() was
N * called.  If the timer was in the dormant state then xTimerReset() has
N * equivalent functionality to the xTimerStart() API function.
N *
N * Resetting a timer ensures the timer is in the active state.  If the timer
N * is not stopped, deleted, or reset in the mean time, the callback function
N * associated with the timer will get called 'n' ticks after xTimerReset() was
N * called, where 'n' is the timers defined period.
N *
N * It is valid to call xTimerReset() before the scheduler has been started, but
N * when this is done the timer will not actually start until the scheduler is
N * started, and the timers expiry time will be relative to when the scheduler is
N * started, not relative to when xTimerReset() was called.
N *
N * The configUSE_TIMERS configuration constant must be set to 1 for xTimerReset()
N * to be available.
N *
N * @param xTimer The handle of the timer being reset/started/restarted.
N *
N * @param xTicksToWait Specifies the time, in ticks, that the calling task should
N * be held in the Blocked state to wait for the reset command to be successfully
N * sent to the timer command queue, should the queue already be full when
N * xTimerReset() was called.  xTicksToWait is ignored if xTimerReset() is called
N * before the scheduler is started.
N *
N * @return pdFAIL will be returned if the reset command could not be sent to
N * the timer command queue even after xTicksToWait ticks had passed.  pdPASS will
N * be returned if the command was successfully sent to the timer command queue.
N * When the command is actually processed will depend on the priority of the
N * timer service/daemon task relative to other tasks in the system, although the
N * timers expiry time is relative to when xTimerStart() is actually called.  The
N * timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY
N * configuration constant.
N *
N * Example usage:
N * @verbatim
N * // When a key is pressed, an LCD back-light is switched on.  If 5 seconds pass
N * // without a key being pressed, then the LCD back-light is switched off.  In
N * // this case, the timer is a one-shot timer.
N *
N * TimerHandle_t xBacklightTimer = NULL;
N *
N * // The callback function assigned to the one-shot timer.  In this case the
N * // parameter is not used.
N * void vBacklightTimerCallback( TimerHandle_t pxTimer )
N * {
N *     // The timer expired, therefore 5 seconds must have passed since a key
N *     // was pressed.  Switch off the LCD back-light.
N *     vSetBacklightState( BACKLIGHT_OFF );
N * }
N *
N * // The key press event handler.
N * void vKeyPressEventHandler( char cKey )
N * {
N *     // Ensure the LCD back-light is on, then reset the timer that is
N *     // responsible for turning the back-light off after 5 seconds of
N *     // key inactivity.  Wait 10 ticks for the command to be successfully sent
N *     // if it cannot be sent immediately.
N *     vSetBacklightState( BACKLIGHT_ON );
N *     if( xTimerReset( xBacklightTimer, 100 ) != pdPASS )
N *     {
N *         // The reset command was not executed successfully.  Take appropriate
N *         // action here.
N *     }
N *
N *     // Perform the rest of the key processing here.
N * }
N *
N * void main( void )
N * {
N * int32_t x;
N *
N *     // Create then start the one-shot timer that is responsible for turning
N *     // the back-light off if no keys are pressed within a 5 second period.
N *     xBacklightTimer = xTimerCreate( "BacklightTimer",           // Just a text name, not used by the kernel.
N *                                     ( 5000 / portTICK_PERIOD_MS), // The timer period in ticks.
N *                                     pdFALSE,                    // The timer is a one-shot timer.
N *                                     0,                          // The id is not used by the callback so can take any value.
N *                                     vBacklightTimerCallback     // The callback function that switches the LCD back-light off.
N *                                   );
N *
N *     if( xBacklightTimer == NULL )
N *     {
N *         // The timer was not created.
N *     }
N *     else
N *     {
N *         // Start the timer.  No block time is specified, and even if one was
N *         // it would be ignored because the scheduler has not yet been
N *         // started.
N *         if( xTimerStart( xBacklightTimer, 0 ) != pdPASS )
N *         {
N *             // The timer could not be set into the Active state.
N *         }
N *     }
N *
N *     // ...
N *     // Create tasks here.
N *     // ...
N *
N *     // Starting the scheduler will start the timer running as it has already
N *     // been set into the active state.
N *     xTaskStartScheduler();
N *
N *     // Should not reach here.
N *     for( ;; );
N * }
N * @endverbatim
N */
N#define xTimerReset( xTimer, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_RESET, ( xTaskGetTickCount() ), NULL, ( xTicksToWait ) )
N
N/**
N * BaseType_t xTimerStartFromISR( 	TimerHandle_t xTimer,
N *									BaseType_t *pxHigherPriorityTaskWoken );
N *
N * A version of xTimerStart() that can be called from an interrupt service
N * routine.
N *
N * @param xTimer The handle of the timer being started/restarted.
N *
N * @param pxHigherPriorityTaskWoken The timer service/daemon task spends most
N * of its time in the Blocked state, waiting for messages to arrive on the timer
N * command queue.  Calling xTimerStartFromISR() writes a message to the timer
N * command queue, so has the potential to transition the timer service/daemon
N * task out of the Blocked state.  If calling xTimerStartFromISR() causes the
N * timer service/daemon task to leave the Blocked state, and the timer service/
N * daemon task has a priority equal to or greater than the currently executing
N * task (the task that was interrupted), then *pxHigherPriorityTaskWoken will
N * get set to pdTRUE internally within the xTimerStartFromISR() function.  If
N * xTimerStartFromISR() sets this value to pdTRUE then a context switch should
N * be performed before the interrupt exits.
N *
N * @return pdFAIL will be returned if the start command could not be sent to
N * the timer command queue.  pdPASS will be returned if the command was
N * successfully sent to the timer command queue.  When the command is actually
N * processed will depend on the priority of the timer service/daemon task
N * relative to other tasks in the system, although the timers expiry time is
N * relative to when xTimerStartFromISR() is actually called.  The timer
N * service/daemon task priority is set by the configTIMER_TASK_PRIORITY
N * configuration constant.
N *
N * Example usage:
N * @verbatim
N * // This scenario assumes xBacklightTimer has already been created.  When a
N * // key is pressed, an LCD back-light is switched on.  If 5 seconds pass
N * // without a key being pressed, then the LCD back-light is switched off.  In
N * // this case, the timer is a one-shot timer, and unlike the example given for
N * // the xTimerReset() function, the key press event handler is an interrupt
N * // service routine.
N *
N * // The callback function assigned to the one-shot timer.  In this case the
N * // parameter is not used.
N * void vBacklightTimerCallback( TimerHandle_t pxTimer )
N * {
N *     // The timer expired, therefore 5 seconds must have passed since a key
N *     // was pressed.  Switch off the LCD back-light.
N *     vSetBacklightState( BACKLIGHT_OFF );
N * }
N *
N * // The key press interrupt service routine.
N * void vKeyPressEventInterruptHandler( void )
N * {
N * BaseType_t xHigherPriorityTaskWoken = pdFALSE;
N *
N *     // Ensure the LCD back-light is on, then restart the timer that is
N *     // responsible for turning the back-light off after 5 seconds of
N *     // key inactivity.  This is an interrupt service routine so can only
N *     // call FreeRTOS API functions that end in "FromISR".
N *     vSetBacklightState( BACKLIGHT_ON );
N *
N *     // xTimerStartFromISR() or xTimerResetFromISR() could be called here
N *     // as both cause the timer to re-calculate its expiry time.
N *     // xHigherPriorityTaskWoken was initialised to pdFALSE when it was
N *     // declared (in this function).
N *     if( xTimerStartFromISR( xBacklightTimer, &xHigherPriorityTaskWoken ) != pdPASS )
N *     {
N *         // The start command was not executed successfully.  Take appropriate
N *         // action here.
N *     }
N *
N *     // Perform the rest of the key processing here.
N *
N *     // If xHigherPriorityTaskWoken equals pdTRUE, then a context switch
N *     // should be performed.  The syntax required to perform a context switch
N *     // from inside an ISR varies from port to port, and from compiler to
N *     // compiler.  Inspect the demos for the port you are using to find the
N *     // actual syntax required.
N *     if( xHigherPriorityTaskWoken != pdFALSE )
N *     {
N *         // Call the interrupt safe yield function here (actual function
N *         // depends on the FreeRTOS port being used).
N *     }
N * }
N * @endverbatim
N */
N#define xTimerStartFromISR( xTimer, pxHigherPriorityTaskWoken ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_START_FROM_ISR, ( xTaskGetTickCountFromISR() ), ( pxHigherPriorityTaskWoken ), 0U )
N
N/**
N * BaseType_t xTimerStopFromISR( 	TimerHandle_t xTimer,
N *									BaseType_t *pxHigherPriorityTaskWoken );
N *
N * A version of xTimerStop() that can be called from an interrupt service
N * routine.
N *
N * @param xTimer The handle of the timer being stopped.
N *
N * @param pxHigherPriorityTaskWoken The timer service/daemon task spends most
N * of its time in the Blocked state, waiting for messages to arrive on the timer
N * command queue.  Calling xTimerStopFromISR() writes a message to the timer
N * command queue, so has the potential to transition the timer service/daemon
N * task out of the Blocked state.  If calling xTimerStopFromISR() causes the
N * timer service/daemon task to leave the Blocked state, and the timer service/
N * daemon task has a priority equal to or greater than the currently executing
N * task (the task that was interrupted), then *pxHigherPriorityTaskWoken will
N * get set to pdTRUE internally within the xTimerStopFromISR() function.  If
N * xTimerStopFromISR() sets this value to pdTRUE then a context switch should
N * be performed before the interrupt exits.
N *
N * @return pdFAIL will be returned if the stop command could not be sent to
N * the timer command queue.  pdPASS will be returned if the command was
N * successfully sent to the timer command queue.  When the command is actually
N * processed will depend on the priority of the timer service/daemon task
N * relative to other tasks in the system.  The timer service/daemon task
N * priority is set by the configTIMER_TASK_PRIORITY configuration constant.
N *
N * Example usage:
N * @verbatim
N * // This scenario assumes xTimer has already been created and started.  When
N * // an interrupt occurs, the timer should be simply stopped.
N *
N * // The interrupt service routine that stops the timer.
N * void vAnExampleInterruptServiceRoutine( void )
N * {
N * BaseType_t xHigherPriorityTaskWoken = pdFALSE;
N *
N *     // The interrupt has occurred - simply stop the timer.
N *     // xHigherPriorityTaskWoken was set to pdFALSE where it was defined
N *     // (within this function).  As this is an interrupt service routine, only
N *     // FreeRTOS API functions that end in "FromISR" can be used.
N *     if( xTimerStopFromISR( xTimer, &xHigherPriorityTaskWoken ) != pdPASS )
N *     {
N *         // The stop command was not executed successfully.  Take appropriate
N *         // action here.
N *     }
N *
N *     // If xHigherPriorityTaskWoken equals pdTRUE, then a context switch
N *     // should be performed.  The syntax required to perform a context switch
N *     // from inside an ISR varies from port to port, and from compiler to
N *     // compiler.  Inspect the demos for the port you are using to find the
N *     // actual syntax required.
N *     if( xHigherPriorityTaskWoken != pdFALSE )
N *     {
N *         // Call the interrupt safe yield function here (actual function
N *         // depends on the FreeRTOS port being used).
N *     }
N * }
N * @endverbatim
N */
N#define xTimerStopFromISR( xTimer, pxHigherPriorityTaskWoken ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_STOP_FROM_ISR, 0, ( pxHigherPriorityTaskWoken ), 0U )
N
N/**
N * BaseType_t xTimerChangePeriodFromISR( TimerHandle_t xTimer,
N *										 TickType_t xNewPeriod,
N *										 BaseType_t *pxHigherPriorityTaskWoken );
N *
N * A version of xTimerChangePeriod() that can be called from an interrupt
N * service routine.
N *
N * @param xTimer The handle of the timer that is having its period changed.
N *
N * @param xNewPeriod The new period for xTimer. Timer periods are specified in
N * tick periods, so the constant portTICK_PERIOD_MS can be used to convert a time
N * that has been specified in milliseconds.  For example, if the timer must
N * expire after 100 ticks, then xNewPeriod should be set to 100.  Alternatively,
N * if the timer must expire after 500ms, then xNewPeriod can be set to
N * ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than
N * or equal to 1000.
N *
N * @param pxHigherPriorityTaskWoken The timer service/daemon task spends most
N * of its time in the Blocked state, waiting for messages to arrive on the timer
N * command queue.  Calling xTimerChangePeriodFromISR() writes a message to the
N * timer command queue, so has the potential to transition the timer service/
N * daemon task out of the Blocked state.  If calling xTimerChangePeriodFromISR()
N * causes the timer service/daemon task to leave the Blocked state, and the
N * timer service/daemon task has a priority equal to or greater than the
N * currently executing task (the task that was interrupted), then
N * *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the
N * xTimerChangePeriodFromISR() function.  If xTimerChangePeriodFromISR() sets
N * this value to pdTRUE then a context switch should be performed before the
N * interrupt exits.
N *
N * @return pdFAIL will be returned if the command to change the timers period
N * could not be sent to the timer command queue.  pdPASS will be returned if the
N * command was successfully sent to the timer command queue.  When the command
N * is actually processed will depend on the priority of the timer service/daemon
N * task relative to other tasks in the system.  The timer service/daemon task
N * priority is set by the configTIMER_TASK_PRIORITY configuration constant.
N *
N * Example usage:
N * @verbatim
N * // This scenario assumes xTimer has already been created and started.  When
N * // an interrupt occurs, the period of xTimer should be changed to 500ms.
N *
N * // The interrupt service routine that changes the period of xTimer.
N * void vAnExampleInterruptServiceRoutine( void )
N * {
N * BaseType_t xHigherPriorityTaskWoken = pdFALSE;
N *
N *     // The interrupt has occurred - change the period of xTimer to 500ms.
N *     // xHigherPriorityTaskWoken was set to pdFALSE where it was defined
N *     // (within this function).  As this is an interrupt service routine, only
N *     // FreeRTOS API functions that end in "FromISR" can be used.
N *     if( xTimerChangePeriodFromISR( xTimer, &xHigherPriorityTaskWoken ) != pdPASS )
N *     {
N *         // The command to change the timers period was not executed
N *         // successfully.  Take appropriate action here.
N *     }
N *
N *     // If xHigherPriorityTaskWoken equals pdTRUE, then a context switch
N *     // should be performed.  The syntax required to perform a context switch
N *     // from inside an ISR varies from port to port, and from compiler to
N *     // compiler.  Inspect the demos for the port you are using to find the
N *     // actual syntax required.
N *     if( xHigherPriorityTaskWoken != pdFALSE )
N *     {
N *         // Call the interrupt safe yield function here (actual function
N *         // depends on the FreeRTOS port being used).
N *     }
N * }
N * @endverbatim
N */
N#define xTimerChangePeriodFromISR( xTimer, xNewPeriod, pxHigherPriorityTaskWoken ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_CHANGE_PERIOD_FROM_ISR, ( xNewPeriod ), ( pxHigherPriorityTaskWoken ), 0U )
N
N/**
N * BaseType_t xTimerResetFromISR( 	TimerHandle_t xTimer,
N *									BaseType_t *pxHigherPriorityTaskWoken );
N *
N * A version of xTimerReset() that can be called from an interrupt service
N * routine.
N *
N * @param xTimer The handle of the timer that is to be started, reset, or
N * restarted.
N *
N * @param pxHigherPriorityTaskWoken The timer service/daemon task spends most
N * of its time in the Blocked state, waiting for messages to arrive on the timer
N * command queue.  Calling xTimerResetFromISR() writes a message to the timer
N * command queue, so has the potential to transition the timer service/daemon
N * task out of the Blocked state.  If calling xTimerResetFromISR() causes the
N * timer service/daemon task to leave the Blocked state, and the timer service/
N * daemon task has a priority equal to or greater than the currently executing
N * task (the task that was interrupted), then *pxHigherPriorityTaskWoken will
N * get set to pdTRUE internally within the xTimerResetFromISR() function.  If
N * xTimerResetFromISR() sets this value to pdTRUE then a context switch should
N * be performed before the interrupt exits.
N *
N * @return pdFAIL will be returned if the reset command could not be sent to
N * the timer command queue.  pdPASS will be returned if the command was
N * successfully sent to the timer command queue.  When the command is actually
N * processed will depend on the priority of the timer service/daemon task
N * relative to other tasks in the system, although the timers expiry time is
N * relative to when xTimerResetFromISR() is actually called.  The timer service/daemon
N * task priority is set by the configTIMER_TASK_PRIORITY configuration constant.
N *
N * Example usage:
N * @verbatim
N * // This scenario assumes xBacklightTimer has already been created.  When a
N * // key is pressed, an LCD back-light is switched on.  If 5 seconds pass
N * // without a key being pressed, then the LCD back-light is switched off.  In
N * // this case, the timer is a one-shot timer, and unlike the example given for
N * // the xTimerReset() function, the key press event handler is an interrupt
N * // service routine.
N *
N * // The callback function assigned to the one-shot timer.  In this case the
N * // parameter is not used.
N * void vBacklightTimerCallback( TimerHandle_t pxTimer )
N * {
N *     // The timer expired, therefore 5 seconds must have passed since a key
N *     // was pressed.  Switch off the LCD back-light.
N *     vSetBacklightState( BACKLIGHT_OFF );
N * }
N *
N * // The key press interrupt service routine.
N * void vKeyPressEventInterruptHandler( void )
N * {
N * BaseType_t xHigherPriorityTaskWoken = pdFALSE;
N *
N *     // Ensure the LCD back-light is on, then reset the timer that is
N *     // responsible for turning the back-light off after 5 seconds of
N *     // key inactivity.  This is an interrupt service routine so can only
N *     // call FreeRTOS API functions that end in "FromISR".
N *     vSetBacklightState( BACKLIGHT_ON );
N *
N *     // xTimerStartFromISR() or xTimerResetFromISR() could be called here
N *     // as both cause the timer to re-calculate its expiry time.
N *     // xHigherPriorityTaskWoken was initialised to pdFALSE when it was
N *     // declared (in this function).
N *     if( xTimerResetFromISR( xBacklightTimer, &xHigherPriorityTaskWoken ) != pdPASS )
N *     {
N *         // The reset command was not executed successfully.  Take appropriate
N *         // action here.
N *     }
N *
N *     // Perform the rest of the key processing here.
N *
N *     // If xHigherPriorityTaskWoken equals pdTRUE, then a context switch
N *     // should be performed.  The syntax required to perform a context switch
N *     // from inside an ISR varies from port to port, and from compiler to
N *     // compiler.  Inspect the demos for the port you are using to find the
N *     // actual syntax required.
N *     if( xHigherPriorityTaskWoken != pdFALSE )
N *     {
N *         // Call the interrupt safe yield function here (actual function
N *         // depends on the FreeRTOS port being used).
N *     }
N * }
N * @endverbatim
N */
N#define xTimerResetFromISR( xTimer, pxHigherPriorityTaskWoken ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_RESET_FROM_ISR, ( xTaskGetTickCountFromISR() ), ( pxHigherPriorityTaskWoken ), 0U )
N
N
N/**
N * BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend,
N *                                          void *pvParameter1,
N *                                          uint32_t ulParameter2,
N *                                          BaseType_t *pxHigherPriorityTaskWoken );
N *
N *
N * Used from application interrupt service routines to defer the execution of a
N * function to the RTOS daemon task (the timer service task, hence this function
N * is implemented in timers.c and is prefixed with 'Timer').
N *
N * Ideally an interrupt service routine (ISR) is kept as short as possible, but
N * sometimes an ISR either has a lot of processing to do, or needs to perform
N * processing that is not deterministic.  In these cases
N * xTimerPendFunctionCallFromISR() can be used to defer processing of a function
N * to the RTOS daemon task.
N *
N * A mechanism is provided that allows the interrupt to return directly to the
N * task that will subsequently execute the pended callback function.  This
N * allows the callback function to execute contiguously in time with the
N * interrupt - just as if the callback had executed in the interrupt itself.
N *
N * @param xFunctionToPend The function to execute from the timer service/
N * daemon task.  The function must conform to the PendedFunction_t
N * prototype.
N *
N * @param pvParameter1 The value of the callback function's first parameter.
N * The parameter has a void * type to allow it to be used to pass any type.
N * For example, unsigned longs can be cast to a void *, or the void * can be
N * used to point to a structure.
N *
N * @param ulParameter2 The value of the callback function's second parameter.
N *
N * @param pxHigherPriorityTaskWoken As mentioned above, calling this function
N * will result in a message being sent to the timer daemon task.  If the
N * priority of the timer daemon task (which is set using
N * configTIMER_TASK_PRIORITY in FreeRTOSConfig.h) is higher than the priority of
N * the currently running task (the task the interrupt interrupted) then
N * *pxHigherPriorityTaskWoken will be set to pdTRUE within
N * xTimerPendFunctionCallFromISR(), indicating that a context switch should be
N * requested before the interrupt exits.  For that reason
N * *pxHigherPriorityTaskWoken must be initialised to pdFALSE.  See the
N * example code below.
N *
N * @return pdPASS is returned if the message was successfully sent to the
N * timer daemon task, otherwise pdFALSE is returned.
N *
N * Example usage:
N * @verbatim
N *
N *	// The callback function that will execute in the context of the daemon task.
N *  // Note callback functions must all use this same prototype.
N *  void vProcessInterface( void *pvParameter1, uint32_t ulParameter2 )
N *	{
N *		BaseType_t xInterfaceToService;
N *
N *		// The interface that requires servicing is passed in the second
N *      // parameter.  The first parameter is not used in this case.
N *		xInterfaceToService = ( BaseType_t ) ulParameter2;
N *
N *		// ...Perform the processing here...
N *	}
N *
N *	// An ISR that receives data packets from multiple interfaces
N *  void vAnISR( void )
N *	{
N *		BaseType_t xInterfaceToService, xHigherPriorityTaskWoken;
N *
N *		// Query the hardware to determine which interface needs processing.
N *		xInterfaceToService = prvCheckInterfaces();
N *
N *      // The actual processing is to be deferred to a task.  Request the
N *      // vProcessInterface() callback function is executed, passing in the
N *		// number of the interface that needs processing.  The interface to
N *		// service is passed in the second parameter.  The first parameter is
N *		// not used in this case.
N *		xHigherPriorityTaskWoken = pdFALSE;
N *		xTimerPendFunctionCallFromISR( vProcessInterface, NULL, ( uint32_t ) xInterfaceToService, &xHigherPriorityTaskWoken );
N *
N *		// If xHigherPriorityTaskWoken is now set to pdTRUE then a context
N *		// switch should be requested.  The macro used is port specific and will
N *		// be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() - refer to
N *		// the documentation page for the port being used.
N *		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
N *
N *	}
N * @endverbatim
N */
NBaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken ) ;
N
N /**
N  * BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend,
N  *                                    void *pvParameter1,
N  *                                    uint32_t ulParameter2,
N  *                                    TickType_t xTicksToWait );
N  *
N  *
N  * Used to defer the execution of a function to the RTOS daemon task (the timer
N  * service task, hence this function is implemented in timers.c and is prefixed
N  * with 'Timer').
N  *
N  * @param xFunctionToPend The function to execute from the timer service/
N  * daemon task.  The function must conform to the PendedFunction_t
N  * prototype.
N  *
N  * @param pvParameter1 The value of the callback function's first parameter.
N  * The parameter has a void * type to allow it to be used to pass any type.
N  * For example, unsigned longs can be cast to a void *, or the void * can be
N  * used to point to a structure.
N  *
N  * @param ulParameter2 The value of the callback function's second parameter.
N  *
N  * @param xTicksToWait Calling this function will result in a message being
N  * sent to the timer daemon task on a queue.  xTicksToWait is the amount of
N  * time the calling task should remain in the Blocked state (so not using any
N  * processing time) for space to become available on the timer queue if the
N  * queue is found to be full.
N  *
N  * @return pdPASS is returned if the message was successfully sent to the
N  * timer daemon task, otherwise pdFALSE is returned.
N  *
N  */
NBaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait ) ;
N
N/**
N * const char * const pcTimerGetTimerName( TimerHandle_t xTimer );
N *
N * Returns the name that was assigned to a timer when the timer was created.
N *
N * @param xTimer The handle of the timer being queried.
N *
N * @return The name assigned to the timer specified by the xTimer parameter.
N */
Nconst char * pcTimerGetTimerName( TimerHandle_t xTimer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xconst char * pcTimerGetTimerName( TimerHandle_t xTimer ) ;  
N
N/*
N * Functions beyond this part are not part of the public API and are intended
N * for use by the kernel only.
N */
NBaseType_t xTimerCreateTimerTask( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTimerCreateTimerTask( void ) ;
NBaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait ) ;
N
N#ifdef __cplusplus
S}
N#endif
N#endif /* TIMERS_H */
N
N
N
L 78 "..\..\FreeRTOS\Source\include\event_groups.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**
N * An event group is a collection of bits to which an application can assign a
N * meaning.  For example, an application may create an event group to convey
N * the status of various CAN bus related events in which bit 0 might mean "A CAN
N * message has been received and is ready for processing", bit 1 might mean "The
N * application has queued a message that is ready for sending onto the CAN
N * network", and bit 2 might mean "It is time to send a SYNC message onto the
N * CAN network" etc.  A task can then test the bit values to see which events
N * are active, and optionally enter the Blocked state to wait for a specified
N * bit or a group of specified bits to be active.  To continue the CAN bus
N * example, a CAN controlling task can enter the Blocked state (and therefore
N * not consume any processing time) until either bit 0, bit 1 or bit 2 are
N * active, at which time the bit that was actually active would inform the task
N * which action it had to take (process a received message, send a message, or
N * send a SYNC).
N *
N * The event groups implementation contains intelligence to avoid race
N * conditions that would otherwise occur were an application to use a simple
N * variable for the same purpose.  This is particularly important with respect
N * to when a bit within an event group is to be cleared, and when bits have to
N * be set and then tested atomically - as is the case where event groups are
N * used to create a synchronisation point between multiple tasks (a
N * 'rendezvous').
N *
N * \defgroup EventGroup
N */
N
N
N
N/**
N * event_groups.h
N *
N * Type by which event groups are referenced.  For example, a call to
N * xEventGroupCreate() returns an EventGroupHandle_t variable that can then
N * be used as a parameter to other event group functions.
N *
N * \defgroup EventGroupHandle_t EventGroupHandle_t
N * \ingroup EventGroup
N */
Ntypedef void * EventGroupHandle_t;
N
N/* 
N * The type that holds event bits always matches TickType_t - therefore the
N * number of bits it holds is set by configUSE_16_BIT_TICKS (16 bits if set to 1,
N * 32 bits if set to 0. 
N *
N * \defgroup EventBits_t EventBits_t
N * \ingroup EventGroup
N */
Ntypedef TickType_t EventBits_t;
N
N/**
N * event_groups.h
N *<pre>
N EventGroupHandle_t xEventGroupCreate( void );
N </pre>
N *
N * Create a new event group.  This function cannot be called from an interrupt.
N *
N * Although event groups are not related to ticks, for internal implementation
N * reasons the number of bits available for use in an event group is dependent
N * on the configUSE_16_BIT_TICKS setting in FreeRTOSConfig.h.  If
N * configUSE_16_BIT_TICKS is 1 then each event group contains 8 usable bits (bit
N * 0 to bit 7).  If configUSE_16_BIT_TICKS is set to 0 then each event group has
N * 24 usable bits (bit 0 to bit 23).  The EventBits_t type is used to store
N * event bits within an event group.
N *
N * @return If the event group was created then a handle to the event group is
N * returned.  If there was insufficient FreeRTOS heap available to create the
N * event group then NULL is returned.  See http://www.freertos.org/a00111.html
N *
N * Example usage:
N   <pre>
N	// Declare a variable to hold the created event group.
N	EventGroupHandle_t xCreatedEventGroup;
N
N	// Attempt to create the event group.
N	xCreatedEventGroup = xEventGroupCreate();
N
N	// Was the event group created successfully?
N	if( xCreatedEventGroup == NULL )
N	{
N		// The event group was not created because there was insufficient
N		// FreeRTOS heap available.
N	}
N	else
N	{
N		// The event group was created.
N	}
N   </pre>
N * \defgroup xEventGroupCreate xEventGroupCreate
N * \ingroup EventGroup
N */
NEventGroupHandle_t xEventGroupCreate( void ) PRIVILEGED_FUNCTION;
XEventGroupHandle_t xEventGroupCreate( void ) ;
N
N/**
N * event_groups.h
N *<pre>
N	EventBits_t xEventGroupWaitBits( 	EventGroupHandle_t xEventGroup,
N										const EventBits_t uxBitsToWaitFor,
N										const BaseType_t xClearOnExit,
N										const BaseType_t xWaitForAllBits,
N										const TickType_t xTicksToWait );
N </pre>
N *
N * [Potentially] block to wait for one or more bits to be set within a
N * previously created event group.
N *
N * This function cannot be called from an interrupt.
N *
N * @param xEventGroup The event group in which the bits are being tested.  The
N * event group must have previously been created using a call to
N * xEventGroupCreate().
N *
N * @param uxBitsToWaitFor A bitwise value that indicates the bit or bits to test
N * inside the event group.  For example, to wait for bit 0 and/or bit 2 set
N * uxBitsToWaitFor to 0x05.  To wait for bits 0 and/or bit 1 and/or bit 2 set
N * uxBitsToWaitFor to 0x07.  Etc.
N *
N * @param xClearOnExit If xClearOnExit is set to pdTRUE then any bits within
N * uxBitsToWaitFor that are set within the event group will be cleared before
N * xEventGroupWaitBits() returns if the wait condition was met (if the function
N * returns for a reason other than a timeout).  If xClearOnExit is set to
N * pdFALSE then the bits set in the event group are not altered when the call to
N * xEventGroupWaitBits() returns.
N *
N * @param xWaitForAllBits If xWaitForAllBits is set to pdTRUE then
N * xEventGroupWaitBits() will return when either all the bits in uxBitsToWaitFor
N * are set or the specified block time expires.  If xWaitForAllBits is set to
N * pdFALSE then xEventGroupWaitBits() will return when any one of the bits set
N * in uxBitsToWaitFor is set or the specified block time expires.  The block
N * time is specified by the xTicksToWait parameter.
N *
N * @param xTicksToWait The maximum amount of time (specified in 'ticks') to wait
N * for one/all (depending on the xWaitForAllBits value) of the bits specified by
N * uxBitsToWaitFor to become set.
N *
N * @return The value of the event group at the time either the bits being waited
N * for became set, or the block time expired.  Test the return value to know
N * which bits were set.  If xEventGroupWaitBits() returned because its timeout
N * expired then not all the bits being waited for will be set.  If
N * xEventGroupWaitBits() returned because the bits it was waiting for were set
N * then the returned value is the event group value before any bits were
N * automatically cleared in the case that xClearOnExit parameter was set to
N * pdTRUE.
N *
N * Example usage:
N   <pre>
N   #define BIT_0	( 1 << 0 )
N   #define BIT_4	( 1 << 4 )
N
N   void aFunction( EventGroupHandle_t xEventGroup )
N   {
N   EventBits_t uxBits;
N   const TickType_t xTicksToWait = 100 / portTICK_PERIOD_MS;
N
N		// Wait a maximum of 100ms for either bit 0 or bit 4 to be set within
N		// the event group.  Clear the bits before exiting.
N		uxBits = xEventGroupWaitBits(
N					xEventGroup,	// The event group being tested.
N					BIT_0 | BIT_4,	// The bits within the event group to wait for.
N					pdTRUE,			// BIT_0 and BIT_4 should be cleared before returning.
N					pdFALSE,		// Don't wait for both bits, either bit will do.
N					xTicksToWait );	// Wait a maximum of 100ms for either bit to be set.
N
N		if( ( uxBits & ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )
N		{
N			// xEventGroupWaitBits() returned because both bits were set.
N		}
N		else if( ( uxBits & BIT_0 ) != 0 )
N		{
N			// xEventGroupWaitBits() returned because just BIT_0 was set.
N		}
N		else if( ( uxBits & BIT_4 ) != 0 )
N		{
N			// xEventGroupWaitBits() returned because just BIT_4 was set.
N		}
N		else
N		{
N			// xEventGroupWaitBits() returned because xTicksToWait ticks passed
N			// without either BIT_0 or BIT_4 becoming set.
N		}
N   }
N   </pre>
N * \defgroup xEventGroupWaitBits xEventGroupWaitBits
N * \ingroup EventGroup
N */
NEventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XEventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait ) ;
N
N/**
N * event_groups.h
N *<pre>
N	EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear );
N </pre>
N *
N * Clear bits within an event group.  This function cannot be called from an
N * interrupt.
N *
N * @param xEventGroup The event group in which the bits are to be cleared.
N *
N * @param uxBitsToClear A bitwise value that indicates the bit or bits to clear
N * in the event group.  For example, to clear bit 3 only, set uxBitsToClear to
N * 0x08.  To clear bit 3 and bit 0 set uxBitsToClear to 0x09.
N *
N * @return The value of the event group before the specified bits were cleared.
N *
N * Example usage:
N   <pre>
N   #define BIT_0	( 1 << 0 )
N   #define BIT_4	( 1 << 4 )
N
N   void aFunction( EventGroupHandle_t xEventGroup )
N   {
N   EventBits_t uxBits;
N
N		// Clear bit 0 and bit 4 in xEventGroup.
N		uxBits = xEventGroupClearBits(
N								xEventGroup,	// The event group being updated.
N								BIT_0 | BIT_4 );// The bits being cleared.
N
N		if( ( uxBits & ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )
N		{
N			// Both bit 0 and bit 4 were set before xEventGroupClearBits() was
N			// called.  Both will now be clear (not set).
N		}
N		else if( ( uxBits & BIT_0 ) != 0 )
N		{
N			// Bit 0 was set before xEventGroupClearBits() was called.  It will
N			// now be clear.
N		}
N		else if( ( uxBits & BIT_4 ) != 0 )
N		{
N			// Bit 4 was set before xEventGroupClearBits() was called.  It will
N			// now be clear.
N		}
N		else
N		{
N			// Neither bit 0 nor bit 4 were set in the first place.
N		}
N   }
N   </pre>
N * \defgroup xEventGroupClearBits xEventGroupClearBits
N * \ingroup EventGroup
N */
NEventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear ) PRIVILEGED_FUNCTION;
XEventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear ) ;
N
N/**
N * event_groups.h
N *<pre>
N	BaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet );
N </pre>
N *
N * A version of xEventGroupClearBits() that can be called from an interrupt.
N *
N * Setting bits in an event group is not a deterministic operation because there
N * are an unknown number of tasks that may be waiting for the bit or bits being
N * set.  FreeRTOS does not allow nondeterministic operations to be performed
N * while interrupts are disabled, so protects event groups that are accessed
N * from tasks by suspending the scheduler rather than disabling interrupts.  As
N * a result event groups cannot be accessed directly from an interrupt service
N * routine.  Therefore xEventGroupClearBitsFromISR() sends a message to the 
N * timer task to have the clear operation performed in the context of the timer 
N * task.
N *
N * @param xEventGroup The event group in which the bits are to be cleared.
N *
N * @param uxBitsToClear A bitwise value that indicates the bit or bits to clear.
N * For example, to clear bit 3 only, set uxBitsToClear to 0x08.  To clear bit 3
N * and bit 0 set uxBitsToClear to 0x09.
N *
N * @return If the request to execute the function was posted successfully then 
N * pdPASS is returned, otherwise pdFALSE is returned.  pdFALSE will be returned 
N * if the timer service queue was full.
N *
N * Example usage:
N   <pre>
N   #define BIT_0	( 1 << 0 )
N   #define BIT_4	( 1 << 4 )
N
N   // An event group which it is assumed has already been created by a call to
N   // xEventGroupCreate().
N   EventGroupHandle_t xEventGroup;
N
N   void anInterruptHandler( void )
N   {
N		// Clear bit 0 and bit 4 in xEventGroup.
N		xResult = xEventGroupClearBitsFromISR(
N							xEventGroup,	 // The event group being updated.
N							BIT_0 | BIT_4 ); // The bits being set.
N
N		if( xResult == pdPASS )
N		{
N			// The message was posted successfully.
N		}
N  }
N   </pre>
N * \defgroup xEventGroupSetBitsFromISR xEventGroupSetBitsFromISR
N * \ingroup EventGroup
N */
N#if( configUSE_TRACE_FACILITY == 1 )
X#if( 0 == 1 )
S	BaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet ) PRIVILEGED_FUNCTION;
N#else
N	#define xEventGroupClearBitsFromISR( xEventGroup, uxBitsToClear ) xTimerPendFunctionCallFromISR( vEventGroupClearBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToClear, NULL )
N#endif
N
N/**
N * event_groups.h
N *<pre>
N	EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet );
N </pre>
N *
N * Set bits within an event group.
N * This function cannot be called from an interrupt.  xEventGroupSetBitsFromISR()
N * is a version that can be called from an interrupt.
N *
N * Setting bits in an event group will automatically unblock tasks that are
N * blocked waiting for the bits.
N *
N * @param xEventGroup The event group in which the bits are to be set.
N *
N * @param uxBitsToSet A bitwise value that indicates the bit or bits to set.
N * For example, to set bit 3 only, set uxBitsToSet to 0x08.  To set bit 3
N * and bit 0 set uxBitsToSet to 0x09.
N *
N * @return The value of the event group at the time the call to
N * xEventGroupSetBits() returns.  There are two reasons why the returned value
N * might have the bits specified by the uxBitsToSet parameter cleared.  First,
N * if setting a bit results in a task that was waiting for the bit leaving the
N * blocked state then it is possible the bit will be cleared automatically
N * (see the xClearBitOnExit parameter of xEventGroupWaitBits()).  Second, any
N * unblocked (or otherwise Ready state) task that has a priority above that of
N * the task that called xEventGroupSetBits() will execute and may change the
N * event group value before the call to xEventGroupSetBits() returns.
N *
N * Example usage:
N   <pre>
N   #define BIT_0	( 1 << 0 )
N   #define BIT_4	( 1 << 4 )
N
N   void aFunction( EventGroupHandle_t xEventGroup )
N   {
N   EventBits_t uxBits;
N
N		// Set bit 0 and bit 4 in xEventGroup.
N		uxBits = xEventGroupSetBits(
N							xEventGroup,	// The event group being updated.
N							BIT_0 | BIT_4 );// The bits being set.
N
N		if( ( uxBits & ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )
N		{
N			// Both bit 0 and bit 4 remained set when the function returned.
N		}
N		else if( ( uxBits & BIT_0 ) != 0 )
N		{
N			// Bit 0 remained set when the function returned, but bit 4 was
N			// cleared.  It might be that bit 4 was cleared automatically as a
N			// task that was waiting for bit 4 was removed from the Blocked
N			// state.
N		}
N		else if( ( uxBits & BIT_4 ) != 0 )
N		{
N			// Bit 4 remained set when the function returned, but bit 0 was
N			// cleared.  It might be that bit 0 was cleared automatically as a
N			// task that was waiting for bit 0 was removed from the Blocked
N			// state.
N		}
N		else
N		{
N			// Neither bit 0 nor bit 4 remained set.  It might be that a task
N			// was waiting for both of the bits to be set, and the bits were
N			// cleared as the task left the Blocked state.
N		}
N   }
N   </pre>
N * \defgroup xEventGroupSetBits xEventGroupSetBits
N * \ingroup EventGroup
N */
NEventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet ) PRIVILEGED_FUNCTION;
XEventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet ) ;
N
N/**
N * event_groups.h
N *<pre>
N	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken );
N </pre>
N *
N * A version of xEventGroupSetBits() that can be called from an interrupt.
N *
N * Setting bits in an event group is not a deterministic operation because there
N * are an unknown number of tasks that may be waiting for the bit or bits being
N * set.  FreeRTOS does not allow nondeterministic operations to be performed in
N * interrupts or from critical sections.  Therefore xEventGroupSetBitFromISR()
N * sends a message to the timer task to have the set operation performed in the
N * context of the timer task - where a scheduler lock is used in place of a
N * critical section.
N *
N * @param xEventGroup The event group in which the bits are to be set.
N *
N * @param uxBitsToSet A bitwise value that indicates the bit or bits to set.
N * For example, to set bit 3 only, set uxBitsToSet to 0x08.  To set bit 3
N * and bit 0 set uxBitsToSet to 0x09.
N *
N * @param pxHigherPriorityTaskWoken As mentioned above, calling this function
N * will result in a message being sent to the timer daemon task.  If the
N * priority of the timer daemon task is higher than the priority of the
N * currently running task (the task the interrupt interrupted) then
N * *pxHigherPriorityTaskWoken will be set to pdTRUE by
N * xEventGroupSetBitsFromISR(), indicating that a context switch should be
N * requested before the interrupt exits.  For that reason
N * *pxHigherPriorityTaskWoken must be initialised to pdFALSE.  See the
N * example code below.
N *
N * @return If the request to execute the function was posted successfully then 
N * pdPASS is returned, otherwise pdFALSE is returned.  pdFALSE will be returned 
N * if the timer service queue was full.
N *
N * Example usage:
N   <pre>
N   #define BIT_0	( 1 << 0 )
N   #define BIT_4	( 1 << 4 )
N
N   // An event group which it is assumed has already been created by a call to
N   // xEventGroupCreate().
N   EventGroupHandle_t xEventGroup;
N
N   void anInterruptHandler( void )
N   {
N   BaseType_t xHigherPriorityTaskWoken, xResult;
N
N		// xHigherPriorityTaskWoken must be initialised to pdFALSE.
N		xHigherPriorityTaskWoken = pdFALSE;
N
N		// Set bit 0 and bit 4 in xEventGroup.
N		xResult = xEventGroupSetBitsFromISR(
N							xEventGroup,	// The event group being updated.
N							BIT_0 | BIT_4   // The bits being set.
N							&xHigherPriorityTaskWoken );
N
N		// Was the message posted successfully?
N		if( xResult == pdPASS )
N		{
N			// If xHigherPriorityTaskWoken is now set to pdTRUE then a context
N			// switch should be requested.  The macro used is port specific and 
N			// will be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() - 
N			// refer to the documentation page for the port being used.
N			portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
N		}
N  }
N   </pre>
N * \defgroup xEventGroupSetBitsFromISR xEventGroupSetBitsFromISR
N * \ingroup EventGroup
N */
N#if( configUSE_TRACE_FACILITY == 1 )
X#if( 0 == 1 )
S	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
N#else
N	#define xEventGroupSetBitsFromISR( xEventGroup, uxBitsToSet, pxHigherPriorityTaskWoken ) xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken )
N#endif
N
N/**
N * event_groups.h
N *<pre>
N	EventBits_t xEventGroupSync(	EventGroupHandle_t xEventGroup,
N									const EventBits_t uxBitsToSet,
N									const EventBits_t uxBitsToWaitFor,
N									TickType_t xTicksToWait );
N </pre>
N *
N * Atomically set bits within an event group, then wait for a combination of
N * bits to be set within the same event group.  This functionality is typically
N * used to synchronise multiple tasks, where each task has to wait for the other
N * tasks to reach a synchronisation point before proceeding.
N *
N * This function cannot be used from an interrupt.
N *
N * The function will return before its block time expires if the bits specified
N * by the uxBitsToWait parameter are set, or become set within that time.  In
N * this case all the bits specified by uxBitsToWait will be automatically
N * cleared before the function returns.
N *
N * @param xEventGroup The event group in which the bits are being tested.  The
N * event group must have previously been created using a call to
N * xEventGroupCreate().
N *
N * @param uxBitsToSet The bits to set in the event group before determining
N * if, and possibly waiting for, all the bits specified by the uxBitsToWait
N * parameter are set.
N *
N * @param uxBitsToWaitFor A bitwise value that indicates the bit or bits to test
N * inside the event group.  For example, to wait for bit 0 and bit 2 set
N * uxBitsToWaitFor to 0x05.  To wait for bits 0 and bit 1 and bit 2 set
N * uxBitsToWaitFor to 0x07.  Etc.
N *
N * @param xTicksToWait The maximum amount of time (specified in 'ticks') to wait
N * for all of the bits specified by uxBitsToWaitFor to become set.
N *
N * @return The value of the event group at the time either the bits being waited
N * for became set, or the block time expired.  Test the return value to know
N * which bits were set.  If xEventGroupSync() returned because its timeout
N * expired then not all the bits being waited for will be set.  If
N * xEventGroupSync() returned because all the bits it was waiting for were
N * set then the returned value is the event group value before any bits were
N * automatically cleared.
N *
N * Example usage:
N <pre>
N // Bits used by the three tasks.
N #define TASK_0_BIT		( 1 << 0 )
N #define TASK_1_BIT		( 1 << 1 )
N #define TASK_2_BIT		( 1 << 2 )
N
N #define ALL_SYNC_BITS ( TASK_0_BIT | TASK_1_BIT | TASK_2_BIT )
N
N // Use an event group to synchronise three tasks.  It is assumed this event
N // group has already been created elsewhere.
N EventGroupHandle_t xEventBits;
N
N void vTask0( void *pvParameters )
N {
N EventBits_t uxReturn;
N TickType_t xTicksToWait = 100 / portTICK_PERIOD_MS;
N
N	 for( ;; )
N	 {
N		// Perform task functionality here.
N
N		// Set bit 0 in the event flag to note this task has reached the
N		// sync point.  The other two tasks will set the other two bits defined
N		// by ALL_SYNC_BITS.  All three tasks have reached the synchronisation
N		// point when all the ALL_SYNC_BITS are set.  Wait a maximum of 100ms
N		// for this to happen.
N		uxReturn = xEventGroupSync( xEventBits, TASK_0_BIT, ALL_SYNC_BITS, xTicksToWait );
N
N		if( ( uxReturn & ALL_SYNC_BITS ) == ALL_SYNC_BITS )
N		{
N			// All three tasks reached the synchronisation point before the call
N			// to xEventGroupSync() timed out.
N		}
N	}
N }
N
N void vTask1( void *pvParameters )
N {
N	 for( ;; )
N	 {
N		// Perform task functionality here.
N
N		// Set bit 1 in the event flag to note this task has reached the
N		// synchronisation point.  The other two tasks will set the other two
N		// bits defined by ALL_SYNC_BITS.  All three tasks have reached the
N		// synchronisation point when all the ALL_SYNC_BITS are set.  Wait
N		// indefinitely for this to happen.
N		xEventGroupSync( xEventBits, TASK_1_BIT, ALL_SYNC_BITS, portMAX_DELAY );
N
N		// xEventGroupSync() was called with an indefinite block time, so
N		// this task will only reach here if the syncrhonisation was made by all
N		// three tasks, so there is no need to test the return value.
N	 }
N }
N
N void vTask2( void *pvParameters )
N {
N	 for( ;; )
N	 {
N		// Perform task functionality here.
N
N		// Set bit 2 in the event flag to note this task has reached the
N		// synchronisation point.  The other two tasks will set the other two
N		// bits defined by ALL_SYNC_BITS.  All three tasks have reached the
N		// synchronisation point when all the ALL_SYNC_BITS are set.  Wait
N		// indefinitely for this to happen.
N		xEventGroupSync( xEventBits, TASK_2_BIT, ALL_SYNC_BITS, portMAX_DELAY );
N
N		// xEventGroupSync() was called with an indefinite block time, so
N		// this task will only reach here if the syncrhonisation was made by all
N		// three tasks, so there is no need to test the return value.
N	}
N }
N
N </pre>
N * \defgroup xEventGroupSync xEventGroupSync
N * \ingroup EventGroup
N */
NEventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XEventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait ) ;
N
N
N/**
N * event_groups.h
N *<pre>
N	EventBits_t xEventGroupGetBits( EventGroupHandle_t xEventGroup );
N </pre>
N *
N * Returns the current value of the bits in an event group.  This function
N * cannot be used from an interrupt.
N *
N * @param xEventGroup The event group being queried.
N *
N * @return The event group bits at the time xEventGroupGetBits() was called.
N *
N * \defgroup xEventGroupGetBits xEventGroupGetBits
N * \ingroup EventGroup
N */
N#define xEventGroupGetBits( xEventGroup ) xEventGroupClearBits( xEventGroup, 0 )
N
N/**
N * event_groups.h
N *<pre>
N	EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup );
N </pre>
N *
N * A version of xEventGroupGetBits() that can be called from an ISR.
N *
N * @param xEventGroup The event group being queried.
N *
N * @return The event group bits at the time xEventGroupGetBitsFromISR() was called.
N *
N * \defgroup xEventGroupGetBitsFromISR xEventGroupGetBitsFromISR
N * \ingroup EventGroup
N */
NEventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup ) PRIVILEGED_FUNCTION;
XEventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup ) ;
N
N/**
N * event_groups.h
N *<pre>
N	void xEventGroupDelete( EventGroupHandle_t xEventGroup );
N </pre>
N *
N * Delete an event group that was previously created by a call to
N * xEventGroupCreate().  Tasks that are blocked on the event group will be
N * unblocked and obtain 0 as the event group's value.
N *
N * @param xEventGroup The event group being deleted.
N */
Nvoid vEventGroupDelete( EventGroupHandle_t xEventGroup ) PRIVILEGED_FUNCTION;
Xvoid vEventGroupDelete( EventGroupHandle_t xEventGroup ) ;
N
N/* For internal use only. */
Nvoid vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet ) PRIVILEGED_FUNCTION;
Xvoid vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet ) ;
Nvoid vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear ) PRIVILEGED_FUNCTION;
Xvoid vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear ) ;
N
N#if (configUSE_TRACE_FACILITY == 1)
X#if (0 == 1)
S	UBaseType_t uxEventGroupGetNumber( void* xEventGroup ) PRIVILEGED_FUNCTION;
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* EVENT_GROUPS_H */
N
N
L 112 "..\..\..\ZR60_v1.0_freeRTOS\Include.h" 2
N
N/*******************************************************
Ndescription锛macro definitions
N*******************************************************/
N/**********瀹寮冲涔*******/
N
N/*******************************************************
Ndescription：Often use of macro definitions
N*******************************************************/
N/***********瀹芥*********/
N
N#ifdef UART_DEBUG
N#define USART_PRINTF_S(x)   	 printf("%s\n",x)
N#define USART_PRINTF_D(x,d)   	 printf(x,d)
N#define USART_PRINTF_CARD_NUM(x,d1,d2,d3,d4)    	printf(x,d1,d2,d3,d4)
N#define USART_PRINTF_IP(x,d1,d2,d3,d4)    			printf(x,d1,d2,d3,d4)
N#define USART_PRINTF_MAC(x,d1,d2,d3,d4,d5,d6)    	printf(x,d1,d2,d3,d4,d5,d6)
N#define USART_PRINTF_DATE(x,d1,d2,d3,d4,d5,d6)   	printf(x,d1,d2,d3,d4,d5,d6)
N#else
S#define USART_PRINTF_S(x)    
S#define USART_PRINTF_D(x,d)  
S#define USART_PRINTF_CARD_NUM(x,d1,d2,d3,d4)
S#define USART_PRINTF_IP(x,d1,d2,d3,d4)
S#define USART_PRINTF_MAC(x,d1,d2,d3,d4,d5,d6)
S#define USART_PRINTF_DATE(x,d1,d2,d3,d4,d5,d6)
N#endif
N
N
N/*******************************************************
Ndescription锛struct definitions
N*******************************************************/
N
N/*******************************************************
Ndescription锛typedef definitions
N*******************************************************/
N/*****struct definitions*****/
N
N/******enum definitions******/
N
N/******union definitions*****/
N
N/*******************************************************
Ndescription锛variable External declaration
N*******************************************************/
N//extern uint16 Vemain_w_5msTskTimer;
N
N/*******************************************************
Ndescription锛function External declaration
N*******************************************************/
N
N#endif
L 15 "..\..\Lwip\App\dnsAnalysis.h" 2
N
N/*******************************************************
Ndescription： macro definitions
N*******************************************************/
N/**********宏开关定义*********/
N
N/**********宏常量定义*********/
N#define DNS_ANALYSIS_TASK_PERIOD   5000U//大概30s
N
N
N#ifdef USE_DHCP
N#define DNS_DHCP_STATE    DHCP_state
N#else
S#define DNS_DHCP_STATE    DHCP_ADDRESS_ASSIGNED
N#endif
N/***********宏函数***********/
N
N
N/*******************************************************
Ndescription： struct definitions
N*******************************************************/
N
N/*******************************************************
Ndescription： typedef definitions
N*******************************************************/
N/*****struct definitions*****/
Ntypedef struct
N{
N	char* name;
N}dnsAnalysis_Struct;
N
N/******enum definitions******/
Ntypedef enum
N{
N	ShortConnect = 0U,	  /*短连接*/
N	LngConnect,	  /*长连接*/
N	ntp_one,	  /*ntp服务器*/
N	ntp_two,	  /*ntp服务器*/
N	ntp_three,	  /*ntp服务器*/
N	ntp_four,	  /*ntp服务器*/
N	ntp_five,	  /*ntp服务器*/
N	ntp_six,	  /*ntp服务器*/
N	http_download,	  /*http文件下载服务器*/
N	//ntp_eight,	  /*ntp服务器*/
N	domainNum
N}dnsAnalysis_Enum;
N/******union definitions*****/
N
N/*******************************************************
Ndescription： variable External declaration
N*******************************************************/
N
N
N
N/*******************************************************
Ndescription： function External declaration
N*******************************************************/
Nextern void InitdnsAnalysis_parameter(void);
Nextern void TskdnsAnalysis_MainFunction(void);
Nextern void GetdnsAnalysis_ipAddr(uint8 index, struct ip_addr *ipaddr);
Nextern uint8 GetdnsAnalysis_u_ipValidity(uint8 index);
Nextern void SetdnsAnalysis_ipUpdate(uint8 index);
N#endif 
L 13 "..\..\Lwip\App\dnsAnalysis.c" 2
N
N/*******************************************************
Ndescription： global variable definitions
N*******************************************************/
N
N/*******************************************************
Ndescription： static variable definitions
N*******************************************************/
Nstatic struct ip_addr SednsAnalysis_dw_DestIPaddr[domainNum];//目的ip
Nstatic uint8  SednsAnalysis_u_Validity[domainNum];//ip有效性
Nstatic uint8  SednsAnalysis_u_UpdateFlag;//ip更新标志，便于实时更新ip
Nstatic uint8  SednsAnalysis_u_UpdateHost[domainNum];//待更新ip的主机
Nstatic uint16 SednsAnalysis_w_Timer;//计时器
Nstatic char Se_u_arg[domainNum];
Nstatic char short_hostname[]="api.zzwtec.com";//短连接主机域名
Nstatic char lng_hostname[]="push2.zzwtec.com";//长连接主机域名
Nstatic char ntp_one_hostname[]="ntp1.aliyun.com";//ntp主机域名
Nstatic char ntp_two_hostname[]="time1.aliyun.com";//ntp主机域名
Nstatic char ntp_three_hostname[]="time.syn029.com";//ntp主机域名
Nstatic char ntp_four_hostname[]="ntp.shu.edu.cn";//ntp主机域名
Nstatic char ntp_five_hostname[]="s2f.time.edu.cn";//ntp主机域名
Nstatic char ntp_six_hostname[]="1.cn.pool.ntp.org";//ntp主机域名
Nstatic char http_download_hostname[]="mobile.zzwtec.com";//http文件下载服务器
N//static char ntp_eight_hostname[]="time3.aliyun.com";//ntp主机域名
N
NdnsAnalysis_Struct  domain[domainNum] = 
N{
N	short_hostname,
N	lng_hostname,
N	ntp_one_hostname,
N	ntp_two_hostname,
N	ntp_three_hostname,
N	ntp_four_hostname,
N	ntp_five_hostname,
N	ntp_six_hostname,
N	http_download_hostname
N	//ntp_eight_hostname
N};
N/*******************************************************
Ndescription： function declaration
N*******************************************************/
N/*Global function declaration*/
N
N/*Static function declaration*/
Nstatic void dnsAnalysis_DNSfound(const char *name, struct ip_addr *ipaddr, void *arg);
N
N
N/******************************************************
Ndescription： function code
N******************************************************/
N/******************************************************
N*函数名：InitdnsAnalysis_parameter
N
N*形  参：void
N
N*返回值：void
N
N*描  述：初始化
N
N*备  注：
N******************************************************/
Nvoid InitdnsAnalysis_parameter(void)
N{
N	char Le_u_i;
N	for(Le_u_i = 0U;Le_u_i < domainNum;Le_u_i++)
N	{
N		SednsAnalysis_u_Validity[Le_u_i] = 0U;
N		Se_u_arg[Le_u_i] = Le_u_i;
N		SednsAnalysis_u_UpdateHost[Le_u_i] = 1U;
N	}
N	SednsAnalysis_w_Timer = DNS_ANALYSIS_TASK_PERIOD - 1100U;
X	SednsAnalysis_w_Timer = 5000U - 1100U;
N	SednsAnalysis_u_UpdateFlag = 0U;
N}
N
N/******************************************************
N*函数名：TskdnsAnalysis_MainFunction
N
N*形  参：
N
N*返回值：
N
N*描  述：域名解析主任务,5ms周期调用
N
N*备  注：
N******************************************************/
Nvoid TskdnsAnalysis_MainFunction(void)
N{
N	struct ip_addr IPaddr[domainNum];
N	char Le_u_i;
N
N	if(GET_PHY_LINK_STATUS() && (DHCP_ADDRESS_ASSIGNED == DNS_DHCP_STATE))/* Get Ethernet link status*/
X	if((ETH_ReadPHYRegister(0x00, 1) & 0x00000004) && (3 == DHCP_state)) 
N	{
N		if((SednsAnalysis_w_Timer >= DNS_ANALYSIS_TASK_PERIOD) || (SednsAnalysis_u_UpdateFlag == 1U))
X		if((SednsAnalysis_w_Timer >= 5000U) || (SednsAnalysis_u_UpdateFlag == 1U))
N		{
N			SednsAnalysis_w_Timer = 0U;
N			SednsAnalysis_u_UpdateFlag = 0U;//ip更新标志
N			for(Le_u_i = 0U;Le_u_i < domainNum;Le_u_i++)
N			{
N				if(SednsAnalysis_u_UpdateHost[Le_u_i] == 1U)
N				{
N					USART_PRINTF_D("%d DNS域名开始解析\n",Le_u_i);
X					printf("%d DNS域名开始解析\n",Le_u_i);
N					dns_gethostbyname(domain[Le_u_i].name,&IPaddr[Le_u_i],&dnsAnalysis_DNSfound,&Se_u_arg[Le_u_i]);//域名解析	
N				}
N			}
N		}
N		else
N		{
N			SednsAnalysis_w_Timer++;
N		}
N	}
N}
N
N/******************************************************
N*函数名：GetdnsAnalysis_ipAddr
N
N*形  参：void
N
N*返回值：void
N
N*描  述：获取dns解析后的ip
N
N*备  注：
N******************************************************/
Nvoid GetdnsAnalysis_ipAddr(uint8 index, struct ip_addr *ipaddr)
N{
N	ipaddr->addr = SednsAnalysis_dw_DestIPaddr[index].addr;
N}
N
N
N/******************************************************
N*函数名：dnsAnalysis_DNSfound
N
N*形  参：
N
N*返回值：void
N
N*描  述：dns解析完成回调函数
N
N*备  注：
N******************************************************/
Nstatic void dnsAnalysis_DNSfound(const char *name, struct ip_addr *ipaddr, void *arg)
N{
N	char Le_u_obj;
N	Le_u_obj = *((char*)arg);
N	if(ipaddr != NULL)
X	if(ipaddr != 0)
N	{
N		if(ipaddr->addr == 0)
N		{
N			//SednsAnalysis_u_Validity[Le_u_obj] = 0U;
N			SednsAnalysis_u_UpdateHost[Le_u_obj] = 1U;
N			USART_PRINTF_D("%d DNS域名解析失败,ip地址:0.0.0.0 ",Le_u_obj);
X			printf("%d DNS域名解析失败,ip地址:0.0.0.0 ",Le_u_obj);
N		}
N		else
N		{
N			SednsAnalysis_u_Validity[Le_u_obj] = 1U;
N			SednsAnalysis_u_UpdateHost[Le_u_obj] = 0U;
N			SednsAnalysis_dw_DestIPaddr[Le_u_obj].addr = ipaddr->addr;
N			USART_PRINTF_D("%d DNS域名解析成功,ip地址: ",Le_u_obj);
X			printf("%d DNS域名解析成功,ip地址: ",Le_u_obj);
N			USART_PRINTF_IP("%u.%u.%u.%u\n",(uint8_t)SednsAnalysis_dw_DestIPaddr[Le_u_obj].addr, \
N							(uint8_t)(SednsAnalysis_dw_DestIPaddr[Le_u_obj].addr >> 8),	\
N							(uint8_t)(SednsAnalysis_dw_DestIPaddr[Le_u_obj].addr >> 16),	\
N							(uint8_t)(SednsAnalysis_dw_DestIPaddr[Le_u_obj].addr >> 24));
X			printf("%u.%u.%u.%u\n",(uint8_t)SednsAnalysis_dw_DestIPaddr[Le_u_obj]. addr,(uint8_t)(SednsAnalysis_dw_DestIPaddr[Le_u_obj]. addr >> 8),(uint8_t)(SednsAnalysis_dw_DestIPaddr[Le_u_obj]. addr >> 16),(uint8_t)(SednsAnalysis_dw_DestIPaddr[Le_u_obj]. addr >> 24));
N		}
N	}
N	else
N	{
N		//SednsAnalysis_u_Validity[Le_u_obj] = 0U;
N		SednsAnalysis_u_UpdateHost[Le_u_obj] = 1U;
N		USART_PRINTF_D("%d DNS域名解析失败",Le_u_obj);
X		printf("%d DNS域名解析失败",Le_u_obj);
N	}
N}
N
N
N/******************************************************
N*函数名：GetdnsAnalysis_u_ipValidity
N
N*形  参：void
N
N*返回值：void
N
N*描  述：获取dns解析后的ip有效性
N
N*备  注：
N******************************************************/
Nuint8 GetdnsAnalysis_u_ipValidity(uint8 index)
N{
N	return SednsAnalysis_u_Validity[index];
N}
N
N
N/******************************************************
N*函数名：SetdnsAnalysis_ipUpdate
N
N*形  参：void
N
N*返回值：void
N
N*描  述：更新ip
N
N*备  注：
N******************************************************/
Nvoid SetdnsAnalysis_ipUpdate(uint8 index)
N{
N	SednsAnalysis_u_UpdateHost[index] = 1U;
N	SednsAnalysis_u_UpdateFlag = 1U;//ip更新标志
N}
N

; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\tcp_in.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\tcp_in.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\ZR60_v1.0_freeRTOS -I..\..\Lwip\App -I..\..\Lwip\Bsp -I..\..\Lwip\Bsp\LAN8742A -I..\..\Lwip\lwip-1.4.1 -I..\..\Lwip\lwip-1.4.1\port -I..\..\Lwip\lwip-1.4.1\port\arch -I..\..\Lwip\lwip-1.4.1\port\Standalone -I..\..\Lwip\lwip-1.4.1\src\include -I..\..\Lwip\lwip-1.4.1\src\include\ipv4 -I..\..\Lwip\lwip-1.4.1\src\include\lwip -I..\..\Lwip\lwip-1.4.1\src\include\netif -I..\..\Ecal\BtnFltr -I..\..\Ecal\UartComn -I..\..\Ecal\MemIf -I..\..\APP -I..\..\APP\BlackListMng -I..\..\APP\SeverNewsPush -I..\..\APP\NewsPull -I..\..\Ecal -I..\..\Ecal\JsonIf -I..\..\Ecal\Mcu_Init -I..\..\Service -I..\..\Complex -I..\..\Complex\FATFS -I..\..\FreeRTOS\Source\include -I..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\FreeRTOS -I.\RTE\_ZR60 -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=..\..\output\tcp_in.crf ..\..\Lwip\lwip-1.4.1\src\core\tcp_in.c]
                          THUMB

                          AREA ||i.tcp_input||, CODE, READONLY, ALIGN=2

                  tcp_input PROC
;;;91     void
;;;92     tcp_input(struct pbuf *p, struct netif *inp)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;93     {
000004  4605              MOV      r5,r0
;;;94       struct tcp_pcb *pcb, *prev;
;;;95       struct tcp_pcb_listen *lpcb;
;;;96     #if SO_REUSE
;;;97       struct tcp_pcb *lpcb_prev = NULL;
;;;98       struct tcp_pcb_listen *lpcb_any = NULL;
;;;99     #endif /* SO_REUSE */
;;;100      u8_t hdrlen;
;;;101      err_t err;
;;;102    
;;;103      PERF_START;
;;;104    
;;;105      TCP_STATS_INC(tcp.recv);
;;;106      snmp_inc_tcpinsegs();
;;;107    
;;;108      iphdr = (struct ip_hdr *)p->payload;
000006  4ed4              LDR      r6,|L1.856|
000008  6840              LDR      r0,[r0,#4]
00000a  460c              MOV      r4,r1                 ;93
;;;109      tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
00000c  60b0              STR      r0,[r6,#8]  ; iphdr
00000e  7801              LDRB     r1,[r0,#0]
000010  f001010f          AND      r1,r1,#0xf
000014  eb000081          ADD      r0,r0,r1,LSL #2
;;;110    
;;;111    #if TCP_INPUT_DEBUG
;;;112      tcp_debug_print(tcphdr);
;;;113    #endif
;;;114    
;;;115      /* remove header from payload */
;;;116      if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
000018  6070              STR      r0,[r6,#4]  ; tcphdr
00001a  0088              LSLS     r0,r1,#2
00001c  4241              RSBS     r1,r0,#0
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       pbuf_header
000024  2800              CMP      r0,#0
                  |L1.38|
000026  d17a              BNE      |L1.286|
000028  8928              LDRH     r0,[r5,#8]
00002a  2814              CMP      r0,#0x14
00002c  d377              BCC      |L1.286|
;;;117        /* drop short packets */
;;;118        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
;;;119        TCP_STATS_INC(tcp.lenerr);
;;;120        goto dropped;
;;;121      }
;;;122    
;;;123      /* Don't even process incoming broadcasts/multicasts. */
;;;124      if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
00002e  f8df832c          LDR      r8,|L1.860|
000032  4621              MOV      r1,r4
000034  f8d80000          LDR      r0,[r8,#0]  ; current_iphdr_dest
000038  f7fffffe          BL       ip4_addr_isbroadcast
00003c  2800              CMP      r0,#0
00003e  d1f2              BNE      |L1.38|
;;;125          ip_addr_ismulticast(&current_iphdr_dest)) {
000040  f8980000          LDRB     r0,[r8,#0]  ; current_iphdr_dest
000044  f3c01003          UBFX     r0,r0,#4,#4
000048  280e              CMP      r0,#0xe
00004a  d068              BEQ      |L1.286|
;;;126        TCP_STATS_INC(tcp.proterr);
;;;127        goto dropped;
;;;128      }
;;;129    
;;;130    #if CHECKSUM_CHECK_TCP
;;;131      /* Verify TCP checksum. */
;;;132      if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
;;;133          IP_PROTO_TCP, p->tot_len) != 0) {
;;;134          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packet discarded due to failing checksum 0x%04"X16_F"\n",
;;;135            inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
;;;136          IP_PROTO_TCP, p->tot_len)));
;;;137    #if TCP_DEBUG
;;;138        tcp_debug_print(tcphdr);
;;;139    #endif /* TCP_DEBUG */
;;;140        TCP_STATS_INC(tcp.chkerr);
;;;141        goto dropped;
;;;142      }
;;;143    #endif
;;;144    
;;;145      /* Move the payload pointer in the pbuf so that it points to the
;;;146         TCP data instead of the TCP header. */
;;;147      hdrlen = TCPH_HDRLEN(tcphdr);
00004c  6870              LDR      r0,[r6,#4]  ; tcphdr
00004e  8980              LDRH     r0,[r0,#0xc]
000050  f7fffffe          BL       lwip_ntohs
000054  0b00              LSRS     r0,r0,#12
;;;148      if(pbuf_header(p, -(hdrlen * 4))){
000056  0080              LSLS     r0,r0,#2
000058  4241              RSBS     r1,r0,#0
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       pbuf_header
000060  2800              CMP      r0,#0
000062  d1e0              BNE      |L1.38|
;;;149        /* drop short packets */
;;;150        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
;;;151        TCP_STATS_INC(tcp.lenerr);
;;;152        goto dropped;
;;;153      }
;;;154    
;;;155      /* Convert fields in TCP header to host byte order. */
;;;156      tcphdr->src = ntohs(tcphdr->src);
000064  6870              LDR      r0,[r6,#4]  ; tcphdr
000066  8800              LDRH     r0,[r0,#0]
000068  f7fffffe          BL       lwip_ntohs
00006c  4601              MOV      r1,r0
00006e  6870              LDR      r0,[r6,#4]  ; tcphdr
000070  8001              STRH     r1,[r0,#0]
;;;157      tcphdr->dest = ntohs(tcphdr->dest);
000072  8840              LDRH     r0,[r0,#2]
000074  f7fffffe          BL       lwip_ntohs
000078  4601              MOV      r1,r0
00007a  6870              LDR      r0,[r6,#4]  ; tcphdr
00007c  8041              STRH     r1,[r0,#2]
;;;158      seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
00007e  6840              LDR      r0,[r0,#4]
000080  f7fffffe          BL       lwip_ntohl
000084  4601              MOV      r1,r0
000086  6870              LDR      r0,[r6,#4]  ; tcphdr
000088  6041              STR      r1,[r0,#4]
;;;159      ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
00008a  60f1              STR      r1,[r6,#0xc]  ; seqno
00008c  6880              LDR      r0,[r0,#8]
00008e  f7fffffe          BL       lwip_ntohl
000092  4601              MOV      r1,r0
000094  6870              LDR      r0,[r6,#4]  ; tcphdr
000096  6081              STR      r1,[r0,#8]
;;;160      tcphdr->wnd = ntohs(tcphdr->wnd);
000098  6131              STR      r1,[r6,#0x10]  ; ackno
00009a  89c0              LDRH     r0,[r0,#0xe]
00009c  f7fffffe          BL       lwip_ntohs
0000a0  4601              MOV      r1,r0
0000a2  6870              LDR      r0,[r6,#4]  ; tcphdr
0000a4  81c1              STRH     r1,[r0,#0xe]
;;;161    
;;;162      flags = TCPH_FLAGS(tcphdr);
0000a6  8980              LDRH     r0,[r0,#0xc]
0000a8  f7fffffe          BL       lwip_ntohs
0000ac  f000003f          AND      r0,r0,#0x3f
0000b0  7030              STRB     r0,[r6,#0]
;;;163      tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
0000b2  8929              LDRH     r1,[r5,#8]
0000b4  0780              LSLS     r0,r0,#30
0000b6  d000              BEQ      |L1.186|
0000b8  2001              MOVS     r0,#1
                  |L1.186|
;;;164    
;;;165      /* Demultiplex an incoming segment. First, we check if it is destined
;;;166         for an active connection. */
;;;167      prev = NULL;
;;;168    
;;;169      
;;;170      for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
0000ba  f8dfa2a4          LDR      r10,|L1.864|
0000be  4408              ADD      r0,r0,r1              ;163
0000c0  8070              STRH     r0,[r6,#2]            ;163
0000c2  2700              MOVS     r7,#0                 ;167
;;;171        LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
;;;172        LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
;;;173        LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
;;;174        if (pcb->remote_port == tcphdr->src &&
;;;175           pcb->local_port == tcphdr->dest &&
;;;176           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
0000c4  f8df929c          LDR      r9,|L1.868|
0000c8  f8da4000          LDR      r4,[r10,#0]           ;170  ; tcp_active_pcbs
0000cc  e03d              B        |L1.330|
                  |L1.206|
0000ce  7e20              LDRB     r0,[r4,#0x18]         ;171
0000d0  b910              CBNZ     r0,|L1.216|
0000d2  a0a5              ADR      r0,|L1.872|
0000d4  f7fffffe          BL       __2printf
                  |L1.216|
0000d8  7e20              LDRB     r0,[r4,#0x18]         ;172
0000da  280a              CMP      r0,#0xa               ;172
0000dc  d102              BNE      |L1.228|
0000de  a0ac              ADR      r0,|L1.912|
0000e0  f7fffffe          BL       __2printf
                  |L1.228|
0000e4  7e20              LDRB     r0,[r4,#0x18]         ;173
0000e6  2801              CMP      r0,#1                 ;173
0000e8  d102              BNE      |L1.240|
0000ea  a0b4              ADR      r0,|L1.956|
0000ec  f7fffffe          BL       __2printf
                  |L1.240|
0000f0  6870              LDR      r0,[r6,#4]            ;174  ; tcphdr
0000f2  8ba1              LDRH     r1,[r4,#0x1c]         ;174
0000f4  8802              LDRH     r2,[r0,#0]            ;174
0000f6  4291              CMP      r1,r2                 ;174
0000f8  d125              BNE      |L1.326|
0000fa  8b61              LDRH     r1,[r4,#0x1a]         ;175
0000fc  8840              LDRH     r0,[r0,#2]            ;175
0000fe  4281              CMP      r1,r0                 ;175
000100  d121              BNE      |L1.326|
000102  6861              LDR      r1,[r4,#4]
000104  f8d90000          LDR      r0,[r9,#0]  ; current_iphdr_src
000108  4281              CMP      r1,r0
00010a  d11c              BNE      |L1.326|
;;;177           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
00010c  6821              LDR      r1,[r4,#0]
00010e  f8d80000          LDR      r0,[r8,#0]  ; current_iphdr_dest
000112  4281              CMP      r1,r0
000114  d117              BNE      |L1.326|
;;;178    
;;;179          /* Move this PCB to the front of the list so that subsequent
;;;180             lookups will be faster (we exploit locality in TCP segment
;;;181             arrivals). */
;;;182          LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
000116  68e0              LDR      r0,[r4,#0xc]
000118  42a0              CMP      r0,r4
00011a  d104              BNE      |L1.294|
00011c  e000              B        |L1.288|
                  |L1.286|
00011e  e115              B        |L1.844|
                  |L1.288|
000120  a0b0              ADR      r0,|L1.996|
000122  f7fffffe          BL       __2printf
                  |L1.294|
;;;183          if (prev != NULL) {
000126  b137              CBZ      r7,|L1.310|
;;;184            prev->next = pcb->next;
000128  68e0              LDR      r0,[r4,#0xc]
;;;185            pcb->next = tcp_active_pcbs;
00012a  60f8              STR      r0,[r7,#0xc]
00012c  f8da1000          LDR      r1,[r10,#0]  ; tcp_active_pcbs
;;;186            tcp_active_pcbs = pcb;
000130  60e1              STR      r1,[r4,#0xc]
000132  f8ca4000          STR      r4,[r10,#0]  ; tcp_active_pcbs
                  |L1.310|
;;;187          }
;;;188          LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
000136  68e0              LDR      r0,[r4,#0xc]
000138  42a0              CMP      r0,r4
00013a  d102              BNE      |L1.322|
00013c  a0b4              ADR      r0,|L1.1040|
00013e  f7fffffe          BL       __2printf
                  |L1.322|
;;;189          break;
;;;190        }
;;;191        prev = pcb;
;;;192      }
;;;193    
;;;194      if (pcb == NULL) {
000142  b124              CBZ      r4,|L1.334|
000144  e04b              B        |L1.478|
                  |L1.326|
000146  4627              MOV      r7,r4                 ;191
000148  68e4              LDR      r4,[r4,#0xc]          ;170
                  |L1.330|
00014a  2c00              CMP      r4,#0                 ;170
00014c  d1bf              BNE      |L1.206|
                  |L1.334|
;;;195        /* If it did not go to an active connection, we check the connections
;;;196           in the TIME-WAIT state. */
;;;197        for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
00014e  48bb              LDR      r0,|L1.1084|
000150  4647              MOV      r7,r8                 ;124
000152  6804              LDR      r4,[r0,#0]  ; tcp_tw_pcbs
000154  e01c              B        |L1.400|
                  |L1.342|
;;;198          LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
000156  7e20              LDRB     r0,[r4,#0x18]
000158  280a              CMP      r0,#0xa
00015a  d002              BEQ      |L1.354|
00015c  a0b8              ADR      r0,|L1.1088|
00015e  f7fffffe          BL       __2printf
                  |L1.354|
;;;199          if (pcb->remote_port == tcphdr->src &&
000162  6870              LDR      r0,[r6,#4]  ; tcphdr
000164  8ba1              LDRH     r1,[r4,#0x1c]
000166  8802              LDRH     r2,[r0,#0]
000168  4291              CMP      r1,r2
00016a  d110              BNE      |L1.398|
;;;200             pcb->local_port == tcphdr->dest &&
00016c  8b61              LDRH     r1,[r4,#0x1a]
00016e  8840              LDRH     r0,[r0,#2]
000170  4281              CMP      r1,r0
000172  d10c              BNE      |L1.398|
;;;201             ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
000174  6861              LDR      r1,[r4,#4]
000176  f8d90000          LDR      r0,[r9,#0]  ; current_iphdr_src
00017a  4281              CMP      r1,r0
00017c  d107              BNE      |L1.398|
;;;202             ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
00017e  6820              LDR      r0,[r4,#0]
000180  6839              LDR      r1,[r7,#0]  ; current_iphdr_dest
000182  4288              CMP      r0,r1
000184  d103              BNE      |L1.398|
;;;203            /* We don't really care enough to move this PCB to the front
;;;204               of the list since we are not very likely to receive that
;;;205               many segments for connections in TIME-WAIT. */
;;;206            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
;;;207            tcp_timewait_input(pcb);
000186  4620              MOV      r0,r4
000188  f7fffffe          BL       tcp_timewait_input
;;;208            pbuf_free(p);
;;;209            return;
00018c  e0de              B        |L1.844|
                  |L1.398|
00018e  68e4              LDR      r4,[r4,#0xc]          ;197
                  |L1.400|
000190  2c00              CMP      r4,#0                 ;197
000192  d1e0              BNE      |L1.342|
;;;210          }
;;;211        }
;;;212    
;;;213        /* Finally, if we still did not get a match, we check all PCBs that
;;;214           are LISTENing for incoming connections. */
;;;215        prev = NULL;
;;;216        for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
000194  f8df92d8          LDR      r9,|L1.1136|
000198  2200              MOVS     r2,#0                 ;215
00019a  6873              LDR      r3,[r6,#4]            ;124
00019c  f8d90000          LDR      r0,[r9,#0]  ; tcp_listen_pcbs
0001a0  683f              LDR      r7,[r7,#0]            ;124
0001a2  4684              MOV      r12,r0
0001a4  e00b              B        |L1.446|
                  |L1.422|
;;;217          if (lpcb->local_port == tcphdr->dest) {
0001a6  8b41              LDRH     r1,[r0,#0x1a]
0001a8  f8b38002          LDRH     r8,[r3,#2]
0001ac  4541              CMP      r1,r8
0001ae  d104              BNE      |L1.442|
;;;218    #if SO_REUSE
;;;219            if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest)) {
;;;220              /* found an exact match */
;;;221              break;
;;;222            } else if(ip_addr_isany(&(lpcb->local_ip))) {
;;;223              /* found an ANY-match */
;;;224              lpcb_any = lpcb;
;;;225              lpcb_prev = prev;
;;;226            }
;;;227    #else /* SO_REUSE */
;;;228            if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
0001b0  6801              LDR      r1,[r0,#0]
0001b2  42b9              CMP      r1,r7
0001b4  d006              BEQ      |L1.452|
;;;229                ip_addr_isany(&(lpcb->local_ip))) {
0001b6  b180              CBZ      r0,|L1.474|
0001b8  b129              CBZ      r1,|L1.454|
                  |L1.442|
;;;230              /* found a match */
;;;231              break;
;;;232            }
;;;233    #endif /* SO_REUSE */
;;;234          }
;;;235          prev = (struct tcp_pcb *)lpcb;
0001ba  4602              MOV      r2,r0
0001bc  68c0              LDR      r0,[r0,#0xc]          ;216
                  |L1.446|
0001be  2800              CMP      r0,#0                 ;216
0001c0  d1f1              BNE      |L1.422|
0001c2  e00a              B        |L1.474|
                  |L1.452|
;;;236        }
;;;237    #if SO_REUSE
;;;238        /* first try specific local IP */
;;;239        if (lpcb == NULL) {
;;;240          /* only pass to ANY if no specific local IP has been found */
;;;241          lpcb = lpcb_any;
;;;242          prev = lpcb_prev;
;;;243        }
;;;244    #endif /* SO_REUSE */
;;;245        if (lpcb != NULL) {
0001c4  b148              CBZ      r0,|L1.474|
                  |L1.454|
;;;246          /* Move this PCB to the front of the list so that subsequent
;;;247             lookups will be faster (we exploit locality in TCP segment
;;;248             arrivals). */
;;;249          if (prev != NULL) {
0001c6  b12a              CBZ      r2,|L1.468|
;;;250            ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
0001c8  68c1              LDR      r1,[r0,#0xc]
;;;251                  /* our successor is the remainder of the listening list */
;;;252            lpcb->next = tcp_listen_pcbs.listen_pcbs;
0001ca  60d1              STR      r1,[r2,#0xc]
;;;253                  /* put this listening pcb at the head of the listening list */
;;;254            tcp_listen_pcbs.listen_pcbs = lpcb;
0001cc  f8c0c00c          STR      r12,[r0,#0xc]
0001d0  f8c90000          STR      r0,[r9,#0]  ; tcp_listen_pcbs
                  |L1.468|
;;;255          }
;;;256        
;;;257          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
;;;258          tcp_listen_input(lpcb);
0001d4  f7fffffe          BL       tcp_listen_input
;;;259          pbuf_free(p);
;;;260          return;
0001d8  e0b8              B        |L1.844|
                  |L1.474|
;;;261        }
;;;262      }
;;;263    
;;;264    #if TCP_INPUT_DEBUG
;;;265      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("+-+-+-+-+-+-+-+-+-+-+-+-+-+- tcp_input: flags "));
;;;266      tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
;;;267      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
;;;268    #endif /* TCP_INPUT_DEBUG */
;;;269    
;;;270    
;;;271      if (pcb != NULL) {
0001da  2c00              CMP      r4,#0
0001dc  d07d              BEQ      |L1.730|
                  |L1.478|
;;;272        /* The incoming segment belongs to a connection. */
;;;273    #if TCP_INPUT_DEBUG
;;;274    #if TCP_DEBUG
;;;275        tcp_debug_print_state(pcb->state);
;;;276    #endif /* TCP_DEBUG */
;;;277    #endif /* TCP_INPUT_DEBUG */
;;;278    
;;;279        /* Set up a tcp_seg structure. */
;;;280        inseg.next = NULL;
0001de  f8df8294          LDR      r8,|L1.1140|
0001e2  2700              MOVS     r7,#0
;;;281        inseg.len = p->tot_len;
0001e4  f8c87000          STR      r7,[r8,#0]  ; inseg
0001e8  8929              LDRH     r1,[r5,#8]
0001ea  f8a81008          STRH     r1,[r8,#8]
;;;282        inseg.p = p;
;;;283        inseg.tcphdr = tcphdr;
0001ee  f8c85004          STR      r5,[r8,#4]  ; inseg
0001f2  6871              LDR      r1,[r6,#4]  ; tcphdr
;;;284    
;;;285        recv_data = NULL;
0001f4  f8c8100c          STR      r1,[r8,#0xc]  ; inseg
;;;286        recv_flags = 0;
0001f8  6177              STR      r7,[r6,#0x14]  ; recv_data
0001fa  7077              STRB     r7,[r6,#1]
;;;287    
;;;288        if (flags & TCP_PSH) {
0001fc  7830              LDRB     r0,[r6,#0]  ; flags
0001fe  0700              LSLS     r0,r0,#28
000200  d503              BPL      |L1.522|
;;;289          p->flags |= PBUF_FLAG_PUSH;
000202  7b68              LDRB     r0,[r5,#0xd]
000204  f0400001          ORR      r0,r0,#1
000208  7368              STRB     r0,[r5,#0xd]
                  |L1.522|
;;;290        }
;;;291    
;;;292        /* If there is data which was previously "refused" by upper layer */
;;;293        if (pcb->refused_data != NULL) {
00020a  6fa0              LDR      r0,[r4,#0x78]
00020c  b140              CBZ      r0,|L1.544|
;;;294          if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
00020e  4620              MOV      r0,r4
000210  f7fffffe          BL       tcp_process_refused_data
000214  300a              ADDS     r0,r0,#0xa
000216  d07b              BEQ      |L1.784|
;;;295            ((pcb->refused_data != NULL) && (tcplen > 0))) {
000218  6fa0              LDR      r0,[r4,#0x78]
00021a  b108              CBZ      r0,|L1.544|
00021c  8870              LDRH     r0,[r6,#2]  ; tcplen
00021e  bb18              CBNZ     r0,|L1.616|
                  |L1.544|
;;;296            /* pcb has been aborted or refused data is still refused and the new
;;;297               segment contains data */
;;;298            TCP_STATS_INC(tcp.drop);
;;;299            snmp_inc_tcpinerrs();
;;;300            goto aborted;
;;;301          }
;;;302        }
;;;303        tcp_input_pcb = pcb;
;;;304        err = tcp_process(pcb);
000220  4620              MOV      r0,r4
000222  61b4              STR      r4,[r6,#0x18]  ; tcp_input_pcb
000224  f7fffffe          BL       tcp_process
000228  300a              ADDS     r0,r0,#0xa
;;;305        /* A return value of ERR_ABRT means that tcp_abort() was called
;;;306           and that the pcb has been freed. If so, we don't do anything. */
;;;307        if (err != ERR_ABRT) {
00022a  d071              BEQ      |L1.784|
;;;308          if (recv_flags & TF_RESET) {
00022c  7870              LDRB     r0,[r6,#1]  ; recv_flags
00022e  0701              LSLS     r1,r0,#28
000230  d506              BPL      |L1.576|
;;;309            /* TF_RESET means that the connection was reset by the other
;;;310               end. We then call the error callback to inform the
;;;311               application that the connection is dead before we
;;;312               deallocate the PCB. */
;;;313            TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
000232  f8d4208c          LDR      r2,[r4,#0x8c]
000236  b17a              CBZ      r2,|L1.600|
000238  f06f010a          MVN      r1,#0xa
00023c  6920              LDR      r0,[r4,#0x10]
00023e  e00a              B        |L1.598|
                  |L1.576|
;;;314            tcp_pcb_remove(&tcp_active_pcbs, pcb);
;;;315    		TCP_DEBUG_USART_PRINTF_S("(recv_flags & TF_RESET) -->tcp_pcb_remove(&tcp_active_pcbs, pcb)");
;;;316            memp_free(MEMP_TCP_PCB, pcb);
;;;317    		TCP_DEBUG_USART_PRINTF_S("(recv_flags & TF_RESET) -->memp_free(MEMP_TCP_PCB, pcb);\n");
;;;318          } else if (recv_flags & TF_CLOSED) {
000240  06c0              LSLS     r0,r0,#27
000242  d512              BPL      |L1.618|
;;;319            /* The connection has been closed and we will deallocate the
;;;320               PCB. */
;;;321            if (!(pcb->flags & TF_RXCLOSED)) 
000244  7fa0              LDRB     r0,[r4,#0x1e]
000246  06c0              LSLS     r0,r0,#27
000248  d406              BMI      |L1.600|
;;;322    		{
;;;323              /* Connection closed although the application has only shut down the
;;;324                 tx side: call the PCB's err callback and indicate the closure to
;;;325                 ensure the application doesn't continue using the PCB. */
;;;326              TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
00024a  f8d4208c          LDR      r2,[r4,#0x8c]
00024e  b11a              CBZ      r2,|L1.600|
000250  f06f010b          MVN      r1,#0xb
000254  6920              LDR      r0,[r4,#0x10]
                  |L1.598|
000256  4790              BLX      r2                    ;313
                  |L1.600|
;;;327            }
;;;328            tcp_pcb_remove(&tcp_active_pcbs, pcb);
000258  4621              MOV      r1,r4
00025a  4841              LDR      r0,|L1.864|
00025c  f7fffffe          BL       tcp_pcb_remove
;;;329            memp_free(MEMP_TCP_PCB, pcb);
000260  4621              MOV      r1,r4
000262  2002              MOVS     r0,#2
000264  f7fffffe          BL       memp_free
                  |L1.616|
000268  e052              B        |L1.784|
                  |L1.618|
;;;330    		TCP_DEBUG_USART_PRINTF_S("(recv_flags & TF_CLOSED) -->tcp_pcb_remove(&tcp_active_pcbs, pcb)");
;;;331    		TCP_DEBUG_USART_PRINTF_S("(recv_flags & TF_CLOSED) --> memp_free(MEMP_TCP_PCB, pcb)");
;;;332          } else {
;;;333            err = ERR_OK;
;;;334            /* If the application has registered a "sent" function to be
;;;335               called when new send buffer space is available, we call it
;;;336               now. */
;;;337            if (pcb->acked > 0) {
00026a  f8b42064          LDRH     r2,[r4,#0x64]
00026e  2000              MOVS     r0,#0                 ;333
000270  b132              CBZ      r2,|L1.640|
;;;338              TCP_EVENT_SENT(pcb, pcb->acked, err);
000272  6fe3              LDR      r3,[r4,#0x7c]
000274  b113              CBZ      r3,|L1.636|
000276  4621              MOV      r1,r4
000278  6920              LDR      r0,[r4,#0x10]
00027a  4798              BLX      r3
                  |L1.636|
00027c  300a              ADDS     r0,r0,#0xa
;;;339              if (err == ERR_ABRT) {
00027e  d047              BEQ      |L1.784|
                  |L1.640|
;;;340                goto aborted;
;;;341              }
;;;342            }
;;;343    
;;;344            if (recv_data != NULL) {
000280  6970              LDR      r0,[r6,#0x14]  ; recv_data
000282  b318              CBZ      r0,|L1.716|
;;;345              LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
000284  6fa0              LDR      r0,[r4,#0x78]
000286  b110              CBZ      r0,|L1.654|
000288  a07b              ADR      r0,|L1.1144|
00028a  f7fffffe          BL       __2printf
                  |L1.654|
;;;346              if (pcb->flags & TF_RXCLOSED) {
00028e  7fa0              LDRB     r0,[r4,#0x1e]
000290  06c0              LSLS     r0,r0,#27
000292  d506              BPL      |L1.674|
;;;347                /* received data although already closed -> abort (send RST) to
;;;348                   notify the remote host that not all data has been processed */
;;;349                pbuf_free(recv_data);
000294  6970              LDR      r0,[r6,#0x14]  ; recv_data
000296  f7fffffe          BL       pbuf_free
;;;350                tcp_abort(pcb);
00029a  4620              MOV      r0,r4
00029c  f7fffffe          BL       tcp_abort
;;;351                goto aborted;
0002a0  e036              B        |L1.784|
                  |L1.674|
;;;352              }
;;;353    
;;;354              /* Notify application that data has been received. */
;;;355              TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
0002a2  f8d45080          LDR      r5,[r4,#0x80]
0002a6  b12d              CBZ      r5,|L1.692|
0002a8  2300              MOVS     r3,#0
0002aa  6920              LDR      r0,[r4,#0x10]
0002ac  4621              MOV      r1,r4
0002ae  6972              LDR      r2,[r6,#0x14]  ; recv_data
0002b0  47a8              BLX      r5
0002b2  e005              B        |L1.704|
                  |L1.692|
0002b4  2300              MOVS     r3,#0
0002b6  4621              MOV      r1,r4
0002b8  4618              MOV      r0,r3
0002ba  6972              LDR      r2,[r6,#0x14]  ; recv_data
0002bc  f7fffffe          BL       tcp_recv_null
                  |L1.704|
;;;356              if (err == ERR_ABRT) {
0002c0  f1100f0a          CMN      r0,#0xa
0002c4  d024              BEQ      |L1.784|
;;;357                goto aborted;
;;;358              }
;;;359    
;;;360              /* If the upper layer can't receive this data, store it */
;;;361              if (err != ERR_OK) {
0002c6  b108              CBZ      r0,|L1.716|
;;;362                pcb->refused_data = recv_data;
0002c8  6970              LDR      r0,[r6,#0x14]  ; recv_data
0002ca  67a0              STR      r0,[r4,#0x78]
                  |L1.716|
;;;363                LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: keep incoming packet, because pcb is \"full\"\n"));
;;;364              }
;;;365            }
;;;366    
;;;367            /* If a FIN segment was received, we call the callback
;;;368               function with a NULL buffer to indicate EOF. */
;;;369            if (recv_flags & TF_GOT_FIN) {
0002cc  7870              LDRB     r0,[r6,#1]  ; recv_flags
0002ce  0680              LSLS     r0,r0,#26
0002d0  d51a              BPL      |L1.776|
;;;370              if (pcb->refused_data != NULL) {
0002d2  6fa0              LDR      r0,[r4,#0x78]
0002d4  b130              CBZ      r0,|L1.740|
;;;371                /* Delay this if we have refused data. */
;;;372                pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
0002d6  7b41              LDRB     r1,[r0,#0xd]
0002d8  e000              B        |L1.732|
                  |L1.730|
0002da  e025              B        |L1.808|
                  |L1.732|
0002dc  f0410120          ORR      r1,r1,#0x20
0002e0  7341              STRB     r1,[r0,#0xd]
0002e2  e011              B        |L1.776|
                  |L1.740|
;;;373              } else {
;;;374                /* correct rcv_wnd as the application won't call tcp_recved()
;;;375                   for the FIN's seqno */
;;;376                if (pcb->rcv_wnd != TCP_WND) {
0002e4  8da0              LDRH     r0,[r4,#0x2c]
0002e6  f5b06f2a          CMP      r0,#0xaa0
0002ea  d001              BEQ      |L1.752|
0002ec  1c40              ADDS     r0,r0,#1
;;;377                  pcb->rcv_wnd++;
0002ee  85a0              STRH     r0,[r4,#0x2c]
                  |L1.752|
;;;378                }
;;;379                TCP_EVENT_CLOSED(pcb, err);
0002f0  f8d45080          LDR      r5,[r4,#0x80]
0002f4  b12d              CBZ      r5,|L1.770|
0002f6  2300              MOVS     r3,#0
0002f8  461a              MOV      r2,r3
0002fa  4621              MOV      r1,r4
0002fc  6920              LDR      r0,[r4,#0x10]
0002fe  47a8              BLX      r5
000300  e000              B        |L1.772|
                  |L1.770|
000302  2000              MOVS     r0,#0
                  |L1.772|
000304  300a              ADDS     r0,r0,#0xa
;;;380                if (err == ERR_ABRT) {
000306  d003              BEQ      |L1.784|
                  |L1.776|
;;;381                  goto aborted;
;;;382                }
;;;383              }
;;;384            }
;;;385    
;;;386            tcp_input_pcb = NULL;
;;;387            /* Try to send something out. */
;;;388            tcp_output(pcb);
000308  4620              MOV      r0,r4
00030a  61b7              STR      r7,[r6,#0x18]  ; tcp_input_pcb
00030c  f7fffffe          BL       tcp_output
                  |L1.784|
;;;389    #if TCP_INPUT_DEBUG
;;;390    #if TCP_DEBUG
;;;391            tcp_debug_print_state(pcb->state);
;;;392    #endif /* TCP_DEBUG */
;;;393    #endif /* TCP_INPUT_DEBUG */
;;;394          }
;;;395        }
;;;396        /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
;;;397           Below this line, 'pcb' may not be dereferenced! */
;;;398    aborted:
;;;399        tcp_input_pcb = NULL;
;;;400        recv_data = NULL;
000310  61b7              STR      r7,[r6,#0x18]  ; tcp_input_pcb
;;;401    
;;;402        /* give up our reference to inseg.p */
;;;403        if (inseg.p != NULL)
000312  6177              STR      r7,[r6,#0x14]  ; recv_data
000314  f8d80004          LDR      r0,[r8,#4]  ; inseg
000318  4644              MOV      r4,r8
00031a  2800              CMP      r0,#0
00031c  d002              BEQ      |L1.804|
;;;404        {
;;;405          pbuf_free(inseg.p);
00031e  f7fffffe          BL       pbuf_free
;;;406          inseg.p = NULL;
000322  6067              STR      r7,[r4,#4]  ; inseg
                  |L1.804|
;;;407        }
;;;408      } else {
;;;409    
;;;410        /* If no matching PCB was found, send a TCP RST (reset) to the
;;;411           sender. */
;;;412        LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
;;;413        if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
;;;414          TCP_STATS_INC(tcp.proterr);
;;;415          TCP_STATS_INC(tcp.drop);
;;;416          tcp_rst(ackno, seqno + tcplen,
;;;417            ip_current_dest_addr(), ip_current_src_addr(),
;;;418            tcphdr->dest, tcphdr->src);
;;;419        }
;;;420        pbuf_free(p);
;;;421      }
;;;422    
;;;423      LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
;;;424      PERF_STOP("tcp_input");
;;;425      return;
;;;426    dropped:
;;;427      TCP_STATS_INC(tcp.drop);
;;;428      snmp_inc_tcpinerrs();
;;;429      pbuf_free(p);
;;;430    }
000324  e8bd87fc          POP      {r2-r10,pc}
                  |L1.808|
000328  8998              LDRH     r0,[r3,#0xc]          ;413
00032a  f7fffffe          BL       lwip_ntohs
00032e  0740              LSLS     r0,r0,#29             ;413
000330  d40c              BMI      |L1.844|
000332  6870              LDR      r0,[r6,#4]            ;416  ; tcphdr
000334  4b0b              LDR      r3,|L1.868|
000336  4a09              LDR      r2,|L1.860|
000338  8801              LDRH     r1,[r0,#0]            ;416
00033a  8840              LDRH     r0,[r0,#2]            ;416
00033c  e9cd0100          STRD     r0,r1,[sp,#0]         ;416
000340  8871              LDRH     r1,[r6,#2]            ;416  ; tcplen
000342  68f0              LDR      r0,[r6,#0xc]          ;416  ; seqno
000344  4401              ADD      r1,r1,r0              ;416
000346  6930              LDR      r0,[r6,#0x10]         ;416  ; ackno
000348  f7fffffe          BL       tcp_rst
                  |L1.844|
00034c  4628              MOV      r0,r5                 ;429
00034e  e8bd47fc          POP      {r2-r10,lr}           ;429
000352  f7ffbffe          B.W      pbuf_free
;;;431    
                          ENDP

000356  0000              DCW      0x0000
                  |L1.856|
                          DCD      ||.data||
                  |L1.860|
                          DCD      current_iphdr_dest
                  |L1.864|
                          DCD      tcp_active_pcbs
                  |L1.868|
                          DCD      current_iphdr_src
                  |L1.872|
000368  7463705f          DCB      "tcp_input: active pcb->state != CLOSED",0
00036c  696e7075
000370  743a2061
000374  63746976
000378  65207063
00037c  622d3e73
000380  74617465
000384  20213d20
000388  434c4f53
00038c  454400  
00038f  00                DCB      0
                  |L1.912|
000390  7463705f          DCB      "tcp_input: active pcb->state != TIME-WAIT",0
000394  696e7075
000398  743a2061
00039c  63746976
0003a0  65207063
0003a4  622d3e73
0003a8  74617465
0003ac  20213d20
0003b0  54494d45
0003b4  2d574149
0003b8  5400    
0003ba  00                DCB      0
0003bb  00                DCB      0
                  |L1.956|
0003bc  7463705f          DCB      "tcp_input: active pcb->state != LISTEN",0
0003c0  696e7075
0003c4  743a2061
0003c8  63746976
0003cc  65207063
0003d0  622d3e73
0003d4  74617465
0003d8  20213d20
0003dc  4c495354
0003e0  454e00  
0003e3  00                DCB      0
                  |L1.996|
0003e4  7463705f          DCB      "tcp_input: pcb->next != pcb (before cache)",0
0003e8  696e7075
0003ec  743a2070
0003f0  63622d3e
0003f4  6e657874
0003f8  20213d20
0003fc  70636220
000400  28626566
000404  6f726520
000408  63616368
00040c  652900  
00040f  00                DCB      0
                  |L1.1040|
000410  7463705f          DCB      "tcp_input: pcb->next != pcb (after cache)",0
000414  696e7075
000418  743a2070
00041c  63622d3e
000420  6e657874
000424  20213d20
000428  70636220
00042c  28616674
000430  65722063
000434  61636865
000438  2900    
00043a  00                DCB      0
00043b  00                DCB      0
                  |L1.1084|
                          DCD      tcp_tw_pcbs
                  |L1.1088|
000440  7463705f          DCB      "tcp_input: TIME-WAIT pcb->state == TIME-WAIT",0
000444  696e7075
000448  743a2054
00044c  494d452d
000450  57414954
000454  20706362
000458  2d3e7374
00045c  61746520
000460  3d3d2054
000464  494d452d
000468  57414954
00046c  00      
00046d  00                DCB      0
00046e  00                DCB      0
00046f  00                DCB      0
                  |L1.1136|
                          DCD      tcp_listen_pcbs
                  |L1.1140|
                          DCD      ||.bss||
                  |L1.1144|
000478  7063622d          DCB      "pcb->refused_data == NULL",0
00047c  3e726566
000480  75736564
000484  5f646174
000488  61203d3d
00048c  204e554c
000490  4c00    
000492  00                DCB      0
000493  00                DCB      0

                          AREA ||i.tcp_listen_input||, CODE, READONLY, ALIGN=2

                  tcp_listen_input PROC
;;;444    static err_t
;;;445    tcp_listen_input(struct tcp_pcb_listen *pcb)
000000  b57c              PUSH     {r2-r6,lr}
;;;446    {
;;;447      struct tcp_pcb *npcb;
;;;448      err_t rc;
;;;449    
;;;450      if (flags & TCP_RST) {
000002  4e33              LDR      r6,|L2.208|
000004  4605              MOV      r5,r0                 ;446
000006  7830              LDRB     r0,[r6,#0]  ; flags
000008  0741              LSLS     r1,r0,#29
00000a  d45f              BMI      |L2.204|
;;;451        /* An incoming RST should be ignored. Return. */
;;;452        return ERR_OK;
;;;453      }
;;;454    
;;;455      /* In the LISTEN state, we check for incoming SYN segments,
;;;456         creates a new PCB, and responds with a SYN|ACK. */
;;;457      if (flags & TCP_ACK) {
00000c  06c1              LSLS     r1,r0,#27
00000e  d50d              BPL      |L2.44|
;;;458        /* For incoming segments with the ACK flag set, respond with a
;;;459           RST. */
;;;460        LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
;;;461        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
000010  6870              LDR      r0,[r6,#4]  ; tcphdr
000012  4b30              LDR      r3,|L2.212|
000014  4a30              LDR      r2,|L2.216|
000016  8801              LDRH     r1,[r0,#0]
000018  8840              LDRH     r0,[r0,#2]
00001a  e9cd0100          STRD     r0,r1,[sp,#0]
00001e  8871              LDRH     r1,[r6,#2]  ; tcplen
000020  68f0              LDR      r0,[r6,#0xc]  ; seqno
000022  4401              ADD      r1,r1,r0
000024  6930              LDR      r0,[r6,#0x10]  ; ackno
000026  f7fffffe          BL       tcp_rst
00002a  e04f              B        |L2.204|
                  |L2.44|
;;;462          ip_current_src_addr(), tcphdr->dest, tcphdr->src);
;;;463      } else if (flags & TCP_SYN) {
00002c  0780              LSLS     r0,r0,#30
00002e  d54d              BPL      |L2.204|
;;;464        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection request %"U16_F" -> %"U16_F".\n", tcphdr->src, tcphdr->dest));
;;;465    #if TCP_LISTEN_BACKLOG
;;;466        if (pcb->accepts_pending >= pcb->backlog) {
;;;467          LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
;;;468          return ERR_ABRT;
;;;469        }
;;;470    #endif /* TCP_LISTEN_BACKLOG */
;;;471        npcb = tcp_alloc(pcb->prio);
000030  7e68              LDRB     r0,[r5,#0x19]
000032  f7fffffe          BL       tcp_alloc
000036  0004              MOVS     r4,r0
;;;472        /* If a new PCB could not be created (probably due to lack of memory),
;;;473           we don't do anything, but rely on the sender will retransmit the
;;;474           SYN at a time when we have more memory available. */
;;;475        if (npcb == NULL) {
000038  d040              BEQ      |L2.188|
;;;476          LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
;;;477          TCP_STATS_INC(tcp.memerr);
;;;478          return ERR_MEM;
;;;479        }
;;;480    #if TCP_LISTEN_BACKLOG
;;;481        pcb->accepts_pending++;
;;;482    #endif /* TCP_LISTEN_BACKLOG */
;;;483        /* Set up the new PCB. */
;;;484        ip_addr_copy(npcb->local_ip, current_iphdr_dest);
00003a  4827              LDR      r0,|L2.216|
00003c  6800              LDR      r0,[r0,#0]  ; current_iphdr_dest
;;;485        npcb->local_port = pcb->local_port;
00003e  6020              STR      r0,[r4,#0]
000040  8b68              LDRH     r0,[r5,#0x1a]
000042  8360              STRH     r0,[r4,#0x1a]
;;;486        ip_addr_copy(npcb->remote_ip, current_iphdr_src);
000044  4823              LDR      r0,|L2.212|
000046  6800              LDR      r0,[r0,#0]  ; current_iphdr_src
;;;487        npcb->remote_port = tcphdr->src;
000048  6060              STR      r0,[r4,#4]
00004a  6870              LDR      r0,[r6,#4]  ; tcphdr
00004c  8801              LDRH     r1,[r0,#0]
00004e  83a1              STRH     r1,[r4,#0x1c]
;;;488        npcb->state = SYN_RCVD;
000050  2103              MOVS     r1,#3
000052  7621              STRB     r1,[r4,#0x18]
;;;489        npcb->rcv_nxt = seqno + 1;
000054  68f1              LDR      r1,[r6,#0xc]  ; seqno
000056  460a              MOV      r2,r1
000058  1c49              ADDS     r1,r1,#1
;;;490        npcb->rcv_ann_right_edge = npcb->rcv_nxt;
00005a  62a1              STR      r1,[r4,#0x28]
;;;491        npcb->snd_wnd = tcphdr->wnd;
00005c  6321              STR      r1,[r4,#0x30]
00005e  89c1              LDRH     r1,[r0,#0xe]
000060  f8a41060          STRH     r1,[r4,#0x60]
;;;492        npcb->snd_wnd_max = tcphdr->wnd;
000064  89c0              LDRH     r0,[r0,#0xe]
000066  f8a40062          STRH     r0,[r4,#0x62]
;;;493        npcb->ssthresh = npcb->snd_wnd;
00006a  f8a4104e          STRH     r1,[r4,#0x4e]
00006e  1e52              SUBS     r2,r2,#1
;;;494        npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
;;;495        npcb->callback_arg = pcb->callback_arg;
000070  6562              STR      r2,[r4,#0x54]
000072  6928              LDR      r0,[r5,#0x10]
;;;496    #if LWIP_CALLBACK_API
;;;497        npcb->accept = pcb->accept;
000074  6120              STR      r0,[r4,#0x10]
000076  6968              LDR      r0,[r5,#0x14]
;;;498    #endif /* LWIP_CALLBACK_API */
;;;499        /* inherit socket options */
;;;500        npcb->so_options = pcb->so_options & SOF_INHERITED;
000078  6160              STR      r0,[r4,#0x14]
00007a  7a28              LDRB     r0,[r5,#8]
00007c  f000008c          AND      r0,r0,#0x8c
000080  7220              STRB     r0,[r4,#8]
;;;501        /* Register the new PCB so that we can begin receiving segments
;;;502           for it. */
;;;503        TCP_REG_ACTIVE(npcb);
000082  4816              LDR      r0,|L2.220|
000084  6801              LDR      r1,[r0,#0]  ; tcp_active_pcbs
000086  60e1              STR      r1,[r4,#0xc]
000088  6004              STR      r4,[r0,#0]  ; tcp_active_pcbs
00008a  f7fffffe          BL       tcp_timer_needed
00008e  4914              LDR      r1,|L2.224|
000090  2001              MOVS     r0,#1
000092  7008              STRB     r0,[r1,#0]
;;;504    
;;;505        /* Parse any options in the SYN. */
;;;506        tcp_parseopt(npcb);
000094  4620              MOV      r0,r4
000096  f7fffffe          BL       tcp_parseopt
;;;507    #if TCP_CALCULATE_EFF_SEND_MSS
;;;508        npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
00009a  8ee0              LDRH     r0,[r4,#0x36]
00009c  1d21              ADDS     r1,r4,#4
00009e  f7fffffe          BL       tcp_eff_send_mss
0000a2  86e0              STRH     r0,[r4,#0x36]
;;;509    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;510    
;;;511        snmp_inc_tcppassiveopens();
;;;512    
;;;513        /* Send a SYN|ACK together with the MSS option. */
;;;514        rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
0000a4  2112              MOVS     r1,#0x12
0000a6  4620              MOV      r0,r4
0000a8  f7fffffe          BL       tcp_enqueue_flags
0000ac  0005              MOVS     r5,r0
;;;515        if (rc != ERR_OK) {
0000ae  d008              BEQ      |L2.194|
;;;516          tcp_abandon(npcb, 0);
0000b0  2100              MOVS     r1,#0
0000b2  4620              MOV      r0,r4
0000b4  f7fffffe          BL       tcp_abandon
;;;517          return rc;
0000b8  4628              MOV      r0,r5
;;;518        }
;;;519        return tcp_output(npcb);
;;;520      }
;;;521      return ERR_OK;
;;;522    }
0000ba  bd7c              POP      {r2-r6,pc}
                  |L2.188|
0000bc  f04f30ff          MOV      r0,#0xffffffff        ;478
0000c0  bd7c              POP      {r2-r6,pc}
                  |L2.194|
0000c2  4620              MOV      r0,r4                 ;519
0000c4  e8bd407c          POP      {r2-r6,lr}            ;519
0000c8  f7ffbffe          B.W      tcp_output
                  |L2.204|
0000cc  2000              MOVS     r0,#0                 ;521
0000ce  bd7c              POP      {r2-r6,pc}
;;;523    
                          ENDP

                  |L2.208|
                          DCD      ||.data||
                  |L2.212|
                          DCD      current_iphdr_src
                  |L2.216|
                          DCD      current_iphdr_dest
                  |L2.220|
                          DCD      tcp_active_pcbs
                  |L2.224|
                          DCD      tcp_active_pcbs_changed

                          AREA ||i.tcp_oos_insert_segment||, CODE, READONLY, ALIGN=2

                  tcp_oos_insert_segment PROC
;;;807    static void
;;;808    tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
000000  b570              PUSH     {r4-r6,lr}
;;;809    {
000002  4605              MOV      r5,r0
;;;810      struct tcp_seg *old_seg;
;;;811    
;;;812      if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
000004  68c0              LDR      r0,[r0,#0xc]
000006  460c              MOV      r4,r1                 ;809
000008  8980              LDRH     r0,[r0,#0xc]
00000a  f7fffffe          BL       lwip_ntohs
;;;813        /* received segment overlaps all following segments */
;;;814        tcp_segs_free(next);
;;;815        next = NULL;
;;;816    	TCP_DEBUG_USART_PRINTF_S(" tcp_segs_free(next);\n");
;;;817      }
;;;818      else {
;;;819        /* delete some following segments
;;;820           oos queue may have segments with FIN flag */
;;;821        while (next &&
;;;822               TCP_SEQ_GEQ((seqno + cseg->len),
00000e  4e19              LDR      r6,|L3.116|
000010  07c0              LSLS     r0,r0,#31             ;812
000012  d015              BEQ      |L3.64|
000014  4620              MOV      r0,r4                 ;814
000016  f7fffffe          BL       tcp_segs_free
00001a  2400              MOVS     r4,#0                 ;815
00001c  e027              B        |L3.110|
                  |L3.30|
;;;823                          (next->tcphdr->seqno + next->len))) {
;;;824          /* cseg with FIN already processed */
;;;825          if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
00001e  8980              LDRH     r0,[r0,#0xc]
000020  f7fffffe          BL       lwip_ntohs
000024  07c0              LSLS     r0,r0,#31
000026  d007              BEQ      |L3.56|
;;;826            TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
000028  2001              MOVS     r0,#1
00002a  f7fffffe          BL       lwip_htons
00002e  4601              MOV      r1,r0
000030  68e8              LDR      r0,[r5,#0xc]
000032  8982              LDRH     r2,[r0,#0xc]
000034  4311              ORRS     r1,r1,r2
000036  8181              STRH     r1,[r0,#0xc]
                  |L3.56|
;;;827          }
;;;828          old_seg = next;
;;;829          next = next->next;
000038  4620              MOV      r0,r4
00003a  6824              LDR      r4,[r4,#0]
;;;830          tcp_seg_free(old_seg);
00003c  f7fffffe          BL       tcp_seg_free
                  |L3.64|
000040  b1ac              CBZ      r4,|L3.110|
000042  68e0              LDR      r0,[r4,#0xc]          ;822
000044  8922              LDRH     r2,[r4,#8]            ;822
000046  68f3              LDR      r3,[r6,#0xc]          ;822  ; seqno
000048  6841              LDR      r1,[r0,#4]            ;822
00004a  4411              ADD      r1,r1,r2              ;822
00004c  892a              LDRH     r2,[r5,#8]            ;822
00004e  441a              ADD      r2,r2,r3              ;822
000050  1a51              SUBS     r1,r2,r1              ;822
000052  d5e4              BPL      |L3.30|
;;;831        }
;;;832        if (next &&
;;;833            TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
000054  8929              LDRH     r1,[r5,#8]
000056  18ca              ADDS     r2,r1,r3
000058  68e1              LDR      r1,[r4,#0xc]
00005a  6849              LDR      r1,[r1,#4]
00005c  1a52              SUBS     r2,r2,r1
00005e  2a00              CMP      r2,#0
000060  dd05              BLE      |L3.110|
;;;834          /* We need to trim the incoming segment. */
;;;835          cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
000062  1ac8              SUBS     r0,r1,r3
000064  b281              UXTH     r1,r0
000066  8129              STRH     r1,[r5,#8]
;;;836          pbuf_realloc(cseg->p, cseg->len);
000068  6868              LDR      r0,[r5,#4]
00006a  f7fffffe          BL       pbuf_realloc
                  |L3.110|
;;;837        }
;;;838      }
;;;839      cseg->next = next;
00006e  602c              STR      r4,[r5,#0]
;;;840    }
000070  bd70              POP      {r4-r6,pc}
;;;841    #endif /* TCP_QUEUE_OOSEQ */
                          ENDP

000072  0000              DCW      0x0000
                  |L3.116|
                          DCD      ||.data||

                          AREA ||i.tcp_parseopt||, CODE, READONLY, ALIGN=2

                  tcp_parseopt PROC
;;;1550   static void
;;;1551   tcp_parseopt(struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;1552   {
;;;1553     u16_t c, max_c;
;;;1554     u16_t mss;
;;;1555     u8_t *opts, opt;
;;;1556   #if LWIP_TCP_TIMESTAMPS
;;;1557     u32_t tsval;
;;;1558   #endif
;;;1559   
;;;1560     opts = (u8_t *)tcphdr + TCP_HLEN;
000002  4e1e              LDR      r6,|L4.124|
000004  4605              MOV      r5,r0                 ;1552
000006  6870              LDR      r0,[r6,#4]  ; tcphdr
000008  f1000414          ADD      r4,r0,#0x14
;;;1561   
;;;1562     /* Parse the TCP MSS option, if present. */
;;;1563     if(TCPH_HDRLEN(tcphdr) > 0x5) {
00000c  8980              LDRH     r0,[r0,#0xc]
00000e  f7fffffe          BL       lwip_ntohs
000012  2105              MOVS     r1,#5
000014  ebb13f10          CMP      r1,r0,LSR #12
000018  d21e              BCS      |L4.88|
;;;1564       max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
00001a  6870              LDR      r0,[r6,#4]  ; tcphdr
00001c  8980              LDRH     r0,[r0,#0xc]
00001e  f7fffffe          BL       lwip_ntohs
000022  f06f0104          MVN      r1,#4
000026  eb013010          ADD      r0,r1,r0,LSR #12
00002a  0c09              LSRS     r1,r1,#16
00002c  ea010380          AND      r3,r1,r0,LSL #2
;;;1565       for (c = 0; c < max_c; ) {
000030  2100              MOVS     r1,#0
;;;1566         opt = opts[c];
;;;1567         switch (opt) {
;;;1568         case 0x00:
;;;1569           /* End of options. */
;;;1570           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
;;;1571           return;
;;;1572         case 0x01:
;;;1573           /* NOP option. */
;;;1574           ++c;
;;;1575           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
;;;1576           break;
;;;1577         case 0x02:
;;;1578           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
;;;1579           if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
;;;1580             /* Bad length */
;;;1581             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1582             return;
;;;1583           }
;;;1584           /* An MSS option with the right option length. */
;;;1585           mss = (opts[c + 2] << 8) | opts[c + 3];
;;;1586           /* Limit the mss to the configured TCP_MSS and prevent division by zero */
;;;1587           pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
000032  f44f66aa          MOV      r6,#0x550
000036  e00d              B        |L4.84|
                  |L4.56|
000038  5c60              LDRB     r0,[r4,r1]            ;1566
00003a  2800              CMP      r0,#0                 ;1567
00003c  d00c              BEQ      |L4.88|
00003e  2801              CMP      r0,#1                 ;1567
000040  d00b              BEQ      |L4.90|
000042  2802              CMP      r0,#2                 ;1567
000044  eb040001          ADD      r0,r4,r1              ;1579
000048  d009              BEQ      |L4.94|
;;;1588           /* Advance to next option */
;;;1589           c += 0x04;
;;;1590           break;
;;;1591   #if LWIP_TCP_TIMESTAMPS
;;;1592         case 0x08:
;;;1593           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: TS\n"));
;;;1594           if (opts[c + 1] != 0x0A || c + 0x0A > max_c) {
;;;1595             /* Bad length */
;;;1596             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1597             return;
;;;1598           }
;;;1599           /* TCP timestamp option with valid length */
;;;1600           tsval = (opts[c+2]) | (opts[c+3] << 8) | 
;;;1601             (opts[c+4] << 16) | (opts[c+5] << 24);
;;;1602           if (flags & TCP_SYN) {
;;;1603             pcb->ts_recent = ntohl(tsval);
;;;1604             pcb->flags |= TF_TIMESTAMP;
;;;1605           } else if (TCP_SEQ_BETWEEN(pcb->ts_lastacksent, seqno, seqno+tcplen)) {
;;;1606             pcb->ts_recent = ntohl(tsval);
;;;1607           }
;;;1608           /* Advance to next option */
;;;1609           c += 0x0A;
;;;1610           break;
;;;1611   #endif
;;;1612         default:
;;;1613           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
;;;1614           if (opts[c + 1] == 0) {
00004a  7840              LDRB     r0,[r0,#1]
00004c  2800              CMP      r0,#0
00004e  d003              BEQ      |L4.88|
;;;1615             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1616             /* If the length field is zero, the options are malformed
;;;1617                and we don't process them further. */
;;;1618             return;
;;;1619           }
;;;1620           /* All other options have a length field, so that we easily
;;;1621              can skip past them. */
;;;1622           c += opts[c + 1];
000050  4408              ADD      r0,r0,r1
000052  b281              UXTH     r1,r0
                  |L4.84|
000054  4299              CMP      r1,r3                 ;1565
000056  d3ef              BCC      |L4.56|
                  |L4.88|
;;;1623         }
;;;1624       }
;;;1625     }
;;;1626   }
000058  bd70              POP      {r4-r6,pc}
                  |L4.90|
00005a  1c49              ADDS     r1,r1,#1
00005c  e00c              B        |L4.120|
                  |L4.94|
00005e  7842              LDRB     r2,[r0,#1]            ;1579
000060  2a04              CMP      r2,#4                 ;1579
000062  d1f9              BNE      |L4.88|
000064  1d09              ADDS     r1,r1,#4              ;1579
000066  4299              CMP      r1,r3                 ;1579
000068  d8f6              BHI      |L4.88|
00006a  8840              LDRH     r0,[r0,#2]            ;1585
00006c  ba42              REV16    r2,r0                 ;1585
00006e  42b2              CMP      r2,r6                 ;1587
000070  d800              BHI      |L4.116|
000072  b902              CBNZ     r2,|L4.118|
                  |L4.116|
000074  4632              MOV      r2,r6                 ;1587
                  |L4.118|
000076  86ea              STRH     r2,[r5,#0x36]         ;1587
                  |L4.120|
000078  b289              UXTH     r1,r1                 ;1589
00007a  e7eb              B        |L4.84|
;;;1627   
                          ENDP

                  |L4.124|
                          DCD      ||.data||

                          AREA ||i.tcp_process||, CODE, READONLY, ALIGN=2

                  tcp_process PROC
;;;579    static err_t
;;;580    tcp_process(struct tcp_pcb *pcb)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;581    {
000004  4604              MOV      r4,r0
;;;582      struct tcp_seg *rseg;
;;;583      u8_t acceptable = 0;
;;;584      err_t err;
;;;585    
;;;586      err = ERR_OK;
;;;587    
;;;588      /* Process incoming RST segments. */
;;;589      if (flags & TCP_RST) {
000006  4ed0              LDR      r6,|L5.840|
000008  2000              MOVS     r0,#0                 ;586
00000a  9000              STR      r0,[sp,#0]
00000c  7830              LDRB     r0,[r6,#0]  ; flags
00000e  0741              LSLS     r1,r0,#29
000010  d521              BPL      |L5.86|
;;;590        /* First, determine if the reset is acceptable. */
;;;591        if (pcb->state == SYN_SENT) {
000012  7e22              LDRB     r2,[r4,#0x18]
000014  2a02              CMP      r2,#2
000016  d00a              BEQ      |L5.46|
;;;592          if (ackno == pcb->snd_nxt) {
;;;593            acceptable = 1;
;;;594          }
;;;595        } else {
;;;596          if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
000018  6aa0              LDR      r0,[r4,#0x28]
00001a  68f1              LDR      r1,[r6,#0xc]  ; seqno
00001c  1a0b              SUBS     r3,r1,r0
00001e  d40a              BMI      |L5.54|
000020  8da3              LDRH     r3,[r4,#0x2c]
000022  4418              ADD      r0,r0,r3
000024  1a08              SUBS     r0,r1,r0
000026  2800              CMP      r0,#0
000028  dc05              BGT      |L5.54|
;;;597                              pcb->rcv_nxt+pcb->rcv_wnd)) {
;;;598            acceptable = 1;
00002a  b12a              CBZ      r2,|L5.56|
00002c  e007              B        |L5.62|
                  |L5.46|
00002e  6d20              LDR      r0,[r4,#0x50]         ;592
000030  6931              LDR      r1,[r6,#0x10]         ;592  ; ackno
000032  4288              CMP      r0,r1                 ;592
000034  d003              BEQ      |L5.62|
                  |L5.54|
000036  e185              B        |L5.836|
                  |L5.56|
;;;599          }
;;;600        }
;;;601    
;;;602        if (acceptable) {
;;;603          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
;;;604          LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
000038  a0c4              ADR      r0,|L5.844|
00003a  f7fffffe          BL       __2printf
                  |L5.62|
;;;605          recv_flags |= TF_RESET;
00003e  7870              LDRB     r0,[r6,#1]  ; recv_flags
000040  f0400008          ORR      r0,r0,#8
000044  7070              STRB     r0,[r6,#1]
;;;606          pcb->flags &= ~TF_ACK_DELAY;
000046  7fa0              LDRB     r0,[r4,#0x1e]
000048  f0200001          BIC      r0,r0,#1
00004c  77a0              STRB     r0,[r4,#0x1e]
;;;607          return ERR_RST;
00004e  f06f000a          MVN      r0,#0xa
                  |L5.82|
;;;608        } else {
;;;609          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
;;;610           seqno, pcb->rcv_nxt));
;;;611          LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
;;;612           seqno, pcb->rcv_nxt));
;;;613          return ERR_OK;
;;;614        }
;;;615      }
;;;616    
;;;617      if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) { 
;;;618        /* Cope with new connection attempt after remote end crashed */
;;;619        tcp_ack_now(pcb);
;;;620        return ERR_OK;
;;;621      }
;;;622      
;;;623      if ((pcb->flags & TF_RXCLOSED) == 0) {
;;;624        /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
;;;625        pcb->tmr = tcp_ticks;
;;;626      }
;;;627      pcb->keep_cnt_sent = 0;
;;;628    
;;;629      tcp_parseopt(pcb);
;;;630    
;;;631      /* Do different things depending on the TCP state. */
;;;632      switch (pcb->state) {
;;;633      case SYN_SENT:
;;;634        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
;;;635         pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
;;;636        /* received SYN ACK with expected sequence number? */
;;;637        if ((flags & TCP_ACK) && (flags & TCP_SYN)
;;;638            && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
;;;639          pcb->snd_buf++;
;;;640          pcb->rcv_nxt = seqno + 1;
;;;641          pcb->rcv_ann_right_edge = pcb->rcv_nxt;
;;;642          pcb->lastack = ackno;
;;;643          pcb->snd_wnd = tcphdr->wnd;
;;;644          pcb->snd_wnd_max = tcphdr->wnd;
;;;645          pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
;;;646          pcb->state = ESTABLISHED;
;;;647    
;;;648    #if TCP_CALCULATE_EFF_SEND_MSS
;;;649          pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
;;;650    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;651    
;;;652          /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
;;;653           * but for the default value of pcb->mss) */
;;;654          pcb->ssthresh = pcb->mss * 10;
;;;655    
;;;656          pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
;;;657          LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
;;;658          --pcb->snd_queuelen;
;;;659          LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
;;;660          rseg = pcb->unacked;
;;;661          pcb->unacked = rseg->next;
;;;662          tcp_seg_free(rseg);
;;;663    
;;;664          /* If there's nothing left to acknowledge, stop the retransmit
;;;665             timer, otherwise reset it to start again */
;;;666          if(pcb->unacked == NULL)
;;;667            pcb->rtime = -1;
;;;668          else {
;;;669            pcb->rtime = 0;
;;;670            pcb->nrtx = 0;
;;;671          }
;;;672    
;;;673          /* Call the user specified function to call when sucessfully
;;;674           * connected. */
;;;675          TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
;;;676          if (err == ERR_ABRT) {
;;;677            return ERR_ABRT;
;;;678          }
;;;679          tcp_ack_now(pcb);
;;;680        }
;;;681        /* received ACK? possibly a half-open connection */
;;;682        else if (flags & TCP_ACK) {
;;;683          /* send a RST to bring the other side in a non-synchronized state. */
;;;684          tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
;;;685            tcphdr->dest, tcphdr->src);
;;;686        }
;;;687        break;
;;;688      case SYN_RCVD:
;;;689        if (flags & TCP_ACK) {
;;;690          /* expected ACK number? */
;;;691          if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
;;;692            u16_t old_cwnd;
;;;693            pcb->state = ESTABLISHED;
;;;694            LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;695    #if LWIP_CALLBACK_API
;;;696            LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
;;;697    #endif
;;;698            /* Call the accept function. */
;;;699            TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
;;;700            if (err != ERR_OK) {
;;;701              /* If the accept function returns with an error, we abort
;;;702               * the connection. */
;;;703              /* Already aborted? */
;;;704              if (err != ERR_ABRT) {
;;;705                tcp_abort(pcb);
;;;706              }
;;;707              return ERR_ABRT;
;;;708            }
;;;709            old_cwnd = pcb->cwnd;
;;;710            /* If there was any data contained within this ACK,
;;;711             * we'd better pass it on to the application as well. */
;;;712            tcp_receive(pcb);
;;;713    
;;;714            /* Prevent ACK for SYN to generate a sent event */
;;;715            if (pcb->acked != 0) {
;;;716              pcb->acked--;
;;;717            }
;;;718    
;;;719            pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
;;;720    
;;;721            if (recv_flags & TF_GOT_FIN) {
;;;722              tcp_ack_now(pcb);
;;;723              pcb->state = CLOSE_WAIT;
;;;724            }
;;;725          } else {
;;;726            /* incorrect ACK number, send RST */
;;;727            tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
;;;728                    tcphdr->dest, tcphdr->src);
;;;729          }
;;;730        } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
;;;731          /* Looks like another copy of the SYN - retransmit our SYN-ACK */
;;;732          tcp_rexmit(pcb);
;;;733        }
;;;734        break;
;;;735      case CLOSE_WAIT:
;;;736        /* FALLTHROUGH */
;;;737      case ESTABLISHED:
;;;738        tcp_receive(pcb);
;;;739        if (recv_flags & TF_GOT_FIN) { /* passive close */
;;;740          tcp_ack_now(pcb);
;;;741          pcb->state = CLOSE_WAIT;
;;;742        }
;;;743        break;
;;;744      case FIN_WAIT_1:
;;;745        tcp_receive(pcb);
;;;746        if (recv_flags & TF_GOT_FIN) {
;;;747          if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
;;;748            LWIP_DEBUGF(TCP_DEBUG,
;;;749              ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;750            tcp_ack_now(pcb);
;;;751            tcp_pcb_purge(pcb);
;;;752            TCP_RMV_ACTIVE(pcb);
;;;753    		TCP_DEBUG_USART_PRINTF_S("FIN_WAIT_1--> TCP_RMV_ACTIVE(pcb);\n");
;;;754            pcb->state = TIME_WAIT;
;;;755            TCP_REG(&tcp_tw_pcbs, pcb);
;;;756          } else {
;;;757            tcp_ack_now(pcb);
;;;758            pcb->state = CLOSING;
;;;759          }
;;;760        } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
;;;761          pcb->state = FIN_WAIT_2;
;;;762        }
;;;763        break;
;;;764      case FIN_WAIT_2:
;;;765        tcp_receive(pcb);
;;;766        if (recv_flags & TF_GOT_FIN) {
;;;767          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;768          tcp_ack_now(pcb);
;;;769          tcp_pcb_purge(pcb);
;;;770          TCP_RMV_ACTIVE(pcb);
;;;771    	  TCP_DEBUG_USART_PRINTF_S("FIN_WAIT_2--> TCP_RMV_ACTIVE(pcb);\n");
;;;772          pcb->state = TIME_WAIT;
;;;773          TCP_REG(&tcp_tw_pcbs, pcb);
;;;774        }
;;;775        break;
;;;776      case CLOSING:
;;;777        tcp_receive(pcb);
;;;778        if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
;;;779          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;780          tcp_pcb_purge(pcb);
;;;781          TCP_RMV_ACTIVE(pcb);
;;;782          pcb->state = TIME_WAIT;
;;;783    	  TCP_DEBUG_USART_PRINTF_S("CLOSING--> TCP_RMV_ACTIVE(pcb);\n");
;;;784          TCP_REG(&tcp_tw_pcbs, pcb);
;;;785        }
;;;786        break;
;;;787      case LAST_ACK:
;;;788        tcp_receive(pcb);
;;;789        if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
;;;790          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;791          /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
;;;792          recv_flags |= TF_CLOSED;
;;;793        }
;;;794        break;
;;;795      default:
;;;796        break;
;;;797      }
;;;798      return ERR_OK;
;;;799    }
000052  e8bd9ffc          POP      {r2-r12,pc}
                  |L5.86|
000056  0780              LSLS     r0,r0,#30             ;617
000058  d509              BPL      |L5.110|
00005a  7e20              LDRB     r0,[r4,#0x18]         ;617
00005c  2802              CMP      r0,#2                 ;617
00005e  d006              BEQ      |L5.110|
000060  2803              CMP      r0,#3                 ;617
000062  d004              BEQ      |L5.110|
                  |L5.100|
000064  7fa0              LDRB     r0,[r4,#0x1e]         ;619
000066  f0400002          ORR      r0,r0,#2              ;619
00006a  77a0              STRB     r0,[r4,#0x1e]         ;619
00006c  e16a              B        |L5.836|
                  |L5.110|
00006e  7fa0              LDRB     r0,[r4,#0x1e]         ;623
000070  06c0              LSLS     r0,r0,#27             ;623
000072  d402              BMI      |L5.122|
000074  48bd              LDR      r0,|L5.876|
000076  6800              LDR      r0,[r0,#0]            ;625  ; tcp_ticks
000078  6260              STR      r0,[r4,#0x24]         ;625
                  |L5.122|
00007a  2000              MOVS     r0,#0                 ;627
00007c  f8840096          STRB     r0,[r4,#0x96]         ;627
000080  4620              MOV      r0,r4                 ;629
000082  f7fffffe          BL       tcp_parseopt
000086  7e20              LDRB     r0,[r4,#0x18]         ;632
000088  f8dfa2e4          LDR      r10,|L5.880|
00008c  f8df82e4          LDR      r8,|L5.884|
000090  4fb9              LDR      r7,|L5.888|
000092  4dba              LDR      r5,|L5.892|
000094  1e80              SUBS     r0,r0,#2              ;752
000096  f04f0901          MOV      r9,#1                 ;593
00009a  f04f0b0a          MOV      r11,#0xa              ;754
00009e  2808              CMP      r0,#8                 ;632
0000a0  d2c9              BCS      |L5.54|
0000a2  e8dff000          TBB      [pc,r0]               ;632
0000a6  0474              DCB      0x04,0x74
0000a8  ccd0eecc          DCB      0xcc,0xd0,0xee,0xcc
0000ac  edec              DCB      0xed,0xec
0000ae  7830              LDRB     r0,[r6,#0]            ;637  ; flags
0000b0  06c1              LSLS     r1,r0,#27             ;637
                  |L5.178|
0000b2  d5c0              BPL      |L5.54|
0000b4  0780              LSLS     r0,r0,#30             ;637
0000b6  d55e              BPL      |L5.374|
0000b8  6f20              LDR      r0,[r4,#0x70]         ;638
0000ba  68c0              LDR      r0,[r0,#0xc]          ;638
0000bc  6840              LDR      r0,[r0,#4]            ;638
0000be  f7fffffe          BL       lwip_ntohl
0000c2  6931              LDR      r1,[r6,#0x10]         ;638  ; ackno
0000c4  1c40              ADDS     r0,r0,#1              ;638
0000c6  4288              CMP      r0,r1                 ;638
0000c8  d152              BNE      |L5.368|
0000ca  f8340f66          LDRH     r0,[r4,#0x66]!        ;639
0000ce  1c40              ADDS     r0,r0,#1              ;639
0000d0  f824093e          STRH     r0,[r4],#-0x3e        ;639
0000d4  68f0              LDR      r0,[r6,#0xc]          ;640  ; seqno
0000d6  4602              MOV      r2,r0                 ;640
0000d8  1c40              ADDS     r0,r0,#1              ;640
0000da  6020              STR      r0,[r4,#0]            ;641
0000dc  6221              STR      r1,[r4,#0x20]         ;643
0000de  60a0              STR      r0,[r4,#8]            ;643
0000e0  6870              LDR      r0,[r6,#4]            ;643  ; tcphdr
0000e2  1e52              SUBS     r2,r2,#1              ;644
0000e4  89c1              LDRH     r1,[r0,#0xe]          ;643
0000e6  8721              STRH     r1,[r4,#0x38]         ;643
0000e8  89c0              LDRH     r0,[r0,#0xe]          ;644
0000ea  8760              STRH     r0,[r4,#0x3a]         ;644
0000ec  2004              MOVS     r0,#4                 ;646
0000ee  62e2              STR      r2,[r4,#0x2c]         ;646
0000f0  f8040c10          STRB     r0,[r4,#-0x10]        ;646
0000f4  f8340f0e          LDRH     r0,[r4,#0xe]!         ;649
0000f8  f1a40132          SUB      r1,r4,#0x32           ;649
0000fc  3c36              SUBS     r4,r4,#0x36           ;649
0000fe  f7fffffe          BL       tcp_eff_send_mss
000102  eb000180          ADD      r1,r0,r0,LSL #2       ;654
000106  f64f72ff          MOV      r2,#0xffff            ;654
00010a  86e0              STRH     r0,[r4,#0x36]         ;649
00010c  ea020141          AND      r1,r2,r1,LSL #1       ;654
000110  f8a4104e          STRH     r1,[r4,#0x4e]         ;654
000114  f8b4104c          LDRH     r1,[r4,#0x4c]         ;656
000118  2901              CMP      r1,#1                 ;656
00011a  d100              BNE      |L5.286|
00011c  0040              LSLS     r0,r0,#1              ;656
                  |L5.286|
00011e  f8a4004c          STRH     r0,[r4,#0x4c]         ;656
000122  f8b40068          LDRH     r0,[r4,#0x68]         ;657
000126  b910              CBNZ     r0,|L5.302|
000128  a095              ADR      r0,|L5.896|
00012a  f7fffffe          BL       __2printf
                  |L5.302|
00012e  f8b40068          LDRH     r0,[r4,#0x68]         ;658
000132  1e40              SUBS     r0,r0,#1              ;658
000134  f8a40068          STRH     r0,[r4,#0x68]         ;658
000138  6f20              LDR      r0,[r4,#0x70]         ;661
00013a  6801              LDR      r1,[r0,#0]            ;661
00013c  6721              STR      r1,[r4,#0x70]         ;662
00013e  f7fffffe          BL       tcp_seg_free
000142  6f20              LDR      r0,[r4,#0x70]         ;666
000144  b170              CBZ      r0,|L5.356|
000146  2000              MOVS     r0,#0                 ;669
000148  86a0              STRH     r0,[r4,#0x34]         ;669
00014a  f8840046          STRB     r0,[r4,#0x46]         ;670
                  |L5.334|
00014e  f8d43084          LDR      r3,[r4,#0x84]         ;675
000152  b15b              CBZ      r3,|L5.364|
000154  2200              MOVS     r2,#0                 ;675
000156  4621              MOV      r1,r4                 ;675
000158  6920              LDR      r0,[r4,#0x10]         ;675
00015a  4798              BLX      r3                    ;675
00015c  9000              STR      r0,[sp,#0]            ;675
                  |L5.350|
00015e  300a              ADDS     r0,r0,#0xa            ;675
000160  d038              BEQ      |L5.468|
000162  e77f              B        |L5.100|
                  |L5.356|
000164  f04f30ff          MOV      r0,#0xffffffff        ;667
000168  86a0              STRH     r0,[r4,#0x34]         ;667
00016a  e7f0              B        |L5.334|
                  |L5.364|
00016c  9800              LDR      r0,[sp,#0]            ;675
00016e  e7f6              B        |L5.350|
                  |L5.368|
000170  7830              LDRB     r0,[r6,#0]            ;682  ; flags
000172  06c0              LSLS     r0,r0,#27             ;682
000174  d59d              BPL      |L5.178|
                  |L5.374|
000176  6870              LDR      r0,[r6,#4]            ;684  ; tcphdr
000178  4b87              LDR      r3,|L5.920|
00017a  4a88              LDR      r2,|L5.924|
00017c  8801              LDRH     r1,[r0,#0]            ;684
00017e  8840              LDRH     r0,[r0,#2]            ;684
000180  e9cd0100          STRD     r0,r1,[sp,#0]         ;684
000184  8871              LDRH     r1,[r6,#2]            ;684  ; tcplen
000186  68f0              LDR      r0,[r6,#0xc]          ;684  ; seqno
000188  4401              ADD      r1,r1,r0              ;684
00018a  6930              LDR      r0,[r6,#0x10]         ;684  ; ackno
00018c  e049              B        |L5.546|
00018e  7830              LDRB     r0,[r6,#0]            ;689  ; flags
000190  06c1              LSLS     r1,r0,#27             ;689
000192  d549              BPL      |L5.552|
000194  6ca1              LDR      r1,[r4,#0x48]         ;691
000196  6930              LDR      r0,[r6,#0x10]         ;691  ; ackno
000198  1a41              SUBS     r1,r0,r1              ;691
00019a  2901              CMP      r1,#1                 ;691
00019c  d437              BMI      |L5.526|
00019e  6d21              LDR      r1,[r4,#0x50]         ;691
0001a0  1a41              SUBS     r1,r0,r1              ;691
0001a2  2900              CMP      r1,#0                 ;691
0001a4  dc33              BGT      |L5.526|
0001a6  2004              MOVS     r0,#4                 ;693
0001a8  7620              STRB     r0,[r4,#0x18]         ;693
0001aa  6960              LDR      r0,[r4,#0x14]         ;696
0001ac  b920              CBNZ     r0,|L5.440|
0001ae  a07c              ADR      r0,|L5.928|
0001b0  f7fffffe          BL       __2printf
0001b4  6960              LDR      r0,[r4,#0x14]         ;696
0001b6  b130              CBZ      r0,|L5.454|
                  |L5.440|
0001b8  e9d40304          LDRD     r0,r3,[r4,#0x10]      ;699
0001bc  2200              MOVS     r2,#0                 ;699
0001be  4621              MOV      r1,r4                 ;699
0001c0  4798              BLX      r3                    ;699
0001c2  b910              CBNZ     r0,|L5.458|
0001c4  e009              B        |L5.474|
                  |L5.454|
0001c6  f06f000d          MVN      r0,#0xd               ;699
                  |L5.458|
0001ca  300a              ADDS     r0,r0,#0xa            ;699
0001cc  d002              BEQ      |L5.468|
0001ce  4620              MOV      r0,r4                 ;705
0001d0  f7fffffe          BL       tcp_abort
                  |L5.468|
0001d4  f06f0009          MVN      r0,#9                 ;707
0001d8  e73b              B        |L5.82|
                  |L5.474|
0001da  f8b4504c          LDRH     r5,[r4,#0x4c]         ;709
0001de  4620              MOV      r0,r4                 ;712
0001e0  f7fffffe          BL       tcp_receive
0001e4  f8b40064          LDRH     r0,[r4,#0x64]         ;715
0001e8  b110              CBZ      r0,|L5.496|
0001ea  1e40              SUBS     r0,r0,#1              ;715
0001ec  f8a40064          STRH     r0,[r4,#0x64]         ;716
                  |L5.496|
0001f0  8ee0              LDRH     r0,[r4,#0x36]         ;719
0001f2  2d01              CMP      r5,#1                 ;719
0001f4  d100              BNE      |L5.504|
0001f6  0040              LSLS     r0,r0,#1              ;719
                  |L5.504|
0001f8  f8a4004c          STRH     r0,[r4,#0x4c]         ;719
                  |L5.508|
0001fc  7870              LDRB     r0,[r6,#1]            ;721  ; recv_flags
0001fe  0680              LSLS     r0,r0,#26             ;721
000200  d511              BPL      |L5.550|
000202  7fa0              LDRB     r0,[r4,#0x1e]         ;740
000204  f0400002          ORR      r0,r0,#2              ;740
000208  77a0              STRB     r0,[r4,#0x1e]         ;740
00020a  2007              MOVS     r0,#7                 ;741
00020c  e050              B        |L5.688|
                  |L5.526|
00020e  6871              LDR      r1,[r6,#4]            ;727  ; tcphdr
000210  4b61              LDR      r3,|L5.920|
000212  880a              LDRH     r2,[r1,#0]            ;727
000214  8849              LDRH     r1,[r1,#2]            ;727
000216  e9cd1200          STRD     r1,r2,[sp,#0]         ;727
00021a  8872              LDRH     r2,[r6,#2]            ;727  ; tcplen
00021c  68f1              LDR      r1,[r6,#0xc]          ;727  ; seqno
00021e  4411              ADD      r1,r1,r2              ;727
000220  4a5e              LDR      r2,|L5.924|
                  |L5.546|
000222  f7fffffe          BL       tcp_rst
                  |L5.550|
000226  e08d              B        |L5.836|
                  |L5.552|
000228  0780              LSLS     r0,r0,#30             ;730
00022a  d507              BPL      |L5.572|
00022c  6aa0              LDR      r0,[r4,#0x28]         ;730
00022e  68f1              LDR      r1,[r6,#0xc]          ;730  ; seqno
000230  1e40              SUBS     r0,r0,#1              ;730
000232  4288              CMP      r0,r1                 ;730
000234  d102              BNE      |L5.572|
000236  4620              MOV      r0,r4                 ;732
000238  f7fffffe          BL       tcp_rexmit
                  |L5.572|
00023c  e082              B        |L5.836|
00023e  4620              MOV      r0,r4                 ;738
000240  f7fffffe          BL       tcp_receive
000244  e7da              B        |L5.508|
000246  4620              MOV      r0,r4                 ;745
000248  f7fffffe          BL       tcp_receive
00024c  7870              LDRB     r0,[r6,#1]            ;746  ; recv_flags
00024e  0680              LSLS     r0,r0,#26             ;746
000250  7830              LDRB     r0,[r6,#0]            ;760  ; flags
000252  ea4f60c0          LSL      r0,r0,#27             ;760
000256  d524              BPL      |L5.674|
000258  2800              CMP      r0,#0                 ;747
00025a  da1c              BGE      |L5.662|
00025c  6d20              LDR      r0,[r4,#0x50]         ;747
00025e  6931              LDR      r1,[r6,#0x10]         ;747  ; ackno
000260  4288              CMP      r0,r1                 ;747
000262  d118              BNE      |L5.662|
000264  7fa0              LDRB     r0,[r4,#0x1e]         ;750
000266  f0400002          ORR      r0,r0,#2              ;750
00026a  77a0              STRB     r0,[r4,#0x1e]         ;750
00026c  4620              MOV      r0,r4                 ;751
00026e  f7fffffe          BL       tcp_pcb_purge
000272  6838              LDR      r0,[r7,#0]            ;752  ; tcp_active_pcbs
000274  42a0              CMP      r0,r4                 ;752
000276  d105              BNE      |L5.644|
                  |L5.632|
000278  68c0              LDR      r0,[r0,#0xc]          ;752
00027a  6038              STR      r0,[r7,#0]            ;752  ; tcp_active_pcbs
00027c  e048              B        |L5.784|
00027e  e053              B        |L5.808|
000280  e02e              B        |L5.736|
000282  e017              B        |L5.692|
                  |L5.644|
000284  6028              STR      r0,[r5,#0]            ;752  ; tcp_tmp_pcb
000286  b3e8              CBZ      r0,|L5.772|
000288  68c0              LDR      r0,[r0,#0xc]          ;752
00028a  42a0              CMP      r0,r4                 ;752
00028c  d1fa              BNE      |L5.644|
                  |L5.654|
00028e  6829              LDR      r1,[r5,#0]            ;752  ; tcp_tmp_pcb
000290  68e0              LDR      r0,[r4,#0xc]          ;752
000292  60c8              STR      r0,[r1,#0xc]          ;752
000294  e03c              B        |L5.784|
                  |L5.662|
000296  7fa0              LDRB     r0,[r4,#0x1e]         ;757
000298  f0400002          ORR      r0,r0,#2              ;757
00029c  77a0              STRB     r0,[r4,#0x1e]         ;757
00029e  2008              MOVS     r0,#8                 ;758
0002a0  e006              B        |L5.688|
                  |L5.674|
0002a2  2800              CMP      r0,#0                 ;760
0002a4  da4e              BGE      |L5.836|
0002a6  6d20              LDR      r0,[r4,#0x50]         ;760
0002a8  6931              LDR      r1,[r6,#0x10]         ;760  ; ackno
0002aa  4288              CMP      r0,r1                 ;760
0002ac  d14a              BNE      |L5.836|
0002ae  2006              MOVS     r0,#6                 ;761
                  |L5.688|
0002b0  7620              STRB     r0,[r4,#0x18]         ;723
0002b2  e047              B        |L5.836|
                  |L5.692|
0002b4  4620              MOV      r0,r4                 ;765
0002b6  f7fffffe          BL       tcp_receive
0002ba  7870              LDRB     r0,[r6,#1]            ;766  ; recv_flags
0002bc  0680              LSLS     r0,r0,#26             ;766
0002be  d541              BPL      |L5.836|
0002c0  7fa0              LDRB     r0,[r4,#0x1e]         ;768
0002c2  f0400002          ORR      r0,r0,#2              ;768
0002c6  77a0              STRB     r0,[r4,#0x1e]         ;768
0002c8  4620              MOV      r0,r4                 ;769
0002ca  f7fffffe          BL       tcp_pcb_purge
0002ce  6838              LDR      r0,[r7,#0]            ;770  ; tcp_active_pcbs
0002d0  42a0              CMP      r0,r4                 ;770
0002d2  d0d1              BEQ      |L5.632|
                  |L5.724|
0002d4  6028              STR      r0,[r5,#0]            ;770  ; tcp_tmp_pcb
0002d6  b1a8              CBZ      r0,|L5.772|
0002d8  68c0              LDR      r0,[r0,#0xc]          ;770
0002da  42a0              CMP      r0,r4                 ;770
0002dc  d1fa              BNE      |L5.724|
0002de  e7d6              B        |L5.654|
                  |L5.736|
0002e0  4620              MOV      r0,r4                 ;777
0002e2  f7fffffe          BL       tcp_receive
0002e6  7830              LDRB     r0,[r6,#0]            ;778  ; flags
0002e8  06c0              LSLS     r0,r0,#27             ;778
0002ea  d52b              BPL      |L5.836|
0002ec  6d20              LDR      r0,[r4,#0x50]         ;778
0002ee  6931              LDR      r1,[r6,#0x10]         ;778  ; ackno
0002f0  4288              CMP      r0,r1                 ;778
0002f2  d127              BNE      |L5.836|
0002f4  4620              MOV      r0,r4                 ;780
0002f6  f7fffffe          BL       tcp_pcb_purge
0002fa  6838              LDR      r0,[r7,#0]            ;781  ; tcp_active_pcbs
0002fc  42a0              CMP      r0,r4                 ;781
0002fe  d0bb              BEQ      |L5.632|
                  |L5.768|
000300  6028              STR      r0,[r5,#0]            ;781  ; tcp_tmp_pcb
000302  e000              B        |L5.774|
                  |L5.772|
000304  e004              B        |L5.784|
                  |L5.774|
000306  b118              CBZ      r0,|L5.784|
000308  68c0              LDR      r0,[r0,#0xc]          ;781
00030a  42a0              CMP      r0,r4                 ;781
00030c  d1f8              BNE      |L5.768|
00030e  e7be              B        |L5.654|
                  |L5.784|
000310  f88a9000          STRB     r9,[r10,#0]           ;781
000314  f884b018          STRB     r11,[r4,#0x18]        ;782
000318  f8d81000          LDR      r1,[r8,#0]            ;784  ; tcp_tw_pcbs
00031c  60e1              STR      r1,[r4,#0xc]          ;784
00031e  f8c84000          STR      r4,[r8,#0]            ;784  ; tcp_tw_pcbs
000322  f7fffffe          BL       tcp_timer_needed
000326  e00d              B        |L5.836|
                  |L5.808|
000328  4620              MOV      r0,r4                 ;788
00032a  f7fffffe          BL       tcp_receive
00032e  7830              LDRB     r0,[r6,#0]            ;789  ; flags
000330  06c0              LSLS     r0,r0,#27             ;789
000332  d507              BPL      |L5.836|
000334  6d20              LDR      r0,[r4,#0x50]         ;789
000336  6931              LDR      r1,[r6,#0x10]         ;789  ; ackno
000338  4288              CMP      r0,r1                 ;789
00033a  d103              BNE      |L5.836|
00033c  7870              LDRB     r0,[r6,#1]            ;792  ; recv_flags
00033e  f0400010          ORR      r0,r0,#0x10           ;792
000342  7070              STRB     r0,[r6,#1]            ;792
                  |L5.836|
000344  2000              MOVS     r0,#0                 ;798
000346  e684              B        |L5.82|
;;;800    
                          ENDP

                  |L5.840|
                          DCD      ||.data||
                  |L5.844|
00034c  7463705f          DCB      "tcp_input: pcb->state != CLOSED",0
000350  696e7075
000354  743a2070
000358  63622d3e
00035c  73746174
000360  6520213d
000364  20434c4f
000368  53454400
                  |L5.876|
                          DCD      tcp_ticks
                  |L5.880|
                          DCD      tcp_active_pcbs_changed
                  |L5.884|
                          DCD      tcp_tw_pcbs
                  |L5.888|
                          DCD      tcp_active_pcbs
                  |L5.892|
                          DCD      tcp_tmp_pcb
                  |L5.896|
000380  7063622d          DCB      "pcb->snd_queuelen > 0",0
000384  3e736e64
000388  5f717565
00038c  75656c65
000390  6e203e20
000394  3000    
000396  00                DCB      0
000397  00                DCB      0
                  |L5.920|
                          DCD      current_iphdr_src
                  |L5.924|
                          DCD      current_iphdr_dest
                  |L5.928|
0003a0  7063622d          DCB      "pcb->accept != NULL",0
0003a4  3e616363
0003a8  65707420
0003ac  213d204e
0003b0  554c4c00

                          AREA ||i.tcp_receive||, CODE, READONLY, ALIGN=2

                  tcp_receive PROC
;;;855    static void
;;;856    tcp_receive(struct tcp_pcb *pcb)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;857    {
000004  4604              MOV      r4,r0
;;;858      struct tcp_seg *next;
;;;859    #if TCP_QUEUE_OOSEQ
;;;860      struct tcp_seg *prev, *cseg;
;;;861    #endif /* TCP_QUEUE_OOSEQ */
;;;862      struct pbuf *p;
;;;863      s32_t off;
;;;864      s16_t m;
;;;865      u32_t right_wnd_edge;
;;;866      u16_t new_tot_len;
;;;867      int found_dupack = 0;
;;;868    #if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
;;;869      u32_t ooseq_blen;
;;;870      u16_t ooseq_qlen;
;;;871    #endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
;;;872    
;;;873      LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
000006  7e00              LDRB     r0,[r0,#0x18]
000008  2804              CMP      r0,#4
00000a  d202              BCS      |L6.18|
00000c  a0f7              ADR      r0,|L6.1004|
00000e  f7fffffe          BL       __2printf
                  |L6.18|
;;;874    
;;;875      if (flags & TCP_ACK) {
000012  4ffd              LDR      r7,|L6.1032|
000014  f04f0600          MOV      r6,#0
000018  7838              LDRB     r0,[r7,#0]  ; flags
00001a  06c0              LSLS     r0,r0,#27
00001c  d57d              BPL      |L6.282|
;;;876        right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
00001e  f8b45060          LDRH     r5,[r4,#0x60]
000022  6da1              LDR      r1,[r4,#0x58]
;;;877    
;;;878        /* Update window. */
;;;879        if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
000024  6d63              LDR      r3,[r4,#0x54]
000026  68f8              LDR      r0,[r7,#0xc]  ; seqno
000028  186a              ADDS     r2,r5,r1              ;876
00002a  ebb30c00          SUBS     r12,r3,r0
00002e  d40b              BMI      |L6.72|
;;;880           (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
000030  4283              CMP      r3,r0
000032  d102              BNE      |L6.58|
000034  693b              LDR      r3,[r7,#0x10]  ; ackno
000036  1acb              SUBS     r3,r1,r3
000038  d406              BMI      |L6.72|
                  |L6.58|
;;;881           (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
00003a  693b              LDR      r3,[r7,#0x10]  ; ackno
00003c  4299              CMP      r1,r3
00003e  d117              BNE      |L6.112|
000040  6879              LDR      r1,[r7,#4]  ; tcphdr
000042  89c9              LDRH     r1,[r1,#0xe]
000044  42a9              CMP      r1,r5
000046  d913              BLS      |L6.112|
                  |L6.72|
;;;882          pcb->snd_wnd = tcphdr->wnd;
000048  6879              LDR      r1,[r7,#4]  ; tcphdr
00004a  89cb              LDRH     r3,[r1,#0xe]
00004c  f8a43060          STRH     r3,[r4,#0x60]
;;;883          /* keep track of the biggest window announced by the remote host to calculate
;;;884             the maximum segment size */
;;;885          if (pcb->snd_wnd_max < tcphdr->wnd) {
000050  f8b45062          LDRH     r5,[r4,#0x62]
000054  89c9              LDRH     r1,[r1,#0xe]
000056  428d              CMP      r5,r1
000058  d201              BCS      |L6.94|
;;;886            pcb->snd_wnd_max = tcphdr->wnd;
00005a  f8a41062          STRH     r1,[r4,#0x62]
                  |L6.94|
;;;887          }
;;;888          pcb->snd_wl1 = seqno;
;;;889          pcb->snd_wl2 = ackno;
00005e  6560              STR      r0,[r4,#0x54]
000060  6938              LDR      r0,[r7,#0x10]  ; ackno
;;;890          if (pcb->snd_wnd == 0) {
;;;891            if (pcb->persist_backoff == 0) {
;;;892              /* start persist timer */
;;;893              pcb->persist_cnt = 0;
;;;894              pcb->persist_backoff = 1;
;;;895            }
;;;896          } else if (pcb->persist_backoff > 0) {
000062  65a0              STR      r0,[r4,#0x58]
000064  f8940095          LDRB     r0,[r4,#0x95]
000068  b163              CBZ      r3,|L6.132|
00006a  b108              CBZ      r0,|L6.112|
;;;897            /* stop persist timer */
;;;898              pcb->persist_backoff = 0;
00006c  f8846095          STRB     r6,[r4,#0x95]
                  |L6.112|
;;;899          }
;;;900          LWIP_DEBUGF(TCP_WND_DEBUG, ("tcp_receive: window update %"U16_F"\n", pcb->snd_wnd));
;;;901    #if TCP_WND_DEBUG
;;;902        } else {
;;;903          if (pcb->snd_wnd != tcphdr->wnd) {
;;;904            LWIP_DEBUGF(TCP_WND_DEBUG, 
;;;905                        ("tcp_receive: no window update lastack %"U32_F" ackno %"
;;;906                         U32_F" wl1 %"U32_F" seqno %"U32_F" wl2 %"U32_F"\n",
;;;907                         pcb->lastack, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
;;;908          }
;;;909    #endif /* TCP_WND_DEBUG */
;;;910        }
;;;911    
;;;912        /* (From Stevens TCP/IP Illustrated Vol II, p970.) Its only a
;;;913         * duplicate ack if:
;;;914         * 1) It doesn't ACK new data 
;;;915         * 2) length of received packet is zero (i.e. no payload) 
;;;916         * 3) the advertised window hasn't changed 
;;;917         * 4) There is outstanding unacknowledged data (retransmission timer running)
;;;918         * 5) The ACK is == biggest ACK sequence number so far seen (snd_una)
;;;919         * 
;;;920         * If it passes all five, should process as a dupack: 
;;;921         * a) dupacks < 3: do nothing 
;;;922         * b) dupacks == 3: fast retransmit 
;;;923         * c) dupacks > 3: increase cwnd 
;;;924         * 
;;;925         * If it only passes 1-3, should reset dupack counter (and add to
;;;926         * stats, which we don't do in lwIP)
;;;927         *
;;;928         * If it only passes 1, should reset dupack counter
;;;929         *
;;;930         */
;;;931    
;;;932        /* Clause 1 */
;;;933        if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
000070  6ca3              LDR      r3,[r4,#0x48]
000072  6938              LDR      r0,[r7,#0x10]  ; ackno
000074  1ac1              SUBS     r1,r0,r3
000076  2900              CMP      r1,#0
000078  dc36              BGT      |L6.232|
;;;934          pcb->acked = 0;
00007a  f8a46064          STRH     r6,[r4,#0x64]
;;;935          /* Clause 2 */
;;;936          if (tcplen == 0) {
00007e  8879              LDRH     r1,[r7,#2]  ; tcplen
000080  b141              CBZ      r1,|L6.148|
000082  e02e              B        |L6.226|
                  |L6.132|
000084  2800              CMP      r0,#0                 ;891
000086  d1f3              BNE      |L6.112|
000088  f8846094          STRB     r6,[r4,#0x94]         ;893
00008c  2001              MOVS     r0,#1                 ;894
00008e  f8840095          STRB     r0,[r4,#0x95]         ;894
000092  e7ed              B        |L6.112|
                  |L6.148|
;;;937            /* Clause 3 */
;;;938            if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
000094  f8b45060          LDRH     r5,[r4,#0x60]
000098  6da1              LDR      r1,[r4,#0x58]
00009a  4429              ADD      r1,r1,r5
00009c  4291              CMP      r1,r2
00009e  d120              BNE      |L6.226|
;;;939              /* Clause 4 */
;;;940              if (pcb->rtime >= 0) {
0000a0  f9b41034          LDRSH    r1,[r4,#0x34]
0000a4  2900              CMP      r1,#0
0000a6  db1c              BLT      |L6.226|
;;;941                /* Clause 5 */
;;;942                if (pcb->lastack == ackno) {
0000a8  4283              CMP      r3,r0
0000aa  d11a              BNE      |L6.226|
;;;943                  found_dupack = 1;
;;;944                  if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
0000ac  f8940047          LDRB     r0,[r4,#0x47]
0000b0  1c41              ADDS     r1,r0,#1
0000b2  b2c9              UXTB     r1,r1
0000b4  4281              CMP      r1,r0
0000b6  d901              BLS      |L6.188|
;;;945                    ++pcb->dupacks;
0000b8  f8841047          STRB     r1,[r4,#0x47]
                  |L6.188|
;;;946                  }
;;;947                  if (pcb->dupacks > 3) {
0000bc  f8940047          LDRB     r0,[r4,#0x47]
0000c0  2803              CMP      r0,#3
0000c2  d909              BLS      |L6.216|
;;;948                    /* Inflate the congestion window, but not if it means that
;;;949                       the value overflows. */
;;;950                    if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
0000c4  f8b4004c          LDRH     r0,[r4,#0x4c]
0000c8  8ee1              LDRH     r1,[r4,#0x36]
0000ca  4401              ADD      r1,r1,r0
0000cc  b289              UXTH     r1,r1
0000ce  4281              CMP      r1,r0
0000d0  d901              BLS      |L6.214|
;;;951                      pcb->cwnd += pcb->mss;
0000d2  f8a4104c          STRH     r1,[r4,#0x4c]
                  |L6.214|
0000d6  e0c9              B        |L6.620|
                  |L6.216|
;;;952                    }
;;;953                  } else if (pcb->dupacks == 3) {
0000d8  d1fd              BNE      |L6.214|
;;;954                    /* Do fast retransmit */
;;;955                    tcp_rexmit_fast(pcb);
0000da  4620              MOV      r0,r4
0000dc  f7fffffe          BL       tcp_rexmit_fast
0000e0  e0c4              B        |L6.620|
                  |L6.226|
;;;956                  }
;;;957                }
;;;958              }
;;;959            }
;;;960          }
;;;961          /* If Clause (1) or more is true, but not a duplicate ack, reset
;;;962           * count of consecutive duplicate acks */
;;;963          if (!found_dupack) {
;;;964            pcb->dupacks = 0;
0000e2  f8846047          STRB     r6,[r4,#0x47]
0000e6  e0c1              B        |L6.620|
                  |L6.232|
;;;965          }
;;;966        } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)){
0000e8  2901              CMP      r1,#1
0000ea  d47d              BMI      |L6.488|
0000ec  6d22              LDR      r2,[r4,#0x50]
0000ee  1a82              SUBS     r2,r0,r2
0000f0  2a00              CMP      r2,#0
0000f2  dc79              BGT      |L6.488|
;;;967          /* We come here when the ACK acknowledges new data. */
;;;968    
;;;969          /* Reset the "IN Fast Retransmit" flag, since we are no longer
;;;970             in fast retransmit. Also reset the congestion window to the
;;;971             slow start threshold. */
;;;972          if (pcb->flags & TF_INFR) {
0000f4  7fa2              LDRB     r2,[r4,#0x1e]
0000f6  0753              LSLS     r3,r2,#29
0000f8  d506              BPL      |L6.264|
;;;973            pcb->flags &= ~TF_INFR;
0000fa  f0220204          BIC      r2,r2,#4
0000fe  77a2              STRB     r2,[r4,#0x1e]
;;;974            pcb->cwnd = pcb->ssthresh;
000100  f8b4204e          LDRH     r2,[r4,#0x4e]
000104  f8a4204c          STRH     r2,[r4,#0x4c]
                  |L6.264|
;;;975          }
;;;976    
;;;977          /* Reset the number of retransmissions. */
;;;978          pcb->nrtx = 0;
000108  f8846046          STRB     r6,[r4,#0x46]
;;;979    
;;;980          /* Reset the retransmission time-out. */
;;;981          pcb->rto = (pcb->sa >> 3) + pcb->sv;
00010c  f8b42042          LDRH     r2,[r4,#0x42]
000110  f9b43040          LDRSH    r3,[r4,#0x40]
000114  eb0202e3          ADD      r2,r2,r3,ASR #3
000118  e000              B        |L6.284|
                  |L6.282|
00011a  e0e3              B        |L6.740|
                  |L6.284|
00011c  f8a42044          STRH     r2,[r4,#0x44]
;;;982    
;;;983          /* Update the send buffer space. Diff between the two can never exceed 64K? */
;;;984          pcb->acked = (u16_t)(ackno - pcb->lastack);
000120  f8a41064          STRH     r1,[r4,#0x64]
;;;985    
;;;986          pcb->snd_buf += pcb->acked;
000124  f8b42066          LDRH     r2,[r4,#0x66]
000128  4411              ADD      r1,r1,r2
00012a  f8a41066          STRH     r1,[r4,#0x66]
;;;987    
;;;988          /* Reset the fast retransmit variables. */
;;;989          pcb->dupacks = 0;
00012e  f8846047          STRB     r6,[r4,#0x47]
;;;990          pcb->lastack = ackno;
;;;991    
;;;992          /* Update the congestion control variables (cwnd and
;;;993             ssthresh). */
;;;994          if (pcb->state >= ESTABLISHED) {
000132  64a0              STR      r0,[r4,#0x48]
000134  7e20              LDRB     r0,[r4,#0x18]
000136  2804              CMP      r0,#4
000138  d343              BCC      |L6.450|
;;;995            if (pcb->cwnd < pcb->ssthresh) {
00013a  f8b4004c          LDRH     r0,[r4,#0x4c]
00013e  f8b4104e          LDRH     r1,[r4,#0x4e]
000142  4288              CMP      r0,r1
;;;996              if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
;;;997                pcb->cwnd += pcb->mss;
;;;998              }
;;;999              LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
;;;1000           } else {
;;;1001             u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
000144  8ee1              LDRH     r1,[r4,#0x36]
000146  d204              BCS      |L6.338|
000148  4401              ADD      r1,r1,r0              ;996
00014a  b289              UXTH     r1,r1                 ;996
00014c  4281              CMP      r1,r0                 ;996
00014e  d807              BHI      |L6.352|
000150  e037              B        |L6.450|
                  |L6.338|
000152  4349              MULS     r1,r1,r1
000154  fb91f1f0          SDIV     r1,r1,r0
000158  4401              ADD      r1,r1,r0
00015a  b289              UXTH     r1,r1
;;;1002             if (new_cwnd > pcb->cwnd) {
00015c  4288              CMP      r0,r1
00015e  d230              BCS      |L6.450|
                  |L6.352|
;;;1003               pcb->cwnd = new_cwnd;
000160  f8a4104c          STRH     r1,[r4,#0x4c]
000164  e02d              B        |L6.450|
                  |L6.358|
;;;1004             }
;;;1005             LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: congestion avoidance cwnd %"U16_F"\n", pcb->cwnd));
;;;1006           }
;;;1007         }
;;;1008         LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: ACK for %"U32_F", unacked->seqno %"U32_F":%"U32_F"\n",
;;;1009                                       ackno,
;;;1010                                       pcb->unacked != NULL?
;;;1011                                       ntohl(pcb->unacked->tcphdr->seqno): 0,
;;;1012                                       pcb->unacked != NULL?
;;;1013                                       ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));
;;;1014   
;;;1015         /* Remove segment from the unacknowledged list if the incoming
;;;1016            ACK acknowlegdes them. */
;;;1017         while (pcb->unacked != NULL &&
;;;1018                TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
;;;1019                            TCP_TCPLEN(pcb->unacked), ackno)) {
;;;1020           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
;;;1021                                         ntohl(pcb->unacked->tcphdr->seqno),
;;;1022                                         ntohl(pcb->unacked->tcphdr->seqno) +
;;;1023                                         TCP_TCPLEN(pcb->unacked)));
;;;1024   
;;;1025           next = pcb->unacked;
;;;1026           pcb->unacked = pcb->unacked->next;
000166  6828              LDR      r0,[r5,#0]
;;;1027   
;;;1028           LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
;;;1029           LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
000168  6720              STR      r0,[r4,#0x70]
00016a  6868              LDR      r0,[r5,#4]
00016c  f7fffffe          BL       pbuf_clen
000170  f8b41068          LDRH     r1,[r4,#0x68]
000174  4288              CMP      r0,r1
000176  d902              BLS      |L6.382|
000178  a0a4              ADR      r0,|L6.1036|
00017a  f7fffffe          BL       __2printf
                  |L6.382|
;;;1030           /* Prevent ACK for FIN to generate a sent event */
;;;1031           if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
00017e  f8b40064          LDRH     r0,[r4,#0x64]
000182  b150              CBZ      r0,|L6.410|
000184  68e8              LDR      r0,[r5,#0xc]
000186  8980              LDRH     r0,[r0,#0xc]
000188  f7fffffe          BL       lwip_ntohs
00018c  07c0              LSLS     r0,r0,#31
00018e  d004              BEQ      |L6.410|
;;;1032             pcb->acked--;
000190  f8b40064          LDRH     r0,[r4,#0x64]
000194  1e40              SUBS     r0,r0,#1
000196  f8a40064          STRH     r0,[r4,#0x64]
                  |L6.410|
;;;1033           }
;;;1034   
;;;1035           pcb->snd_queuelen -= pbuf_clen(next->p);
00019a  6868              LDR      r0,[r5,#4]
00019c  f7fffffe          BL       pbuf_clen
0001a0  f8341f68          LDRH     r1,[r4,#0x68]!
0001a4  1a08              SUBS     r0,r1,r0
0001a6  8020              STRH     r0,[r4,#0]
;;;1036           tcp_seg_free(next);
0001a8  4628              MOV      r0,r5
0001aa  f7fffffe          BL       tcp_seg_free
;;;1037   
;;;1038           LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
;;;1039           if (pcb->snd_queuelen != 0) {
0001ae  f8340968          LDRH     r0,[r4],#-0x68
0001b2  b130              CBZ      r0,|L6.450|
;;;1040             LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
0001b4  6f20              LDR      r0,[r4,#0x70]
0001b6  b930              CBNZ     r0,|L6.454|
0001b8  6ee0              LDR      r0,[r4,#0x6c]
0001ba  b9f8              CBNZ     r0,|L6.508|
0001bc  a09d              ADR      r0,|L6.1076|
0001be  f7fffffe          BL       __2printf
                  |L6.450|
0001c2  6f20              LDR      r0,[r4,#0x70]         ;1017
0001c4  b1d0              CBZ      r0,|L6.508|
                  |L6.454|
0001c6  68c0              LDR      r0,[r0,#0xc]          ;1018
0001c8  6840              LDR      r0,[r0,#4]            ;1018
0001ca  f7fffffe          BL       lwip_ntohl
0001ce  4605              MOV      r5,r0                 ;1018
0001d0  6f20              LDR      r0,[r4,#0x70]         ;1018
0001d2  68c0              LDR      r0,[r0,#0xc]          ;1018
0001d4  8980              LDRH     r0,[r0,#0xc]          ;1018
0001d6  f7fffffe          BL       lwip_ntohs
0001da  0780              LSLS     r0,r0,#30             ;1018
0001dc  d000              BEQ      |L6.480|
0001de  2001              MOVS     r0,#1                 ;1018
                  |L6.480|
0001e0  4428              ADD      r0,r0,r5              ;1018
0001e2  6f25              LDR      r5,[r4,#0x70]         ;1018
0001e4  8929              LDRH     r1,[r5,#8]            ;1018
0001e6  e000              B        |L6.490|
                  |L6.488|
0001e8  e00c              B        |L6.516|
                  |L6.490|
0001ea  4408              ADD      r0,r0,r1              ;1018
0001ec  6939              LDR      r1,[r7,#0x10]         ;1018  ; ackno
0001ee  1a40              SUBS     r0,r0,r1              ;1018
0001f0  2800              CMP      r0,#0                 ;1018
0001f2  ddb8              BLE      |L6.358|
;;;1041                         pcb->unsent != NULL);
;;;1042           }
;;;1043         }
;;;1044   
;;;1045         /* If there's nothing left to acknowledge, stop the retransmit
;;;1046            timer, otherwise reset it to start again */
;;;1047         if(pcb->unacked == NULL)
0001f4  b115              CBZ      r5,|L6.508|
;;;1048           pcb->rtime = -1;
;;;1049         else
;;;1050           pcb->rtime = 0;
0001f6  86a6              STRH     r6,[r4,#0x34]
                  |L6.504|
;;;1051   
;;;1052         pcb->polltmr = 0;
0001f8  77e6              STRB     r6,[r4,#0x1f]
0001fa  e037              B        |L6.620|
                  |L6.508|
0001fc  f04f30ff          MOV      r0,#0xffffffff        ;1048
000200  86a0              STRH     r0,[r4,#0x34]         ;1048
000202  e7f9              B        |L6.504|
                  |L6.516|
;;;1053       } else {
;;;1054         /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
;;;1055         pcb->acked = 0;
000204  f8a46064          STRH     r6,[r4,#0x64]
000208  e030              B        |L6.620|
                  |L6.522|
;;;1056       }
;;;1057   
;;;1058       /* We go through the ->unsent list to see if any of the segments
;;;1059          on the list are acknowledged by the ACK. This may seem
;;;1060          strange since an "unsent" segment shouldn't be acked. The
;;;1061          rationale is that lwIP puts all outstanding segments on the
;;;1062          ->unsent list after a retransmission, so these segments may
;;;1063          in fact have been sent once. */
;;;1064       while (pcb->unsent != NULL &&
;;;1065              TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
;;;1066                              TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
;;;1067         LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
;;;1068                                       ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
;;;1069                                       TCP_TCPLEN(pcb->unsent)));
;;;1070   
;;;1071         next = pcb->unsent;
;;;1072         pcb->unsent = pcb->unsent->next;
00020a  6828              LDR      r0,[r5,#0]
;;;1073   #if TCP_OVERSIZE
;;;1074         if (pcb->unsent == NULL) {
00020c  66e0              STR      r0,[r4,#0x6c]
00020e  b908              CBNZ     r0,|L6.532|
;;;1075           pcb->unsent_oversize = 0;
000210  f8a4606a          STRH     r6,[r4,#0x6a]
                  |L6.532|
;;;1076         }
;;;1077   #endif /* TCP_OVERSIZE */ 
;;;1078         LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
;;;1079         LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
000214  6868              LDR      r0,[r5,#4]
000216  f7fffffe          BL       pbuf_clen
00021a  f8b41068          LDRH     r1,[r4,#0x68]
00021e  4288              CMP      r0,r1
000220  d902              BLS      |L6.552|
000222  a07a              ADR      r0,|L6.1036|
000224  f7fffffe          BL       __2printf
                  |L6.552|
;;;1080         /* Prevent ACK for FIN to generate a sent event */
;;;1081         if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
000228  f8b40064          LDRH     r0,[r4,#0x64]
00022c  b150              CBZ      r0,|L6.580|
00022e  68e8              LDR      r0,[r5,#0xc]
000230  8980              LDRH     r0,[r0,#0xc]
000232  f7fffffe          BL       lwip_ntohs
000236  07c0              LSLS     r0,r0,#31
000238  d004              BEQ      |L6.580|
;;;1082           pcb->acked--;
00023a  f8b40064          LDRH     r0,[r4,#0x64]
00023e  1e40              SUBS     r0,r0,#1
000240  f8a40064          STRH     r0,[r4,#0x64]
                  |L6.580|
;;;1083         }
;;;1084         pcb->snd_queuelen -= pbuf_clen(next->p);
000244  6868              LDR      r0,[r5,#4]
000246  f7fffffe          BL       pbuf_clen
00024a  f8341f68          LDRH     r1,[r4,#0x68]!
00024e  1a08              SUBS     r0,r1,r0
000250  8020              STRH     r0,[r4,#0]
;;;1085         tcp_seg_free(next);
000252  4628              MOV      r0,r5
000254  f7fffffe          BL       tcp_seg_free
;;;1086         LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
;;;1087         if (pcb->snd_queuelen != 0) {
000258  f8340968          LDRH     r0,[r4],#-0x68
00025c  b130              CBZ      r0,|L6.620|
;;;1088           LWIP_ASSERT("tcp_receive: valid queue length",
00025e  6f20              LDR      r0,[r4,#0x70]
000260  b920              CBNZ     r0,|L6.620|
000262  6ee0              LDR      r0,[r4,#0x6c]
000264  b920              CBNZ     r0,|L6.624|
000266  a073              ADR      r0,|L6.1076|
000268  f7fffffe          BL       __2printf
                  |L6.620|
00026c  6ee0              LDR      r0,[r4,#0x6c]         ;1064
00026e  b1b8              CBZ      r0,|L6.672|
                  |L6.624|
000270  68c0              LDR      r0,[r0,#0xc]          ;1065
000272  6840              LDR      r0,[r0,#4]            ;1065
000274  f7fffffe          BL       lwip_ntohl
000278  4605              MOV      r5,r0                 ;1065
00027a  6ee0              LDR      r0,[r4,#0x6c]         ;1065
00027c  68c0              LDR      r0,[r0,#0xc]          ;1065
00027e  8980              LDRH     r0,[r0,#0xc]          ;1065
000280  f7fffffe          BL       lwip_ntohs
000284  0780              LSLS     r0,r0,#30             ;1065
000286  d000              BEQ      |L6.650|
000288  2001              MOVS     r0,#1                 ;1065
                  |L6.650|
00028a  4428              ADD      r0,r0,r5              ;1065
00028c  6ee5              LDR      r5,[r4,#0x6c]         ;1065
00028e  8929              LDRH     r1,[r5,#8]            ;1065
000290  4401              ADD      r1,r1,r0              ;1065
000292  6938              LDR      r0,[r7,#0x10]         ;1065  ; ackno
000294  1a41              SUBS     r1,r0,r1              ;1065
000296  d403              BMI      |L6.672|
000298  6d21              LDR      r1,[r4,#0x50]         ;1065
00029a  1a40              SUBS     r0,r0,r1              ;1065
00029c  2800              CMP      r0,#0                 ;1065
00029e  ddb4              BLE      |L6.522|
                  |L6.672|
;;;1089             pcb->unacked != NULL || pcb->unsent != NULL);
;;;1090         }
;;;1091       }
;;;1092       /* End of ACK for new data processing. */
;;;1093   
;;;1094       LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: pcb->rttest %"U32_F" rtseq %"U32_F" ackno %"U32_F"\n",
;;;1095                                   pcb->rttest, pcb->rtseq, ackno));
;;;1096   
;;;1097       /* RTT estimation calculations. This is done by checking if the
;;;1098          incoming segment acknowledges the segment we use to take a
;;;1099          round-trip time measurement. */
;;;1100       if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
0002a0  6ba0              LDR      r0,[r4,#0x38]
0002a2  b1f8              CBZ      r0,|L6.740|
0002a4  6be1              LDR      r1,[r4,#0x3c]
0002a6  693a              LDR      r2,[r7,#0x10]  ; ackno
0002a8  1a89              SUBS     r1,r1,r2
0002aa  d51b              BPL      |L6.740|
;;;1101         /* diff between this shouldn't exceed 32K since this are tcp timer ticks
;;;1102            and a round-trip shouldn't be that long... */
;;;1103         m = (s16_t)(tcp_ticks - pcb->rttest);
0002ac  4969              LDR      r1,|L6.1108|
0002ae  8809              LDRH     r1,[r1,#0]  ; tcp_ticks
0002b0  1a08              SUBS     r0,r1,r0
;;;1104   
;;;1105         LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
;;;1106                                     m, m * TCP_SLOW_INTERVAL));
;;;1107   
;;;1108         /* This is taken directly from VJs original code in his paper */
;;;1109         m = m - (pcb->sa >> 3);
0002b2  f9b41040          LDRSH    r1,[r4,#0x40]
0002b6  eba000e1          SUB      r0,r0,r1,ASR #3
0002ba  b200              SXTH     r0,r0
;;;1110         pcb->sa += m;
0002bc  4401              ADD      r1,r1,r0
0002be  b20a              SXTH     r2,r1
0002c0  f8a42040          STRH     r2,[r4,#0x40]
;;;1111         if (m < 0) {
0002c4  2800              CMP      r0,#0
0002c6  da01              BGE      |L6.716|
;;;1112           m = -m;
0002c8  4240              RSBS     r0,r0,#0
0002ca  b200              SXTH     r0,r0
                  |L6.716|
;;;1113         }
;;;1114         m = m - (pcb->sv >> 2);
0002cc  f9b41042          LDRSH    r1,[r4,#0x42]
0002d0  eba000a1          SUB      r0,r0,r1,ASR #2
;;;1115         pcb->sv += m;
0002d4  4408              ADD      r0,r0,r1
0002d6  f8a40042          STRH     r0,[r4,#0x42]
;;;1116         pcb->rto = (pcb->sa >> 3) + pcb->sv;
0002da  eb0000e2          ADD      r0,r0,r2,ASR #3
0002de  f8a40044          STRH     r0,[r4,#0x44]
;;;1117   
;;;1118         LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
;;;1119                                     pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));
;;;1120   
;;;1121         pcb->rttest = 0;
0002e2  63a6              STR      r6,[r4,#0x38]
                  |L6.740|
;;;1122       }
;;;1123     }
;;;1124   
;;;1125     /* If the incoming segment contains data, we must process it
;;;1126        further unless the pcb already received a FIN.
;;;1127        (RFC 793, chapeter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
;;;1128        LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
;;;1129     if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
0002e4  887a              LDRH     r2,[r7,#2]  ; tcplen
0002e6  2a00              CMP      r2,#0
0002e8  d07e              BEQ      |L6.1000|
0002ea  7e20              LDRB     r0,[r4,#0x18]
0002ec  2807              CMP      r0,#7
0002ee  d27b              BCS      |L6.1000|
;;;1130       /* This code basically does three things:
;;;1131   
;;;1132       +) If the incoming segment contains data that is the next
;;;1133       in-sequence data, this data is passed to the application. This
;;;1134       might involve trimming the first edge of the data. The rcv_nxt
;;;1135       variable and the advertised window are adjusted.
;;;1136   
;;;1137       +) If the incoming segment has data that is above the next
;;;1138       sequence number expected (->rcv_nxt), the segment is placed on
;;;1139       the ->ooseq queue. This is done by finding the appropriate
;;;1140       place in the ->ooseq queue (which is ordered by sequence
;;;1141       number) and trim the segment in both ends if needed. An
;;;1142       immediate ACK is sent to indicate that we received an
;;;1143       out-of-sequence segment.
;;;1144   
;;;1145       +) Finally, we check if the first segment on the ->ooseq queue
;;;1146       now is in sequence (i.e., if rcv_nxt >= ooseq->seqno). If
;;;1147       rcv_nxt > ooseq->seqno, we must trim the first edge of the
;;;1148       segment on ->ooseq before we adjust rcv_nxt. The data in the
;;;1149       segments that are now on sequence are chained onto the
;;;1150       incoming segment so that we only need to call the application
;;;1151       once.
;;;1152       */
;;;1153   
;;;1154       /* First, we check if we must trim the first edge. We have to do
;;;1155          this if the sequence number of the incoming segment is less
;;;1156          than rcv_nxt, and the sequence number plus the length of the
;;;1157          segment is larger than rcv_nxt. */
;;;1158       /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
;;;1159             if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
;;;1160       if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
0002f0  6aa1              LDR      r1,[r4,#0x28]
0002f2  68f8              LDR      r0,[r7,#0xc]  ; seqno
;;;1161         /* Trimming the first edge is done by pushing the payload
;;;1162            pointer in the pbuf downwards. This is somewhat tricky since
;;;1163            we do not want to discard the full contents of the pbuf up to
;;;1164            the new starting point of the data since we have to keep the
;;;1165            TCP header which is present in the first pbuf in the chain.
;;;1166   
;;;1167            What is done is really quite a nasty hack: the first pbuf in
;;;1168            the pbuf chain is pointed to by inseg.p. Since we need to be
;;;1169            able to deallocate the whole pbuf, we cannot change this
;;;1170            inseg.p pointer to point to any of the later pbufs in the
;;;1171            chain. Instead, we point the ->payload pointer in the first
;;;1172            pbuf to data in one of the later pbufs. We also set the
;;;1173            inseg.data pointer to point to the right place. This way, the
;;;1174            ->p pointer will still point to the first pbuf, but the
;;;1175            ->p->payload pointer will point to data in another pbuf.
;;;1176   
;;;1177            After we are done with adjusting the pbuf pointers we must
;;;1178            adjust the ->data pointer in the seg and the segment
;;;1179            length.*/
;;;1180   
;;;1181         off = pcb->rcv_nxt - seqno;
;;;1182         p = inseg.p;
0002f4  f8df9160          LDR      r9,|L6.1112|
0002f8  1a0d              SUBS     r5,r1,r0              ;1160
0002fa  46b8              MOV      r8,r7                 ;1160
0002fc  2d01              CMP      r5,#1                 ;1160
0002fe  d447              BMI      |L6.912|
000300  4402              ADD      r2,r2,r0              ;1160
000302  1a8a              SUBS     r2,r1,r2              ;1160
000304  1c52              ADDS     r2,r2,#1              ;1160
000306  2a00              CMP      r2,#0                 ;1160
000308  dc42              BGT      |L6.912|
;;;1183         LWIP_ASSERT("inseg.p != NULL", inseg.p);
00030a  f8d97004          LDR      r7,[r9,#4]  ; inseg
00030e  b917              CBNZ     r7,|L6.790|
000310  a052              ADR      r0,|L6.1116|
000312  f7fffffe          BL       __2printf
                  |L6.790|
;;;1184         LWIP_ASSERT("insane offset!", (off < 0x7fff));
000316  f64770ff          MOV      r0,#0x7fff
00031a  4285              CMP      r5,r0
00031c  db02              BLT      |L6.804|
00031e  a053              ADR      r0,|L6.1132|
000320  f7fffffe          BL       __2printf
                  |L6.804|
;;;1185         if (inseg.p->len < off) {
000324  f8d90004          LDR      r0,[r9,#4]  ; inseg
000328  8941              LDRH     r1,[r0,#0xa]
00032a  42a9              CMP      r1,r5
00032c  da2d              BGE      |L6.906|
;;;1186           LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
00032e  8900              LDRH     r0,[r0,#8]
000330  42a8              CMP      r0,r5
000332  da02              BGE      |L6.826|
000334  a051              ADR      r0,|L6.1148|
000336  f7fffffe          BL       __2printf
                  |L6.826|
;;;1187           new_tot_len = (u16_t)(inseg.p->tot_len - off);
00033a  f8d90004          LDR      r0,[r9,#4]  ; inseg
00033e  8900              LDRH     r0,[r0,#8]
000340  1b40              SUBS     r0,r0,r5
000342  b281              UXTH     r1,r0
;;;1188           while (p->len < off) {
000344  e003              B        |L6.846|
                  |L6.838|
;;;1189             off -= p->len;
;;;1190             /* KJM following line changed (with addition of new_tot_len var)
;;;1191                to fix bug #9076
;;;1192                inseg.p->tot_len -= p->len; */
;;;1193             p->tot_len = new_tot_len;
000346  8139              STRH     r1,[r7,#8]
;;;1194             p->len = 0;
000348  817e              STRH     r6,[r7,#0xa]
;;;1195             p = p->next;
00034a  683f              LDR      r7,[r7,#0]
00034c  1a2d              SUBS     r5,r5,r0              ;1189
                  |L6.846|
00034e  8978              LDRH     r0,[r7,#0xa]          ;1188
000350  42a8              CMP      r0,r5                 ;1188
000352  dbf8              BLT      |L6.838|
;;;1196           }
;;;1197           if(pbuf_header(p, (s16_t)-off)) {
000354  4268              RSBS     r0,r5,#0
000356  b201              SXTH     r1,r0
000358  4638              MOV      r0,r7
                  |L6.858|
;;;1198             /* Do we need to cope with this failing?  Assert for now */
;;;1199             LWIP_ASSERT("pbuf_header failed", 0);
;;;1200           }
;;;1201         } else {
;;;1202           if(pbuf_header(inseg.p, (s16_t)-off)) {
00035a  f7fffffe          BL       pbuf_header
00035e  b110              CBZ      r0,|L6.870|
;;;1203             /* Do we need to cope with this failing?  Assert for now */
;;;1204             LWIP_ASSERT("pbuf_header failed", 0);
000360  a04a              ADR      r0,|L6.1164|
000362  f7fffffe          BL       __2printf
                  |L6.870|
;;;1205           }
;;;1206         }
;;;1207         inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
000366  f8b8500c          LDRH     r5,[r8,#0xc]  ; seqno
00036a  6aa0              LDR      r0,[r4,#0x28]
00036c  f8b93008          LDRH     r3,[r9,#8]  ; inseg
000370  1b45              SUBS     r5,r0,r5
000372  1b5b              SUBS     r3,r3,r5
000374  f8a93008          STRH     r3,[r9,#8]
;;;1208         inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
000378  f8c8000c          STR      r0,[r8,#0xc]  ; seqno
00037c  f8d9100c          LDR      r1,[r9,#0xc]  ; inseg
000380  6048              STR      r0,[r1,#4]
;;;1209       }
;;;1210       else {
;;;1211         if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
;;;1212           /* the whole segment is < rcv_nxt */
;;;1213           /* must be a duplicate of a packet that has already been correctly handled */
;;;1214   
;;;1215           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
;;;1216           tcp_ack_now(pcb);
;;;1217         }
;;;1218       }
;;;1219   
;;;1220       /* The sequence number must be within the window (above rcv_nxt
;;;1221          and below rcv_nxt + rcv_wnd) in order to be further
;;;1222          processed. */
;;;1223       if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
000382  6aa1              LDR      r1,[r4,#0x28]
000384  1a40              SUBS     r0,r0,r1
000386  d50a              BPL      |L6.926|
                  |L6.904|
000388  e26f              B        |L6.2154|
                  |L6.906|
00038a  4269              RSBS     r1,r5,#0              ;1202
00038c  b209              SXTH     r1,r1                 ;1202
00038e  e7e4              B        |L6.858|
                  |L6.912|
000390  1a40              SUBS     r0,r0,r1              ;1211
000392  d504              BPL      |L6.926|
000394  7fa0              LDRB     r0,[r4,#0x1e]         ;1216
000396  f0400002          ORR      r0,r0,#2              ;1216
00039a  77a0              STRB     r0,[r4,#0x1e]         ;1216
00039c  e265              B        |L6.2154|
                  |L6.926|
00039e  4608              MOV      r0,r1
0003a0  8da1              LDRH     r1,[r4,#0x2c]
0003a2  4647              MOV      r7,r8
0003a4  1842              ADDS     r2,r0,r1
0003a6  f8d8100c          LDR      r1,[r8,#0xc]  ; seqno
0003aa  1a8a              SUBS     r2,r1,r2
0003ac  1c52              ADDS     r2,r2,#1
0003ae  2a00              CMP      r2,#0
0003b0  dcea              BGT      |L6.904|
;;;1224                           pcb->rcv_nxt + pcb->rcv_wnd - 1)){
;;;1225         if (pcb->rcv_nxt == seqno) {
0003b2  4288              CMP      r0,r1
0003b4  d119              BNE      |L6.1002|
;;;1226           /* The incoming segment is the next in sequence. We check if
;;;1227              we have to trim the end of the segment and update rcv_nxt
;;;1228              and pass the data to the application. */
;;;1229           tcplen = TCP_TCPLEN(&inseg);
0003b6  f8d9000c          LDR      r0,[r9,#0xc]  ; inseg
0003ba  464d              MOV      r5,r9
0003bc  8980              LDRH     r0,[r0,#0xc]
0003be  f7fffffe          BL       lwip_ntohs
0003c2  0780              LSLS     r0,r0,#30
0003c4  d000              BEQ      |L6.968|
0003c6  2001              MOVS     r0,#1
                  |L6.968|
0003c8  8929              LDRH     r1,[r5,#8]  ; inseg
0003ca  46a9              MOV      r9,r5
0003cc  4408              ADD      r0,r0,r1
0003ce  b280              UXTH     r0,r0
0003d0  8078              STRH     r0,[r7,#2]
;;;1230   
;;;1231           if (tcplen > pcb->rcv_wnd) {
0003d2  8da1              LDRH     r1,[r4,#0x2c]
0003d4  4281              CMP      r1,r0
0003d6  d27d              BCS      |L6.1236|
;;;1232             LWIP_DEBUGF(TCP_INPUT_DEBUG, 
;;;1233                         ("tcp_receive: other end overran receive window"
;;;1234                          "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
;;;1235                          seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
;;;1236             if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
0003d8  f8d9000c          LDR      r0,[r9,#0xc]  ; inseg
0003dc  464d              MOV      r5,r9
0003de  8980              LDRH     r0,[r0,#0xc]
0003e0  f7fffffe          BL       lwip_ntohs
0003e4  07c0              LSLS     r0,r0,#31
0003e6  e05b              B        |L6.1184|
                  |L6.1000|
0003e8  e244              B        |L6.2164|
                  |L6.1002|
0003ea  e188              B        |L6.1790|
                  |L6.1004|
0003ec  7463705f          DCB      "tcp_receive: wrong state",0
0003f0  72656365
0003f4  6976653a
0003f8  2077726f
0003fc  6e672073
000400  74617465
000404  00      
000405  00                DCB      0
000406  00                DCB      0
000407  00                DCB      0
                  |L6.1032|
                          DCD      ||.data||
                  |L6.1036|
00040c  7063622d          DCB      "pcb->snd_queuelen >= pbuf_clen(next->p)",0
000410  3e736e64
000414  5f717565
000418  75656c65
00041c  6e203e3d
000420  20706275
000424  665f636c
000428  656e286e
00042c  6578742d
000430  3e702900
                  |L6.1076|
000434  7463705f          DCB      "tcp_receive: valid queue length",0
000438  72656365
00043c  6976653a
000440  2076616c
000444  69642071
000448  75657565
00044c  206c656e
000450  67746800
                  |L6.1108|
                          DCD      tcp_ticks
                  |L6.1112|
                          DCD      ||.bss||
                  |L6.1116|
00045c  696e7365          DCB      "inseg.p != NULL",0
000460  672e7020
000464  213d204e
000468  554c4c00
                  |L6.1132|
00046c  696e7361          DCB      "insane offset!",0
000470  6e65206f
000474  66667365
000478  742100  
00047b  00                DCB      0
                  |L6.1148|
00047c  70627566          DCB      "pbuf too short!",0
000480  20746f6f
000484  2073686f
000488  72742100
                  |L6.1164|
00048c  70627566          DCB      "pbuf_header failed",0
000490  5f686561
000494  64657220
000498  6661696c
00049c  656400  
00049f  00                DCB      0
                  |L6.1184|
0004a0  d00e              BEQ      |L6.1216|
;;;1237               /* Must remove the FIN from the header as we're trimming 
;;;1238                * that byte of sequence-space from the packet */
;;;1239               TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
0004a2  68e8              LDR      r0,[r5,#0xc]  ; inseg
0004a4  8980              LDRH     r0,[r0,#0xc]
0004a6  f7fffffe          BL       lwip_ntohs
0004aa  f000003e          AND      r0,r0,#0x3e
0004ae  f7fffffe          BL       lwip_htons
0004b2  4601              MOV      r1,r0
0004b4  68e8              LDR      r0,[r5,#0xc]  ; inseg
0004b6  8982              LDRH     r2,[r0,#0xc]
0004b8  f422527c          BIC      r2,r2,#0x3f00
0004bc  4311              ORRS     r1,r1,r2
0004be  8181              STRH     r1,[r0,#0xc]
                  |L6.1216|
;;;1240             }
;;;1241             /* Adjust length of segment to fit in the window. */
;;;1242             inseg.len = pcb->rcv_wnd;
0004c0  8da0              LDRH     r0,[r4,#0x2c]
0004c2  8128              STRH     r0,[r5,#8]
;;;1243             if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
0004c4  68e8              LDR      r0,[r5,#0xc]  ; inseg
0004c6  8980              LDRH     r0,[r0,#0xc]
0004c8  f7fffffe          BL       lwip_ntohs
0004cc  0780              LSLS     r0,r0,#30
0004ce  d504              BPL      |L6.1242|
;;;1244               inseg.len -= 1;
0004d0  8928              LDRH     r0,[r5,#8]  ; inseg
0004d2  e000              B        |L6.1238|
                  |L6.1236|
0004d4  e01a              B        |L6.1292|
                  |L6.1238|
0004d6  1e40              SUBS     r0,r0,#1
0004d8  8128              STRH     r0,[r5,#8]
                  |L6.1242|
;;;1245             }
;;;1246             pbuf_realloc(inseg.p, inseg.len);
0004da  8929              LDRH     r1,[r5,#8]  ; inseg
0004dc  6868              LDR      r0,[r5,#4]  ; inseg
0004de  f7fffffe          BL       pbuf_realloc
;;;1247             tcplen = TCP_TCPLEN(&inseg);
0004e2  68e8              LDR      r0,[r5,#0xc]  ; inseg
0004e4  8980              LDRH     r0,[r0,#0xc]
0004e6  f7fffffe          BL       lwip_ntohs
0004ea  0780              LSLS     r0,r0,#30
0004ec  d000              BEQ      |L6.1264|
0004ee  2001              MOVS     r0,#1
                  |L6.1264|
0004f0  8929              LDRH     r1,[r5,#8]  ; inseg
0004f2  4408              ADD      r0,r0,r1
0004f4  b280              UXTH     r0,r0
0004f6  8078              STRH     r0,[r7,#2]
;;;1248             LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
0004f8  8da2              LDRH     r2,[r4,#0x2c]
0004fa  6aa1              LDR      r1,[r4,#0x28]
0004fc  4411              ADD      r1,r1,r2
0004fe  68fa              LDR      r2,[r7,#0xc]  ; seqno
000500  4410              ADD      r0,r0,r2
000502  4288              CMP      r0,r1
000504  d002              BEQ      |L6.1292|
000506  a0e2              ADR      r0,|L6.2192|
000508  f7fffffe          BL       __2printf
                  |L6.1292|
;;;1249                         (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
;;;1250           }
;;;1251   #if TCP_QUEUE_OOSEQ
;;;1252           /* Received in-sequence data, adjust ooseq data if:
;;;1253              - FIN has been received or
;;;1254              - inseq overlaps with ooseq */
;;;1255           if (pcb->ooseq != NULL) {
00050c  6f60              LDR      r0,[r4,#0x74]
00050e  b3e8              CBZ      r0,|L6.1420|
;;;1256             if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
000510  f8d9000c          LDR      r0,[r9,#0xc]  ; inseg
000514  8980              LDRH     r0,[r0,#0xc]
000516  f7fffffe          BL       lwip_ntohs
00051a  07c0              LSLS     r0,r0,#31
00051c  d104              BNE      |L6.1320|
00051e  e007              B        |L6.1328|
                  |L6.1312|
;;;1257               LWIP_DEBUGF(TCP_INPUT_DEBUG, 
;;;1258                           ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
;;;1259               /* Received in-order FIN means anything that was received
;;;1260                * out of order must now have been received in-order, so
;;;1261                * bin the ooseq queue */
;;;1262               while (pcb->ooseq != NULL) {
;;;1263                 struct tcp_seg *old_ooseq = pcb->ooseq;
;;;1264                 pcb->ooseq = pcb->ooseq->next;
000520  6801              LDR      r1,[r0,#0]
;;;1265                 tcp_seg_free(old_ooseq);
000522  6761              STR      r1,[r4,#0x74]
000524  f7fffffe          BL       tcp_seg_free
                  |L6.1320|
000528  6f60              LDR      r0,[r4,#0x74]         ;1262
00052a  2800              CMP      r0,#0                 ;1262
00052c  d1f8              BNE      |L6.1312|
00052e  e068              B        |L6.1538|
                  |L6.1328|
;;;1266               }
;;;1267             } else {
;;;1268               next = pcb->ooseq;
;;;1269               /* Remove all segments on ooseq that are covered by inseg already.
;;;1270                * FIN is copied from ooseq to inseg if present. */
;;;1271               while (next &&
000530  6f65              LDR      r5,[r4,#0x74]
000532  e021              B        |L6.1400|
                  |L6.1332|
;;;1272                      TCP_SEQ_GEQ(seqno + tcplen,
;;;1273                                  next->tcphdr->seqno + next->len)) {
;;;1274                 /* inseg cannot have FIN here (already processed above) */
;;;1275                 if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
000534  8980              LDRH     r0,[r0,#0xc]
000536  f7fffffe          BL       lwip_ntohs
00053a  07c0              LSLS     r0,r0,#31
00053c  d018              BEQ      |L6.1392|
;;;1276                     (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
00053e  f8d9000c          LDR      r0,[r9,#0xc]  ; inseg
000542  46c8              MOV      r8,r9
000544  8980              LDRH     r0,[r0,#0xc]
000546  f7fffffe          BL       lwip_ntohs
00054a  0780              LSLS     r0,r0,#30
00054c  d410              BMI      |L6.1392|
;;;1277                   TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
00054e  2001              MOVS     r0,#1
000550  f7fffffe          BL       lwip_htons
000554  f8d8100c          LDR      r1,[r8,#0xc]  ; inseg
000558  898a              LDRH     r2,[r1,#0xc]
00055a  4310              ORRS     r0,r0,r2
00055c  8188              STRH     r0,[r1,#0xc]
;;;1278                   tcplen = TCP_TCPLEN(&inseg);
00055e  f7fffffe          BL       lwip_ntohs
000562  0780              LSLS     r0,r0,#30
000564  d000              BEQ      |L6.1384|
000566  2001              MOVS     r0,#1
                  |L6.1384|
000568  f8b81008          LDRH     r1,[r8,#8]  ; inseg
00056c  4408              ADD      r0,r0,r1
00056e  8078              STRH     r0,[r7,#2]
                  |L6.1392|
;;;1279                 }
;;;1280                 prev = next;
;;;1281                 next = next->next;
000570  4628              MOV      r0,r5
000572  682d              LDR      r5,[r5,#0]
;;;1282                 tcp_seg_free(prev);
000574  f7fffffe          BL       tcp_seg_free
                  |L6.1400|
000578  b3f5              CBZ      r5,|L6.1528|
00057a  68e8              LDR      r0,[r5,#0xc]          ;1272
00057c  892a              LDRH     r2,[r5,#8]            ;1272
00057e  887b              LDRH     r3,[r7,#2]            ;1272  ; tcplen
000580  6841              LDR      r1,[r0,#4]            ;1272
000582  4411              ADD      r1,r1,r2              ;1272
000584  68fa              LDR      r2,[r7,#0xc]          ;1272  ; seqno
000586  441a              ADD      r2,r2,r3              ;1272
000588  1a51              SUBS     r1,r2,r1              ;1272
00058a  e000              B        |L6.1422|
                  |L6.1420|
00058c  e039              B        |L6.1538|
                  |L6.1422|
00058e  d5d1              BPL      |L6.1332|
;;;1283               }
;;;1284               /* Now trim right side of inseg if it overlaps with the first
;;;1285                * segment on ooseq */
;;;1286               if (next &&
;;;1287                   TCP_SEQ_GT(seqno + tcplen,
000590  68f9              LDR      r1,[r7,#0xc]  ; seqno
000592  b298              UXTH     r0,r3
000594  180a              ADDS     r2,r1,r0
000596  68e8              LDR      r0,[r5,#0xc]
000598  6840              LDR      r0,[r0,#4]
00059a  1a12              SUBS     r2,r2,r0
00059c  2a00              CMP      r2,#0
00059e  dd2f              BLE      |L6.1536|
;;;1288                              next->tcphdr->seqno)) {
;;;1289                 /* inseg cannot have FIN here (already processed above) */
;;;1290                 inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
0005a0  1a41              SUBS     r1,r0,r1
0005a2  f8a91008          STRH     r1,[r9,#8]
;;;1291                 if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
0005a6  f8d9000c          LDR      r0,[r9,#0xc]  ; inseg
0005aa  46b8              MOV      r8,r7                 ;1290
0005ac  8980              LDRH     r0,[r0,#0xc]
0005ae  f7fffffe          BL       lwip_ntohs
0005b2  0780              LSLS     r0,r0,#30
0005b4  d504              BPL      |L6.1472|
;;;1292                   inseg.len -= 1;
0005b6  f8b90008          LDRH     r0,[r9,#8]  ; inseg
0005ba  1e40              SUBS     r0,r0,#1
0005bc  f8a90008          STRH     r0,[r9,#8]
                  |L6.1472|
;;;1293                 }
;;;1294                 pbuf_realloc(inseg.p, inseg.len);
0005c0  f8b91008          LDRH     r1,[r9,#8]  ; inseg
0005c4  f8d90004          LDR      r0,[r9,#4]  ; inseg
0005c8  f7fffffe          BL       pbuf_realloc
;;;1295                 tcplen = TCP_TCPLEN(&inseg);
0005cc  f8d9000c          LDR      r0,[r9,#0xc]  ; inseg
0005d0  8980              LDRH     r0,[r0,#0xc]
0005d2  f7fffffe          BL       lwip_ntohs
0005d6  0780              LSLS     r0,r0,#30
0005d8  d000              BEQ      |L6.1500|
0005da  2001              MOVS     r0,#1
                  |L6.1500|
0005dc  f8b91008          LDRH     r1,[r9,#8]  ; inseg
0005e0  4408              ADD      r0,r0,r1
0005e2  b280              UXTH     r0,r0
0005e4  f8a80002          STRH     r0,[r8,#2]
;;;1296                 LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
0005e8  f8d8100c          LDR      r1,[r8,#0xc]  ; seqno
0005ec  4408              ADD      r0,r0,r1
0005ee  68e9              LDR      r1,[r5,#0xc]
0005f0  6849              LDR      r1,[r1,#4]
0005f2  4288              CMP      r0,r1
0005f4  d004              BEQ      |L6.1536|
0005f6  e000              B        |L6.1530|
                  |L6.1528|
0005f8  e002              B        |L6.1536|
                  |L6.1530|
0005fa  a0b3              ADR      r0,|L6.2248|
0005fc  f7fffffe          BL       __2printf
                  |L6.1536|
;;;1297                             (seqno + tcplen) == next->tcphdr->seqno);
;;;1298               }
;;;1299               pcb->ooseq = next;
000600  6765              STR      r5,[r4,#0x74]
                  |L6.1538|
;;;1300             }
;;;1301           }
;;;1302   #endif /* TCP_QUEUE_OOSEQ */
;;;1303   
;;;1304           pcb->rcv_nxt = seqno + tcplen;
000602  8878              LDRH     r0,[r7,#2]  ; tcplen
000604  68f9              LDR      r1,[r7,#0xc]  ; seqno
000606  4401              ADD      r1,r1,r0
;;;1305   
;;;1306           /* Update the receiver's (our) window. */
;;;1307           LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
000608  62a1              STR      r1,[r4,#0x28]
00060a  8da1              LDRH     r1,[r4,#0x2c]
00060c  4281              CMP      r1,r0
00060e  d202              BCS      |L6.1558|
000610  a0bc              ADR      r0,|L6.2308|
000612  f7fffffe          BL       __2printf
                  |L6.1558|
;;;1308           pcb->rcv_wnd -= tcplen;
000616  8da0              LDRH     r0,[r4,#0x2c]
000618  8879              LDRH     r1,[r7,#2]  ; tcplen
00061a  1a40              SUBS     r0,r0,r1
00061c  85a0              STRH     r0,[r4,#0x2c]
;;;1309   
;;;1310           tcp_update_rcv_ann_wnd(pcb);
00061e  4620              MOV      r0,r4
000620  f7fffffe          BL       tcp_update_rcv_ann_wnd
;;;1311   
;;;1312           /* If there is data in the segment, we make preparations to
;;;1313              pass this up to the application. The ->recv_data variable
;;;1314              is used for holding the pbuf that goes to the
;;;1315              application. The code for reassembling out-of-sequence data
;;;1316              chains its data on this pbuf as well.
;;;1317   
;;;1318              If the segment was a FIN, we set the TF_GOT_FIN flag that will
;;;1319              be used to indicate to the application that the remote side has
;;;1320              closed its end of the connection. */
;;;1321           if (inseg.p->tot_len > 0) {
000624  f8d90004          LDR      r0,[r9,#4]  ; inseg
000628  4649              MOV      r1,r9
00062a  8902              LDRH     r2,[r0,#8]
00062c  b10a              CBZ      r2,|L6.1586|
;;;1322             recv_data = inseg.p;
;;;1323             /* Since this pbuf now is the responsibility of the
;;;1324                application, we delete our reference to it so that we won't
;;;1325                (mistakingly) deallocate it. */
;;;1326             inseg.p = NULL;
00062e  6178              STR      r0,[r7,#0x14]  ; recv_data
000630  604e              STR      r6,[r1,#4]  ; inseg
                  |L6.1586|
;;;1327           }
;;;1328           if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
000632  f8d9000c          LDR      r0,[r9,#0xc]  ; inseg
000636  8980              LDRH     r0,[r0,#0xc]
000638  f7fffffe          BL       lwip_ntohs
00063c  07c0              LSLS     r0,r0,#31
00063e  d04c              BEQ      |L6.1754|
;;;1329             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
;;;1330             recv_flags |= TF_GOT_FIN;
000640  7878              LDRB     r0,[r7,#1]  ; recv_flags
000642  f0400020          ORR      r0,r0,#0x20
000646  7078              STRB     r0,[r7,#1]
000648  e047              B        |L6.1754|
                  |L6.1610|
;;;1331           }
;;;1332   
;;;1333   #if TCP_QUEUE_OOSEQ
;;;1334           /* We now check if we have segments on the ->ooseq queue that
;;;1335              are now in sequence. */
;;;1336           while (pcb->ooseq != NULL &&
;;;1337                  pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
;;;1338   
;;;1339             cseg = pcb->ooseq;
;;;1340             seqno = pcb->ooseq->tcphdr->seqno;
;;;1341   
;;;1342             pcb->rcv_nxt += TCP_TCPLEN(cseg);
00064a  60f9              STR      r1,[r7,#0xc]  ; seqno
00064c  8980              LDRH     r0,[r0,#0xc]
00064e  f7fffffe          BL       lwip_ntohs
000652  0780              LSLS     r0,r0,#30
000654  d000              BEQ      |L6.1624|
000656  2001              MOVS     r0,#1
                  |L6.1624|
000658  892a              LDRH     r2,[r5,#8]
00065a  6aa1              LDR      r1,[r4,#0x28]
00065c  4411              ADD      r1,r1,r2
00065e  4408              ADD      r0,r0,r1
;;;1343             LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
000660  62a0              STR      r0,[r4,#0x28]
000662  68e8              LDR      r0,[r5,#0xc]
000664  8980              LDRH     r0,[r0,#0xc]
000666  f7fffffe          BL       lwip_ntohs
00066a  0780              LSLS     r0,r0,#30
00066c  d000              BEQ      |L6.1648|
00066e  2001              MOVS     r0,#1
                  |L6.1648|
000670  8929              LDRH     r1,[r5,#8]
000672  4408              ADD      r0,r0,r1
000674  8da1              LDRH     r1,[r4,#0x2c]
000676  4288              CMP      r0,r1
000678  d902              BLS      |L6.1664|
00067a  a0aa              ADR      r0,|L6.2340|
00067c  f7fffffe          BL       __2printf
                  |L6.1664|
;;;1344                         pcb->rcv_wnd >= TCP_TCPLEN(cseg));
;;;1345             pcb->rcv_wnd -= TCP_TCPLEN(cseg);
000680  68e8              LDR      r0,[r5,#0xc]
000682  8980              LDRH     r0,[r0,#0xc]
000684  f7fffffe          BL       lwip_ntohs
000688  0780              LSLS     r0,r0,#30
00068a  d000              BEQ      |L6.1678|
00068c  2001              MOVS     r0,#1
                  |L6.1678|
00068e  8929              LDRH     r1,[r5,#8]
000690  4408              ADD      r0,r0,r1
000692  8da1              LDRH     r1,[r4,#0x2c]
000694  1a08              SUBS     r0,r1,r0
000696  85a0              STRH     r0,[r4,#0x2c]
;;;1346   
;;;1347             tcp_update_rcv_ann_wnd(pcb);
000698  4620              MOV      r0,r4
00069a  f7fffffe          BL       tcp_update_rcv_ann_wnd
;;;1348   
;;;1349             if (cseg->p->tot_len > 0) {
00069e  6869              LDR      r1,[r5,#4]
0006a0  8908              LDRH     r0,[r1,#8]
0006a2  b130              CBZ      r0,|L6.1714|
;;;1350               /* Chain this pbuf onto the pbuf that we will pass to
;;;1351                  the application. */
;;;1352               if (recv_data) {
0006a4  6978              LDR      r0,[r7,#0x14]  ; recv_data
0006a6  b110              CBZ      r0,|L6.1710|
;;;1353                 pbuf_cat(recv_data, cseg->p);
0006a8  f7fffffe          BL       pbuf_cat
0006ac  e000              B        |L6.1712|
                  |L6.1710|
;;;1354               } else {
;;;1355                 recv_data = cseg->p;
0006ae  6179              STR      r1,[r7,#0x14]  ; recv_data
                  |L6.1712|
;;;1356               }
;;;1357               cseg->p = NULL;
0006b0  606e              STR      r6,[r5,#4]
                  |L6.1714|
;;;1358             }
;;;1359             if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
0006b2  68e8              LDR      r0,[r5,#0xc]
0006b4  8980              LDRH     r0,[r0,#0xc]
0006b6  f7fffffe          BL       lwip_ntohs
0006ba  07c0              LSLS     r0,r0,#31
0006bc  d008              BEQ      |L6.1744|
;;;1360               LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
;;;1361               recv_flags |= TF_GOT_FIN;
0006be  7878              LDRB     r0,[r7,#1]  ; recv_flags
0006c0  f0400020          ORR      r0,r0,#0x20
0006c4  7078              STRB     r0,[r7,#1]
;;;1362               if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
0006c6  7e20              LDRB     r0,[r4,#0x18]
0006c8  2804              CMP      r0,#4
0006ca  d101              BNE      |L6.1744|
;;;1363                 pcb->state = CLOSE_WAIT;
0006cc  2007              MOVS     r0,#7
0006ce  7620              STRB     r0,[r4,#0x18]
                  |L6.1744|
;;;1364               } 
;;;1365             }
;;;1366   
;;;1367             pcb->ooseq = cseg->next;
0006d0  6828              LDR      r0,[r5,#0]
;;;1368             tcp_seg_free(cseg);
0006d2  6760              STR      r0,[r4,#0x74]
0006d4  4628              MOV      r0,r5
0006d6  f7fffffe          BL       tcp_seg_free
                  |L6.1754|
0006da  6f65              LDR      r5,[r4,#0x74]         ;1336
0006dc  b125              CBZ      r5,|L6.1768|
0006de  68e8              LDR      r0,[r5,#0xc]          ;1337
0006e0  6aa2              LDR      r2,[r4,#0x28]         ;1337
0006e2  6841              LDR      r1,[r0,#4]            ;1337
0006e4  4291              CMP      r1,r2                 ;1337
0006e6  d0b0              BEQ      |L6.1610|
                  |L6.1768|
;;;1369           }
;;;1370   #endif /* TCP_QUEUE_OOSEQ */
;;;1371   
;;;1372   
;;;1373           /* Acknowledge the segment(s). */
;;;1374           tcp_ack(pcb);
0006e8  7fa0              LDRB     r0,[r4,#0x1e]
0006ea  07c1              LSLS     r1,r0,#31
0006ec  d002              BEQ      |L6.1780|
0006ee  f0200001          BIC      r0,r0,#1
0006f2  e0ca              B        |L6.2186|
                  |L6.1780|
0006f4  f0400001          ORR      r0,r0,#1
                  |L6.1784|
0006f8  77a0              STRB     r0,[r4,#0x1e]
                  |L6.1786|
;;;1375   
;;;1376         } else {
;;;1377           /* We get here if the incoming segment is out-of-sequence. */
;;;1378           tcp_send_empty_ack(pcb);
;;;1379   #if TCP_QUEUE_OOSEQ
;;;1380           /* We queue the segment on the ->ooseq queue. */
;;;1381           if (pcb->ooseq == NULL) {
;;;1382             pcb->ooseq = tcp_seg_copy(&inseg);
;;;1383           } else {
;;;1384             /* If the queue is not empty, we walk through the queue and
;;;1385                try to find a place where the sequence number of the
;;;1386                incoming segment is between the sequence numbers of the
;;;1387                previous and the next segment on the ->ooseq queue. That is
;;;1388                the place where we put the incoming segment. If needed, we
;;;1389                trim the second edges of the previous and the incoming
;;;1390                segment so that it will fit into the sequence.
;;;1391   
;;;1392                If the incoming segment has the same sequence number as a
;;;1393                segment on the ->ooseq queue, we discard the segment that
;;;1394                contains less data. */
;;;1395   
;;;1396             prev = NULL;
;;;1397             for(next = pcb->ooseq; next != NULL; next = next->next) {
;;;1398               if (seqno == next->tcphdr->seqno) {
;;;1399                 /* The sequence number of the incoming segment is the
;;;1400                    same as the sequence number of the segment on
;;;1401                    ->ooseq. We check the lengths to see which one to
;;;1402                    discard. */
;;;1403                 if (inseg.len > next->len) {
;;;1404                   /* The incoming segment is larger than the old
;;;1405                      segment. We replace some segments with the new
;;;1406                      one. */
;;;1407                   cseg = tcp_seg_copy(&inseg);
;;;1408                   if (cseg != NULL) {
;;;1409                     if (prev != NULL) {
;;;1410                       prev->next = cseg;
;;;1411                     } else {
;;;1412                       pcb->ooseq = cseg;
;;;1413                     }
;;;1414                     tcp_oos_insert_segment(cseg, next);
;;;1415                   }
;;;1416                   break;
;;;1417                 } else {
;;;1418                   /* Either the lenghts are the same or the incoming
;;;1419                      segment was smaller than the old one; in either
;;;1420                      case, we ditch the incoming segment. */
;;;1421                   break;
;;;1422                 }
;;;1423               } else {
;;;1424                 if (prev == NULL) {
;;;1425                   if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
;;;1426                     /* The sequence number of the incoming segment is lower
;;;1427                        than the sequence number of the first segment on the
;;;1428                        queue. We put the incoming segment first on the
;;;1429                        queue. */
;;;1430                     cseg = tcp_seg_copy(&inseg);
;;;1431                     if (cseg != NULL) {
;;;1432                       pcb->ooseq = cseg;
;;;1433                       tcp_oos_insert_segment(cseg, next);
;;;1434                     }
;;;1435                     break;
;;;1436                   }
;;;1437                 } else {
;;;1438                   /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
;;;1439                     TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
;;;1440                   if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
;;;1441                     /* The sequence number of the incoming segment is in
;;;1442                        between the sequence numbers of the previous and
;;;1443                        the next segment on ->ooseq. We trim trim the previous
;;;1444                        segment, delete next segments that included in received segment
;;;1445                        and trim received, if needed. */
;;;1446                     cseg = tcp_seg_copy(&inseg);
;;;1447                     if (cseg != NULL) {
;;;1448                       if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
;;;1449                         /* We need to trim the prev segment. */
;;;1450                         prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
;;;1451                         pbuf_realloc(prev->p, prev->len);
;;;1452                       }
;;;1453                       prev->next = cseg;
;;;1454                       tcp_oos_insert_segment(cseg, next);
;;;1455                     }
;;;1456                     break;
;;;1457                   }
;;;1458                 }
;;;1459                 /* If the "next" segment is the last segment on the
;;;1460                    ooseq queue, we add the incoming segment to the end
;;;1461                    of the list. */
;;;1462                 if (next->next == NULL &&
;;;1463                     TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
;;;1464                   if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
;;;1465                     /* segment "next" already contains all data */
;;;1466                     break;
;;;1467                   }
;;;1468                   next->next = tcp_seg_copy(&inseg);
;;;1469                   if (next->next != NULL) {
;;;1470                     if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
;;;1471                       /* We need to trim the last segment. */
;;;1472                       next->len = (u16_t)(seqno - next->tcphdr->seqno);
;;;1473                       pbuf_realloc(next->p, next->len);
;;;1474                     }
;;;1475                     /* check if the remote side overruns our receive window */
;;;1476                     if ((u32_t)tcplen + seqno > pcb->rcv_nxt + (u32_t)pcb->rcv_wnd) {
;;;1477                       LWIP_DEBUGF(TCP_INPUT_DEBUG, 
;;;1478                                   ("tcp_receive: other end overran receive window"
;;;1479                                    "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
;;;1480                                    seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
;;;1481                       if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
;;;1482                         /* Must remove the FIN from the header as we're trimming 
;;;1483                          * that byte of sequence-space from the packet */
;;;1484                         TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) &~ TCP_FIN);
;;;1485                       }
;;;1486                       /* Adjust length of segment to fit in the window. */
;;;1487                       next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
;;;1488                       pbuf_realloc(next->next->p, next->next->len);
;;;1489                       tcplen = TCP_TCPLEN(next->next);
;;;1490                       LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
;;;1491                                   (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
;;;1492                     }
;;;1493                   }
;;;1494                   break;
;;;1495                 }
;;;1496               }
;;;1497               prev = next;
;;;1498             }
;;;1499           }
;;;1500   #if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
;;;1501           /* Check that the data on ooseq doesn't exceed one of the limits
;;;1502              and throw away everything above that limit. */
;;;1503           ooseq_blen = 0;
;;;1504           ooseq_qlen = 0;
;;;1505           prev = NULL;
;;;1506           for(next = pcb->ooseq; next != NULL; prev = next, next = next->next) {
;;;1507             struct pbuf *p = next->p;
;;;1508             ooseq_blen += p->tot_len;
;;;1509             ooseq_qlen += pbuf_clen(p);
;;;1510             if ((ooseq_blen > TCP_OOSEQ_MAX_BYTES) ||
;;;1511                 (ooseq_qlen > TCP_OOSEQ_MAX_PBUFS)) {
;;;1512                /* too much ooseq data, dump this and everything after it */
;;;1513                tcp_segs_free(next);
;;;1514                if (prev == NULL) {
;;;1515                  /* first ooseq segment is too much, dump the whole queue */
;;;1516                  pcb->ooseq = NULL;
;;;1517                } else {
;;;1518                  /* just dump 'next' and everything after it */
;;;1519                  prev->next = NULL;
;;;1520                }
;;;1521                break;
;;;1522             }
;;;1523           }
;;;1524   #endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
;;;1525   #endif /* TCP_QUEUE_OOSEQ */
;;;1526         }
;;;1527       } else {
;;;1528         /* The incoming segment is not withing the window. */
;;;1529         tcp_send_empty_ack(pcb);
;;;1530       }
;;;1531     } else {
;;;1532       /* Segments with length 0 is taken care of here. Segments that
;;;1533          fall out of the window are ACKed. */
;;;1534       /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
;;;1535         TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
;;;1536       if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
;;;1537         tcp_ack_now(pcb);
;;;1538       }
;;;1539     }
;;;1540   }
0006fa  e8bd87f0          POP      {r4-r10,pc}
                  |L6.1790|
0006fe  4620              MOV      r0,r4                 ;1378
000700  f7fffffe          BL       tcp_send_empty_ack
000704  6f65              LDR      r5,[r4,#0x74]         ;1381
000706  b19d              CBZ      r5,|L6.1840|
000708  68f8              LDR      r0,[r7,#0xc]          ;879
00070a  2600              MOVS     r6,#0                 ;1396
                  |L6.1804|
00070c  68e9              LDR      r1,[r5,#0xc]          ;1398
00070e  6849              LDR      r1,[r1,#4]            ;1398
000710  4281              CMP      r1,r0                 ;1398
000712  d112              BNE      |L6.1850|
000714  f8b90008          LDRH     r0,[r9,#8]            ;1403  ; inseg
000718  8929              LDRH     r1,[r5,#8]            ;1403
00071a  4288              CMP      r0,r1                 ;1403
00071c  d9ed              BLS      |L6.1786|
00071e  488b              LDR      r0,|L6.2380|
000720  f7fffffe          BL       tcp_seg_copy
000724  2800              CMP      r0,#0                 ;1408
000726  d0e8              BEQ      |L6.1786|
000728  b396              CBZ      r6,|L6.1936|
00072a  6030              STR      r0,[r6,#0]            ;1410
                  |L6.1836|
00072c  4629              MOV      r1,r5                 ;1414
00072e  e024              B        |L6.1914|
                  |L6.1840|
000730  4886              LDR      r0,|L6.2380|
000732  f7fffffe          BL       tcp_seg_copy
000736  6760              STR      r0,[r4,#0x74]         ;1382
000738  e7df              B        |L6.1786|
                  |L6.1850|
00073a  b316              CBZ      r6,|L6.1922|
00073c  68f2              LDR      r2,[r6,#0xc]          ;1440
00073e  6852              LDR      r2,[r2,#4]            ;1440
000740  1a82              SUBS     r2,r0,r2              ;1440
000742  2a01              CMP      r2,#1                 ;1440
000744  d426              BMI      |L6.1940|
000746  1a42              SUBS     r2,r0,r1              ;1440
000748  1c52              ADDS     r2,r2,#1              ;1440
00074a  2a00              CMP      r2,#0                 ;1440
00074c  dc22              BGT      |L6.1940|
00074e  487f              LDR      r0,|L6.2380|
000750  f7fffffe          BL       tcp_seg_copy
000754  0004              MOVS     r4,r0                 ;1446
000756  d0d0              BEQ      |L6.1786|
000758  68f0              LDR      r0,[r6,#0xc]          ;1448
00075a  8931              LDRH     r1,[r6,#8]            ;1448
00075c  6840              LDR      r0,[r0,#4]            ;1448
00075e  1842              ADDS     r2,r0,r1              ;1448
000760  68f9              LDR      r1,[r7,#0xc]          ;1448  ; seqno
000762  1a52              SUBS     r2,r2,r1              ;1448
000764  2a00              CMP      r2,#0                 ;1448
000766  dd05              BLE      |L6.1908|
000768  1a08              SUBS     r0,r1,r0              ;1450
00076a  b281              UXTH     r1,r0                 ;1450
00076c  8131              STRH     r1,[r6,#8]            ;1450
00076e  6870              LDR      r0,[r6,#4]            ;1451
000770  f7fffffe          BL       pbuf_realloc
                  |L6.1908|
000774  4629              MOV      r1,r5                 ;1454
000776  4620              MOV      r0,r4                 ;1454
000778  6034              STR      r4,[r6,#0]            ;1454
                  |L6.1914|
00077a  e8bd47f0          POP      {r4-r10,lr}           ;1454
00077e  f7ffbffe          B.W      tcp_oos_insert_segment
                  |L6.1922|
000782  1a42              SUBS     r2,r0,r1              ;1425
000784  d506              BPL      |L6.1940|
000786  4871              LDR      r0,|L6.2380|
000788  f7fffffe          BL       tcp_seg_copy
00078c  2800              CMP      r0,#0                 ;1431
                  |L6.1934|
00078e  d0b4              BEQ      |L6.1786|
                  |L6.1936|
000790  6760              STR      r0,[r4,#0x74]         ;1433
000792  e7cb              B        |L6.1836|
                  |L6.1940|
000794  682a              LDR      r2,[r5,#0]            ;1462
000796  bbea              CBNZ     r2,|L6.2068|
000798  1a41              SUBS     r1,r0,r1              ;1463
00079a  2900              CMP      r1,#0                 ;1463
00079c  dd60              BLE      |L6.2144|
00079e  68e8              LDR      r0,[r5,#0xc]          ;1464
0007a0  8980              LDRH     r0,[r0,#0xc]          ;1464
0007a2  f7fffffe          BL       lwip_ntohs
0007a6  07c0              LSLS     r0,r0,#31             ;1464
0007a8  d1a7              BNE      |L6.1786|
0007aa  4868              LDR      r0,|L6.2380|
0007ac  f7fffffe          BL       tcp_seg_copy
0007b0  6028              STR      r0,[r5,#0]            ;1469
0007b2  2800              CMP      r0,#0                 ;1469
0007b4  d0a1              BEQ      |L6.1786|
0007b6  68e8              LDR      r0,[r5,#0xc]          ;1470
0007b8  6841              LDR      r1,[r0,#4]            ;1470
0007ba  8928              LDRH     r0,[r5,#8]            ;1470
0007bc  180a              ADDS     r2,r1,r0              ;1470
0007be  68f8              LDR      r0,[r7,#0xc]          ;1470  ; seqno
0007c0  1a12              SUBS     r2,r2,r0              ;1470
0007c2  2a00              CMP      r2,#0                 ;1470
0007c4  dd05              BLE      |L6.2002|
0007c6  1a40              SUBS     r0,r0,r1              ;1472
0007c8  b281              UXTH     r1,r0                 ;1472
0007ca  8129              STRH     r1,[r5,#8]            ;1472
0007cc  6868              LDR      r0,[r5,#4]            ;1473
0007ce  f7fffffe          BL       pbuf_realloc
                  |L6.2002|
0007d2  8da1              LDRH     r1,[r4,#0x2c]         ;1476
0007d4  6aa0              LDR      r0,[r4,#0x28]         ;1476
0007d6  68fa              LDR      r2,[r7,#0xc]          ;1476  ; seqno
0007d8  4408              ADD      r0,r0,r1              ;1476
0007da  8879              LDRH     r1,[r7,#2]            ;1476  ; tcplen
0007dc  4411              ADD      r1,r1,r2              ;1476
0007de  4288              CMP      r0,r1                 ;1476
0007e0  d28b              BCS      |L6.1786|
0007e2  6828              LDR      r0,[r5,#0]            ;1481
0007e4  68c0              LDR      r0,[r0,#0xc]          ;1481
0007e6  8980              LDRH     r0,[r0,#0xc]          ;1481
0007e8  f7fffffe          BL       lwip_ntohs
0007ec  07c0              LSLS     r0,r0,#31             ;1481
0007ee  d010              BEQ      |L6.2066|
0007f0  6828              LDR      r0,[r5,#0]            ;1484
0007f2  68c0              LDR      r0,[r0,#0xc]          ;1484
0007f4  8980              LDRH     r0,[r0,#0xc]          ;1484
0007f6  f7fffffe          BL       lwip_ntohs
0007fa  f000003e          AND      r0,r0,#0x3e           ;1484
0007fe  f7fffffe          BL       lwip_htons
000802  4601              MOV      r1,r0                 ;1484
000804  6828              LDR      r0,[r5,#0]            ;1484
000806  68c0              LDR      r0,[r0,#0xc]          ;1484
000808  8982              LDRH     r2,[r0,#0xc]          ;1484
00080a  f422527c          BIC      r2,r2,#0x3f00         ;1484
00080e  4311              ORRS     r1,r1,r2              ;1484
000810  8181              STRH     r1,[r0,#0xc]          ;1484
                  |L6.2066|
000812  e000              B        |L6.2070|
                  |L6.2068|
000814  e024              B        |L6.2144|
                  |L6.2070|
000816  8d20              LDRH     r0,[r4,#0x28]         ;1487
000818  8da1              LDRH     r1,[r4,#0x2c]         ;1487
00081a  4408              ADD      r0,r0,r1              ;1487
00081c  89b9              LDRH     r1,[r7,#0xc]          ;1487  ; seqno
00081e  1a40              SUBS     r0,r0,r1              ;1487
000820  b281              UXTH     r1,r0                 ;1487
000822  6828              LDR      r0,[r5,#0]            ;1487
000824  8101              STRH     r1,[r0,#8]            ;1487
000826  6828              LDR      r0,[r5,#0]            ;1488
000828  6840              LDR      r0,[r0,#4]            ;1488
00082a  f7fffffe          BL       pbuf_realloc
00082e  6828              LDR      r0,[r5,#0]            ;1489
000830  68c0              LDR      r0,[r0,#0xc]          ;1489
000832  8980              LDRH     r0,[r0,#0xc]          ;1489
000834  f7fffffe          BL       lwip_ntohs
000838  0780              LSLS     r0,r0,#30             ;1489
00083a  d000              BEQ      |L6.2110|
00083c  2001              MOVS     r0,#1                 ;1489
                  |L6.2110|
00083e  6829              LDR      r1,[r5,#0]            ;1489
000840  8909              LDRH     r1,[r1,#8]            ;1489
000842  4408              ADD      r0,r0,r1              ;1489
000844  b280              UXTH     r0,r0                 ;1489
000846  8078              STRH     r0,[r7,#2]            ;1489
000848  8da2              LDRH     r2,[r4,#0x2c]         ;1490
00084a  6aa1              LDR      r1,[r4,#0x28]         ;1490
00084c  4411              ADD      r1,r1,r2              ;1490
00084e  68fa              LDR      r2,[r7,#0xc]          ;1490  ; seqno
000850  4410              ADD      r0,r0,r2              ;1490
000852  4288              CMP      r0,r1                 ;1490
000854  d09b              BEQ      |L6.1934|
000856  e8bd47f0          POP      {r4-r10,lr}           ;1490
00085a  a00d              ADR      r0,|L6.2192|
00085c  f7ffbffe          B.W      __2printf
                  |L6.2144|
000860  462e              MOV      r6,r5                 ;1497
000862  0015              MOVS     r5,r2                 ;1397
000864  f47faf52          BNE      |L6.1804|
                  |L6.2152|
000868  e747              B        |L6.1786|
                  |L6.2154|
00086a  4620              MOV      r0,r4                 ;1529
00086c  e8bd47f0          POP      {r4-r10,lr}           ;1529
000870  f7ffbffe          B.W      tcp_send_empty_ack
                  |L6.2164|
000874  6aa0              LDR      r0,[r4,#0x28]         ;1536
000876  68f9              LDR      r1,[r7,#0xc]          ;1536  ; seqno
000878  1a0a              SUBS     r2,r1,r0              ;1536
00087a  d405              BMI      |L6.2184|
00087c  8da2              LDRH     r2,[r4,#0x2c]         ;1536
00087e  4410              ADD      r0,r0,r2              ;1536
000880  1a08              SUBS     r0,r1,r0              ;1536
000882  1c40              ADDS     r0,r0,#1              ;1536
000884  2800              CMP      r0,#0                 ;1536
000886  ddef              BLE      |L6.2152|
                  |L6.2184|
000888  7fa0              LDRB     r0,[r4,#0x1e]         ;1537
                  |L6.2186|
00088a  f0400002          ORR      r0,r0,#2              ;1537
00088e  e733              B        |L6.1784|
;;;1541   
                          ENDP

                  |L6.2192|
000890  7463705f          DCB      "tcp_receive: segment not trimmed correctly to rcv_wnd\n"
000894  72656365
000898  6976653a
00089c  20736567
0008a0  6d656e74
0008a4  206e6f74
0008a8  20747269
0008ac  6d6d6564
0008b0  20636f72
0008b4  72656374
0008b8  6c792074
0008bc  6f207263
0008c0  765f776e
0008c4  640a    
0008c6  00                DCB      0
0008c7  00                DCB      0
                  |L6.2248|
0008c8  7463705f          DCB      "tcp_receive: segment not trimmed correctly to ooseq que"
0008cc  72656365
0008d0  6976653a
0008d4  20736567
0008d8  6d656e74
0008dc  206e6f74
0008e0  20747269
0008e4  6d6d6564
0008e8  20636f72
0008ec  72656374
0008f0  6c792074
0008f4  6f206f6f
0008f8  73657120
0008fc  717565  
0008ff  75650a00          DCB      "ue\n",0
000903  00                DCB      0
                  |L6.2308|
000904  7463705f          DCB      "tcp_receive: tcplen > rcv_wnd\n",0
000908  72656365
00090c  6976653a
000910  20746370
000914  6c656e20
000918  3e207263
00091c  765f776e
000920  640a00  
000923  00                DCB      0
                  |L6.2340|
000924  7463705f          DCB      "tcp_receive: ooseq tcplen > rcv_wnd\n",0
000928  72656365
00092c  6976653a
000930  206f6f73
000934  65712074
000938  63706c65
00093c  6e203e20
000940  7263765f
000944  776e640a
000948  00      
000949  00                DCB      0
00094a  00                DCB      0
00094b  00                DCB      0
                  |L6.2380|
                          DCD      ||.bss||

                          AREA ||i.tcp_timewait_input||, CODE, READONLY, ALIGN=2

                  tcp_timewait_input PROC
;;;533    static err_t
;;;534    tcp_timewait_input(struct tcp_pcb *pcb)
000000  b57c              PUSH     {r2-r6,lr}
;;;535    {
;;;536      /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
;;;537      /* RFC 793 3.9 Event Processing - Segment Arrives:
;;;538       * - first check sequence number - we skip that one in TIME_WAIT (always
;;;539       *   acceptable since we only send ACKs)
;;;540       * - second check the RST bit (... return) */
;;;541      if (flags & TCP_RST)  {
000002  4c16              LDR      r4,|L7.92|
000004  7822              LDRB     r2,[r4,#0]  ; flags
000006  0751              LSLS     r1,r2,#29
000008  d426              BMI      |L7.88|
00000a  4621              MOV      r1,r4
;;;542        return ERR_OK;
;;;543      }
;;;544      /* - fourth, check the SYN bit, */
;;;545      if (flags & TCP_SYN) {
00000c  0793              LSLS     r3,r2,#30
;;;546        /* If an incoming segment is not acceptable, an acknowledgment
;;;547           should be sent in reply */
;;;548        if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
;;;549          /* If the SYN is in the window it is an error, send a reset */
;;;550          tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
00000e  8849              LDRH     r1,[r1,#2]
000010  d514              BPL      |L7.60|
000012  6a83              LDR      r3,[r0,#0x28]         ;548
000014  68e2              LDR      r2,[r4,#0xc]          ;548  ; seqno
000016  1ad5              SUBS     r5,r2,r3              ;548
000018  d415              BMI      |L7.70|
00001a  8d85              LDRH     r5,[r0,#0x2c]         ;548
00001c  442b              ADD      r3,r3,r5              ;548
00001e  1ad3              SUBS     r3,r2,r3              ;548
000020  2b00              CMP      r3,#0                 ;548
000022  dc10              BGT      |L7.70|
000024  6860              LDR      r0,[r4,#4]  ; tcphdr
000026  4411              ADD      r1,r1,r2
000028  4a0e              LDR      r2,|L7.100|
00002a  8803              LDRH     r3,[r0,#0]
00002c  8840              LDRH     r0,[r0,#2]
00002e  e9cd0300          STRD     r0,r3,[sp,#0]
000032  4b0b              LDR      r3,|L7.96|
000034  6920              LDR      r0,[r4,#0x10]  ; ackno
000036  f7fffffe          BL       tcp_rst
;;;551            tcphdr->dest, tcphdr->src);
;;;552          return ERR_OK;
00003a  e00d              B        |L7.88|
                  |L7.60|
;;;553        }
;;;554      } else if (flags & TCP_FIN) {
00003c  07d2              LSLS     r2,r2,#31
00003e  d002              BEQ      |L7.70|
;;;555        /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
;;;556             Restart the 2 MSL time-wait timeout.*/
;;;557        pcb->tmr = tcp_ticks;
000040  4a09              LDR      r2,|L7.104|
000042  6812              LDR      r2,[r2,#0]  ; tcp_ticks
000044  6242              STR      r2,[r0,#0x24]
                  |L7.70|
;;;558      }
;;;559    
;;;560      if ((tcplen > 0))  {
000046  b139              CBZ      r1,|L7.88|
;;;561        /* Acknowledge data, FIN or out-of-window SYN */
;;;562        pcb->flags |= TF_ACK_NOW;
000048  7f81              LDRB     r1,[r0,#0x1e]
00004a  f0410102          ORR      r1,r1,#2
00004e  7781              STRB     r1,[r0,#0x1e]
;;;563        return tcp_output(pcb);
000050  e8bd407c          POP      {r2-r6,lr}
000054  f7ffbffe          B.W      tcp_output
                  |L7.88|
;;;564      }
;;;565      return ERR_OK;
000058  2000              MOVS     r0,#0
;;;566    }
00005a  bd7c              POP      {r2-r6,pc}
;;;567    
                          ENDP

                  |L7.92|
                          DCD      ||.data||
                  |L7.96|
                          DCD      current_iphdr_src
                  |L7.100|
                          DCD      current_iphdr_dest
                  |L7.104|
                          DCD      tcp_ticks

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  inseg
                          %        16

                          AREA ||.data||, DATA, ALIGN=2

                  flags
000000  00                DCB      0x00
                  recv_flags
000001  00                DCB      0x00
                  tcplen
000002  0000              DCB      0x00,0x00
                  tcphdr
                          DCD      0x00000000
                  iphdr
                          DCD      0x00000000
                  seqno
                          DCD      0x00000000
                  ackno
                          DCD      0x00000000
                  recv_data
                          DCD      0x00000000
                  tcp_input_pcb
                          DCD      0x00000000

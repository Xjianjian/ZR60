; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\mem.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\mem.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\ZR60_v1.0_freeRTOS -I..\..\Lwip\App -I..\..\Lwip\Bsp -I..\..\Lwip\Bsp\LAN8742A -I..\..\Lwip\lwip-1.4.1 -I..\..\Lwip\lwip-1.4.1\port -I..\..\Lwip\lwip-1.4.1\port\arch -I..\..\Lwip\lwip-1.4.1\port\Standalone -I..\..\Lwip\lwip-1.4.1\src\include -I..\..\Lwip\lwip-1.4.1\src\include\ipv4 -I..\..\Lwip\lwip-1.4.1\src\include\lwip -I..\..\Lwip\lwip-1.4.1\src\include\netif -I..\..\Ecal\BtnFltr -I..\..\Ecal\UartComn -I..\..\Ecal\MemIf -I..\..\APP -I..\..\APP\BlackListMng -I..\..\APP\SeverNewsPush -I..\..\APP\NewsPull -I..\..\Ecal -I..\..\Ecal\JsonIf -I..\..\Ecal\Mcu_Init -I..\..\Service -I..\..\Complex -I..\..\Complex\FATFS -I..\..\FreeRTOS\Source\include -I..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\FreeRTOS -I.\RTE\_ZR60 -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=..\..\output\mem.crf ..\..\Lwip\lwip-1.4.1\src\core\mem.c]
                          THUMB

                          AREA ||i.mem_calloc||, CODE, READONLY, ALIGN=1

                  mem_calloc PROC
;;;645     */
;;;646    void *mem_calloc(mem_size_t count, mem_size_t size)
000000  b570              PUSH     {r4-r6,lr}
;;;647    {
;;;648      void *p;
;;;649    
;;;650      /* allocate 'count' objects of size 'size' */
;;;651      p = mem_malloc(count * size);
000002  fb00f501          MUL      r5,r0,r1
000006  b2a8              UXTH     r0,r5
000008  f7fffffe          BL       mem_malloc
00000c  0004              MOVS     r4,r0
;;;652      if (p) {
00000e  d002              BEQ      |L1.22|
000010  4629              MOV      r1,r5
;;;653        /* zero the memory */
;;;654        memset(p, 0, count * size);
000012  f7fffffe          BL       __aeabi_memclr
                  |L1.22|
;;;655      }
;;;656      return p;
000016  4620              MOV      r0,r4
;;;657    }
000018  bd70              POP      {r4-r6,pc}
;;;658    
                          ENDP


                          AREA ||i.mem_free||, CODE, READONLY, ALIGN=2

                  mem_free PROC
;;;310    void
;;;311    mem_free(void *rmem)
000000  b570              PUSH     {r4-r6,lr}
;;;312    {
000002  0004              MOVS     r4,r0
000004  d026              BEQ      |L2.84|
;;;313      struct mem *mem;
;;;314      LWIP_MEM_FREE_DECL_PROTECT();
;;;315    
;;;316      if (rmem == NULL) {
;;;317        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
;;;318        return;
;;;319      }
;;;320      LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
000006  07a0              LSLS     r0,r4,#30
000008  d002              BEQ      |L2.16|
00000a  a013              ADR      r0,|L2.88|
00000c  f7fffffe          BL       __2printf
                  |L2.16|
;;;321    
;;;322      LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
000010  4d1a              LDR      r5,|L2.124|
000012  6828              LDR      r0,[r5,#0]  ; ram
000014  4284              CMP      r4,r0
000016  d302              BCC      |L2.30|
000018  6868              LDR      r0,[r5,#4]  ; ram_end
00001a  4284              CMP      r4,r0
00001c  d302              BCC      |L2.36|
                  |L2.30|
00001e  a018              ADR      r0,|L2.128|
000020  f7fffffe          BL       __2printf
                  |L2.36|
;;;323        (u8_t *)rmem < (u8_t *)ram_end);
;;;324    
;;;325      if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
000024  6828              LDR      r0,[r5,#0]  ; ram
000026  4284              CMP      r4,r0
000028  d314              BCC      |L2.84|
00002a  6868              LDR      r0,[r5,#4]  ; ram_end
00002c  4284              CMP      r4,r0
00002e  d211              BCS      |L2.84|
;;;326        SYS_ARCH_DECL_PROTECT(lev);
;;;327        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
;;;328        /* protect mem stats from concurrent access */
;;;329        SYS_ARCH_PROTECT(lev);
;;;330        MEM_STATS_INC(illegal);
;;;331        SYS_ARCH_UNPROTECT(lev);
;;;332        return;
;;;333      }
;;;334      /* protect the heap from concurrent access */
;;;335      LWIP_MEM_FREE_PROTECT();
;;;336      /* Get the corresponding struct mem ... */
;;;337      mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
;;;338      /* ... which has to be in a used state ... */
;;;339      LWIP_ASSERT("mem_free: mem->used", mem->used);
000030  f8140c04          LDRB     r0,[r4,#-4]
000034  3c08              SUBS     r4,r4,#8
000036  b910              CBNZ     r0,|L2.62|
000038  a017              ADR      r0,|L2.152|
00003a  f7fffffe          BL       __2printf
                  |L2.62|
;;;340      /* ... and is now unused. */
;;;341      mem->used = 0;
00003e  2000              MOVS     r0,#0
000040  7120              STRB     r0,[r4,#4]
;;;342    
;;;343      if (mem < lfree) {
000042  68a8              LDR      r0,[r5,#8]  ; lfree
000044  4284              CMP      r4,r0
000046  d200              BCS      |L2.74|
;;;344        /* the newly freed struct is now the lowest */
;;;345        lfree = mem;
000048  60ac              STR      r4,[r5,#8]  ; lfree
                  |L2.74|
;;;346      }
;;;347    
;;;348      MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
;;;349    
;;;350      /* finally, see if prev or next are free also */
;;;351      plug_holes(mem);
00004a  4620              MOV      r0,r4
00004c  e8bd4070          POP      {r4-r6,lr}
000050  f7ffbffe          B.W      plug_holes
                  |L2.84|
;;;352    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;353      mem_free_count = 1;
;;;354    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;355      LWIP_MEM_FREE_UNPROTECT();
;;;356    }
000054  bd70              POP      {r4-r6,pc}
;;;357    
                          ENDP

000056  0000              DCW      0x0000
                  |L2.88|
000058  6d656d5f          DCB      "mem_free: sanity check alignment",0
00005c  66726565
000060  3a207361
000064  6e697479
000068  20636865
00006c  636b2061
000070  6c69676e
000074  6d656e74
000078  00      
000079  00                DCB      0
00007a  00                DCB      0
00007b  00                DCB      0
                  |L2.124|
                          DCD      ||.data||
                  |L2.128|
000080  6d656d5f          DCB      "mem_free: legal memory",0
000084  66726565
000088  3a206c65
00008c  67616c20
000090  6d656d6f
000094  727900  
000097  00                DCB      0
                  |L2.152|
000098  6d656d5f          DCB      "mem_free: mem->used",0
00009c  66726565
0000a0  3a206d65
0000a4  6d2d3e75
0000a8  73656400

                          AREA ||i.mem_init||, CODE, READONLY, ALIGN=2

                  mem_init PROC
;;;273    void
;;;274    mem_init(void)
000000  480a              LDR      r0,|L3.44|
;;;275    {
000002  b510              PUSH     {r4,lr}
;;;276      struct mem *mem;
;;;277    
;;;278      LWIP_ASSERT("Sanity check alignment",
;;;279        (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);
;;;280    
;;;281      /* align the heap */
;;;282      ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
000004  4a0a              LDR      r2,|L3.48|
000006  f0200103          BIC      r1,r0,#3
;;;283      /* initialize the start of the heap */
;;;284      mem = (struct mem *)(void *)ram;
;;;285      mem->next = MEM_SIZE_ALIGNED;
00000a  f44f43a0          MOV      r3,#0x5000
00000e  6011              STR      r1,[r2,#0]  ; ram
000010  800b              STRH     r3,[r1,#0]
;;;286      mem->prev = 0;
000012  2400              MOVS     r4,#0
000014  804c              STRH     r4,[r1,#2]
;;;287      mem->used = 0;
000016  710c              STRB     r4,[r1,#4]
;;;288      /* initialize the end of the heap */
;;;289      ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
000018  f50140a0          ADD      r0,r1,#0x5000
;;;290      ram_end->used = 1;
00001c  2401              MOVS     r4,#1
00001e  6050              STR      r0,[r2,#4]  ; ram_end
000020  7104              STRB     r4,[r0,#4]
;;;291      ram_end->next = MEM_SIZE_ALIGNED;
000022  8003              STRH     r3,[r0,#0]
;;;292      ram_end->prev = MEM_SIZE_ALIGNED;
000024  8043              STRH     r3,[r0,#2]
;;;293    
;;;294      /* initialize the lowest-free pointer to the start of the heap */
;;;295      lfree = (struct mem *)(void *)ram;
000026  6091              STR      r1,[r2,#8]  ; lfree
;;;296    
;;;297      MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
;;;298    
;;;299      if(sys_mutex_new(&mem_mutex) != ERR_OK) {
;;;300        LWIP_ASSERT("failed to create mem_mutex", 0);
;;;301      }
;;;302    }
000028  bd10              POP      {r4,pc}
;;;303    
                          ENDP

00002a  0000              DCW      0x0000
                  |L3.44|
                          DCD      ||.bss||+0x3
                  |L3.48|
                          DCD      ||.data||

                          AREA ||i.mem_malloc||, CODE, READONLY, ALIGN=2

                  mem_malloc PROC
;;;493    void *
;;;494    mem_malloc(mem_size_t size)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;495    {
000004  2800              CMP      r0,#0
000006  d062              BEQ      |L4.206|
;;;496      mem_size_t ptr, ptr2;
;;;497      struct mem *mem, *mem2;
;;;498    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;499      u8_t local_mem_free_count = 0;
;;;500    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;501      LWIP_MEM_ALLOC_DECL_PROTECT();
;;;502    
;;;503      if (size == 0) {
;;;504        return NULL;
;;;505      }
;;;506    
;;;507      /* Expand the size of the allocated memory region so that we can
;;;508         adjust for alignment. */
;;;509      size = LWIP_MEM_ALIGN_SIZE(size);
000008  f64f71fc          MOV      r1,#0xfffc
00000c  1cc0              ADDS     r0,r0,#3
00000e  ea000501          AND      r5,r0,r1
;;;510    
;;;511      if(size < MIN_SIZE_ALIGNED) {
;;;512        /* every data block must be at least MIN_SIZE_ALIGNED long */
;;;513        size = MIN_SIZE_ALIGNED;
;;;514      }
;;;515    
;;;516      if (size > MEM_SIZE_ALIGNED) {
000012  f44f49a0          MOV      r9,#0x5000
000016  2d0c              CMP      r5,#0xc               ;511
000018  d201              BCS      |L4.30|
00001a  250c              MOVS     r5,#0xc               ;513
00001c  e001              B        |L4.34|
                  |L4.30|
00001e  454d              CMP      r5,r9
000020  d85a              BHI      |L4.216|
                  |L4.34|
;;;517        return NULL;
;;;518      }
;;;519    
;;;520      /* protect the heap from concurrent access */
;;;521      sys_mutex_lock(&mem_mutex);
;;;522      LWIP_MEM_ALLOC_PROTECT();
;;;523    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;524      /* run as long as a mem_free disturbed mem_malloc or mem_trim */
;;;525      do {
;;;526        local_mem_free_count = 0;
;;;527    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;528    
;;;529        /* Scan through the heap searching for a free block that is big enough,
;;;530         * beginning with the lowest free block.
;;;531         */
;;;532        for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
000022  4e2e              LDR      r6,|L4.220|
000024  f5c543a0          RSB      r3,r5,#0x5000
000028  68b7              LDR      r7,[r6,#8]  ; lfree
00002a  6831              LDR      r1,[r6,#0]  ; ram
00002c  1a78              SUBS     r0,r7,r1
00002e  b280              UXTH     r0,r0
000030  e050              B        |L4.212|
                  |L4.50|
;;;533             ptr = ((struct mem *)(void *)&ram[ptr])->next) {
;;;534          mem = (struct mem *)(void *)&ram[ptr];
000032  180c              ADDS     r4,r1,r0
;;;535    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;536          mem_free_count = 0;
;;;537          LWIP_MEM_ALLOC_UNPROTECT();
;;;538          /* allow mem_free or mem_trim to run */
;;;539          LWIP_MEM_ALLOC_PROTECT();
;;;540          if (mem_free_count != 0) {
;;;541            /* If mem_free or mem_trim have run, we have to restart since they
;;;542               could have altered our current struct mem. */
;;;543            local_mem_free_count = 1;
;;;544            break;
;;;545          }
;;;546    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;547    
;;;548          if ((!mem->used) &&
000034  7922              LDRB     r2,[r4,#4]
000036  2a00              CMP      r2,#0
000038  d14b              BNE      |L4.210|
;;;549              (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
00003a  8822              LDRH     r2,[r4,#0]
00003c  1a12              SUBS     r2,r2,r0
00003e  3a08              SUBS     r2,r2,#8
000040  42aa              CMP      r2,r5
000042  d346              BCC      |L4.210|
;;;550            /* mem is not used and at least perfect fit is possible:
;;;551             * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */
;;;552    
;;;553            if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
000044  8822              LDRH     r2,[r4,#0]
000046  f1050314          ADD      r3,r5,#0x14
00004a  1a12              SUBS     r2,r2,r0
;;;554              /* (in addition to the above, we test if another struct mem (SIZEOF_STRUCT_MEM) containing
;;;555               * at least MIN_SIZE_ALIGNED of data also fits in the 'user data space' of 'mem')
;;;556               * -> split large block, create empty remainder,
;;;557               * remainder must be large enough to contain MIN_SIZE_ALIGNED data: if
;;;558               * mem->next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,
;;;559               * struct mem would fit in but no data between mem2 and mem2->next
;;;560               * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
;;;561               *       region that couldn't hold data, but when mem->next gets freed,
;;;562               *       the 2 regions would be combined, resulting in more free memory
;;;563               */
;;;564              ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
;;;565              /* create mem2 struct */
;;;566              mem2 = (struct mem *)(void *)&ram[ptr2];
;;;567              mem2->used = 0;
;;;568              mem2->next = mem->next;
;;;569              mem2->prev = ptr;
;;;570              /* and insert it between mem and mem->next */
;;;571              mem->next = ptr2;
;;;572              mem->used = 1;
00004c  3a08              SUBS     r2,r2,#8
00004e  f04f0801          MOV      r8,#1
000052  429a              CMP      r2,r3                 ;553
000054  d315              BCC      |L4.130|
000056  1942              ADDS     r2,r0,r5              ;564
000058  3208              ADDS     r2,r2,#8              ;564
00005a  b293              UXTH     r3,r2                 ;564
00005c  18ca              ADDS     r2,r1,r3              ;566
00005e  f04f0c00          MOV      r12,#0                ;567
000062  f882c004          STRB     r12,[r2,#4]           ;567
000066  f8b4c000          LDRH     r12,[r4,#0]           ;568
00006a  f8a2c000          STRH     r12,[r2,#0]           ;568
00006e  8050              STRH     r0,[r2,#2]            ;569
000070  8023              STRH     r3,[r4,#0]            ;571
000072  f8848004          STRB     r8,[r4,#4]
;;;573    
;;;574              if (mem2->next != MEM_SIZE_ALIGNED) {
000076  8810              LDRH     r0,[r2,#0]
000078  4548              CMP      r0,r9
00007a  d004              BEQ      |L4.134|
;;;575                ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
00007c  1c8a              ADDS     r2,r1,#2
00007e  5283              STRH     r3,[r0,r2]
000080  e001              B        |L4.134|
                  |L4.130|
;;;576              }
;;;577              MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
;;;578            } else {
;;;579              /* (a mem2 struct does no fit into the user data space of mem and mem->next will always
;;;580               * be used at this point: if not we have 2 unused structs in a row, plug_holes should have
;;;581               * take care of this).
;;;582               * -> near fit or excact fit: do not split, no mem2 creation
;;;583               * also can't move mem->next directly behind mem, since mem->next
;;;584               * will always be used at this point!
;;;585               */
;;;586              mem->used = 1;
000082  f8848004          STRB     r8,[r4,#4]
                  |L4.134|
;;;587              MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
;;;588            }
;;;589    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;590    mem_malloc_adjust_lfree:
;;;591    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;592            if (mem == lfree) {
000086  42bc              CMP      r4,r7
000088  d10f              BNE      |L4.170|
;;;593              struct mem *cur = lfree;
;;;594              /* Find next free block after mem and update lowest free pointer */
;;;595              while (cur->used && cur != ram_end) {
00008a  6870              LDR      r0,[r6,#4]
00008c  e001              B        |L4.146|
                  |L4.142|
;;;596    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;597                mem_free_count = 0;
;;;598                LWIP_MEM_ALLOC_UNPROTECT();
;;;599                /* prevent high interrupt latency... */
;;;600                LWIP_MEM_ALLOC_PROTECT();
;;;601                if (mem_free_count != 0) {
;;;602                  /* If mem_free or mem_trim have run, we have to restart since they
;;;603                     could have altered our current struct mem or lfree. */
;;;604                  goto mem_malloc_adjust_lfree;
;;;605                }
;;;606    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;607                cur = (struct mem *)(void *)&ram[cur->next];
00008e  883a              LDRH     r2,[r7,#0]
000090  1857              ADDS     r7,r2,r1
                  |L4.146|
000092  793a              LDRB     r2,[r7,#4]            ;595
000094  b10a              CBZ      r2,|L4.154|
000096  4287              CMP      r7,r0                 ;595
000098  d1f9              BNE      |L4.142|
                  |L4.154|
;;;608              }
;;;609              lfree = cur;
;;;610              LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
00009a  60b7              STR      r7,[r6,#8]  ; lfree
00009c  4287              CMP      r7,r0
00009e  d004              BEQ      |L4.170|
0000a0  7938              LDRB     r0,[r7,#4]
0000a2  b110              CBZ      r0,|L4.170|
0000a4  a00e              ADR      r0,|L4.224|
0000a6  f7fffffe          BL       __2printf
                  |L4.170|
;;;611            }
;;;612            LWIP_MEM_ALLOC_UNPROTECT();
;;;613            sys_mutex_unlock(&mem_mutex);
;;;614            LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
0000aa  1960              ADDS     r0,r4,r5
0000ac  6871              LDR      r1,[r6,#4]  ; ram_end
0000ae  3008              ADDS     r0,r0,#8
0000b0  4288              CMP      r0,r1
0000b2  d902              BLS      |L4.186|
0000b4  a011              ADR      r0,|L4.252|
0000b6  f7fffffe          BL       __2printf
                  |L4.186|
;;;615             (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
;;;616            LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
0000ba  07a0              LSLS     r0,r4,#30
0000bc  d005              BEQ      |L4.202|
0000be  a01b              ADR      r0,|L4.300|
0000c0  f7fffffe          BL       __2printf
;;;617             ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
;;;618            LWIP_ASSERT("mem_malloc: sanity check alignment",
0000c4  a025              ADR      r0,|L4.348|
0000c6  f7fffffe          BL       __2printf
                  |L4.202|
;;;619              (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);
;;;620    
;;;621            return (u8_t *)mem + SIZEOF_STRUCT_MEM;
0000ca  f1040008          ADD      r0,r4,#8
                  |L4.206|
;;;622          }
;;;623        }
;;;624    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;625        /* if we got interrupted by a mem_free, try again */
;;;626      } while(local_mem_free_count != 0);
;;;627    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;628      LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
;;;629      MEM_STATS_INC(err);
;;;630      LWIP_MEM_ALLOC_UNPROTECT();
;;;631      sys_mutex_unlock(&mem_mutex);
;;;632      return NULL;
;;;633    }
0000ce  e8bd87f0          POP      {r4-r10,pc}
                  |L4.210|
0000d2  5a08              LDRH     r0,[r1,r0]            ;533
                  |L4.212|
0000d4  4283              CMP      r3,r0                 ;532
0000d6  dcac              BGT      |L4.50|
                  |L4.216|
0000d8  2000              MOVS     r0,#0                 ;632
0000da  e7f8              B        |L4.206|
;;;634    
                          ENDP

                  |L4.220|
                          DCD      ||.data||
                  |L4.224|
0000e0  6d656d5f          DCB      "mem_malloc: !lfree->used",0
0000e4  6d616c6c
0000e8  6f633a20
0000ec  216c6672
0000f0  65652d3e
0000f4  75736564
0000f8  00      
0000f9  00                DCB      0
0000fa  00                DCB      0
0000fb  00                DCB      0
                  |L4.252|
0000fc  6d656d5f          DCB      "mem_malloc: allocated memory not above ram_end.",0
000100  6d616c6c
000104  6f633a20
000108  616c6c6f
00010c  63617465
000110  64206d65
000114  6d6f7279
000118  206e6f74
00011c  2061626f
000120  76652072
000124  616d5f65
000128  6e642e00
                  |L4.300|
00012c  6d656d5f          DCB      "mem_malloc: allocated memory properly aligned.",0
000130  6d616c6c
000134  6f633a20
000138  616c6c6f
00013c  63617465
000140  64206d65
000144  6d6f7279
000148  2070726f
00014c  7065726c
000150  7920616c
000154  69676e65
000158  642e00  
00015b  00                DCB      0
                  |L4.348|
00015c  6d656d5f          DCB      "mem_malloc: sanity check alignment",0
000160  6d616c6c
000164  6f633a20
000168  73616e69
00016c  74792063
000170  6865636b
000174  20616c69
000178  676e6d65
00017c  6e7400  
00017f  00                DCB      0

                          AREA ||i.mem_trim||, CODE, READONLY, ALIGN=2

                  mem_trim PROC
;;;368    void *
;;;369    mem_trim(void *rmem, mem_size_t newsize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;370    {
000004  4607              MOV      r7,r0
;;;371      mem_size_t size;
;;;372      mem_size_t ptr, ptr2;
;;;373      struct mem *mem, *mem2;
;;;374      /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
;;;375      LWIP_MEM_FREE_DECL_PROTECT();
;;;376    
;;;377      /* Expand the size of the allocated memory region so that we can
;;;378         adjust for alignment. */
;;;379      newsize = LWIP_MEM_ALIGN_SIZE(newsize);
000006  f64f70fc          MOV      r0,#0xfffc
00000a  1cc9              ADDS     r1,r1,#3
00000c  ea010400          AND      r4,r1,r0
;;;380    
;;;381      if(newsize < MIN_SIZE_ALIGNED) {
;;;382        /* every data block must be at least MIN_SIZE_ALIGNED long */
;;;383        newsize = MIN_SIZE_ALIGNED;
;;;384      }
;;;385    
;;;386      if (newsize > MEM_SIZE_ALIGNED) {
000010  f44f4aa0          MOV      r10,#0x5000
000014  2c0c              CMP      r4,#0xc               ;381
000016  d201              BCS      |L5.28|
000018  240c              MOVS     r4,#0xc               ;383
00001a  e001              B        |L5.32|
                  |L5.28|
00001c  4554              CMP      r4,r10
00001e  d820              BHI      |L5.98|
                  |L5.32|
;;;387        return NULL;
;;;388      }
;;;389    
;;;390      LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
000020  4e2f              LDR      r6,|L5.224|
000022  6830              LDR      r0,[r6,#0]  ; ram
000024  4287              CMP      r7,r0
000026  d302              BCC      |L5.46|
000028  6870              LDR      r0,[r6,#4]  ; ram_end
00002a  4287              CMP      r7,r0
00002c  d302              BCC      |L5.52|
                  |L5.46|
00002e  a02d              ADR      r0,|L5.228|
000030  f7fffffe          BL       __2printf
                  |L5.52|
;;;391       (u8_t *)rmem < (u8_t *)ram_end);
;;;392    
;;;393      if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
000034  6830              LDR      r0,[r6,#0]  ; ram
000036  4287              CMP      r7,r0
000038  d33a              BCC      |L5.176|
00003a  6871              LDR      r1,[r6,#4]  ; ram_end
00003c  428f              CMP      r7,r1
00003e  d237              BCS      |L5.176|
;;;394        SYS_ARCH_DECL_PROTECT(lev);
;;;395        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
;;;396        /* protect mem stats from concurrent access */
;;;397        SYS_ARCH_PROTECT(lev);
;;;398        MEM_STATS_INC(illegal);
;;;399        SYS_ARCH_UNPROTECT(lev);
;;;400        return rmem;
;;;401      }
;;;402      /* Get the corresponding struct mem ... */
;;;403      mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
000040  f1a70508          SUB      r5,r7,#8
;;;404      /* ... and its offset pointer */
;;;405      ptr = (mem_size_t)((u8_t *)mem - ram);
000044  46b0              MOV      r8,r6
000046  1a28              SUBS     r0,r5,r0
000048  b286              UXTH     r6,r0
;;;406    
;;;407      size = mem->next - ptr - SIZEOF_STRUCT_MEM;
00004a  8828              LDRH     r0,[r5,#0]
00004c  1b80              SUBS     r0,r0,r6
00004e  3808              SUBS     r0,r0,#8
000050  fa1ff980          UXTH     r9,r0
;;;408      LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
000054  454c              CMP      r4,r9
000056  d902              BLS      |L5.94|
000058  a028              ADR      r0,|L5.252|
00005a  f7fffffe          BL       __2printf
                  |L5.94|
;;;409      if (newsize > size) {
00005e  454c              CMP      r4,r9
000060  d903              BLS      |L5.106|
                  |L5.98|
;;;410        /* not supported */
;;;411        return NULL;
000062  f04f0000          MOV      r0,#0
                  |L5.102|
;;;412      }
;;;413      if (newsize == size) {
;;;414        /* No change in size, simply return */
;;;415        return rmem;
;;;416      }
;;;417    
;;;418      /* protect the heap from concurrent access */
;;;419      LWIP_MEM_FREE_PROTECT();
;;;420    
;;;421      mem2 = (struct mem *)(void *)&ram[mem->next];
;;;422      if(mem2->used == 0) {
;;;423        /* The next struct is unused, we can simply move it at little */
;;;424        mem_size_t next;
;;;425        /* remember the old next pointer */
;;;426        next = mem2->next;
;;;427        /* create new struct mem which is moved directly after the shrinked mem */
;;;428        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
;;;429        if (lfree == mem2) {
;;;430          lfree = (struct mem *)(void *)&ram[ptr2];
;;;431        }
;;;432        mem2 = (struct mem *)(void *)&ram[ptr2];
;;;433        mem2->used = 0;
;;;434        /* restore the next pointer */
;;;435        mem2->next = next;
;;;436        /* link it back to mem */
;;;437        mem2->prev = ptr;
;;;438        /* link mem to it */
;;;439        mem->next = ptr2;
;;;440        /* last thing to restore linked list: as we have moved mem2,
;;;441         * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
;;;442         * the end of the heap */
;;;443        if (mem2->next != MEM_SIZE_ALIGNED) {
;;;444          ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
;;;445        }
;;;446        MEM_STATS_DEC_USED(used, (size - newsize));
;;;447        /* no need to plug holes, we've already done that */
;;;448      } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
;;;449        /* Next struct is used but there's room for another struct mem with
;;;450         * at least MIN_SIZE_ALIGNED of data.
;;;451         * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
;;;452         * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
;;;453         * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
;;;454         *       region that couldn't hold data, but when mem->next gets freed,
;;;455         *       the 2 regions would be combined, resulting in more free memory */
;;;456        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
;;;457        mem2 = (struct mem *)(void *)&ram[ptr2];
;;;458        if (mem2 < lfree) {
;;;459          lfree = mem2;
;;;460        }
;;;461        mem2->used = 0;
;;;462        mem2->next = mem->next;
;;;463        mem2->prev = ptr;
;;;464        mem->next = ptr2;
;;;465        if (mem2->next != MEM_SIZE_ALIGNED) {
;;;466          ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
;;;467        }
;;;468        MEM_STATS_DEC_USED(used, (size - newsize));
;;;469        /* the original mem->next is used, so no need to plug holes! */
;;;470      }
;;;471      /* else {
;;;472        next struct mem is used but size between mem and mem2 is not big enough
;;;473        to create another struct mem
;;;474        -> don't do anyhting. 
;;;475        -> the remaining space stays unused since it is too small
;;;476      } */
;;;477    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;478      mem_free_count = 1;
;;;479    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;480      LWIP_MEM_FREE_UNPROTECT();
;;;481      return rmem;
;;;482    }
000066  e8bd87f0          POP      {r4-r10,pc}
                  |L5.106|
00006a  d021              BEQ      |L5.176|
00006c  8828              LDRH     r0,[r5,#0]            ;421
00006e  f8d81000          LDR      r1,[r8,#0]            ;421  ; ram
000072  4642              MOV      r2,r8                 ;421
000074  eb000801          ADD      r8,r0,r1              ;421
000078  f04f0300          MOV      r3,#0                 ;422
00007c  f8980004          LDRB     r0,[r8,#4]            ;422
000080  b1c0              CBZ      r0,|L5.180|
000082  f1040014          ADD      r0,r4,#0x14           ;448
000086  4548              CMP      r0,r9                 ;448
000088  d812              BHI      |L5.176|
00008a  1930              ADDS     r0,r6,r4              ;456
00008c  3008              ADDS     r0,r0,#8              ;456
00008e  b284              UXTH     r4,r0                 ;456
000090  f8d2c008          LDR      r12,[r2,#8]           ;458  ; lfree
000094  1908              ADDS     r0,r1,r4              ;457
000096  4560              CMP      r0,r12                ;458
000098  d200              BCS      |L5.156|
00009a  6090              STR      r0,[r2,#8]            ;459  ; lfree
                  |L5.156|
00009c  7103              STRB     r3,[r0,#4]            ;461
00009e  882a              LDRH     r2,[r5,#0]            ;462
0000a0  8002              STRH     r2,[r0,#0]            ;462
0000a2  8046              STRH     r6,[r0,#2]            ;463
0000a4  802c              STRH     r4,[r5,#0]            ;464
0000a6  8800              LDRH     r0,[r0,#0]            ;465
0000a8  4550              CMP      r0,r10                ;465
0000aa  d001              BEQ      |L5.176|
0000ac  1c89              ADDS     r1,r1,#2              ;465
0000ae  5244              STRH     r4,[r0,r1]            ;466
                  |L5.176|
0000b0  4638              MOV      r0,r7                 ;481
0000b2  e7d8              B        |L5.102|
                  |L5.180|
0000b4  1930              ADDS     r0,r6,r4              ;428
0000b6  3008              ADDS     r0,r0,#8              ;428
0000b8  6894              LDR      r4,[r2,#8]            ;429  ; lfree
0000ba  f8b8c000          LDRH     r12,[r8,#0]           ;426
0000be  b280              UXTH     r0,r0                 ;428
0000c0  4544              CMP      r4,r8                 ;429
0000c2  d101              BNE      |L5.200|
0000c4  180c              ADDS     r4,r1,r0              ;430
0000c6  6094              STR      r4,[r2,#8]            ;430  ; lfree
                  |L5.200|
0000c8  180a              ADDS     r2,r1,r0              ;432
0000ca  7113              STRB     r3,[r2,#4]            ;433
0000cc  f8a2c000          STRH     r12,[r2,#0]           ;435
0000d0  8056              STRH     r6,[r2,#2]            ;437
0000d2  8028              STRH     r0,[r5,#0]            ;439
0000d4  8812              LDRH     r2,[r2,#0]            ;443
0000d6  4552              CMP      r2,r10                ;443
0000d8  d0ea              BEQ      |L5.176|
0000da  1c89              ADDS     r1,r1,#2              ;443
0000dc  5250              STRH     r0,[r2,r1]            ;444
0000de  e7e7              B        |L5.176|
;;;483    
                          ENDP

                  |L5.224|
                          DCD      ||.data||
                  |L5.228|
0000e4  6d656d5f          DCB      "mem_trim: legal memory",0
0000e8  7472696d
0000ec  3a206c65
0000f0  67616c20
0000f4  6d656d6f
0000f8  727900  
0000fb  00                DCB      0
                  |L5.252|
0000fc  6d656d5f          DCB      "mem_trim can only shrink memory",0
000100  7472696d
000104  2063616e
000108  206f6e6c
00010c  79207368
000110  72696e6b
000114  206d656d
000118  6f727900

                          AREA ||i.plug_holes||, CODE, READONLY, ALIGN=2

                  plug_holes PROC
;;;235    static void
;;;236    plug_holes(struct mem *mem)
000000  b570              PUSH     {r4-r6,lr}
;;;237    {
;;;238      struct mem *nmem;
;;;239      struct mem *pmem;
;;;240    
;;;241      LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
000002  4d20              LDR      r5,|L6.132|
000004  4604              MOV      r4,r0                 ;237
000006  6828              LDR      r0,[r5,#0]  ; ram
000008  4284              CMP      r4,r0
00000a  d202              BCS      |L6.18|
00000c  a01e              ADR      r0,|L6.136|
00000e  f7fffffe          BL       __2printf
                  |L6.18|
;;;242      LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
000012  6868              LDR      r0,[r5,#4]  ; ram_end
000014  4284              CMP      r4,r0
000016  d302              BCC      |L6.30|
000018  a021              ADR      r0,|L6.160|
00001a  f7fffffe          BL       __2printf
                  |L6.30|
;;;243      LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
00001e  7920              LDRB     r0,[r4,#4]
000020  b110              CBZ      r0,|L6.40|
000022  a026              ADR      r0,|L6.188|
000024  f7fffffe          BL       __2printf
                  |L6.40|
;;;244    
;;;245      /* plug hole forward */
;;;246      LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
000028  8820              LDRH     r0,[r4,#0]
00002a  f5b04fa0          CMP      r0,#0x5000
00002e  d902              BLS      |L6.54|
000030  a029              ADR      r0,|L6.216|
000032  f7fffffe          BL       __2printf
                  |L6.54|
;;;247    
;;;248      nmem = (struct mem *)(void *)&ram[mem->next];
000036  8820              LDRH     r0,[r4,#0]
000038  6829              LDR      r1,[r5,#0]  ; ram
00003a  4408              ADD      r0,r0,r1
;;;249      if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
00003c  4284              CMP      r4,r0
00003e  d00e              BEQ      |L6.94|
000040  7902              LDRB     r2,[r0,#4]
000042  b962              CBNZ     r2,|L6.94|
000044  686a              LDR      r2,[r5,#4]  ; ram_end
000046  4290              CMP      r0,r2
000048  d009              BEQ      |L6.94|
;;;250        /* if mem->next is unused and not end of ram, combine mem and mem->next */
;;;251        if (lfree == nmem) {
00004a  68aa              LDR      r2,[r5,#8]  ; lfree
00004c  4282              CMP      r2,r0
00004e  d100              BNE      |L6.82|
;;;252          lfree = mem;
000050  60ac              STR      r4,[r5,#8]  ; lfree
                  |L6.82|
;;;253        }
;;;254        mem->next = nmem->next;
000052  8802              LDRH     r2,[r0,#0]
000054  8022              STRH     r2,[r4,#0]
;;;255        ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
000056  8803              LDRH     r3,[r0,#0]
000058  1a62              SUBS     r2,r4,r1
00005a  1c88              ADDS     r0,r1,#2
00005c  521a              STRH     r2,[r3,r0]
                  |L6.94|
;;;256      }
;;;257    
;;;258      /* plug hole backward */
;;;259      pmem = (struct mem *)(void *)&ram[mem->prev];
00005e  8860              LDRH     r0,[r4,#2]
000060  4408              ADD      r0,r0,r1
;;;260      if (pmem != mem && pmem->used == 0) {
000062  42a0              CMP      r0,r4
000064  d00c              BEQ      |L6.128|
000066  7902              LDRB     r2,[r0,#4]
000068  2a00              CMP      r2,#0
00006a  d109              BNE      |L6.128|
;;;261        /* if mem->prev is unused, combine mem and mem->prev */
;;;262        if (lfree == mem) {
00006c  68aa              LDR      r2,[r5,#8]  ; lfree
00006e  42a2              CMP      r2,r4
000070  d100              BNE      |L6.116|
;;;263          lfree = pmem;
000072  60a8              STR      r0,[r5,#8]  ; lfree
                  |L6.116|
;;;264        }
;;;265        pmem->next = mem->next;
000074  8822              LDRH     r2,[r4,#0]
000076  8002              STRH     r2,[r0,#0]
;;;266        ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
000078  8822              LDRH     r2,[r4,#0]
00007a  1a40              SUBS     r0,r0,r1
00007c  1c89              ADDS     r1,r1,#2
00007e  5250              STRH     r0,[r2,r1]
                  |L6.128|
;;;267      }
;;;268    }
000080  bd70              POP      {r4-r6,pc}
;;;269    
                          ENDP

000082  0000              DCW      0x0000
                  |L6.132|
                          DCD      ||.data||
                  |L6.136|
000088  706c7567          DCB      "plug_holes: mem >= ram",0
00008c  5f686f6c
000090  65733a20
000094  6d656d20
000098  3e3d2072
00009c  616d00  
00009f  00                DCB      0
                  |L6.160|
0000a0  706c7567          DCB      "plug_holes: mem < ram_end",0
0000a4  5f686f6c
0000a8  65733a20
0000ac  6d656d20
0000b0  3c207261
0000b4  6d5f656e
0000b8  6400    
0000ba  00                DCB      0
0000bb  00                DCB      0
                  |L6.188|
0000bc  706c7567          DCB      "plug_holes: mem->used == 0",0
0000c0  5f686f6c
0000c4  65733a20
0000c8  6d656d2d
0000cc  3e757365
0000d0  64203d3d
0000d4  203000  
0000d7  00                DCB      0
                  |L6.216|
0000d8  706c7567          DCB      "plug_holes: mem->next <= MEM_SIZE_ALIGNED",0
0000dc  5f686f6c
0000e0  65733a20
0000e4  6d656d2d
0000e8  3e6e6578
0000ec  74203c3d
0000f0  204d454d
0000f4  5f53495a
0000f8  455f414c
0000fc  49474e45
000100  4400    
000102  00                DCB      0
000103  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ram_heap
                          %        20500

                          AREA ||.data||, DATA, ALIGN=2

                  ||ram||
                          DCD      0x00000000
                  ram_end
                          DCD      0x00000000
                  lfree
                          DCD      0x00000000

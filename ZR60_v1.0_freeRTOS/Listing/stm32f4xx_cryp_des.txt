; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\stm32f4xx_cryp_des.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\stm32f4xx_cryp_des.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\ZR60_v1.0_freeRTOS -I..\..\Lwip\App -I..\..\Lwip\Bsp -I..\..\Lwip\Bsp\LAN8742A -I..\..\Lwip\lwip-1.4.1 -I..\..\Lwip\lwip-1.4.1\port -I..\..\Lwip\lwip-1.4.1\port\arch -I..\..\Lwip\lwip-1.4.1\port\Standalone -I..\..\Lwip\lwip-1.4.1\src\include -I..\..\Lwip\lwip-1.4.1\src\include\ipv4 -I..\..\Lwip\lwip-1.4.1\src\include\lwip -I..\..\Lwip\lwip-1.4.1\src\include\netif -I..\..\Ecal\BtnFltr -I..\..\Ecal\UartComn -I..\..\Ecal\MemIf -I..\..\APP -I..\..\APP\BlackListMng -I..\..\APP\SeverNewsPush -I..\..\APP\NewsPull -I..\..\Ecal -I..\..\Ecal\JsonIf -I..\..\Ecal\Mcu_Init -I..\..\Service -I..\..\Complex -I..\..\Complex\FATFS -I..\..\FreeRTOS\Source\include -I..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\FreeRTOS -I.\RTE\_ZR60 -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=..\..\output\stm32f4xx_cryp_des.crf ..\..\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_cryp_des.c]
                          THUMB

                          AREA ||i.CRYP_DES_CBC||, CODE, READONLY, ALIGN=1

                  CRYP_DES_CBC PROC
;;;201      */
;;;202    ErrorStatus CRYP_DES_CBC(uint8_t Mode, uint8_t Key[8], uint8_t InitVectors[8],
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;203                             uint8_t *Input, uint32_t Ilength, uint8_t *Output)
;;;204    {
000004  b091              SUB      sp,sp,#0x44
;;;205      CRYP_InitTypeDef DES_CRYP_InitStructure;
;;;206      CRYP_KeyInitTypeDef DES_CRYP_KeyInitStructure;
;;;207      CRYP_IVInitTypeDef DES_CRYP_IVInitStructure;
;;;208      __IO uint32_t counter = 0;
000006  f04f0a00          MOV      r10,#0
00000a  e9ddb51e          LDRD     r11,r5,[sp,#0x78]     ;204
00000e  461c              MOV      r4,r3                 ;204
;;;209      uint32_t busystatus = 0;
;;;210      ErrorStatus status = SUCCESS;
000010  2701              MOVS     r7,#1
;;;211      uint32_t keyaddr    = (uint32_t)Key;
000012  4688              MOV      r8,r1
;;;212      uint32_t inputaddr  = (uint32_t)Input;
;;;213      uint32_t outputaddr = (uint32_t)Output;
;;;214      uint32_t ivaddr     = (uint32_t)InitVectors;
000014  4691              MOV      r9,r2
;;;215      uint32_t i = 0;
000016  4656              MOV      r6,r10
;;;216    
;;;217      /* Crypto structures initialisation*/
;;;218      CRYP_KeyStructInit(&DES_CRYP_KeyInitStructure);
000018  4668              MOV      r0,sp
00001a  f8cda030          STR      r10,[sp,#0x30]
00001e  f7fffffe          BL       CRYP_KeyStructInit
;;;219    
;;;220      /* Crypto Init for Encryption process */
;;;221      if(Mode == MODE_ENCRYPT) /* DES encryption */
000022  9811              LDR      r0,[sp,#0x44]
000024  2801              CMP      r0,#1
000026  d027              BEQ      |L1.120|
;;;222      {
;;;223         DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
;;;224      }
;;;225      else /*if(Mode == MODE_DECRYPT)*/ /* DES decryption */
;;;226      {
;;;227         DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Decrypt;
000028  2004              MOVS     r0,#4
00002a  9008              STR      r0,[sp,#0x20]
                  |L1.44|
;;;228      }
;;;229    
;;;230      DES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_DES_CBC;
00002c  2018              MOVS     r0,#0x18
;;;231      DES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
00002e  9009              STR      r0,[sp,#0x24]
000030  2080              MOVS     r0,#0x80
;;;232      CRYP_Init(&DES_CRYP_InitStructure);
000032  900a              STR      r0,[sp,#0x28]
000034  a808              ADD      r0,sp,#0x20
000036  f7fffffe          BL       CRYP_Init
;;;233    
;;;234      /* Key Initialisation */
;;;235      DES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
00003a  f8d80000          LDR      r0,[r8,#0]
00003e  ba00              REV      r0,r0
;;;236      keyaddr+=4;
;;;237      DES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
000040  9002              STR      r0,[sp,#8]
000042  f8d80004          LDR      r0,[r8,#4]
000046  ba00              REV      r0,r0
;;;238      CRYP_KeyInit(& DES_CRYP_KeyInitStructure);
000048  9003              STR      r0,[sp,#0xc]
00004a  4668              MOV      r0,sp
00004c  f7fffffe          BL       CRYP_KeyInit
;;;239    
;;;240      /* Initialization Vectors */
;;;241      DES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
000050  f8d90000          LDR      r0,[r9,#0]
000054  ba00              REV      r0,r0
;;;242      ivaddr+=4;
;;;243      DES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
000056  900d              STR      r0,[sp,#0x34]
000058  f8d90004          LDR      r0,[r9,#4]
00005c  ba00              REV      r0,r0
;;;244      CRYP_IVInit(&DES_CRYP_IVInitStructure);
00005e  900e              STR      r0,[sp,#0x38]
000060  a80d              ADD      r0,sp,#0x34
000062  f7fffffe          BL       CRYP_IVInit
;;;245    
;;;246      /* Flush IN/OUT FIFO */
;;;247      CRYP_FIFOFlush();
000066  f7fffffe          BL       CRYP_FIFOFlush
;;;248      
;;;249      /* Enable Crypto processor */
;;;250      CRYP_Cmd(ENABLE);
00006a  2001              MOVS     r0,#1
00006c  f7fffffe          BL       CRYP_Cmd
;;;251    
;;;252      if(CRYP_GetCmdStatus() == DISABLE)
000070  f7fffffe          BL       CRYP_GetCmdStatus
000074  b118              CBZ      r0,|L1.126|
000076  e026              B        |L1.198|
                  |L1.120|
000078  f8cda020          STR      r10,[sp,#0x20]        ;223
00007c  e7d6              B        |L1.44|
                  |L1.126|
;;;253      {
;;;254        /* The CRYP peripheral clock is not enabled or the device doesn't embed 
;;;255        the CRYP peripheral (please check the device sales type. */
;;;256        status = ERROR;
00007e  2700              MOVS     r7,#0
000080  e028              B        |L1.212|
                  |L1.130|
;;;257      }
;;;258      else
;;;259      {
;;;260        for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
;;;261        {
;;;262          /* Write the Input block in the Input FIFO */
;;;263          CRYP_DataIn(*(uint32_t*)(inputaddr));
000082  6820              LDR      r0,[r4,#0]
000084  f7fffffe          BL       CRYP_DataIn
;;;264          inputaddr+=4;
;;;265          CRYP_DataIn(*(uint32_t*)(inputaddr));
000088  f8540f04          LDR      r0,[r4,#4]!
00008c  f7fffffe          BL       CRYP_DataIn
;;;266          inputaddr+=4;
;;;267          
;;;268          /* Wait until the complete message has been processed */
;;;269          counter = 0;
;;;270          do
;;;271          {
;;;272            busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;273            counter++;
;;;274          }while ((counter != DESBUSY_TIMEOUT) && (busystatus != RESET));
000090  f44f3880          MOV      r8,#0x10000
000094  1d24              ADDS     r4,r4,#4
000096  f8cda030          STR      r10,[sp,#0x30]
                  |L1.154|
00009a  2010              MOVS     r0,#0x10              ;272
00009c  f7fffffe          BL       CRYP_GetFlagStatus
0000a0  990c              LDR      r1,[sp,#0x30]         ;273
0000a2  1c49              ADDS     r1,r1,#1              ;273
0000a4  910c              STR      r1,[sp,#0x30]
0000a6  4541              CMP      r1,r8
0000a8  d002              BEQ      |L1.176|
0000aa  2800              CMP      r0,#0
0000ac  d1f5              BNE      |L1.154|
0000ae  e002              B        |L1.182|
                  |L1.176|
;;;275          
;;;276          if (busystatus != RESET)
0000b0  b108              CBZ      r0,|L1.182|
;;;277          {
;;;278            status = ERROR;
0000b2  2700              MOVS     r7,#0
0000b4  e006              B        |L1.196|
                  |L1.182|
;;;279          }
;;;280          else
;;;281          {
;;;282            /* Read the Output block from the Output FIFO */
;;;283            *(uint32_t*)(outputaddr) = CRYP_DataOut();
0000b6  f7fffffe          BL       CRYP_DataOut
;;;284            outputaddr+=4;
;;;285            *(uint32_t*)(outputaddr) = CRYP_DataOut();
0000ba  6028              STR      r0,[r5,#0]
0000bc  f7fffffe          BL       CRYP_DataOut
0000c0  6068              STR      r0,[r5,#4]
0000c2  3508              ADDS     r5,r5,#8
                  |L1.196|
0000c4  3608              ADDS     r6,r6,#8
                  |L1.198|
0000c6  455e              CMP      r6,r11                ;260
0000c8  d201              BCS      |L1.206|
0000ca  2f00              CMP      r7,#0                 ;260
0000cc  d1d9              BNE      |L1.130|
                  |L1.206|
;;;286            outputaddr+=4;
;;;287          }
;;;288        }
;;;289        
;;;290        /* Disable Crypto */
;;;291        CRYP_Cmd(DISABLE);
0000ce  2000              MOVS     r0,#0
0000d0  f7fffffe          BL       CRYP_Cmd
                  |L1.212|
;;;292      }
;;;293      return status; 
;;;294    }
0000d4  b015              ADD      sp,sp,#0x54
0000d6  4638              MOV      r0,r7                 ;293
0000d8  e8bd8ff0          POP      {r4-r11,pc}
;;;295    
                          ENDP


                          AREA ||i.CRYP_DES_ECB||, CODE, READONLY, ALIGN=1

                  CRYP_DES_ECB PROC
;;;98       */
;;;99     ErrorStatus CRYP_DES_ECB(uint8_t Mode, uint8_t Key[8], uint8_t *Input, 
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;100                             uint32_t Ilength, uint8_t *Output)
;;;101    {
000004  b08d              SUB      sp,sp,#0x34
;;;102      CRYP_InitTypeDef DES_CRYP_InitStructure;
;;;103      CRYP_KeyInitTypeDef DES_CRYP_KeyInitStructure;
;;;104      __IO uint32_t counter = 0;
000006  f04f0900          MOV      r9,#0
00000a  4683              MOV      r11,r0                ;101
00000c  9d16              LDR      r5,[sp,#0x58]
00000e  469a              MOV      r10,r3                ;101
000010  4614              MOV      r4,r2                 ;101
;;;105      uint32_t busystatus = 0;
;;;106      ErrorStatus status = SUCCESS;
000012  2701              MOVS     r7,#1
;;;107      uint32_t keyaddr    = (uint32_t)Key;
000014  4688              MOV      r8,r1
;;;108      uint32_t inputaddr  = (uint32_t)Input;
;;;109      uint32_t outputaddr = (uint32_t)Output;
;;;110      uint32_t i = 0;
000016  464e              MOV      r6,r9
;;;111    
;;;112      /* Crypto structures initialisation*/
;;;113      CRYP_KeyStructInit(&DES_CRYP_KeyInitStructure);
000018  4668              MOV      r0,sp
00001a  f8cd9030          STR      r9,[sp,#0x30]
00001e  f7fffffe          BL       CRYP_KeyStructInit
;;;114    
;;;115      /* Crypto Init for Encryption process */
;;;116      if( Mode == MODE_ENCRYPT ) /* DES encryption */
000022  f1bb0f01          CMP      r11,#1
000026  d01c              BEQ      |L2.98|
;;;117      {
;;;118         DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
;;;119      }
;;;120      else/* if( Mode == MODE_DECRYPT )*/ /* DES decryption */
;;;121      {      
;;;122         DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Decrypt;
000028  2004              MOVS     r0,#4
00002a  9008              STR      r0,[sp,#0x20]
                  |L2.44|
;;;123      }
;;;124    
;;;125      DES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_DES_ECB;
00002c  2010              MOVS     r0,#0x10
;;;126      DES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
00002e  9009              STR      r0,[sp,#0x24]
000030  2080              MOVS     r0,#0x80
;;;127      CRYP_Init(&DES_CRYP_InitStructure);
000032  900a              STR      r0,[sp,#0x28]
000034  a808              ADD      r0,sp,#0x20
000036  f7fffffe          BL       CRYP_Init
;;;128    
;;;129      /* Key Initialisation */
;;;130      DES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
00003a  f8d80000          LDR      r0,[r8,#0]
00003e  ba00              REV      r0,r0
;;;131      keyaddr+=4;
;;;132      DES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
000040  9002              STR      r0,[sp,#8]
000042  f8d80004          LDR      r0,[r8,#4]
000046  ba00              REV      r0,r0
;;;133      CRYP_KeyInit(& DES_CRYP_KeyInitStructure);
000048  9003              STR      r0,[sp,#0xc]
00004a  4668              MOV      r0,sp
00004c  f7fffffe          BL       CRYP_KeyInit
;;;134    
;;;135      /* Flush IN/OUT FIFO */
;;;136      CRYP_FIFOFlush();
000050  f7fffffe          BL       CRYP_FIFOFlush
;;;137    
;;;138      /* Enable Crypto processor */
;;;139      CRYP_Cmd(ENABLE);
000054  2001              MOVS     r0,#1
000056  f7fffffe          BL       CRYP_Cmd
;;;140    
;;;141      if(CRYP_GetCmdStatus() == DISABLE)
00005a  f7fffffe          BL       CRYP_GetCmdStatus
00005e  b118              CBZ      r0,|L2.104|
000060  e026              B        |L2.176|
                  |L2.98|
000062  f8cd9020          STR      r9,[sp,#0x20]         ;118
000066  e7e1              B        |L2.44|
                  |L2.104|
;;;142      {
;;;143        /* The CRYP peripheral clock is not enabled or the device doesn't embed 
;;;144        the CRYP peripheral (please check the device sales type. */
;;;145        status = ERROR;
000068  2700              MOVS     r7,#0
00006a  e028              B        |L2.190|
                  |L2.108|
;;;146      }
;;;147      else
;;;148      {
;;;149        for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
;;;150        {
;;;151          
;;;152          /* Write the Input block in the Input FIFO */
;;;153          CRYP_DataIn(*(uint32_t*)(inputaddr));
00006c  6820              LDR      r0,[r4,#0]
00006e  f7fffffe          BL       CRYP_DataIn
;;;154          inputaddr+=4;
;;;155          CRYP_DataIn(*(uint32_t*)(inputaddr));
000072  f8540f04          LDR      r0,[r4,#4]!
000076  f7fffffe          BL       CRYP_DataIn
;;;156          inputaddr+=4;
;;;157          
;;;158          /* Wait until the complete message has been processed */
;;;159          counter = 0;
;;;160          do
;;;161          {
;;;162            busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
;;;163            counter++;
;;;164          }while ((counter != DESBUSY_TIMEOUT) && (busystatus != RESET));
00007a  f44f3880          MOV      r8,#0x10000
00007e  1d24              ADDS     r4,r4,#4
000080  f8cd9030          STR      r9,[sp,#0x30]
                  |L2.132|
000084  2010              MOVS     r0,#0x10              ;162
000086  f7fffffe          BL       CRYP_GetFlagStatus
00008a  990c              LDR      r1,[sp,#0x30]         ;163
00008c  1c49              ADDS     r1,r1,#1              ;163
00008e  910c              STR      r1,[sp,#0x30]
000090  4541              CMP      r1,r8
000092  d002              BEQ      |L2.154|
000094  2800              CMP      r0,#0
000096  d1f5              BNE      |L2.132|
000098  e002              B        |L2.160|
                  |L2.154|
;;;165          
;;;166          if (busystatus != RESET)
00009a  b108              CBZ      r0,|L2.160|
;;;167          {
;;;168            status = ERROR;
00009c  2700              MOVS     r7,#0
00009e  e006              B        |L2.174|
                  |L2.160|
;;;169          }
;;;170          else
;;;171          {
;;;172            
;;;173            /* Read the Output block from the Output FIFO */
;;;174            *(uint32_t*)(outputaddr) = CRYP_DataOut();
0000a0  f7fffffe          BL       CRYP_DataOut
;;;175            outputaddr+=4;
;;;176            *(uint32_t*)(outputaddr) = CRYP_DataOut();
0000a4  6028              STR      r0,[r5,#0]
0000a6  f7fffffe          BL       CRYP_DataOut
0000aa  6068              STR      r0,[r5,#4]
0000ac  3508              ADDS     r5,r5,#8
                  |L2.174|
0000ae  3608              ADDS     r6,r6,#8
                  |L2.176|
0000b0  4556              CMP      r6,r10                ;149
0000b2  d201              BCS      |L2.184|
0000b4  2f00              CMP      r7,#0                 ;149
0000b6  d1d9              BNE      |L2.108|
                  |L2.184|
;;;177            outputaddr+=4;
;;;178          }
;;;179        }
;;;180        
;;;181        /* Disable Crypto */
;;;182        CRYP_Cmd(DISABLE);
0000b8  2000              MOVS     r0,#0
0000ba  f7fffffe          BL       CRYP_Cmd
                  |L2.190|
;;;183      }
;;;184      return status; 
;;;185    }
0000be  b00d              ADD      sp,sp,#0x34
0000c0  4638              MOV      r0,r7                 ;184
0000c2  e8bd8ff0          POP      {r4-r11,pc}
;;;186    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_cryp_des.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_cryp_des_c_9174d91f____REV16|
#line 138 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___20_stm32f4xx_cryp_des_c_9174d91f____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_cryp_des_c_9174d91f____REVSH|
#line 153
|__asm___20_stm32f4xx_cryp_des_c_9174d91f____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_cryp_des_c_9174d91f____RRX|
#line 328
|__asm___20_stm32f4xx_cryp_des_c_9174d91f____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

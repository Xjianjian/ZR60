; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\tcp_out.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\tcp_out.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\ZR60_v1.0_freeRTOS -I..\..\Lwip\App -I..\..\Lwip\Bsp -I..\..\Lwip\Bsp\LAN8742A -I..\..\Lwip\lwip-1.4.1 -I..\..\Lwip\lwip-1.4.1\port -I..\..\Lwip\lwip-1.4.1\port\arch -I..\..\Lwip\lwip-1.4.1\port\Standalone -I..\..\Lwip\lwip-1.4.1\src\include -I..\..\Lwip\lwip-1.4.1\src\include\ipv4 -I..\..\Lwip\lwip-1.4.1\src\include\lwip -I..\..\Lwip\lwip-1.4.1\src\include\netif -I..\..\Ecal\BtnFltr -I..\..\Ecal\UartComn -I..\..\Ecal\MemIf -I..\..\APP -I..\..\APP\BlackListMng -I..\..\APP\SeverNewsPush -I..\..\APP\NewsPull -I..\..\Ecal -I..\..\Ecal\JsonIf -I..\..\Ecal\Mcu_Init -I..\..\Service -I..\..\Complex -I..\..\Complex\FATFS -I..\..\FreeRTOS\Source\include -I..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\FreeRTOS -I.\RTE\_ZR60 -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=..\..\output\tcp_out.crf ..\..\Lwip\lwip-1.4.1\src\core\tcp_out.c]
                          THUMB

                          AREA ||i.tcp_create_segment||, CODE, READONLY, ALIGN=1

                  tcp_create_segment PROC
;;;158    static struct tcp_seg *
;;;159    tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;160    {
000004  4680              MOV      r8,r0
;;;161      struct tcp_seg *seg;
;;;162      u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
000006  9e08              LDR      r6,[sp,#0x20]
000008  469a              MOV      r10,r3                ;160
00000a  4691              MOV      r9,r2                 ;160
00000c  460f              MOV      r7,r1                 ;160
00000e  07f0              LSLS     r0,r6,#31
000010  d000              BEQ      |L1.20|
000012  2004              MOVS     r0,#4
                  |L1.20|
000014  07b1              LSLS     r1,r6,#30
000016  d501              BPL      |L1.28|
000018  210c              MOVS     r1,#0xc
00001a  e000              B        |L1.30|
                  |L1.28|
00001c  2100              MOVS     r1,#0
                  |L1.30|
00001e  1845              ADDS     r5,r0,r1
;;;163    
;;;164      if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
000020  2004              MOVS     r0,#4
000022  f7fffffe          BL       memp_malloc
000026  0004              MOVS     r4,r0
000028  d011              BEQ      |L1.78|
;;;165        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
;;;166        pbuf_free(p);
;;;167        return NULL;
;;;168      }
;;;169      seg->flags = optflags;
00002a  72a6              STRB     r6,[r4,#0xa]
;;;170      seg->next = NULL;
00002c  2600              MOVS     r6,#0
00002e  e9c46700          STRD     r6,r7,[r4,#0]
;;;171      seg->p = p;
;;;172      seg->len = p->tot_len - optlen;
000032  8938              LDRH     r0,[r7,#8]
;;;173    #if TCP_OVERSIZE_DBGCHECK
;;;174      seg->oversize_left = 0;
;;;175    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;176    #if TCP_CHECKSUM_ON_COPY
;;;177      seg->chksum = 0;
;;;178      seg->chksum_swapped = 0;
;;;179      /* check optflags */
;;;180      LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
;;;181                  (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
;;;182    #endif /* TCP_CHECKSUM_ON_COPY */
;;;183    
;;;184      /* build TCP header */
;;;185      if (pbuf_header(p, TCP_HLEN)) {
000034  2114              MOVS     r1,#0x14
000036  1b40              SUBS     r0,r0,r5              ;172
000038  8120              STRH     r0,[r4,#8]            ;172
00003a  4638              MOV      r0,r7
00003c  f7fffffe          BL       pbuf_header
000040  b148              CBZ      r0,|L1.86|
;;;186        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
;;;187        TCP_STATS_INC(tcp.err);
;;;188        tcp_seg_free(seg);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       tcp_seg_free
                  |L1.72|
;;;189        return NULL;
000048  2000              MOVS     r0,#0
                  |L1.74|
;;;190      }
;;;191      seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
;;;192      seg->tcphdr->src = htons(pcb->local_port);
;;;193      seg->tcphdr->dest = htons(pcb->remote_port);
;;;194      seg->tcphdr->seqno = htonl(seqno);
;;;195      /* ackno is set in tcp_output */
;;;196      TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
;;;197      /* wnd and chksum are set in tcp_output */
;;;198      seg->tcphdr->urgp = 0;
;;;199      return seg;
;;;200    } 
00004a  e8bd87f0          POP      {r4-r10,pc}
                  |L1.78|
00004e  4638              MOV      r0,r7                 ;166
000050  f7fffffe          BL       pbuf_free
000054  e7f8              B        |L1.72|
                  |L1.86|
000056  6860              LDR      r0,[r4,#4]            ;191
000058  6840              LDR      r0,[r0,#4]            ;191
00005a  60e0              STR      r0,[r4,#0xc]          ;192
00005c  f8b8001a          LDRH     r0,[r8,#0x1a]         ;192
000060  f7fffffe          BL       lwip_htons
000064  68e1              LDR      r1,[r4,#0xc]          ;192
000066  8008              STRH     r0,[r1,#0]            ;192
000068  f8b8001c          LDRH     r0,[r8,#0x1c]         ;193
00006c  f7fffffe          BL       lwip_htons
000070  68e1              LDR      r1,[r4,#0xc]          ;193
000072  8048              STRH     r0,[r1,#2]            ;193
000074  4650              MOV      r0,r10                ;194
000076  f7fffffe          BL       lwip_htonl
00007a  68e1              LDR      r1,[r4,#0xc]          ;194
00007c  6048              STR      r0,[r1,#4]            ;194
00007e  08a8              LSRS     r0,r5,#2              ;196
000080  0300              LSLS     r0,r0,#12             ;196
000082  f50040a0          ADD      r0,r0,#0x5000         ;196
000086  ea400009          ORR      r0,r0,r9              ;196
00008a  f7fffffe          BL       lwip_htons
00008e  68e1              LDR      r1,[r4,#0xc]          ;196
000090  8188              STRH     r0,[r1,#0xc]          ;196
000092  68e0              LDR      r0,[r4,#0xc]          ;198
000094  8246              STRH     r6,[r0,#0x12]         ;198
000096  4620              MOV      r0,r4                 ;199
000098  e7d7              B        |L1.74|
;;;201    
                          ENDP


                          AREA ||i.tcp_enqueue_flags||, CODE, READONLY, ALIGN=2

                  tcp_enqueue_flags PROC
;;;722    err_t
;;;723    tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;724    {
000004  4604              MOV      r4,r0
;;;725      struct pbuf *p;
;;;726      struct tcp_seg *seg;
;;;727      u8_t optflags = 0;
000006  2500              MOVS     r5,#0
000008  460e              MOV      r6,r1                 ;724
;;;728      u8_t optlen = 0;
;;;729    
;;;730      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));
;;;731    
;;;732      LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
00000a  0788              LSLS     r0,r1,#30
00000c  d102              BNE      |L2.20|
00000e  483a              LDR      r0,|L2.248|
000010  f7fffffe          BL       __2printf
                  |L2.20|
;;;733                  (flags & (TCP_SYN | TCP_FIN)) != 0);
;;;734    
;;;735      /* check for configured max queuelen and possible overflow */
;;;736      if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
000014  f8b40068          LDRH     r0,[r4,#0x68]
;;;737        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: too long queue %"U16_F" (max %"U16_F")\n",
;;;738                                           pcb->snd_queuelen, TCP_SND_QUEUELEN));
;;;739        TCP_STATS_INC(tcp.memerr);
;;;740        pcb->flags |= TF_NAGLEMEMERR;
;;;741        return ERR_MEM;
000018  f04f39ff          MOV      r9,#0xffffffff
00001c  2810              CMP      r0,#0x10              ;736
00001e  d304              BCC      |L2.42|
                  |L2.32|
000020  7fa0              LDRB     r0,[r4,#0x1e]         ;740
000022  f0400080          ORR      r0,r0,#0x80           ;740
000026  77a0              STRB     r0,[r4,#0x1e]         ;740
000028  e034              B        |L2.148|
                  |L2.42|
;;;742      }
;;;743    
;;;744      if (flags & TCP_SYN) {
00002a  07b0              LSLS     r0,r6,#30
00002c  d500              BPL      |L2.48|
;;;745        optflags = TF_SEG_OPTS_MSS;
00002e  2501              MOVS     r5,#1
                  |L2.48|
;;;746      }
;;;747    #if LWIP_TCP_TIMESTAMPS
;;;748      if ((pcb->flags & TF_TIMESTAMP)) {
;;;749        optflags |= TF_SEG_OPTS_TS;
;;;750      }
;;;751    #endif /* LWIP_TCP_TIMESTAMPS */
;;;752      optlen = LWIP_TCP_OPT_LENGTH(optflags);
000030  07e8              LSLS     r0,r5,#31
000032  d000              BEQ      |L2.54|
000034  2004              MOVS     r0,#4
                  |L2.54|
000036  07a9              LSLS     r1,r5,#30
000038  d501              BPL      |L2.62|
00003a  210c              MOVS     r1,#0xc
00003c  e000              B        |L2.64|
                  |L2.62|
00003e  2100              MOVS     r1,#0
                  |L2.64|
000040  eb000801          ADD      r8,r0,r1
;;;753    
;;;754      /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
;;;755       * We need one available snd_buf byte to do that.
;;;756       * This means we can't send FIN while snd_buf==0. A better fix would be to
;;;757       * not include SYN and FIN sequence numbers in the snd_buf count. */
;;;758      if (pcb->snd_buf == 0) {
000044  f8b40066          LDRH     r0,[r4,#0x66]
000048  2800              CMP      r0,#0
00004a  d023              BEQ      |L2.148|
;;;759        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: no send buffer available\n"));
;;;760        TCP_STATS_INC(tcp.memerr);
;;;761        return ERR_MEM;
;;;762      }
;;;763    
;;;764      /* Allocate pbuf with room for TCP header + options */
;;;765      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
00004c  2200              MOVS     r2,#0
00004e  4641              MOV      r1,r8
000050  4610              MOV      r0,r2
000052  f7fffffe          BL       pbuf_alloc
000056  0007              MOVS     r7,r0
000058  d0e2              BEQ      |L2.32|
;;;766        pcb->flags |= TF_NAGLEMEMERR;
;;;767        TCP_STATS_INC(tcp.memerr);
;;;768        return ERR_MEM;
;;;769      }
;;;770      LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
00005a  8979              LDRH     r1,[r7,#0xa]
00005c  4541              CMP      r1,r8
00005e  d202              BCS      |L2.102|
000060  a026              ADR      r0,|L2.252|
000062  f7fffffe          BL       __2printf
                  |L2.102|
;;;771                  (p->len >= optlen));
;;;772    
;;;773      /* Allocate memory for tcp_seg, and fill in fields. */
;;;774      if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
000066  9500              STR      r5,[sp,#0]
000068  4632              MOV      r2,r6
00006a  4639              MOV      r1,r7
00006c  4620              MOV      r0,r4
00006e  6de3              LDR      r3,[r4,#0x5c]
000070  f7fffffe          BL       tcp_create_segment
000074  0005              MOVS     r5,r0
000076  d0d3              BEQ      |L2.32|
;;;775        pcb->flags |= TF_NAGLEMEMERR;
;;;776        TCP_STATS_INC(tcp.memerr);
;;;777        return ERR_MEM;
;;;778      }
;;;779      LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % MEM_ALIGNMENT) == 0);
000078  7b28              LDRB     r0,[r5,#0xc]
00007a  0780              LSLS     r0,r0,#30
00007c  d002              BEQ      |L2.132|
00007e  a02e              ADR      r0,|L2.312|
000080  f7fffffe          BL       __2printf
                  |L2.132|
;;;780      LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
000084  8928              LDRH     r0,[r5,#8]
000086  b110              CBZ      r0,|L2.142|
000088  a031              ADR      r0,|L2.336|
00008a  f7fffffe          BL       __2printf
                  |L2.142|
;;;781    
;;;782      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE,
;;;783                  ("tcp_enqueue_flags: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
;;;784                   ntohl(seg->tcphdr->seqno),
;;;785                   ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
;;;786                   (u16_t)flags));
;;;787    
;;;788      /* Now append seg to pcb->unsent queue */
;;;789      if (pcb->unsent == NULL) {
00008e  6ee0              LDR      r0,[r4,#0x6c]
000090  b118              CBZ      r0,|L2.154|
000092  e005              B        |L2.160|
                  |L2.148|
000094  4648              MOV      r0,r9                 ;761
                  |L2.150|
;;;790        pcb->unsent = seg;
;;;791      } else {
;;;792        struct tcp_seg *useg;
;;;793        for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
;;;794        useg->next = seg;
;;;795      }
;;;796    #if TCP_OVERSIZE
;;;797      /* The new unsent tail has no space */
;;;798      pcb->unsent_oversize = 0;
;;;799    #endif /* TCP_OVERSIZE */
;;;800    
;;;801      /* SYN and FIN bump the sequence number */
;;;802      if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
;;;803        pcb->snd_lbb++;
;;;804        /* optlen does not influence snd_buf */
;;;805        pcb->snd_buf--;
;;;806      }
;;;807      if (flags & TCP_FIN) {
;;;808        pcb->flags |= TF_FIN;
;;;809      }
;;;810    
;;;811      /* update number of segments on the queues */
;;;812      pcb->snd_queuelen += pbuf_clen(seg->p);
;;;813      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
;;;814      if (pcb->snd_queuelen != 0) {
;;;815        LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
;;;816          pcb->unacked != NULL || pcb->unsent != NULL);
;;;817      }
;;;818    
;;;819      return ERR_OK;
;;;820    }
000096  e8bd83f8          POP      {r3-r9,pc}
                  |L2.154|
00009a  66e5              STR      r5,[r4,#0x6c]         ;790
00009c  e004              B        |L2.168|
                  |L2.158|
00009e  4608              MOV      r0,r1                 ;790
                  |L2.160|
0000a0  6801              LDR      r1,[r0,#0]            ;793
0000a2  2900              CMP      r1,#0                 ;793
0000a4  d1fb              BNE      |L2.158|
0000a6  6005              STR      r5,[r0,#0]            ;794
                  |L2.168|
0000a8  2000              MOVS     r0,#0                 ;798
0000aa  f8a4006a          STRH     r0,[r4,#0x6a]         ;798
0000ae  07b0              LSLS     r0,r6,#30             ;802
0000b0  d007              BEQ      |L2.194|
0000b2  6de0              LDR      r0,[r4,#0x5c]         ;803
0000b4  1c40              ADDS     r0,r0,#1              ;803
0000b6  65e0              STR      r0,[r4,#0x5c]         ;805
0000b8  f8b40066          LDRH     r0,[r4,#0x66]         ;805
0000bc  1e40              SUBS     r0,r0,#1              ;805
0000be  f8a40066          STRH     r0,[r4,#0x66]         ;805
                  |L2.194|
0000c2  07f0              LSLS     r0,r6,#31             ;807
0000c4  d003              BEQ      |L2.206|
0000c6  7fa0              LDRB     r0,[r4,#0x1e]         ;808
0000c8  f0400020          ORR      r0,r0,#0x20           ;808
0000cc  77a0              STRB     r0,[r4,#0x1e]         ;808
                  |L2.206|
0000ce  6868              LDR      r0,[r5,#4]            ;812
0000d0  f7fffffe          BL       pbuf_clen
0000d4  f8b41068          LDRH     r1,[r4,#0x68]         ;812
0000d8  4408              ADD      r0,r0,r1              ;812
0000da  0400              LSLS     r0,r0,#16             ;812
0000dc  0c00              LSRS     r0,r0,#16             ;812
0000de  f8a40068          STRH     r0,[r4,#0x68]         ;812
0000e2  d006              BEQ      |L2.242|
0000e4  6f20              LDR      r0,[r4,#0x70]         ;815
0000e6  b920              CBNZ     r0,|L2.242|
0000e8  6ee0              LDR      r0,[r4,#0x6c]         ;815
0000ea  b910              CBNZ     r0,|L2.242|
0000ec  a023              ADR      r0,|L2.380|
0000ee  f7fffffe          BL       __2printf
                  |L2.242|
0000f2  2000              MOVS     r0,#0                 ;819
0000f4  e7cf              B        |L2.150|
;;;821    
                          ENDP

0000f6  0000              DCW      0x0000
                  |L2.248|
                          DCD      ||.conststring||
                  |L2.252|
0000fc  7463705f          DCB      "tcp_enqueue_flags: check that first pbuf can hold optle"
000100  656e7175
000104  6575655f
000108  666c6167
00010c  733a2063
000110  6865636b
000114  20746861
000118  74206669
00011c  72737420
000120  70627566
000124  2063616e
000128  20686f6c
00012c  64206f70
000130  746c65  
000133  6e00              DCB      "n",0
000135  00                DCB      0
000136  00                DCB      0
000137  00                DCB      0
                  |L2.312|
000138  7365672d          DCB      "seg->tcphdr not aligned",0
00013c  3e746370
000140  68647220
000144  6e6f7420
000148  616c6967
00014c  6e656400
                  |L2.336|
000150  7463705f          DCB      "tcp_enqueue_flags: invalid segment length",0
000154  656e7175
000158  6575655f
00015c  666c6167
000160  733a2069
000164  6e76616c
000168  69642073
00016c  65676d65
000170  6e74206c
000174  656e6774
000178  6800    
00017a  00                DCB      0
00017b  00                DCB      0
                  |L2.380|
00017c  7463705f          DCB      "tcp_enqueue_flags: invalid queue length",0
000180  656e7175
000184  6575655f
000188  666c6167
00018c  733a2069
000190  6e76616c
000194  69642071
000198  75657565
00019c  206c656e
0001a0  67746800

                          AREA ||i.tcp_keepalive||, CODE, READONLY, ALIGN=1

                  tcp_keepalive PROC
;;;1364   void
;;;1365   tcp_keepalive(struct tcp_pcb *pcb)
000000  b57c              PUSH     {r2-r6,lr}
;;;1366   {
000002  4604              MOV      r4,r0
;;;1367     struct pbuf *p;
;;;1368     struct tcp_hdr *tcphdr;
;;;1369   
;;;1370     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: sending KEEPALIVE probe to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;1371                             ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
;;;1372                             ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
;;;1373   
;;;1374     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
;;;1375                             tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
;;;1376      
;;;1377     p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
000004  6d00              LDR      r0,[r0,#0x50]
000006  1e40              SUBS     r0,r0,#1
000008  f7fffffe          BL       lwip_htonl
00000c  4603              MOV      r3,r0
00000e  2200              MOVS     r2,#0
000010  4611              MOV      r1,r2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       tcp_output_alloc_header
000018  0005              MOVS     r5,r0
;;;1378     if(p == NULL) {
00001a  d00e              BEQ      |L3.58|
;;;1379       LWIP_DEBUGF(TCP_DEBUG, 
;;;1380                   ("tcp_keepalive: could not allocate memory for pbuf\n"));
;;;1381       return;
;;;1382     }
;;;1383     tcphdr = (struct tcp_hdr *)p->payload;
;;;1384   
;;;1385   #if CHECKSUM_GEN_TCP
;;;1386     tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
;;;1387                                         IP_PROTO_TCP, p->tot_len);
;;;1388   #endif
;;;1389     TCP_STATS_INC(tcp.xmit);
;;;1390   
;;;1391     /* Send output to IP */
;;;1392   #if LWIP_NETIF_HWADDRHINT
;;;1393     ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
;;;1394       &(pcb->addr_hint));
;;;1395   #else /* LWIP_NETIF_HWADDRHINT*/
;;;1396     ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
00001c  2106              MOVS     r1,#6
00001e  2000              MOVS     r0,#0
000020  e9cd0100          STRD     r0,r1,[sp,#0]
000024  7aa3              LDRB     r3,[r4,#0xa]
000026  1d22              ADDS     r2,r4,#4
000028  4621              MOV      r1,r4
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       ip_output
;;;1397   #endif /* LWIP_NETIF_HWADDRHINT*/
;;;1398   
;;;1399     pbuf_free(p);
000030  4628              MOV      r0,r5
000032  e8bd407c          POP      {r2-r6,lr}
000036  f7ffbffe          B.W      pbuf_free
                  |L3.58|
;;;1400   
;;;1401     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
;;;1402                             pcb->snd_nxt - 1, pcb->rcv_nxt));
;;;1403   }
00003a  bd7c              POP      {r2-r6,pc}
;;;1404   
                          ENDP


                          AREA ||i.tcp_output||, CODE, READONLY, ALIGN=2

                  tcp_output PROC
;;;898    err_t
;;;899    tcp_output(struct tcp_pcb *pcb)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;900    {
000004  4604              MOV      r4,r0
;;;901      struct tcp_seg *seg, *useg;
;;;902      u32_t wnd, snd_nxt;
;;;903    #if TCP_CWND_DEBUG
;;;904      s16_t i = 0;
;;;905    #endif /* TCP_CWND_DEBUG */
;;;906    
;;;907      /* pcb->state LISTEN not allowed here */
;;;908      LWIP_ASSERT("don't call tcp_output for listen-pcbs",
000006  7e00              LDRB     r0,[r0,#0x18]
000008  2801              CMP      r0,#1
00000a  d102              BNE      |L4.18|
00000c  a065              ADR      r0,|L4.420|
00000e  f7fffffe          BL       __2printf
                  |L4.18|
;;;909        pcb->state != LISTEN);
;;;910    
;;;911      /* First, check if we are invoked by the TCP input processing
;;;912         code. If so, we do not output anything. Instead, we rely on the
;;;913         input processing code to call us when input processing is done
;;;914         with. */
;;;915      if (tcp_input_pcb == pcb) {
000012  486e              LDR      r0,|L4.460|
000014  6800              LDR      r0,[r0,#0]  ; tcp_input_pcb
000016  42a0              CMP      r0,r4
000018  d102              BNE      |L4.32|
                  |L4.26|
;;;916        return ERR_OK;
00001a  2000              MOVS     r0,#0
;;;917      }
;;;918    
;;;919      wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
;;;920    
;;;921      seg = pcb->unsent;
;;;922    
;;;923      /* If the TF_ACK_NOW flag is set and no data will be sent (either
;;;924       * because the ->unsent queue is empty or because the window does
;;;925       * not allow it), construct an empty ACK segment and send it.
;;;926       *
;;;927       * If data is to be sent, we will just piggyback the ACK (see below).
;;;928       */
;;;929      if (pcb->flags & TF_ACK_NOW &&
;;;930         (seg == NULL ||
;;;931          ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
;;;932         return tcp_send_empty_ack(pcb);
;;;933      }
;;;934    
;;;935      /* useg should point to last segment on unacked queue */
;;;936      useg = pcb->unacked;
;;;937      if (useg != NULL) {
;;;938        for (; useg->next != NULL; useg = useg->next);
;;;939      }
;;;940    
;;;941    #if TCP_OUTPUT_DEBUG
;;;942      if (seg == NULL) {
;;;943        LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: nothing to send (%p)\n",
;;;944                                       (void*)pcb->unsent));
;;;945      }
;;;946    #endif /* TCP_OUTPUT_DEBUG */
;;;947    #if TCP_CWND_DEBUG
;;;948      if (seg == NULL) {
;;;949        LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"U16_F
;;;950                                     ", cwnd %"U16_F", wnd %"U32_F
;;;951                                     ", seg == NULL, ack %"U32_F"\n",
;;;952                                     pcb->snd_wnd, pcb->cwnd, wnd, pcb->lastack));
;;;953      } else {
;;;954        LWIP_DEBUGF(TCP_CWND_DEBUG, 
;;;955                    ("tcp_output: snd_wnd %"U16_F", cwnd %"U16_F", wnd %"U32_F
;;;956                     ", effwnd %"U32_F", seq %"U32_F", ack %"U32_F"\n",
;;;957                     pcb->snd_wnd, pcb->cwnd, wnd,
;;;958                     ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
;;;959                     ntohl(seg->tcphdr->seqno), pcb->lastack));
;;;960      }
;;;961    #endif /* TCP_CWND_DEBUG */
;;;962      /* data available and window allows it to be sent? */
;;;963      while (seg != NULL &&
;;;964             ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
;;;965        LWIP_ASSERT("RST not expected here!", 
;;;966                    (TCPH_FLAGS(seg->tcphdr) & TCP_RST) == 0);
;;;967        /* Stop sending if the nagle algorithm would prevent it
;;;968         * Don't stop:
;;;969         * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
;;;970         * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
;;;971         *   either seg->next != NULL or pcb->unacked == NULL;
;;;972         *   RST is no sent using tcp_write/tcp_output.
;;;973         */
;;;974        if((tcp_do_output_nagle(pcb) == 0) &&
;;;975          ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
;;;976          break;
;;;977        }
;;;978    #if TCP_CWND_DEBUG
;;;979        LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"U16_F", cwnd %"U16_F", wnd %"U32_F", effwnd %"U32_F", seq %"U32_F", ack %"U32_F", i %"S16_F"\n",
;;;980                                pcb->snd_wnd, pcb->cwnd, wnd,
;;;981                                ntohl(seg->tcphdr->seqno) + seg->len -
;;;982                                pcb->lastack,
;;;983                                ntohl(seg->tcphdr->seqno), pcb->lastack, i));
;;;984        ++i;
;;;985    #endif /* TCP_CWND_DEBUG */
;;;986    
;;;987        pcb->unsent = seg->next;
;;;988    
;;;989        if (pcb->state != SYN_SENT) {
;;;990          TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
;;;991          pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
;;;992        }
;;;993    
;;;994        tcp_output_segment(seg, pcb);
;;;995        snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
;;;996        if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
;;;997          pcb->snd_nxt = snd_nxt;
;;;998        }
;;;999        /* put segment on unacknowledged list if length > 0 */
;;;1000       if (TCP_TCPLEN(seg) > 0) {
;;;1001         seg->next = NULL;
;;;1002         /* unacked list is empty? */
;;;1003         if (pcb->unacked == NULL) {
;;;1004           pcb->unacked = seg;
;;;1005           useg = seg;
;;;1006         /* unacked list is not empty? */
;;;1007         } else {
;;;1008           /* In the case of fast retransmit, the packet should not go to the tail
;;;1009            * of the unacked queue, but rather somewhere before it. We need to check for
;;;1010            * this case. -STJ Jul 27, 2004 */
;;;1011           if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
;;;1012             /* add segment to before tail of unacked list, keeping the list sorted */
;;;1013             struct tcp_seg **cur_seg = &(pcb->unacked);
;;;1014             while (*cur_seg &&
;;;1015               TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
;;;1016                 cur_seg = &((*cur_seg)->next );
;;;1017             }
;;;1018             seg->next = (*cur_seg);
;;;1019             (*cur_seg) = seg;
;;;1020           } else {
;;;1021             /* add segment to tail of unacked list */
;;;1022             useg->next = seg;
;;;1023             useg = useg->next;
;;;1024           }
;;;1025         }
;;;1026       /* do not queue empty segments on the unacked list */
;;;1027       } else {
;;;1028         tcp_seg_free(seg);
;;;1029       }
;;;1030       seg = pcb->unsent;
;;;1031     }
;;;1032   #if TCP_OVERSIZE
;;;1033     if (pcb->unsent == NULL) {
;;;1034       /* last unsent has been removed, reset unsent_oversize */
;;;1035       pcb->unsent_oversize = 0;
;;;1036     }
;;;1037   #endif /* TCP_OVERSIZE */
;;;1038   
;;;1039     pcb->flags &= ~TF_NAGLEMEMERR;
;;;1040     return ERR_OK;
;;;1041   }
00001c  e8bd87f0          POP      {r4-r10,pc}
                  |L4.32|
000020  f8b40060          LDRH     r0,[r4,#0x60]         ;919
000024  f8b4104c          LDRH     r1,[r4,#0x4c]         ;919
000028  4288              CMP      r0,r1                 ;919
00002a  d300              BCC      |L4.46|
00002c  4608              MOV      r0,r1                 ;919
                  |L4.46|
00002e  4681              MOV      r9,r0                 ;919
000030  7fa0              LDRB     r0,[r4,#0x1e]         ;929
000032  6ee5              LDR      r5,[r4,#0x6c]         ;929
000034  0780              LSLS     r0,r0,#30             ;929
000036  d50f              BPL      |L4.88|
000038  b14d              CBZ      r5,|L4.78|
00003a  68e8              LDR      r0,[r5,#0xc]          ;931
00003c  6840              LDR      r0,[r0,#4]            ;931
00003e  f7fffffe          BL       lwip_ntohl
000042  6ca1              LDR      r1,[r4,#0x48]         ;931
000044  1a40              SUBS     r0,r0,r1              ;931
000046  8929              LDRH     r1,[r5,#8]            ;931
000048  4401              ADD      r1,r1,r0              ;931
00004a  4549              CMP      r1,r9                 ;931
00004c  d904              BLS      |L4.88|
                  |L4.78|
00004e  4620              MOV      r0,r4                 ;932
000050  e8bd47f0          POP      {r4-r10,lr}           ;932
000054  f7ffbffe          B.W      tcp_send_empty_ack
                  |L4.88|
000058  f8d48070          LDR      r8,[r4,#0x70]         ;937
00005c  f04f0a00          MOV      r10,#0                ;937
000060  ea5f0008          MOVS     r0,r8                 ;937
000064  d101              BNE      |L4.106|
000066  e087              B        |L4.376|
                  |L4.104|
000068  4680              MOV      r8,r0                 ;938
                  |L4.106|
00006a  f8d80000          LDR      r0,[r8,#0]            ;938
00006e  2800              CMP      r0,#0                 ;938
000070  d1fa              BNE      |L4.104|
000072  e081              B        |L4.376|
                  |L4.116|
000074  68e8              LDR      r0,[r5,#0xc]          ;965
000076  8980              LDRH     r0,[r0,#0xc]          ;965
000078  f7fffffe          BL       lwip_ntohs
00007c  0740              LSLS     r0,r0,#29             ;965
00007e  d502              BPL      |L4.134|
000080  a053              ADR      r0,|L4.464|
000082  f7fffffe          BL       __2printf
                  |L4.134|
000086  6f20              LDR      r0,[r4,#0x70]         ;974
000088  b1a8              CBZ      r0,|L4.182|
00008a  7fa1              LDRB     r1,[r4,#0x1e]         ;974
00008c  f0110f44          TST      r1,#0x44              ;974
000090  d111              BNE      |L4.182|
000092  6ee0              LDR      r0,[r4,#0x6c]         ;974
000094  b128              CBZ      r0,|L4.162|
000096  6802              LDR      r2,[r0,#0]            ;974
000098  b96a              CBNZ     r2,|L4.182|
00009a  8900              LDRH     r0,[r0,#8]            ;974
00009c  8ee2              LDRH     r2,[r4,#0x36]         ;974
00009e  4290              CMP      r0,r2                 ;974
0000a0  d209              BCS      |L4.182|
                  |L4.162|
0000a2  f8b40066          LDRH     r0,[r4,#0x66]         ;974
0000a6  b130              CBZ      r0,|L4.182|
0000a8  f8b40068          LDRH     r0,[r4,#0x68]         ;974
0000ac  2810              CMP      r0,#0x10              ;974
0000ae  d202              BCS      |L4.182|
0000b0  f0110fa0          TST      r1,#0xa0              ;975
0000b4  d06c              BEQ      |L4.400|
                  |L4.182|
0000b6  6828              LDR      r0,[r5,#0]            ;987
0000b8  66e0              STR      r0,[r4,#0x6c]         ;989
0000ba  7e20              LDRB     r0,[r4,#0x18]         ;989
0000bc  2802              CMP      r0,#2                 ;989
0000be  d00b              BEQ      |L4.216|
0000c0  2010              MOVS     r0,#0x10              ;990
0000c2  f7fffffe          BL       lwip_htons
0000c6  4601              MOV      r1,r0                 ;990
0000c8  68e8              LDR      r0,[r5,#0xc]          ;990
0000ca  8982              LDRH     r2,[r0,#0xc]          ;990
0000cc  4311              ORRS     r1,r1,r2              ;990
0000ce  8181              STRH     r1,[r0,#0xc]          ;990
0000d0  7fa0              LDRB     r0,[r4,#0x1e]         ;991
0000d2  f0200003          BIC      r0,r0,#3              ;991
0000d6  77a0              STRB     r0,[r4,#0x1e]         ;991
                  |L4.216|
0000d8  4621              MOV      r1,r4                 ;994
0000da  4628              MOV      r0,r5                 ;994
0000dc  f7fffffe          BL       tcp_output_segment
0000e0  68e8              LDR      r0,[r5,#0xc]          ;995
0000e2  6840              LDR      r0,[r0,#4]            ;995
0000e4  f7fffffe          BL       lwip_ntohl
0000e8  4606              MOV      r6,r0                 ;995
0000ea  68e8              LDR      r0,[r5,#0xc]          ;995
0000ec  8980              LDRH     r0,[r0,#0xc]          ;995
0000ee  f7fffffe          BL       lwip_ntohs
0000f2  0780              LSLS     r0,r0,#30             ;995
0000f4  d000              BEQ      |L4.248|
0000f6  2001              MOVS     r0,#1                 ;995
                  |L4.248|
0000f8  8929              LDRH     r1,[r5,#8]            ;995
0000fa  4430              ADD      r0,r0,r6              ;995
0000fc  4408              ADD      r0,r0,r1              ;995
0000fe  6d21              LDR      r1,[r4,#0x50]         ;996
000100  1a09              SUBS     r1,r1,r0              ;996
000102  d500              BPL      |L4.262|
000104  6520              STR      r0,[r4,#0x50]         ;997
                  |L4.262|
000106  68e8              LDR      r0,[r5,#0xc]          ;1000
000108  8980              LDRH     r0,[r0,#0xc]          ;1000
00010a  f7fffffe          BL       lwip_ntohs
00010e  0780              LSLS     r0,r0,#30             ;1000
000110  d000              BEQ      |L4.276|
000112  2001              MOVS     r0,#1                 ;1000
                  |L4.276|
000114  8929              LDRH     r1,[r5,#8]            ;1000
000116  42c8              CMN      r0,r1                 ;1000
000118  d02a              BEQ      |L4.368|
00011a  f8c5a000          STR      r10,[r5,#0]           ;1003
00011e  6f20              LDR      r0,[r4,#0x70]         ;1003
000120  b170              CBZ      r0,|L4.320|
000122  68e8              LDR      r0,[r5,#0xc]          ;1011
000124  6840              LDR      r0,[r0,#4]            ;1011
000126  f7fffffe          BL       lwip_ntohl
00012a  4606              MOV      r6,r0                 ;1011
00012c  f8d8000c          LDR      r0,[r8,#0xc]          ;1011
000130  6840              LDR      r0,[r0,#4]            ;1011
000132  f7fffffe          BL       lwip_ntohl
000136  1a30              SUBS     r0,r6,r0              ;1011
000138  d516              BPL      |L4.360|
00013a  f1040670          ADD      r6,r4,#0x70           ;1013
00013e  e002              B        |L4.326|
                  |L4.320|
000140  6725              STR      r5,[r4,#0x70]         ;1005
000142  e013              B        |L4.364|
                  |L4.324|
000144  6836              LDR      r6,[r6,#0]            ;1016
                  |L4.326|
000146  6830              LDR      r0,[r6,#0]            ;1014
000148  b150              CBZ      r0,|L4.352|
00014a  68c0              LDR      r0,[r0,#0xc]          ;1015
00014c  6840              LDR      r0,[r0,#4]            ;1015
00014e  f7fffffe          BL       lwip_ntohl
000152  4607              MOV      r7,r0                 ;1015
000154  68e8              LDR      r0,[r5,#0xc]          ;1015
000156  6840              LDR      r0,[r0,#4]            ;1015
000158  f7fffffe          BL       lwip_ntohl
00015c  1a38              SUBS     r0,r7,r0              ;1015
00015e  d4f1              BMI      |L4.324|
                  |L4.352|
000160  6830              LDR      r0,[r6,#0]            ;1018
000162  6028              STR      r0,[r5,#0]            ;1019
000164  6035              STR      r5,[r6,#0]            ;1020
000166  e006              B        |L4.374|
                  |L4.360|
000168  f8c85000          STR      r5,[r8,#0]            ;1022
                  |L4.364|
00016c  46a8              MOV      r8,r5                 ;1023
00016e  e002              B        |L4.374|
                  |L4.368|
000170  4628              MOV      r0,r5                 ;1028
000172  f7fffffe          BL       tcp_seg_free
                  |L4.374|
000176  6ee5              LDR      r5,[r4,#0x6c]         ;1030
                  |L4.376|
000178  b155              CBZ      r5,|L4.400|
00017a  68e8              LDR      r0,[r5,#0xc]          ;964
00017c  6840              LDR      r0,[r0,#4]            ;964
00017e  f7fffffe          BL       lwip_ntohl
000182  6ca1              LDR      r1,[r4,#0x48]         ;964
000184  1a40              SUBS     r0,r0,r1              ;964
000186  8929              LDRH     r1,[r5,#8]            ;964
000188  4401              ADD      r1,r1,r0              ;964
00018a  4549              CMP      r1,r9                 ;964
00018c  f67faf72          BLS      |L4.116|
                  |L4.400|
000190  6ee0              LDR      r0,[r4,#0x6c]         ;1033
000192  b908              CBNZ     r0,|L4.408|
000194  f8a4a06a          STRH     r10,[r4,#0x6a]        ;1035
                  |L4.408|
000198  7fa0              LDRB     r0,[r4,#0x1e]         ;1039
00019a  f0200080          BIC      r0,r0,#0x80           ;1039
00019e  77a0              STRB     r0,[r4,#0x1e]         ;1039
0001a0  e73b              B        |L4.26|
;;;1042   
                          ENDP

0001a2  0000              DCW      0x0000
                  |L4.420|
0001a4  646f6e27          DCB      "don't call tcp_output for listen-pcbs",0
0001a8  74206361
0001ac  6c6c2074
0001b0  63705f6f
0001b4  75747075
0001b8  7420666f
0001bc  72206c69
0001c0  7374656e
0001c4  2d706362
0001c8  7300    
0001ca  00                DCB      0
0001cb  00                DCB      0
                  |L4.460|
                          DCD      tcp_input_pcb
                  |L4.464|
0001d0  52535420          DCB      "RST not expected here!",0
0001d4  6e6f7420
0001d8  65787065
0001dc  63746564
0001e0  20686572
0001e4  652100  
0001e7  00                DCB      0

                          AREA ||i.tcp_output_alloc_header||, CODE, READONLY, ALIGN=2

                  tcp_output_alloc_header PROC
;;;93     static struct pbuf *
;;;94     tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;95                           u32_t seqno_be /* already in network byte order */)
;;;96     {
000004  4605              MOV      r5,r0
;;;97       struct tcp_hdr *tcphdr;
;;;98       struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
000006  1888              ADDS     r0,r1,r2
000008  460f              MOV      r7,r1                 ;96
00000a  3014              ADDS     r0,r0,#0x14
00000c  b281              UXTH     r1,r0
00000e  4698              MOV      r8,r3                 ;96
000010  2200              MOVS     r2,#0
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       pbuf_alloc
000018  0006              MOVS     r6,r0
;;;99       if (p != NULL) {
00001a  d02b              BEQ      |L5.116|
;;;100        LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
00001c  8971              LDRH     r1,[r6,#0xa]
00001e  f1070014          ADD      r0,r7,#0x14
000022  4281              CMP      r1,r0
000024  d202              BCS      |L5.44|
000026  a015              ADR      r0,|L5.124|
000028  f7fffffe          BL       __2printf
                  |L5.44|
;;;101                     (p->len >= TCP_HLEN + optlen));
;;;102        tcphdr = (struct tcp_hdr *)p->payload;
;;;103        tcphdr->src = htons(pcb->local_port);
00002c  8b68              LDRH     r0,[r5,#0x1a]
00002e  6874              LDR      r4,[r6,#4]
000030  f7fffffe          BL       lwip_htons
000034  8020              STRH     r0,[r4,#0]
;;;104        tcphdr->dest = htons(pcb->remote_port);
000036  8ba8              LDRH     r0,[r5,#0x1c]
000038  f7fffffe          BL       lwip_htons
00003c  8060              STRH     r0,[r4,#2]
;;;105        tcphdr->seqno = seqno_be;
00003e  f8c48004          STR      r8,[r4,#4]
;;;106        tcphdr->ackno = htonl(pcb->rcv_nxt);
000042  6aa8              LDR      r0,[r5,#0x28]
000044  f7fffffe          BL       lwip_htonl
000048  60a0              STR      r0,[r4,#8]
;;;107        TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
00004a  08b8              LSRS     r0,r7,#2
00004c  0300              LSLS     r0,r0,#12
00004e  f50040a0          ADD      r0,r0,#0x5000
000052  b280              UXTH     r0,r0
000054  f0400010          ORR      r0,r0,#0x10
000058  f7fffffe          BL       lwip_htons
00005c  81a0              STRH     r0,[r4,#0xc]
;;;108        tcphdr->wnd = htons(pcb->rcv_ann_wnd);
00005e  8de8              LDRH     r0,[r5,#0x2e]
000060  f7fffffe          BL       lwip_htons
000064  81e0              STRH     r0,[r4,#0xe]
;;;109        tcphdr->chksum = 0;
000066  2000              MOVS     r0,#0
000068  8220              STRH     r0,[r4,#0x10]
;;;110        tcphdr->urgp = 0;
00006a  8260              STRH     r0,[r4,#0x12]
;;;111    
;;;112        /* If we're sending a packet, update the announced right window edge */
;;;113        pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
00006c  8de9              LDRH     r1,[r5,#0x2e]
00006e  6aa8              LDR      r0,[r5,#0x28]
000070  4408              ADD      r0,r0,r1
000072  6328              STR      r0,[r5,#0x30]
                  |L5.116|
;;;114      }
;;;115      return p;
000074  4630              MOV      r0,r6
;;;116    }
000076  e8bd81f0          POP      {r4-r8,pc}
;;;117    
                          ENDP

00007a  0000              DCW      0x0000
                  |L5.124|
00007c  63686563          DCB      "check that first pbuf can hold struct tcp_hdr",0
000080  6b207468
000084  61742066
000088  69727374
00008c  20706275
000090  66206361
000094  6e20686f
000098  6c642073
00009c  74727563
0000a0  74207463
0000a4  705f6864
0000a8  7200    
0000aa  00                DCB      0
0000ab  00                DCB      0

                          AREA ||i.tcp_output_segment||, CODE, READONLY, ALIGN=2

                  tcp_output_segment PROC
;;;1049   static void
;;;1050   tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
000000  b57c              PUSH     {r2-r6,lr}
;;;1051   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1052     u16_t len;
;;;1053     struct netif *netif;
;;;1054     u32_t *opts;
;;;1055   
;;;1056     /** @bug Exclude retransmitted segments from this count. */
;;;1057     snmp_inc_tcpoutsegs();
;;;1058   
;;;1059     /* The TCP header has already been constructed, but the ackno and
;;;1060      wnd fields remain. */
;;;1061     seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
000006  6a88              LDR      r0,[r1,#0x28]
000008  f7fffffe          BL       lwip_htonl
00000c  68e9              LDR      r1,[r5,#0xc]
00000e  6088              STR      r0,[r1,#8]
;;;1062   
;;;1063     /* advertise our receive window size in this TCP segment */
;;;1064     seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
000010  8de0              LDRH     r0,[r4,#0x2e]
000012  f7fffffe          BL       lwip_htons
000016  68e9              LDR      r1,[r5,#0xc]
000018  81c8              STRH     r0,[r1,#0xe]
;;;1065   
;;;1066     pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
00001a  8de1              LDRH     r1,[r4,#0x2e]
00001c  6aa0              LDR      r0,[r4,#0x28]
00001e  4408              ADD      r0,r0,r1
;;;1067   
;;;1068     /* Add any requested options.  NB MSS option is only set on SYN
;;;1069        packets, so ignore it here */
;;;1070     opts = (u32_t *)(void *)(seg->tcphdr + 1);
000020  6320              STR      r0,[r4,#0x30]
;;;1071     if (seg->flags & TF_SEG_OPTS_MSS) {
000022  68ee              LDR      r6,[r5,#0xc]
000024  7aa8              LDRB     r0,[r5,#0xa]
000026  3614              ADDS     r6,r6,#0x14
000028  07c0              LSLS     r0,r0,#31
00002a  d009              BEQ      |L6.64|
;;;1072       u16_t mss;
;;;1073   #if TCP_CALCULATE_EFF_SEND_MSS
;;;1074       mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
00002c  1d21              ADDS     r1,r4,#4
00002e  f44f60aa          MOV      r0,#0x550
000032  f7fffffe          BL       tcp_eff_send_mss
;;;1075   #else /* TCP_CALCULATE_EFF_SEND_MSS */
;;;1076       mss = TCP_MSS;
;;;1077   #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;1078       *opts = TCP_BUILD_MSS_OPTION(mss);
000036  f0407001          ORR      r0,r0,#0x2040000
00003a  f7fffffe          BL       lwip_htonl
00003e  6030              STR      r0,[r6,#0]
                  |L6.64|
;;;1079       opts += 1;
;;;1080     }
;;;1081   #if LWIP_TCP_TIMESTAMPS
;;;1082     pcb->ts_lastacksent = pcb->rcv_nxt;
;;;1083   
;;;1084     if (seg->flags & TF_SEG_OPTS_TS) {
;;;1085       tcp_build_timestamp_option(pcb, opts);
;;;1086       opts += 3;
;;;1087     }
;;;1088   #endif
;;;1089   
;;;1090     /* Set retransmission timer running if it is not currently enabled 
;;;1091        This must be set before checking the route. */
;;;1092     if (pcb->rtime == -1) {
000040  f9b40034          LDRSH    r0,[r4,#0x34]
000044  2600              MOVS     r6,#0
000046  1c40              ADDS     r0,r0,#1
000048  d100              BNE      |L6.76|
;;;1093       pcb->rtime = 0;
00004a  86a6              STRH     r6,[r4,#0x34]
                  |L6.76|
;;;1094     }
;;;1095   
;;;1096     /* If we don't have a local IP address, we get one by
;;;1097        calling ip_route(). */
;;;1098     if (ip_addr_isany(&(pcb->local_ip))) {
00004c  b10c              CBZ      r4,|L6.82|
00004e  6820              LDR      r0,[r4,#0]
000050  b930              CBNZ     r0,|L6.96|
                  |L6.82|
;;;1099       netif = ip_route(&(pcb->remote_ip));
000052  1d20              ADDS     r0,r4,#4
000054  f7fffffe          BL       ip_route
;;;1100       if (netif == NULL) {
000058  2800              CMP      r0,#0
00005a  d025              BEQ      |L6.168|
;;;1101         return;
;;;1102       }
;;;1103       ip_addr_copy(pcb->local_ip, netif->ip_addr);
00005c  6840              LDR      r0,[r0,#4]
00005e  6020              STR      r0,[r4,#0]
                  |L6.96|
;;;1104     }
;;;1105   
;;;1106     if (pcb->rttest == 0) {
000060  6ba0              LDR      r0,[r4,#0x38]
000062  b938              CBNZ     r0,|L6.116|
;;;1107       pcb->rttest = tcp_ticks;
000064  4811              LDR      r0,|L6.172|
000066  6800              LDR      r0,[r0,#0]  ; tcp_ticks
;;;1108       pcb->rtseq = ntohl(seg->tcphdr->seqno);
000068  63a0              STR      r0,[r4,#0x38]
00006a  68e8              LDR      r0,[r5,#0xc]
00006c  6840              LDR      r0,[r0,#4]
00006e  f7fffffe          BL       lwip_ntohl
000072  63e0              STR      r0,[r4,#0x3c]
                  |L6.116|
;;;1109   
;;;1110       LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_output_segment: rtseq %"U32_F"\n", pcb->rtseq));
;;;1111     }
;;;1112     LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
;;;1113             htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
;;;1114             seg->len));
;;;1115   
;;;1116     len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
000074  6869              LDR      r1,[r5,#4]
000076  89a8              LDRH     r0,[r5,#0xc]
000078  888a              LDRH     r2,[r1,#4]
00007a  1a80              SUBS     r0,r0,r2
;;;1117   
;;;1118     seg->p->len -= len;
00007c  894a              LDRH     r2,[r1,#0xa]
00007e  1a12              SUBS     r2,r2,r0
000080  814a              STRH     r2,[r1,#0xa]
;;;1119     seg->p->tot_len -= len;
000082  6869              LDR      r1,[r5,#4]
000084  890a              LDRH     r2,[r1,#8]
000086  1a10              SUBS     r0,r2,r0
000088  8108              STRH     r0,[r1,#8]
;;;1120   
;;;1121     seg->p->payload = seg->tcphdr;
00008a  6869              LDR      r1,[r5,#4]
00008c  68e8              LDR      r0,[r5,#0xc]
;;;1122   
;;;1123     seg->tcphdr->chksum = 0;
;;;1124   #if CHECKSUM_GEN_TCP
;;;1125   #if TCP_CHECKSUM_ON_COPY
;;;1126     {
;;;1127       u32_t acc;
;;;1128   #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
;;;1129       u16_t chksum_slow = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
;;;1130              &(pcb->remote_ip),
;;;1131              IP_PROTO_TCP, seg->p->tot_len);
;;;1132   #endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
;;;1133       if ((seg->flags & TF_SEG_DATA_CHECKSUMMED) == 0) {
;;;1134         LWIP_ASSERT("data included but not checksummed",
;;;1135           seg->p->tot_len == (TCPH_HDRLEN(seg->tcphdr) * 4));
;;;1136       }
;;;1137   
;;;1138       /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
;;;1139       acc = inet_chksum_pseudo_partial(seg->p, &(pcb->local_ip),
;;;1140                &(pcb->remote_ip),
;;;1141                IP_PROTO_TCP, seg->p->tot_len, TCPH_HDRLEN(seg->tcphdr) * 4);
;;;1142       /* add payload checksum */
;;;1143       if (seg->chksum_swapped) {
;;;1144         seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
;;;1145         seg->chksum_swapped = 0;
;;;1146       }
;;;1147       acc += (u16_t)~(seg->chksum);
;;;1148       seg->tcphdr->chksum = FOLD_U32T(acc);
;;;1149   #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
;;;1150       if (chksum_slow != seg->tcphdr->chksum) {
;;;1151         LWIP_DEBUGF(TCP_DEBUG | LWIP_DBG_LEVEL_WARNING,
;;;1152                     ("tcp_output_segment: calculated checksum is %"X16_F" instead of %"X16_F"\n",
;;;1153                     seg->tcphdr->chksum, chksum_slow));
;;;1154         seg->tcphdr->chksum = chksum_slow;
;;;1155       }
;;;1156   #endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
;;;1157     }
;;;1158   #else /* TCP_CHECKSUM_ON_COPY */
;;;1159     seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
;;;1160            &(pcb->remote_ip),
;;;1161            IP_PROTO_TCP, seg->p->tot_len);
;;;1162   #endif /* TCP_CHECKSUM_ON_COPY */
;;;1163   #endif /* CHECKSUM_GEN_TCP */
;;;1164     TCP_STATS_INC(tcp.xmit);
;;;1165   
;;;1166   #if LWIP_NETIF_HWADDRHINT
;;;1167     ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
;;;1168         IP_PROTO_TCP, &(pcb->addr_hint));
;;;1169   #else /* LWIP_NETIF_HWADDRHINT*/
;;;1170     ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
00008e  1d22              ADDS     r2,r4,#4
000090  6048              STR      r0,[r1,#4]            ;1123
000092  68e8              LDR      r0,[r5,#0xc]          ;1123
000094  2106              MOVS     r1,#6
000096  8206              STRH     r6,[r0,#0x10]         ;1123
000098  7a60              LDRB     r0,[r4,#9]
00009a  e9cd0100          STRD     r0,r1,[sp,#0]
00009e  7aa3              LDRB     r3,[r4,#0xa]
0000a0  4621              MOV      r1,r4
0000a2  6868              LDR      r0,[r5,#4]
0000a4  f7fffffe          BL       ip_output
                  |L6.168|
;;;1171         IP_PROTO_TCP);
;;;1172   #endif /* LWIP_NETIF_HWADDRHINT*/
;;;1173   }
0000a8  bd7c              POP      {r2-r6,pc}
;;;1174   
                          ENDP

0000aa  0000              DCW      0x0000
                  |L6.172|
                          DCD      tcp_ticks

                          AREA ||i.tcp_pbuf_prealloc||, CODE, READONLY, ALIGN=2

                  tcp_pbuf_prealloc PROC
;;;218    static struct pbuf *
;;;219    tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;220                      u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
;;;221                      u8_t first_seg)
;;;222    {
000004  461e              MOV      r6,r3
000006  e9dd3706          LDRD     r3,r7,[sp,#0x18]
;;;223      struct pbuf *p;
;;;224      u16_t alloc = length;
;;;225    
;;;226    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;227      LWIP_UNUSED_ARG(max_length);
;;;228      LWIP_UNUSED_ARG(pcb);
;;;229      LWIP_UNUSED_ARG(apiflags);
;;;230      LWIP_UNUSED_ARG(first_seg);
;;;231      /* always create MSS-sized pbufs */
;;;232      alloc = max_length;
;;;233    #else /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;234      if (length < max_length) {
00000a  9c08              LDR      r4,[sp,#0x20]
00000c  460d              MOV      r5,r1                 ;222
00000e  4291              CMP      r1,r2
000010  d211              BCS      |L7.54|
;;;235        /* Should we allocate an oversized pbuf, or just the minimum
;;;236         * length required? If tcp_write is going to be called again
;;;237         * before this segment is transmitted, we want the oversized
;;;238         * buffer. If the segment will be transmitted immediately, we can
;;;239         * save memory by allocating only length. We use a simple
;;;240         * heuristic based on the following information:
;;;241         *
;;;242         * Did the user set TCP_WRITE_FLAG_MORE?
;;;243         *
;;;244         * Will the Nagle algorithm defer transmission of this segment?
;;;245         */
;;;246        if ((apiflags & TCP_WRITE_FLAG_MORE) ||
000012  07bf              LSLS     r7,r7,#30
000014  d407              BMI      |L7.38|
;;;247            (!(pcb->flags & TF_NODELAY) &&
000016  7f9f              LDRB     r7,[r3,#0x1e]
000018  067f              LSLS     r7,r7,#25
00001a  d40c              BMI      |L7.54|
;;;248             (!first_seg ||
00001c  b11c              CBZ      r4,|L7.38|
;;;249              pcb->unsent != NULL ||
00001e  6edc              LDR      r4,[r3,#0x6c]
000020  b90c              CBNZ     r4,|L7.38|
;;;250              pcb->unacked != NULL))) {
000022  6f1b              LDR      r3,[r3,#0x70]
000024  b13b              CBZ      r3,|L7.54|
                  |L7.38|
;;;251          alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(length + TCP_OVERSIZE));
000026  f2055153          ADD      r1,r5,#0x553
00002a  f0210103          BIC      r1,r1,#3
00002e  4291              CMP      r1,r2
000030  d800              BHI      |L7.52|
000032  460a              MOV      r2,r1
                  |L7.52|
000034  b291              UXTH     r1,r2
                  |L7.54|
;;;252        }
;;;253      }
;;;254    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;255      p = pbuf_alloc(layer, alloc, PBUF_RAM);
000036  2200              MOVS     r2,#0
000038  f7fffffe          BL       pbuf_alloc
00003c  0004              MOVS     r4,r0
;;;256      if (p == NULL) {
00003e  d00c              BEQ      |L7.90|
;;;257        return NULL;
;;;258      }
;;;259      LWIP_ASSERT("need unchained pbuf", p->next == NULL);
000040  6820              LDR      r0,[r4,#0]
000042  b110              CBZ      r0,|L7.74|
000044  a006              ADR      r0,|L7.96|
000046  f7fffffe          BL       __2printf
                  |L7.74|
;;;260      *oversize = p->len - length;
00004a  8960              LDRH     r0,[r4,#0xa]
00004c  1b40              SUBS     r0,r0,r5
00004e  8030              STRH     r0,[r6,#0]
;;;261      /* trim p->len to the currently used size */
;;;262      p->len = p->tot_len = length;
000050  8125              STRH     r5,[r4,#8]
000052  8165              STRH     r5,[r4,#0xa]
;;;263      return p;
000054  4620              MOV      r0,r4
                  |L7.86|
;;;264    }
000056  e8bd81f0          POP      {r4-r8,pc}
                  |L7.90|
00005a  2000              MOVS     r0,#0                 ;257
00005c  e7fb              B        |L7.86|
;;;265    #else /* TCP_OVERSIZE */
                          ENDP

00005e  0000              DCW      0x0000
                  |L7.96|
000060  6e656564          DCB      "need unchained pbuf",0
000064  20756e63
000068  6861696e
00006c  65642070
000070  62756600

                          AREA ||i.tcp_rexmit||, CODE, READONLY, ALIGN=1

                  tcp_rexmit PROC
;;;1275   void
;;;1276   tcp_rexmit(struct tcp_pcb *pcb)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1277   {
000004  6f06              LDR      r6,[r0,#0x70]
000006  4605              MOV      r5,r0
000008  2e00              CMP      r6,#0
00000a  d020              BEQ      |L8.78|
;;;1278     struct tcp_seg *seg;
;;;1279     struct tcp_seg **cur_seg;
;;;1280   
;;;1281     if (pcb->unacked == NULL) {
;;;1282       return;
;;;1283     }
;;;1284   
;;;1285     /* Move the first unacked segment to the unsent queue */
;;;1286     /* Keep the unsent queue sorted. */
;;;1287     seg = pcb->unacked;
;;;1288     pcb->unacked = seg->next;
00000c  6830              LDR      r0,[r6,#0]
;;;1289   
;;;1290     cur_seg = &(pcb->unsent);
00000e  f105046c          ADD      r4,r5,#0x6c
;;;1291     while (*cur_seg &&
000012  6728              STR      r0,[r5,#0x70]
000014  e000              B        |L8.24|
                  |L8.22|
;;;1292       TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
;;;1293         cur_seg = &((*cur_seg)->next );
000016  6824              LDR      r4,[r4,#0]
                  |L8.24|
000018  6820              LDR      r0,[r4,#0]            ;1291
00001a  b150              CBZ      r0,|L8.50|
00001c  68c0              LDR      r0,[r0,#0xc]          ;1292
00001e  6840              LDR      r0,[r0,#4]            ;1292
000020  f7fffffe          BL       lwip_ntohl
000024  4607              MOV      r7,r0                 ;1292
000026  68f0              LDR      r0,[r6,#0xc]          ;1292
000028  6840              LDR      r0,[r0,#4]            ;1292
00002a  f7fffffe          BL       lwip_ntohl
00002e  1a38              SUBS     r0,r7,r0              ;1292
000030  d4f1              BMI      |L8.22|
                  |L8.50|
;;;1294     }
;;;1295     seg->next = *cur_seg;
000032  6820              LDR      r0,[r4,#0]
;;;1296     *cur_seg = seg;
000034  6030              STR      r0,[r6,#0]
;;;1297   #if TCP_OVERSIZE
;;;1298     if (seg->next == NULL) {
000036  6026              STR      r6,[r4,#0]
000038  6831              LDR      r1,[r6,#0]
00003a  2000              MOVS     r0,#0
00003c  b909              CBNZ     r1,|L8.66|
;;;1299       /* the retransmitted segment is last in unsent, so reset unsent_oversize */
;;;1300       pcb->unsent_oversize = 0;
00003e  f8a5006a          STRH     r0,[r5,#0x6a]
                  |L8.66|
;;;1301     }
;;;1302   #endif /* TCP_OVERSIZE */
;;;1303   
;;;1304     ++pcb->nrtx;
000042  f8151f46          LDRB     r1,[r5,#0x46]!
000046  1c49              ADDS     r1,r1,#1
000048  f805190e          STRB     r1,[r5],#-0xe
;;;1305   
;;;1306     /* Don't take any rtt measurements after retransmitting. */
;;;1307     pcb->rttest = 0;
00004c  6028              STR      r0,[r5,#0]
                  |L8.78|
;;;1308   
;;;1309     /* Do the actual retransmission. */
;;;1310     snmp_inc_tcpretranssegs();
;;;1311     /* No need to call tcp_output: we are always called from tcp_input()
;;;1312        and thus tcp_output directly returns. */
;;;1313   }
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;1314   
                          ENDP


                          AREA ||i.tcp_rexmit_fast||, CODE, READONLY, ALIGN=1

                  tcp_rexmit_fast PROC
;;;1321   void 
;;;1322   tcp_rexmit_fast(struct tcp_pcb *pcb)
000000  b510              PUSH     {r4,lr}
;;;1323   {
000002  4604              MOV      r4,r0
;;;1324     if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
000004  6f00              LDR      r0,[r0,#0x70]
000006  2800              CMP      r0,#0                 ;1323
000008  d025              BEQ      |L9.86|
00000a  7fa0              LDRB     r0,[r4,#0x1e]
00000c  0740              LSLS     r0,r0,#29
00000e  d422              BMI      |L9.86|
;;;1325       /* This is fast retransmit. Retransmit the first unacked segment. */
;;;1326       LWIP_DEBUGF(TCP_FR_DEBUG, 
;;;1327                   ("tcp_receive: dupacks %"U16_F" (%"U32_F
;;;1328                    "), fast retransmit %"U32_F"\n",
;;;1329                    (u16_t)pcb->dupacks, pcb->lastack,
;;;1330                    ntohl(pcb->unacked->tcphdr->seqno)));
;;;1331       tcp_rexmit(pcb);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       tcp_rexmit
;;;1332   
;;;1333       /* Set ssthresh to half of the minimum of the current
;;;1334        * cwnd and the advertised window */
;;;1335       if (pcb->cwnd > pcb->snd_wnd) {
000016  f8b4004c          LDRH     r0,[r4,#0x4c]
00001a  f8b41060          LDRH     r1,[r4,#0x60]
00001e  4288              CMP      r0,r1
000020  d901              BLS      |L9.38|
;;;1336         pcb->ssthresh = pcb->snd_wnd / 2;
000022  0848              LSRS     r0,r1,#1
000024  e000              B        |L9.40|
                  |L9.38|
;;;1337       } else {
;;;1338         pcb->ssthresh = pcb->cwnd / 2;
000026  0840              LSRS     r0,r0,#1
                  |L9.40|
000028  f8a4004e          STRH     r0,[r4,#0x4e]
;;;1339       }
;;;1340       
;;;1341       /* The minimum value for ssthresh should be 2 MSS */
;;;1342       if (pcb->ssthresh < 2*pcb->mss) {
00002c  b281              UXTH     r1,r0
00002e  8ee0              LDRH     r0,[r4,#0x36]
000030  ebb10f40          CMP      r1,r0,LSL #1
000034  d205              BCS      |L9.66|
;;;1343         LWIP_DEBUGF(TCP_FR_DEBUG, 
;;;1344                     ("tcp_receive: The minimum value for ssthresh %"U16_F
;;;1345                      " should be min 2 mss %"U16_F"...\n",
;;;1346                      pcb->ssthresh, 2*pcb->mss));
;;;1347         pcb->ssthresh = 2*pcb->mss;
000036  f64f71ff          MOV      r1,#0xffff
00003a  ea010140          AND      r1,r1,r0,LSL #1
00003e  f8a4104e          STRH     r1,[r4,#0x4e]
                  |L9.66|
;;;1348       }
;;;1349       
;;;1350       pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
000042  b289              UXTH     r1,r1
000044  eb000040          ADD      r0,r0,r0,LSL #1
000048  4408              ADD      r0,r0,r1
00004a  f8a4004c          STRH     r0,[r4,#0x4c]
;;;1351       pcb->flags |= TF_INFR;
00004e  7fa0              LDRB     r0,[r4,#0x1e]
000050  f0400004          ORR      r0,r0,#4
000054  77a0              STRB     r0,[r4,#0x1e]
                  |L9.86|
;;;1352     } 
;;;1353   }
000056  bd10              POP      {r4,pc}
;;;1354   
                          ENDP


                          AREA ||i.tcp_rexmit_rto||, CODE, READONLY, ALIGN=1

                  tcp_rexmit_rto PROC
;;;1239   void
;;;1240   tcp_rexmit_rto(struct tcp_pcb *pcb)
000000  6f01              LDR      r1,[r0,#0x70]
;;;1241   {
000002  2900              CMP      r1,#0
000004  d012              BEQ      |L10.44|
000006  e000              B        |L10.10|
                  |L10.8|
000008  4611              MOV      r1,r2
                  |L10.10|
;;;1242     struct tcp_seg *seg;
;;;1243   
;;;1244     if (pcb->unacked == NULL) {
;;;1245       return;
;;;1246     }
;;;1247   
;;;1248     /* Move all unacked segments to the head of the unsent queue */
;;;1249     for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
00000a  680a              LDR      r2,[r1,#0]
00000c  2a00              CMP      r2,#0
00000e  d1fb              BNE      |L10.8|
;;;1250     /* concatenate unsent queue after unacked queue */
;;;1251     seg->next = pcb->unsent;
000010  6ec2              LDR      r2,[r0,#0x6c]
;;;1252     /* unsent queue is the concatenated queue (of unacked, unsent) */
;;;1253     pcb->unsent = pcb->unacked;
000012  600a              STR      r2,[r1,#0]
000014  6f01              LDR      r1,[r0,#0x70]
;;;1254     /* unacked queue is now empty */
;;;1255     pcb->unacked = NULL;
000016  66c1              STR      r1,[r0,#0x6c]
000018  2100              MOVS     r1,#0
;;;1256     /* last unsent hasn't changed, no need to reset unsent_oversize */
;;;1257   
;;;1258     /* increment number of retransmissions */
;;;1259     ++pcb->nrtx;
00001a  6701              STR      r1,[r0,#0x70]
00001c  f8902046          LDRB     r2,[r0,#0x46]
000020  1c52              ADDS     r2,r2,#1
000022  f8802046          STRB     r2,[r0,#0x46]
;;;1260   
;;;1261     /* Don't take any RTT measurements after retransmitting. */
;;;1262     pcb->rttest = 0;
;;;1263   
;;;1264     /* Do the actual retransmission */
;;;1265     tcp_output(pcb);
000026  6381              STR      r1,[r0,#0x38]
000028  f7ffbffe          B.W      tcp_output
                  |L10.44|
;;;1266   }
00002c  4770              BX       lr
;;;1267   
                          ENDP


                          AREA ||i.tcp_rst||, CODE, READONLY, ALIGN=2

                  tcp_rst PROC
;;;1195   void
;;;1196   tcp_rst(u32_t seqno, u32_t ackno,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;1197     ip_addr_t *local_ip, ip_addr_t *remote_ip,
;;;1198     u16_t local_port, u16_t remote_port)
;;;1199   {
000004  4617              MOV      r7,r2
000006  e9dd9a0c          LDRD     r9,r10,[sp,#0x30]
00000a  4688              MOV      r8,r1
00000c  4683              MOV      r11,r0
00000e  461e              MOV      r6,r3
;;;1200     struct pbuf *p;
;;;1201     struct tcp_hdr *tcphdr;
;;;1202     p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
000010  2200              MOVS     r2,#0
000012  2114              MOVS     r1,#0x14
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       pbuf_alloc
00001a  0005              MOVS     r5,r0
;;;1203     if (p == NULL) {
00001c  d02f              BEQ      |L11.126|
;;;1204         LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
;;;1205         return;
;;;1206     }
;;;1207     LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
00001e  8968              LDRH     r0,[r5,#0xa]
000020  2814              CMP      r0,#0x14
000022  d202              BCS      |L11.42|
000024  a017              ADR      r0,|L11.132|
000026  f7fffffe          BL       __2printf
                  |L11.42|
;;;1208                 (p->len >= sizeof(struct tcp_hdr)));
;;;1209   
;;;1210     tcphdr = (struct tcp_hdr *)p->payload;
;;;1211     tcphdr->src = htons(local_port);
00002a  4648              MOV      r0,r9
00002c  686c              LDR      r4,[r5,#4]
00002e  f7fffffe          BL       lwip_htons
000032  8020              STRH     r0,[r4,#0]
;;;1212     tcphdr->dest = htons(remote_port);
000034  4650              MOV      r0,r10
000036  f7fffffe          BL       lwip_htons
00003a  8060              STRH     r0,[r4,#2]
;;;1213     tcphdr->seqno = htonl(seqno);
00003c  4658              MOV      r0,r11
00003e  f7fffffe          BL       lwip_htonl
000042  6060              STR      r0,[r4,#4]
;;;1214     tcphdr->ackno = htonl(ackno);
000044  4640              MOV      r0,r8
000046  f7fffffe          BL       lwip_htonl
00004a  60a0              STR      r0,[r4,#8]
;;;1215     TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
00004c  f2450014          MOV      r0,#0x5014
000050  f7fffffe          BL       lwip_htons
000054  81a0              STRH     r0,[r4,#0xc]
;;;1216     tcphdr->wnd = PP_HTONS(TCP_WND);
000056  f24a000a          MOV      r0,#0xa00a
00005a  81e0              STRH     r0,[r4,#0xe]
;;;1217     tcphdr->chksum = 0;
00005c  2000              MOVS     r0,#0
00005e  8220              STRH     r0,[r4,#0x10]
;;;1218     tcphdr->urgp = 0;
000060  8260              STRH     r0,[r4,#0x12]
;;;1219   
;;;1220   #if CHECKSUM_GEN_TCP
;;;1221     tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
;;;1222                 IP_PROTO_TCP, p->tot_len);
;;;1223   #endif
;;;1224     TCP_STATS_INC(tcp.xmit);
;;;1225     snmp_inc_tcpoutrsts();
;;;1226      /* Send output with hardcoded TTL since we have no access to the pcb */
;;;1227     ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
000062  2106              MOVS     r1,#6
000064  e9cd0100          STRD     r0,r1,[sp,#0]
000068  23ff              MOVS     r3,#0xff
00006a  4632              MOV      r2,r6
00006c  4639              MOV      r1,r7
00006e  4628              MOV      r0,r5
000070  f7fffffe          BL       ip_output
;;;1228     pbuf_free(p);
000074  4628              MOV      r0,r5
000076  e8bd5ffc          POP      {r2-r12,lr}
00007a  f7ffbffe          B.W      pbuf_free
                  |L11.126|
;;;1229     LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
;;;1230   }
00007e  e8bd9ffc          POP      {r2-r12,pc}
;;;1231   
                          ENDP

000082  0000              DCW      0x0000
                  |L11.132|
000084  63686563          DCB      "check that first pbuf can hold struct tcp_hdr",0
000088  6b207468
00008c  61742066
000090  69727374
000094  20706275
000098  66206361
00009c  6e20686f
0000a0  6c642073
0000a4  74727563
0000a8  74207463
0000ac  705f6864
0000b0  7200    
0000b2  00                DCB      0
0000b3  00                DCB      0

                          AREA ||i.tcp_send_empty_ack||, CODE, READONLY, ALIGN=1

                  tcp_send_empty_ack PROC
;;;842    err_t
;;;843    tcp_send_empty_ack(struct tcp_pcb *pcb)
000000  b57c              PUSH     {r2-r6,lr}
;;;844    {
000002  4604              MOV      r4,r0
;;;845      struct pbuf *p;
;;;846      struct tcp_hdr *tcphdr;
;;;847      u8_t optlen = 0;
000004  2500              MOVS     r5,#0
;;;848    
;;;849    #if LWIP_TCP_TIMESTAMPS
;;;850      if (pcb->flags & TF_TIMESTAMP) {
;;;851        optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
;;;852      }
;;;853    #endif
;;;854    
;;;855      p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
000006  6d00              LDR      r0,[r0,#0x50]
000008  f7fffffe          BL       lwip_htonl
00000c  4603              MOV      r3,r0
00000e  2200              MOVS     r2,#0
000010  4629              MOV      r1,r5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       tcp_output_alloc_header
000018  0005              MOVS     r5,r0
;;;856      if (p == NULL) {
00001a  d012              BEQ      |L12.66|
;;;857        LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
;;;858        return ERR_BUF;
;;;859      }
;;;860      tcphdr = (struct tcp_hdr *)p->payload;
;;;861      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
;;;862                  ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
;;;863      /* remove ACK flags from the PCB, as we send an empty ACK now */
;;;864      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
00001c  7fa0              LDRB     r0,[r4,#0x1e]
;;;865    
;;;866      /* NB. MSS option is only sent on SYNs, so ignore it here */
;;;867    #if LWIP_TCP_TIMESTAMPS
;;;868      pcb->ts_lastacksent = pcb->rcv_nxt;
;;;869    
;;;870      if (pcb->flags & TF_TIMESTAMP) {
;;;871        tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
;;;872      }
;;;873    #endif 
;;;874    
;;;875    #if CHECKSUM_GEN_TCP
;;;876      tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
;;;877            IP_PROTO_TCP, p->tot_len);
;;;878    #endif
;;;879    #if LWIP_NETIF_HWADDRHINT
;;;880      ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
;;;881          IP_PROTO_TCP, &(pcb->addr_hint));
;;;882    #else /* LWIP_NETIF_HWADDRHINT*/
;;;883      ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
00001e  2106              MOVS     r1,#6
000020  f0200003          BIC      r0,r0,#3              ;864
000024  77a0              STRB     r0,[r4,#0x1e]         ;864
000026  7a60              LDRB     r0,[r4,#9]
000028  e9cd0100          STRD     r0,r1,[sp,#0]
00002c  7aa3              LDRB     r3,[r4,#0xa]
00002e  1d22              ADDS     r2,r4,#4
000030  4621              MOV      r1,r4
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       ip_output
;;;884          IP_PROTO_TCP);
;;;885    #endif /* LWIP_NETIF_HWADDRHINT*/
;;;886      pbuf_free(p);
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       pbuf_free
;;;887    
;;;888      return ERR_OK;
00003e  2000              MOVS     r0,#0
;;;889    }
000040  bd7c              POP      {r2-r6,pc}
                  |L12.66|
000042  f06f0001          MVN      r0,#1                 ;858
000046  bd7c              POP      {r2-r6,pc}
;;;890    
                          ENDP


                          AREA ||i.tcp_send_fin||, CODE, READONLY, ALIGN=1

                  tcp_send_fin PROC
;;;124    err_t
;;;125    tcp_send_fin(struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;126    {
000002  6ec4              LDR      r4,[r0,#0x6c]
000004  4605              MOV      r5,r0
000006  b90c              CBNZ     r4,|L13.12|
000008  e009              B        |L13.30|
                  |L13.10|
;;;127      /* first, try to add the fin to the last unsent segment */
;;;128      if (pcb->unsent != NULL) {
;;;129        struct tcp_seg *last_unsent;
;;;130        for (last_unsent = pcb->unsent; last_unsent->next != NULL;
;;;131             last_unsent = last_unsent->next);
00000a  460c              MOV      r4,r1
                  |L13.12|
00000c  6821              LDR      r1,[r4,#0]            ;130
00000e  2900              CMP      r1,#0                 ;130
000010  d1fb              BNE      |L13.10|
;;;132    
;;;133        if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
000012  68e0              LDR      r0,[r4,#0xc]
000014  8980              LDRH     r0,[r0,#0xc]
000016  f7fffffe          BL       lwip_ntohs
00001a  0740              LSLS     r0,r0,#29
00001c  d005              BEQ      |L13.42|
                  |L13.30|
;;;134          /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
;;;135          TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
;;;136          pcb->flags |= TF_FIN;
;;;137          return ERR_OK;
;;;138        }
;;;139      }
;;;140      /* no data, no length, flags, copy=1, no optdata */
;;;141      return tcp_enqueue_flags(pcb, TCP_FIN);
00001e  4628              MOV      r0,r5
000020  e8bd4070          POP      {r4-r6,lr}
000024  2101              MOVS     r1,#1
000026  f7ffbffe          B.W      tcp_enqueue_flags
                  |L13.42|
00002a  2001              MOVS     r0,#1                 ;135
00002c  f7fffffe          BL       lwip_htons
000030  4601              MOV      r1,r0                 ;135
000032  68e0              LDR      r0,[r4,#0xc]          ;135
000034  8982              LDRH     r2,[r0,#0xc]          ;135
000036  4311              ORRS     r1,r1,r2              ;135
000038  8181              STRH     r1,[r0,#0xc]          ;135
00003a  7fa8              LDRB     r0,[r5,#0x1e]         ;136
00003c  f0400020          ORR      r0,r0,#0x20           ;136
000040  77a8              STRB     r0,[r5,#0x1e]         ;136
000042  2000              MOVS     r0,#0                 ;137
;;;142    }
000044  bd70              POP      {r4-r6,pc}
;;;143    
                          ENDP


                          AREA ||i.tcp_write||, CODE, READONLY, ALIGN=2

                  tcp_write PROC
;;;353    err_t
;;;354    tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;355    {
000004  4604              MOV      r4,r0
;;;356      struct pbuf *concat_p = NULL;
000006  2000              MOVS     r0,#0
000008  b08b              SUB      sp,sp,#0x2c           ;355
;;;357      struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
00000a  4606              MOV      r6,r0
;;;358      u16_t pos = 0; /* position in 'arg' data */
;;;359      u16_t queuelen;
;;;360      u8_t optlen = 0;
;;;361      u8_t optflags = 0;
00000c  9005              STR      r0,[sp,#0x14]
00000e  9006              STR      r0,[sp,#0x18]         ;357
000010  9008              STR      r0,[sp,#0x20]         ;360
;;;362    #if TCP_OVERSIZE
;;;363      u16_t oversize = 0;
000012  900a              STR      r0,[sp,#0x28]
000014  f8ad0024          STRH     r0,[sp,#0x24]
000018  4607              MOV      r7,r0                 ;357
00001a  4683              MOV      r11,r0                ;357
00001c  4605              MOV      r5,r0                 ;358
;;;364      u16_t oversize_used = 0;
00001e  4680              MOV      r8,r0
;;;365    #endif /* TCP_OVERSIZE */
;;;366    #if TCP_CHECKSUM_ON_COPY
;;;367      u16_t concat_chksum = 0;
;;;368      u8_t concat_chksum_swapped = 0;
;;;369      u16_t concat_chksummed = 0;
;;;370    #endif /* TCP_CHECKSUM_ON_COPY */
;;;371      err_t err;
;;;372      /* don't allocate segments bigger than half the maximum window we ever received */
;;;373      u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
000020  8ee0              LDRH     r0,[r4,#0x36]
000022  f8b41062          LDRH     r1,[r4,#0x62]
000026  4691              MOV      r9,r2                 ;355
000028  ebb00f51          CMP      r0,r1,LSR #1
00002c  d300              BCC      |L14.48|
00002e  0848              LSRS     r0,r1,#1
                  |L14.48|
;;;374    
;;;375    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;376      /* Always copy to try to create single pbufs for TX */
;;;377      apiflags |= TCP_WRITE_FLAG_COPY;
;;;378    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;379    
;;;380      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
;;;381        (void *)pcb, arg, len, (u16_t)apiflags));
;;;382      LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)", 
000030  9007              STR      r0,[sp,#0x1c]
000032  980c              LDR      r0,[sp,#0x30]
000034  b1b0              CBZ      r0,|L14.100|
;;;383                 arg != NULL, return ERR_ARG;);
;;;384    
;;;385      err = tcp_write_checks(pcb, len);
000036  4611              MOV      r1,r2
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       tcp_write_checks
;;;386      if (err != ERR_OK) {
00003e  2800              CMP      r0,#0
000040  d115              BNE      |L14.110|
;;;387        return err;
;;;388      }
;;;389      queuelen = pcb->snd_queuelen;
;;;390    
;;;391    #if LWIP_TCP_TIMESTAMPS
;;;392      if ((pcb->flags & TF_TIMESTAMP)) {
;;;393        optflags = TF_SEG_OPTS_TS;
;;;394        optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
;;;395      }
;;;396    #endif /* LWIP_TCP_TIMESTAMPS */
;;;397    
;;;398    
;;;399      /*
;;;400       * TCP segmentation is done in three phases with increasing complexity:
;;;401       *
;;;402       * 1. Copy data directly into an oversized pbuf.
;;;403       * 2. Chain a new pbuf to the end of pcb->unsent.
;;;404       * 3. Create new segments.
;;;405       *
;;;406       * We may run out of memory at any point. In that case we must
;;;407       * return ERR_MEM and not change anything in pcb. Therefore, all
;;;408       * changes are recorded in local variables and committed at the end
;;;409       * of the function. Some pcb fields are maintained in local copies:
;;;410       *
;;;411       * queuelen = pcb->snd_queuelen
;;;412       * oversize = pcb->unsent_oversize
;;;413       *
;;;414       * These variables are set consistently by the phases:
;;;415       *
;;;416       * seg points to the last segment tampered with.
;;;417       *
;;;418       * pos records progress as data is segmented.
;;;419       */
;;;420    
;;;421      /* Find the tail of the unsent queue. */
;;;422      if (pcb->unsent != NULL) {
000042  6ee0              LDR      r0,[r4,#0x6c]
000044  f8b4a068          LDRH     r10,[r4,#0x68]        ;389
000048  2800              CMP      r0,#0
00004a  d07d              BEQ      |L14.328|
                  |L14.76|
;;;423        u16_t space;
;;;424        u16_t unsent_optlen;
;;;425    
;;;426        /* @todo: this could be sped up by keeping last_unsent in the pcb */
;;;427        for (last_unsent = pcb->unsent; last_unsent->next != NULL;
00004c  4606              MOV      r6,r0
00004e  6800              LDR      r0,[r0,#0]
000050  2800              CMP      r0,#0
000052  d1fb              BNE      |L14.76|
;;;428             last_unsent = last_unsent->next);
;;;429    
;;;430        /* Usable space at the end of the last unsent segment */
;;;431        unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
000054  7ab0              LDRB     r0,[r6,#0xa]
000056  07c1              LSLS     r1,r0,#31
000058  d000              BEQ      |L14.92|
00005a  2104              MOVS     r1,#4
                  |L14.92|
00005c  0780              LSLS     r0,r0,#30
00005e  d509              BPL      |L14.116|
000060  200c              MOVS     r0,#0xc
000062  e008              B        |L14.118|
                  |L14.100|
000064  a0ba              ADR      r0,|L14.848|
000066  f7fffffe          BL       __2printf
00006a  f06f000d          MVN      r0,#0xd               ;382
                  |L14.110|
;;;432        space = mss_local - (last_unsent->len + unsent_optlen);
;;;433    
;;;434        /*
;;;435         * Phase 1: Copy data directly into an oversized pbuf.
;;;436         *
;;;437         * The number of bytes copied is recorded in the oversize_used
;;;438         * variable. The actual copying is done at the bottom of the
;;;439         * function.
;;;440         */
;;;441    #if TCP_OVERSIZE
;;;442    #if TCP_OVERSIZE_DBGCHECK
;;;443        /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
;;;444        LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
;;;445                    pcb->unsent_oversize == last_unsent->oversize_left);
;;;446    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;447        oversize = pcb->unsent_oversize;
;;;448        if (oversize > 0) {
;;;449          LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
;;;450          seg = last_unsent;
;;;451          oversize_used = oversize < len ? oversize : len;
;;;452          pos += oversize_used;
;;;453          oversize -= oversize_used;
;;;454          space -= oversize_used;
;;;455        }
;;;456        /* now we are either finished or oversize is zero */
;;;457        LWIP_ASSERT("inconsistend oversize vs. len", (oversize == 0) || (pos == len));
;;;458    #endif /* TCP_OVERSIZE */
;;;459    
;;;460        /*
;;;461         * Phase 2: Chain a new pbuf to the end of pcb->unsent.
;;;462         *
;;;463         * We don't extend segments containing SYN/FIN flags or options
;;;464         * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
;;;465         * the end.
;;;466         */
;;;467        if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
;;;468          u16_t seglen = space < len - pos ? space : len - pos;
;;;469          seg = last_unsent;
;;;470    
;;;471          /* Create a pbuf with a copy or reference to seglen bytes. We
;;;472           * can use PBUF_RAW here since the data appears in the middle of
;;;473           * a segment. A header will never be prepended. */
;;;474          if (apiflags & TCP_WRITE_FLAG_COPY) {
;;;475            /* Data is copied */
;;;476            if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
;;;477              LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
;;;478                          ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n",
;;;479                           seglen));
;;;480              goto memerr;
;;;481            }
;;;482    #if TCP_OVERSIZE_DBGCHECK
;;;483            last_unsent->oversize_left += oversize;
;;;484    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;485            TCP_DATA_COPY2(concat_p->payload, (u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
;;;486    #if TCP_CHECKSUM_ON_COPY
;;;487            concat_chksummed += seglen;
;;;488    #endif /* TCP_CHECKSUM_ON_COPY */
;;;489          } else {
;;;490            /* Data is not copied */
;;;491            if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
;;;492              LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
;;;493                          ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
;;;494              goto memerr;
;;;495            }
;;;496    #if TCP_CHECKSUM_ON_COPY
;;;497            /* calculate the checksum of nocopy-data */
;;;498            tcp_seg_add_chksum(~inet_chksum((u8_t*)arg + pos, seglen), seglen,
;;;499              &concat_chksum, &concat_chksum_swapped);
;;;500            concat_chksummed += seglen;
;;;501    #endif /* TCP_CHECKSUM_ON_COPY */
;;;502            /* reference the non-volatile payload data */
;;;503            concat_p->payload = (u8_t*)arg + pos;
;;;504          }
;;;505    
;;;506          pos += seglen;
;;;507          queuelen += pbuf_clen(concat_p);
;;;508        }
;;;509      } else {
;;;510    #if TCP_OVERSIZE
;;;511        LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
;;;512                    pcb->unsent_oversize == 0);
;;;513    #endif /* TCP_OVERSIZE */
;;;514      }
;;;515    
;;;516      /*
;;;517       * Phase 3: Create new segments.
;;;518       *
;;;519       * The new segments are chained together in the local 'queue'
;;;520       * variable, ready to be appended to pcb->unsent.
;;;521       */
;;;522      while (pos < len) {
;;;523        struct pbuf *p;
;;;524        u16_t left = len - pos;
;;;525        u16_t max_len = mss_local - optlen;
;;;526        u16_t seglen = left > max_len ? max_len : left;
;;;527    #if TCP_CHECKSUM_ON_COPY
;;;528        u16_t chksum = 0;
;;;529        u8_t chksum_swapped = 0;
;;;530    #endif /* TCP_CHECKSUM_ON_COPY */
;;;531    
;;;532        if (apiflags & TCP_WRITE_FLAG_COPY) {
;;;533          /* If copy is set, memory should be allocated and data copied
;;;534           * into pbuf */
;;;535          if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
;;;536            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
;;;537            goto memerr;
;;;538          }
;;;539          LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
;;;540                      (p->len >= seglen));
;;;541          TCP_DATA_COPY2((char *)p->payload + optlen, (u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
;;;542        } else {
;;;543          /* Copy is not set: First allocate a pbuf for holding the data.
;;;544           * Since the referenced data is available at least until it is
;;;545           * sent out on the link (as it has to be ACKed by the remote
;;;546           * party) we can safely use PBUF_ROM instead of PBUF_REF here.
;;;547           */
;;;548          struct pbuf *p2;
;;;549    #if TCP_OVERSIZE
;;;550          LWIP_ASSERT("oversize == 0", oversize == 0);
;;;551    #endif /* TCP_OVERSIZE */
;;;552          if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
;;;553            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
;;;554            goto memerr;
;;;555          }
;;;556    #if TCP_CHECKSUM_ON_COPY
;;;557          /* calculate the checksum of nocopy-data */
;;;558          chksum = ~inet_chksum((u8_t*)arg + pos, seglen);
;;;559    #endif /* TCP_CHECKSUM_ON_COPY */
;;;560          /* reference the non-volatile payload data */
;;;561          p2->payload = (u8_t*)arg + pos;
;;;562    
;;;563          /* Second, allocate a pbuf for the headers. */
;;;564          if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
;;;565            /* If allocation fails, we have to deallocate the data pbuf as
;;;566             * well. */
;;;567            pbuf_free(p2);
;;;568            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for header pbuf\n"));
;;;569            goto memerr;
;;;570          }
;;;571          /* Concatenate the headers and data pbufs together. */
;;;572          pbuf_cat(p/*header*/, p2/*data*/);
;;;573        }
;;;574    
;;;575        queuelen += pbuf_clen(p);
;;;576    
;;;577        /* Now that there are more segments queued, we check again if the
;;;578         * length of the queue exceeds the configured maximum or
;;;579         * overflows. */
;;;580        if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
;;;581          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
;;;582          pbuf_free(p);
;;;583          goto memerr;
;;;584        }
;;;585    
;;;586        if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
;;;587          goto memerr;
;;;588        }
;;;589    #if TCP_OVERSIZE_DBGCHECK
;;;590        seg->oversize_left = oversize;
;;;591    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;592    #if TCP_CHECKSUM_ON_COPY
;;;593        seg->chksum = chksum;
;;;594        seg->chksum_swapped = chksum_swapped;
;;;595        seg->flags |= TF_SEG_DATA_CHECKSUMMED;
;;;596    #endif /* TCP_CHECKSUM_ON_COPY */
;;;597    
;;;598        /* first segment of to-be-queued data? */
;;;599        if (queue == NULL) {
;;;600          queue = seg;
;;;601        } else {
;;;602          /* Attach the segment to the end of the queued segments */
;;;603          LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
;;;604          prev_seg->next = seg;
;;;605        }
;;;606        /* remember last segment of to-be-queued data for next iteration */
;;;607        prev_seg = seg;
;;;608    
;;;609        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
;;;610          ntohl(seg->tcphdr->seqno),
;;;611          ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));
;;;612    
;;;613        pos += seglen;
;;;614      }
;;;615    
;;;616      /*
;;;617       * All three segmentation phases were successful. We can commit the
;;;618       * transaction.
;;;619       */
;;;620    
;;;621      /*
;;;622       * Phase 1: If data has been added to the preallocated tail of
;;;623       * last_unsent, we update the length fields of the pbuf chain.
;;;624       */
;;;625    #if TCP_OVERSIZE
;;;626      if (oversize_used > 0) {
;;;627        struct pbuf *p;
;;;628        /* Bump tot_len of whole chain, len of tail */
;;;629        for (p = last_unsent->p; p; p = p->next) {
;;;630          p->tot_len += oversize_used;
;;;631          if (p->next == NULL) {
;;;632            TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
;;;633            p->len += oversize_used;
;;;634          }
;;;635        }
;;;636        last_unsent->len += oversize_used;
;;;637    #if TCP_OVERSIZE_DBGCHECK
;;;638        LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
;;;639                    last_unsent->oversize_left >= oversize_used);
;;;640        last_unsent->oversize_left -= oversize_used;
;;;641    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;642      }
;;;643      pcb->unsent_oversize = oversize;
;;;644    #endif /* TCP_OVERSIZE */
;;;645    
;;;646      /*
;;;647       * Phase 2: concat_p can be concatenated onto last_unsent->p
;;;648       */
;;;649      if (concat_p != NULL) {
;;;650        LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
;;;651          (last_unsent != NULL));
;;;652        pbuf_cat(last_unsent->p, concat_p);
;;;653        last_unsent->len += concat_p->tot_len;
;;;654    #if TCP_CHECKSUM_ON_COPY
;;;655        if (concat_chksummed) {
;;;656          tcp_seg_add_chksum(concat_chksum, concat_chksummed, &last_unsent->chksum,
;;;657            &last_unsent->chksum_swapped);
;;;658          last_unsent->flags |= TF_SEG_DATA_CHECKSUMMED;
;;;659        }
;;;660    #endif /* TCP_CHECKSUM_ON_COPY */
;;;661      }
;;;662    
;;;663      /*
;;;664       * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
;;;665       * is harmless
;;;666       */
;;;667      if (last_unsent == NULL) {
;;;668        pcb->unsent = queue;
;;;669      } else {
;;;670        last_unsent->next = queue;
;;;671      }
;;;672    
;;;673      /*
;;;674       * Finally update the pcb state.
;;;675       */
;;;676      pcb->snd_lbb += len;
;;;677      pcb->snd_buf -= len;
;;;678      pcb->snd_queuelen = queuelen;
;;;679    
;;;680      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
;;;681        pcb->snd_queuelen));
;;;682      if (pcb->snd_queuelen != 0) {
;;;683        LWIP_ASSERT("tcp_write: valid queue length",
;;;684                    pcb->unacked != NULL || pcb->unsent != NULL);
;;;685      }
;;;686    
;;;687      /* Set the PSH flag in the last segment that we enqueued. */
;;;688      if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
;;;689        TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
;;;690      }
;;;691    
;;;692      return ERR_OK;
;;;693    memerr:
;;;694      pcb->flags |= TF_NAGLEMEMERR;
;;;695      TCP_STATS_INC(tcp.memerr);
;;;696    
;;;697      if (concat_p != NULL) {
;;;698        pbuf_free(concat_p);
;;;699      }
;;;700      if (queue != NULL) {
;;;701        tcp_segs_free(queue);
;;;702    	TCP_DEBUG_USART_PRINTF_S(" tcp_segs_free(queue);\n");
;;;703      }
;;;704      if (pcb->snd_queuelen != 0) {
;;;705        LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
;;;706          pcb->unsent != NULL);
;;;707      }
;;;708      LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
;;;709      return ERR_MEM;
;;;710    }
00006e  b00f              ADD      sp,sp,#0x3c
000070  e8bd8ff0          POP      {r4-r11,pc}
                  |L14.116|
000074  2000              MOVS     r0,#0                 ;431
                  |L14.118|
000076  4408              ADD      r0,r0,r1              ;431
000078  8931              LDRH     r1,[r6,#8]            ;432
00007a  4401              ADD      r1,r1,r0              ;432
00007c  9807              LDR      r0,[sp,#0x1c]         ;432
00007e  1a40              SUBS     r0,r0,r1              ;432
000080  b280              UXTH     r0,r0                 ;432
000082  9003              STR      r0,[sp,#0xc]          ;447
000084  f8b4006a          LDRH     r0,[r4,#0x6a]         ;447
000088  f8ad0024          STRH     r0,[sp,#0x24]         ;447
00008c  b1c8              CBZ      r0,|L14.194|
00008e  9903              LDR      r1,[sp,#0xc]          ;449
000090  4588              CMP      r8,r1                 ;449
000092  d902              BLS      |L14.154|
000094  a0bb              ADR      r0,|L14.900|
000096  f7fffffe          BL       __2printf
                  |L14.154|
00009a  f8bd0024          LDRH     r0,[sp,#0x24]         ;451
00009e  4637              MOV      r7,r6                 ;450
0000a0  4649              MOV      r1,r9                 ;451
0000a2  4548              CMP      r0,r9                 ;451
0000a4  d200              BCS      |L14.168|
0000a6  4601              MOV      r1,r0                 ;451
                  |L14.168|
0000a8  4688              MOV      r8,r1                 ;451
0000aa  eba00008          SUB      r0,r0,r8              ;453
0000ae  f8ad0024          STRH     r0,[sp,#0x24]         ;453
0000b2  9803              LDR      r0,[sp,#0xc]          ;454
0000b4  eb050108          ADD      r1,r5,r8              ;452
0000b8  eba00008          SUB      r0,r0,r8              ;454
0000bc  b280              UXTH     r0,r0                 ;454
0000be  b28d              UXTH     r5,r1                 ;452
0000c0  9003              STR      r0,[sp,#0xc]          ;454
                  |L14.194|
0000c2  f8bd0024          LDRH     r0,[sp,#0x24]         ;457
0000c6  b120              CBZ      r0,|L14.210|
0000c8  454d              CMP      r5,r9                 ;457
0000ca  d002              BEQ      |L14.210|
0000cc  a0b5              ADR      r0,|L14.932|
0000ce  f7fffffe          BL       __2printf
                  |L14.210|
0000d2  454d              CMP      r5,r9                 ;467
0000d4  d23e              BCS      |L14.340|
0000d6  9803              LDR      r0,[sp,#0xc]          ;467
0000d8  2800              CMP      r0,#0                 ;467
                  |L14.218|
0000da  d03b              BEQ      |L14.340|
0000dc  8930              LDRH     r0,[r6,#8]            ;467
0000de  2800              CMP      r0,#0                 ;467
0000e0  d0fb              BEQ      |L14.218|
0000e2  9903              LDR      r1,[sp,#0xc]          ;468
0000e4  eba90005          SUB      r0,r9,r5              ;468
0000e8  4288              CMP      r0,r1                 ;468
0000ea  dd00              BLE      |L14.238|
0000ec  4608              MOV      r0,r1                 ;468
                  |L14.238|
0000ee  b280              UXTH     r0,r0                 ;468
0000f0  9004              STR      r0,[sp,#0x10]         ;474
0000f2  980e              LDR      r0,[sp,#0x38]         ;474
0000f4  4637              MOV      r7,r6                 ;469
0000f6  07c0              LSLS     r0,r0,#31             ;474
0000f8  d015              BEQ      |L14.294|
0000fa  2101              MOVS     r1,#1                 ;476
0000fc  980e              LDR      r0,[sp,#0x38]         ;476
0000fe  9400              STR      r4,[sp,#0]            ;476
000100  e9cd0101          STRD     r0,r1,[sp,#4]         ;476
000104  e9dd2103          LDRD     r2,r1,[sp,#0xc]       ;476
000108  ab09              ADD      r3,sp,#0x24           ;476
00010a  2003              MOVS     r0,#3                 ;476
00010c  f7fffffe          BL       tcp_pbuf_prealloc
000110  9006              STR      r0,[sp,#0x18]         ;476
000112  2800              CMP      r0,#0                 ;476
                  |L14.276|
000114  d07e              BEQ      |L14.532|
000116  980c              LDR      r0,[sp,#0x30]         ;485
000118  9a04              LDR      r2,[sp,#0x10]         ;485
00011a  1941              ADDS     r1,r0,r5              ;485
00011c  9806              LDR      r0,[sp,#0x18]         ;485
00011e  6840              LDR      r0,[r0,#4]            ;485
000120  f7fffffe          BL       __aeabi_memcpy
000124  e00b              B        |L14.318|
                  |L14.294|
000126  2201              MOVS     r2,#1                 ;491
000128  2003              MOVS     r0,#3                 ;491
00012a  9904              LDR      r1,[sp,#0x10]         ;491
00012c  f7fffffe          BL       pbuf_alloc
000130  9006              STR      r0,[sp,#0x18]         ;491
000132  2800              CMP      r0,#0                 ;491
000134  d0ee              BEQ      |L14.276|
000136  980c              LDR      r0,[sp,#0x30]         ;503
000138  1941              ADDS     r1,r0,r5              ;503
00013a  9806              LDR      r0,[sp,#0x18]         ;503
00013c  6041              STR      r1,[r0,#4]            ;503
                  |L14.318|
00013e  9804              LDR      r0,[sp,#0x10]         ;506
000140  4428              ADD      r0,r0,r5              ;506
000142  b285              UXTH     r5,r0                 ;506
000144  9806              LDR      r0,[sp,#0x18]         ;507
000146  e000              B        |L14.330|
                  |L14.328|
000148  e005              B        |L14.342|
                  |L14.330|
00014a  f7fffffe          BL       pbuf_clen
00014e  4450              ADD      r0,r0,r10             ;507
000150  fa1ffa80          UXTH     r10,r0                ;507
                  |L14.340|
000154  e082              B        |L14.604|
                  |L14.342|
000156  f8b4006a          LDRH     r0,[r4,#0x6a]         ;511
00015a  2800              CMP      r0,#0                 ;511
00015c  d07e              BEQ      |L14.604|
00015e  a099              ADR      r0,|L14.964|
000160  f7fffffe          BL       __2printf
000164  e07a              B        |L14.604|
                  |L14.358|
000166  eba90005          SUB      r0,r9,r5              ;524
00016a  b281              UXTH     r1,r0                 ;524
00016c  9a05              LDR      r2,[sp,#0x14]         ;525
00016e  9807              LDR      r0,[sp,#0x1c]         ;525
000170  1a80              SUBS     r0,r0,r2              ;525
000172  b280              UXTH     r0,r0                 ;525
000174  4281              CMP      r1,r0                 ;526
000176  d800              BHI      |L14.378|
000178  4608              MOV      r0,r1                 ;526
                  |L14.378|
00017a  9004              STR      r0,[sp,#0x10]         ;532
00017c  980e              LDR      r0,[sp,#0x38]         ;532
00017e  07c0              LSLS     r0,r0,#31             ;532
000180  d025              BEQ      |L14.462|
000182  f1bb0f00          CMP      r11,#0                ;535
000186  d020              BEQ      |L14.458|
000188  2000              MOVS     r0,#0                 ;535
                  |L14.394|
00018a  990e              LDR      r1,[sp,#0x38]         ;535
00018c  9400              STR      r4,[sp,#0]            ;535
00018e  e9cd1001          STRD     r1,r0,[sp,#4]         ;535
000192  9804              LDR      r0,[sp,#0x10]         ;535
000194  ab09              ADD      r3,sp,#0x24           ;535
000196  4410              ADD      r0,r0,r2              ;535
000198  b281              UXTH     r1,r0                 ;535
00019a  2000              MOVS     r0,#0                 ;535
00019c  9a07              LDR      r2,[sp,#0x1c]         ;535
00019e  f7fffffe          BL       tcp_pbuf_prealloc
0001a2  9001              STR      r0,[sp,#4]            ;535
0001a4  2800              CMP      r0,#0                 ;535
0001a6  d0b5              BEQ      |L14.276|
0001a8  8941              LDRH     r1,[r0,#0xa]          ;539
0001aa  9804              LDR      r0,[sp,#0x10]         ;539
0001ac  4281              CMP      r1,r0                 ;539
0001ae  d202              BCS      |L14.438|
0001b0  a090              ADR      r0,|L14.1012|
0001b2  f7fffffe          BL       __2printf
                  |L14.438|
0001b6  980c              LDR      r0,[sp,#0x30]         ;541
0001b8  1941              ADDS     r1,r0,r5              ;541
0001ba  9801              LDR      r0,[sp,#4]            ;541
0001bc  6842              LDR      r2,[r0,#4]            ;541
0001be  9805              LDR      r0,[sp,#0x14]         ;541
0001c0  4410              ADD      r0,r0,r2              ;541
0001c2  9a04              LDR      r2,[sp,#0x10]         ;541
0001c4  f7fffffe          BL       __aeabi_memcpy
0001c8  e01b              B        |L14.514|
                  |L14.458|
0001ca  2001              MOVS     r0,#1                 ;535
0001cc  e7dd              B        |L14.394|
                  |L14.462|
0001ce  f8bd0024          LDRH     r0,[sp,#0x24]         ;550
0001d2  b110              CBZ      r0,|L14.474|
0001d4  a097              ADR      r0,|L14.1076|
0001d6  f7fffffe          BL       __2printf
                  |L14.474|
0001da  2201              MOVS     r2,#1                 ;552
0001dc  2000              MOVS     r0,#0                 ;552
0001de  9904              LDR      r1,[sp,#0x10]         ;552
0001e0  f7fffffe          BL       pbuf_alloc
0001e4  0007              MOVS     r7,r0                 ;552
0001e6  d095              BEQ      |L14.276|
0001e8  980c              LDR      r0,[sp,#0x30]         ;561
0001ea  2200              MOVS     r2,#0                 ;564
0001ec  4428              ADD      r0,r0,r5              ;561
0001ee  6078              STR      r0,[r7,#4]            ;564
0001f0  4610              MOV      r0,r2                 ;564
0001f2  9905              LDR      r1,[sp,#0x14]         ;564
0001f4  f7fffffe          BL       pbuf_alloc
0001f8  9001              STR      r0,[sp,#4]            ;564
0001fa  b188              CBZ      r0,|L14.544|
0001fc  4639              MOV      r1,r7                 ;572
0001fe  f7fffffe          BL       pbuf_cat
                  |L14.514|
000202  9801              LDR      r0,[sp,#4]            ;575
000204  f7fffffe          BL       pbuf_clen
000208  4450              ADD      r0,r0,r10             ;575
00020a  fa1ffa80          UXTH     r10,r0                ;575
00020e  f1ba0f10          CMP      r10,#0x10             ;580
000212  e000              B        |L14.534|
                  |L14.532|
000214  e081              B        |L14.794|
                  |L14.534|
000216  d905              BLS      |L14.548|
000218  9801              LDR      r0,[sp,#4]            ;582
                  |L14.538|
00021a  f7fffffe          BL       pbuf_free
00021e  e07d              B        |L14.796|
                  |L14.544|
000220  4638              MOV      r0,r7                 ;567
000222  e7fa              B        |L14.538|
                  |L14.548|
000224  980a              LDR      r0,[sp,#0x28]         ;586
000226  9000              STR      r0,[sp,#0]            ;586
000228  6de0              LDR      r0,[r4,#0x5c]         ;586
00022a  2200              MOVS     r2,#0                 ;586
00022c  1943              ADDS     r3,r0,r5              ;586
00022e  4620              MOV      r0,r4                 ;586
000230  9901              LDR      r1,[sp,#4]            ;586
000232  f7fffffe          BL       tcp_create_segment
000236  0007              MOVS     r7,r0                 ;586
000238  d070              BEQ      |L14.796|
00023a  f1bb0f00          CMP      r11,#0                ;599
00023e  d002              BEQ      |L14.582|
000240  9808              LDR      r0,[sp,#0x20]         ;603
000242  b110              CBZ      r0,|L14.586|
000244  e004              B        |L14.592|
                  |L14.582|
000246  46bb              MOV      r11,r7                ;600
000248  e004              B        |L14.596|
                  |L14.586|
00024a  a07e              ADR      r0,|L14.1092|
00024c  f7fffffe          BL       __2printf
                  |L14.592|
000250  9808              LDR      r0,[sp,#0x20]         ;604
000252  6007              STR      r7,[r0,#0]            ;604
                  |L14.596|
000254  9804              LDR      r0,[sp,#0x10]         ;613
000256  9708              STR      r7,[sp,#0x20]         ;613
000258  4428              ADD      r0,r0,r5              ;613
00025a  b285              UXTH     r5,r0                 ;613
                  |L14.604|
00025c  454d              CMP      r5,r9                 ;522
00025e  d382              BCC      |L14.358|
000260  f1b80f00          CMP      r8,#0                 ;626
000264  d019              BEQ      |L14.666|
000266  6875              LDR      r5,[r6,#4]            ;629
000268  e011              B        |L14.654|
                  |L14.618|
00026a  8929              LDRH     r1,[r5,#8]            ;630
00026c  eb010008          ADD      r0,r1,r8              ;630
000270  8128              STRH     r0,[r5,#8]            ;630
000272  6828              LDR      r0,[r5,#0]            ;631
000274  b950              CBNZ     r0,|L14.652|
000276  8969              LDRH     r1,[r5,#0xa]          ;632
000278  6868              LDR      r0,[r5,#4]            ;632
00027a  4642              MOV      r2,r8                 ;632
00027c  4408              ADD      r0,r0,r1              ;632
00027e  990c              LDR      r1,[sp,#0x30]         ;632
000280  f7fffffe          BL       __aeabi_memcpy
000284  8969              LDRH     r1,[r5,#0xa]          ;633
000286  eb010008          ADD      r0,r1,r8              ;633
00028a  8168              STRH     r0,[r5,#0xa]          ;633
                  |L14.652|
00028c  682d              LDR      r5,[r5,#0]            ;629
                  |L14.654|
00028e  2d00              CMP      r5,#0                 ;629
000290  d1eb              BNE      |L14.618|
000292  8931              LDRH     r1,[r6,#8]            ;636
000294  eb010008          ADD      r0,r1,r8              ;636
000298  8130              STRH     r0,[r6,#8]            ;636
                  |L14.666|
00029a  f8bd0024          LDRH     r0,[sp,#0x24]         ;643
00029e  f8a4006a          STRH     r0,[r4,#0x6a]         ;643
0002a2  9806              LDR      r0,[sp,#0x18]         ;649
0002a4  b160              CBZ      r0,|L14.704|
0002a6  b916              CBNZ     r6,|L14.686|
0002a8  a06b              ADR      r0,|L14.1112|
0002aa  f7fffffe          BL       __2printf
                  |L14.686|
0002ae  6870              LDR      r0,[r6,#4]            ;652
0002b0  9906              LDR      r1,[sp,#0x18]         ;652
0002b2  f7fffffe          BL       pbuf_cat
0002b6  9806              LDR      r0,[sp,#0x18]         ;653
0002b8  8931              LDRH     r1,[r6,#8]            ;653
0002ba  8900              LDRH     r0,[r0,#8]            ;653
0002bc  4408              ADD      r0,r0,r1              ;653
0002be  8130              STRH     r0,[r6,#8]            ;653
                  |L14.704|
0002c0  b19e              CBZ      r6,|L14.746|
0002c2  f8c6b000          STR      r11,[r6,#0]           ;670
                  |L14.710|
0002c6  6de1              LDR      r1,[r4,#0x5c]         ;676
0002c8  eb010009          ADD      r0,r1,r9              ;676
0002cc  65e0              STR      r0,[r4,#0x5c]         ;677
0002ce  f8b41066          LDRH     r1,[r4,#0x66]         ;677
0002d2  eba10009          SUB      r0,r1,r9              ;677
0002d6  f8a40066          STRH     r0,[r4,#0x66]         ;677
0002da  ea5f000a          MOVS     r0,r10                ;678
0002de  f8a40068          STRH     r0,[r4,#0x68]         ;678
0002e2  d00a              BEQ      |L14.762|
0002e4  6f20              LDR      r0,[r4,#0x70]         ;683
0002e6  b118              CBZ      r0,|L14.752|
0002e8  e007              B        |L14.762|
                  |L14.746|
0002ea  f8c4b06c          STR      r11,[r4,#0x6c]        ;668
0002ee  e7ea              B        |L14.710|
                  |L14.752|
0002f0  6ee0              LDR      r0,[r4,#0x6c]         ;683
0002f2  b910              CBNZ     r0,|L14.762|
0002f4  a066              ADR      r0,|L14.1168|
0002f6  f7fffffe          BL       __2printf
                  |L14.762|
0002fa  b167              CBZ      r7,|L14.790|
0002fc  68f8              LDR      r0,[r7,#0xc]          ;688
0002fe  b150              CBZ      r0,|L14.790|
000300  980e              LDR      r0,[sp,#0x38]         ;688
000302  0780              LSLS     r0,r0,#30             ;688
000304  d407              BMI      |L14.790|
000306  2008              MOVS     r0,#8                 ;689
000308  f7fffffe          BL       lwip_htons
00030c  4601              MOV      r1,r0                 ;689
00030e  68f8              LDR      r0,[r7,#0xc]          ;689
000310  8982              LDRH     r2,[r0,#0xc]          ;689
000312  4311              ORRS     r1,r1,r2              ;689
000314  8181              STRH     r1,[r0,#0xc]          ;689
                  |L14.790|
000316  2000              MOVS     r0,#0                 ;692
000318  e6a9              B        |L14.110|
                  |L14.794|
00031a  e7ff              B        |L14.796|
                  |L14.796|
00031c  7fa0              LDRB     r0,[r4,#0x1e]         ;694
00031e  f0400080          ORR      r0,r0,#0x80           ;694
000322  77a0              STRB     r0,[r4,#0x1e]         ;694
000324  9806              LDR      r0,[sp,#0x18]         ;697
000326  b108              CBZ      r0,|L14.812|
000328  f7fffffe          BL       pbuf_free
                  |L14.812|
00032c  f1bb0000          SUBS     r0,r11,#0             ;700
000330  d001              BEQ      |L14.822|
000332  f7fffffe          BL       tcp_segs_free
                  |L14.822|
000336  f8b40068          LDRH     r0,[r4,#0x68]         ;704
00033a  b130              CBZ      r0,|L14.842|
00033c  6f20              LDR      r0,[r4,#0x70]         ;705
00033e  b920              CBNZ     r0,|L14.842|
000340  6ee0              LDR      r0,[r4,#0x6c]         ;705
000342  b910              CBNZ     r0,|L14.842|
000344  a052              ADR      r0,|L14.1168|
000346  f7fffffe          BL       __2printf
                  |L14.842|
00034a  f04f30ff          MOV      r0,#0xffffffff        ;709
00034e  e68e              B        |L14.110|
;;;711    
                          ENDP

                  |L14.848|
000350  7463705f          DCB      "tcp_write: arg == NULL (programmer violates API)",0
000354  77726974
000358  653a2061
00035c  7267203d
000360  3d204e55
000364  4c4c2028
000368  70726f67
00036c  72616d6d
000370  65722076
000374  696f6c61
000378  74657320
00037c  41504929
000380  00      
000381  00                DCB      0
000382  00                DCB      0
000383  00                DCB      0
                  |L14.900|
000384  696e636f          DCB      "inconsistent oversize vs. space",0
000388  6e736973
00038c  74656e74
000390  206f7665
000394  7273697a
000398  65207673
00039c  2e207370
0003a0  61636500
                  |L14.932|
0003a4  696e636f          DCB      "inconsistend oversize vs. len",0
0003a8  6e736973
0003ac  74656e64
0003b0  206f7665
0003b4  7273697a
0003b8  65207673
0003bc  2e206c65
0003c0  6e00    
0003c2  00                DCB      0
0003c3  00                DCB      0
                  |L14.964|
0003c4  756e7365          DCB      "unsent_oversize mismatch (pcb->unsent is NULL)",0
0003c8  6e745f6f
0003cc  76657273
0003d0  697a6520
0003d4  6d69736d
0003d8  61746368
0003dc  20287063
0003e0  622d3e75
0003e4  6e73656e
0003e8  74206973
0003ec  204e554c
0003f0  4c2900  
0003f3  00                DCB      0
                  |L14.1012|
0003f4  7463705f          DCB      "tcp_write: check that first pbuf can hold the complete "
0003f8  77726974
0003fc  653a2063
000400  6865636b
000404  20746861
000408  74206669
00040c  72737420
000410  70627566
000414  2063616e
000418  20686f6c
00041c  64207468
000420  6520636f
000424  6d706c65
000428  746520  
00042b  7365676c          DCB      "seglen",0
00042f  656e00  
000432  00                DCB      0
000433  00                DCB      0
                  |L14.1076|
000434  6f766572          DCB      "oversize == 0",0
000438  73697a65
00043c  203d3d20
000440  3000    
000442  00                DCB      0
000443  00                DCB      0
                  |L14.1092|
000444  70726576          DCB      "prev_seg != NULL",0
000448  5f736567
00044c  20213d20
000450  4e554c4c
000454  00      
000455  00                DCB      0
000456  00                DCB      0
000457  00                DCB      0
                  |L14.1112|
000458  7463705f          DCB      "tcp_write: cannot concatenate when pcb->unsent is empty"
00045c  77726974
000460  653a2063
000464  616e6e6f
000468  7420636f
00046c  6e636174
000470  656e6174
000474  65207768
000478  656e2070
00047c  63622d3e
000480  756e7365
000484  6e742069
000488  7320656d
00048c  707479  
00048f  00                DCB      0
                  |L14.1168|
000490  7463705f          DCB      "tcp_write: valid queue length",0
000494  77726974
000498  653a2076
00049c  616c6964
0004a0  20717565
0004a4  7565206c
0004a8  656e6774
0004ac  6800    
0004ae  00                DCB      0
0004af  00                DCB      0

                          AREA ||i.tcp_write_checks||, CODE, READONLY, ALIGN=2

                  tcp_write_checks PROC
;;;293    static err_t
;;;294    tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
000000  b510              PUSH     {r4,lr}
;;;295    {
;;;296      /* connection is in invalid state for data transmission? */
;;;297      if ((pcb->state != ESTABLISHED) &&
000002  7e02              LDRB     r2,[r0,#0x18]
000004  2a04              CMP      r2,#4
000006  d008              BEQ      |L15.26|
;;;298          (pcb->state != CLOSE_WAIT) &&
000008  2a07              CMP      r2,#7
00000a  d006              BEQ      |L15.26|
;;;299          (pcb->state != SYN_SENT) &&
00000c  2a02              CMP      r2,#2
00000e  d004              BEQ      |L15.26|
;;;300          (pcb->state != SYN_RCVD)) {
000010  2a03              CMP      r2,#3
000012  d002              BEQ      |L15.26|
;;;301        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
;;;302        return ERR_CONN;
000014  f06f000c          MVN      r0,#0xc
;;;303      } else if (len == 0) {
;;;304        return ERR_OK;
;;;305      }
;;;306    
;;;307      /* fail on too much data */
;;;308      if (len > pcb->snd_buf) {
;;;309        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n",
;;;310          len, pcb->snd_buf));
;;;311        pcb->flags |= TF_NAGLEMEMERR;
;;;312        return ERR_MEM;
;;;313      }
;;;314    
;;;315      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));
;;;316    
;;;317      /* If total number of pbufs on the unsent/unacked queues exceeds the
;;;318       * configured maximum, return an error */
;;;319      /* check for configured max queuelen and possible overflow */
;;;320      if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
;;;321        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
;;;322          pcb->snd_queuelen, TCP_SND_QUEUELEN));
;;;323        TCP_STATS_INC(tcp.memerr);
;;;324        pcb->flags |= TF_NAGLEMEMERR;
;;;325        return ERR_MEM;
;;;326      }
;;;327      if (pcb->snd_queuelen != 0) {
;;;328        LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
;;;329          pcb->unacked != NULL || pcb->unsent != NULL);
;;;330      } else {
;;;331        LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
;;;332          pcb->unacked == NULL && pcb->unsent == NULL);
;;;333      }
;;;334      return ERR_OK;
;;;335    }
000018  bd10              POP      {r4,pc}
                  |L15.26|
00001a  2900              CMP      r1,#0                 ;303
00001c  d01d              BEQ      |L15.90|
00001e  f8b03066          LDRH     r3,[r0,#0x66]         ;308
000022  f04f32ff          MOV      r2,#0xffffffff        ;312
000026  428b              CMP      r3,r1                 ;308
000028  d303              BCC      |L15.50|
00002a  f8b01068          LDRH     r1,[r0,#0x68]         ;320
00002e  2910              CMP      r1,#0x10              ;320
000030  d305              BCC      |L15.62|
                  |L15.50|
000032  7f81              LDRB     r1,[r0,#0x1e]         ;324
000034  f0410180          ORR      r1,r1,#0x80           ;324
000038  7781              STRB     r1,[r0,#0x1e]         ;324
00003a  4610              MOV      r0,r2                 ;325
00003c  bd10              POP      {r4,pc}
                  |L15.62|
00003e  2900              CMP      r1,#0                 ;327
000040  6f01              LDR      r1,[r0,#0x70]         ;327
000042  d004              BEQ      |L15.78|
000044  b949              CBNZ     r1,|L15.90|
000046  6ec0              LDR      r0,[r0,#0x6c]         ;328
000048  b938              CBNZ     r0,|L15.90|
00004a  a005              ADR      r0,|L15.96|
00004c  e003              B        |L15.86|
                  |L15.78|
00004e  b909              CBNZ     r1,|L15.84|
000050  6ec0              LDR      r0,[r0,#0x6c]         ;331
000052  b110              CBZ      r0,|L15.90|
                  |L15.84|
000054  a011              ADR      r0,|L15.156|
                  |L15.86|
000056  f7fffffe          BL       __2printf
                  |L15.90|
00005a  2000              MOVS     r0,#0                 ;334
00005c  bd10              POP      {r4,pc}
;;;336    
                          ENDP

00005e  0000              DCW      0x0000
                  |L15.96|
000060  7463705f          DCB      "tcp_write: pbufs on queue => at least one queue non-emp"
000064  77726974
000068  653a2070
00006c  62756673
000070  206f6e20
000074  71756575
000078  65203d3e
00007c  20617420
000080  6c656173
000084  74206f6e
000088  65207175
00008c  65756520
000090  6e6f6e2d
000094  656d70  
000097  747900            DCB      "ty",0
00009a  00                DCB      0
00009b  00                DCB      0
                  |L15.156|
00009c  7463705f          DCB      "tcp_write: no pbufs on queue => both queues empty",0
0000a0  77726974
0000a4  653a206e
0000a8  6f207062
0000ac  75667320
0000b0  6f6e2071
0000b4  75657565
0000b8  203d3e20
0000bc  626f7468
0000c0  20717565
0000c4  75657320
0000c8  656d7074
0000cc  7900    
0000ce  00                DCB      0
0000cf  00                DCB      0

                          AREA ||i.tcp_zero_window_probe||, CODE, READONLY, ALIGN=1

                  tcp_zero_window_probe PROC
;;;1414   void
;;;1415   tcp_zero_window_probe(struct tcp_pcb *pcb)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;1416   {
000004  6f04              LDR      r4,[r0,#0x70]
000006  4605              MOV      r5,r0
000008  b914              CBNZ     r4,|L16.16|
;;;1417     struct pbuf *p;
;;;1418     struct tcp_hdr *tcphdr;
;;;1419     struct tcp_seg *seg;
;;;1420     u16_t len;
;;;1421     u8_t is_fin;
;;;1422   
;;;1423     LWIP_DEBUGF(TCP_DEBUG, 
;;;1424                 ("tcp_zero_window_probe: sending ZERO WINDOW probe to %"
;;;1425                  U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;1426                  ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
;;;1427                  ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
;;;1428   
;;;1429     LWIP_DEBUGF(TCP_DEBUG, 
;;;1430                 ("tcp_zero_window_probe: tcp_ticks %"U32_F
;;;1431                  "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
;;;1432                  tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
;;;1433   
;;;1434     seg = pcb->unacked;
;;;1435   
;;;1436     if(seg == NULL) {
;;;1437       seg = pcb->unsent;
00000a  6eec              LDR      r4,[r5,#0x6c]
00000c  2c00              CMP      r4,#0
00000e  d03e              BEQ      |L16.142|
                  |L16.16|
;;;1438     }
;;;1439     if(seg == NULL) {
;;;1440       return;
;;;1441     }
;;;1442   
;;;1443     is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
000010  68e0              LDR      r0,[r4,#0xc]
000012  8980              LDRH     r0,[r0,#0xc]
000014  f7fffffe          BL       lwip_ntohs
000018  07c0              LSLS     r0,r0,#31
00001a  d001              BEQ      |L16.32|
00001c  8920              LDRH     r0,[r4,#8]
00001e  b1c8              CBZ      r0,|L16.84|
                  |L16.32|
000020  2000              MOVS     r0,#0
                  |L16.34|
000022  ea5f0800          MOVS     r8,r0
;;;1444     /* we want to send one seqno: either FIN or data (no options) */
;;;1445     len = is_fin ? 0 : 1;
000026  d017              BEQ      |L16.88|
000028  2200              MOVS     r2,#0
                  |L16.42|
;;;1446   
;;;1447     p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
00002a  68e0              LDR      r0,[r4,#0xc]
00002c  2100              MOVS     r1,#0
00002e  6843              LDR      r3,[r0,#4]
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       tcp_output_alloc_header
000036  0007              MOVS     r7,r0
;;;1448     if(p == NULL) {
000038  d029              BEQ      |L16.142|
;;;1449       LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
;;;1450       return;
;;;1451     }
;;;1452     tcphdr = (struct tcp_hdr *)p->payload;
;;;1453   
;;;1454     if (is_fin) {
00003a  687e              LDR      r6,[r7,#4]
00003c  f1b80f00          CMP      r8,#0
000040  d00c              BEQ      |L16.92|
;;;1455       /* FIN segment, no data */
;;;1456       TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
000042  2011              MOVS     r0,#0x11
000044  f7fffffe          BL       lwip_htons
000048  89b1              LDRH     r1,[r6,#0xc]
00004a  f421517c          BIC      r1,r1,#0x3f00
00004e  4308              ORRS     r0,r0,r1
000050  81b0              STRH     r0,[r6,#0xc]
000052  e00d              B        |L16.112|
                  |L16.84|
000054  2001              MOVS     r0,#1                 ;1443
000056  e7e4              B        |L16.34|
                  |L16.88|
000058  2201              MOVS     r2,#1                 ;1445
00005a  e7e6              B        |L16.42|
                  |L16.92|
;;;1457     } else {
;;;1458       /* Data segment, copy in one byte from the head of the unacked queue */
;;;1459       char *d = ((char *)p->payload + TCP_HLEN);
;;;1460       /* Depending on whether the segment has already been sent (unacked) or not
;;;1461          (unsent), seg->p->payload points to the IP header or TCP header.
;;;1462          Ensure we copy the first TCP data byte: */
;;;1463       pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
00005c  6860              LDR      r0,[r4,#4]
00005e  8923              LDRH     r3,[r4,#8]
000060  f1060114          ADD      r1,r6,#0x14           ;1459
000064  8902              LDRH     r2,[r0,#8]
000066  1ad2              SUBS     r2,r2,r3
000068  b293              UXTH     r3,r2
00006a  2201              MOVS     r2,#1
00006c  f7fffffe          BL       pbuf_copy_partial
                  |L16.112|
;;;1464     }
;;;1465   
;;;1466   #if CHECKSUM_GEN_TCP
;;;1467     tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
;;;1468                                         IP_PROTO_TCP, p->tot_len);
;;;1469   #endif
;;;1470     TCP_STATS_INC(tcp.xmit);
;;;1471   
;;;1472     /* Send output to IP */
;;;1473   #if LWIP_NETIF_HWADDRHINT
;;;1474     ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
;;;1475       &(pcb->addr_hint));
;;;1476   #else /* LWIP_NETIF_HWADDRHINT*/
;;;1477     ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
000070  2106              MOVS     r1,#6
000072  2000              MOVS     r0,#0
000074  e9cd0100          STRD     r0,r1,[sp,#0]
000078  7aab              LDRB     r3,[r5,#0xa]
00007a  1d2a              ADDS     r2,r5,#4
00007c  4629              MOV      r1,r5
00007e  4638              MOV      r0,r7
000080  f7fffffe          BL       ip_output
;;;1478   #endif /* LWIP_NETIF_HWADDRHINT*/
;;;1479   
;;;1480     pbuf_free(p);
000084  4638              MOV      r0,r7
000086  e8bd41fc          POP      {r2-r8,lr}
00008a  f7ffbffe          B.W      pbuf_free
                  |L16.142|
;;;1481   
;;;1482     LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
;;;1483                             " ackno %"U32_F".\n",
;;;1484                             pcb->snd_nxt - 1, pcb->rcv_nxt));
;;;1485   }
00008e  e8bd81fc          POP      {r2-r8,pc}
;;;1486   #endif /* LWIP_TCP */
                          ENDP


                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  7463705f          DCB      "tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in fl"
000004  656e7175
000008  6575655f
00000c  666c6167
000010  733a206e
000014  65656420
000018  65697468
00001c  65722054
000020  43505f53
000024  594e206f
000028  72205443
00002c  505f4649
000030  4e20696e
000034  20666c  
000037  61677320          DCB      "ags (programmer violates API)",0
00003b  2870726f
00003f  6772616d
000043  6d657220
000047  76696f6c
00004b  61746573
00004f  20415049
000053  2900    

; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\stm32f4xx_can.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\stm32f4xx_can.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\ZR60_v1.0_freeRTOS -I..\..\Lwip\App -I..\..\Lwip\Bsp -I..\..\Lwip\Bsp\LAN8742A -I..\..\Lwip\lwip-1.4.1 -I..\..\Lwip\lwip-1.4.1\port -I..\..\Lwip\lwip-1.4.1\port\arch -I..\..\Lwip\lwip-1.4.1\port\Standalone -I..\..\Lwip\lwip-1.4.1\src\include -I..\..\Lwip\lwip-1.4.1\src\include\ipv4 -I..\..\Lwip\lwip-1.4.1\src\include\lwip -I..\..\Lwip\lwip-1.4.1\src\include\netif -I..\..\Ecal\BtnFltr -I..\..\Ecal\UartComn -I..\..\Ecal\MemIf -I..\..\APP -I..\..\APP\BlackListMng -I..\..\APP\SeverNewsPush -I..\..\APP\NewsPull -I..\..\Ecal -I..\..\Ecal\JsonIf -I..\..\Ecal\Mcu_Init -I..\..\Service -I..\..\Complex -I..\..\Complex\FATFS -I..\..\FreeRTOS\Source\include -I..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\FreeRTOS -I.\RTE\_ZR60 -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=..\..\output\stm32f4xx_can.crf ..\..\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_can.c]
                          THUMB

                          AREA ||i.CAN_CancelTransmit||, CODE, READONLY, ALIGN=1

                  CAN_CancelTransmit PROC
;;;845      */
;;;846    void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
000000  b141              CBZ      r1,|L1.20|
;;;847    {
;;;848      /* Check the parameters */
;;;849      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;850      assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
;;;851      /* abort transmission */
;;;852      switch (Mailbox)
000002  2901              CMP      r1,#1
000004  d00a              BEQ      |L1.28|
000006  2902              CMP      r1,#2
000008  d103              BNE      |L1.18|
;;;853      {
;;;854        case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
;;;855          break;
;;;856        case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
;;;857          break;
;;;858        case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
00000a  6881              LDR      r1,[r0,#8]
00000c  f4410100          ORR      r1,r1,#0x800000
                  |L1.16|
000010  6081              STR      r1,[r0,#8]
                  |L1.18|
;;;859          break;
;;;860        default:
;;;861          break;
;;;862      }
;;;863    }
000012  4770              BX       lr
                  |L1.20|
000014  6881              LDR      r1,[r0,#8]            ;854
000016  f0410180          ORR      r1,r1,#0x80           ;854
00001a  e7f9              B        |L1.16|
                  |L1.28|
00001c  6881              LDR      r1,[r0,#8]            ;856
00001e  f4414100          ORR      r1,r1,#0x8000         ;856
000022  e7f5              B        |L1.16|
;;;864    /**
                          ENDP


                          AREA ||i.CAN_ClearFlag||, CODE, READONLY, ALIGN=2

                  CAN_ClearFlag PROC
;;;1582     */
;;;1583   void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
000000  4a0a              LDR      r2,|L2.44|
;;;1584   {
;;;1585     uint32_t flagtmp=0;
;;;1586     /* Check the parameters */
;;;1587     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1588     assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
;;;1589     
;;;1590     if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
000002  4291              CMP      r1,r2
000004  d102              BNE      |L2.12|
;;;1591     {
;;;1592       /* Clear the selected CAN flags */
;;;1593       CANx->ESR = (uint32_t)RESET;
000006  2100              MOVS     r1,#0
000008  6181              STR      r1,[r0,#0x18]
;;;1594     }
;;;1595     else /* MSR or TSR or RF0R or RF1R */
;;;1596     {
;;;1597       flagtmp = CAN_FLAG & 0x000FFFFF;
;;;1598   
;;;1599       if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
;;;1600       {
;;;1601         /* Receive Flags */
;;;1602         CANx->RF0R = (uint32_t)(flagtmp);
;;;1603       }
;;;1604       else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
;;;1605       {
;;;1606         /* Receive Flags */
;;;1607         CANx->RF1R = (uint32_t)(flagtmp);
;;;1608       }
;;;1609       else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
;;;1610       {
;;;1611         /* Transmit Flags */
;;;1612         CANx->TSR = (uint32_t)(flagtmp);
;;;1613       }
;;;1614       else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
;;;1615       {
;;;1616         /* Operating mode Flags */
;;;1617         CANx->MSR = (uint32_t)(flagtmp);
;;;1618       }
;;;1619     }
;;;1620   }
00000a  4770              BX       lr
                  |L2.12|
00000c  f3c10213          UBFX     r2,r1,#0,#20          ;1597
000010  018b              LSLS     r3,r1,#6              ;1599
000012  d501              BPL      |L2.24|
000014  60c2              STR      r2,[r0,#0xc]          ;1602
000016  4770              BX       lr
                  |L2.24|
000018  014b              LSLS     r3,r1,#5              ;1604
00001a  d501              BPL      |L2.32|
00001c  6102              STR      r2,[r0,#0x10]         ;1607
00001e  4770              BX       lr
                  |L2.32|
000020  0109              LSLS     r1,r1,#4              ;1609
000022  d501              BPL      |L2.40|
000024  6082              STR      r2,[r0,#8]            ;1612
000026  4770              BX       lr
                  |L2.40|
000028  6042              STR      r2,[r0,#4]            ;1617
00002a  4770              BX       lr
;;;1621   
                          ENDP

                  |L2.44|
                          DCD      0x30f00070

                          AREA ||i.CAN_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  CAN_ClearITPendingBit PROC
;;;1748     */
;;;1749   void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;1750   {
;;;1751     /* Check the parameters */
;;;1752     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1753     assert_param(IS_CAN_CLEAR_IT(CAN_IT));
;;;1754   
;;;1755     switch (CAN_IT)
;;;1756     {
;;;1757       case CAN_IT_TME:
;;;1758         /* Clear CAN_TSR_RQCPx (rc_w1)*/
;;;1759         CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
;;;1760         break;
;;;1761       case CAN_IT_FF0:
;;;1762         /* Clear CAN_RF0R_FULL0 (rc_w1)*/
;;;1763         CANx->RF0R = CAN_RF0R_FULL0; 
000002  2308              MOVS     r3,#8
;;;1764         break;
;;;1765       case CAN_IT_FOV0:
;;;1766         /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
;;;1767         CANx->RF0R = CAN_RF0R_FOVR0; 
000004  2410              MOVS     r4,#0x10
;;;1768         break;
;;;1769       case CAN_IT_FF1:
;;;1770         /* Clear CAN_RF1R_FULL1 (rc_w1)*/
;;;1771         CANx->RF1R = CAN_RF1R_FULL1;  
;;;1772         break;
;;;1773       case CAN_IT_FOV1:
;;;1774         /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
;;;1775         CANx->RF1R = CAN_RF1R_FOVR1; 
;;;1776         break;
;;;1777       case CAN_IT_WKU:
;;;1778         /* Clear CAN_MSR_WKUI (rc_w1)*/
;;;1779         CANx->MSR = CAN_MSR_WKUI;  
;;;1780         break;
;;;1781       case CAN_IT_SLK:
;;;1782         /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
;;;1783         CANx->MSR = CAN_MSR_SLAKI;   
;;;1784         break;
;;;1785       case CAN_IT_EWG:
;;;1786         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1787         CANx->MSR = CAN_MSR_ERRI;
000006  2204              MOVS     r2,#4
000008  f5b17f00          CMP      r1,#0x200             ;1755
00000c  d01d              BEQ      |L3.74|
00000e  dc10              BGT      |L3.50|
000010  2920              CMP      r1,#0x20              ;1755
000012  d029              BEQ      |L3.104|
000014  dc07              BGT      |L3.38|
000016  2901              CMP      r1,#1                 ;1755
000018  d021              BEQ      |L3.94|
00001a  2904              CMP      r1,#4                 ;1755
00001c  d022              BEQ      |L3.100|
00001e  2908              CMP      r1,#8                 ;1755
000020  d100              BNE      |L3.36|
000022  60c4              STR      r4,[r0,#0xc]          ;1767
                  |L3.36|
;;;1788          /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/ 
;;;1789         break;
;;;1790       case CAN_IT_EPV:
;;;1791         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1792         CANx->MSR = CAN_MSR_ERRI; 
;;;1793          /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
;;;1794         break;
;;;1795       case CAN_IT_BOF:
;;;1796         /* Clear CAN_MSR_ERRI (rc_w1) */ 
;;;1797         CANx->MSR = CAN_MSR_ERRI; 
;;;1798          /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
;;;1799          break;
;;;1800       case CAN_IT_LEC:
;;;1801         /*  Clear LEC bits */
;;;1802         CANx->ESR = RESET; 
;;;1803         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1804         CANx->MSR = CAN_MSR_ERRI; 
;;;1805         break;
;;;1806       case CAN_IT_ERR:
;;;1807         /*Clear LEC bits */
;;;1808         CANx->ESR = RESET; 
;;;1809         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1810         CANx->MSR = CAN_MSR_ERRI; 
;;;1811          /* @note BOFF, EPVF and EWGF Flags are cleared by hardware depending on the CAN Bus status*/
;;;1812          break;
;;;1813       default:
;;;1814          break;
;;;1815      }
;;;1816   }
000024  bd30              POP      {r4,r5,pc}
                  |L3.38|
000026  2940              CMP      r1,#0x40              ;1755
000028  d020              BEQ      |L3.108|
00002a  f5b17f80          CMP      r1,#0x100             ;1755
00002e  d1f9              BNE      |L3.36|
000030  e00b              B        |L3.74|
                  |L3.50|
000032  2500              MOVS     r5,#0                 ;1755
000034  f5b14f00          CMP      r1,#0x8000            ;1755
000038  d006              BEQ      |L3.72|
00003a  dc08              BGT      |L3.78|
00003c  f5b16f80          CMP      r1,#0x400             ;1755
000040  d003              BEQ      |L3.74|
000042  f5b16f00          CMP      r1,#0x800             ;1755
000046  d1ed              BNE      |L3.36|
                  |L3.72|
000048  6185              STR      r5,[r0,#0x18]         ;1808
                  |L3.74|
00004a  6042              STR      r2,[r0,#4]            ;1797
                  |L3.76|
00004c  bd30              POP      {r4,r5,pc}
                  |L3.78|
00004e  f5b13f80          CMP      r1,#0x10000           ;1755
000052  d00d              BEQ      |L3.112|
000054  f5b13f00          CMP      r1,#0x20000           ;1755
000058  d1f8              BNE      |L3.76|
00005a  6044              STR      r4,[r0,#4]            ;1783
00005c  bd30              POP      {r4,r5,pc}
                  |L3.94|
00005e  4905              LDR      r1,|L3.116|
000060  6081              STR      r1,[r0,#8]            ;1759
000062  bd30              POP      {r4,r5,pc}
                  |L3.100|
000064  60c3              STR      r3,[r0,#0xc]          ;1763
000066  bd30              POP      {r4,r5,pc}
                  |L3.104|
000068  6103              STR      r3,[r0,#0x10]         ;1771
00006a  bd30              POP      {r4,r5,pc}
                  |L3.108|
00006c  6104              STR      r4,[r0,#0x10]         ;1775
00006e  bd30              POP      {r4,r5,pc}
                  |L3.112|
000070  6043              STR      r3,[r0,#4]            ;1779
000072  bd30              POP      {r4,r5,pc}
;;;1817    /**
                          ENDP

                  |L3.116|
                          DCD      0x00010101

                          AREA ||i.CAN_DBGFreeze||, CODE, READONLY, ALIGN=1

                  CAN_DBGFreeze PROC
;;;631      */
;;;632    void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;633    {
;;;634      /* Check the parameters */
;;;635      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;636      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;637      
;;;638      if (NewState != DISABLE)
;;;639      {
;;;640        /* Enable Debug Freeze  */
;;;641        CANx->MCR |= MCR_DBF;
;;;642      }
;;;643      else
;;;644      {
;;;645        /* Disable Debug Freeze */
;;;646        CANx->MCR &= ~MCR_DBF;
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L4.12|
000006  f4413180          ORR      r1,r1,#0x10000        ;641
00000a  e001              B        |L4.16|
                  |L4.12|
00000c  f4213180          BIC      r1,r1,#0x10000
                  |L4.16|
000010  6001              STR      r1,[r0,#0]            ;641
;;;647      }
;;;648    }
000012  4770              BX       lr
;;;649    
                          ENDP


                          AREA ||i.CAN_DeInit||, CODE, READONLY, ALIGN=2

                  CAN_DeInit PROC
;;;166      */
;;;167    void CAN_DeInit(CAN_TypeDef* CANx)
000000  4909              LDR      r1,|L5.40|
;;;168    {
000002  b510              PUSH     {r4,lr}
;;;169      /* Check the parameters */
;;;170      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;171     
;;;172      if (CANx == CAN1)
000004  4288              CMP      r0,r1
;;;173      {
;;;174        /* Enable CAN1 reset state */
;;;175        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
;;;176        /* Release CAN1 from reset state */
;;;177        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
;;;178      }
;;;179    #if defined(STM32F413_423xx)
;;;180      else if(CANx == CAN2)
;;;181      {  
;;;182        /* Enable CAN2 reset state */
;;;183        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
;;;184        /* Release CAN2 from reset state */
;;;185        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
;;;186      }
;;;187      
;;;188      else /* CAN3 available only for STM32F413_423xx */
;;;189      {
;;;190        /* Enable CAN3 reset state */
;;;191        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN3, ENABLE);
;;;192        /* Release CAN3 from reset state */
;;;193        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN3, DISABLE); 
;;;194      }
;;;195    #else
;;;196      else
;;;197      {
;;;198        /* Enable CAN2 reset state */
;;;199        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
000006  f04f0101          MOV      r1,#1
00000a  d101              BNE      |L5.16|
00000c  064c              LSLS     r4,r1,#25             ;175
00000e  e001              B        |L5.20|
                  |L5.16|
000010  f04f6480          MOV      r4,#0x4000000
                  |L5.20|
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;200        /* Release CAN2 from reset state */
;;;201        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
00001a  4620              MOV      r0,r4
00001c  e8bd4010          POP      {r4,lr}
000020  2100              MOVS     r1,#0
000022  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
;;;202      }
;;;203    #endif /* STM32F413_423xx */
;;;204    }
;;;205    
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
                          DCD      0x40006400

                          AREA ||i.CAN_FIFORelease||, CODE, READONLY, ALIGN=1

                  CAN_FIFORelease PROC
;;;943      */
;;;944    void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
000000  b121              CBZ      r1,|L6.12|
;;;945    {
;;;946      /* Check the parameters */
;;;947      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;948      assert_param(IS_CAN_FIFO(FIFONumber));
;;;949      /* Release FIFO0 */
;;;950      if (FIFONumber == CAN_FIFO0)
;;;951      {
;;;952        CANx->RF0R |= CAN_RF0R_RFOM0;
;;;953      }
;;;954      /* Release FIFO1 */
;;;955      else /* FIFONumber == CAN_FIFO1 */
;;;956      {
;;;957        CANx->RF1R |= CAN_RF1R_RFOM1;
000002  6901              LDR      r1,[r0,#0x10]
000004  f0410120          ORR      r1,r1,#0x20
000008  6101              STR      r1,[r0,#0x10]
;;;958      }
;;;959    }
00000a  4770              BX       lr
                  |L6.12|
00000c  68c1              LDR      r1,[r0,#0xc]          ;952
00000e  f0410120          ORR      r1,r1,#0x20           ;952
000012  60c1              STR      r1,[r0,#0xc]          ;952
000014  4770              BX       lr
;;;960    
                          ENDP


                          AREA ||i.CAN_FilterInit||, CODE, READONLY, ALIGN=2

                  CAN_FilterInit PROC
;;;447      */
;;;448    void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
000000  b5f0              PUSH     {r4-r7,lr}
;;;449    {
;;;450      uint32_t filter_number_bit_pos = 0;
;;;451      /* Check the parameters */
;;;452      assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
;;;453      assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
;;;454      assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
;;;455      assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
;;;456      assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
;;;457    
;;;458      filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
000002  7a82              LDRB     r2,[r0,#0xa]
;;;459    
;;;460      /* Initialisation mode for the filter */
;;;461      CAN1->FMR |= FMR_FINIT;
000004  4d2f              LDR      r5,|L7.196|
000006  2101              MOVS     r1,#1                 ;458
000008  4091              LSLS     r1,r1,r2              ;458
00000a  682a              LDR      r2,[r5,#0]
00000c  f0420201          ORR      r2,r2,#1
000010  602a              STR      r2,[r5,#0]
;;;462    
;;;463      /* Filter Deactivation */
;;;464      CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
000012  4e2c              LDR      r6,|L7.196|
000014  361c              ADDS     r6,r6,#0x1c
000016  6832              LDR      r2,[r6,#0]
000018  438a              BICS     r2,r2,r1
00001a  6032              STR      r2,[r6,#0]
;;;465    
;;;466      /* Filter Scale */
;;;467      if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
;;;468      {
;;;469        /* 16-bit scale for the filter */
;;;470        CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
00001c  4a29              LDR      r2,|L7.196|
00001e  7b04              LDRB     r4,[r0,#0xc]          ;467
;;;471    
;;;472        /* First 16-bit identifier and First 16-bit mask */
;;;473        /* Or First 16-bit identifier and Second 16-bit identifier */
;;;474        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
000020  4b29              LDR      r3,|L7.200|
000022  320c              ADDS     r2,r2,#0xc            ;470
000024  b9a4              CBNZ     r4,|L7.80|
000026  6814              LDR      r4,[r2,#0]            ;470
000028  438c              BICS     r4,r4,r1              ;470
00002a  6014              STR      r4,[r2,#0]            ;470
00002c  8844              LDRH     r4,[r0,#2]
00002e  88c7              LDRH     r7,[r0,#6]
000030  ea444407          ORR      r4,r4,r7,LSL #16
000034  7a87              LDRB     r7,[r0,#0xa]
000036  eb0307c7          ADD      r7,r3,r7,LSL #3
00003a  f8c74640          STR      r4,[r7,#0x640]
;;;475           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
;;;476            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
;;;477    
;;;478        /* Second 16-bit identifier and Second 16-bit mask */
;;;479        /* Or Third 16-bit identifier and Fourth 16-bit identifier */
;;;480        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
00003e  8804              LDRH     r4,[r0,#0]
000040  8887              LDRH     r7,[r0,#4]
000042  ea444407          ORR      r4,r4,r7,LSL #16
000046  7a87              LDRB     r7,[r0,#0xa]
000048  eb0307c7          ADD      r7,r3,r7,LSL #3
00004c  f8c74644          STR      r4,[r7,#0x644]
                  |L7.80|
;;;481           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
;;;482            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
;;;483      }
;;;484    
;;;485      if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
000050  7b04              LDRB     r4,[r0,#0xc]
000052  2c01              CMP      r4,#1
000054  d112              BNE      |L7.124|
;;;486      {
;;;487        /* 32-bit scale for the filter */
;;;488        CAN1->FS1R |= filter_number_bit_pos;
000056  6814              LDR      r4,[r2,#0]
000058  430c              ORRS     r4,r4,r1
00005a  6014              STR      r4,[r2,#0]
;;;489        /* 32-bit identifier or First 32-bit identifier */
;;;490        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
00005c  7a84              LDRB     r4,[r0,#0xa]
00005e  6802              LDR      r2,[r0,#0]
000060  eb0304c4          ADD      r4,r3,r4,LSL #3
000064  ea4f4232          ROR      r2,r2,#16
000068  f8c42640          STR      r2,[r4,#0x640]
;;;491           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
;;;492            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
;;;493        /* 32-bit mask or Second 32-bit identifier */
;;;494        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
00006c  7a84              LDRB     r4,[r0,#0xa]
00006e  6842              LDR      r2,[r0,#4]
000070  eb0303c4          ADD      r3,r3,r4,LSL #3
000074  ea4f4232          ROR      r2,r2,#16
000078  f8c32644          STR      r2,[r3,#0x644]
                  |L7.124|
;;;495           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
;;;496            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
;;;497      }
;;;498    
;;;499      /* Filter Mode */
;;;500      if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
;;;501      {
;;;502        /*Id/Mask mode for the filter*/
;;;503        CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
00007c  4a11              LDR      r2,|L7.196|
00007e  7ac3              LDRB     r3,[r0,#0xb]          ;500
000080  1d12              ADDS     r2,r2,#4
000082  2b00              CMP      r3,#0                 ;500
;;;504      }
;;;505      else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
;;;506      {
;;;507        /*Identifier list mode for the filter*/
;;;508        CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
000084  6813              LDR      r3,[r2,#0]
000086  d006              BEQ      |L7.150|
000088  430b              ORRS     r3,r3,r1
                  |L7.138|
00008a  6013              STR      r3,[r2,#0]
;;;509      }
;;;510    
;;;511      /* Filter FIFO assignment */
;;;512      if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
;;;513      {
;;;514        /* FIFO 0 assignation for the filter */
;;;515        CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
00008c  4a0d              LDR      r2,|L7.196|
00008e  8903              LDRH     r3,[r0,#8]            ;512
000090  3214              ADDS     r2,r2,#0x14
000092  b113              CBZ      r3,|L7.154|
000094  e004              B        |L7.160|
                  |L7.150|
000096  438b              BICS     r3,r3,r1              ;503
000098  e7f7              B        |L7.138|
                  |L7.154|
00009a  6813              LDR      r3,[r2,#0]
00009c  438b              BICS     r3,r3,r1
00009e  6013              STR      r3,[r2,#0]
                  |L7.160|
;;;516      }
;;;517    
;;;518      if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
0000a0  8903              LDRH     r3,[r0,#8]
0000a2  2b01              CMP      r3,#1
0000a4  d102              BNE      |L7.172|
;;;519      {
;;;520        /* FIFO 1 assignation for the filter */
;;;521        CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
0000a6  6813              LDR      r3,[r2,#0]
0000a8  430b              ORRS     r3,r3,r1
0000aa  6013              STR      r3,[r2,#0]
                  |L7.172|
;;;522      }
;;;523      
;;;524      /* Filter activation */
;;;525      if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
0000ac  7b40              LDRB     r0,[r0,#0xd]
0000ae  2801              CMP      r0,#1
0000b0  d102              BNE      |L7.184|
;;;526      {
;;;527        CAN1->FA1R |= filter_number_bit_pos;
0000b2  6830              LDR      r0,[r6,#0]
0000b4  4308              ORRS     r0,r0,r1
0000b6  6030              STR      r0,[r6,#0]
                  |L7.184|
;;;528      }
;;;529    
;;;530      /* Leave the initialisation mode for the filter */
;;;531      CAN1->FMR &= ~FMR_FINIT;
0000b8  6828              LDR      r0,[r5,#0]
0000ba  f0200001          BIC      r0,r0,#1
0000be  6028              STR      r0,[r5,#0]
;;;532    }
0000c0  bdf0              POP      {r4-r7,pc}
;;;533    #endif /* STM32F413_423xx */
                          ENDP

0000c2  0000              DCW      0x0000
                  |L7.196|
                          DCD      0x40006600
                  |L7.200|
                          DCD      0x40006000

                          AREA ||i.CAN_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  CAN_GetFlagStatus PROC
;;;1481     */
;;;1482   FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
000000  4602              MOV      r2,r0
;;;1483   {
;;;1484     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1485     
;;;1486     /* Check the parameters */
;;;1487     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1488     assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
;;;1489     
;;;1490   
;;;1491     if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
000004  f4110f70          TST      r1,#0xf00000
000008  d003              BEQ      |L8.18|
;;;1492     { 
;;;1493       /* Check the status of the specified CAN flag */
;;;1494       if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
00000a  6992              LDR      r2,[r2,#0x18]
00000c  e004              B        |L8.24|
                  |L8.14|
;;;1495       { 
;;;1496         /* CAN_FLAG is set */
;;;1497         bitstatus = SET;
00000e  2001              MOVS     r0,#1
;;;1498       }
;;;1499       else
;;;1500       { 
;;;1501         /* CAN_FLAG is reset */
;;;1502         bitstatus = RESET;
;;;1503       }
;;;1504     }
;;;1505     else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
;;;1506     { 
;;;1507       /* Check the status of the specified CAN flag */
;;;1508       if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
;;;1509       { 
;;;1510         /* CAN_FLAG is set */
;;;1511         bitstatus = SET;
;;;1512       }
;;;1513       else
;;;1514       { 
;;;1515         /* CAN_FLAG is reset */
;;;1516         bitstatus = RESET;
;;;1517       }
;;;1518     }
;;;1519     else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
;;;1520     { 
;;;1521       /* Check the status of the specified CAN flag */
;;;1522       if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
;;;1523       { 
;;;1524         /* CAN_FLAG is set */
;;;1525         bitstatus = SET;
;;;1526       }
;;;1527       else
;;;1528       { 
;;;1529         /* CAN_FLAG is reset */
;;;1530         bitstatus = RESET;
;;;1531       }
;;;1532     }
;;;1533     else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
;;;1534     { 
;;;1535       /* Check the status of the specified CAN flag */
;;;1536       if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
;;;1537       { 
;;;1538         /* CAN_FLAG is set */
;;;1539         bitstatus = SET;
;;;1540       }
;;;1541       else
;;;1542       { 
;;;1543         /* CAN_FLAG is reset */
;;;1544         bitstatus = RESET;
;;;1545       }
;;;1546     }
;;;1547     else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
;;;1548     { 
;;;1549       /* Check the status of the specified CAN flag */
;;;1550       if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
;;;1551       { 
;;;1552         /* CAN_FLAG is set */
;;;1553         bitstatus = SET;
;;;1554       }
;;;1555       else
;;;1556       { 
;;;1557         /* CAN_FLAG is reset */
;;;1558         bitstatus = RESET;
;;;1559       }
;;;1560     }
;;;1561     /* Return the CAN_FLAG status */
;;;1562     return  bitstatus;
;;;1563   }
000010  4770              BX       lr
                  |L8.18|
000012  01cb              LSLS     r3,r1,#7              ;1505
000014  d504              BPL      |L8.32|
000016  6852              LDR      r2,[r2,#4]            ;1508
                  |L8.24|
000018  400a              ANDS     r2,r2,r1              ;1494
00001a  0311              LSLS     r1,r2,#12             ;1494
00001c  d1f7              BNE      |L8.14|
00001e  4770              BX       lr
                  |L8.32|
000020  010b              LSLS     r3,r1,#4              ;1519
000022  d501              BPL      |L8.40|
000024  6892              LDR      r2,[r2,#8]            ;1522
000026  e7f7              B        |L8.24|
                  |L8.40|
000028  018b              LSLS     r3,r1,#6              ;1533
00002a  d501              BPL      |L8.48|
00002c  68d2              LDR      r2,[r2,#0xc]          ;1536
00002e  e7f3              B        |L8.24|
                  |L8.48|
000030  6912              LDR      r2,[r2,#0x10]         ;1550
000032  e7f1              B        |L8.24|
;;;1564   
                          ENDP


                          AREA ||i.CAN_GetITStatus||, CODE, READONLY, ALIGN=2

                  CAN_GetITStatus PROC
;;;1643     */
;;;1644   ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
000000  4602              MOV      r2,r0
;;;1645   {
;;;1646     ITStatus itstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1647     /* Check the parameters */
;;;1648     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1649     assert_param(IS_CAN_IT(CAN_IT));
;;;1650     
;;;1651     /* check the interrupt enable bit */
;;;1652    if((CANx->IER & CAN_IT) != RESET)
000004  6953              LDR      r3,[r2,#0x14]
000006  420b              TST      r3,r1
000008  d04a              BEQ      |L9.160|
;;;1653    {
;;;1654      /* in case the Interrupt is enabled, .... */
;;;1655       switch (CAN_IT)
00000a  f5b17f80          CMP      r1,#0x100
00000e  d03b              BEQ      |L9.136|
000010  dc13              BGT      |L9.58|
000012  2908              CMP      r1,#8
000014  d02e              BEQ      |L9.116|
000016  dc07              BGT      |L9.40|
000018  2901              CMP      r1,#1
00001a  d026              BEQ      |L9.106|
00001c  2902              CMP      r1,#2
00001e  d027              BEQ      |L9.112|
000020  2904              CMP      r1,#4
000022  d13d              BNE      |L9.160|
;;;1656       {
;;;1657         case CAN_IT_TME:
;;;1658           /* Check CAN_TSR_RQCPx bits */
;;;1659           itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
;;;1660           break;
;;;1661         case CAN_IT_FMP0:
;;;1662           /* Check CAN_RF0R_FMP0 bit */
;;;1663           itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
;;;1664           break;
;;;1665         case CAN_IT_FF0:
;;;1666           /* Check CAN_RF0R_FULL0 bit */
;;;1667           itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
000024  68d0              LDR      r0,[r2,#0xc]
;;;1668           break;
000026  e02b              B        |L9.128|
                  |L9.40|
000028  2910              CMP      r1,#0x10              ;1655
00002a  d025              BEQ      |L9.120|
00002c  2920              CMP      r1,#0x20              ;1655
00002e  d026              BEQ      |L9.126|
000030  2940              CMP      r1,#0x40              ;1655
000032  d135              BNE      |L9.160|
;;;1669         case CAN_IT_FOV0:
;;;1670           /* Check CAN_RF0R_FOVR0 bit */
;;;1671           itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
;;;1672           break;
;;;1673         case CAN_IT_FMP1:
;;;1674           /* Check CAN_RF1R_FMP1 bit */
;;;1675           itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
;;;1676           break;
;;;1677         case CAN_IT_FF1:
;;;1678           /* Check CAN_RF1R_FULL1 bit */
;;;1679           itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
;;;1680           break;
;;;1681         case CAN_IT_FOV1:
;;;1682           /* Check CAN_RF1R_FOVR1 bit */
;;;1683           itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
000034  6910              LDR      r0,[r2,#0x10]
                  |L9.54|
000036  2110              MOVS     r1,#0x10              ;1671
000038  e030              B        |L9.156|
                  |L9.58|
00003a  f5b14f00          CMP      r1,#0x8000            ;1655
00003e  d02b              BEQ      |L9.152|
000040  dc0b              BGT      |L9.90|
000042  f5b17f00          CMP      r1,#0x200             ;1655
000046  d022              BEQ      |L9.142|
000048  f5b16f80          CMP      r1,#0x400             ;1655
00004c  d022              BEQ      |L9.148|
00004e  f5b16f00          CMP      r1,#0x800             ;1655
000052  d125              BNE      |L9.160|
;;;1684           break;
;;;1685         case CAN_IT_WKU:
;;;1686           /* Check CAN_MSR_WKUI bit */
;;;1687           itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
;;;1688           break;
;;;1689         case CAN_IT_SLK:
;;;1690           /* Check CAN_MSR_SLAKI bit */
;;;1691           itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
;;;1692           break;
;;;1693         case CAN_IT_EWG:
;;;1694           /* Check CAN_ESR_EWGF bit */
;;;1695           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
;;;1696           break;
;;;1697         case CAN_IT_EPV:
;;;1698           /* Check CAN_ESR_EPVF bit */
;;;1699           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
;;;1700           break;
;;;1701         case CAN_IT_BOF:
;;;1702           /* Check CAN_ESR_BOFF bit */
;;;1703           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
;;;1704           break;
;;;1705         case CAN_IT_LEC:
;;;1706           /* Check CAN_ESR_LEC bit */
;;;1707           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
000054  6990              LDR      r0,[r2,#0x18]
000056  2170              MOVS     r1,#0x70
;;;1708           break;
000058  e020              B        |L9.156|
                  |L9.90|
00005a  f5b13f80          CMP      r1,#0x10000           ;1655
00005e  d011              BEQ      |L9.132|
000060  f5b13f00          CMP      r1,#0x20000           ;1655
000064  d11c              BNE      |L9.160|
000066  6850              LDR      r0,[r2,#4]            ;1691
000068  e7e5              B        |L9.54|
                  |L9.106|
00006a  6890              LDR      r0,[r2,#8]            ;1659
00006c  490d              LDR      r1,|L9.164|
00006e  e015              B        |L9.156|
                  |L9.112|
000070  68d0              LDR      r0,[r2,#0xc]          ;1663
000072  e002              B        |L9.122|
                  |L9.116|
000074  68d0              LDR      r0,[r2,#0xc]          ;1671
000076  e7de              B        |L9.54|
                  |L9.120|
000078  6910              LDR      r0,[r2,#0x10]         ;1675
                  |L9.122|
00007a  2103              MOVS     r1,#3                 ;1663
00007c  e00e              B        |L9.156|
                  |L9.126|
00007e  6910              LDR      r0,[r2,#0x10]         ;1679
                  |L9.128|
000080  2108              MOVS     r1,#8                 ;1667
000082  e00b              B        |L9.156|
                  |L9.132|
000084  6850              LDR      r0,[r2,#4]            ;1687
000086  e7fb              B        |L9.128|
                  |L9.136|
000088  6990              LDR      r0,[r2,#0x18]         ;1695
00008a  2101              MOVS     r1,#1                 ;1695
00008c  e006              B        |L9.156|
                  |L9.142|
00008e  6990              LDR      r0,[r2,#0x18]         ;1699
000090  2102              MOVS     r1,#2                 ;1699
000092  e003              B        |L9.156|
                  |L9.148|
000094  6990              LDR      r0,[r2,#0x18]         ;1703
000096  e000              B        |L9.154|
                  |L9.152|
;;;1709         case CAN_IT_ERR:
;;;1710           /* Check CAN_MSR_ERRI bit */ 
;;;1711           itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
000098  6850              LDR      r0,[r2,#4]
                  |L9.154|
00009a  2104              MOVS     r1,#4                 ;1703
                  |L9.156|
00009c  f7ffbffe          B.W      CheckITStatus
                  |L9.160|
;;;1712           break;
;;;1713         default:
;;;1714           /* in case of error, return RESET */
;;;1715           itstatus = RESET;
;;;1716           break;
;;;1717       }
;;;1718     }
;;;1719     else
;;;1720     {
;;;1721      /* in case the Interrupt is not enabled, return RESET */
;;;1722       itstatus  = RESET;
;;;1723     }
;;;1724     
;;;1725     /* Return the CAN_IT status */
;;;1726     return  itstatus;
;;;1727   }
0000a0  4770              BX       lr
;;;1728   
                          ENDP

0000a2  0000              DCW      0x0000
                  |L9.164|
                          DCD      0x00010101

                          AREA ||i.CAN_GetLSBTransmitErrorCounter||, CODE, READONLY, ALIGN=1

                  CAN_GetLSBTransmitErrorCounter PROC
;;;1234     */
;;;1235   uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)
000000  6980              LDR      r0,[r0,#0x18]
;;;1236   {
;;;1237     uint8_t counter=0;
;;;1238     
;;;1239     /* Check the parameters */
;;;1240     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1241     
;;;1242     /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
;;;1243     counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
000002  f3c04007          UBFX     r0,r0,#16,#8
;;;1244     
;;;1245     /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
;;;1246     return counter;
;;;1247   }
000006  4770              BX       lr
;;;1248   /**
                          ENDP


                          AREA ||i.CAN_GetLastErrorCode||, CODE, READONLY, ALIGN=1

                  CAN_GetLastErrorCode PROC
;;;1187     */
;;;1188   uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)
000000  6980              LDR      r0,[r0,#0x18]
;;;1189   {
;;;1190     uint8_t errorcode=0;
;;;1191     
;;;1192     /* Check the parameters */
;;;1193     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1194     
;;;1195     /* Get the error code*/
;;;1196     errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
000002  f3c01002          UBFX     r0,r0,#4,#3
000006  0100              LSLS     r0,r0,#4
;;;1197     
;;;1198     /* Return the error code*/
;;;1199     return errorcode;
;;;1200   }
000008  4770              BX       lr
;;;1201   
                          ENDP


                          AREA ||i.CAN_GetReceiveErrorCounter||, CODE, READONLY, ALIGN=1

                  CAN_GetReceiveErrorCounter PROC
;;;1213     */
;;;1214   uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)
000000  6980              LDR      r0,[r0,#0x18]
;;;1215   {
;;;1216     uint8_t counter=0;
;;;1217     
;;;1218     /* Check the parameters */
;;;1219     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1220     
;;;1221     /* Get the Receive Error Counter*/
;;;1222     counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
000002  0e00              LSRS     r0,r0,#24
;;;1223     
;;;1224     /* Return the Receive Error Counter*/
;;;1225     return counter;
;;;1226   }
000004  4770              BX       lr
;;;1227   
                          ENDP


                          AREA ||i.CAN_ITConfig||, CODE, READONLY, ALIGN=1

                  CAN_ITConfig PROC
;;;1440     */
;;;1441   void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;1442   {
;;;1443     /* Check the parameters */
;;;1444     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1445     assert_param(IS_CAN_IT(CAN_IT));
;;;1446     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1447   
;;;1448     if (NewState != DISABLE)
;;;1449     {
;;;1450       /* Enable the selected CANx interrupt */
;;;1451       CANx->IER |= CAN_IT;
;;;1452     }
;;;1453     else
;;;1454     {
;;;1455       /* Disable the selected CANx interrupt */
;;;1456       CANx->IER &= ~CAN_IT;
000002  6942              LDR      r2,[r0,#0x14]
000004  d001              BEQ      |L13.10|
000006  430a              ORRS     r2,r2,r1              ;1451
000008  e000              B        |L13.12|
                  |L13.10|
00000a  438a              BICS     r2,r2,r1
                  |L13.12|
00000c  6142              STR      r2,[r0,#0x14]         ;1451
;;;1457     }
;;;1458   }
00000e  4770              BX       lr
;;;1459   /**
                          ENDP


                          AREA ||i.CAN_Init||, CODE, READONLY, ALIGN=1

                  CAN_Init PROC
;;;215      */
;;;216    uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
000000  b510              PUSH     {r4,lr}
;;;217    {
;;;218      uint8_t InitStatus = CAN_InitStatus_Failed;
;;;219      uint32_t wait_ack = 0x00000000;
;;;220      /* Check the parameters */
;;;221      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;222      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
;;;223      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
;;;224      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
;;;225      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
;;;226      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
;;;227      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
;;;228      assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
;;;229      assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
;;;230      assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
;;;231      assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
;;;232      assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
;;;233    
;;;234      /* Exit from sleep mode */
;;;235      CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
000002  6803              LDR      r3,[r0,#0]
000004  2200              MOVS     r2,#0                 ;219
000006  f0230302          BIC      r3,r3,#2
00000a  6003              STR      r3,[r0,#0]
;;;236    
;;;237      /* Request initialisation */
;;;238      CANx->MCR |= CAN_MCR_INRQ ;
00000c  6803              LDR      r3,[r0,#0]
00000e  f0430301          ORR      r3,r3,#1
000012  6003              STR      r3,[r0,#0]
;;;239    
;;;240      /* Wait the acknowledge */
;;;241      while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
000014  f64f73ff          MOV      r3,#0xffff
000018  e000              B        |L14.28|
                  |L14.26|
00001a  1c52              ADDS     r2,r2,#1              ;217
                  |L14.28|
00001c  6844              LDR      r4,[r0,#4]
00001e  07e4              LSLS     r4,r4,#31
000020  d101              BNE      |L14.38|
000022  429a              CMP      r2,r3
000024  d1f9              BNE      |L14.26|
                  |L14.38|
;;;242      {
;;;243        wait_ack++;
;;;244      }
;;;245    
;;;246      /* Check acknowledge */
;;;247      if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
000026  6842              LDR      r2,[r0,#4]
000028  07d2              LSLS     r2,r2,#31
00002a  d03e              BEQ      |L14.170|
;;;248      {
;;;249        InitStatus = CAN_InitStatus_Failed;
;;;250      }
;;;251      else 
;;;252      {
;;;253        /* Set the time triggered communication mode */
;;;254        if (CAN_InitStruct->CAN_TTCM == ENABLE)
00002c  798a              LDRB     r2,[r1,#6]
00002e  2a01              CMP      r2,#1
;;;255        {
;;;256          CANx->MCR |= CAN_MCR_TTCM;
;;;257        }
;;;258        else
;;;259        {
;;;260          CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
000030  6802              LDR      r2,[r0,#0]
000032  d03c              BEQ      |L14.174|
000034  f0220280          BIC      r2,r2,#0x80
                  |L14.56|
000038  6002              STR      r2,[r0,#0]
;;;261        }
;;;262    
;;;263        /* Set the automatic bus-off management */
;;;264        if (CAN_InitStruct->CAN_ABOM == ENABLE)
00003a  79ca              LDRB     r2,[r1,#7]
00003c  2a01              CMP      r2,#1
;;;265        {
;;;266          CANx->MCR |= CAN_MCR_ABOM;
;;;267        }
;;;268        else
;;;269        {
;;;270          CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
00003e  6802              LDR      r2,[r0,#0]
000040  d038              BEQ      |L14.180|
000042  f0220240          BIC      r2,r2,#0x40
                  |L14.70|
000046  6002              STR      r2,[r0,#0]
;;;271        }
;;;272    
;;;273        /* Set the automatic wake-up mode */
;;;274        if (CAN_InitStruct->CAN_AWUM == ENABLE)
000048  7a0a              LDRB     r2,[r1,#8]
00004a  2a01              CMP      r2,#1
;;;275        {
;;;276          CANx->MCR |= CAN_MCR_AWUM;
;;;277        }
;;;278        else
;;;279        {
;;;280          CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
00004c  6802              LDR      r2,[r0,#0]
00004e  d034              BEQ      |L14.186|
000050  f0220220          BIC      r2,r2,#0x20
                  |L14.84|
000054  6002              STR      r2,[r0,#0]
;;;281        }
;;;282    
;;;283        /* Set the no automatic retransmission */
;;;284        if (CAN_InitStruct->CAN_NART == ENABLE)
000056  7a4a              LDRB     r2,[r1,#9]
000058  2a01              CMP      r2,#1
;;;285        {
;;;286          CANx->MCR |= CAN_MCR_NART;
;;;287        }
;;;288        else
;;;289        {
;;;290          CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
00005a  6802              LDR      r2,[r0,#0]
00005c  d030              BEQ      |L14.192|
00005e  f0220210          BIC      r2,r2,#0x10
                  |L14.98|
000062  6002              STR      r2,[r0,#0]
;;;291        }
;;;292    
;;;293        /* Set the receive FIFO locked mode */
;;;294        if (CAN_InitStruct->CAN_RFLM == ENABLE)
000064  7a8a              LDRB     r2,[r1,#0xa]
000066  2a01              CMP      r2,#1
;;;295        {
;;;296          CANx->MCR |= CAN_MCR_RFLM;
;;;297        }
;;;298        else
;;;299        {
;;;300          CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
000068  6802              LDR      r2,[r0,#0]
00006a  d02c              BEQ      |L14.198|
00006c  f0220208          BIC      r2,r2,#8
                  |L14.112|
000070  6002              STR      r2,[r0,#0]
;;;301        }
;;;302    
;;;303        /* Set the transmit FIFO priority */
;;;304        if (CAN_InitStruct->CAN_TXFP == ENABLE)
000072  7aca              LDRB     r2,[r1,#0xb]
000074  2a01              CMP      r2,#1
;;;305        {
;;;306          CANx->MCR |= CAN_MCR_TXFP;
;;;307        }
;;;308        else
;;;309        {
;;;310          CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
000076  6802              LDR      r2,[r0,#0]
000078  d028              BEQ      |L14.204|
00007a  f0220204          BIC      r2,r2,#4
                  |L14.126|
00007e  6002              STR      r2,[r0,#0]
;;;311        }
;;;312    
;;;313        /* Set the bit timing register */
;;;314        CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
000080  788a              LDRB     r2,[r1,#2]
000082  78cc              LDRB     r4,[r1,#3]
000084  0792              LSLS     r2,r2,#30
000086  ea426204          ORR      r2,r2,r4,LSL #24
00008a  790c              LDRB     r4,[r1,#4]
00008c  ea424204          ORR      r2,r2,r4,LSL #16
000090  794c              LDRB     r4,[r1,#5]
000092  8809              LDRH     r1,[r1,#0]
000094  ea425204          ORR      r2,r2,r4,LSL #20
000098  1e49              SUBS     r1,r1,#1
00009a  430a              ORRS     r2,r2,r1
00009c  61c2              STR      r2,[r0,#0x1c]
;;;315                    ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
;;;316                    ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
;;;317                    ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
;;;318                   ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
;;;319    
;;;320        /* Request leave initialisation */
;;;321        CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
00009e  6801              LDR      r1,[r0,#0]
0000a0  f0210101          BIC      r1,r1,#1
0000a4  6001              STR      r1,[r0,#0]
;;;322    
;;;323       /* Wait the acknowledge */
;;;324       wait_ack = 0;
0000a6  2100              MOVS     r1,#0
0000a8  e014              B        |L14.212|
                  |L14.170|
0000aa  2000              MOVS     r0,#0                 ;249
;;;325    
;;;326       while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
;;;327       {
;;;328         wait_ack++;
;;;329       }
;;;330    
;;;331        /* ...and check acknowledged */
;;;332        if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
;;;333        {
;;;334          InitStatus = CAN_InitStatus_Failed;
;;;335        }
;;;336        else
;;;337        {
;;;338          InitStatus = CAN_InitStatus_Success ;
;;;339        }
;;;340      }
;;;341    
;;;342      /* At this step, return the status of initialization */
;;;343      return InitStatus;
;;;344    }
0000ac  bd10              POP      {r4,pc}
                  |L14.174|
0000ae  f0420280          ORR      r2,r2,#0x80           ;256
0000b2  e7c1              B        |L14.56|
                  |L14.180|
0000b4  f0420240          ORR      r2,r2,#0x40           ;266
0000b8  e7c5              B        |L14.70|
                  |L14.186|
0000ba  f0420220          ORR      r2,r2,#0x20           ;276
0000be  e7c9              B        |L14.84|
                  |L14.192|
0000c0  f0420210          ORR      r2,r2,#0x10           ;286
0000c4  e7cd              B        |L14.98|
                  |L14.198|
0000c6  f0420208          ORR      r2,r2,#8              ;296
0000ca  e7d1              B        |L14.112|
                  |L14.204|
0000cc  f0420204          ORR      r2,r2,#4              ;306
0000d0  e7d5              B        |L14.126|
                  |L14.210|
0000d2  1c49              ADDS     r1,r1,#1              ;306
                  |L14.212|
0000d4  6842              LDR      r2,[r0,#4]            ;326
0000d6  07d2              LSLS     r2,r2,#31             ;326
0000d8  d001              BEQ      |L14.222|
0000da  4299              CMP      r1,r3                 ;326
0000dc  d1f9              BNE      |L14.210|
                  |L14.222|
0000de  6840              LDR      r0,[r0,#4]            ;332
0000e0  07c0              LSLS     r0,r0,#31             ;332
0000e2  d1e2              BNE      |L14.170|
0000e4  2001              MOVS     r0,#1                 ;338
0000e6  bd10              POP      {r4,pc}
;;;345    
                          ENDP


                          AREA ||i.CAN_MessagePending||, CODE, READONLY, ALIGN=1

                  CAN_MessagePending PROC
;;;967      */
;;;968    uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
000000  4602              MOV      r2,r0
;;;969    {
;;;970      uint8_t message_pending=0;
000002  2000              MOVS     r0,#0
000004  b129              CBZ      r1,|L15.18|
;;;971      /* Check the parameters */
;;;972      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;973      assert_param(IS_CAN_FIFO(FIFONumber));
;;;974      if (FIFONumber == CAN_FIFO0)
;;;975      {
;;;976        message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
;;;977      }
;;;978      else if (FIFONumber == CAN_FIFO1)
000006  2901              CMP      r1,#1
000008  d102              BNE      |L15.16|
;;;979      {
;;;980        message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
00000a  6910              LDR      r0,[r2,#0x10]
                  |L15.12|
00000c  f0000003          AND      r0,r0,#3              ;976
                  |L15.16|
;;;981      }
;;;982      else
;;;983      {
;;;984        message_pending = 0;
;;;985      }
;;;986      return message_pending;
;;;987    }
000010  4770              BX       lr
                  |L15.18|
000012  68d0              LDR      r0,[r2,#0xc]          ;976
000014  e7fa              B        |L15.12|
;;;988    /**
                          ENDP


                          AREA ||i.CAN_OperatingModeRequest||, CODE, READONLY, ALIGN=1

                  CAN_OperatingModeRequest PROC
;;;1017     */
;;;1018   uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)
000000  2300              MOVS     r3,#0
;;;1019   {
;;;1020     uint8_t status = CAN_ModeStatus_Failed;
;;;1021     
;;;1022     /* Timeout for INAK or also for SLAK bits*/
;;;1023     uint32_t timeout = INAK_TIMEOUT; 
000002  f64f72ff          MOV      r2,#0xffff
000006  b121              CBZ      r1,|L16.18|
;;;1024   
;;;1025     /* Check the parameters */
;;;1026     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1027     assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));
;;;1028   
;;;1029     if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
;;;1030     {
;;;1031       /* Request initialisation */
;;;1032       CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
;;;1033   
;;;1034       /* Wait the acknowledge */
;;;1035       while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
;;;1036       {
;;;1037         timeout--;
;;;1038       }
;;;1039       if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
;;;1040       {
;;;1041         status = CAN_ModeStatus_Failed;
;;;1042       }
;;;1043       else
;;;1044       {
;;;1045         status = CAN_ModeStatus_Success;
;;;1046       }
;;;1047     }
;;;1048     else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
000008  2901              CMP      r1,#1
00000a  d017              BEQ      |L16.60|
;;;1049     {
;;;1050       /* Request leave initialisation and sleep mode  and enter Normal mode */
;;;1051       CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
;;;1052   
;;;1053       /* Wait the acknowledge */
;;;1054       while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
;;;1055       {
;;;1056         timeout--;
;;;1057       }
;;;1058       if ((CANx->MSR & CAN_MODE_MASK) != 0)
;;;1059       {
;;;1060         status = CAN_ModeStatus_Failed;
;;;1061       }
;;;1062       else
;;;1063       {
;;;1064         status = CAN_ModeStatus_Success;
;;;1065       }
;;;1066     }
;;;1067     else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
00000c  2902              CMP      r1,#2
00000e  d024              BEQ      |L16.90|
000010  e03a              B        |L16.136|
                  |L16.18|
000012  6801              LDR      r1,[r0,#0]            ;1032
000014  f0210102          BIC      r1,r1,#2              ;1032
000018  f0410101          ORR      r1,r1,#1              ;1032
00001c  6001              STR      r1,[r0,#0]            ;1032
00001e  e000              B        |L16.34|
                  |L16.32|
000020  1e52              SUBS     r2,r2,#1              ;1035
                  |L16.34|
000022  6841              LDR      r1,[r0,#4]            ;1035
000024  f0010103          AND      r1,r1,#3              ;1035
000028  2901              CMP      r1,#1                 ;1035
00002a  d001              BEQ      |L16.48|
00002c  2a00              CMP      r2,#0                 ;1035
00002e  d1f7              BNE      |L16.32|
                  |L16.48|
000030  6840              LDR      r0,[r0,#4]            ;1039
000032  f0000003          AND      r0,r0,#3              ;1039
000036  2801              CMP      r0,#1                 ;1039
000038  d123              BNE      |L16.130|
00003a  e024              B        |L16.134|
                  |L16.60|
00003c  6801              LDR      r1,[r0,#0]            ;1051
00003e  f0210103          BIC      r1,r1,#3              ;1051
000042  6001              STR      r1,[r0,#0]            ;1051
000044  e000              B        |L16.72|
                  |L16.70|
000046  1e52              SUBS     r2,r2,#1              ;1054
                  |L16.72|
000048  6841              LDR      r1,[r0,#4]            ;1054
00004a  0789              LSLS     r1,r1,#30             ;1054
00004c  d001              BEQ      |L16.82|
00004e  2a00              CMP      r2,#0                 ;1054
000050  d1f9              BNE      |L16.70|
                  |L16.82|
000052  6840              LDR      r0,[r0,#4]            ;1058
000054  0780              LSLS     r0,r0,#30             ;1058
000056  d114              BNE      |L16.130|
000058  e015              B        |L16.134|
                  |L16.90|
;;;1068     {
;;;1069       /* Request Sleep mode */
;;;1070       CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
00005a  6801              LDR      r1,[r0,#0]
00005c  f0210101          BIC      r1,r1,#1
000060  f0410102          ORR      r1,r1,#2
000064  6001              STR      r1,[r0,#0]
;;;1071   
;;;1072       /* Wait the acknowledge */
;;;1073       while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
000066  e000              B        |L16.106|
                  |L16.104|
000068  1e52              SUBS     r2,r2,#1
                  |L16.106|
00006a  6841              LDR      r1,[r0,#4]
00006c  f0010103          AND      r1,r1,#3
000070  2902              CMP      r1,#2
000072  d001              BEQ      |L16.120|
000074  2a00              CMP      r2,#0
000076  d1f7              BNE      |L16.104|
                  |L16.120|
;;;1074       {
;;;1075         timeout--;
;;;1076       }
;;;1077       if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
000078  6840              LDR      r0,[r0,#4]
00007a  f0000003          AND      r0,r0,#3
00007e  2802              CMP      r0,#2
000080  d001              BEQ      |L16.134|
                  |L16.130|
;;;1078       {
;;;1079         status = CAN_ModeStatus_Failed;
000082  2300              MOVS     r3,#0
000084  e000              B        |L16.136|
                  |L16.134|
;;;1080       }
;;;1081       else
;;;1082       {
;;;1083         status = CAN_ModeStatus_Success;
000086  2301              MOVS     r3,#1
                  |L16.136|
;;;1084       }
;;;1085     }
;;;1086     else
;;;1087     {
;;;1088       status = CAN_ModeStatus_Failed;
;;;1089     }
;;;1090   
;;;1091     return  (uint8_t) status;
000088  4618              MOV      r0,r3
;;;1092   }
00008a  4770              BX       lr
;;;1093   
                          ENDP


                          AREA ||i.CAN_Receive||, CODE, READONLY, ALIGN=1

                  CAN_Receive PROC
;;;893      */
;;;894    void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
000000  b510              PUSH     {r4,lr}
;;;895    {
;;;896      /* Check the parameters */
;;;897      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;898      assert_param(IS_CAN_FIFO(FIFONumber));
;;;899      /* Get the Id */
;;;900      RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
000002  eb001301          ADD      r3,r0,r1,LSL #4
000006  f8d341b0          LDR      r4,[r3,#0x1b0]
00000a  f0140404          ANDS     r4,r4,#4
00000e  7214              STRB     r4,[r2,#8]
;;;901      if (RxMessage->IDE == CAN_Id_Standard)
;;;902      {
;;;903        RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
;;;904      }
;;;905      else
;;;906      {
;;;907        RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
000010  f8d341b0          LDR      r4,[r3,#0x1b0]
000014  d033              BEQ      |L17.126|
000016  08e4              LSRS     r4,r4,#3
000018  6054              STR      r4,[r2,#4]
                  |L17.26|
;;;908      }
;;;909      
;;;910      RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
00001a  f8d341b0          LDR      r4,[r3,#0x1b0]
00001e  f0040402          AND      r4,r4,#2
000022  7254              STRB     r4,[r2,#9]
;;;911      /* Get the DLC */
;;;912      RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
000024  f8d341b4          LDR      r4,[r3,#0x1b4]
000028  f004040f          AND      r4,r4,#0xf
00002c  7294              STRB     r4,[r2,#0xa]
;;;913      /* Get the FMI */
;;;914      RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
00002e  f8d341b4          LDR      r4,[r3,#0x1b4]
000032  0a24              LSRS     r4,r4,#8
000034  74d4              STRB     r4,[r2,#0x13]
;;;915      /* Get the data field */
;;;916      RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
000036  f8d341b8          LDR      r4,[r3,#0x1b8]
00003a  72d4              STRB     r4,[r2,#0xb]
;;;917      RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
00003c  f8d341b8          LDR      r4,[r3,#0x1b8]
000040  0a24              LSRS     r4,r4,#8
000042  7314              STRB     r4,[r2,#0xc]
;;;918      RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
000044  f8d341b8          LDR      r4,[r3,#0x1b8]
000048  0c24              LSRS     r4,r4,#16
00004a  7354              STRB     r4,[r2,#0xd]
;;;919      RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
00004c  f8d341b8          LDR      r4,[r3,#0x1b8]
000050  0e24              LSRS     r4,r4,#24
000052  7394              STRB     r4,[r2,#0xe]
;;;920      RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
000054  f8d341bc          LDR      r4,[r3,#0x1bc]
000058  73d4              STRB     r4,[r2,#0xf]
;;;921      RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
00005a  f8d341bc          LDR      r4,[r3,#0x1bc]
00005e  0a24              LSRS     r4,r4,#8
000060  7414              STRB     r4,[r2,#0x10]
;;;922      RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
000062  f8d341bc          LDR      r4,[r3,#0x1bc]
000066  0c24              LSRS     r4,r4,#16
000068  7454              STRB     r4,[r2,#0x11]
;;;923      RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
00006a  f8d331bc          LDR      r3,[r3,#0x1bc]
00006e  0e1b              LSRS     r3,r3,#24
000070  7493              STRB     r3,[r2,#0x12]
;;;924      /* Release the FIFO */
;;;925      /* Release FIFO0 */
;;;926      if (FIFONumber == CAN_FIFO0)
000072  b139              CBZ      r1,|L17.132|
;;;927      {
;;;928        CANx->RF0R |= CAN_RF0R_RFOM0;
;;;929      }
;;;930      /* Release FIFO1 */
;;;931      else /* FIFONumber == CAN_FIFO1 */
;;;932      {
;;;933        CANx->RF1R |= CAN_RF1R_RFOM1;
000074  6901              LDR      r1,[r0,#0x10]
000076  f0410120          ORR      r1,r1,#0x20
00007a  6101              STR      r1,[r0,#0x10]
;;;934      }
;;;935    }
00007c  bd10              POP      {r4,pc}
                  |L17.126|
00007e  0d64              LSRS     r4,r4,#21             ;903
000080  6014              STR      r4,[r2,#0]            ;903
000082  e7ca              B        |L17.26|
                  |L17.132|
000084  68c1              LDR      r1,[r0,#0xc]          ;928
000086  f0410120          ORR      r1,r1,#0x20           ;928
00008a  60c1              STR      r1,[r0,#0xc]          ;928
00008c  bd10              POP      {r4,pc}
;;;936    
                          ENDP


                          AREA ||i.CAN_SlaveStartBank||, CODE, READONLY, ALIGN=2

                  CAN_SlaveStartBank PROC
;;;605      */
;;;606    void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
000000  4909              LDR      r1,|L18.40|
;;;607    {
;;;608      /* Check the parameters */
;;;609      assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
;;;610      
;;;611      /* Enter Initialisation mode for the filter */
;;;612      CAN1->FMR |= FMR_FINIT;
000002  680a              LDR      r2,[r1,#0]
000004  f0420201          ORR      r2,r2,#1
000008  600a              STR      r2,[r1,#0]
;;;613      
;;;614      /* Select the start slave bank */
;;;615      CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
00000a  680a              LDR      r2,[r1,#0]
00000c  f643730e          MOV      r3,#0x3f0e
000010  439a              BICS     r2,r2,r3
000012  600a              STR      r2,[r1,#0]
;;;616      CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
000014  680a              LDR      r2,[r1,#0]
000016  ea422000          ORR      r0,r2,r0,LSL #8
00001a  6008              STR      r0,[r1,#0]
;;;617      
;;;618      /* Leave Initialisation mode for the filter */
;;;619      CAN1->FMR &= ~FMR_FINIT;
00001c  6808              LDR      r0,[r1,#0]
00001e  f0200001          BIC      r0,r0,#1
000022  6008              STR      r0,[r1,#0]
;;;620    }
000024  4770              BX       lr
;;;621    #endif /* STM32F413_423xx */
                          ENDP

000026  0000              DCW      0x0000
                  |L18.40|
                          DCD      0x40006600

                          AREA ||i.CAN_Sleep||, CODE, READONLY, ALIGN=1

                  CAN_Sleep PROC
;;;1099     */
;;;1100   uint8_t CAN_Sleep(CAN_TypeDef* CANx)
000000  6802              LDR      r2,[r0,#0]
;;;1101   {
;;;1102     uint8_t sleepstatus = CAN_Sleep_Failed;
000002  2100              MOVS     r1,#0
;;;1103     
;;;1104     /* Check the parameters */
;;;1105     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1106       
;;;1107     /* Request Sleep mode */
;;;1108      CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
000004  f0220201          BIC      r2,r2,#1
000008  f0420202          ORR      r2,r2,#2
00000c  6002              STR      r2,[r0,#0]
;;;1109      
;;;1110     /* Sleep mode status */
;;;1111     if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
00000e  6840              LDR      r0,[r0,#4]
000010  f0000003          AND      r0,r0,#3
000014  2802              CMP      r0,#2
000016  d100              BNE      |L19.26|
;;;1112     {
;;;1113       /* Sleep mode not entered */
;;;1114       sleepstatus =  CAN_Sleep_Ok;
000018  2101              MOVS     r1,#1
                  |L19.26|
;;;1115     }
;;;1116     /* return sleep mode status */
;;;1117      return (uint8_t)sleepstatus;
00001a  4608              MOV      r0,r1
;;;1118   }
00001c  4770              BX       lr
;;;1119   
                          ENDP


                          AREA ||i.CAN_StructInit||, CODE, READONLY, ALIGN=1

                  CAN_StructInit PROC
;;;539      */
;;;540    void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
000000  2100              MOVS     r1,#0
;;;541    {
;;;542      /* Reset CAN init structure parameters values */
;;;543      
;;;544      /* Initialize the time triggered communication mode */
;;;545      CAN_InitStruct->CAN_TTCM = DISABLE;
000002  7181              STRB     r1,[r0,#6]
;;;546      
;;;547      /* Initialize the automatic bus-off management */
;;;548      CAN_InitStruct->CAN_ABOM = DISABLE;
000004  71c1              STRB     r1,[r0,#7]
;;;549      
;;;550      /* Initialize the automatic wake-up mode */
;;;551      CAN_InitStruct->CAN_AWUM = DISABLE;
000006  7201              STRB     r1,[r0,#8]
;;;552      
;;;553      /* Initialize the no automatic retransmission */
;;;554      CAN_InitStruct->CAN_NART = DISABLE;
000008  7241              STRB     r1,[r0,#9]
;;;555      
;;;556      /* Initialize the receive FIFO locked mode */
;;;557      CAN_InitStruct->CAN_RFLM = DISABLE;
00000a  7281              STRB     r1,[r0,#0xa]
;;;558      
;;;559      /* Initialize the transmit FIFO priority */
;;;560      CAN_InitStruct->CAN_TXFP = DISABLE;
00000c  72c1              STRB     r1,[r0,#0xb]
;;;561      
;;;562      /* Initialize the CAN_Mode member */
;;;563      CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
00000e  7081              STRB     r1,[r0,#2]
;;;564      
;;;565      /* Initialize the CAN_SJW member */
;;;566      CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
000010  70c1              STRB     r1,[r0,#3]
;;;567      
;;;568      /* Initialize the CAN_BS1 member */
;;;569      CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
000012  2103              MOVS     r1,#3
000014  7101              STRB     r1,[r0,#4]
;;;570      
;;;571      /* Initialize the CAN_BS2 member */
;;;572      CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
000016  2102              MOVS     r1,#2
000018  7141              STRB     r1,[r0,#5]
;;;573      
;;;574      /* Initialize the CAN_Prescaler member */
;;;575      CAN_InitStruct->CAN_Prescaler = 1;
00001a  2101              MOVS     r1,#1
00001c  8001              STRH     r1,[r0,#0]
;;;576    }
00001e  4770              BX       lr
;;;577    
                          ENDP


                          AREA ||i.CAN_TTComModeCmd||, CODE, READONLY, ALIGN=1

                  CAN_TTComModeCmd PROC
;;;662      */
;;;663    void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;664    {
;;;665      /* Check the parameters */
;;;666      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;667      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;668      if (NewState != DISABLE)
;;;669      {
;;;670        /* Enable the TTCM mode */
;;;671        CANx->MCR |= CAN_MCR_TTCM;
;;;672    
;;;673        /* Set TGT bits */
;;;674        CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
;;;675        CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
;;;676        CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
;;;677      }
;;;678      else
;;;679      {
;;;680        /* Disable the TTCM mode */
;;;681        CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
000002  6801              LDR      r1,[r0,#0]
000004  d013              BEQ      |L21.46|
000006  f0410180          ORR      r1,r1,#0x80           ;671
00000a  6001              STR      r1,[r0,#0]            ;671
00000c  f8d01184          LDR      r1,[r0,#0x184]        ;674
000010  f4417180          ORR      r1,r1,#0x100          ;674
000014  f8c01184          STR      r1,[r0,#0x184]        ;674
000018  f8d01194          LDR      r1,[r0,#0x194]        ;675
00001c  f4417180          ORR      r1,r1,#0x100          ;675
000020  f8c01194          STR      r1,[r0,#0x194]        ;675
000024  f8d011a4          LDR      r1,[r0,#0x1a4]        ;676
000028  f4417180          ORR      r1,r1,#0x100          ;676
00002c  e012              B        |L21.84|
                  |L21.46|
00002e  f0210180          BIC      r1,r1,#0x80
000032  6001              STR      r1,[r0,#0]
;;;682    
;;;683        /* Reset TGT bits */
;;;684        CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
000034  f8d01184          LDR      r1,[r0,#0x184]
000038  f4217180          BIC      r1,r1,#0x100
00003c  f8c01184          STR      r1,[r0,#0x184]
;;;685        CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
000040  f8d01194          LDR      r1,[r0,#0x194]
000044  f4217180          BIC      r1,r1,#0x100
000048  f8c01194          STR      r1,[r0,#0x194]
;;;686        CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
00004c  f8d011a4          LDR      r1,[r0,#0x1a4]
000050  f4217180          BIC      r1,r1,#0x100
                  |L21.84|
000054  f8c011a4          STR      r1,[r0,#0x1a4]        ;676
;;;687      }
;;;688    }
000058  4770              BX       lr
;;;689    /**
                          ENDP


                          AREA ||i.CAN_Transmit||, CODE, READONLY, ALIGN=1

                  CAN_Transmit PROC
;;;717      */
;;;718    uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
000000  b530              PUSH     {r4,r5,lr}
;;;719    {
000002  4602              MOV      r2,r0
;;;720      uint8_t transmit_mailbox = 0;
000004  2000              MOVS     r0,#0
;;;721      /* Check the parameters */
;;;722      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;723      assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
;;;724      assert_param(IS_CAN_RTR(TxMessage->RTR));
;;;725      assert_param(IS_CAN_DLC(TxMessage->DLC));
;;;726    
;;;727      /* Select one empty transmit mailbox */
;;;728      if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
000006  6893              LDR      r3,[r2,#8]
000008  015b              LSLS     r3,r3,#5
00000a  d408              BMI      |L22.30|
;;;729      {
;;;730        transmit_mailbox = 0;
;;;731      }
;;;732      else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
00000c  6890              LDR      r0,[r2,#8]
00000e  0100              LSLS     r0,r0,#4
000010  d501              BPL      |L22.22|
;;;733      {
;;;734        transmit_mailbox = 1;
000012  2001              MOVS     r0,#1
000014  e003              B        |L22.30|
                  |L22.22|
;;;735      }
;;;736      else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
000016  6890              LDR      r0,[r2,#8]
000018  00c0              LSLS     r0,r0,#3
00001a  d537              BPL      |L22.140|
;;;737      {
;;;738        transmit_mailbox = 2;
00001c  2002              MOVS     r0,#2
                  |L22.30|
;;;739      }
;;;740      else
;;;741      {
;;;742        transmit_mailbox = CAN_TxStatus_NoMailBox;
;;;743      }
;;;744    
;;;745      if (transmit_mailbox != CAN_TxStatus_NoMailBox)
;;;746      {
;;;747        /* Set up the Id */
;;;748        CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
00001e  eb021200          ADD      r2,r2,r0,LSL #4
000022  f8d23180          LDR      r3,[r2,#0x180]
000026  f0030301          AND      r3,r3,#1
00002a  f8c23180          STR      r3,[r2,#0x180]
;;;749        if (TxMessage->IDE == CAN_Id_Standard)
00002e  7a0b              LDRB     r3,[r1,#8]
000030  b373              CBZ      r3,|L22.144|
;;;750        {
;;;751          assert_param(IS_CAN_STDID(TxMessage->StdId));  
;;;752          CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
;;;753                                                      TxMessage->RTR);
;;;754        }
;;;755        else
;;;756        {
;;;757          assert_param(IS_CAN_EXTID(TxMessage->ExtId));
;;;758          CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
000032  f8d24180          LDR      r4,[r2,#0x180]
000036  684d              LDR      r5,[r1,#4]
000038  431c              ORRS     r4,r4,r3
00003a  7a4b              LDRB     r3,[r1,#9]
00003c  ea4303c5          ORR      r3,r3,r5,LSL #3
000040  431c              ORRS     r4,r4,r3
000042  f8c24180          STR      r4,[r2,#0x180]
                  |L22.70|
;;;759                                                      TxMessage->IDE | \
;;;760                                                      TxMessage->RTR);
;;;761        }
;;;762        
;;;763        /* Set up the DLC */
;;;764        TxMessage->DLC &= (uint8_t)0x0000000F;
000046  7a8b              LDRB     r3,[r1,#0xa]
000048  f003030f          AND      r3,r3,#0xf
00004c  728b              STRB     r3,[r1,#0xa]
;;;765        CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
00004e  f8d23184          LDR      r3,[r2,#0x184]
000052  f023030f          BIC      r3,r3,#0xf
000056  f8c23184          STR      r3,[r2,#0x184]
;;;766        CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
00005a  f8d23184          LDR      r3,[r2,#0x184]
00005e  7a8c              LDRB     r4,[r1,#0xa]
000060  4323              ORRS     r3,r3,r4
000062  f8c23184          STR      r3,[r2,#0x184]
;;;767    
;;;768        /* Set up the data field */
;;;769        CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
000066  7acb              LDRB     r3,[r1,#0xb]
000068  68cc              LDR      r4,[r1,#0xc]
00006a  ea432304          ORR      r3,r3,r4,LSL #8
00006e  f8c23188          STR      r3,[r2,#0x188]
;;;770                                                 ((uint32_t)TxMessage->Data[2] << 16) |
;;;771                                                 ((uint32_t)TxMessage->Data[1] << 8) | 
;;;772                                                 ((uint32_t)TxMessage->Data[0]));
;;;773        CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
000072  7bcb              LDRB     r3,[r1,#0xf]
000074  6909              LDR      r1,[r1,#0x10]
000076  ea432101          ORR      r1,r3,r1,LSL #8
00007a  f8c2118c          STR      r1,[r2,#0x18c]
;;;774                                                 ((uint32_t)TxMessage->Data[6] << 16) |
;;;775                                                 ((uint32_t)TxMessage->Data[5] << 8) |
;;;776                                                 ((uint32_t)TxMessage->Data[4]));
;;;777        /* Request transmission */
;;;778        CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
00007e  f8d21180          LDR      r1,[r2,#0x180]
000082  f0410101          ORR      r1,r1,#1
000086  f8c21180          STR      r1,[r2,#0x180]
;;;779      }
;;;780      return transmit_mailbox;
;;;781    }
00008a  bd30              POP      {r4,r5,pc}
                  |L22.140|
00008c  2004              MOVS     r0,#4                 ;742
00008e  bd30              POP      {r4,r5,pc}
                  |L22.144|
000090  f8d23180          LDR      r3,[r2,#0x180]        ;752
000094  7a4c              LDRB     r4,[r1,#9]            ;752
000096  4323              ORRS     r3,r3,r4              ;752
000098  880c              LDRH     r4,[r1,#0]            ;752
00009a  ea435344          ORR      r3,r3,r4,LSL #21      ;752
00009e  f8c23180          STR      r3,[r2,#0x180]        ;752
0000a2  e7d0              B        |L22.70|
;;;782    
                          ENDP


                          AREA ||i.CAN_TransmitStatus||, CODE, READONLY, ALIGN=2

                  CAN_TransmitStatus PROC
;;;790      */
;;;791    uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
000000  2200              MOVS     r2,#0
;;;792    {
000002  b121              CBZ      r1,|L23.14|
;;;793      uint32_t state = 0;
;;;794    
;;;795      /* Check the parameters */
;;;796      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;797      assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
;;;798     
;;;799      switch (TransmitMailbox)
000004  2901              CMP      r1,#1
000006  d005              BEQ      |L23.20|
000008  2902              CMP      r1,#2
00000a  d106              BNE      |L23.26|
00000c  e012              B        |L23.52|
                  |L23.14|
;;;800      {
;;;801        case (CAN_TXMAILBOX_0): 
;;;802          state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
00000e  6882              LDR      r2,[r0,#8]
000010  4811              LDR      r0,|L23.88|
;;;803          break;
000012  e001              B        |L23.24|
                  |L23.20|
;;;804        case (CAN_TXMAILBOX_1): 
;;;805          state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
000014  6882              LDR      r2,[r0,#8]
000016  4811              LDR      r0,|L23.92|
                  |L23.24|
000018  4002              ANDS     r2,r2,r0              ;802
                  |L23.26|
;;;806          break;
;;;807        case (CAN_TXMAILBOX_2): 
;;;808          state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
;;;809          break;
;;;810        default:
;;;811          state = CAN_TxStatus_Failed;
;;;812          break;
;;;813      }
;;;814      switch (state)
00001a  4911              LDR      r1,|L23.96|
00001c  1a50              SUBS     r0,r2,r1
00001e  428a              CMP      r2,r1
000020  d014              BEQ      |L23.76|
000022  dc0a              BGT      |L23.58|
000024  b1a2              CBZ      r2,|L23.80|
000026  f06f6080          MVN      r0,#0x4000000
00002a  1810              ADDS     r0,r2,r0
00002c  d00f              BEQ      |L23.78|
00002e  2802              CMP      r0,#2
000030  d10c              BNE      |L23.76|
000032  e00f              B        |L23.84|
                  |L23.52|
000034  6882              LDR      r2,[r0,#8]            ;808
000036  480b              LDR      r0,|L23.100|
000038  e7ee              B        |L23.24|
                  |L23.58|
00003a  f5b07f00          CMP      r0,#0x200
00003e  d009              BEQ      |L23.84|
000040  4909              LDR      r1,|L23.104|
000042  1840              ADDS     r0,r0,r1
000044  d003              BEQ      |L23.78|
000046  f5b03f00          CMP      r0,#0x20000
00004a  d003              BEQ      |L23.84|
                  |L23.76|
;;;815      {
;;;816          /* transmit pending  */
;;;817        case (0x0): state = CAN_TxStatus_Pending;
;;;818          break;
;;;819          /* transmit failed  */
;;;820         case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
;;;821          break;
;;;822         case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
;;;823          break;
;;;824         case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
;;;825          break;
;;;826          /* transmit succeeded  */
;;;827        case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
;;;828          break;
;;;829        case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
;;;830          break;
;;;831        case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
;;;832          break;
;;;833        default: state = CAN_TxStatus_Failed;
00004c  2000              MOVS     r0,#0
                  |L23.78|
;;;834          break;
;;;835      }
;;;836      return (uint8_t) state;
;;;837    }
00004e  4770              BX       lr
                  |L23.80|
000050  2002              MOVS     r0,#2                 ;817
000052  4770              BX       lr
                  |L23.84|
000054  2001              MOVS     r0,#1                 ;831
000056  4770              BX       lr
;;;838    
                          ENDP

                  |L23.88|
                          DCD      0x04000003
                  |L23.92|
                          DCD      0x08000300
                  |L23.96|
                          DCD      0x08000100
                  |L23.100|
                          DCD      0x10030000
                  |L23.104|
                          DCD      0xf7ff0100

                          AREA ||i.CAN_WakeUp||, CODE, READONLY, ALIGN=1

                  CAN_WakeUp PROC
;;;1125     */
;;;1126   uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
000000  6802              LDR      r2,[r0,#0]
;;;1127   {
;;;1128     uint32_t wait_slak = SLAK_TIMEOUT;
000002  f64f71ff          MOV      r1,#0xffff
;;;1129     uint8_t wakeupstatus = CAN_WakeUp_Failed;
000006  2300              MOVS     r3,#0
;;;1130     
;;;1131     /* Check the parameters */
;;;1132     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1133       
;;;1134     /* Wake up request */
;;;1135     CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
000008  f0220202          BIC      r2,r2,#2
00000c  6002              STR      r2,[r0,#0]
00000e  e000              B        |L24.18|
                  |L24.16|
000010  1e49              SUBS     r1,r1,#1              ;1127
                  |L24.18|
;;;1136       
;;;1137     /* Sleep mode status */
;;;1138     while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
000012  6842              LDR      r2,[r0,#4]
000014  0792              LSLS     r2,r2,#30
000016  d501              BPL      |L24.28|
000018  2900              CMP      r1,#0
00001a  d1f9              BNE      |L24.16|
                  |L24.28|
;;;1139     {
;;;1140      wait_slak--;
;;;1141     }
;;;1142     if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
00001c  6840              LDR      r0,[r0,#4]
00001e  0780              LSLS     r0,r0,#30
000020  d400              BMI      |L24.36|
;;;1143     {
;;;1144      /* wake up done : Sleep mode exited */
;;;1145       wakeupstatus = CAN_WakeUp_Ok;
000022  2301              MOVS     r3,#1
                  |L24.36|
;;;1146     }
;;;1147     /* return wakeup status */
;;;1148     return (uint8_t)wakeupstatus;
000024  4618              MOV      r0,r3
;;;1149   }
000026  4770              BX       lr
;;;1150   /**
                          ENDP


                          AREA ||i.CheckITStatus||, CODE, READONLY, ALIGN=1

                  CheckITStatus PROC
;;;1826     */
;;;1827   static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
000000  4602              MOV      r2,r0
;;;1828   {
;;;1829     ITStatus pendingbitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1830     
;;;1831     if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
000004  420a              TST      r2,r1
000006  d000              BEQ      |L25.10|
;;;1832     {
;;;1833       /* CAN_IT is set */
;;;1834       pendingbitstatus = SET;
000008  2001              MOVS     r0,#1
                  |L25.10|
;;;1835     }
;;;1836     else
;;;1837     {
;;;1838       /* CAN_IT is reset */
;;;1839       pendingbitstatus = RESET;
;;;1840     }
;;;1841     return pendingbitstatus;
;;;1842   }
00000a  4770              BX       lr
;;;1843   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_can.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_can_c_347dae01____REV16|
#line 138 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_can_c_347dae01____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_can_c_347dae01____REVSH|
#line 153
|__asm___15_stm32f4xx_can_c_347dae01____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_can_c_347dae01____RRX|
#line 328
|__asm___15_stm32f4xx_can_c_347dae01____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

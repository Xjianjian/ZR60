; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\stm32f4xx_fsmc.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\stm32f4xx_fsmc.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\ZR60_v1.0_freeRTOS -I..\..\Lwip\App -I..\..\Lwip\Bsp -I..\..\Lwip\Bsp\LAN8742A -I..\..\Lwip\lwip-1.4.1 -I..\..\Lwip\lwip-1.4.1\port -I..\..\Lwip\lwip-1.4.1\port\arch -I..\..\Lwip\lwip-1.4.1\port\Standalone -I..\..\Lwip\lwip-1.4.1\src\include -I..\..\Lwip\lwip-1.4.1\src\include\ipv4 -I..\..\Lwip\lwip-1.4.1\src\include\lwip -I..\..\Lwip\lwip-1.4.1\src\include\netif -I..\..\Ecal\BtnFltr -I..\..\Ecal\UartComn -I..\..\Ecal\MemIf -I..\..\APP -I..\..\APP\BlackListMng -I..\..\APP\SeverNewsPush -I..\..\APP\NewsPull -I..\..\Ecal -I..\..\Ecal\JsonIf -I..\..\Ecal\Mcu_Init -I..\..\Service -I..\..\Complex -I..\..\Complex\FATFS -I..\..\FreeRTOS\Source\include -I..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\FreeRTOS -I.\RTE\_ZR60 -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=..\..\output\stm32f4xx_fsmc.crf ..\..\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_fsmc.c]
                          THUMB

                          AREA ||i.FSMC_ClearFlag||, CODE, READONLY, ALIGN=1

                  FSMC_ClearFlag PROC
;;;976      */
;;;977    void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
000000  f04f4220          MOV      r2,#0xa0000000
;;;978    {
;;;979     /* Check the parameters */
;;;980      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;981      assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
;;;982        
;;;983      if(FSMC_Bank == FSMC_Bank2_NAND)
000004  2810              CMP      r0,#0x10
000006  d007              BEQ      |L1.24|
;;;984      {
;;;985        FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
;;;986      }  
;;;987      else if(FSMC_Bank == FSMC_Bank3_NAND)
000008  f5b07f80          CMP      r0,#0x100
00000c  d008              BEQ      |L1.32|
;;;988      {
;;;989        FSMC_Bank3->SR3 &= ~FSMC_FLAG;
;;;990      }
;;;991      /* FSMC_Bank4_PCCARD*/
;;;992      else
;;;993      {
;;;994        FSMC_Bank4->SR4 &= ~FSMC_FLAG;
00000e  f8520fa4          LDR      r0,[r2,#0xa4]!
                  |L1.18|
000012  4388              BICS     r0,r0,r1
000014  6010              STR      r0,[r2,#0]
;;;995      }
;;;996    }
000016  4770              BX       lr
                  |L1.24|
000018  6e50              LDR      r0,[r2,#0x64]         ;985
00001a  4388              BICS     r0,r0,r1              ;985
00001c  6650              STR      r0,[r2,#0x64]         ;985
00001e  4770              BX       lr
                  |L1.32|
000020  f8520f84          LDR      r0,[r2,#0x84]!        ;989
000024  e7f5              B        |L1.18|
;;;997    
                          ENDP


                          AREA ||i.FSMC_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  FSMC_ClearITPendingBit PROC
;;;1062     */
;;;1063   void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT)
000000  f04f4220          MOV      r2,#0xa0000000
;;;1064   {
;;;1065     /* Check the parameters */
;;;1066     assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;1067     assert_param(IS_FSMC_IT(FSMC_IT));
;;;1068       
;;;1069     if(FSMC_Bank == FSMC_Bank2_NAND)
000004  2810              CMP      r0,#0x10
000006  d008              BEQ      |L2.26|
;;;1070     {
;;;1071       FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
;;;1072     }  
;;;1073     else if(FSMC_Bank == FSMC_Bank3_NAND)
000008  f5b07f80          CMP      r0,#0x100
00000c  d00a              BEQ      |L2.36|
;;;1074     {
;;;1075       FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
;;;1076     }
;;;1077     /* FSMC_Bank4_PCCARD*/
;;;1078     else
;;;1079     {
;;;1080       FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
00000e  f8520fa4          LDR      r0,[r2,#0xa4]!
                  |L2.18|
000012  ea2000d1          BIC      r0,r0,r1,LSR #3
000016  6010              STR      r0,[r2,#0]
;;;1081     }
;;;1082   }
000018  4770              BX       lr
                  |L2.26|
00001a  6e50              LDR      r0,[r2,#0x64]         ;1071
00001c  ea2000d1          BIC      r0,r0,r1,LSR #3       ;1071
000020  6650              STR      r0,[r2,#0x64]         ;1071
000022  4770              BX       lr
                  |L2.36|
000024  f8520f84          LDR      r0,[r2,#0x84]!        ;1075
000028  e7f3              B        |L2.18|
;;;1083   
                          ENDP


                          AREA ||i.FSMC_GetECC||, CODE, READONLY, ALIGN=1

                  FSMC_GetECC PROC
;;;622      */
;;;623    uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
000000  f04f4120          MOV      r1,#0xa0000000
;;;624    {
;;;625      uint32_t eccval = 0x00000000;
;;;626      
;;;627      if(FSMC_Bank == FSMC_Bank2_NAND)
000004  2810              CMP      r0,#0x10
000006  d002              BEQ      |L3.14|
;;;628      {
;;;629        /* Get the ECCR2 register value */
;;;630        eccval = FSMC_Bank2->ECCR2;
;;;631      }
;;;632      else
;;;633      {
;;;634        /* Get the ECCR3 register value */
;;;635        eccval = FSMC_Bank3->ECCR3;
000008  f8d10094          LDR      r0,[r1,#0x94]
;;;636      }
;;;637      /* Return the error correction code value */
;;;638      return(eccval);
;;;639    }
00000c  4770              BX       lr
                  |L3.14|
00000e  6f48              LDR      r0,[r1,#0x74]         ;630
000010  4770              BX       lr
;;;640    /**
                          ENDP


                          AREA ||i.FSMC_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  FSMC_GetFlagStatus PROC
;;;926      */
;;;927    FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
000000  4603              MOV      r3,r0
;;;928    {
;;;929      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;930      uint32_t tmpsr = 0x00000000;
;;;931      
;;;932      /* Check the parameters */
;;;933      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;934      assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
;;;935      
;;;936      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;937      {
;;;938        tmpsr = FSMC_Bank2->SR2;
000004  f04f4220          MOV      r2,#0xa0000000
000008  2b10              CMP      r3,#0x10              ;936
00000a  d008              BEQ      |L4.30|
;;;939      }  
;;;940      else if(FSMC_Bank == FSMC_Bank3_NAND)
00000c  f5b37f80          CMP      r3,#0x100
000010  d007              BEQ      |L4.34|
;;;941      {
;;;942        tmpsr = FSMC_Bank3->SR3;
;;;943      }
;;;944      /* FSMC_Bank4_PCCARD*/
;;;945      else
;;;946      {
;;;947        tmpsr = FSMC_Bank4->SR4;
000012  f8d220a4          LDR      r2,[r2,#0xa4]
                  |L4.22|
;;;948      } 
;;;949      
;;;950      /* Get the flag status */
;;;951      if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )
000016  420a              TST      r2,r1
000018  d000              BEQ      |L4.28|
;;;952      {
;;;953        bitstatus = SET;
00001a  2001              MOVS     r0,#1
                  |L4.28|
;;;954      }
;;;955      else
;;;956      {
;;;957        bitstatus = RESET;
;;;958      }
;;;959      /* Return the flag status */
;;;960      return bitstatus;
;;;961    }
00001c  4770              BX       lr
                  |L4.30|
00001e  6e52              LDR      r2,[r2,#0x64]         ;938
000020  e7f9              B        |L4.22|
                  |L4.34|
000022  f8d22084          LDR      r2,[r2,#0x84]         ;942
000026  e7f6              B        |L4.22|
;;;962    
                          ENDP


                          AREA ||i.FSMC_GetITStatus||, CODE, READONLY, ALIGN=1

                  FSMC_GetITStatus PROC
;;;1011     */
;;;1012   ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)
000000  4603              MOV      r3,r0
;;;1013   {
;;;1014     ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1015     uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
;;;1016     
;;;1017     /* Check the parameters */
;;;1018     assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;1019     assert_param(IS_FSMC_GET_IT(FSMC_IT));
;;;1020     
;;;1021     if(FSMC_Bank == FSMC_Bank2_NAND)
;;;1022     {
;;;1023       tmpsr = FSMC_Bank2->SR2;
000004  f04f4220          MOV      r2,#0xa0000000
000008  2b10              CMP      r3,#0x10              ;1021
00000a  d00c              BEQ      |L5.38|
;;;1024     }  
;;;1025     else if(FSMC_Bank == FSMC_Bank3_NAND)
00000c  f5b37f80          CMP      r3,#0x100
000010  d00b              BEQ      |L5.42|
;;;1026     {
;;;1027       tmpsr = FSMC_Bank3->SR3;
;;;1028     }
;;;1029     /* FSMC_Bank4_PCCARD*/
;;;1030     else
;;;1031     {
;;;1032       tmpsr = FSMC_Bank4->SR4;
000012  f8d220a4          LDR      r2,[r2,#0xa4]
                  |L5.22|
;;;1033     } 
;;;1034     
;;;1035     itstatus = tmpsr & FSMC_IT;
000016  420a              TST      r2,r1
;;;1036     
;;;1037     itenable = tmpsr & (FSMC_IT >> 3);
000018  ea0201d1          AND      r1,r2,r1,LSR #3
;;;1038     if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
00001c  d002              BEQ      |L5.36|
00001e  2900              CMP      r1,#0
000020  d000              BEQ      |L5.36|
;;;1039     {
;;;1040       bitstatus = SET;
000022  2001              MOVS     r0,#1
                  |L5.36|
;;;1041     }
;;;1042     else
;;;1043     {
;;;1044       bitstatus = RESET;
;;;1045     }
;;;1046     return bitstatus; 
;;;1047   }
000024  4770              BX       lr
                  |L5.38|
000026  6e52              LDR      r2,[r2,#0x64]         ;1023
000028  e7f5              B        |L5.22|
                  |L5.42|
00002a  f8d22084          LDR      r2,[r2,#0x84]         ;1027
00002e  e7f2              B        |L5.22|
;;;1048   
                          ENDP


                          AREA ||i.FSMC_ITConfig||, CODE, READONLY, ALIGN=1

                  FSMC_ITConfig PROC
;;;866      */
;;;867    void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;868    {
;;;869      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;870      assert_param(IS_FSMC_IT(FSMC_IT));	
;;;871      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;872      
;;;873      if (NewState != DISABLE)
;;;874      {
;;;875        /* Enable the selected FSMC_Bank2 interrupts */
;;;876        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;877        {
;;;878          FSMC_Bank2->SR2 |= FSMC_IT;
;;;879        }
;;;880        /* Enable the selected FSMC_Bank3 interrupts */
;;;881        else if (FSMC_Bank == FSMC_Bank3_NAND)
000002  f44f7480          MOV      r4,#0x100
000006  f04f4320          MOV      r3,#0xa0000000        ;878
00000a  b172              CBZ      r2,|L6.42|
00000c  2810              CMP      r0,#0x10              ;876
00000e  d004              BEQ      |L6.26|
000010  42a0              CMP      r0,r4
000012  d105              BNE      |L6.32|
;;;882        {
;;;883          FSMC_Bank3->SR3 |= FSMC_IT;
000014  f8530f84          LDR      r0,[r3,#0x84]!
000018  e004              B        |L6.36|
                  |L6.26|
00001a  6e58              LDR      r0,[r3,#0x64]         ;878
00001c  4308              ORRS     r0,r0,r1              ;878
00001e  e00d              B        |L6.60|
                  |L6.32|
;;;884        }
;;;885        /* Enable the selected FSMC_Bank4 interrupts */
;;;886        else
;;;887        {
;;;888          FSMC_Bank4->SR4 |= FSMC_IT;    
000020  f8530fa4          LDR      r0,[r3,#0xa4]!
                  |L6.36|
000024  4308              ORRS     r0,r0,r1
                  |L6.38|
000026  6018              STR      r0,[r3,#0]
;;;889        }
;;;890      }
;;;891      else
;;;892      {
;;;893        /* Disable the selected FSMC_Bank2 interrupts */
;;;894        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;895        {
;;;896          
;;;897          FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
;;;898        }
;;;899        /* Disable the selected FSMC_Bank3 interrupts */
;;;900        else if (FSMC_Bank == FSMC_Bank3_NAND)
;;;901        {
;;;902          FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
;;;903        }
;;;904        /* Disable the selected FSMC_Bank4 interrupts */
;;;905        else
;;;906        {
;;;907          FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
;;;908        }
;;;909      }
;;;910    }
000028  bd10              POP      {r4,pc}
                  |L6.42|
00002a  2810              CMP      r0,#0x10              ;894
00002c  d004              BEQ      |L6.56|
00002e  42a0              CMP      r0,r4                 ;900
000030  d106              BNE      |L6.64|
000032  f8530f84          LDR      r0,[r3,#0x84]!        ;902
000036  e005              B        |L6.68|
                  |L6.56|
000038  6e58              LDR      r0,[r3,#0x64]         ;897
00003a  4388              BICS     r0,r0,r1              ;897
                  |L6.60|
00003c  6658              STR      r0,[r3,#0x64]         ;878
00003e  bd10              POP      {r4,pc}
                  |L6.64|
000040  f8530fa4          LDR      r0,[r3,#0xa4]!        ;907
                  |L6.68|
000044  4388              BICS     r0,r0,r1              ;902
000046  e7ee              B        |L6.38|
;;;911    
                          ENDP


                          AREA ||i.FSMC_NANDCmd||, CODE, READONLY, ALIGN=2

                  FSMC_NANDCmd PROC
;;;543      */
;;;544    void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000000  f04f4220          MOV      r2,#0xa0000000
;;;545    {
000004  b151              CBZ      r1,|L7.28|
;;;546      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;547      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;548      
;;;549      if (NewState != DISABLE)
;;;550      {
;;;551        /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
;;;552        if(FSMC_Bank == FSMC_Bank2_NAND)
000006  2810              CMP      r0,#0x10
000008  d004              BEQ      |L7.20|
;;;553        {
;;;554          FSMC_Bank2->PCR2 |= PCR_PBKEN_SET;
;;;555        }
;;;556        else
;;;557        {
;;;558          FSMC_Bank3->PCR3 |= PCR_PBKEN_SET;
00000a  f8520f80          LDR      r0,[r2,#0x80]!
00000e  f0400004          ORR      r0,r0,#4
000012  e009              B        |L7.40|
                  |L7.20|
000014  6e10              LDR      r0,[r2,#0x60]         ;554
000016  f0400004          ORR      r0,r0,#4              ;554
00001a  e009              B        |L7.48|
                  |L7.28|
;;;559        }
;;;560      }
;;;561      else
;;;562      {
;;;563        /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
;;;564        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;565        {
;;;566          FSMC_Bank2->PCR2 &= PCR_PBKEN_RESET;
00001c  4905              LDR      r1,|L7.52|
00001e  2810              CMP      r0,#0x10              ;564
000020  d004              BEQ      |L7.44|
;;;567        }
;;;568        else
;;;569        {
;;;570          FSMC_Bank3->PCR3 &= PCR_PBKEN_RESET;
000022  f8520f80          LDR      r0,[r2,#0x80]!
000026  4008              ANDS     r0,r0,r1
                  |L7.40|
000028  6010              STR      r0,[r2,#0]            ;558
;;;571        }
;;;572      }
;;;573    }
00002a  4770              BX       lr
                  |L7.44|
00002c  6e10              LDR      r0,[r2,#0x60]         ;566
00002e  4008              ANDS     r0,r0,r1              ;566
                  |L7.48|
000030  6610              STR      r0,[r2,#0x60]         ;554
000032  4770              BX       lr
;;;574    /**
                          ENDP

                  |L7.52|
                          DCD      0x000ffffb

                          AREA ||i.FSMC_NANDDeInit||, CODE, READONLY, ALIGN=1

                  FSMC_NANDDeInit PROC
;;;372      */
;;;373    void FSMC_NANDDeInit(uint32_t FSMC_Bank)
000000  b510              PUSH     {r4,lr}
;;;374    {
;;;375      /* Check the parameter */
;;;376      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;377      
;;;378      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;379      {
;;;380        /* Set the FSMC_Bank2 registers to their reset values */
;;;381        FSMC_Bank2->PCR2 = 0x00000018;
000002  2318              MOVS     r3,#0x18
;;;382        FSMC_Bank2->SR2 = 0x00000040;
000004  2440              MOVS     r4,#0x40
000006  f04f4120          MOV      r1,#0xa0000000        ;381
;;;383        FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
00000a  f04f32fc          MOV      r2,#0xfcfcfcfc
00000e  2810              CMP      r0,#0x10              ;378
000010  d005              BEQ      |L8.30|
;;;384        FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
;;;385      }
;;;386      /* FSMC_Bank3_NAND */  
;;;387      else
;;;388      {
;;;389        /* Set the FSMC_Bank3 registers to their reset values */
;;;390        FSMC_Bank3->PCR3 = 0x00000018;
000012  f8413f80          STR      r3,[r1,#0x80]!
;;;391        FSMC_Bank3->SR3 = 0x00000040;
000016  604c              STR      r4,[r1,#4]
;;;392        FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
000018  608a              STR      r2,[r1,#8]
;;;393        FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
00001a  60ca              STR      r2,[r1,#0xc]
;;;394      }  
;;;395    }
00001c  bd10              POP      {r4,pc}
                  |L8.30|
00001e  660b              STR      r3,[r1,#0x60]         ;381
000020  664c              STR      r4,[r1,#0x64]         ;382
000022  668a              STR      r2,[r1,#0x68]         ;383
000024  66ca              STR      r2,[r1,#0x6c]         ;384
000026  bd10              POP      {r4,pc}
;;;396    
                          ENDP


                          AREA ||i.FSMC_NANDECCCmd||, CODE, READONLY, ALIGN=2

                  FSMC_NANDECCCmd PROC
;;;583      */
;;;584    void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000000  f04f4220          MOV      r2,#0xa0000000
;;;585    {
000004  b151              CBZ      r1,|L9.28|
;;;586      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;587      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;588      
;;;589      if (NewState != DISABLE)
;;;590      {
;;;591        /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
;;;592        if(FSMC_Bank == FSMC_Bank2_NAND)
000006  2810              CMP      r0,#0x10
000008  d004              BEQ      |L9.20|
;;;593        {
;;;594          FSMC_Bank2->PCR2 |= PCR_ECCEN_SET;
;;;595        }
;;;596        else
;;;597        {
;;;598          FSMC_Bank3->PCR3 |= PCR_ECCEN_SET;
00000a  f8520f80          LDR      r0,[r2,#0x80]!
00000e  f0400040          ORR      r0,r0,#0x40
000012  e009              B        |L9.40|
                  |L9.20|
000014  6e10              LDR      r0,[r2,#0x60]         ;594
000016  f0400040          ORR      r0,r0,#0x40           ;594
00001a  e009              B        |L9.48|
                  |L9.28|
;;;599        }
;;;600      }
;;;601      else
;;;602      {
;;;603        /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
;;;604        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;605        {
;;;606          FSMC_Bank2->PCR2 &= PCR_ECCEN_RESET;
00001c  4905              LDR      r1,|L9.52|
00001e  2810              CMP      r0,#0x10              ;604
000020  d004              BEQ      |L9.44|
;;;607        }
;;;608        else
;;;609        {
;;;610          FSMC_Bank3->PCR3 &= PCR_ECCEN_RESET;
000022  f8520f80          LDR      r0,[r2,#0x80]!
000026  4008              ANDS     r0,r0,r1
                  |L9.40|
000028  6010              STR      r0,[r2,#0]            ;598
;;;611        }
;;;612      }
;;;613    }
00002a  4770              BX       lr
                  |L9.44|
00002c  6e10              LDR      r0,[r2,#0x60]         ;606
00002e  4008              ANDS     r0,r0,r1              ;606
                  |L9.48|
000030  6610              STR      r0,[r2,#0x60]         ;594
000032  4770              BX       lr
;;;614    
                          ENDP

                  |L9.52|
                          DCD      0x000fffbf

                          AREA ||i.FSMC_NANDInit||, CODE, READONLY, ALIGN=2

                  FSMC_NANDInit PROC
;;;403      */
;;;404    void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;405    {
;;;406      uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
;;;407        
;;;408      /* Check the parameters */
;;;409      assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));
;;;410      assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));
;;;411      assert_param( IS_FSMC_MEMORY_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));
;;;412      assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));
;;;413      assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));
;;;414      assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));
;;;415      assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));
;;;416      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;417      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;418      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;419      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;420      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;421      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;422      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;423      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;424      
;;;425      if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
000002  6802              LDR      r2,[r0,#0]
;;;426      {
;;;427      /* Get the NAND bank 2 register value */
;;;428        tmppcr = FSMC_Bank2->PCR2;
000004  f04f4120          MOV      r1,#0xa0000000
000008  2a10              CMP      r2,#0x10              ;425
00000a  d01b              BEQ      |L10.68|
;;;429      }
;;;430      else
;;;431      {
;;;432      /* Get the NAND bank 3 register value */
;;;433        tmppcr = FSMC_Bank3->PCR3;
00000c  f8d12080          LDR      r2,[r1,#0x80]
                  |L10.16|
;;;434      }
;;;435    
;;;436      /* Clear PWAITEN, PBKEN, PTYP, PWID, ECCEN, TCLR, TAR and ECCPS bits */
;;;437      tmppcr &= ((uint32_t)~(FSMC_PCR2_PWAITEN  | FSMC_PCR2_PBKEN | FSMC_PCR2_PTYP | \
000010  4b21              LDR      r3,|L10.152|
000012  ea020203          AND      r2,r2,r3
000016  e9d03401          LDRD     r3,r4,[r0,#4]
;;;438                             FSMC_PCR2_PWID | FSMC_PCR2_ECCEN | FSMC_PCR2_TCLR | \
;;;439                             FSMC_PCR2_TAR | FSMC_PCR2_ECCPS));  
;;;440    					   
;;;441      /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
;;;442      tmppcr |= (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
00001a  ea430304          ORR      r3,r3,r4
00001e  e9d04503          LDRD     r4,r5,[r0,#0xc]
000022  ea440405          ORR      r4,r4,r5
000026  ea430304          ORR      r3,r3,r4
00002a  6944              LDR      r4,[r0,#0x14]
00002c  ea432344          ORR      r3,r3,r4,LSL #9
000030  6984              LDR      r4,[r0,#0x18]
000032  ea433344          ORR      r3,r3,r4,LSL #13
000036  ea430302          ORR      r3,r3,r2
00003a  f0430408          ORR      r4,r3,#8
;;;443                          PCR_MEMORYTYPE_NAND |
;;;444                          FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
;;;445                          FSMC_NANDInitStruct->FSMC_ECC |
;;;446                          FSMC_NANDInitStruct->FSMC_ECCPageSize |
;;;447                          (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
;;;448                          (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
;;;449        
;;;450      if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
00003e  d103              BNE      |L10.72|
;;;451      {
;;;452        /* Get the NAND bank 2 register value */
;;;453        tmppmem = FSMC_Bank2->PMEM2;
000040  6e8a              LDR      r2,[r1,#0x68]
000042  e003              B        |L10.76|
                  |L10.68|
000044  6e0a              LDR      r2,[r1,#0x60]         ;428
000046  e7e3              B        |L10.16|
                  |L10.72|
;;;454      }
;;;455      else
;;;456      {
;;;457        /* Get the NAND bank 3 register value */
;;;458        tmppmem = FSMC_Bank3->PMEM3;
000048  f8d12088          LDR      r2,[r1,#0x88]
                  |L10.76|
;;;459      } 
;;;460      
;;;461      /* Clear MEMSETx, MEMWAITx, MEMHOLDx and MEMHIZx bits */
;;;462      tmppmem &= ((uint32_t)~(FSMC_PMEM2_MEMSET2  | FSMC_PMEM2_MEMWAIT2 | FSMC_PMEM2_MEMHOLD2 | \
;;;463                              FSMC_PMEM2_MEMHIZ2));
;;;464    					   
;;;465      /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
;;;466      tmppmem |= (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
00004c  69c2              LDR      r2,[r0,#0x1c]
00004e  e9d23500          LDRD     r3,r5,[r2,#0]
000052  ea432305          ORR      r3,r3,r5,LSL #8
000056  8915              LDRH     r5,[r2,#8]
000058  7b12              LDRB     r2,[r2,#0xc]
00005a  ea4f4505          LSL      r5,r5,#16
00005e  ea456202          ORR      r2,r5,r2,LSL #24
000062  ea430302          ORR      r3,r3,r2
;;;467                           (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;468                           (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;469                           (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;470    
;;;471      if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
;;;472      {
;;;473        /* Get the NAND bank 2 register value */
;;;474        tmppatt = FSMC_Bank2->PATT2;
;;;475      }
;;;476      else
;;;477      {
;;;478        /* Get the NAND bank 3 register value */
;;;479        tmppatt = FSMC_Bank2->PATT2;
000066  6eca              LDR      r2,[r1,#0x6c]
;;;480      } 
;;;481      
;;;482      /* Clear ATTSETx, ATTWAITx, ATTHOLDx and ATTHIZx bits */
;;;483      tmppatt &= ((uint32_t)~(FSMC_PATT2_ATTSET2  | FSMC_PATT2_ATTWAIT2 | FSMC_PATT2_ATTHOLD2 | \
;;;484                              FSMC_PATT2_ATTHIZ2));
;;;485      
;;;486      /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;487      tmppatt |= (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
000068  6a00              LDR      r0,[r0,#0x20]
00006a  e9d02500          LDRD     r2,r5,[r0,#0]
00006e  ea422205          ORR      r2,r2,r5,LSL #8
000072  8905              LDRH     r5,[r0,#8]
000074  7b00              LDRB     r0,[r0,#0xc]
000076  ea4f4505          LSL      r5,r5,#16
00007a  ea456000          ORR      r0,r5,r0,LSL #24
00007e  ea420200          ORR      r2,r2,r0
;;;488                           (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;489                           (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;490                           (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
;;;491      
;;;492      if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
000082  d103              BNE      |L10.140|
;;;493      {
;;;494        /* FSMC_Bank2_NAND registers configuration */
;;;495        FSMC_Bank2->PCR2 = tmppcr;
000084  660c              STR      r4,[r1,#0x60]
;;;496        FSMC_Bank2->PMEM2 = tmppmem;
000086  668b              STR      r3,[r1,#0x68]
;;;497        FSMC_Bank2->PATT2 = tmppatt;
000088  66ca              STR      r2,[r1,#0x6c]
;;;498      }
;;;499      else
;;;500      {
;;;501        /* FSMC_Bank3_NAND registers configuration */
;;;502        FSMC_Bank3->PCR3 = tmppcr;
;;;503        FSMC_Bank3->PMEM3 = tmppmem;
;;;504        FSMC_Bank3->PATT3 = tmppatt;
;;;505      }
;;;506    }
00008a  bd30              POP      {r4,r5,pc}
                  |L10.140|
00008c  f8414f80          STR      r4,[r1,#0x80]!        ;502
000090  608b              STR      r3,[r1,#8]            ;503
000092  60ca              STR      r2,[r1,#0xc]          ;504
000094  bd30              POP      {r4,r5,pc}
;;;507    
                          ENDP

000096  0000              DCW      0x0000
                  |L10.152|
                          DCD      0xfff00181

                          AREA ||i.FSMC_NANDStructInit||, CODE, READONLY, ALIGN=1

                  FSMC_NANDStructInit PROC
;;;514      */
;;;515    void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
000000  2110              MOVS     r1,#0x10
;;;516    { 
;;;517      /* Reset NAND Init structure parameters values */
;;;518      FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
;;;519      FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
000002  6001              STR      r1,[r0,#0]
000004  2100              MOVS     r1,#0
;;;520      FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
000006  6041              STR      r1,[r0,#4]
;;;521      FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
000008  6081              STR      r1,[r0,#8]
;;;522      FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
00000a  60c1              STR      r1,[r0,#0xc]
;;;523      FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
00000c  6101              STR      r1,[r0,#0x10]
;;;524      FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
00000e  6141              STR      r1,[r0,#0x14]
;;;525      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000010  6181              STR      r1,[r0,#0x18]
000012  69c2              LDR      r2,[r0,#0x1c]
000014  21fc              MOVS     r1,#0xfc
;;;526      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000016  6011              STR      r1,[r2,#0]
000018  69c2              LDR      r2,[r0,#0x1c]
;;;527      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00001a  6051              STR      r1,[r2,#4]
00001c  69c2              LDR      r2,[r0,#0x1c]
;;;528      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
00001e  6091              STR      r1,[r2,#8]
000020  69c2              LDR      r2,[r0,#0x1c]
;;;529      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000022  60d1              STR      r1,[r2,#0xc]
000024  6a02              LDR      r2,[r0,#0x20]
;;;530      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000026  6011              STR      r1,[r2,#0]
000028  6a02              LDR      r2,[r0,#0x20]
;;;531      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00002a  6051              STR      r1,[r2,#4]
00002c  6a02              LDR      r2,[r0,#0x20]
;;;532      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
00002e  6091              STR      r1,[r2,#8]
000030  6a00              LDR      r0,[r0,#0x20]
000032  60c1              STR      r1,[r0,#0xc]
;;;533    }
000034  4770              BX       lr
;;;534    
                          ENDP


                          AREA ||i.FSMC_NORSRAMCmd||, CODE, READONLY, ALIGN=2

                  FSMC_NORSRAMCmd PROC
;;;299      */
;;;300    void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000000  0080              LSLS     r0,r0,#2
;;;301    {
;;;302      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;303      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;304      
;;;305      if (NewState != DISABLE)
;;;306      {
;;;307        /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
;;;308        FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_SET;
000002  f1a040c0          SUB      r0,r0,#0x60000000
000006  2900              CMP      r1,#0                 ;305
;;;309      }
;;;310      else
;;;311      {
;;;312        /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
;;;313        FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_RESET;
000008  6801              LDR      r1,[r0,#0]
00000a  d002              BEQ      |L12.18|
00000c  f0410101          ORR      r1,r1,#1              ;308
000010  e001              B        |L12.22|
                  |L12.18|
000012  4a02              LDR      r2,|L12.28|
000014  4011              ANDS     r1,r1,r2
                  |L12.22|
000016  6001              STR      r1,[r0,#0]            ;308
;;;314      }
;;;315    }
000018  4770              BX       lr
;;;316    /**
                          ENDP

00001a  0000              DCW      0x0000
                  |L12.28|
                          DCD      0x000ffffe

                          AREA ||i.FSMC_NORSRAMDeInit||, CODE, READONLY, ALIGN=1

                  FSMC_NORSRAMDeInit PROC
;;;128      */
;;;129    void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)
000000  0081              LSLS     r1,r0,#2
;;;130    {
;;;131      /* Check the parameter */
;;;132      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;133      
;;;134      /* FSMC_Bank1_NORSRAM1 */
;;;135      if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
;;;136      {
;;;137        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
;;;138      }
;;;139      /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
;;;140      else
;;;141      {   
;;;142        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
000002  f1a141c0          SUB      r1,r1,#0x60000000
000006  b140              CBZ      r0,|L13.26|
000008  f24300d2          MOV      r0,#0x30d2
00000c  6008              STR      r0,[r1,#0]
                  |L13.14|
;;;143      }
;;;144      FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
00000e  f06f4070          MVN      r0,#0xf0000000
000012  6048              STR      r0,[r1,#4]
;;;145      FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
000014  f8c10104          STR      r0,[r1,#0x104]
;;;146    }
000018  4770              BX       lr
                  |L13.26|
00001a  f04f4220          MOV      r2,#0xa0000000        ;137
00001e  f24300db          MOV      r0,#0x30db            ;137
000022  6010              STR      r0,[r2,#0]            ;137
000024  e7f3              B        |L13.14|
;;;147    
                          ENDP


                          AREA ||i.FSMC_NORSRAMInit||, CODE, READONLY, ALIGN=2

                  FSMC_NORSRAMInit PROC
;;;155      */
;;;156    void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;157    { 
;;;158      uint32_t tmpbcr = 0, tmpbtr = 0, tmpbwr = 0;
;;;159    
;;;160      /* Check the parameters */
;;;161      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));
;;;162      assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));
;;;163      assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));
;;;164      assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));
;;;165      assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));
;;;166      assert_param(IS_FSMC_ASYNWAIT(FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait));
;;;167      assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));
;;;168      assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));
;;;169      assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));
;;;170      assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));
;;;171      assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));
;;;172      assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));
;;;173      assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));  
;;;174      assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));
;;;175      assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));
;;;176      assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));
;;;177      assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));
;;;178      assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
;;;179      assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
;;;180      assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
;;;181    
;;;182      /* Get the BTCR register value */
;;;183      tmpbcr = FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank];
000002  6801              LDR      r1,[r0,#0]
000004  0089              LSLS     r1,r1,#2
000006  f1a141c0          SUB      r1,r1,#0x60000000
00000a  680b              LDR      r3,[r1,#0]
;;;184    
;;;185      /* Clear MBKEN, MUXEN, MTYP, MWID, FACCEN, BURSTEN, WAITPOL, WRAPMOD, WAITCFG, WREN,
;;;186               WAITEN, EXTMOD, ASYNCWAIT, CBURSTRW and CCLKEN bits */
;;;187      tmpbcr &= ((uint32_t)~(FSMC_BCR1_MBKEN    | FSMC_BCR1_MUXEN    | FSMC_BCR1_MTYP     | \
00000c  4a33              LDR      r2,|L14.220|
00000e  4013              ANDS     r3,r3,r2
000010  e9d02401          LDRD     r2,r4,[r0,#4]
;;;188                             FSMC_BCR1_MWID      | FSMC_BCR1_FACCEN   | FSMC_BCR1_BURSTEN  | \
;;;189                             FSMC_BCR1_WAITPOL   | FSMC_BCR1_WRAPMOD  | FSMC_BCR1_WAITCFG  | \
;;;190                             FSMC_BCR1_WREN      | FSMC_BCR1_WAITEN   | FSMC_BCR1_EXTMOD   | \
;;;191                             FSMC_BCR1_ASYNCWAIT | FSMC_BCR1_CBURSTRW));
;;;192    
;;;193      /* Bank1 NOR/SRAM control register configuration */ 
;;;194      tmpbcr |= (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
000014  4322              ORRS     r2,r2,r4
000016  e9d04503          LDRD     r4,r5,[r0,#0xc]
00001a  432c              ORRS     r4,r4,r5
00001c  4322              ORRS     r2,r2,r4
00001e  6944              LDR      r4,[r0,#0x14]
000020  4322              ORRS     r2,r2,r4
000022  6984              LDR      r4,[r0,#0x18]
000024  4322              ORRS     r2,r2,r4
000026  69c4              LDR      r4,[r0,#0x1c]
000028  4322              ORRS     r2,r2,r4
00002a  6a04              LDR      r4,[r0,#0x20]
00002c  4322              ORRS     r2,r2,r4
00002e  6a44              LDR      r4,[r0,#0x24]
000030  4322              ORRS     r2,r2,r4
000032  6a84              LDR      r4,[r0,#0x28]
000034  4322              ORRS     r2,r2,r4
000036  6ac4              LDR      r4,[r0,#0x2c]
000038  4322              ORRS     r2,r2,r4
00003a  6b04              LDR      r4,[r0,#0x30]
00003c  4322              ORRS     r2,r2,r4
00003e  431a              ORRS     r2,r2,r3
;;;195                FSMC_NORSRAMInitStruct->FSMC_MemoryType |
;;;196                FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
;;;197                FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
;;;198                FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
;;;199                FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
;;;200                FSMC_NORSRAMInitStruct->FSMC_WrapMode |
;;;201                FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
;;;202                FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
;;;203                FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
;;;204                FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
;;;205                FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
;;;206    			
;;;207      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = tmpbcr;
000040  600a              STR      r2,[r1,#0]
;;;208      
;;;209      if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
000042  6881              LDR      r1,[r0,#8]
000044  2908              CMP      r1,#8
000046  d107              BNE      |L14.88|
;;;210      {
;;;211        FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_SET;
000048  6801              LDR      r1,[r0,#0]
00004a  0089              LSLS     r1,r1,#2
00004c  f1a141c0          SUB      r1,r1,#0x60000000
000050  680a              LDR      r2,[r1,#0]
000052  f0420240          ORR      r2,r2,#0x40
000056  600a              STR      r2,[r1,#0]
                  |L14.88|
;;;212      }
;;;213      
;;;214      /* Get the BTCR register value */
;;;215      tmpbtr = FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1];
000058  6801              LDR      r1,[r0,#0]
00005a  008a              LSLS     r2,r1,#2
00005c  f1a242c0          SUB      r2,r2,#0x60000000
000060  6851              LDR      r1,[r2,#4]
;;;216    
;;;217      /* Clear ADDSET, ADDHLD, DATAST, BUSTURN, CLKDIV, DATLAT and ACCMOD bits */
;;;218      tmpbtr &= ((uint32_t)~(FSMC_BTR1_ADDSET | FSMC_BTR1_ADDHLD | FSMC_BTR1_DATAST | \
000062  f0014340          AND      r3,r1,#0xc0000000
;;;219                           FSMC_BTR1_BUSTURN | FSMC_BTR1_CLKDIV | FSMC_BTR1_DATLAT | \
;;;220                           FSMC_BTR1_ACCMOD));
;;;221    					   
;;;222      /* Bank1 NOR/SRAM timing register configuration */
;;;223      tmpbtr |= (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
000066  6b41              LDR      r1,[r0,#0x34]
000068  e9d14500          LDRD     r4,r5,[r1,#0]
00006c  ea441405          ORR      r4,r4,r5,LSL #4
000070  688d              LDR      r5,[r1,#8]
000072  898e              LDRH     r6,[r1,#0xc]
000074  022d              LSLS     r5,r5,#8
000076  ea454506          ORR      r5,r5,r6,LSL #16
00007a  432c              ORRS     r4,r4,r5
00007c  8a0d              LDRH     r5,[r1,#0x10]
00007e  ea445405          ORR      r4,r4,r5,LSL #20
000082  7d0d              LDRB     r5,[r1,#0x14]
000084  6989              LDR      r1,[r1,#0x18]
000086  ea446405          ORR      r4,r4,r5,LSL #24
00008a  430c              ORRS     r4,r4,r1
00008c  431c              ORRS     r4,r4,r3
;;;224                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
;;;225                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;226                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
;;;227                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
;;;228                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
;;;229                 FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
;;;230                
;;;231      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = tmpbtr;
00008e  6054              STR      r4,[r2,#4]
;;;232    	
;;;233      /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
;;;234      if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
000090  6ac1              LDR      r1,[r0,#0x2c]
000092  f5b14f80          CMP      r1,#0x4000
000096  d008              BEQ      |L14.170|
;;;235      {
;;;236        assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));
;;;237        assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
;;;238        assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
;;;239        assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration));
;;;240        assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
;;;241        
;;;242        /* Get the BWTR register value */
;;;243        tmpbwr = FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank];
;;;244        
;;;245        /* Clear ADDSET, ADDHLD, DATAST, BUSTURN, and ACCMOD bits */
;;;246        tmpbwr &= ((uint32_t)~(FSMC_BWTR1_ADDSET | FSMC_BWTR1_ADDHLD | FSMC_BWTR1_DATAST | \
;;;247                               FSMC_BWTR1_BUSTURN | FSMC_BWTR1_ACCMOD));
;;;248        
;;;249        tmpbwr |= (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
;;;250                           (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
;;;251                           (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;252                           (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
;;;253                            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
;;;254        
;;;255        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = tmpbwr;
;;;256      }
;;;257      else
;;;258      {
;;;259        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
000098  6800              LDR      r0,[r0,#0]
00009a  f06f4170          MVN      r1,#0xf0000000
00009e  0080              LSLS     r0,r0,#2
0000a0  f1a040c0          SUB      r0,r0,#0x60000000
0000a4  f8c01104          STR      r1,[r0,#0x104]
;;;260      }
;;;261    }
0000a8  bd70              POP      {r4-r6,pc}
                  |L14.170|
0000aa  6801              LDR      r1,[r0,#0]            ;243
0000ac  0089              LSLS     r1,r1,#2              ;243
0000ae  f1a141c0          SUB      r1,r1,#0x60000000     ;243
0000b2  f8d12104          LDR      r2,[r1,#0x104]        ;243
0000b6  6b80              LDR      r0,[r0,#0x38]         ;249
0000b8  4b09              LDR      r3,|L14.224|
0000ba  401a              ANDS     r2,r2,r3              ;246
0000bc  e9d03400          LDRD     r3,r4,[r0,#0]         ;249
0000c0  ea431304          ORR      r3,r3,r4,LSL #4       ;249
0000c4  6884              LDR      r4,[r0,#8]            ;249
0000c6  8985              LDRH     r5,[r0,#0xc]          ;249
0000c8  0224              LSLS     r4,r4,#8              ;249
0000ca  ea444405          ORR      r4,r4,r5,LSL #16      ;249
0000ce  6980              LDR      r0,[r0,#0x18]         ;249
0000d0  4323              ORRS     r3,r3,r4              ;249
0000d2  4303              ORRS     r3,r3,r0              ;249
0000d4  4313              ORRS     r3,r3,r2              ;249
0000d6  f8c13104          STR      r3,[r1,#0x104]        ;255
0000da  bd70              POP      {r4-r6,pc}
;;;262    
                          ENDP

                  |L14.220|
                          DCD      0xfff70080
                  |L14.224|
                          DCD      0xcff00000

                          AREA ||i.FSMC_NORSRAMStructInit||, CODE, READONLY, ALIGN=2

                  FSMC_NORSRAMStructInit PROC
;;;268      */
;;;269    void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
000000  2100              MOVS     r1,#0
;;;270    {  
;;;271      /* Reset NOR/SRAM Init structure parameters values */
;;;272      FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
;;;273      FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
000002  2202              MOVS     r2,#2
000004  e9c01200          STRD     r1,r2,[r0,#0]
;;;274      FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
;;;275      FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
000008  6081              STR      r1,[r0,#8]
;;;276      FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
00000a  60c1              STR      r1,[r0,#0xc]
;;;277      FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
00000c  6101              STR      r1,[r0,#0x10]
;;;278      FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
00000e  6141              STR      r1,[r0,#0x14]
;;;279      FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
000010  6181              STR      r1,[r0,#0x18]
;;;280      FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
;;;281      FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
000012  02d2              LSLS     r2,r2,#11
000014  61c1              STR      r1,[r0,#0x1c]
000016  e9c01208          STRD     r1,r2,[r0,#0x20]
;;;282      FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
00001a  0052              LSLS     r2,r2,#1
00001c  e9c0210a          STRD     r2,r1,[r0,#0x28]
;;;283      FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
;;;284      FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
;;;285      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct = (FSMC_NORSRAMTimingInitTypeDef*)((uint32_t)&FSMC_DefaultTimingStruct);
000020  6301              STR      r1,[r0,#0x30]
000022  4902              LDR      r1,|L15.44|
;;;286      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct = (FSMC_NORSRAMTimingInitTypeDef*)((uint32_t)&FSMC_DefaultTimingStruct);
000024  6341              STR      r1,[r0,#0x34]
000026  6381              STR      r1,[r0,#0x38]
;;;287    }
000028  4770              BX       lr
;;;288    
                          ENDP

00002a  0000              DCW      0x0000
                  |L15.44|
                          DCD      ||.constdata||

                          AREA ||i.FSMC_PCCARDCmd||, CODE, READONLY, ALIGN=2

                  FSMC_PCCARDCmd PROC
;;;819      */
;;;820    void FSMC_PCCARDCmd(FunctionalState NewState)
000000  f04f4120          MOV      r1,#0xa0000000
;;;821    {
;;;822      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;823      
;;;824      if (NewState != DISABLE)
000004  2800              CMP      r0,#0
;;;825      {
;;;826        /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
;;;827        FSMC_Bank4->PCR4 |= PCR_PBKEN_SET;
;;;828      }
;;;829      else
;;;830      {
;;;831        /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
;;;832        FSMC_Bank4->PCR4 &= PCR_PBKEN_RESET;
000006  f8510fa0          LDR      r0,[r1,#0xa0]!
00000a  d002              BEQ      |L16.18|
00000c  f0400004          ORR      r0,r0,#4              ;827
000010  e001              B        |L16.22|
                  |L16.18|
000012  4a02              LDR      r2,|L16.28|
000014  4010              ANDS     r0,r0,r2
                  |L16.22|
000016  6008              STR      r0,[r1,#0]            ;827
;;;833      }
;;;834    }
000018  4770              BX       lr
;;;835    /**
                          ENDP

00001a  0000              DCW      0x0000
                  |L16.28|
                          DCD      0x000ffffb

                          AREA ||i.FSMC_PCCARDDeInit||, CODE, READONLY, ALIGN=1

                  FSMC_PCCARDDeInit PROC
;;;686      */
;;;687    void FSMC_PCCARDDeInit(void)
000000  f04f4020          MOV      r0,#0xa0000000
;;;688    {
;;;689      /* Set the FSMC_Bank4 registers to their reset values */
;;;690      FSMC_Bank4->PCR4 = 0x00000018; 
000004  2118              MOVS     r1,#0x18
000006  f8401fa0          STR      r1,[r0,#0xa0]!
;;;691      FSMC_Bank4->SR4 = 0x00000000;	
00000a  2100              MOVS     r1,#0
00000c  6041              STR      r1,[r0,#4]
;;;692      FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
00000e  f04f31fc          MOV      r1,#0xfcfcfcfc
000012  6081              STR      r1,[r0,#8]
;;;693      FSMC_Bank4->PATT4 = 0xFCFCFCFC;
000014  60c1              STR      r1,[r0,#0xc]
;;;694      FSMC_Bank4->PIO4 = 0xFCFCFCFC;
000016  6101              STR      r1,[r0,#0x10]
;;;695    }
000018  4770              BX       lr
;;;696    
                          ENDP


                          AREA ||i.FSMC_PCCARDInit||, CODE, READONLY, ALIGN=2

                  FSMC_PCCARDInit PROC
;;;703      */
;;;704    void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
000000  b510              PUSH     {r4,lr}
;;;705    {
;;;706       uint32_t tmppcr4 = 0, tmppmem4 = 0, tmppatt4 = 0, tmppio4 = 0;
;;;707    
;;;708      /* Check the parameters */
;;;709      assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));
;;;710      assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));
;;;711      assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));
;;;712     
;;;713      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;714      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;715      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;716      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;717      
;;;718      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;719      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;720      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;721      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;722      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));
;;;723      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
;;;724      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
;;;725      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
;;;726      
;;;727      /* Get PCCARD control register value */
;;;728      tmppcr4 = FSMC_Bank4->PCR4;
000002  f04f4120          MOV      r1,#0xa0000000
000006  f8512fa0          LDR      r2,[r1,#0xa0]!
;;;729      
;;;730      /* Clear TAR, TCLR, PWAITEN and PWID bits */
;;;731      tmppcr4 &= ((uint32_t)~(FSMC_PCR4_TAR  | FSMC_PCR4_TCLR | FSMC_PCR4_PWAITEN | \
00000a  4b1a              LDR      r3,|L18.116|
;;;732                              FSMC_PCR4_PWID));
;;;733    					   
;;;734      /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
;;;735      tmppcr4 |= (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
00000c  6884              LDR      r4,[r0,#8]
00000e  401a              ANDS     r2,r2,r3              ;731
000010  6843              LDR      r3,[r0,#4]
000012  025b              LSLS     r3,r3,#9
000014  ea433344          ORR      r3,r3,r4,LSL #13
000018  6804              LDR      r4,[r0,#0]
00001a  4314              ORRS     r4,r4,r2
00001c  4323              ORRS     r3,r3,r4
00001e  f0430210          ORR      r2,r3,#0x10
;;;736                           FSMC_MemoryDataWidth_16b |  
;;;737                           (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
;;;738                           (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
;;;739      
;;;740      FSMC_Bank4->PCR4 = tmppcr4;
000022  600a              STR      r2,[r1,#0]
;;;741      
;;;742      /* Get PCCARD common space timing register value */
;;;743      tmppmem4 = FSMC_Bank4->PMEM4;
000024  688a              LDR      r2,[r1,#8]
;;;744      
;;;745      /* Clear MEMSETx, MEMWAITx, MEMHOLDx and MEMHIZx bits */
;;;746      tmppmem4 &= ((uint32_t)~(FSMC_PMEM4_MEMSET4  | FSMC_PMEM4_MEMWAIT4 | FSMC_PMEM4_MEMHOLD4 | \
;;;747                               FSMC_PMEM4_MEMHIZ4));
;;;748    					   
;;;749      /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
;;;750      tmppmem4 |= (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
000026  68c2              LDR      r2,[r0,#0xc]
000028  e9d23400          LDRD     r3,r4,[r2,#0]
00002c  ea432304          ORR      r3,r3,r4,LSL #8
000030  8914              LDRH     r4,[r2,#8]
000032  7b12              LDRB     r2,[r2,#0xc]
000034  0424              LSLS     r4,r4,#16
000036  ea446202          ORR      r2,r4,r2,LSL #24
00003a  4313              ORRS     r3,r3,r2
;;;751                            (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;752                            (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;753                            (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;754       
;;;755      FSMC_Bank4->PMEM4 = tmppmem4;
00003c  608b              STR      r3,[r1,#8]
;;;756      
;;;757      /* Get PCCARD timing parameters */
;;;758      tmppatt4 = FSMC_Bank4->PATT4;
00003e  68ca              LDR      r2,[r1,#0xc]
;;;759    
;;;760      /* Clear ATTSETx, ATTWAITx, ATTHOLDx and ATTHIZx bits */
;;;761      tmppatt4 &= ((uint32_t)~(FSMC_PATT4_ATTSET4  | FSMC_PATT4_ATTWAIT4 | FSMC_PATT4_ATTHOLD4 | \
;;;762                               FSMC_PATT4_ATTHIZ4));
;;;763    					   
;;;764      /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;765      tmppatt4 |= (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
000040  6902              LDR      r2,[r0,#0x10]
000042  e9d23400          LDRD     r3,r4,[r2,#0]
000046  ea432304          ORR      r3,r3,r4,LSL #8
00004a  8914              LDRH     r4,[r2,#8]
00004c  7b12              LDRB     r2,[r2,#0xc]
00004e  0424              LSLS     r4,r4,#16
000050  ea446202          ORR      r2,r4,r2,LSL #24
000054  4313              ORRS     r3,r3,r2
;;;766                            (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;767                            (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;768                            (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
;;;769       
;;;770      FSMC_Bank4->PATT4 = tmppatt4;
000056  60cb              STR      r3,[r1,#0xc]
;;;771    
;;;772      /* Get FSMC_PCCARD device timing parameters */
;;;773      tmppio4 = FSMC_Bank4->PIO4;
000058  690a              LDR      r2,[r1,#0x10]
;;;774    
;;;775      /* Clear IOSET4, IOWAIT4, IOHOLD4 and IOHIZ4 bits */
;;;776      tmppio4 &= ((uint32_t)~(FSMC_PIO4_IOSET4  | FSMC_PIO4_IOWAIT4 | FSMC_PIO4_IOHOLD4 | \
;;;777                              FSMC_PIO4_IOHIZ4));
;;;778    					   
;;;779      /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
;;;780      tmppio4 |= (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
00005a  6940              LDR      r0,[r0,#0x14]
00005c  e9d02300          LDRD     r2,r3,[r0,#0]
000060  ea422203          ORR      r2,r2,r3,LSL #8
000064  8903              LDRH     r3,[r0,#8]
000066  7b00              LDRB     r0,[r0,#0xc]
000068  041b              LSLS     r3,r3,#16
00006a  ea436000          ORR      r0,r3,r0,LSL #24
00006e  4302              ORRS     r2,r2,r0
;;;781                           (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;782                           (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;783                           (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;784      
;;;785      FSMC_Bank4->PIO4 = tmppio4;					 
000070  610a              STR      r2,[r1,#0x10]
;;;786    }
000072  bd10              POP      {r4,pc}
;;;787    
                          ENDP

                  |L18.116|
                          DCD      0xfffe01cd

                          AREA ||i.FSMC_PCCARDStructInit||, CODE, READONLY, ALIGN=1

                  FSMC_PCCARDStructInit PROC
;;;793      */
;;;794    void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
000000  2100              MOVS     r1,#0
;;;795    {
;;;796      /* Reset PCCARD Init structure parameters values */
;;;797      FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
;;;798      FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
000002  6001              STR      r1,[r0,#0]
;;;799      FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
000004  6041              STR      r1,[r0,#4]
;;;800      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000006  6081              STR      r1,[r0,#8]
000008  68c2              LDR      r2,[r0,#0xc]
00000a  21fc              MOVS     r1,#0xfc
;;;801      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00000c  6011              STR      r1,[r2,#0]
00000e  68c2              LDR      r2,[r0,#0xc]
;;;802      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000010  6051              STR      r1,[r2,#4]
000012  68c2              LDR      r2,[r0,#0xc]
;;;803      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000014  6091              STR      r1,[r2,#8]
000016  68c2              LDR      r2,[r0,#0xc]
;;;804      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000018  60d1              STR      r1,[r2,#0xc]
00001a  6902              LDR      r2,[r0,#0x10]
;;;805      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00001c  6011              STR      r1,[r2,#0]
00001e  6902              LDR      r2,[r0,#0x10]
;;;806      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000020  6051              STR      r1,[r2,#4]
000022  6902              LDR      r2,[r0,#0x10]
;;;807      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
000024  6091              STR      r1,[r2,#8]
000026  6902              LDR      r2,[r0,#0x10]
;;;808      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000028  60d1              STR      r1,[r2,#0xc]
00002a  6942              LDR      r2,[r0,#0x14]
;;;809      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00002c  6011              STR      r1,[r2,#0]
00002e  6942              LDR      r2,[r0,#0x14]
;;;810      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000030  6051              STR      r1,[r2,#4]
000032  6942              LDR      r2,[r0,#0x14]
;;;811      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000034  6091              STR      r1,[r2,#8]
000036  6940              LDR      r0,[r0,#0x14]
000038  60c1              STR      r1,[r0,#0xc]
;;;812    }
00003a  4770              BX       lr
;;;813    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  FSMC_DefaultTimingStruct
                          DCD      0x0000000f
                          DCD      0x0000000f
                          DCD      0x000000ff
                          DCD      0x0000000f
                          DCD      0x0000000f
                          DCD      0x0000000f
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_fsmc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_fsmc_c_13019877____REV16|
#line 138 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_stm32f4xx_fsmc_c_13019877____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_fsmc_c_13019877____REVSH|
#line 153
|__asm___16_stm32f4xx_fsmc_c_13019877____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_fsmc_c_13019877____RRX|
#line 328
|__asm___16_stm32f4xx_fsmc_c_13019877____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

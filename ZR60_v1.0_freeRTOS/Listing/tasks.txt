; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\tasks.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\tasks.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\ZR60_v1.0_freeRTOS -I..\..\Lwip\App -I..\..\Lwip\Bsp -I..\..\Lwip\Bsp\LAN8742A -I..\..\Lwip\lwip-1.4.1 -I..\..\Lwip\lwip-1.4.1\port -I..\..\Lwip\lwip-1.4.1\port\arch -I..\..\Lwip\lwip-1.4.1\port\Standalone -I..\..\Lwip\lwip-1.4.1\src\include -I..\..\Lwip\lwip-1.4.1\src\include\ipv4 -I..\..\Lwip\lwip-1.4.1\src\include\lwip -I..\..\Lwip\lwip-1.4.1\src\include\netif -I..\..\Ecal\BtnFltr -I..\..\Ecal\UartComn -I..\..\Ecal\MemIf -I..\..\APP -I..\..\APP\BlackListMng -I..\..\APP\SeverNewsPush -I..\..\APP\NewsPull -I..\..\Ecal -I..\..\Ecal\JsonIf -I..\..\Ecal\Mcu_Init -I..\..\Service -I..\..\Complex -I..\..\Complex\FATFS -I..\..\FreeRTOS\Source\include -I..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\FreeRTOS -I.\RTE\_ZR60 -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=..\..\output\tasks.crf ..\..\FreeRTOS\Source\tasks.c]
                          THUMB

                          AREA ||i.prvAddCurrentTaskToDelayedList||, CODE, READONLY, ALIGN=2

                  prvAddCurrentTaskToDelayedList PROC
;;;3072   
;;;3073   static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
000000  b570              PUSH     {r4-r6,lr}
;;;3074   {
;;;3075   	/* The list item will be inserted in wake time order. */
;;;3076   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
000002  4d0b              LDR      r5,|L1.48|
000004  4604              MOV      r4,r0                 ;3074
000006  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
;;;3077   
;;;3078   	if( xTimeToWake < xTickCount )
000008  6044              STR      r4,[r0,#4]
00000a  68e8              LDR      r0,[r5,#0xc]  ; xTickCount
;;;3079   	{
;;;3080   		/* Wake time has overflowed.  Place this item in the overflow list. */
;;;3081   		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
;;;3082   	}
;;;3083   	else
;;;3084   	{
;;;3085   		/* The wake time has not overflowed, so the current block list is used. */
;;;3086   		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
00000c  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
00000e  4284              CMP      r4,r0                 ;3078
000010  d205              BCS      |L1.30|
000012  6b68              LDR      r0,[r5,#0x34]         ;3081  ; pxOverflowDelayedTaskList
000014  e8bd4070          POP      {r4-r6,lr}            ;3081
000018  1d09              ADDS     r1,r1,#4              ;3081
00001a  f7ffbffe          B.W      vListInsert
                  |L1.30|
00001e  6b28              LDR      r0,[r5,#0x30]  ; pxDelayedTaskList
000020  1d09              ADDS     r1,r1,#4
000022  f7fffffe          BL       vListInsert
;;;3087   
;;;3088   		/* If the task entering the blocked state was placed at the head of the
;;;3089   		list of blocked tasks then xNextTaskUnblockTime needs to be updated
;;;3090   		too. */
;;;3091   		if( xTimeToWake < xNextTaskUnblockTime )
000026  6aa8              LDR      r0,[r5,#0x28]  ; xNextTaskUnblockTime
000028  4284              CMP      r4,r0
00002a  d200              BCS      |L1.46|
;;;3092   		{
;;;3093   			xNextTaskUnblockTime = xTimeToWake;
00002c  62ac              STR      r4,[r5,#0x28]  ; xNextTaskUnblockTime
                  |L1.46|
;;;3094   		}
;;;3095   		else
;;;3096   		{
;;;3097   			mtCOVERAGE_TEST_MARKER();
;;;3098   		}
;;;3099   	}
;;;3100   }
00002e  bd70              POP      {r4-r6,pc}
;;;3101   /*-----------------------------------------------------------*/
                          ENDP

                  |L1.48|
                          DCD      ||.data||

                          AREA ||i.prvCheckTasksWaitingTermination||, CODE, READONLY, ALIGN=2

                  prvCheckTasksWaitingTermination PROC
;;;3031   
;;;3032   static void prvCheckTasksWaitingTermination( void )
000000  b570              PUSH     {r4-r6,lr}
;;;3033   {
;;;3034   	#if ( INCLUDE_vTaskDelete == 1 )
;;;3035   	{
;;;3036   		BaseType_t xListIsEmpty;
;;;3037   
;;;3038   		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
;;;3039   		too often in the idle task. */
;;;3040   		while( uxTasksDeleted > ( UBaseType_t ) 0U )
;;;3041   		{
;;;3042   			vTaskSuspendAll();
;;;3043   			{
;;;3044   				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
000002  4e13              LDR      r6,|L2.80|
;;;3045   			}
;;;3046   			( void ) xTaskResumeAll();
;;;3047   
;;;3048   			if( xListIsEmpty == pdFALSE )
;;;3049   			{
;;;3050   				TCB_t *pxTCB;
;;;3051   
;;;3052   				taskENTER_CRITICAL();
;;;3053   				{
;;;3054   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
;;;3055   					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
;;;3056   					--uxCurrentNumberOfTasks;
000004  4d13              LDR      r5,|L2.84|
000006  e01f              B        |L2.72|
                  |L2.8|
000008  f7fffffe          BL       vTaskSuspendAll
00000c  6830              LDR      r0,[r6,#0]            ;3044  ; xTasksWaitingTermination
00000e  b120              CBZ      r0,|L2.26|
000010  2400              MOVS     r4,#0                 ;3044
                  |L2.18|
000012  f7fffffe          BL       xTaskResumeAll
000016  b9bc              CBNZ     r4,|L2.72|
000018  e001              B        |L2.30|
                  |L2.26|
00001a  2401              MOVS     r4,#1                 ;3044
00001c  e7f9              B        |L2.18|
                  |L2.30|
00001e  f7fffffe          BL       vPortEnterCritical
000022  68f0              LDR      r0,[r6,#0xc]          ;3054  ; xTasksWaitingTermination
000024  68c4              LDR      r4,[r0,#0xc]          ;3055
000026  1d20              ADDS     r0,r4,#4              ;3055
000028  f7fffffe          BL       uxListRemove
00002c  68a8              LDR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
00002e  1e40              SUBS     r0,r0,#1
000030  60a8              STR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
;;;3057   					--uxTasksDeleted;
000032  6868              LDR      r0,[r5,#4]  ; uxTasksDeleted
000034  1e40              SUBS     r0,r0,#1
000036  6068              STR      r0,[r5,#4]  ; uxTasksDeleted
;;;3058   				}
;;;3059   				taskEXIT_CRITICAL();
000038  f7fffffe          BL       vPortExitCritical
00003c  6b20              LDR      r0,[r4,#0x30]
00003e  f7fffffe          BL       vPortFree
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       vPortFree
                  |L2.72|
000048  6868              LDR      r0,[r5,#4]            ;3040  ; uxTasksDeleted
00004a  2800              CMP      r0,#0                 ;3040
00004c  d1dc              BNE      |L2.8|
;;;3060   
;;;3061   				prvDeleteTCB( pxTCB );
;;;3062   			}
;;;3063   			else
;;;3064   			{
;;;3065   				mtCOVERAGE_TEST_MARKER();
;;;3066   			}
;;;3067   		}
;;;3068   	}
;;;3069   	#endif /* vTaskDelete */
;;;3070   }
00004e  bd70              POP      {r4-r6,pc}
;;;3071   /*-----------------------------------------------------------*/
                          ENDP

                  |L2.80|
                          DCD      ||.bss||+0xa0
                  |L2.84|
                          DCD      ||.data||

                          AREA ||i.prvIdleTask||, CODE, READONLY, ALIGN=2

                  prvIdleTask PROC
;;;2691    */
;;;2692   static portTASK_FUNCTION( prvIdleTask, pvParameters )
000000  4e07              LDR      r6,|L3.32|
;;;2693   {
;;;2694   	/* Stop warnings. */
;;;2695   	( void ) pvParameters;
;;;2696   
;;;2697   	for( ;; )
;;;2698   	{
;;;2699   		/* See if any tasks have been deleted. */
;;;2700   		prvCheckTasksWaitingTermination();
;;;2701   
;;;2702   		#if ( configUSE_PREEMPTION == 0 )
;;;2703   		{
;;;2704   			/* If we are not using preemption we keep forcing a task switch to
;;;2705   			see if any other task has become available.  If we are using
;;;2706   			preemption we don't need to do this as any task becoming available
;;;2707   			will automatically get the processor anyway. */
;;;2708   			taskYIELD();
;;;2709   		}
;;;2710   		#endif /* configUSE_PREEMPTION */
;;;2711   
;;;2712   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
;;;2713   		{
;;;2714   			/* When using preemption tasks of equal priority will be
;;;2715   			timesliced.  If a task that is sharing the idle priority is ready
;;;2716   			to run then the idle task should yield before the end of the
;;;2717   			timeslice.
;;;2718   
;;;2719   			A critical region is not required here as we are just reading from
;;;2720   			the list, and an occasional incorrect value will not matter.  If
;;;2721   			the ready list at the idle priority contains more than one task
;;;2722   			then a task other than the idle task is ready to execute. */
;;;2723   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
;;;2724   			{
;;;2725   				taskYIELD();
000002  f04f5480          MOV      r4,#0x10000000
000006  4d07              LDR      r5,|L3.36|
                  |L3.8|
000008  f7fffffe          BL       prvCheckTasksWaitingTermination
00000c  6830              LDR      r0,[r6,#0]            ;2723  ; pxReadyTasksLists
00000e  2801              CMP      r0,#1                 ;2723
000010  d9fa              BLS      |L3.8|
000012  602c              STR      r4,[r5,#0]
000014  f3bf8f4f          DSB      
000018  f3bf8f6f          ISB      
00001c  e7f4              B        |L3.8|
;;;2726   			}
;;;2727   			else
;;;2728   			{
;;;2729   				mtCOVERAGE_TEST_MARKER();
;;;2730   			}
;;;2731   		}
;;;2732   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
;;;2733   
;;;2734   		#if ( configUSE_IDLE_HOOK == 1 )
;;;2735   		{
;;;2736   			extern void vApplicationIdleHook( void );
;;;2737   
;;;2738   			/* Call the user defined function from within the idle task.  This
;;;2739   			allows the application designer to add background functionality
;;;2740   			without the overhead of a separate task.
;;;2741   			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
;;;2742   			CALL A FUNCTION THAT MIGHT BLOCK. */
;;;2743   			vApplicationIdleHook();
;;;2744   		}
;;;2745   		#endif /* configUSE_IDLE_HOOK */
;;;2746   
;;;2747   		/* This conditional compilation should use inequality to 0, not equality
;;;2748   		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
;;;2749   		user defined low power mode	implementations require
;;;2750   		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
;;;2751   		#if ( configUSE_TICKLESS_IDLE != 0 )
;;;2752   		{
;;;2753   		TickType_t xExpectedIdleTime;
;;;2754   
;;;2755   			/* It is not desirable to suspend then resume the scheduler on
;;;2756   			each iteration of the idle task.  Therefore, a preliminary
;;;2757   			test of the expected idle time is performed without the
;;;2758   			scheduler suspended.  The result here is not necessarily
;;;2759   			valid. */
;;;2760   			xExpectedIdleTime = prvGetExpectedIdleTime();
;;;2761   
;;;2762   			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;2763   			{
;;;2764   				vTaskSuspendAll();
;;;2765   				{
;;;2766   					/* Now the scheduler is suspended, the expected idle
;;;2767   					time can be sampled again, and this time its value can
;;;2768   					be used. */
;;;2769   					configASSERT( xNextTaskUnblockTime >= xTickCount );
;;;2770   					xExpectedIdleTime = prvGetExpectedIdleTime();
;;;2771   
;;;2772   					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;2773   					{
;;;2774   						traceLOW_POWER_IDLE_BEGIN();
;;;2775   						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
;;;2776   						traceLOW_POWER_IDLE_END();
;;;2777   					}
;;;2778   					else
;;;2779   					{
;;;2780   						mtCOVERAGE_TEST_MARKER();
;;;2781   					}
;;;2782   				}
;;;2783   				( void ) xTaskResumeAll();
;;;2784   			}
;;;2785   			else
;;;2786   			{
;;;2787   				mtCOVERAGE_TEST_MARKER();
;;;2788   			}
;;;2789   		}
;;;2790   		#endif /* configUSE_TICKLESS_IDLE */
;;;2791   	}
;;;2792   }
;;;2793   /*-----------------------------------------------------------*/
                          ENDP

00001e  0000              DCW      0x0000
                  |L3.32|
                          DCD      ||.bss||
                  |L3.36|
                          DCD      0xe000ed04

                          AREA ||i.prvResetNextTaskUnblockTime||, CODE, READONLY, ALIGN=2

                  prvResetNextTaskUnblockTime PROC
;;;3348   
;;;3349   static void prvResetNextTaskUnblockTime( void )
000000  4806              LDR      r0,|L4.28|
;;;3350   {
;;;3351   TCB_t *pxTCB;
;;;3352   
;;;3353   	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
000002  6b01              LDR      r1,[r0,#0x30]  ; pxDelayedTaskList
000004  6809              LDR      r1,[r1,#0]
000006  b129              CBZ      r1,|L4.20|
;;;3354   	{
;;;3355   		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
;;;3356   		the maximum possible value so it is	extremely unlikely that the
;;;3357   		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
;;;3358   		there is an item in the delayed list. */
;;;3359   		xNextTaskUnblockTime = portMAX_DELAY;
;;;3360   	}
;;;3361   	else
;;;3362   	{
;;;3363   		/* The new current delayed list is not empty, get the value of
;;;3364   		the item at the head of the delayed list.  This is the time at
;;;3365   		which the task at the head of the delayed list should be removed
;;;3366   		from the Blocked state. */
;;;3367   		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
000008  6b01              LDR      r1,[r0,#0x30]  ; pxDelayedTaskList
00000a  68c9              LDR      r1,[r1,#0xc]
00000c  68c9              LDR      r1,[r1,#0xc]
;;;3368   		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
00000e  6849              LDR      r1,[r1,#4]
                  |L4.16|
000010  6281              STR      r1,[r0,#0x28]         ;3359  ; xNextTaskUnblockTime
;;;3369   	}
;;;3370   }
000012  4770              BX       lr
                  |L4.20|
000014  f04f31ff          MOV      r1,#0xffffffff        ;3359
000018  e7fa              B        |L4.16|
;;;3371   /*-----------------------------------------------------------*/
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      ||.data||

                          AREA ||i.prvTaskIsTaskSuspended||, CODE, READONLY, ALIGN=2

                  prvTaskIsTaskSuspended PROC
;;;1372   
;;;1373   	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
000000  4b06              LDR      r3,|L5.28|
;;;1374   	{
;;;1375   	BaseType_t xReturn = pdFALSE;
;;;1376   	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
;;;1377   
;;;1378   		/* Accesses xPendingReadyList so must be called from a critical
;;;1379   		section. */
;;;1380   
;;;1381   		/* It does not make sense to check if the calling task is suspended. */
;;;1382   		configASSERT( xTask );
;;;1383   
;;;1384   		/* Is the task being resumed actually in the suspended list? */
;;;1385   		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
000002  6942              LDR      r2,[r0,#0x14]
000004  2100              MOVS     r1,#0                 ;1375
000006  429a              CMP      r2,r3
000008  d106              BNE      |L5.24|
;;;1386   		{
;;;1387   			/* Has the task already been resumed from within an ISR? */
;;;1388   			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
00000a  6a80              LDR      r0,[r0,#0x28]
00000c  f1a30228          SUB      r2,r3,#0x28
000010  4290              CMP      r0,r2
000012  d001              BEQ      |L5.24|
;;;1389   			{
;;;1390   				/* Is it in the suspended list because it is in the	Suspended
;;;1391   				state, or because is is blocked with no timeout? */
;;;1392   				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
000014  b900              CBNZ     r0,|L5.24|
;;;1393   				{
;;;1394   					xReturn = pdTRUE;
000016  2101              MOVS     r1,#1
                  |L5.24|
;;;1395   				}
;;;1396   				else
;;;1397   				{
;;;1398   					mtCOVERAGE_TEST_MARKER();
;;;1399   				}
;;;1400   			}
;;;1401   			else
;;;1402   			{
;;;1403   				mtCOVERAGE_TEST_MARKER();
;;;1404   			}
;;;1405   		}
;;;1406   		else
;;;1407   		{
;;;1408   			mtCOVERAGE_TEST_MARKER();
;;;1409   		}
;;;1410   
;;;1411   		return xReturn;
000018  4608              MOV      r0,r1
;;;1412   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
00001a  4770              BX       lr
;;;1413   
                          ENDP

                  |L5.28|
                          DCD      ||.bss||+0xb4

                          AREA ||i.pvTaskIncrementMutexHeldCount||, CODE, READONLY, ALIGN=2

                  pvTaskIncrementMutexHeldCount PROC
;;;3886   
;;;3887   	void *pvTaskIncrementMutexHeldCount( void )
000000  4904              LDR      r1,|L6.20|
;;;3888   	{
;;;3889   		/* If xSemaphoreCreateMutex() is called before any tasks have been created
;;;3890   		then pxCurrentTCB will be NULL. */
;;;3891   		if( pxCurrentTCB != NULL )
000002  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
000004  b118              CBZ      r0,|L6.14|
;;;3892   		{
;;;3893   			( pxCurrentTCB->uxMutexesHeld )++;
000006  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
000008  6c82              LDR      r2,[r0,#0x48]
00000a  1c52              ADDS     r2,r2,#1
00000c  6482              STR      r2,[r0,#0x48]
                  |L6.14|
;;;3894   		}
;;;3895   
;;;3896   		return pxCurrentTCB;
00000e  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
;;;3897   	}
000010  4770              BX       lr
;;;3898   
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      ||.data||

                          AREA ||i.ulTaskNotifyTake||, CODE, READONLY, ALIGN=2

                  ulTaskNotifyTake PROC
;;;3903   
;;;3904   	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3905   	{
000004  460c              MOV      r4,r1
000006  4606              MOV      r6,r0
;;;3906   	TickType_t xTimeToWake;
;;;3907   	uint32_t ulReturn;
;;;3908   
;;;3909   		taskENTER_CRITICAL();
000008  f7fffffe          BL       vPortEnterCritical
;;;3910   		{
;;;3911   			/* Only block if the notification count is not already non-zero. */
;;;3912   			if( pxCurrentTCB->ulNotifiedValue == 0UL )
00000c  4d20              LDR      r5,|L7.144|
00000e  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000010  6cc0              LDR      r0,[r0,#0x4c]
000012  b9f0              CBNZ     r0,|L7.82|
;;;3913   			{
;;;3914   				/* Mark this task as waiting for a notification. */
;;;3915   				pxCurrentTCB->eNotifyState = eWaitingNotification;
000014  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000016  2701              MOVS     r7,#1
000018  f8807050          STRB     r7,[r0,#0x50]
;;;3916   
;;;3917   				if( xTicksToWait > ( TickType_t ) 0 )
00001c  b1cc              CBZ      r4,|L7.82|
;;;3918   				{
;;;3919   					/* The task is going to block.  First it must be removed
;;;3920   					from the ready list. */
;;;3921   					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
00001e  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000020  1d00              ADDS     r0,r0,#4
000022  f7fffffe          BL       uxListRemove
000026  b930              CBNZ     r0,|L7.54|
;;;3922   					{
;;;3923   						/* The current task must be in a ready list, so there is
;;;3924   						no need to check, and the port reset macro can be called
;;;3925   						directly. */
;;;3926   						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
000028  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00002a  f890002c          LDRB     r0,[r0,#0x2c]
00002e  4087              LSLS     r7,r7,r0
000030  6928              LDR      r0,[r5,#0x10]  ; uxTopReadyPriority
000032  43b8              BICS     r0,r0,r7
000034  6128              STR      r0,[r5,#0x10]  ; uxTopReadyPriority
                  |L7.54|
;;;3927   					}
;;;3928   					else
;;;3929   					{
;;;3930   						mtCOVERAGE_TEST_MARKER();
;;;3931   					}
;;;3932   
;;;3933   					#if ( INCLUDE_vTaskSuspend == 1 )
;;;3934   					{
;;;3935   						if( xTicksToWait == portMAX_DELAY )
000036  1c60              ADDS     r0,r4,#1
000038  d017              BEQ      |L7.106|
;;;3936   						{
;;;3937   							/* Add the task to the suspended task list instead
;;;3938   							of a delayed task list to ensure the task is not
;;;3939   							woken by a timing event.  It will block
;;;3940   							indefinitely. */
;;;3941   							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
;;;3942   						}
;;;3943   						else
;;;3944   						{
;;;3945   							/* Calculate the time at which the task should be
;;;3946   							woken if no notification events occur.  This may
;;;3947   							overflow but this doesn't matter, the scheduler will
;;;3948   							handle it. */
;;;3949   							xTimeToWake = xTickCount + xTicksToWait;
00003a  68e8              LDR      r0,[r5,#0xc]  ; xTickCount
00003c  4420              ADD      r0,r0,r4
;;;3950   							prvAddCurrentTaskToDelayedList( xTimeToWake );
00003e  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L7.66|
;;;3951   						}
;;;3952   					}
;;;3953   					#else /* INCLUDE_vTaskSuspend */
;;;3954   					{
;;;3955   							/* Calculate the time at which the task should be
;;;3956   							woken if the event does not occur.  This may
;;;3957   							overflow but this doesn't matter, the scheduler will
;;;3958   							handle it. */
;;;3959   							xTimeToWake = xTickCount + xTicksToWait;
;;;3960   							prvAddCurrentTaskToDelayedList( xTimeToWake );
;;;3961   					}
;;;3962   					#endif /* INCLUDE_vTaskSuspend */
;;;3963   
;;;3964   					traceTASK_NOTIFY_TAKE_BLOCK();
;;;3965   
;;;3966   					/* All ports are written to allow a yield in a critical
;;;3967   					section (some will yield immediately, others wait until the
;;;3968   					critical section exits) - but it is not something that
;;;3969   					application code should ever do. */
;;;3970   					portYIELD_WITHIN_API();
000042  4914              LDR      r1,|L7.148|
000044  f04f5080          MOV      r0,#0x10000000
000048  6008              STR      r0,[r1,#0]
00004a  f3bf8f4f          DSB      
00004e  f3bf8f6f          ISB      
                  |L7.82|
;;;3971   				}
;;;3972   				else
;;;3973   				{
;;;3974   					mtCOVERAGE_TEST_MARKER();
;;;3975   				}
;;;3976   			}
;;;3977   			else
;;;3978   			{
;;;3979   				mtCOVERAGE_TEST_MARKER();
;;;3980   			}
;;;3981   		}
;;;3982   		taskEXIT_CRITICAL();
000052  f7fffffe          BL       vPortExitCritical
;;;3983   
;;;3984   		taskENTER_CRITICAL();
000056  f7fffffe          BL       vPortEnterCritical
;;;3985   		{
;;;3986   			traceTASK_NOTIFY_TAKE();
;;;3987   			ulReturn = pxCurrentTCB->ulNotifiedValue;
00005a  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00005c  6cc4              LDR      r4,[r0,#0x4c]
00005e  2200              MOVS     r2,#0
;;;3988   
;;;3989   			if( ulReturn != 0UL )
000060  b16c              CBZ      r4,|L7.126|
;;;3990   			{
;;;3991   				if( xClearCountOnExit != pdFALSE )
000062  b146              CBZ      r6,|L7.118|
;;;3992   				{
;;;3993   					pxCurrentTCB->ulNotifiedValue = 0UL;
000064  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000066  64c2              STR      r2,[r0,#0x4c]
000068  e009              B        |L7.126|
                  |L7.106|
00006a  6829              LDR      r1,[r5,#0]            ;3941  ; pxCurrentTCB
00006c  480a              LDR      r0,|L7.152|
00006e  1d09              ADDS     r1,r1,#4              ;3941
000070  f7fffffe          BL       vListInsertEnd
000074  e7e5              B        |L7.66|
                  |L7.118|
;;;3994   				}
;;;3995   				else
;;;3996   				{
;;;3997   					( pxCurrentTCB->ulNotifiedValue )--;
000076  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000078  6cc8              LDR      r0,[r1,#0x4c]
00007a  1e40              SUBS     r0,r0,#1
00007c  64c8              STR      r0,[r1,#0x4c]
                  |L7.126|
;;;3998   				}
;;;3999   			}
;;;4000   			else
;;;4001   			{
;;;4002   				mtCOVERAGE_TEST_MARKER();
;;;4003   			}
;;;4004   
;;;4005   			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
00007e  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000080  f8802050          STRB     r2,[r0,#0x50]
;;;4006   		}
;;;4007   		taskEXIT_CRITICAL();
000084  f7fffffe          BL       vPortExitCritical
;;;4008   
;;;4009   		return ulReturn;
000088  4620              MOV      r0,r4
;;;4010   	}
00008a  e8bd81f0          POP      {r4-r8,pc}
;;;4011   
                          ENDP

00008e  0000              DCW      0x0000
                  |L7.144|
                          DCD      ||.data||
                  |L7.148|
                          DCD      0xe000ed04
                  |L7.152|
                          DCD      ||.bss||+0xb4

                          AREA ||i.uxTaskGetNumberOfTasks||, CODE, READONLY, ALIGN=2

                  uxTaskGetNumberOfTasks PROC
;;;1809   
;;;1810   UBaseType_t uxTaskGetNumberOfTasks( void )
000000  4801              LDR      r0,|L8.8|
;;;1811   {
;;;1812   	/* A critical section is not required because the variables are of type
;;;1813   	BaseType_t. */
;;;1814   	return uxCurrentNumberOfTasks;
000002  6880              LDR      r0,[r0,#8]  ; uxCurrentNumberOfTasks
;;;1815   }
000004  4770              BX       lr
;;;1816   /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      ||.data||

                          AREA ||i.uxTaskPriorityGet||, CODE, READONLY, ALIGN=2

                  uxTaskPriorityGet PROC
;;;1057   
;;;1058   	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
000000  b510              PUSH     {r4,lr}
;;;1059   	{
000002  4604              MOV      r4,r0
;;;1060   	TCB_t *pxTCB;
;;;1061   	UBaseType_t uxReturn;
;;;1062   
;;;1063   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1064   		{
;;;1065   			/* If null is passed in here then it is the priority of the that
;;;1066   			called uxTaskPriorityGet() that is being queried. */
;;;1067   			pxTCB = prvGetTCBFromHandle( xTask );
000008  b90c              CBNZ     r4,|L9.14|
00000a  4803              LDR      r0,|L9.24|
00000c  6804              LDR      r4,[r0,#0]  ; pxCurrentTCB
                  |L9.14|
;;;1068   			uxReturn = pxTCB->uxPriority;
00000e  6ae4              LDR      r4,[r4,#0x2c]
;;;1069   		}
;;;1070   		taskEXIT_CRITICAL();
000010  f7fffffe          BL       vPortExitCritical
;;;1071   
;;;1072   		return uxReturn;
000014  4620              MOV      r0,r4
;;;1073   	}
000016  bd10              POP      {r4,pc}
;;;1074   
                          ENDP

                  |L9.24|
                          DCD      ||.data||

                          AREA ||i.uxTaskPriorityGetFromISR||, CODE, READONLY, ALIGN=2

                  uxTaskPriorityGetFromISR PROC
;;;1079   
;;;1080   	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
000000  2210              MOVS     r2,#0x10
000002  f3ef8111          MRS      r1,BASEPRI
000006  f3828811          MSR      BASEPRI,r2
00000a  f3bf8f4f          DSB      
00000e  f3bf8f6f          ISB      
;;;1081   	{
000012  b908              CBNZ     r0,|L10.24|
;;;1082   	TCB_t *pxTCB;
;;;1083   	UBaseType_t uxReturn, uxSavedInterruptState;
;;;1084   
;;;1085   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1086   		maximum	system call (or maximum API call) interrupt priority.
;;;1087   		Interrupts that are	above the maximum system call priority are keep
;;;1088   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1089   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1090   		is defined in FreeRTOSConfig.h then
;;;1091   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1092   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1093   		been assigned a priority above the configured maximum system call
;;;1094   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1095   		from interrupts	that have been assigned a priority at or (logically)
;;;1096   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1097   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1098   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1099   		provided on the following link:
;;;1100   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1101   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1102   
;;;1103   		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
;;;1104   		{
;;;1105   			/* If null is passed in here then it is the priority of the calling
;;;1106   			task that is being queried. */
;;;1107   			pxTCB = prvGetTCBFromHandle( xTask );
000014  4802              LDR      r0,|L10.32|
000016  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
                  |L10.24|
;;;1108   			uxReturn = pxTCB->uxPriority;
000018  6ac0              LDR      r0,[r0,#0x2c]
00001a  f3818811          MSR      BASEPRI,r1
;;;1109   		}
;;;1110   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
;;;1111   
;;;1112   		return uxReturn;
;;;1113   	}
00001e  4770              BX       lr
;;;1114   
                          ENDP

                  |L10.32|
                          DCD      ||.data||

                          AREA ||i.uxTaskResetEventItemValue||, CODE, READONLY, ALIGN=2

                  uxTaskResetEventItemValue PROC
;;;3870   
;;;3871   TickType_t uxTaskResetEventItemValue( void )
000000  4904              LDR      r1,|L11.20|
;;;3872   {
;;;3873   TickType_t uxReturn;
;;;3874   
;;;3875   	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
000002  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
;;;3876   
;;;3877   	/* Reset the event list item to its normal value - so it can be used with
;;;3878   	queues and semaphores. */
;;;3879   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000004  680a              LDR      r2,[r1,#0]  ; pxCurrentTCB
000006  6980              LDR      r0,[r0,#0x18]         ;3875
000008  6ad2              LDR      r2,[r2,#0x2c]
00000a  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00000c  f1c20205          RSB      r2,r2,#5
000010  618a              STR      r2,[r1,#0x18]
;;;3880   
;;;3881   	return uxReturn;
;;;3882   }
000012  4770              BX       lr
;;;3883   /*-----------------------------------------------------------*/
                          ENDP

                  |L11.20|
                          DCD      ||.data||

                          AREA ||i.vTaskDelay||, CODE, READONLY, ALIGN=2

                  vTaskDelay PROC
;;;921    
;;;922    	void vTaskDelay( const TickType_t xTicksToDelay )
000000  b570              PUSH     {r4-r6,lr}
;;;923    	{
000002  0002              MOVS     r2,r0
000004  d018              BEQ      |L12.56|
;;;924    	TickType_t xTimeToWake;
;;;925    	BaseType_t xAlreadyYielded = pdFALSE;
;;;926    
;;;927    
;;;928    		/* A delay time of zero just forces a reschedule. */
;;;929    		if( xTicksToDelay > ( TickType_t ) 0U )
;;;930    		{
;;;931    			configASSERT( uxSchedulerSuspended == 0 );
;;;932    			vTaskSuspendAll();
000006  f7fffffe          BL       vTaskSuspendAll
;;;933    			{
;;;934    				traceTASK_DELAY();
;;;935    
;;;936    				/* A task that is removed from the event list while the
;;;937    				scheduler is suspended will not get placed in the ready
;;;938    				list or removed from the blocked list until the scheduler
;;;939    				is resumed.
;;;940    
;;;941    				This task cannot be in an event list as it is the currently
;;;942    				executing task. */
;;;943    
;;;944    				/* Calculate the time to wake - this may overflow but this is
;;;945    				not a problem. */
;;;946    				xTimeToWake = xTickCount + xTicksToDelay;
00000a  4c10              LDR      r4,|L12.76|
00000c  68e0              LDR      r0,[r4,#0xc]  ; xTickCount
00000e  1885              ADDS     r5,r0,r2
;;;947    
;;;948    				/* We must remove ourselves from the ready list before adding
;;;949    				ourselves to the blocked list as the same list item is used for
;;;950    				both lists. */
;;;951    				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
000010  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000012  1d00              ADDS     r0,r0,#4
000014  f7fffffe          BL       uxListRemove
000018  b938              CBNZ     r0,|L12.42|
;;;952    				{
;;;953    					/* The current task must be in a ready list, so there is
;;;954    					no need to check, and the port reset macro can be called
;;;955    					directly. */
;;;956    					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
00001a  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
00001c  f890102c          LDRB     r1,[r0,#0x2c]
000020  2001              MOVS     r0,#1
000022  4088              LSLS     r0,r0,r1
000024  6921              LDR      r1,[r4,#0x10]  ; uxTopReadyPriority
000026  4381              BICS     r1,r1,r0
000028  6121              STR      r1,[r4,#0x10]  ; uxTopReadyPriority
                  |L12.42|
;;;957    				}
;;;958    				else
;;;959    				{
;;;960    					mtCOVERAGE_TEST_MARKER();
;;;961    				}
;;;962    				prvAddCurrentTaskToDelayedList( xTimeToWake );
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;963    			}
;;;964    			xAlreadyYielded = xTaskResumeAll();
000030  f7fffffe          BL       xTaskResumeAll
000034  2800              CMP      r0,#0
000036  d107              BNE      |L12.72|
                  |L12.56|
;;;965    		}
;;;966    		else
;;;967    		{
;;;968    			mtCOVERAGE_TEST_MARKER();
;;;969    		}
;;;970    
;;;971    		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;972    		have put ourselves to sleep. */
;;;973    		if( xAlreadyYielded == pdFALSE )
;;;974    		{
;;;975    			portYIELD_WITHIN_API();
000038  4905              LDR      r1,|L12.80|
00003a  f04f5080          MOV      r0,#0x10000000
00003e  6008              STR      r0,[r1,#0]
000040  f3bf8f4f          DSB      
000044  f3bf8f6f          ISB      
                  |L12.72|
;;;976    		}
;;;977    		else
;;;978    		{
;;;979    			mtCOVERAGE_TEST_MARKER();
;;;980    		}
;;;981    	}
000048  bd70              POP      {r4-r6,pc}
;;;982    
                          ENDP

00004a  0000              DCW      0x0000
                  |L12.76|
                          DCD      ||.data||
                  |L12.80|
                          DCD      0xe000ed04

                          AREA ||i.vTaskDelayUntil||, CODE, READONLY, ALIGN=2

                  vTaskDelayUntil PROC
;;;825    
;;;826    	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
000000  b570              PUSH     {r4-r6,lr}
;;;827    	{
000002  460c              MOV      r4,r1
000004  4606              MOV      r6,r0
;;;828    	TickType_t xTimeToWake;
;;;829    	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
000006  2200              MOVS     r2,#0
;;;830    
;;;831    		configASSERT( pxPreviousWakeTime );
;;;832    		configASSERT( ( xTimeIncrement > 0U ) );
;;;833    		configASSERT( uxSchedulerSuspended == 0 );
;;;834    
;;;835    		vTaskSuspendAll();
000008  f7fffffe          BL       vTaskSuspendAll
;;;836    		{
;;;837    			/* Minor optimisation.  The tick count cannot change in this
;;;838    			block. */
;;;839    			const TickType_t xConstTickCount = xTickCount;
00000c  4d16              LDR      r5,|L13.104|
00000e  68e8              LDR      r0,[r5,#0xc]  ; xTickCount
;;;840    
;;;841    			/* Generate the tick time at which the task wants to wake. */
;;;842    			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
000010  6833              LDR      r3,[r6,#0]
000012  441c              ADD      r4,r4,r3
;;;843    
;;;844    			if( xConstTickCount < *pxPreviousWakeTime )
000014  4283              CMP      r3,r0
000016  d902              BLS      |L13.30|
;;;845    			{
;;;846    				/* The tick count has overflowed since this function was
;;;847    				lasted called.  In this case the only time we should ever
;;;848    				actually delay is if the wake time has also	overflowed,
;;;849    				and the wake time is greater than the tick time.  When this
;;;850    				is the case it is as if neither time had overflowed. */
;;;851    				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
000018  42a3              CMP      r3,r4
00001a  d802              BHI      |L13.34|
00001c  e004              B        |L13.40|
                  |L13.30|
;;;852    				{
;;;853    					xShouldDelay = pdTRUE;
;;;854    				}
;;;855    				else
;;;856    				{
;;;857    					mtCOVERAGE_TEST_MARKER();
;;;858    				}
;;;859    			}
;;;860    			else
;;;861    			{
;;;862    				/* The tick time has not overflowed.  In this case we will
;;;863    				delay if either the wake time has overflowed, and/or the
;;;864    				tick time is less than the wake time. */
;;;865    				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
00001e  42a3              CMP      r3,r4
000020  d801              BHI      |L13.38|
                  |L13.34|
000022  4284              CMP      r4,r0
000024  d900              BLS      |L13.40|
                  |L13.38|
;;;866    				{
;;;867    					xShouldDelay = pdTRUE;
000026  2201              MOVS     r2,#1
                  |L13.40|
;;;868    				}
;;;869    				else
;;;870    				{
;;;871    					mtCOVERAGE_TEST_MARKER();
;;;872    				}
;;;873    			}
;;;874    
;;;875    			/* Update the wake time ready for the next call. */
;;;876    			*pxPreviousWakeTime = xTimeToWake;
;;;877    
;;;878    			if( xShouldDelay != pdFALSE )
000028  6034              STR      r4,[r6,#0]
00002a  b17a              CBZ      r2,|L13.76|
;;;879    			{
;;;880    				traceTASK_DELAY_UNTIL();
;;;881    
;;;882    				/* Remove the task from the ready list before adding it to the
;;;883    				blocked list as the same list item is used for both lists. */
;;;884    				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
00002c  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00002e  1d00              ADDS     r0,r0,#4
000030  f7fffffe          BL       uxListRemove
000034  b938              CBNZ     r0,|L13.70|
;;;885    				{
;;;886    					/* The current task must be in a ready list, so there is
;;;887    					no need to check, and the port reset macro can be called
;;;888    					directly. */
;;;889    					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
000036  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000038  f890102c          LDRB     r1,[r0,#0x2c]
00003c  2001              MOVS     r0,#1
00003e  4088              LSLS     r0,r0,r1
000040  6929              LDR      r1,[r5,#0x10]  ; uxTopReadyPriority
000042  4381              BICS     r1,r1,r0
000044  6129              STR      r1,[r5,#0x10]  ; uxTopReadyPriority
                  |L13.70|
;;;890    				}
;;;891    				else
;;;892    				{
;;;893    					mtCOVERAGE_TEST_MARKER();
;;;894    				}
;;;895    
;;;896    				prvAddCurrentTaskToDelayedList( xTimeToWake );
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L13.76|
;;;897    			}
;;;898    			else
;;;899    			{
;;;900    				mtCOVERAGE_TEST_MARKER();
;;;901    			}
;;;902    		}
;;;903    		xAlreadyYielded = xTaskResumeAll();
00004c  f7fffffe          BL       xTaskResumeAll
;;;904    
;;;905    		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;906    		have put ourselves to sleep. */
;;;907    		if( xAlreadyYielded == pdFALSE )
000050  2800              CMP      r0,#0
000052  d107              BNE      |L13.100|
;;;908    		{
;;;909    			portYIELD_WITHIN_API();
000054  4905              LDR      r1,|L13.108|
000056  f04f5080          MOV      r0,#0x10000000
00005a  6008              STR      r0,[r1,#0]
00005c  f3bf8f4f          DSB      
000060  f3bf8f6f          ISB      
                  |L13.100|
;;;910    		}
;;;911    		else
;;;912    		{
;;;913    			mtCOVERAGE_TEST_MARKER();
;;;914    		}
;;;915    	}
000064  bd70              POP      {r4-r6,pc}
;;;916    
                          ENDP

000066  0000              DCW      0x0000
                  |L13.104|
                          DCD      ||.data||
                  |L13.108|
                          DCD      0xe000ed04

                          AREA ||i.vTaskDelete||, CODE, READONLY, ALIGN=2

                  vTaskDelete PROC
;;;743    
;;;744    	void vTaskDelete( TaskHandle_t xTaskToDelete )
000000  b570              PUSH     {r4-r6,lr}
;;;745    	{
000002  4604              MOV      r4,r0
;;;746    	TCB_t *pxTCB;
;;;747    
;;;748    		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;749    		{
;;;750    			/* If null is passed in here then it is the calling task that is
;;;751    			being deleted. */
;;;752    			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
000008  4d1e              LDR      r5,|L14.132|
00000a  b904              CBNZ     r4,|L14.14|
00000c  682c              LDR      r4,[r5,#0]  ; pxCurrentTCB
                  |L14.14|
;;;753    
;;;754    			/* Remove task from the ready list and place in the	termination list.
;;;755    			This will stop the task from be scheduled.  The idle task will check
;;;756    			the termination list and free up any memory allocated by the
;;;757    			scheduler for the TCB and stack. */
;;;758    			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
00000e  1d20              ADDS     r0,r4,#4
000010  f7fffffe          BL       uxListRemove
000014  b958              CBNZ     r0,|L14.46|
;;;759    			{
;;;760    				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
000016  6ae0              LDR      r0,[r4,#0x2c]
000018  4a1b              LDR      r2,|L14.136|
00001a  eb000180          ADD      r1,r0,r0,LSL #2
00001e  f8521021          LDR      r1,[r2,r1,LSL #2]
000022  b921              CBNZ     r1,|L14.46|
000024  2101              MOVS     r1,#1
000026  4081              LSLS     r1,r1,r0
000028  6928              LDR      r0,[r5,#0x10]  ; uxTopReadyPriority
00002a  4388              BICS     r0,r0,r1
00002c  6128              STR      r0,[r5,#0x10]  ; uxTopReadyPriority
                  |L14.46|
;;;761    			}
;;;762    			else
;;;763    			{
;;;764    				mtCOVERAGE_TEST_MARKER();
;;;765    			}
;;;766    
;;;767    			/* Is the task waiting on an event also? */
;;;768    			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
00002e  6aa0              LDR      r0,[r4,#0x28]
000030  b118              CBZ      r0,|L14.58|
;;;769    			{
;;;770    				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000032  f1040018          ADD      r0,r4,#0x18
000036  f7fffffe          BL       uxListRemove
                  |L14.58|
;;;771    			}
;;;772    			else
;;;773    			{
;;;774    				mtCOVERAGE_TEST_MARKER();
;;;775    			}
;;;776    
;;;777    			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
00003a  4813              LDR      r0,|L14.136|
00003c  1d21              ADDS     r1,r4,#4
00003e  30a0              ADDS     r0,r0,#0xa0
000040  f7fffffe          BL       vListInsertEnd
;;;778    
;;;779    			/* Increment the ucTasksDeleted variable so the idle task knows
;;;780    			there is a task that has been deleted and that it should therefore
;;;781    			check the xTasksWaitingTermination list. */
;;;782    			++uxTasksDeleted;
000044  6868              LDR      r0,[r5,#4]  ; uxTasksDeleted
000046  1c40              ADDS     r0,r0,#1
000048  6068              STR      r0,[r5,#4]  ; uxTasksDeleted
;;;783    
;;;784    			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
;;;785    			can detect that the task lists need re-generating. */
;;;786    			uxTaskNumber++;
00004a  6a68              LDR      r0,[r5,#0x24]  ; uxTaskNumber
00004c  1c40              ADDS     r0,r0,#1
;;;787    
;;;788    			traceTASK_DELETE( pxTCB );
;;;789    		}
;;;790    		taskEXIT_CRITICAL();
00004e  6268              STR      r0,[r5,#0x24]  ; uxTaskNumber
000050  f7fffffe          BL       vPortExitCritical
;;;791    
;;;792    		/* Force a reschedule if it is the currently running task that has just
;;;793    		been deleted. */
;;;794    		if( xSchedulerRunning != pdFALSE )
000054  6968              LDR      r0,[r5,#0x14]  ; xSchedulerRunning
000056  2800              CMP      r0,#0
000058  d00a              BEQ      |L14.112|
;;;795    		{
;;;796    			if( pxTCB == pxCurrentTCB )
00005a  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00005c  4284              CMP      r4,r0
00005e  d108              BNE      |L14.114|
;;;797    			{
;;;798    				configASSERT( uxSchedulerSuspended == 0 );
;;;799    
;;;800    				/* The pre-delete hook is primarily for the Windows simulator,
;;;801    				in which Windows specific clean up operations are performed,
;;;802    				after which it is not possible to yield away from this task -
;;;803    				hence xYieldPending is used to latch that a context switch is
;;;804    				required. */
;;;805    				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
;;;806    				portYIELD_WITHIN_API();
000060  490a              LDR      r1,|L14.140|
000062  f04f5080          MOV      r0,#0x10000000
000066  6008              STR      r0,[r1,#0]
000068  f3bf8f4f          DSB      
00006c  f3bf8f6f          ISB      
                  |L14.112|
;;;807    			}
;;;808    			else
;;;809    			{
;;;810    				/* Reset the next expected unblock time in case it referred to
;;;811    				the task that has just been deleted. */
;;;812    				taskENTER_CRITICAL();
;;;813    				{
;;;814    					prvResetNextTaskUnblockTime();
;;;815    				}
;;;816    				taskEXIT_CRITICAL();
;;;817    			}
;;;818    		}
;;;819    	}
000070  bd70              POP      {r4-r6,pc}
                  |L14.114|
000072  f7fffffe          BL       vPortEnterCritical
000076  f7fffffe          BL       prvResetNextTaskUnblockTime
00007a  e8bd4070          POP      {r4-r6,lr}            ;816
00007e  f7ffbffe          B.W      vPortExitCritical
;;;820    
                          ENDP

000082  0000              DCW      0x0000
                  |L14.132|
                          DCD      ||.data||
                  |L14.136|
                          DCD      ||.bss||
                  |L14.140|
                          DCD      0xe000ed04

                          AREA ||i.vTaskEndScheduler||, CODE, READONLY, ALIGN=2

                  vTaskEndScheduler PROC
;;;1621   
;;;1622   void vTaskEndScheduler( void )
000000  2010              MOVS     r0,#0x10
000002  f3808811          MSR      BASEPRI,r0
000006  f3bf8f4f          DSB      
00000a  f3bf8f6f          ISB      
;;;1623   {
;;;1624   	/* Stop the scheduler interrupts and call the portable scheduler end
;;;1625   	routine so the original ISRs can be restored if necessary.  The port
;;;1626   	layer must ensure interrupts enable	bit is left in the correct state. */
;;;1627   	portDISABLE_INTERRUPTS();
;;;1628   	xSchedulerRunning = pdFALSE;
00000e  4902              LDR      r1,|L15.24|
000010  2000              MOVS     r0,#0
000012  6148              STR      r0,[r1,#0x14]  ; xSchedulerRunning
;;;1629   	vPortEndScheduler();
000014  f7ffbffe          B.W      vPortEndScheduler
;;;1630   }
;;;1631   /*----------------------------------------------------------*/
                          ENDP

                  |L15.24|
                          DCD      ||.data||

                          AREA ||i.vTaskMissedYield||, CODE, READONLY, ALIGN=2

                  vTaskMissedYield PROC
;;;2636   
;;;2637   void vTaskMissedYield( void )
000000  4901              LDR      r1,|L16.8|
;;;2638   {
;;;2639   	xYieldPending = pdTRUE;
000002  2001              MOVS     r0,#1
000004  61c8              STR      r0,[r1,#0x1c]  ; xYieldPending
;;;2640   }
000006  4770              BX       lr
;;;2641   /*-----------------------------------------------------------*/
                          ENDP

                  |L16.8|
                          DCD      ||.data||

                          AREA ||i.vTaskNotifyGiveFromISR||, CODE, READONLY, ALIGN=2

                  vTaskNotifyGiveFromISR PROC
;;;4364   
;;;4365   	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4366   	{
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  2010              MOVS     r0,#0x10
00000a  f3ef8611          MRS      r6,BASEPRI
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
;;;4367   	TCB_t * pxTCB;
;;;4368   	eNotifyValue eOriginalNotifyState;
;;;4369   	UBaseType_t uxSavedInterruptStatus;
;;;4370   
;;;4371   		configASSERT( xTaskToNotify );
;;;4372   
;;;4373   		/* RTOS ports that support interrupt nesting have the concept of a
;;;4374   		maximum	system call (or maximum API call) interrupt priority.
;;;4375   		Interrupts that are	above the maximum system call priority are keep
;;;4376   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;4377   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;4378   		is defined in FreeRTOSConfig.h then
;;;4379   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;4380   		failure if a FreeRTOS API function is called from an interrupt that has
;;;4381   		been assigned a priority above the configured maximum system call
;;;4382   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;4383   		from interrupts	that have been assigned a priority at or (logically)
;;;4384   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;4385   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;4386   		simple as possible.  More information (albeit Cortex-M specific) is
;;;4387   		provided on the following link:
;;;4388   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;4389   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;4390   
;;;4391   		pxTCB = ( TCB_t * ) xTaskToNotify;
;;;4392   
;;;4393   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
;;;4394   		{
;;;4395   			eOriginalNotifyState = pxTCB->eNotifyState;
00001a  f8941050          LDRB     r1,[r4,#0x50]
;;;4396   			pxTCB->eNotifyState = eNotified;
00001e  2002              MOVS     r0,#2
000020  f8840050          STRB     r0,[r4,#0x50]
;;;4397   
;;;4398   			/* 'Giving' is equivalent to incrementing a count in a counting
;;;4399   			semaphore. */
;;;4400   			( pxTCB->ulNotifiedValue )++;
000024  6ce0              LDR      r0,[r4,#0x4c]
000026  1c40              ADDS     r0,r0,#1
000028  64e0              STR      r0,[r4,#0x4c]
;;;4401   			
;;;4402   			traceTASK_NOTIFY_GIVE_FROM_ISR();
;;;4403   
;;;4404   			/* If the task is in the blocked state specifically to wait for a
;;;4405   			notification then unblock it now. */
;;;4406   			if( eOriginalNotifyState == eWaitingNotification )
00002a  2901              CMP      r1,#1
00002c  d110              BNE      |L17.80|
;;;4407   			{
;;;4408   				/* The task should not have been on an event list. */
;;;4409   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
;;;4410   
;;;4411   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
00002e  4d13              LDR      r5,|L17.124|
000030  6ae8              LDR      r0,[r5,#0x2c]  ; uxSchedulerSuspended
000032  4688              MOV      r8,r1                 ;4368
000034  b180              CBZ      r0,|L17.88|
;;;4412   				{
;;;4413   					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
;;;4414   					prvAddTaskToReadyList( pxTCB );
;;;4415   				}
;;;4416   				else
;;;4417   				{
;;;4418   					/* The delayed and ready lists cannot be accessed, so hold
;;;4419   					this task pending until the scheduler is resumed. */
;;;4420   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000036  f1040118          ADD      r1,r4,#0x18
00003a  4811              LDR      r0,|L17.128|
                  |L17.60|
00003c  f7fffffe          BL       vListInsertEnd
;;;4421   				}
;;;4422   
;;;4423   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
000040  6ae0              LDR      r0,[r4,#0x2c]
000042  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000044  6ac9              LDR      r1,[r1,#0x2c]
000046  4288              CMP      r0,r1
000048  d902              BLS      |L17.80|
;;;4424   				{
;;;4425   					/* The notified task has a priority above the currently
;;;4426   					executing task so a yield is required. */
;;;4427   					if( pxHigherPriorityTaskWoken != NULL )
00004a  b10f              CBZ      r7,|L17.80|
;;;4428   					{
;;;4429   						*pxHigherPriorityTaskWoken = pdTRUE;
00004c  f8c78000          STR      r8,[r7,#0]
                  |L17.80|
000050  f3868811          MSR      BASEPRI,r6
;;;4430   					}
;;;4431   				}
;;;4432   				else
;;;4433   				{
;;;4434   					mtCOVERAGE_TEST_MARKER();
;;;4435   				}
;;;4436   			}
;;;4437   		}
;;;4438   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;4439   	}
000054  e8bd81f0          POP      {r4-r8,pc}
                  |L17.88|
000058  1d20              ADDS     r0,r4,#4              ;4413
00005a  f7fffffe          BL       uxListRemove
00005e  6ae0              LDR      r0,[r4,#0x2c]         ;4414
000060  692a              LDR      r2,[r5,#0x10]         ;4414  ; uxTopReadyPriority
000062  fa08f100          LSL      r1,r8,r0              ;4414
000066  4311              ORRS     r1,r1,r2              ;4414
000068  6129              STR      r1,[r5,#0x10]         ;4414  ; uxTopReadyPriority
00006a  4905              LDR      r1,|L17.128|
00006c  eb000080          ADD      r0,r0,r0,LSL #2       ;4414
000070  398c              SUBS     r1,r1,#0x8c           ;4414
000072  eb010080          ADD      r0,r1,r0,LSL #2       ;4414
000076  1d21              ADDS     r1,r4,#4              ;4414
000078  e7e0              B        |L17.60|
;;;4440   
                          ENDP

00007a  0000              DCW      0x0000
                  |L17.124|
                          DCD      ||.data||
                  |L17.128|
                          DCD      ||.bss||+0x8c

                          AREA ||i.vTaskPlaceOnEventList||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnEventList PROC
;;;2262   
;;;2263   void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;2264   {
;;;2265   TickType_t xTimeToWake;
;;;2266   
;;;2267   	configASSERT( pxEventList );
;;;2268   
;;;2269   	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
;;;2270   	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
;;;2271   
;;;2272   	/* Place the event list item of the TCB in the appropriate event list.
;;;2273   	This is placed in the list in priority order so the highest priority task
;;;2274   	is the first to be woken by the event.  The queue that contains the event
;;;2275   	list is locked, preventing simultaneous access from interrupts. */
;;;2276   	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
000002  4c11              LDR      r4,|L18.72|
000004  460d              MOV      r5,r1                 ;2264
000006  6821              LDR      r1,[r4,#0]  ; pxCurrentTCB
000008  3118              ADDS     r1,r1,#0x18
00000a  f7fffffe          BL       vListInsert
;;;2277   
;;;2278   	/* The task must be removed from from the ready list before it is added to
;;;2279   	the blocked list as the same list item is used for both lists.  Exclusive
;;;2280   	access to the ready lists guaranteed because the scheduler is locked. */
;;;2281   	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
00000e  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000010  1d00              ADDS     r0,r0,#4
000012  f7fffffe          BL       uxListRemove
000016  b938              CBNZ     r0,|L18.40|
;;;2282   	{
;;;2283   		/* The current task must be in a ready list, so there is no need to
;;;2284   		check, and the port reset macro can be called directly. */
;;;2285   		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
000018  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
00001a  f890102c          LDRB     r1,[r0,#0x2c]
00001e  2001              MOVS     r0,#1
000020  4088              LSLS     r0,r0,r1
000022  6921              LDR      r1,[r4,#0x10]  ; uxTopReadyPriority
000024  4381              BICS     r1,r1,r0
000026  6121              STR      r1,[r4,#0x10]  ; uxTopReadyPriority
                  |L18.40|
;;;2286   	}
;;;2287   	else
;;;2288   	{
;;;2289   		mtCOVERAGE_TEST_MARKER();
;;;2290   	}
;;;2291   
;;;2292   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;2293   	{
;;;2294   		if( xTicksToWait == portMAX_DELAY )
000028  1c68              ADDS     r0,r5,#1
00002a  d005              BEQ      |L18.56|
;;;2295   		{
;;;2296   			/* Add the task to the suspended task list instead of a delayed task
;;;2297   			list to ensure the task is not woken by a timing event.  It will
;;;2298   			block indefinitely. */
;;;2299   			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
;;;2300   		}
;;;2301   		else
;;;2302   		{
;;;2303   			/* Calculate the time at which the task should be woken if the event
;;;2304   			does not occur.  This may overflow but this doesn't matter, the
;;;2305   			scheduler will handle it. */
;;;2306   			xTimeToWake = xTickCount + xTicksToWait;
00002c  68e0              LDR      r0,[r4,#0xc]  ; xTickCount
00002e  4428              ADD      r0,r0,r5
;;;2307   			prvAddCurrentTaskToDelayedList( xTimeToWake );
000030  e8bd4070          POP      {r4-r6,lr}
000034  f7ffbffe          B.W      prvAddCurrentTaskToDelayedList
                  |L18.56|
000038  6821              LDR      r1,[r4,#0]            ;2299  ; pxCurrentTCB
00003a  e8bd4070          POP      {r4-r6,lr}            ;2299
00003e  4803              LDR      r0,|L18.76|
000040  1d09              ADDS     r1,r1,#4              ;2299
000042  f7ffbffe          B.W      vListInsertEnd
;;;2308   		}
;;;2309   	}
;;;2310   	#else /* INCLUDE_vTaskSuspend */
;;;2311   	{
;;;2312   			/* Calculate the time at which the task should be woken if the event does
;;;2313   			not occur.  This may overflow but this doesn't matter, the scheduler
;;;2314   			will handle it. */
;;;2315   			xTimeToWake = xTickCount + xTicksToWait;
;;;2316   			prvAddCurrentTaskToDelayedList( xTimeToWake );
;;;2317   	}
;;;2318   	#endif /* INCLUDE_vTaskSuspend */
;;;2319   }
;;;2320   /*-----------------------------------------------------------*/
                          ENDP

000046  0000              DCW      0x0000
                  |L18.72|
                          DCD      ||.data||
                  |L18.76|
                          DCD      ||.bss||+0xb4

                          AREA ||i.vTaskPlaceOnUnorderedEventList||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnUnorderedEventList PROC
;;;2321   
;;;2322   void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;2323   {
;;;2324   TickType_t xTimeToWake;
;;;2325   
;;;2326   	configASSERT( pxEventList );
;;;2327   
;;;2328   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;2329   	the event groups implementation. */
;;;2330   	configASSERT( uxSchedulerSuspended != 0 );
;;;2331   
;;;2332   	/* Store the item value in the event list item.  It is safe to access the
;;;2333   	event list item here as interrupts won't access the event list item of a
;;;2334   	task that is not in the Blocked state. */
;;;2335   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
000002  4c13              LDR      r4,|L19.80|
000004  4615              MOV      r5,r2                 ;2323
000006  f0414100          ORR      r1,r1,#0x80000000
00000a  6822              LDR      r2,[r4,#0]  ; pxCurrentTCB
;;;2336   
;;;2337   	/* Place the event list item of the TCB at the end of the appropriate event
;;;2338   	list.  It is safe to access the event list here because it is part of an
;;;2339   	event group implementation - and interrupts don't access event groups
;;;2340   	directly (instead they access them indirectly by pending function calls to
;;;2341   	the task level). */
;;;2342   	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
00000c  6191              STR      r1,[r2,#0x18]
00000e  6821              LDR      r1,[r4,#0]  ; pxCurrentTCB
000010  3118              ADDS     r1,r1,#0x18
000012  f7fffffe          BL       vListInsertEnd
;;;2343   
;;;2344   	/* The task must be removed from the ready list before it is added to the
;;;2345   	blocked list.  Exclusive access can be assured to the ready list as the
;;;2346   	scheduler is locked. */
;;;2347   	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
000016  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000018  1d00              ADDS     r0,r0,#4
00001a  f7fffffe          BL       uxListRemove
00001e  b938              CBNZ     r0,|L19.48|
;;;2348   	{
;;;2349   		/* The current task must be in a ready list, so there is no need to
;;;2350   		check, and the port reset macro can be called directly. */
;;;2351   		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
000020  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000022  f890102c          LDRB     r1,[r0,#0x2c]
000026  2001              MOVS     r0,#1
000028  4088              LSLS     r0,r0,r1
00002a  6921              LDR      r1,[r4,#0x10]  ; uxTopReadyPriority
00002c  4381              BICS     r1,r1,r0
00002e  6121              STR      r1,[r4,#0x10]  ; uxTopReadyPriority
                  |L19.48|
;;;2352   	}
;;;2353   	else
;;;2354   	{
;;;2355   		mtCOVERAGE_TEST_MARKER();
;;;2356   	}
;;;2357   
;;;2358   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;2359   	{
;;;2360   		if( xTicksToWait == portMAX_DELAY )
000030  1c68              ADDS     r0,r5,#1
000032  d005              BEQ      |L19.64|
;;;2361   		{
;;;2362   			/* Add the task to the suspended task list instead of a delayed task
;;;2363   			list to ensure it is not woken by a timing event.  It will block
;;;2364   			indefinitely. */
;;;2365   			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
;;;2366   		}
;;;2367   		else
;;;2368   		{
;;;2369   			/* Calculate the time at which the task should be woken if the event
;;;2370   			does not occur.  This may overflow but this doesn't matter, the
;;;2371   			kernel will manage it correctly. */
;;;2372   			xTimeToWake = xTickCount + xTicksToWait;
000034  68e0              LDR      r0,[r4,#0xc]  ; xTickCount
000036  4428              ADD      r0,r0,r5
;;;2373   			prvAddCurrentTaskToDelayedList( xTimeToWake );
000038  e8bd4070          POP      {r4-r6,lr}
00003c  f7ffbffe          B.W      prvAddCurrentTaskToDelayedList
                  |L19.64|
000040  6821              LDR      r1,[r4,#0]            ;2365  ; pxCurrentTCB
000042  e8bd4070          POP      {r4-r6,lr}            ;2365
000046  4803              LDR      r0,|L19.84|
000048  1d09              ADDS     r1,r1,#4              ;2365
00004a  f7ffbffe          B.W      vListInsertEnd
;;;2374   		}
;;;2375   	}
;;;2376   	#else /* INCLUDE_vTaskSuspend */
;;;2377   	{
;;;2378   			/* Calculate the time at which the task should be woken if the event does
;;;2379   			not occur.  This may overflow but this doesn't matter, the kernel
;;;2380   			will manage it correctly. */
;;;2381   			xTimeToWake = xTickCount + xTicksToWait;
;;;2382   			prvAddCurrentTaskToDelayedList( xTimeToWake );
;;;2383   	}
;;;2384   	#endif /* INCLUDE_vTaskSuspend */
;;;2385   }
;;;2386   /*-----------------------------------------------------------*/
                          ENDP

00004e  0000              DCW      0x0000
                  |L19.80|
                          DCD      ||.data||
                  |L19.84|
                          DCD      ||.bss||+0xb4

                          AREA ||i.vTaskPriorityInherit||, CODE, READONLY, ALIGN=2

                  vTaskPriorityInherit PROC
;;;3419   
;;;3420   	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
000000  b570              PUSH     {r4-r6,lr}
;;;3421   	{
;;;3422   	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
000002  0004              MOVS     r4,r0
000004  d039              BEQ      |L20.122|
;;;3423   
;;;3424   		/* If the mutex was given back by an interrupt while the queue was
;;;3425   		locked then the mutex holder might now be NULL. */
;;;3426   		if( pxMutexHolder != NULL )
;;;3427   		{
;;;3428   			/* If the holder of the mutex has a priority below the priority of
;;;3429   			the task attempting to obtain the mutex then it will temporarily
;;;3430   			inherit the priority of the task attempting to obtain the mutex. */
;;;3431   			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
000006  4d1d              LDR      r5,|L20.124|
000008  6ae0              LDR      r0,[r4,#0x2c]
00000a  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
00000c  6ac9              LDR      r1,[r1,#0x2c]
00000e  4288              CMP      r0,r1
000010  d233              BCS      |L20.122|
;;;3432   			{
;;;3433   				/* Adjust the mutex holder state to account for its new
;;;3434   				priority.  Only reset the event list item value if the value is
;;;3435   				not	being used for anything else. */
;;;3436   				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000012  69a0              LDR      r0,[r4,#0x18]
000014  2800              CMP      r0,#0
000016  db04              BLT      |L20.34|
;;;3437   				{
;;;3438   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000018  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00001a  6ac0              LDR      r0,[r0,#0x2c]
00001c  f1c00005          RSB      r0,r0,#5
000020  61a0              STR      r0,[r4,#0x18]
                  |L20.34|
;;;3439   				}
;;;3440   				else
;;;3441   				{
;;;3442   					mtCOVERAGE_TEST_MARKER();
;;;3443   				}
;;;3444   
;;;3445   				/* If the task being modified is in the ready state it will need
;;;3446   				to be moved into a new list. */
;;;3447   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
000022  6ae0              LDR      r0,[r4,#0x2c]
000024  4e16              LDR      r6,|L20.128|
000026  eb000080          ADD      r0,r0,r0,LSL #2
00002a  6961              LDR      r1,[r4,#0x14]
00002c  eb060080          ADD      r0,r6,r0,LSL #2
000030  4281              CMP      r1,r0
000032  d11f              BNE      |L20.116|
;;;3448   				{
;;;3449   					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
000034  1d20              ADDS     r0,r4,#4
000036  f7fffffe          BL       uxListRemove
;;;3450   					{
;;;3451   						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
00003a  2101              MOVS     r1,#1
00003c  b950              CBNZ     r0,|L20.84|
00003e  6ae0              LDR      r0,[r4,#0x2c]
000040  eb000280          ADD      r2,r0,r0,LSL #2
000044  f8562022          LDR      r2,[r6,r2,LSL #2]
000048  b922              CBNZ     r2,|L20.84|
00004a  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
00004c  fa01f000          LSL      r0,r1,r0
000050  4382              BICS     r2,r2,r0
000052  612a              STR      r2,[r5,#0x10]  ; uxTopReadyPriority
                  |L20.84|
;;;3452   					}
;;;3453   					else
;;;3454   					{
;;;3455   						mtCOVERAGE_TEST_MARKER();
;;;3456   					}
;;;3457   
;;;3458   					/* Inherit the priority before being moved into the new list. */
;;;3459   					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
000054  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000056  6ac0              LDR      r0,[r0,#0x2c]
;;;3460   					prvAddTaskToReadyList( pxTCB );
000058  62e0              STR      r0,[r4,#0x2c]
00005a  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
00005c  4081              LSLS     r1,r1,r0
00005e  4311              ORRS     r1,r1,r2
000060  6129              STR      r1,[r5,#0x10]  ; uxTopReadyPriority
000062  eb000080          ADD      r0,r0,r0,LSL #2
000066  eb060080          ADD      r0,r6,r0,LSL #2
00006a  1d21              ADDS     r1,r4,#4
00006c  e8bd4070          POP      {r4-r6,lr}
000070  f7ffbffe          B.W      vListInsertEnd
                  |L20.116|
;;;3461   				}
;;;3462   				else
;;;3463   				{
;;;3464   					/* Just inherit the priority. */
;;;3465   					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
000074  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000076  6ac0              LDR      r0,[r0,#0x2c]
000078  62e0              STR      r0,[r4,#0x2c]
                  |L20.122|
;;;3466   				}
;;;3467   
;;;3468   				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
;;;3469   			}
;;;3470   			else
;;;3471   			{
;;;3472   				mtCOVERAGE_TEST_MARKER();
;;;3473   			}
;;;3474   		}
;;;3475   		else
;;;3476   		{
;;;3477   			mtCOVERAGE_TEST_MARKER();
;;;3478   		}
;;;3479   	}
00007a  bd70              POP      {r4-r6,pc}
;;;3480   
                          ENDP

                  |L20.124|
                          DCD      ||.data||
                  |L20.128|
                          DCD      ||.bss||

                          AREA ||i.vTaskPrioritySet||, CODE, READONLY, ALIGN=2

                  vTaskPrioritySet PROC
;;;1119   
;;;1120   	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1121   	{
;;;1122   	TCB_t *pxTCB;
;;;1123   	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
;;;1124   	BaseType_t xYieldRequired = pdFALSE;
000004  2600              MOVS     r6,#0
000006  460d              MOV      r5,r1                 ;1121
000008  4604              MOV      r4,r0                 ;1121
;;;1125   
;;;1126   		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
;;;1127   
;;;1128   		/* Ensure the new priority is valid. */
;;;1129   		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
00000a  2905              CMP      r1,#5
00000c  d300              BCC      |L21.16|
;;;1130   		{
;;;1131   			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
00000e  2504              MOVS     r5,#4
                  |L21.16|
;;;1132   		}
;;;1133   		else
;;;1134   		{
;;;1135   			mtCOVERAGE_TEST_MARKER();
;;;1136   		}
;;;1137   
;;;1138   		taskENTER_CRITICAL();
000010  f7fffffe          BL       vPortEnterCritical
;;;1139   		{
;;;1140   			/* If null is passed in here then it is the priority of the calling
;;;1141   			task that is being changed. */
;;;1142   			pxTCB = prvGetTCBFromHandle( xTask );
000014  4f24              LDR      r7,|L21.168|
000016  b904              CBNZ     r4,|L21.26|
000018  683c              LDR      r4,[r7,#0]  ; pxCurrentTCB
                  |L21.26|
;;;1143   
;;;1144   			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
;;;1145   
;;;1146   			#if ( configUSE_MUTEXES == 1 )
;;;1147   			{
;;;1148   				uxCurrentBasePriority = pxTCB->uxBasePriority;
;;;1149   			}
;;;1150   			#else
;;;1151   			{
;;;1152   				uxCurrentBasePriority = pxTCB->uxPriority;
;;;1153   			}
;;;1154   			#endif
;;;1155   
;;;1156   			if( uxCurrentBasePriority != uxNewPriority )
00001a  6c60              LDR      r0,[r4,#0x44]
00001c  42a8              CMP      r0,r5
00001e  d03f              BEQ      |L21.160|
;;;1157   			{
;;;1158   				/* The priority change may have readied a task of higher
;;;1159   				priority than the calling task. */
;;;1160   				if( uxNewPriority > uxCurrentBasePriority )
;;;1161   				{
;;;1162   					if( pxTCB != pxCurrentTCB )
;;;1163   					{
;;;1164   						/* The priority of a task other than the currently
;;;1165   						running task is being raised.  Is the priority being
;;;1166   						raised above that of the running task? */
;;;1167   						if( uxNewPriority >= pxCurrentTCB->uxPriority )
;;;1168   						{
;;;1169   							xYieldRequired = pdTRUE;
;;;1170   						}
;;;1171   						else
;;;1172   						{
;;;1173   							mtCOVERAGE_TEST_MARKER();
;;;1174   						}
;;;1175   					}
;;;1176   					else
;;;1177   					{
;;;1178   						/* The priority of the running task is being raised,
;;;1179   						but the running task must already be the highest
;;;1180   						priority task able to run so no yield is required. */
;;;1181   					}
;;;1182   				}
;;;1183   				else if( pxTCB == pxCurrentTCB )
000020  6839              LDR      r1,[r7,#0]  ; pxCurrentTCB
000022  4285              CMP      r5,r0                 ;1160
000024  d906              BLS      |L21.52|
000026  428c              CMP      r4,r1                 ;1162
000028  d007              BEQ      |L21.58|
00002a  6839              LDR      r1,[r7,#0]            ;1167  ; pxCurrentTCB
00002c  6ac9              LDR      r1,[r1,#0x2c]         ;1167
00002e  42a9              CMP      r1,r5                 ;1167
000030  d902              BLS      |L21.56|
000032  e002              B        |L21.58|
                  |L21.52|
000034  428c              CMP      r4,r1
000036  d100              BNE      |L21.58|
                  |L21.56|
;;;1184   				{
;;;1185   					/* Setting the priority of the running task down means
;;;1186   					there may now be another task of higher priority that
;;;1187   					is ready to execute. */
;;;1188   					xYieldRequired = pdTRUE;
000038  2601              MOVS     r6,#1
                  |L21.58|
;;;1189   				}
;;;1190   				else
;;;1191   				{
;;;1192   					/* Setting the priority of any other task down does not
;;;1193   					require a yield as the running task must be above the
;;;1194   					new priority of the task being modified. */
;;;1195   				}
;;;1196   
;;;1197   				/* Remember the ready list the task might be referenced from
;;;1198   				before its uxPriority member is changed so the
;;;1199   				taskRESET_READY_PRIORITY() macro can function correctly. */
;;;1200   				uxPriorityUsedOnEntry = pxTCB->uxPriority;
00003a  6ae1              LDR      r1,[r4,#0x2c]
00003c  4688              MOV      r8,r1
;;;1201   
;;;1202   				#if ( configUSE_MUTEXES == 1 )
;;;1203   				{
;;;1204   					/* Only change the priority being used if the task is not
;;;1205   					currently using an inherited priority. */
;;;1206   					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
00003e  4288              CMP      r0,r1
000040  d100              BNE      |L21.68|
;;;1207   					{
;;;1208   						pxTCB->uxPriority = uxNewPriority;
000042  62e5              STR      r5,[r4,#0x2c]
                  |L21.68|
;;;1209   					}
;;;1210   					else
;;;1211   					{
;;;1212   						mtCOVERAGE_TEST_MARKER();
;;;1213   					}
;;;1214   
;;;1215   					/* The base priority gets set whatever. */
;;;1216   					pxTCB->uxBasePriority = uxNewPriority;
;;;1217   				}
;;;1218   				#else
;;;1219   				{
;;;1220   					pxTCB->uxPriority = uxNewPriority;
;;;1221   				}
;;;1222   				#endif
;;;1223   
;;;1224   				/* Only reset the event list item value if the value is not
;;;1225   				being used for anything else. */
;;;1226   				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000044  6465              STR      r5,[r4,#0x44]
000046  69a0              LDR      r0,[r4,#0x18]
000048  2800              CMP      r0,#0
00004a  db02              BLT      |L21.82|
;;;1227   				{
;;;1228   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00004c  f1c50005          RSB      r0,r5,#5
000050  61a0              STR      r0,[r4,#0x18]
                  |L21.82|
;;;1229   				}
;;;1230   				else
;;;1231   				{
;;;1232   					mtCOVERAGE_TEST_MARKER();
;;;1233   				}
;;;1234   
;;;1235   				/* If the task is in the blocked or suspended list we need do
;;;1236   				nothing more than change it's priority variable. However, if
;;;1237   				the task is in a ready list it needs to be removed and placed
;;;1238   				in the list appropriate to its new priority. */
;;;1239   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
000052  4d16              LDR      r5,|L21.172|
000054  eb080088          ADD      r0,r8,r8,LSL #2
000058  6961              LDR      r1,[r4,#0x14]
00005a  eb050080          ADD      r0,r5,r0,LSL #2
00005e  4281              CMP      r1,r0
000060  d115              BNE      |L21.142|
;;;1240   				{
;;;1241   					/* The task is currently in its ready list - remove before adding
;;;1242   					it to it's new ready list.  As we are in a critical section we
;;;1243   					can do this even if the scheduler is suspended. */
;;;1244   					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
000062  1d20              ADDS     r0,r4,#4
000064  f7fffffe          BL       uxListRemove
000068  2101              MOVS     r1,#1                 ;1169
00006a  b920              CBNZ     r0,|L21.118|
;;;1245   					{
;;;1246   						/* It is known that the task is in its ready list so
;;;1247   						there is no need to check again and the port level
;;;1248   						reset macro can be called directly. */
;;;1249   						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
00006c  693a              LDR      r2,[r7,#0x10]  ; uxTopReadyPriority
00006e  fa01f008          LSL      r0,r1,r8
000072  4382              BICS     r2,r2,r0
000074  613a              STR      r2,[r7,#0x10]  ; uxTopReadyPriority
                  |L21.118|
;;;1250   					}
;;;1251   					else
;;;1252   					{
;;;1253   						mtCOVERAGE_TEST_MARKER();
;;;1254   					}
;;;1255   					prvAddTaskToReadyList( pxTCB );
000076  6ae0              LDR      r0,[r4,#0x2c]
000078  693a              LDR      r2,[r7,#0x10]  ; uxTopReadyPriority
00007a  4081              LSLS     r1,r1,r0
00007c  4311              ORRS     r1,r1,r2
00007e  6139              STR      r1,[r7,#0x10]  ; uxTopReadyPriority
000080  eb000080          ADD      r0,r0,r0,LSL #2
000084  eb050080          ADD      r0,r5,r0,LSL #2
000088  1d21              ADDS     r1,r4,#4
00008a  f7fffffe          BL       vListInsertEnd
                  |L21.142|
;;;1256   				}
;;;1257   				else
;;;1258   				{
;;;1259   					mtCOVERAGE_TEST_MARKER();
;;;1260   				}
;;;1261   
;;;1262   				if( xYieldRequired == pdTRUE )
00008e  b13e              CBZ      r6,|L21.160|
;;;1263   				{
;;;1264   					taskYIELD_IF_USING_PREEMPTION();
000090  4907              LDR      r1,|L21.176|
000092  f04f5080          MOV      r0,#0x10000000
000096  6008              STR      r0,[r1,#0]
000098  f3bf8f4f          DSB      
00009c  f3bf8f6f          ISB      
                  |L21.160|
;;;1265   				}
;;;1266   				else
;;;1267   				{
;;;1268   					mtCOVERAGE_TEST_MARKER();
;;;1269   				}
;;;1270   
;;;1271   				/* Remove compiler warning about unused variables when the port
;;;1272   				optimised task selection is not being used. */
;;;1273   				( void ) uxPriorityUsedOnEntry;
;;;1274   			}
;;;1275   		}
;;;1276   		taskEXIT_CRITICAL();
0000a0  e8bd41f0          POP      {r4-r8,lr}
0000a4  f7ffbffe          B.W      vPortExitCritical
;;;1277   	}
;;;1278   
                          ENDP

                  |L21.168|
                          DCD      ||.data||
                  |L21.172|
                          DCD      ||.bss||
                  |L21.176|
                          DCD      0xe000ed04

                          AREA ||i.vTaskResume||, CODE, READONLY, ALIGN=2

                  vTaskResume PROC
;;;1418   
;;;1419   	void vTaskResume( TaskHandle_t xTaskToResume )
000000  b570              PUSH     {r4-r6,lr}
;;;1420   	{
000002  0004              MOVS     r4,r0
000004  d02c              BEQ      |L22.96|
;;;1421   	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
;;;1422   
;;;1423   		/* It does not make sense to resume the calling task. */
;;;1424   		configASSERT( xTaskToResume );
;;;1425   
;;;1426   		/* The parameter cannot be NULL as it is impossible to resume the
;;;1427   		currently executing task. */
;;;1428   		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
000006  4d17              LDR      r5,|L22.100|
000008  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00000a  4284              CMP      r4,r0
00000c  d028              BEQ      |L22.96|
;;;1429   		{
;;;1430   			taskENTER_CRITICAL();
00000e  f7fffffe          BL       vPortEnterCritical
;;;1431   			{
;;;1432   				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       prvTaskIsTaskSuspended
000018  2801              CMP      r0,#1
00001a  d11d              BNE      |L22.88|
;;;1433   				{
;;;1434   					traceTASK_RESUME( pxTCB );
;;;1435   
;;;1436   					/* As we are in a critical section we can access the ready
;;;1437   					lists even if the scheduler is suspended. */
;;;1438   					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
00001c  1d20              ADDS     r0,r4,#4
00001e  f7fffffe          BL       uxListRemove
;;;1439   					prvAddTaskToReadyList( pxTCB );
000022  6ae0              LDR      r0,[r4,#0x2c]
000024  2101              MOVS     r1,#1
000026  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
000028  4081              LSLS     r1,r1,r0
00002a  4311              ORRS     r1,r1,r2
00002c  6129              STR      r1,[r5,#0x10]  ; uxTopReadyPriority
00002e  490e              LDR      r1,|L22.104|
000030  eb000080          ADD      r0,r0,r0,LSL #2
000034  eb010080          ADD      r0,r1,r0,LSL #2
000038  1d21              ADDS     r1,r4,#4
00003a  f7fffffe          BL       vListInsertEnd
;;;1440   
;;;1441   					/* We may have just resumed a higher priority task. */
;;;1442   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
00003e  6ae0              LDR      r0,[r4,#0x2c]
000040  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000042  6ac9              LDR      r1,[r1,#0x2c]
000044  4288              CMP      r0,r1
000046  d307              BCC      |L22.88|
;;;1443   					{
;;;1444   						/* This yield may not cause the task just resumed to run,
;;;1445   						but will leave the lists in the correct state for the
;;;1446   						next yield. */
;;;1447   						taskYIELD_IF_USING_PREEMPTION();
000048  4908              LDR      r1,|L22.108|
00004a  f04f5080          MOV      r0,#0x10000000
00004e  6008              STR      r0,[r1,#0]
000050  f3bf8f4f          DSB      
000054  f3bf8f6f          ISB      
                  |L22.88|
;;;1448   					}
;;;1449   					else
;;;1450   					{
;;;1451   						mtCOVERAGE_TEST_MARKER();
;;;1452   					}
;;;1453   				}
;;;1454   				else
;;;1455   				{
;;;1456   					mtCOVERAGE_TEST_MARKER();
;;;1457   				}
;;;1458   			}
;;;1459   			taskEXIT_CRITICAL();
000058  e8bd4070          POP      {r4-r6,lr}
00005c  f7ffbffe          B.W      vPortExitCritical
                  |L22.96|
;;;1460   		}
;;;1461   		else
;;;1462   		{
;;;1463   			mtCOVERAGE_TEST_MARKER();
;;;1464   		}
;;;1465   	}
000060  bd70              POP      {r4-r6,pc}
;;;1466   
                          ENDP

000062  0000              DCW      0x0000
                  |L22.100|
                          DCD      ||.data||
                  |L22.104|
                          DCD      ||.bss||
                  |L22.108|
                          DCD      0xe000ed04

                          AREA ||i.vTaskSetTimeOutState||, CODE, READONLY, ALIGN=2

                  vTaskSetTimeOutState PROC
;;;2579   
;;;2580   void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
000000  4902              LDR      r1,|L23.12|
;;;2581   {
;;;2582   	configASSERT( pxTimeOut );
;;;2583   	pxTimeOut->xOverflowCount = xNumOfOverflows;
000002  6a0a              LDR      r2,[r1,#0x20]  ; xNumOfOverflows
;;;2584   	pxTimeOut->xTimeOnEntering = xTickCount;
000004  6002              STR      r2,[r0,#0]
000006  68c9              LDR      r1,[r1,#0xc]  ; xTickCount
000008  6041              STR      r1,[r0,#4]
;;;2585   }
00000a  4770              BX       lr
;;;2586   /*-----------------------------------------------------------*/
                          ENDP

                  |L23.12|
                          DCD      ||.data||

                          AREA ||i.vTaskStartScheduler||, CODE, READONLY, ALIGN=2

                  vTaskStartScheduler PROC
;;;1542   
;;;1543   void vTaskStartScheduler( void )
000000  b51f              PUSH     {r0-r4,lr}
;;;1544   {
;;;1545   BaseType_t xReturn;
;;;1546   
;;;1547   	/* Add the idle task at the lowest priority. */
;;;1548   	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
;;;1549   	{
;;;1550   		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
;;;1551   		be returned by the xTaskGetIdleTaskHandle() function. */
;;;1552   		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;1553   	}
;;;1554   	#else
;;;1555   	{
;;;1556   		/* Create the idle task without storing its handle. */
;;;1557   		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
000002  2400              MOVS     r4,#0
000004  9400              STR      r4,[sp,#0]
000006  9401              STR      r4,[sp,#4]
000008  9402              STR      r4,[sp,#8]
00000a  4623              MOV      r3,r4
00000c  2280              MOVS     r2,#0x80
00000e  a10d              ADR      r1,|L24.68|
000010  480e              LDR      r0,|L24.76|
000012  9403              STR      r4,[sp,#0xc]
000014  f7fffffe          BL       xTaskGenericCreate
;;;1558   	}
;;;1559   	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
;;;1560   
;;;1561   	#if ( configUSE_TIMERS == 1 )
;;;1562   	{
;;;1563   		if( xReturn == pdPASS )
;;;1564   		{
;;;1565   			xReturn = xTimerCreateTimerTask();
;;;1566   		}
;;;1567   		else
;;;1568   		{
;;;1569   			mtCOVERAGE_TEST_MARKER();
;;;1570   		}
;;;1571   	}
;;;1572   	#endif /* configUSE_TIMERS */
;;;1573   
;;;1574   	if( xReturn == pdPASS )
000018  2801              CMP      r0,#1
00001a  d111              BNE      |L24.64|
00001c  2010              MOVS     r0,#0x10
00001e  f3808811          MSR      BASEPRI,r0
000022  f3bf8f4f          DSB      
000026  f3bf8f6f          ISB      
;;;1575   	{
;;;1576   		/* Interrupts are turned off here, to ensure a tick does not occur
;;;1577   		before or during the call to xPortStartScheduler().  The stacks of
;;;1578   		the created tasks contain a status word with interrupts switched on
;;;1579   		so interrupts will automatically get re-enabled when the first task
;;;1580   		starts to run. */
;;;1581   		portDISABLE_INTERRUPTS();
;;;1582   
;;;1583   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;1584   		{
;;;1585   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;1586   			structure specific to the task that will run first. */
;;;1587   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;1588   		}
;;;1589   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;1590   
;;;1591   		xNextTaskUnblockTime = portMAX_DELAY;
00002a  4809              LDR      r0,|L24.80|
00002c  f04f31ff          MOV      r1,#0xffffffff
000030  6281              STR      r1,[r0,#0x28]  ; xNextTaskUnblockTime
;;;1592   		xSchedulerRunning = pdTRUE;
000032  2101              MOVS     r1,#1
000034  6141              STR      r1,[r0,#0x14]  ; xSchedulerRunning
;;;1593   		xTickCount = ( TickType_t ) 0U;
000036  60c4              STR      r4,[r0,#0xc]  ; xTickCount
;;;1594   
;;;1595   		/* If configGENERATE_RUN_TIME_STATS is defined then the following
;;;1596   		macro must be defined to configure the timer/counter used to generate
;;;1597   		the run time counter time base. */
;;;1598   		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
;;;1599   
;;;1600   		/* Setting up the timer tick is hardware specific and thus in the
;;;1601   		portable interface. */
;;;1602   		if( xPortStartScheduler() != pdFALSE )
000038  e8bd401f          POP      {r0-r4,lr}
00003c  f7ffbffe          B.W      xPortStartScheduler
                  |L24.64|
;;;1603   		{
;;;1604   			/* Should not reach here as if the scheduler is running the
;;;1605   			function will not return. */
;;;1606   		}
;;;1607   		else
;;;1608   		{
;;;1609   			/* Should only reach here if a task calls xTaskEndScheduler(). */
;;;1610   		}
;;;1611   	}
;;;1612   	else
;;;1613   	{
;;;1614   		/* This line will only be reached if the kernel could not be started,
;;;1615   		because there was not enough FreeRTOS heap to create the idle task
;;;1616   		or the timer task. */
;;;1617   		configASSERT( xReturn );
;;;1618   	}
;;;1619   }
000040  bd1f              POP      {r0-r4,pc}
;;;1620   /*-----------------------------------------------------------*/
                          ENDP

000042  0000              DCW      0x0000
                  |L24.68|
000044  49444c45          DCB      "IDLE",0
000048  00      
000049  00                DCB      0
00004a  00                DCB      0
00004b  00                DCB      0
                  |L24.76|
                          DCD      prvIdleTask
                  |L24.80|
                          DCD      ||.data||

                          AREA ||i.vTaskSuspend||, CODE, READONLY, ALIGN=2

                  vTaskSuspend PROC
;;;1283   
;;;1284   	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
000000  b570              PUSH     {r4-r6,lr}
;;;1285   	{
000002  4604              MOV      r4,r0
;;;1286   	TCB_t *pxTCB;
;;;1287   
;;;1288   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1289   		{
;;;1290   			/* If null is passed in here then it is the running task that is
;;;1291   			being suspended. */
;;;1292   			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
000008  4d22              LDR      r5,|L25.148|
00000a  b904              CBNZ     r4,|L25.14|
00000c  682c              LDR      r4,[r5,#0]  ; pxCurrentTCB
                  |L25.14|
;;;1293   
;;;1294   			traceTASK_SUSPEND( pxTCB );
;;;1295   
;;;1296   			/* Remove task from the ready/delayed list and place in the
;;;1297   			suspended list. */
;;;1298   			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
00000e  1d20              ADDS     r0,r4,#4
000010  f7fffffe          BL       uxListRemove
000014  b958              CBNZ     r0,|L25.46|
;;;1299   			{
;;;1300   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
000016  6ae0              LDR      r0,[r4,#0x2c]
000018  4a1f              LDR      r2,|L25.152|
00001a  eb000180          ADD      r1,r0,r0,LSL #2
00001e  f8521021          LDR      r1,[r2,r1,LSL #2]
000022  b921              CBNZ     r1,|L25.46|
000024  2101              MOVS     r1,#1
000026  4081              LSLS     r1,r1,r0
000028  6928              LDR      r0,[r5,#0x10]  ; uxTopReadyPriority
00002a  4388              BICS     r0,r0,r1
00002c  6128              STR      r0,[r5,#0x10]  ; uxTopReadyPriority
                  |L25.46|
;;;1301   			}
;;;1302   			else
;;;1303   			{
;;;1304   				mtCOVERAGE_TEST_MARKER();
;;;1305   			}
;;;1306   
;;;1307   			/* Is the task waiting on an event also? */
;;;1308   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
00002e  6aa0              LDR      r0,[r4,#0x28]
000030  b118              CBZ      r0,|L25.58|
;;;1309   			{
;;;1310   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000032  f1040018          ADD      r0,r4,#0x18
000036  f7fffffe          BL       uxListRemove
                  |L25.58|
;;;1311   			}
;;;1312   			else
;;;1313   			{
;;;1314   				mtCOVERAGE_TEST_MARKER();
;;;1315   			}
;;;1316   
;;;1317   			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
00003a  4817              LDR      r0,|L25.152|
00003c  1d21              ADDS     r1,r4,#4
00003e  30b4              ADDS     r0,r0,#0xb4
000040  f7fffffe          BL       vListInsertEnd
;;;1318   		}
;;;1319   		taskEXIT_CRITICAL();
000044  f7fffffe          BL       vPortExitCritical
;;;1320   
;;;1321   		if( pxTCB == pxCurrentTCB )
000048  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00004a  4284              CMP      r4,r0
;;;1322   		{
;;;1323   			if( xSchedulerRunning != pdFALSE )
;;;1324   			{
;;;1325   				/* The current task has just been suspended. */
;;;1326   				configASSERT( uxSchedulerSuspended == 0 );
;;;1327   				portYIELD_WITHIN_API();
;;;1328   			}
;;;1329   			else
;;;1330   			{
;;;1331   				/* The scheduler is not running, but the task that was pointed
;;;1332   				to by pxCurrentTCB has just been suspended and pxCurrentTCB
;;;1333   				must be adjusted to point to a different task. */
;;;1334   				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
;;;1335   				{
;;;1336   					/* No other tasks are ready, so set pxCurrentTCB back to
;;;1337   					NULL so when the next task is created pxCurrentTCB will
;;;1338   					be set to point to it no matter what its relative priority
;;;1339   					is. */
;;;1340   					pxCurrentTCB = NULL;
;;;1341   				}
;;;1342   				else
;;;1343   				{
;;;1344   					vTaskSwitchContext();
;;;1345   				}
;;;1346   			}
;;;1347   		}
;;;1348   		else
;;;1349   		{
;;;1350   			if( xSchedulerRunning != pdFALSE )
00004c  6968              LDR      r0,[r5,#0x14]  ; xSchedulerRunning
00004e  d116              BNE      |L25.126|
000050  b140              CBZ      r0,|L25.100|
000052  4912              LDR      r1,|L25.156|
000054  f04f5080          MOV      r0,#0x10000000        ;1327
000058  6008              STR      r0,[r1,#0]            ;1327
00005a  f3bf8f4f          DSB                            ;1327
00005e  f3bf8f6f          ISB                            ;1327
;;;1351   			{
;;;1352   				/* A task other than the currently running task was suspended,
;;;1353   				reset the next expected unblock time in case it referred to the
;;;1354   				task that is now in the Suspended state. */
;;;1355   				taskENTER_CRITICAL();
;;;1356   				{
;;;1357   					prvResetNextTaskUnblockTime();
;;;1358   				}
;;;1359   				taskEXIT_CRITICAL();
;;;1360   			}
;;;1361   			else
;;;1362   			{
;;;1363   				mtCOVERAGE_TEST_MARKER();
;;;1364   			}
;;;1365   		}
;;;1366   	}
000062  bd70              POP      {r4-r6,pc}
                  |L25.100|
000064  480c              LDR      r0,|L25.152|
000066  68a9              LDR      r1,[r5,#8]            ;1334  ; uxCurrentNumberOfTasks
000068  30b4              ADDS     r0,r0,#0xb4           ;1334
00006a  6800              LDR      r0,[r0,#0]            ;1334  ; xSuspendedTaskList
00006c  4288              CMP      r0,r1                 ;1334
00006e  d102              BNE      |L25.118|
000070  2000              MOVS     r0,#0                 ;1340
000072  6028              STR      r0,[r5,#0]            ;1340  ; pxCurrentTCB
                  |L25.116|
000074  bd70              POP      {r4-r6,pc}
                  |L25.118|
000076  e8bd4070          POP      {r4-r6,lr}            ;1344
00007a  f7ffbffe          B.W      vTaskSwitchContext
                  |L25.126|
00007e  2800              CMP      r0,#0                 ;1350
000080  d0f8              BEQ      |L25.116|
000082  f7fffffe          BL       vPortEnterCritical
000086  f7fffffe          BL       prvResetNextTaskUnblockTime
00008a  e8bd4070          POP      {r4-r6,lr}            ;1359
00008e  f7ffbffe          B.W      vPortExitCritical
;;;1367   
                          ENDP

000092  0000              DCW      0x0000
                  |L25.148|
                          DCD      ||.data||
                  |L25.152|
                          DCD      ||.bss||
                  |L25.156|
                          DCD      0xe000ed04

                          AREA ||i.vTaskSuspendAll||, CODE, READONLY, ALIGN=2

                  vTaskSuspendAll PROC
;;;1632   
;;;1633   void vTaskSuspendAll( void )
000000  4802              LDR      r0,|L26.12|
;;;1634   {
;;;1635   	/* A critical section is not required as the variable is of type
;;;1636   	BaseType_t.  Please read Richard Barry's reply in the following link to a
;;;1637   	post in the FreeRTOS support forum before reporting this as a bug! -
;;;1638   	http://goo.gl/wu4acr */
;;;1639   	++uxSchedulerSuspended;
000002  6ac1              LDR      r1,[r0,#0x2c]  ; uxSchedulerSuspended
000004  1c49              ADDS     r1,r1,#1
000006  62c1              STR      r1,[r0,#0x2c]  ; uxSchedulerSuspended
;;;1640   }
000008  4770              BX       lr
;;;1641   /*----------------------------------------------------------*/
                          ENDP

00000a  0000              DCW      0x0000
                  |L26.12|
                          DCD      ||.data||

                          AREA ||i.vTaskSwitchContext||, CODE, READONLY, ALIGN=2

                  vTaskSwitchContext PROC
;;;2202   
;;;2203   void vTaskSwitchContext( void )
000000  4a0e              LDR      r2,|L27.60|
;;;2204   {
;;;2205   	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
000002  6ad0              LDR      r0,[r2,#0x2c]  ; uxSchedulerSuspended
000004  b110              CBZ      r0,|L27.12|
;;;2206   	{
;;;2207   		/* The scheduler is currently suspended - do not allow a context
;;;2208   		switch. */
;;;2209   		xYieldPending = pdTRUE;
000006  2001              MOVS     r0,#1
000008  61d0              STR      r0,[r2,#0x1c]  ; xYieldPending
;;;2210   	}
;;;2211   	else
;;;2212   	{
;;;2213   		xYieldPending = pdFALSE;
;;;2214   		traceTASK_SWITCHED_OUT();
;;;2215   
;;;2216   		#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;2217   		{
;;;2218   				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
;;;2219   					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
;;;2220   				#else
;;;2221   					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
;;;2222   				#endif
;;;2223   
;;;2224   				/* Add the amount of time the task has been running to the
;;;2225   				accumulated	time so far.  The time the task started running was
;;;2226   				stored in ulTaskSwitchedInTime.  Note that there is no overflow
;;;2227   				protection here	so count values are only valid until the timer
;;;2228   				overflows.  The guard against negative values is to protect
;;;2229   				against suspect run time stat counter implementations - which
;;;2230   				are provided by the application, not the kernel. */
;;;2231   				if( ulTotalRunTime > ulTaskSwitchedInTime )
;;;2232   				{
;;;2233   					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
;;;2234   				}
;;;2235   				else
;;;2236   				{
;;;2237   					mtCOVERAGE_TEST_MARKER();
;;;2238   				}
;;;2239   				ulTaskSwitchedInTime = ulTotalRunTime;
;;;2240   		}
;;;2241   		#endif /* configGENERATE_RUN_TIME_STATS */
;;;2242   
;;;2243   		/* Check for stack overflow, if configured. */
;;;2244   		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
;;;2245   		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
;;;2246   
;;;2247   		/* Select a new task to run using either the generic C or port
;;;2248   		optimised asm code. */
;;;2249   		taskSELECT_HIGHEST_PRIORITY_TASK();
;;;2250   		traceTASK_SWITCHED_IN();
;;;2251   
;;;2252   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;2253   		{
;;;2254   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;2255   			structure specific to this task. */
;;;2256   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;2257   		}
;;;2258   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;2259   	}
;;;2260   }
00000a  4770              BX       lr
                  |L27.12|
00000c  2000              MOVS     r0,#0                 ;2213
00000e  61d0              STR      r0,[r2,#0x1c]         ;2213  ; xYieldPending
000010  6910              LDR      r0,[r2,#0x10]         ;2249  ; uxTopReadyPriority
000012  490b              LDR      r1,|L27.64|
000014  fab0f080          CLZ      r0,r0                 ;2249
000018  f1c0001f          RSB      r0,r0,#0x1f           ;2249
00001c  eb000080          ADD      r0,r0,r0,LSL #2       ;2249
000020  eb010080          ADD      r0,r1,r0,LSL #2       ;2249
000024  f1000308          ADD      r3,r0,#8              ;2249
000028  6841              LDR      r1,[r0,#4]            ;2249
00002a  6849              LDR      r1,[r1,#4]            ;2249
00002c  6041              STR      r1,[r0,#4]            ;2249
00002e  4299              CMP      r1,r3                 ;2249
000030  d101              BNE      |L27.54|
000032  6849              LDR      r1,[r1,#4]            ;2249
000034  6041              STR      r1,[r0,#4]            ;2249
                  |L27.54|
000036  68c8              LDR      r0,[r1,#0xc]          ;2249
000038  6010              STR      r0,[r2,#0]            ;2249  ; pxCurrentTCB
00003a  4770              BX       lr
;;;2261   /*-----------------------------------------------------------*/
                          ENDP

                  |L27.60|
                          DCD      ||.data||
                  |L27.64|
                          DCD      ||.bss||

                          AREA ||i.xTaskCheckForTimeOut||, CODE, READONLY, ALIGN=2

                  xTaskCheckForTimeOut PROC
;;;2587   
;;;2588   BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;2589   {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;2590   BaseType_t xReturn;
;;;2591   
;;;2592   	configASSERT( pxTimeOut );
;;;2593   	configASSERT( pxTicksToWait );
;;;2594   
;;;2595   	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;2596   	{
;;;2597   		/* Minor optimisation.  The tick count cannot change in this block. */
;;;2598   		const TickType_t xConstTickCount = xTickCount;
00000a  490e              LDR      r1,|L28.68|
00000c  68ca              LDR      r2,[r1,#0xc]  ; xTickCount
;;;2599   
;;;2600   		#if ( INCLUDE_vTaskSuspend == 1 )
;;;2601   			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
;;;2602   			the maximum block time then the task should block indefinitely, and
;;;2603   			therefore never time out. */
;;;2604   			if( *pxTicksToWait == portMAX_DELAY )
00000e  6828              LDR      r0,[r5,#0]
000010  1c43              ADDS     r3,r0,#1
000012  d00f              BEQ      |L28.52|
;;;2605   			{
;;;2606   				xReturn = pdFALSE;
;;;2607   			}
;;;2608   			else /* We are not blocking indefinitely, perform the checks below. */
;;;2609   		#endif
;;;2610   
;;;2611   		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
000014  6823              LDR      r3,[r4,#0]
000016  6a09              LDR      r1,[r1,#0x20]  ; xNumOfOverflows
000018  428b              CMP      r3,r1
00001a  d002              BEQ      |L28.34|
00001c  6861              LDR      r1,[r4,#4]
00001e  4291              CMP      r1,r2
000020  d90a              BLS      |L28.56|
                  |L28.34|
;;;2612   		{
;;;2613   			/* The tick count is greater than the time at which vTaskSetTimeout()
;;;2614   			was called, but has also overflowed since vTaskSetTimeOut() was called.
;;;2615   			It must have wrapped all the way around and gone past us again. This
;;;2616   			passed since vTaskSetTimeout() was called. */
;;;2617   			xReturn = pdTRUE;
;;;2618   		}
;;;2619   		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
000022  6861              LDR      r1,[r4,#4]
000024  1a51              SUBS     r1,r2,r1
000026  4281              CMP      r1,r0
000028  d206              BCS      |L28.56|
;;;2620   		{
;;;2621   			/* Not a genuine timeout. Adjust parameters for time remaining. */
;;;2622   			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
00002a  1a40              SUBS     r0,r0,r1
;;;2623   			vTaskSetTimeOutState( pxTimeOut );
00002c  6028              STR      r0,[r5,#0]
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       vTaskSetTimeOutState
                  |L28.52|
000034  2400              MOVS     r4,#0                 ;2606
000036  e000              B        |L28.58|
                  |L28.56|
;;;2624   			xReturn = pdFALSE;
;;;2625   		}
;;;2626   		else
;;;2627   		{
;;;2628   			xReturn = pdTRUE;
000038  2401              MOVS     r4,#1
                  |L28.58|
;;;2629   		}
;;;2630   	}
;;;2631   	taskEXIT_CRITICAL();
00003a  f7fffffe          BL       vPortExitCritical
;;;2632   
;;;2633   	return xReturn;
00003e  4620              MOV      r0,r4
;;;2634   }
000040  bd70              POP      {r4-r6,pc}
;;;2635   /*-----------------------------------------------------------*/
                          ENDP

000042  0000              DCW      0x0000
                  |L28.68|
                          DCD      ||.data||

                          AREA ||i.xTaskGenericCreate||, CODE, READONLY, ALIGN=2

                  xTaskGenericCreate PROC
;;;550    
;;;551    BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;552    {
000004  469b              MOV      r11,r3
000006  e9dd900f          LDRD     r9,r0,[sp,#0x3c]
00000a  9e0e              LDR      r6,[sp,#0x38]
00000c  4615              MOV      r5,r2
00000e  468a              MOV      r10,r1
000010  b910              CBNZ     r0,|L29.24|
000012  00a8              LSLS     r0,r5,#2
000014  f7fffffe          BL       pvPortMalloc
                  |L29.24|
000018  0007              MOVS     r7,r0
00001a  d00a              BEQ      |L29.50|
00001c  2054              MOVS     r0,#0x54
00001e  f7fffffe          BL       pvPortMalloc
000022  0004              MOVS     r4,r0
000024  d001              BEQ      |L29.42|
000026  6327              STR      r7,[r4,#0x30]
000028  e004              B        |L29.52|
                  |L29.42|
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       vPortFree
000030  e000              B        |L29.52|
                  |L29.50|
000032  2400              MOVS     r4,#0
                  |L29.52|
;;;553    BaseType_t xReturn;
;;;554    TCB_t * pxNewTCB;
;;;555    StackType_t *pxTopOfStack;
;;;556    
;;;557    	configASSERT( pxTaskCode );
;;;558    	configASSERT( ( ( uxPriority & ( UBaseType_t ) ( ~portPRIVILEGE_BIT ) ) < ( UBaseType_t ) configMAX_PRIORITIES ) );
;;;559    
;;;560    	/* Allocate the memory required by the TCB and stack for the new task,
;;;561    	checking that the allocation was successful. */
;;;562    	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
;;;563    
;;;564    	if( pxNewTCB != NULL )
000034  2c00              CMP      r4,#0
000036  d07c              BEQ      |L29.306|
;;;565    	{
;;;566    		#if( portUSING_MPU_WRAPPERS == 1 )
;;;567    			/* Should the task be created in privileged mode? */
;;;568    			BaseType_t xRunPrivileged;
;;;569    			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
;;;570    			{
;;;571    				xRunPrivileged = pdTRUE;
;;;572    			}
;;;573    			else
;;;574    			{
;;;575    				xRunPrivileged = pdFALSE;
;;;576    			}
;;;577    			uxPriority &= ~portPRIVILEGE_BIT;
;;;578    
;;;579    			if( puxStackBuffer != NULL )
;;;580    			{
;;;581    				/* The application provided its own stack.  Note this so no
;;;582    				attempt is made to delete the stack should that task be
;;;583    				deleted. */
;;;584    				pxNewTCB->xUsingStaticallyAllocatedStack = pdTRUE;
;;;585    			}
;;;586    			else
;;;587    			{
;;;588    				/* The stack was allocated dynamically.  Note this so it can be
;;;589    				deleted again if the task is deleted. */
;;;590    				pxNewTCB->xUsingStaticallyAllocatedStack = pdFALSE;
;;;591    			}
;;;592    		#endif /* portUSING_MPU_WRAPPERS == 1 */
;;;593    
;;;594    		/* Calculate the top of stack address.  This depends on whether the
;;;595    		stack grows from high memory to low (as per the 80x86) or vice versa.
;;;596    		portSTACK_GROWTH is used to make the result positive or negative as
;;;597    		required by the port. */
;;;598    		#if( portSTACK_GROWTH < 0 )
;;;599    		{
;;;600    			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
000038  f06f0003          MVN      r0,#3
00003c  eb000085          ADD      r0,r0,r5,LSL #2
000040  6b21              LDR      r1,[r4,#0x30]
;;;601    			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
;;;602    
;;;603    			/* Check the alignment of the calculated top of stack is correct. */
;;;604    			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;605    		}
;;;606    		#else /* portSTACK_GROWTH */
;;;607    		{
;;;608    			pxTopOfStack = pxNewTCB->pxStack;
;;;609    
;;;610    			/* Check the alignment of the stack buffer is correct. */
;;;611    			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;612    
;;;613    			/* If we want to use stack checking on architectures that use
;;;614    			a positive stack growth direction then we also need to store the
;;;615    			other extreme of the stack space. */
;;;616    			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
;;;617    		}
;;;618    		#endif /* portSTACK_GROWTH */
;;;619    
;;;620    		/* Setup the newly allocated TCB with the initial state of the task. */
;;;621    		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
000042  4635              MOV      r5,r6
000044  4408              ADD      r0,r0,r1              ;600
000046  f0200807          BIC      r8,r0,#7              ;601
00004a  4651              MOV      r1,r10
00004c  2000              MOVS     r0,#0
                  |L29.78|
00004e  1822              ADDS     r2,r4,r0
000050  5c0b              LDRB     r3,[r1,r0]
000052  f8823034          STRB     r3,[r2,#0x34]
000056  5c0a              LDRB     r2,[r1,r0]
000058  b112              CBZ      r2,|L29.96|
00005a  1c40              ADDS     r0,r0,#1
00005c  2810              CMP      r0,#0x10
00005e  d3f6              BCC      |L29.78|
                  |L29.96|
000060  2700              MOVS     r7,#0
000062  f8847043          STRB     r7,[r4,#0x43]
000066  2d05              CMP      r5,#5
000068  d300              BCC      |L29.108|
00006a  2504              MOVS     r5,#4
                  |L29.108|
00006c  62e5              STR      r5,[r4,#0x2c]
00006e  e9c45711          STRD     r5,r7,[r4,#0x44]
000072  1d20              ADDS     r0,r4,#4
000074  f7fffffe          BL       vListInitialiseItem
000078  f1040018          ADD      r0,r4,#0x18
00007c  f7fffffe          BL       vListInitialiseItem
000080  6124              STR      r4,[r4,#0x10]
000082  f1c50105          RSB      r1,r5,#5
000086  6264              STR      r4,[r4,#0x24]
000088  61a1              STR      r1,[r4,#0x18]
00008a  64e7              STR      r7,[r4,#0x4c]
00008c  f8847050          STRB     r7,[r4,#0x50]
;;;622    
;;;623    		/* Initialize the TCB stack to look as if the task was already running,
;;;624    		but had been interrupted by the scheduler.  The return address is set
;;;625    		to the start of the task function. Once the stack has been initialised
;;;626    		the	top of stack variable is updated. */
;;;627    		#if( portUSING_MPU_WRAPPERS == 1 )
;;;628    		{
;;;629    			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
;;;630    		}
;;;631    		#else /* portUSING_MPU_WRAPPERS */
;;;632    		{
;;;633    			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
000090  465a              MOV      r2,r11
000092  4640              MOV      r0,r8
000094  9900              LDR      r1,[sp,#0]
000096  f7fffffe          BL       pxPortInitialiseStack
;;;634    		}
;;;635    		#endif /* portUSING_MPU_WRAPPERS */
;;;636    
;;;637    		if( ( void * ) pxCreatedTask != NULL )
00009a  6020              STR      r0,[r4,#0]
00009c  f1b90f00          CMP      r9,#0
0000a0  d001              BEQ      |L29.166|
;;;638    		{
;;;639    			/* Pass the TCB out - in an anonymous way.  The calling function/
;;;640    			task can use this as a handle to delete the task later if
;;;641    			required.*/
;;;642    			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
0000a2  f8c94000          STR      r4,[r9,#0]
                  |L29.166|
;;;643    		}
;;;644    		else
;;;645    		{
;;;646    			mtCOVERAGE_TEST_MARKER();
;;;647    		}
;;;648    
;;;649    		/* Ensure interrupts don't access the task lists while they are being
;;;650    		updated. */
;;;651    		taskENTER_CRITICAL();
0000a6  f7fffffe          BL       vPortEnterCritical
;;;652    		{
;;;653    			uxCurrentNumberOfTasks++;
0000aa  4f30              LDR      r7,|L29.364|
0000ac  68b8              LDR      r0,[r7,#8]  ; uxCurrentNumberOfTasks
0000ae  1c40              ADDS     r0,r0,#1
0000b0  60b8              STR      r0,[r7,#8]  ; uxCurrentNumberOfTasks
;;;654    			if( pxCurrentTCB == NULL )
0000b2  6838              LDR      r0,[r7,#0]  ; pxCurrentTCB
0000b4  f8df80b8          LDR      r8,|L29.368|
0000b8  b110              CBZ      r0,|L29.192|
;;;655    			{
;;;656    				/* There are no other tasks, or all the other tasks are in
;;;657    				the suspended state - make this the current task. */
;;;658    				pxCurrentTCB =  pxNewTCB;
;;;659    
;;;660    				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
;;;661    				{
;;;662    					/* This is the first task to be created so do the preliminary
;;;663    					initialisation required.  We will not recover if this call
;;;664    					fails, but we will report the failure. */
;;;665    					prvInitialiseTaskLists();
;;;666    				}
;;;667    				else
;;;668    				{
;;;669    					mtCOVERAGE_TEST_MARKER();
;;;670    				}
;;;671    			}
;;;672    			else
;;;673    			{
;;;674    				/* If the scheduler is not already running, make this task the
;;;675    				current task if it is the highest priority task to be created
;;;676    				so far. */
;;;677    				if( xSchedulerRunning == pdFALSE )
0000ba  6978              LDR      r0,[r7,#0x14]  ; xSchedulerRunning
0000bc  b340              CBZ      r0,|L29.272|
0000be  e02c              B        |L29.282|
                  |L29.192|
0000c0  603c              STR      r4,[r7,#0]            ;658  ; pxCurrentTCB
0000c2  68b8              LDR      r0,[r7,#8]            ;660  ; uxCurrentNumberOfTasks
0000c4  2801              CMP      r0,#1                 ;660
0000c6  d128              BNE      |L29.282|
0000c8  2500              MOVS     r5,#0                 ;660
                  |L29.202|
0000ca  eb050185          ADD      r1,r5,r5,LSL #2       ;660
0000ce  eb080081          ADD      r0,r8,r1,LSL #2       ;660
0000d2  f7fffffe          BL       vListInitialise
0000d6  1c6d              ADDS     r5,r5,#1              ;660
0000d8  2d05              CMP      r5,#5                 ;660
0000da  d3f6              BCC      |L29.202|
0000dc  4824              LDR      r0,|L29.368|
0000de  3064              ADDS     r0,r0,#0x64           ;660
0000e0  f7fffffe          BL       vListInitialise
0000e4  4822              LDR      r0,|L29.368|
0000e6  3078              ADDS     r0,r0,#0x78           ;660
0000e8  f7fffffe          BL       vListInitialise
0000ec  4820              LDR      r0,|L29.368|
0000ee  308c              ADDS     r0,r0,#0x8c           ;660
0000f0  f7fffffe          BL       vListInitialise
0000f4  481e              LDR      r0,|L29.368|
0000f6  30a0              ADDS     r0,r0,#0xa0           ;660
0000f8  f7fffffe          BL       vListInitialise
0000fc  481c              LDR      r0,|L29.368|
0000fe  30b4              ADDS     r0,r0,#0xb4           ;660
000100  f7fffffe          BL       vListInitialise
000104  481a              LDR      r0,|L29.368|
000106  3064              ADDS     r0,r0,#0x64           ;660
000108  6338              STR      r0,[r7,#0x30]         ;660  ; pxDelayedTaskList
00010a  3014              ADDS     r0,r0,#0x14           ;660
00010c  6378              STR      r0,[r7,#0x34]         ;660  ; pxOverflowDelayedTaskList
00010e  e004              B        |L29.282|
                  |L29.272|
;;;678    				{
;;;679    					if( pxCurrentTCB->uxPriority <= uxPriority )
000110  6838              LDR      r0,[r7,#0]  ; pxCurrentTCB
000112  6ac0              LDR      r0,[r0,#0x2c]
000114  42b0              CMP      r0,r6
000116  d800              BHI      |L29.282|
;;;680    					{
;;;681    						pxCurrentTCB = pxNewTCB;
000118  603c              STR      r4,[r7,#0]  ; pxCurrentTCB
                  |L29.282|
;;;682    					}
;;;683    					else
;;;684    					{
;;;685    						mtCOVERAGE_TEST_MARKER();
;;;686    					}
;;;687    				}
;;;688    				else
;;;689    				{
;;;690    					mtCOVERAGE_TEST_MARKER();
;;;691    				}
;;;692    			}
;;;693    
;;;694    			uxTaskNumber++;
00011a  6a78              LDR      r0,[r7,#0x24]  ; uxTaskNumber
;;;695    
;;;696    			#if ( configUSE_TRACE_FACILITY == 1 )
;;;697    			{
;;;698    				/* Add a counter into the TCB for tracing only. */
;;;699    				pxNewTCB->uxTCBNumber = uxTaskNumber;
;;;700    			}
;;;701    			#endif /* configUSE_TRACE_FACILITY */
;;;702    			traceTASK_CREATE( pxNewTCB );
;;;703    
;;;704    			prvAddTaskToReadyList( pxNewTCB );
00011c  2101              MOVS     r1,#1
00011e  1c40              ADDS     r0,r0,#1              ;694
000120  6278              STR      r0,[r7,#0x24]  ; uxTaskNumber
000122  6ae0              LDR      r0,[r4,#0x2c]
000124  693a              LDR      r2,[r7,#0x10]  ; uxTopReadyPriority
000126  4081              LSLS     r1,r1,r0
000128  4311              ORRS     r1,r1,r2
00012a  6139              STR      r1,[r7,#0x10]  ; uxTopReadyPriority
00012c  eb000180          ADD      r1,r0,r0,LSL #2
000130  e000              B        |L29.308|
                  |L29.306|
000132  e018              B        |L29.358|
                  |L29.308|
000134  eb080081          ADD      r0,r8,r1,LSL #2
000138  1d21              ADDS     r1,r4,#4
00013a  f7fffffe          BL       vListInsertEnd
;;;705    
;;;706    			xReturn = pdPASS;
00013e  2401              MOVS     r4,#1
;;;707    			portSETUP_TCB( pxNewTCB );
;;;708    		}
;;;709    		taskEXIT_CRITICAL();
000140  f7fffffe          BL       vPortExitCritical
;;;710    	}
;;;711    	else
;;;712    	{
;;;713    		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
;;;714    		traceTASK_CREATE_FAILED();
;;;715    	}
;;;716    
;;;717    	if( xReturn == pdPASS )
;;;718    	{
;;;719    		if( xSchedulerRunning != pdFALSE )
000144  6978              LDR      r0,[r7,#0x14]  ; xSchedulerRunning
000146  b150              CBZ      r0,|L29.350|
;;;720    		{
;;;721    			/* If the created task is of a higher priority than the current task
;;;722    			then it should run now. */
;;;723    			if( pxCurrentTCB->uxPriority < uxPriority )
000148  6838              LDR      r0,[r7,#0]  ; pxCurrentTCB
00014a  6ac0              LDR      r0,[r0,#0x2c]
00014c  42b0              CMP      r0,r6
00014e  d206              BCS      |L29.350|
;;;724    			{
;;;725    				taskYIELD_IF_USING_PREEMPTION();
000150  4908              LDR      r1,|L29.372|
000152  0720              LSLS     r0,r4,#28
000154  6008              STR      r0,[r1,#0]
000156  f3bf8f4f          DSB      
00015a  f3bf8f6f          ISB      
                  |L29.350|
;;;726    			}
;;;727    			else
;;;728    			{
;;;729    				mtCOVERAGE_TEST_MARKER();
;;;730    			}
;;;731    		}
;;;732    		else
;;;733    		{
;;;734    			mtCOVERAGE_TEST_MARKER();
;;;735    		}
;;;736    	}
;;;737    
;;;738    	return xReturn;
;;;739    }
00015e  b004              ADD      sp,sp,#0x10
000160  4620              MOV      r0,r4                 ;738
000162  e8bd9ff0          POP      {r4-r12,pc}
                  |L29.358|
000166  f04f34ff          MOV      r4,#0xffffffff        ;713
00016a  e7f8              B        |L29.350|
;;;740    /*-----------------------------------------------------------*/
                          ENDP

                  |L29.364|
                          DCD      ||.data||
                  |L29.368|
                          DCD      ||.bss||
                  |L29.372|
                          DCD      0xe000ed04

                          AREA ||i.xTaskGenericNotify||, CODE, READONLY, ALIGN=2

                  xTaskGenericNotify PROC
;;;4141   
;;;4142   	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4143   	{
000004  461f              MOV      r7,r3
000006  4690              MOV      r8,r2
000008  460d              MOV      r5,r1
00000a  4604              MOV      r4,r0
;;;4144   	TCB_t * pxTCB;
;;;4145   	eNotifyValue eOriginalNotifyState;
;;;4146   	BaseType_t xReturn = pdPASS;
00000c  2601              MOVS     r6,#1
;;;4147   
;;;4148   		configASSERT( xTaskToNotify );
;;;4149   		pxTCB = ( TCB_t * ) xTaskToNotify;
;;;4150   
;;;4151   		taskENTER_CRITICAL();
00000e  f7fffffe          BL       vPortEnterCritical
;;;4152   		{
;;;4153   			if( pulPreviousNotificationValue != NULL )
000012  b10f              CBZ      r7,|L30.24|
;;;4154   			{
;;;4155   				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
000014  6ce0              LDR      r0,[r4,#0x4c]
000016  6038              STR      r0,[r7,#0]
                  |L30.24|
;;;4156   			}
;;;4157   
;;;4158   			eOriginalNotifyState = pxTCB->eNotifyState;
000018  f8940050          LDRB     r0,[r4,#0x50]
;;;4159   
;;;4160   			pxTCB->eNotifyState = eNotified;
00001c  2102              MOVS     r1,#2
00001e  f8841050          STRB     r1,[r4,#0x50]
;;;4161   
;;;4162   			switch( eAction )
000022  f1b80f05          CMP      r8,#5
000026  d20e              BCS      |L30.70|
000028  e8dff008          TBB      [pc,r8]
00002c  0d03060c          DCB      0x0d,0x03,0x06,0x0c
000030  0a00              DCB      0x0a,0x00
;;;4163   			{
;;;4164   				case eSetBits	:
;;;4165   					pxTCB->ulNotifiedValue |= ulValue;
000032  6ce1              LDR      r1,[r4,#0x4c]
000034  4329              ORRS     r1,r1,r5
;;;4166   					break;
000036  e001              B        |L30.60|
;;;4167   
;;;4168   				case eIncrement	:
;;;4169   					( pxTCB->ulNotifiedValue )++;
000038  6ce1              LDR      r1,[r4,#0x4c]
00003a  1c49              ADDS     r1,r1,#1
                  |L30.60|
00003c  64e1              STR      r1,[r4,#0x4c]         ;4165
00003e  e002              B        |L30.70|
;;;4170   					break;
;;;4171   
;;;4172   				case eSetValueWithOverwrite	:
;;;4173   					pxTCB->ulNotifiedValue = ulValue;
;;;4174   					break;
;;;4175   
;;;4176   				case eSetValueWithoutOverwrite :
;;;4177   					if( eOriginalNotifyState != eNotified )
000040  2802              CMP      r0,#2
000042  d003              BEQ      |L30.76|
;;;4178   					{
;;;4179   						pxTCB->ulNotifiedValue = ulValue;
000044  64e5              STR      r5,[r4,#0x4c]
                  |L30.70|
;;;4180   					}
;;;4181   					else
;;;4182   					{
;;;4183   						/* The value could not be written to the task. */
;;;4184   						xReturn = pdFAIL;
;;;4185   					}
;;;4186   					break;
;;;4187   
;;;4188   				case eNoAction:
;;;4189   					/* The task is being notified without its notify value being
;;;4190   					updated. */
;;;4191   					break;
;;;4192   			}
;;;4193   
;;;4194   			traceTASK_NOTIFY();
;;;4195   
;;;4196   			/* If the task is in the blocked state specifically to wait for a
;;;4197   			notification then unblock it now. */
;;;4198   			if( eOriginalNotifyState == eWaitingNotification )
000046  2801              CMP      r0,#1
000048  d002              BEQ      |L30.80|
00004a  e020              B        |L30.142|
                  |L30.76|
00004c  2600              MOVS     r6,#0                 ;4184
00004e  e01e              B        |L30.142|
                  |L30.80|
;;;4199   			{
;;;4200   				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
000050  1d20              ADDS     r0,r4,#4
000052  f7fffffe          BL       uxListRemove
;;;4201   				prvAddTaskToReadyList( pxTCB );
000056  4d10              LDR      r5,|L30.152|
000058  6ae0              LDR      r0,[r4,#0x2c]
00005a  2101              MOVS     r1,#1
00005c  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
00005e  4081              LSLS     r1,r1,r0
000060  4311              ORRS     r1,r1,r2
000062  6129              STR      r1,[r5,#0x10]  ; uxTopReadyPriority
000064  490d              LDR      r1,|L30.156|
000066  eb000080          ADD      r0,r0,r0,LSL #2
00006a  eb010080          ADD      r0,r1,r0,LSL #2
00006e  1d21              ADDS     r1,r4,#4
000070  f7fffffe          BL       vListInsertEnd
;;;4202   
;;;4203   				/* The task should not have been on an event list. */
;;;4204   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
;;;4205   
;;;4206   				#if( configUSE_TICKLESS_IDLE != 0 )
;;;4207   				{
;;;4208   					/* If a task is blocked waiting for a notification then
;;;4209   					xNextTaskUnblockTime might be set to the blocked task's time
;;;4210   					out time.  If the task is unblocked for a reason other than
;;;4211   					a timeout xNextTaskUnblockTime is normally left unchanged,
;;;4212   					because it will automatically get reset to a new value when
;;;4213   					the tick count equals xNextTaskUnblockTime.  However if
;;;4214   					tickless idling is used it might be more important to enter
;;;4215   					sleep mode at the earliest possible time - so reset
;;;4216   					xNextTaskUnblockTime here to ensure it is updated at the
;;;4217   					earliest possible time. */
;;;4218   					prvResetNextTaskUnblockTime();
;;;4219   				}
;;;4220   				#endif
;;;4221   
;;;4222   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
000074  6ae0              LDR      r0,[r4,#0x2c]
000076  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000078  6ac9              LDR      r1,[r1,#0x2c]
00007a  4288              CMP      r0,r1
00007c  d907              BLS      |L30.142|
;;;4223   				{
;;;4224   					/* The notified task has a priority above the currently
;;;4225   					executing task so a yield is required. */
;;;4226   					taskYIELD_IF_USING_PREEMPTION();
00007e  4908              LDR      r1,|L30.160|
000080  f04f5080          MOV      r0,#0x10000000
000084  6008              STR      r0,[r1,#0]
000086  f3bf8f4f          DSB      
00008a  f3bf8f6f          ISB      
                  |L30.142|
;;;4227   				}
;;;4228   				else
;;;4229   				{
;;;4230   					mtCOVERAGE_TEST_MARKER();
;;;4231   				}
;;;4232   			}
;;;4233   			else
;;;4234   			{
;;;4235   				mtCOVERAGE_TEST_MARKER();
;;;4236   			}
;;;4237   		}
;;;4238   		taskEXIT_CRITICAL();
00008e  f7fffffe          BL       vPortExitCritical
;;;4239   
;;;4240   		return xReturn;
000092  4630              MOV      r0,r6
;;;4241   	}
000094  e8bd81f0          POP      {r4-r8,pc}
;;;4242   
                          ENDP

                  |L30.152|
                          DCD      ||.data||
                  |L30.156|
                          DCD      ||.bss||
                  |L30.160|
                          DCD      0xe000ed04

                          AREA ||i.xTaskGenericNotifyFromISR||, CODE, READONLY, ALIGN=2

                  xTaskGenericNotifyFromISR PROC
;;;4247   
;;;4248   	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;4249   	{
000004  4604              MOV      r4,r0
;;;4250   	TCB_t * pxTCB;
;;;4251   	eNotifyValue eOriginalNotifyState;
;;;4252   	BaseType_t xReturn = pdPASS;
000006  2601              MOVS     r6,#1
000008  2010              MOVS     r0,#0x10
00000a  f3ef8511          MRS      r5,BASEPRI
00000e  f8dd8020          LDR      r8,[sp,#0x20]
000012  f3808811          MSR      BASEPRI,r0
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
00001e  b10b              CBZ      r3,|L31.36|
;;;4253   	UBaseType_t uxSavedInterruptStatus;
;;;4254   
;;;4255   		configASSERT( xTaskToNotify );
;;;4256   
;;;4257   		/* RTOS ports that support interrupt nesting have the concept of a
;;;4258   		maximum	system call (or maximum API call) interrupt priority.
;;;4259   		Interrupts that are	above the maximum system call priority are keep
;;;4260   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;4261   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;4262   		is defined in FreeRTOSConfig.h then
;;;4263   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;4264   		failure if a FreeRTOS API function is called from an interrupt that has
;;;4265   		been assigned a priority above the configured maximum system call
;;;4266   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;4267   		from interrupts	that have been assigned a priority at or (logically)
;;;4268   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;4269   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;4270   		simple as possible.  More information (albeit Cortex-M specific) is
;;;4271   		provided on the following link:
;;;4272   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;4273   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;4274   
;;;4275   		pxTCB = ( TCB_t * ) xTaskToNotify;
;;;4276   
;;;4277   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
;;;4278   		{
;;;4279   			if( pulPreviousNotificationValue != NULL )
;;;4280   			{
;;;4281   				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
000020  6ce0              LDR      r0,[r4,#0x4c]
000022  6018              STR      r0,[r3,#0]
                  |L31.36|
;;;4282   			}
;;;4283   
;;;4284   			eOriginalNotifyState = pxTCB->eNotifyState;
000024  f8940050          LDRB     r0,[r4,#0x50]
;;;4285   			pxTCB->eNotifyState = eNotified;
000028  2302              MOVS     r3,#2
00002a  f8843050          STRB     r3,[r4,#0x50]
;;;4286   
;;;4287   			switch( eAction )
00002e  2a05              CMP      r2,#5
000030  d20e              BCS      |L31.80|
000032  e8dff002          TBB      [pc,r2]
000036  0d03              DCB      0x0d,0x03
000038  070c0a00          DCB      0x07,0x0c,0x0a,0x00
;;;4288   			{
;;;4289   				case eSetBits	:
;;;4290   					pxTCB->ulNotifiedValue |= ulValue;
00003c  6ce2              LDR      r2,[r4,#0x4c]
00003e  430a              ORRS     r2,r2,r1
000040  64e2              STR      r2,[r4,#0x4c]
;;;4291   					break;
000042  e005              B        |L31.80|
;;;4292   
;;;4293   				case eIncrement	:
;;;4294   					( pxTCB->ulNotifiedValue )++;
000044  6ce1              LDR      r1,[r4,#0x4c]
000046  1c49              ADDS     r1,r1,#1
;;;4295   					break;
000048  e001              B        |L31.78|
;;;4296   
;;;4297   				case eSetValueWithOverwrite	:
;;;4298   					pxTCB->ulNotifiedValue = ulValue;
;;;4299   					break;
;;;4300   
;;;4301   				case eSetValueWithoutOverwrite :
;;;4302   					if( eOriginalNotifyState != eNotified )
00004a  2802              CMP      r0,#2
00004c  d003              BEQ      |L31.86|
                  |L31.78|
;;;4303   					{
;;;4304   						pxTCB->ulNotifiedValue = ulValue;
00004e  64e1              STR      r1,[r4,#0x4c]
                  |L31.80|
;;;4305   					}
;;;4306   					else
;;;4307   					{
;;;4308   						/* The value could not be written to the task. */
;;;4309   						xReturn = pdFAIL;
;;;4310   					}
;;;4311   					break;
;;;4312   
;;;4313   				case eNoAction :
;;;4314   					/* The task is being notified without its notify value being
;;;4315   					updated. */
;;;4316   					break;
;;;4317   			}
;;;4318   
;;;4319   			traceTASK_NOTIFY_FROM_ISR();
;;;4320   			
;;;4321   			/* If the task is in the blocked state specifically to wait for a
;;;4322   			notification then unblock it now. */
;;;4323   			if( eOriginalNotifyState == eWaitingNotification )
000050  2801              CMP      r0,#1
000052  d002              BEQ      |L31.90|
000054  e015              B        |L31.130|
                  |L31.86|
000056  2600              MOVS     r6,#0                 ;4309
000058  e013              B        |L31.130|
                  |L31.90|
;;;4324   			{
;;;4325   				/* The task should not have been on an event list. */
;;;4326   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
;;;4327   
;;;4328   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
00005a  4f15              LDR      r7,|L31.176|
00005c  6af8              LDR      r0,[r7,#0x2c]  ; uxSchedulerSuspended
00005e  f04f0901          MOV      r9,#1                 ;4252
000062  b198              CBZ      r0,|L31.140|
;;;4329   				{
;;;4330   					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
;;;4331   					prvAddTaskToReadyList( pxTCB );
;;;4332   				}
;;;4333   				else
;;;4334   				{
;;;4335   					/* The delayed and ready lists cannot be accessed, so hold
;;;4336   					this task pending until the scheduler is resumed. */
;;;4337   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000064  f1040118          ADD      r1,r4,#0x18
000068  4812              LDR      r0,|L31.180|
                  |L31.106|
00006a  f7fffffe          BL       vListInsertEnd
;;;4338   				}
;;;4339   
;;;4340   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
00006e  6ae0              LDR      r0,[r4,#0x2c]
000070  6839              LDR      r1,[r7,#0]  ; pxCurrentTCB
000072  6ac9              LDR      r1,[r1,#0x2c]
000074  4288              CMP      r0,r1
000076  d904              BLS      |L31.130|
;;;4341   				{
;;;4342   					/* The notified task has a priority above the currently
;;;4343   					executing task so a yield is required. */
;;;4344   					if( pxHigherPriorityTaskWoken != NULL )
000078  f1b80f00          CMP      r8,#0
00007c  d001              BEQ      |L31.130|
;;;4345   					{
;;;4346   						*pxHigherPriorityTaskWoken = pdTRUE;
00007e  f8c89000          STR      r9,[r8,#0]
                  |L31.130|
000082  f3858811          MSR      BASEPRI,r5
;;;4347   					}
;;;4348   				}
;;;4349   				else
;;;4350   				{
;;;4351   					mtCOVERAGE_TEST_MARKER();
;;;4352   				}
;;;4353   			}
;;;4354   		}
;;;4355   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;4356   
;;;4357   		return xReturn;
000086  4630              MOV      r0,r6
;;;4358   	}
000088  e8bd87f0          POP      {r4-r10,pc}
                  |L31.140|
00008c  1d20              ADDS     r0,r4,#4              ;4330
00008e  f7fffffe          BL       uxListRemove
000092  6ae0              LDR      r0,[r4,#0x2c]         ;4331
000094  693a              LDR      r2,[r7,#0x10]         ;4331  ; uxTopReadyPriority
000096  fa09f100          LSL      r1,r9,r0              ;4331
00009a  4311              ORRS     r1,r1,r2              ;4331
00009c  6139              STR      r1,[r7,#0x10]         ;4331  ; uxTopReadyPriority
00009e  4905              LDR      r1,|L31.180|
0000a0  eb000080          ADD      r0,r0,r0,LSL #2       ;4331
0000a4  398c              SUBS     r1,r1,#0x8c           ;4331
0000a6  eb010080          ADD      r0,r1,r0,LSL #2       ;4331
0000aa  1d21              ADDS     r1,r4,#4              ;4331
0000ac  e7dd              B        |L31.106|
;;;4359   
                          ENDP

0000ae  0000              DCW      0x0000
                  |L31.176|
                          DCD      ||.data||
                  |L31.180|
                          DCD      ||.bss||+0x8c

                          AREA ||i.xTaskGetCurrentTaskHandle||, CODE, READONLY, ALIGN=2

                  xTaskGetCurrentTaskHandle PROC
;;;3374   
;;;3375   	TaskHandle_t xTaskGetCurrentTaskHandle( void )
000000  4801              LDR      r0,|L32.8|
;;;3376   	{
;;;3377   	TaskHandle_t xReturn;
;;;3378   
;;;3379   		/* A critical section is not required as this is not called from
;;;3380   		an interrupt and the current TCB will always be the same for any
;;;3381   		individual execution thread. */
;;;3382   		xReturn = pxCurrentTCB;
000002  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
;;;3383   
;;;3384   		return xReturn;
;;;3385   	}
000004  4770              BX       lr
;;;3386   
                          ENDP

000006  0000              DCW      0x0000
                  |L32.8|
                          DCD      ||.data||

                          AREA ||i.xTaskGetTickCount||, CODE, READONLY, ALIGN=2

                  xTaskGetTickCount PROC
;;;1763   
;;;1764   TickType_t xTaskGetTickCount( void )
000000  4801              LDR      r0,|L33.8|
;;;1765   {
;;;1766   TickType_t xTicks;
;;;1767   
;;;1768   	/* Critical section required if running on a 16 bit processor. */
;;;1769   	portTICK_TYPE_ENTER_CRITICAL();
;;;1770   	{
;;;1771   		xTicks = xTickCount;
000002  68c0              LDR      r0,[r0,#0xc]  ; xTickCount
;;;1772   	}
;;;1773   	portTICK_TYPE_EXIT_CRITICAL();
;;;1774   
;;;1775   	return xTicks;
;;;1776   }
000004  4770              BX       lr
;;;1777   /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L33.8|
                          DCD      ||.data||

                          AREA ||i.xTaskGetTickCountFromISR||, CODE, READONLY, ALIGN=2

                  xTaskGetTickCountFromISR PROC
;;;1778   
;;;1779   TickType_t xTaskGetTickCountFromISR( void )
000000  4801              LDR      r0,|L34.8|
;;;1780   {
;;;1781   TickType_t xReturn;
;;;1782   UBaseType_t uxSavedInterruptStatus;
;;;1783   
;;;1784   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1785   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1786   	above the maximum system call priority are kept permanently enabled, even
;;;1787   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1788   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1789   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1790   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1791   	assigned a priority above the configured maximum system call priority.
;;;1792   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1793   	that have been assigned a priority at or (logically) below the maximum
;;;1794   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1795   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1796   	More information (albeit Cortex-M specific) is provided on the following
;;;1797   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1798   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1799   
;;;1800   	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
;;;1801   	{
;;;1802   		xReturn = xTickCount;
000002  68c0              LDR      r0,[r0,#0xc]  ; xTickCount
;;;1803   	}
;;;1804   	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;1805   
;;;1806   	return xReturn;
;;;1807   }
000004  4770              BX       lr
;;;1808   /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L34.8|
                          DCD      ||.data||

                          AREA ||i.xTaskIncrementTick||, CODE, READONLY, ALIGN=2

                  xTaskIncrementTick PROC
;;;1938   
;;;1939   BaseType_t xTaskIncrementTick( void )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1940   {
;;;1941   TCB_t * pxTCB;
;;;1942   TickType_t xItemValue;
;;;1943   BaseType_t xSwitchRequired = pdFALSE;
;;;1944   
;;;1945   	/* Called by the portable layer each time a tick interrupt occurs.
;;;1946   	Increments the tick then checks to see if the new tick value will cause any
;;;1947   	tasks to be unblocked. */
;;;1948   	traceTASK_INCREMENT_TICK( xTickCount );
;;;1949   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000004  4f29              LDR      r7,|L35.172|
000006  2500              MOVS     r5,#0                 ;1943
000008  6af8              LDR      r0,[r7,#0x2c]  ; uxSchedulerSuspended
00000a  b140              CBZ      r0,|L35.30|
;;;1950   	{
;;;1951   		/* Increment the RTOS tick, switching the delayed and overflowed
;;;1952   		delayed lists if it wraps to 0. */
;;;1953   		++xTickCount;
;;;1954   
;;;1955   		{
;;;1956   			/* Minor optimisation.  The tick count cannot change in this
;;;1957   			block. */
;;;1958   			const TickType_t xConstTickCount = xTickCount;
;;;1959   
;;;1960   			if( xConstTickCount == ( TickType_t ) 0U )
;;;1961   			{
;;;1962   				taskSWITCH_DELAYED_LISTS();
;;;1963   			}
;;;1964   			else
;;;1965   			{
;;;1966   				mtCOVERAGE_TEST_MARKER();
;;;1967   			}
;;;1968   
;;;1969   			/* See if this tick has made a timeout expire.  Tasks are stored in
;;;1970   			the	queue in the order of their wake time - meaning once one task
;;;1971   			has been found whose block time has not expired there is no need to
;;;1972   			look any further down the list. */
;;;1973   			if( xConstTickCount >= xNextTaskUnblockTime )
;;;1974   			{
;;;1975   				for( ;; )
;;;1976   				{
;;;1977   					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
;;;1978   					{
;;;1979   						/* The delayed list is empty.  Set xNextTaskUnblockTime
;;;1980   						to the maximum possible value so it is extremely
;;;1981   						unlikely that the
;;;1982   						if( xTickCount >= xNextTaskUnblockTime ) test will pass
;;;1983   						next time through. */
;;;1984   						xNextTaskUnblockTime = portMAX_DELAY;
;;;1985   						break;
;;;1986   					}
;;;1987   					else
;;;1988   					{
;;;1989   						/* The delayed list is not empty, get the value of the
;;;1990   						item at the head of the delayed list.  This is the time
;;;1991   						at which the task at the head of the delayed list must
;;;1992   						be removed from the Blocked state. */
;;;1993   						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
;;;1994   						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
;;;1995   
;;;1996   						if( xConstTickCount < xItemValue )
;;;1997   						{
;;;1998   							/* It is not time to unblock this item yet, but the
;;;1999   							item value is the time at which the task at the head
;;;2000   							of the blocked list must be removed from the Blocked
;;;2001   							state -	so record the item value in
;;;2002   							xNextTaskUnblockTime. */
;;;2003   							xNextTaskUnblockTime = xItemValue;
;;;2004   							break;
;;;2005   						}
;;;2006   						else
;;;2007   						{
;;;2008   							mtCOVERAGE_TEST_MARKER();
;;;2009   						}
;;;2010   
;;;2011   						/* It is time to remove the item from the Blocked state. */
;;;2012   						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
;;;2013   
;;;2014   						/* Is the task waiting on an event also?  If so remove
;;;2015   						it from the event list. */
;;;2016   						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
;;;2017   						{
;;;2018   							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
;;;2019   						}
;;;2020   						else
;;;2021   						{
;;;2022   							mtCOVERAGE_TEST_MARKER();
;;;2023   						}
;;;2024   
;;;2025   						/* Place the unblocked task into the appropriate ready
;;;2026   						list. */
;;;2027   						prvAddTaskToReadyList( pxTCB );
;;;2028   
;;;2029   						/* A task being unblocked cannot cause an immediate
;;;2030   						context switch if preemption is turned off. */
;;;2031   						#if (  configUSE_PREEMPTION == 1 )
;;;2032   						{
;;;2033   							/* Preemption is on, but a context switch should
;;;2034   							only be performed if the unblocked task has a
;;;2035   							priority that is equal to or higher than the
;;;2036   							currently executing task. */
;;;2037   							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
;;;2038   							{
;;;2039   								xSwitchRequired = pdTRUE;
;;;2040   							}
;;;2041   							else
;;;2042   							{
;;;2043   								mtCOVERAGE_TEST_MARKER();
;;;2044   							}
;;;2045   						}
;;;2046   						#endif /* configUSE_PREEMPTION */
;;;2047   					}
;;;2048   				}
;;;2049   			}
;;;2050   		}
;;;2051   
;;;2052   		/* Tasks of equal priority to the currently running task will share
;;;2053   		processing time (time slice) if preemption is on, and the application
;;;2054   		writer has not explicitly turned time slicing off. */
;;;2055   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
;;;2056   		{
;;;2057   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
;;;2058   			{
;;;2059   				xSwitchRequired = pdTRUE;
;;;2060   			}
;;;2061   			else
;;;2062   			{
;;;2063   				mtCOVERAGE_TEST_MARKER();
;;;2064   			}
;;;2065   		}
;;;2066   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
;;;2067   
;;;2068   		#if ( configUSE_TICK_HOOK == 1 )
;;;2069   		{
;;;2070   			/* Guard against the tick hook being called when the pended tick
;;;2071   			count is being unwound (when the scheduler is being unlocked). */
;;;2072   			if( uxPendedTicks == ( UBaseType_t ) 0U )
;;;2073   			{
;;;2074   				vApplicationTickHook();
;;;2075   			}
;;;2076   			else
;;;2077   			{
;;;2078   				mtCOVERAGE_TEST_MARKER();
;;;2079   			}
;;;2080   		}
;;;2081   		#endif /* configUSE_TICK_HOOK */
;;;2082   	}
;;;2083   	else
;;;2084   	{
;;;2085   		++uxPendedTicks;
00000c  69b8              LDR      r0,[r7,#0x18]  ; uxPendedTicks
00000e  1c40              ADDS     r0,r0,#1
000010  61b8              STR      r0,[r7,#0x18]  ; uxPendedTicks
                  |L35.18|
;;;2086   
;;;2087   		/* The tick hook gets called at regular intervals, even if the
;;;2088   		scheduler is locked. */
;;;2089   		#if ( configUSE_TICK_HOOK == 1 )
;;;2090   		{
;;;2091   			vApplicationTickHook();
;;;2092   		}
;;;2093   		#endif
;;;2094   	}
;;;2095   
;;;2096   	#if ( configUSE_PREEMPTION == 1 )
;;;2097   	{
;;;2098   		if( xYieldPending != pdFALSE )
000012  69f8              LDR      r0,[r7,#0x1c]  ; xYieldPending
000014  b100              CBZ      r0,|L35.24|
;;;2099   		{
;;;2100   			xSwitchRequired = pdTRUE;
000016  2501              MOVS     r5,#1
                  |L35.24|
;;;2101   		}
;;;2102   		else
;;;2103   		{
;;;2104   			mtCOVERAGE_TEST_MARKER();
;;;2105   		}
;;;2106   	}
;;;2107   	#endif /* configUSE_PREEMPTION */
;;;2108   
;;;2109   	return xSwitchRequired;
000018  4628              MOV      r0,r5
;;;2110   }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L35.30|
00001e  68f8              LDR      r0,[r7,#0xc]          ;1953  ; xTickCount
000020  1c40              ADDS     r0,r0,#1              ;1953
000022  60f8              STR      r0,[r7,#0xc]          ;1953  ; xTickCount
000024  68fe              LDR      r6,[r7,#0xc]          ;1958  ; xTickCount
000026  b946              CBNZ     r6,|L35.58|
000028  6b38              LDR      r0,[r7,#0x30]         ;1962  ; pxDelayedTaskList
00002a  6b79              LDR      r1,[r7,#0x34]         ;1962  ; pxOverflowDelayedTaskList
00002c  6339              STR      r1,[r7,#0x30]         ;1962  ; pxDelayedTaskList
00002e  6378              STR      r0,[r7,#0x34]         ;1962  ; pxOverflowDelayedTaskList
000030  6a38              LDR      r0,[r7,#0x20]         ;1962  ; xNumOfOverflows
000032  1c40              ADDS     r0,r0,#1              ;1962
000034  6238              STR      r0,[r7,#0x20]         ;1962  ; xNumOfOverflows
000036  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L35.58|
00003a  6ab8              LDR      r0,[r7,#0x28]         ;1973  ; xNextTaskUnblockTime
00003c  f8df8070          LDR      r8,|L35.176|
000040  4286              CMP      r6,r0                 ;1973
000042  d309              BCC      |L35.88|
                  |L35.68|
000044  6b38              LDR      r0,[r7,#0x30]         ;1977  ; pxDelayedTaskList
000046  6800              LDR      r0,[r0,#0]            ;1977
000048  b180              CBZ      r0,|L35.108|
00004a  6b38              LDR      r0,[r7,#0x30]         ;1993  ; pxDelayedTaskList
00004c  68c0              LDR      r0,[r0,#0xc]          ;1993
00004e  68c4              LDR      r4,[r0,#0xc]          ;1994
000050  6860              LDR      r0,[r4,#4]            ;1996
000052  4286              CMP      r6,r0                 ;1996
000054  d20d              BCS      |L35.114|
                  |L35.86|
000056  62b8              STR      r0,[r7,#0x28]         ;2003  ; xNextTaskUnblockTime
                  |L35.88|
000058  6838              LDR      r0,[r7,#0]            ;2057  ; pxCurrentTCB
00005a  6ac0              LDR      r0,[r0,#0x2c]         ;2057
00005c  eb000180          ADD      r1,r0,r0,LSL #2       ;2057
000060  f8580021          LDR      r0,[r8,r1,LSL #2]     ;2057
000064  2801              CMP      r0,#1                 ;2057
000066  d9d4              BLS      |L35.18|
000068  2501              MOVS     r5,#1                 ;2059
00006a  e7d2              B        |L35.18|
                  |L35.108|
00006c  f04f30ff          MOV      r0,#0xffffffff        ;1984
000070  e7f1              B        |L35.86|
                  |L35.114|
000072  1d20              ADDS     r0,r4,#4              ;2012
000074  f7fffffe          BL       uxListRemove
000078  6aa0              LDR      r0,[r4,#0x28]         ;2016
00007a  b118              CBZ      r0,|L35.132|
00007c  f1040018          ADD      r0,r4,#0x18           ;2018
000080  f7fffffe          BL       uxListRemove
                  |L35.132|
000084  6ae0              LDR      r0,[r4,#0x2c]         ;2027
000086  2101              MOVS     r1,#1                 ;2027
000088  693a              LDR      r2,[r7,#0x10]         ;2027  ; uxTopReadyPriority
00008a  4081              LSLS     r1,r1,r0              ;2027
00008c  4311              ORRS     r1,r1,r2              ;2027
00008e  6139              STR      r1,[r7,#0x10]         ;2027  ; uxTopReadyPriority
000090  eb000180          ADD      r1,r0,r0,LSL #2       ;2027
000094  eb080081          ADD      r0,r8,r1,LSL #2       ;2027
000098  1d21              ADDS     r1,r4,#4              ;2027
00009a  f7fffffe          BL       vListInsertEnd
00009e  6ae0              LDR      r0,[r4,#0x2c]         ;2037
0000a0  6839              LDR      r1,[r7,#0]            ;2037  ; pxCurrentTCB
0000a2  6ac9              LDR      r1,[r1,#0x2c]         ;2037
0000a4  4288              CMP      r0,r1                 ;2037
0000a6  d3cd              BCC      |L35.68|
0000a8  2501              MOVS     r5,#1                 ;2039
0000aa  e7cb              B        |L35.68|
;;;2111   /*-----------------------------------------------------------*/
                          ENDP

                  |L35.172|
                          DCD      ||.data||
                  |L35.176|
                          DCD      ||.bss||

                          AREA ||i.xTaskNotifyWait||, CODE, READONLY, ALIGN=2

                  xTaskNotifyWait PROC
;;;4016   
;;;4017   	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4018   	{
000004  461c              MOV      r4,r3
000006  4616              MOV      r6,r2
000008  4688              MOV      r8,r1
00000a  4607              MOV      r7,r0
;;;4019   	TickType_t xTimeToWake;
;;;4020   	BaseType_t xReturn;
;;;4021   
;;;4022   		taskENTER_CRITICAL();
00000c  f7fffffe          BL       vPortEnterCritical
;;;4023   		{
;;;4024   			/* Only block if a notification is not already pending. */
;;;4025   			if( pxCurrentTCB->eNotifyState != eNotified )
000010  4d26              LDR      r5,|L36.172|
000012  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000014  f8900050          LDRB     r0,[r0,#0x50]
000018  2802              CMP      r0,#2
00001a  d022              BEQ      |L36.98|
;;;4026   			{
;;;4027   				/* Clear bits in the task's notification value as bits may get
;;;4028   				set	by the notifying task or interrupt.  This can be used to
;;;4029   				clear the value to zero. */
;;;4030   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
00001c  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00001e  6cc1              LDR      r1,[r0,#0x4c]
000020  43b9              BICS     r1,r1,r7
000022  64c1              STR      r1,[r0,#0x4c]
;;;4031   
;;;4032   				/* Mark this task as waiting for a notification. */
;;;4033   				pxCurrentTCB->eNotifyState = eWaitingNotification;
000024  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000026  2701              MOVS     r7,#1
000028  f8807050          STRB     r7,[r0,#0x50]
;;;4034   
;;;4035   				if( xTicksToWait > ( TickType_t ) 0 )
00002c  b1cc              CBZ      r4,|L36.98|
;;;4036   				{
;;;4037   					/* The task is going to block.  First it must be removed
;;;4038   					from the	ready list. */
;;;4039   					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
00002e  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000030  1d00              ADDS     r0,r0,#4
000032  f7fffffe          BL       uxListRemove
000036  b930              CBNZ     r0,|L36.70|
;;;4040   					{
;;;4041   						/* The current task must be in a ready list, so there is
;;;4042   						no need to check, and the port reset macro can be called
;;;4043   						directly. */
;;;4044   						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
000038  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00003a  f890002c          LDRB     r0,[r0,#0x2c]
00003e  4087              LSLS     r7,r7,r0
000040  6928              LDR      r0,[r5,#0x10]  ; uxTopReadyPriority
000042  43b8              BICS     r0,r0,r7
000044  6128              STR      r0,[r5,#0x10]  ; uxTopReadyPriority
                  |L36.70|
;;;4045   					}
;;;4046   					else
;;;4047   					{
;;;4048   						mtCOVERAGE_TEST_MARKER();
;;;4049   					}
;;;4050   
;;;4051   					#if ( INCLUDE_vTaskSuspend == 1 )
;;;4052   					{
;;;4053   						if( xTicksToWait == portMAX_DELAY )
000046  1c60              ADDS     r0,r4,#1
000048  d027              BEQ      |L36.154|
;;;4054   						{
;;;4055   							/* Add the task to the suspended task list instead
;;;4056   							of a delayed task list to ensure the task is not
;;;4057   							woken by a timing event.  It will block
;;;4058   							indefinitely. */
;;;4059   							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
;;;4060   						}
;;;4061   						else
;;;4062   						{
;;;4063   							/* Calculate the time at which the task should be
;;;4064   							woken if no notification events occur.  This may
;;;4065   							overflow but this doesn't matter, the scheduler will
;;;4066   							handle it. */
;;;4067   							xTimeToWake = xTickCount + xTicksToWait;
00004a  68e8              LDR      r0,[r5,#0xc]  ; xTickCount
00004c  4420              ADD      r0,r0,r4
;;;4068   							prvAddCurrentTaskToDelayedList( xTimeToWake );
00004e  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L36.82|
;;;4069   						}
;;;4070   					}
;;;4071   					#else /* INCLUDE_vTaskSuspend */
;;;4072   					{
;;;4073   							/* Calculate the time at which the task should be
;;;4074   							woken if the event does not occur.  This may
;;;4075   							overflow but this doesn't matter, the scheduler will
;;;4076   							handle it. */
;;;4077   							xTimeToWake = xTickCount + xTicksToWait;
;;;4078   							prvAddCurrentTaskToDelayedList( xTimeToWake );
;;;4079   					}
;;;4080   					#endif /* INCLUDE_vTaskSuspend */
;;;4081   
;;;4082   					traceTASK_NOTIFY_WAIT_BLOCK();
;;;4083   					
;;;4084   					/* All ports are written to allow a yield in a critical
;;;4085   					section (some will yield immediately, others wait until the
;;;4086   					critical section exits) - but it is not something that
;;;4087   					application code should ever do. */
;;;4088   					portYIELD_WITHIN_API();
000052  4917              LDR      r1,|L36.176|
000054  f04f5080          MOV      r0,#0x10000000
000058  6008              STR      r0,[r1,#0]
00005a  f3bf8f4f          DSB      
00005e  f3bf8f6f          ISB      
                  |L36.98|
;;;4089   				}
;;;4090   				else
;;;4091   				{
;;;4092   					mtCOVERAGE_TEST_MARKER();
;;;4093   				}
;;;4094   			}
;;;4095   			else
;;;4096   			{
;;;4097   				mtCOVERAGE_TEST_MARKER();
;;;4098   			}
;;;4099   		}
;;;4100   		taskEXIT_CRITICAL();
000062  f7fffffe          BL       vPortExitCritical
;;;4101   
;;;4102   		taskENTER_CRITICAL();
000066  f7fffffe          BL       vPortEnterCritical
;;;4103   		{
;;;4104   			traceTASK_NOTIFY_WAIT();
;;;4105   			
;;;4106   			if( pulNotificationValue != NULL )
00006a  b116              CBZ      r6,|L36.114|
;;;4107   			{
;;;4108   				/* Output the current notification value, which may or may not
;;;4109   				have changed. */
;;;4110   				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
00006c  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00006e  6cc0              LDR      r0,[r0,#0x4c]
000070  6030              STR      r0,[r6,#0]
                  |L36.114|
;;;4111   			}
;;;4112   
;;;4113   			/* If eNotifyValue is set then either the task never entered the
;;;4114   			blocked state (because a notification was already pending) or the
;;;4115   			task unblocked because of a notification.  Otherwise the task
;;;4116   			unblocked because of a timeout. */
;;;4117   			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
000072  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000074  f8900050          LDRB     r0,[r0,#0x50]
000078  2801              CMP      r0,#1
00007a  d014              BEQ      |L36.166|
;;;4118   			{
;;;4119   				/* A notification was not received. */
;;;4120   				xReturn = pdFALSE;
;;;4121   			}
;;;4122   			else
;;;4123   			{
;;;4124   				/* A notification was already pending or a notification was
;;;4125   				received while the task was waiting. */
;;;4126   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
00007c  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00007e  6cc1              LDR      r1,[r0,#0x4c]
000080  ea210108          BIC      r1,r1,r8
000084  64c1              STR      r1,[r0,#0x4c]
;;;4127   				xReturn = pdTRUE;
000086  2401              MOVS     r4,#1
                  |L36.136|
;;;4128   			}
;;;4129   
;;;4130   			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
000088  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
00008a  2000              MOVS     r0,#0
00008c  f8810050          STRB     r0,[r1,#0x50]
;;;4131   		}
;;;4132   		taskEXIT_CRITICAL();
000090  f7fffffe          BL       vPortExitCritical
;;;4133   
;;;4134   		return xReturn;
000094  4620              MOV      r0,r4
;;;4135   	}
000096  e8bd81f0          POP      {r4-r8,pc}
                  |L36.154|
00009a  6829              LDR      r1,[r5,#0]            ;4059  ; pxCurrentTCB
00009c  4805              LDR      r0,|L36.180|
00009e  1d09              ADDS     r1,r1,#4              ;4059
0000a0  f7fffffe          BL       vListInsertEnd
0000a4  e7d5              B        |L36.82|
                  |L36.166|
0000a6  2400              MOVS     r4,#0                 ;4120
0000a8  e7ee              B        |L36.136|
;;;4136   
                          ENDP

0000aa  0000              DCW      0x0000
                  |L36.172|
                          DCD      ||.data||
                  |L36.176|
                          DCD      0xe000ed04
                  |L36.180|
                          DCD      ||.bss||+0xb4

                          AREA ||i.xTaskPriorityDisinherit||, CODE, READONLY, ALIGN=2

                  xTaskPriorityDisinherit PROC
;;;3485   
;;;3486   	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
000000  b570              PUSH     {r4-r6,lr}
;;;3487   	{
000002  0004              MOVS     r4,r0
;;;3488   	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
;;;3489   	BaseType_t xReturn = pdFALSE;
000004  f04f0000          MOV      r0,#0
000008  d02c              BEQ      |L37.100|
;;;3490   
;;;3491   		if( pxMutexHolder != NULL )
;;;3492   		{
;;;3493   			/* A task can only have an inherited priority if it holds the mutex.
;;;3494   			If the mutex is held by a task then it cannot be given from an
;;;3495   			interrupt, and if a mutex is given by the holding task then it must
;;;3496   			be the running state task. */
;;;3497   			configASSERT( pxTCB == pxCurrentTCB );
;;;3498   
;;;3499   			configASSERT( pxTCB->uxMutexesHeld );
;;;3500   			( pxTCB->uxMutexesHeld )--;
00000a  6ca1              LDR      r1,[r4,#0x48]
00000c  1e49              SUBS     r1,r1,#1
;;;3501   
;;;3502   			/* Has the holder of the mutex inherited the priority of another
;;;3503   			task? */
;;;3504   			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
00000e  64a1              STR      r1,[r4,#0x48]
000010  6c63              LDR      r3,[r4,#0x44]
000012  6ae2              LDR      r2,[r4,#0x2c]
000014  429a              CMP      r2,r3
000016  d025              BEQ      |L37.100|
;;;3505   			{
;;;3506   				/* Only disinherit if no other mutexes are held. */
;;;3507   				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
000018  2900              CMP      r1,#0
00001a  d123              BNE      |L37.100|
;;;3508   				{
;;;3509   					/* A task can only have an inherited priority if it holds
;;;3510   					the mutex.  If the mutex is held by a task then it cannot be
;;;3511   					given from an interrupt, and if a mutex is given by the
;;;3512   					holding	task then it must be the running state task.  Remove
;;;3513   					the	holding task from the ready	list. */
;;;3514   					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
00001c  1d20              ADDS     r0,r4,#4
00001e  f7fffffe          BL       uxListRemove
;;;3515   					{
;;;3516   						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
000022  4a11              LDR      r2,|L37.104|
000024  4911              LDR      r1,|L37.108|
000026  2301              MOVS     r3,#1
000028  b950              CBNZ     r0,|L37.64|
00002a  6ae0              LDR      r0,[r4,#0x2c]
00002c  eb000580          ADD      r5,r0,r0,LSL #2
000030  f8525025          LDR      r5,[r2,r5,LSL #2]
000034  b925              CBNZ     r5,|L37.64|
000036  690d              LDR      r5,[r1,#0x10]  ; uxTopReadyPriority
000038  fa03f000          LSL      r0,r3,r0
00003c  4385              BICS     r5,r5,r0
00003e  610d              STR      r5,[r1,#0x10]  ; uxTopReadyPriority
                  |L37.64|
;;;3517   					}
;;;3518   					else
;;;3519   					{
;;;3520   						mtCOVERAGE_TEST_MARKER();
;;;3521   					}
;;;3522   
;;;3523   					/* Disinherit the priority before adding the task into the
;;;3524   					new	ready list. */
;;;3525   					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
;;;3526   					pxTCB->uxPriority = pxTCB->uxBasePriority;
000040  6c60              LDR      r0,[r4,#0x44]
;;;3527   
;;;3528   					/* Reset the event list item value.  It cannot be in use for
;;;3529   					any other purpose if this task is running, and it must be
;;;3530   					running to give back the mutex. */
;;;3531   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000042  62e0              STR      r0,[r4,#0x2c]
000044  f1c00005          RSB      r0,r0,#5
;;;3532   					prvAddTaskToReadyList( pxTCB );
000048  61a0              STR      r0,[r4,#0x18]
00004a  6ae0              LDR      r0,[r4,#0x2c]
00004c  690d              LDR      r5,[r1,#0x10]  ; uxTopReadyPriority
00004e  4083              LSLS     r3,r3,r0
000050  432b              ORRS     r3,r3,r5
000052  610b              STR      r3,[r1,#0x10]  ; uxTopReadyPriority
000054  eb000080          ADD      r0,r0,r0,LSL #2
000058  eb020080          ADD      r0,r2,r0,LSL #2
00005c  1d21              ADDS     r1,r4,#4
00005e  f7fffffe          BL       vListInsertEnd
;;;3533   
;;;3534   					/* Return true to indicate that a context switch is required.
;;;3535   					This is only actually required in the corner case whereby
;;;3536   					multiple mutexes were held and the mutexes were given back
;;;3537   					in an order different to that in which they were taken.
;;;3538   					If a context switch did not occur when the first mutex was
;;;3539   					returned, even if a task was waiting on it, then a context
;;;3540   					switch should occur when the last mutex is returned whether
;;;3541   					a task is waiting on it or not. */
;;;3542   					xReturn = pdTRUE;
000062  2001              MOVS     r0,#1
                  |L37.100|
;;;3543   				}
;;;3544   				else
;;;3545   				{
;;;3546   					mtCOVERAGE_TEST_MARKER();
;;;3547   				}
;;;3548   			}
;;;3549   			else
;;;3550   			{
;;;3551   				mtCOVERAGE_TEST_MARKER();
;;;3552   			}
;;;3553   		}
;;;3554   		else
;;;3555   		{
;;;3556   			mtCOVERAGE_TEST_MARKER();
;;;3557   		}
;;;3558   
;;;3559   		return xReturn;
;;;3560   	}
000064  bd70              POP      {r4-r6,pc}
;;;3561   
                          ENDP

000066  0000              DCW      0x0000
                  |L37.104|
                          DCD      ||.bss||
                  |L37.108|
                          DCD      ||.data||

                          AREA ||i.xTaskRemoveFromEventList||, CODE, READONLY, ALIGN=2

                  xTaskRemoveFromEventList PROC
;;;2466   
;;;2467   BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2468   {
;;;2469   TCB_t *pxUnblockedTCB;
;;;2470   BaseType_t xReturn;
;;;2471   
;;;2472   	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
;;;2473   	called from a critical section within an ISR. */
;;;2474   
;;;2475   	/* The event list is sorted in priority order, so the first in the list can
;;;2476   	be removed as it is known to be the highest priority.  Remove the TCB from
;;;2477   	the delayed list, and add it to the ready list.
;;;2478   
;;;2479   	If an event is for a queue that is locked then this function will never
;;;2480   	get called - the lock count on the queue will get modified instead.  This
;;;2481   	means exclusive access to the event list is guaranteed here.
;;;2482   
;;;2483   	This function assumes that a check has already been made to ensure that
;;;2484   	pxEventList is not empty. */
;;;2485   	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
000004  68c0              LDR      r0,[r0,#0xc]
;;;2486   	configASSERT( pxUnblockedTCB );
;;;2487   	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
000006  68c4              LDR      r4,[r0,#0xc]
000008  f1040018          ADD      r0,r4,#0x18
00000c  4607              MOV      r7,r0
00000e  f7fffffe          BL       uxListRemove
;;;2488   
;;;2489   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000012  4d12              LDR      r5,|L38.92|
000014  6ae8              LDR      r0,[r5,#0x2c]  ; uxSchedulerSuspended
;;;2490   	{
;;;2491   		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
;;;2492   		prvAddTaskToReadyList( pxUnblockedTCB );
000016  2601              MOVS     r6,#1
000018  b160              CBZ      r0,|L38.52|
00001a  4639              MOV      r1,r7                 ;2489
;;;2493   	}
;;;2494   	else
;;;2495   	{
;;;2496   		/* The delayed and ready lists cannot be accessed, so hold this task
;;;2497   		pending until the scheduler is resumed. */
;;;2498   		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
00001c  4810              LDR      r0,|L38.96|
                  |L38.30|
00001e  f7fffffe          BL       vListInsertEnd
;;;2499   	}
;;;2500   
;;;2501   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
000022  6ae0              LDR      r0,[r4,#0x2c]
000024  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000026  6ac9              LDR      r1,[r1,#0x2c]
000028  4288              CMP      r0,r1
00002a  d914              BLS      |L38.86|
;;;2502   	{
;;;2503   		/* Return true if the task removed from the event list has a higher
;;;2504   		priority than the calling task.  This allows the calling task to know if
;;;2505   		it should force a context switch now. */
;;;2506   		xReturn = pdTRUE;
00002c  2001              MOVS     r0,#1
;;;2507   
;;;2508   		/* Mark that a yield is pending in case the user is not using the
;;;2509   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;2510   		xYieldPending = pdTRUE;
00002e  61ee              STR      r6,[r5,#0x1c]  ; xYieldPending
                  |L38.48|
;;;2511   	}
;;;2512   	else
;;;2513   	{
;;;2514   		xReturn = pdFALSE;
;;;2515   	}
;;;2516   
;;;2517   	#if( configUSE_TICKLESS_IDLE != 0 )
;;;2518   	{
;;;2519   		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
;;;2520   		might be set to the blocked task's time out time.  If the task is
;;;2521   		unblocked for a reason other than a timeout xNextTaskUnblockTime is
;;;2522   		normally left unchanged, because it is automatically reset to a new
;;;2523   		value when the tick count equals xNextTaskUnblockTime.  However if
;;;2524   		tickless idling is used it might be more important to enter sleep mode
;;;2525   		at the earliest possible time - so reset xNextTaskUnblockTime here to
;;;2526   		ensure it is updated at the earliest possible time. */
;;;2527   		prvResetNextTaskUnblockTime();
;;;2528   	}
;;;2529   	#endif
;;;2530   
;;;2531   	return xReturn;
;;;2532   }
000030  e8bd81f0          POP      {r4-r8,pc}
                  |L38.52|
000034  1d20              ADDS     r0,r4,#4              ;2491
000036  f7fffffe          BL       uxListRemove
00003a  6ae0              LDR      r0,[r4,#0x2c]         ;2492
00003c  692a              LDR      r2,[r5,#0x10]         ;2492  ; uxTopReadyPriority
00003e  fa06f100          LSL      r1,r6,r0              ;2492
000042  4311              ORRS     r1,r1,r2              ;2492
000044  6129              STR      r1,[r5,#0x10]         ;2492  ; uxTopReadyPriority
000046  4906              LDR      r1,|L38.96|
000048  eb000080          ADD      r0,r0,r0,LSL #2       ;2492
00004c  398c              SUBS     r1,r1,#0x8c           ;2492
00004e  eb010080          ADD      r0,r1,r0,LSL #2       ;2492
000052  1d21              ADDS     r1,r4,#4              ;2492
000054  e7e3              B        |L38.30|
                  |L38.86|
000056  2000              MOVS     r0,#0                 ;2514
000058  e7ea              B        |L38.48|
;;;2533   /*-----------------------------------------------------------*/
                          ENDP

00005a  0000              DCW      0x0000
                  |L38.92|
                          DCD      ||.data||
                  |L38.96|
                          DCD      ||.bss||+0x8c

                          AREA ||i.xTaskRemoveFromUnorderedEventList||, CODE, READONLY, ALIGN=2

                  xTaskRemoveFromUnorderedEventList PROC
;;;2534   
;;;2535   BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
000000  b570              PUSH     {r4-r6,lr}
;;;2536   {
;;;2537   TCB_t *pxUnblockedTCB;
;;;2538   BaseType_t xReturn;
;;;2539   
;;;2540   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;2541   	the event flags implementation. */
;;;2542   	configASSERT( uxSchedulerSuspended != pdFALSE );
;;;2543   
;;;2544   	/* Store the new item value in the event list. */
;;;2545   	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
000002  f0414100          ORR      r1,r1,#0x80000000
;;;2546   
;;;2547   	/* Remove the event list form the event flag.  Interrupts do not access
;;;2548   	event flags. */
;;;2549   	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
000006  6001              STR      r1,[r0,#0]
;;;2550   	configASSERT( pxUnblockedTCB );
;;;2551   	( void ) uxListRemove( pxEventListItem );
000008  68c4              LDR      r4,[r0,#0xc]
00000a  f7fffffe          BL       uxListRemove
;;;2552   
;;;2553   	/* Remove the task from the delayed list and add it to the ready list.  The
;;;2554   	scheduler is suspended so interrupts will not be accessing the ready
;;;2555   	lists. */
;;;2556   	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
00000e  1d20              ADDS     r0,r4,#4
000010  f7fffffe          BL       uxListRemove
;;;2557   	prvAddTaskToReadyList( pxUnblockedTCB );
000014  4d0c              LDR      r5,|L39.72|
000016  6ae0              LDR      r0,[r4,#0x2c]
000018  2601              MOVS     r6,#1
00001a  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
00001c  fa06f100          LSL      r1,r6,r0
000020  4311              ORRS     r1,r1,r2
000022  6129              STR      r1,[r5,#0x10]  ; uxTopReadyPriority
000024  4909              LDR      r1,|L39.76|
000026  eb000080          ADD      r0,r0,r0,LSL #2
00002a  eb010080          ADD      r0,r1,r0,LSL #2
00002e  1d21              ADDS     r1,r4,#4
000030  f7fffffe          BL       vListInsertEnd
;;;2558   
;;;2559   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
000034  6ae0              LDR      r0,[r4,#0x2c]
000036  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000038  6ac9              LDR      r1,[r1,#0x2c]
00003a  4288              CMP      r0,r1
00003c  d902              BLS      |L39.68|
;;;2560   	{
;;;2561   		/* Return true if the task removed from the event list has
;;;2562   		a higher priority than the calling task.  This allows
;;;2563   		the calling task to know if it should force a context
;;;2564   		switch now. */
;;;2565   		xReturn = pdTRUE;
00003e  2001              MOVS     r0,#1
;;;2566   
;;;2567   		/* Mark that a yield is pending in case the user is not using the
;;;2568   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;2569   		xYieldPending = pdTRUE;
000040  61ee              STR      r6,[r5,#0x1c]  ; xYieldPending
;;;2570   	}
;;;2571   	else
;;;2572   	{
;;;2573   		xReturn = pdFALSE;
;;;2574   	}
;;;2575   
;;;2576   	return xReturn;
;;;2577   }
000042  bd70              POP      {r4-r6,pc}
                  |L39.68|
000044  2000              MOVS     r0,#0                 ;2573
000046  bd70              POP      {r4-r6,pc}
;;;2578   /*-----------------------------------------------------------*/
                          ENDP

                  |L39.72|
                          DCD      ||.data||
                  |L39.76|
                          DCD      ||.bss||

                          AREA ||i.xTaskResumeAll||, CODE, READONLY, ALIGN=2

                  xTaskResumeAll PROC
;;;1670   
;;;1671   BaseType_t xTaskResumeAll( void )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1672   {
;;;1673   TCB_t *pxTCB;
;;;1674   BaseType_t xAlreadyYielded = pdFALSE;
000004  2700              MOVS     r7,#0
;;;1675   
;;;1676   	/* If uxSchedulerSuspended is zero then this function does not match a
;;;1677   	previous call to vTaskSuspendAll(). */
;;;1678   	configASSERT( uxSchedulerSuspended );
;;;1679   
;;;1680   	/* It is possible that an ISR caused a task to be removed from an event
;;;1681   	list while the scheduler was suspended.  If this was the case then the
;;;1682   	removed task will have been added to the xPendingReadyList.  Once the
;;;1683   	scheduler has been resumed it is safe to move all the pending ready
;;;1684   	tasks from this list into their appropriate ready list. */
;;;1685   	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;1686   	{
;;;1687   		--uxSchedulerSuspended;
00000a  4d26              LDR      r5,|L40.164|
00000c  6ae8              LDR      r0,[r5,#0x2c]  ; uxSchedulerSuspended
00000e  1e40              SUBS     r0,r0,#1
000010  62e8              STR      r0,[r5,#0x2c]  ; uxSchedulerSuspended
;;;1688   
;;;1689   		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000012  6ae8              LDR      r0,[r5,#0x2c]  ; uxSchedulerSuspended
000014  bbf0              CBNZ     r0,|L40.148|
;;;1690   		{
;;;1691   			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
000016  68a8              LDR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
;;;1692   			{
;;;1693   				/* Move any readied tasks from the pending list into the
;;;1694   				appropriate ready list. */
;;;1695   				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
;;;1696   				{
;;;1697   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
000018  4923              LDR      r1,|L40.168|
;;;1698   					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
;;;1699   					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
;;;1700   					prvAddTaskToReadyList( pxTCB );
00001a  2601              MOVS     r6,#1
00001c  b3d0              CBZ      r0,|L40.148|
00001e  f1a1098c          SUB      r9,r1,#0x8c
000022  4688              MOV      r8,r1                 ;1697
                  |L40.36|
000024  f8d81000          LDR      r1,[r8,#0]            ;1695  ; xPendingReadyList
000028  b1e9              CBZ      r1,|L40.102|
00002a  f8d8000c          LDR      r0,[r8,#0xc]          ;1697  ; xPendingReadyList
00002e  68c4              LDR      r4,[r0,#0xc]          ;1698
000030  f1040018          ADD      r0,r4,#0x18           ;1698
000034  f7fffffe          BL       uxListRemove
000038  1d20              ADDS     r0,r4,#4              ;1699
00003a  f7fffffe          BL       uxListRemove
00003e  6ae0              LDR      r0,[r4,#0x2c]
000040  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
000042  fa06f100          LSL      r1,r6,r0
000046  4311              ORRS     r1,r1,r2
000048  6129              STR      r1,[r5,#0x10]  ; uxTopReadyPriority
00004a  eb000180          ADD      r1,r0,r0,LSL #2
00004e  eb090081          ADD      r0,r9,r1,LSL #2
000052  1d21              ADDS     r1,r4,#4
000054  f7fffffe          BL       vListInsertEnd
;;;1701   
;;;1702   					/* If the moved task has a priority higher than the current
;;;1703   					task then a yield must be performed. */
;;;1704   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000058  6ae0              LDR      r0,[r4,#0x2c]
00005a  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
00005c  6ac9              LDR      r1,[r1,#0x2c]
00005e  4288              CMP      r0,r1
000060  d3e0              BCC      |L40.36|
;;;1705   					{
;;;1706   						xYieldPending = pdTRUE;
000062  61ee              STR      r6,[r5,#0x1c]  ; xYieldPending
000064  e7de              B        |L40.36|
                  |L40.102|
;;;1707   					}
;;;1708   					else
;;;1709   					{
;;;1710   						mtCOVERAGE_TEST_MARKER();
;;;1711   					}
;;;1712   				}
;;;1713   
;;;1714   				/* If any ticks occurred while the scheduler was suspended then
;;;1715   				they should be processed now.  This ensures the tick count does
;;;1716   				not	slip, and that any delayed tasks are resumed at the correct
;;;1717   				time. */
;;;1718   				if( uxPendedTicks > ( UBaseType_t ) 0U )
000066  69a8              LDR      r0,[r5,#0x18]  ; uxPendedTicks
000068  b938              CBNZ     r0,|L40.122|
00006a  e009              B        |L40.128|
                  |L40.108|
;;;1719   				{
;;;1720   					while( uxPendedTicks > ( UBaseType_t ) 0U )
;;;1721   					{
;;;1722   						if( xTaskIncrementTick() != pdFALSE )
00006c  f7fffffe          BL       xTaskIncrementTick
000070  b100              CBZ      r0,|L40.116|
;;;1723   						{
;;;1724   							xYieldPending = pdTRUE;
000072  61ee              STR      r6,[r5,#0x1c]  ; xYieldPending
                  |L40.116|
;;;1725   						}
;;;1726   						else
;;;1727   						{
;;;1728   							mtCOVERAGE_TEST_MARKER();
;;;1729   						}
;;;1730   						--uxPendedTicks;
000074  69a8              LDR      r0,[r5,#0x18]  ; uxPendedTicks
000076  1e40              SUBS     r0,r0,#1
000078  61a8              STR      r0,[r5,#0x18]  ; uxPendedTicks
                  |L40.122|
00007a  69a8              LDR      r0,[r5,#0x18]         ;1720  ; uxPendedTicks
00007c  2800              CMP      r0,#0                 ;1720
00007e  d1f5              BNE      |L40.108|
                  |L40.128|
;;;1731   					}
;;;1732   				}
;;;1733   				else
;;;1734   				{
;;;1735   					mtCOVERAGE_TEST_MARKER();
;;;1736   				}
;;;1737   
;;;1738   				if( xYieldPending == pdTRUE )
000080  69e8              LDR      r0,[r5,#0x1c]  ; xYieldPending
000082  2801              CMP      r0,#1
000084  d109              BNE      |L40.154|
;;;1739   				{
;;;1740   					#if( configUSE_PREEMPTION != 0 )
;;;1741   					{
;;;1742   						xAlreadyYielded = pdTRUE;
;;;1743   					}
;;;1744   					#endif
;;;1745   					taskYIELD_IF_USING_PREEMPTION();
000086  4909              LDR      r1,|L40.172|
000088  2701              MOVS     r7,#1                 ;1742
00008a  0700              LSLS     r0,r0,#28
00008c  6008              STR      r0,[r1,#0]
00008e  f3bf8f4f          DSB      
000092  e000              B        |L40.150|
                  |L40.148|
000094  e001              B        |L40.154|
                  |L40.150|
000096  f3bf8f6f          ISB      
                  |L40.154|
;;;1746   				}
;;;1747   				else
;;;1748   				{
;;;1749   					mtCOVERAGE_TEST_MARKER();
;;;1750   				}
;;;1751   			}
;;;1752   		}
;;;1753   		else
;;;1754   		{
;;;1755   			mtCOVERAGE_TEST_MARKER();
;;;1756   		}
;;;1757   	}
;;;1758   	taskEXIT_CRITICAL();
00009a  f7fffffe          BL       vPortExitCritical
;;;1759   
;;;1760   	return xAlreadyYielded;
00009e  4638              MOV      r0,r7
;;;1761   }
0000a0  e8bd87f0          POP      {r4-r10,pc}
;;;1762   /*-----------------------------------------------------------*/
                          ENDP

                  |L40.164|
                          DCD      ||.data||
                  |L40.168|
                          DCD      ||.bss||+0x8c
                  |L40.172|
                          DCD      0xe000ed04

                          AREA ||i.xTaskResumeFromISR||, CODE, READONLY, ALIGN=2

                  xTaskResumeFromISR PROC
;;;1472   
;;;1473   	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1474   	{
000004  4604              MOV      r4,r0
;;;1475   	BaseType_t xYieldRequired = pdFALSE;
000006  2600              MOVS     r6,#0
000008  2010              MOVS     r0,#0x10
00000a  f3ef8511          MRS      r5,BASEPRI
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
;;;1476   	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
;;;1477   	UBaseType_t uxSavedInterruptStatus;
;;;1478   
;;;1479   		configASSERT( xTaskToResume );
;;;1480   
;;;1481   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1482   		maximum	system call (or maximum API call) interrupt priority.
;;;1483   		Interrupts that are	above the maximum system call priority are keep
;;;1484   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1485   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1486   		is defined in FreeRTOSConfig.h then
;;;1487   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1488   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1489   		been assigned a priority above the configured maximum system call
;;;1490   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1491   		from interrupts	that have been assigned a priority at or (logically)
;;;1492   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1493   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1494   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1495   		provided on the following link:
;;;1496   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1497   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1498   
;;;1499   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
;;;1500   		{
;;;1501   			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       prvTaskIsTaskSuspended
000020  2801              CMP      r0,#1
000022  d11e              BNE      |L41.98|
;;;1502   			{
;;;1503   				traceTASK_RESUME_FROM_ISR( pxTCB );
;;;1504   
;;;1505   				/* Check the ready lists can be accessed. */
;;;1506   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000024  4f11              LDR      r7,|L41.108|
000026  6af8              LDR      r0,[r7,#0x2c]  ; uxSchedulerSuspended
000028  b118              CBZ      r0,|L41.50|
;;;1507   				{
;;;1508   					/* Ready lists can be accessed so move the task from the
;;;1509   					suspended list to the ready list directly. */
;;;1510   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
;;;1511   					{
;;;1512   						xYieldRequired = pdTRUE;
;;;1513   					}
;;;1514   					else
;;;1515   					{
;;;1516   						mtCOVERAGE_TEST_MARKER();
;;;1517   					}
;;;1518   
;;;1519   					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
;;;1520   					prvAddTaskToReadyList( pxTCB );
;;;1521   				}
;;;1522   				else
;;;1523   				{
;;;1524   					/* The delayed or ready lists cannot be accessed so the task
;;;1525   					is held in the pending ready list until the scheduler is
;;;1526   					unsuspended. */
;;;1527   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
00002a  f1040118          ADD      r1,r4,#0x18
00002e  4810              LDR      r0,|L41.112|
000030  e015              B        |L41.94|
                  |L41.50|
000032  6ae0              LDR      r0,[r4,#0x2c]         ;1510
000034  6839              LDR      r1,[r7,#0]            ;1510  ; pxCurrentTCB
000036  6ac9              LDR      r1,[r1,#0x2c]         ;1510
000038  4288              CMP      r0,r1                 ;1510
00003a  d300              BCC      |L41.62|
00003c  2601              MOVS     r6,#1                 ;1512
                  |L41.62|
00003e  1d20              ADDS     r0,r4,#4              ;1519
000040  f7fffffe          BL       uxListRemove
000044  6ae0              LDR      r0,[r4,#0x2c]         ;1520
000046  2101              MOVS     r1,#1                 ;1520
000048  693a              LDR      r2,[r7,#0x10]         ;1520  ; uxTopReadyPriority
00004a  4081              LSLS     r1,r1,r0              ;1520
00004c  4311              ORRS     r1,r1,r2              ;1520
00004e  6139              STR      r1,[r7,#0x10]         ;1520  ; uxTopReadyPriority
000050  4907              LDR      r1,|L41.112|
000052  eb000080          ADD      r0,r0,r0,LSL #2       ;1520
000056  398c              SUBS     r1,r1,#0x8c           ;1520
000058  eb010080          ADD      r0,r1,r0,LSL #2       ;1520
00005c  1d21              ADDS     r1,r4,#4              ;1520
                  |L41.94|
00005e  f7fffffe          BL       vListInsertEnd
                  |L41.98|
000062  f3858811          MSR      BASEPRI,r5            ;1520
;;;1528   				}
;;;1529   			}
;;;1530   			else
;;;1531   			{
;;;1532   				mtCOVERAGE_TEST_MARKER();
;;;1533   			}
;;;1534   		}
;;;1535   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;1536   
;;;1537   		return xYieldRequired;
000066  4630              MOV      r0,r6
;;;1538   	}
000068  e8bd81f0          POP      {r4-r8,pc}
;;;1539   
                          ENDP

                  |L41.108|
                          DCD      ||.data||
                  |L41.112|
                          DCD      ||.bss||+0x8c

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  pxReadyTasksLists
                          %        100
                  xDelayedTaskList1
                          %        20
                  xDelayedTaskList2
                          %        20
                  xPendingReadyList
                          %        20
                  xTasksWaitingTermination
                          %        20
                  xSuspendedTaskList
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  pxCurrentTCB
                          DCD      0x00000000
                  uxTasksDeleted
                          DCD      0x00000000
                  uxCurrentNumberOfTasks
                          DCD      0x00000000
                  xTickCount
                          DCD      0x00000000
                  uxTopReadyPriority
                          DCD      0x00000000
                  xSchedulerRunning
                          DCD      0x00000000
                  uxPendedTicks
                          DCD      0x00000000
                  xYieldPending
                          DCD      0x00000000
                  xNumOfOverflows
                          DCD      0x00000000
                  uxTaskNumber
                          DCD      0x00000000
                  xNextTaskUnblockTime
                          DCD      0x00000000
                  uxSchedulerSuspended
                          DCD      0x00000000
                  pxDelayedTaskList
                          DCD      0x00000000
                  pxOverflowDelayedTaskList
                          DCD      0x00000000

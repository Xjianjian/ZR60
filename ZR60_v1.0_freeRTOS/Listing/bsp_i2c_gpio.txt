; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\bsp_i2c_gpio.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\bsp_i2c_gpio.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\ZR60_v1.0_freeRTOS -I..\..\Lwip\App -I..\..\Lwip\Bsp -I..\..\Lwip\Bsp\LAN8742A -I..\..\Lwip\lwip-1.4.1 -I..\..\Lwip\lwip-1.4.1\port -I..\..\Lwip\lwip-1.4.1\port\arch -I..\..\Lwip\lwip-1.4.1\port\Standalone -I..\..\Lwip\lwip-1.4.1\src\include -I..\..\Lwip\lwip-1.4.1\src\include\ipv4 -I..\..\Lwip\lwip-1.4.1\src\include\lwip -I..\..\Lwip\lwip-1.4.1\src\include\netif -I..\..\Ecal\BtnFltr -I..\..\Ecal\UartComn -I..\..\Ecal\MemIf -I..\..\APP -I..\..\APP\BlackListMng -I..\..\APP\SeverNewsPush -I..\..\APP\NewsPull -I..\..\Ecal -I..\..\Ecal\JsonIf -I..\..\Ecal\Mcu_Init -I..\..\Service -I..\..\Complex -I..\..\Complex\FATFS -I..\..\FreeRTOS\Source\include -I..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\FreeRTOS -I.\RTE\_ZR60 -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=..\..\output\bsp_i2c_gpio.crf ..\..\Complex\i2c\bsp_i2c_gpio.c]
                          THUMB

                          AREA ||i.I2C_BytesRead||, CODE, READONLY, ALIGN=2

                  I2C_BytesRead PROC
;;;206    */
;;;207    uint8_t I2C_BytesRead(uint8_t Dev,uint8_t RegRdAddr,uint8_t* pBuffer,uint8_t NumByteToRead)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;208    {
;;;209    	uint8_t Le_u_i;
;;;210    	uint32_t I2CTimeout = 0U;
;;;211    	I2CTimeout = I2CT_LONG_TIMEOUT;
000004  f44f4a20          MOV      r10,#0xa000
000008  ea5f0803          MOVS     r8,r3                 ;208
00000c  4617              MOV      r7,r2                 ;208
00000e  4655              MOV      r5,r10
000010  d074              BEQ      |L1.252|
;;;212    	
;;;213    	if((0U != NumByteToRead) && (NumByteToRead <= 0xff))
;;;214    	{
;;;215    		while (I2C_GetFlagStatus(iicInfo[Dev].I2Cx, I2C_FLAG_BUSY))
000012  4e4e              LDR      r6,|L1.332|
000014  eb000980          ADD      r9,r0,r0,LSL #2
000018  f44f3b00          MOV      r11,#0x20000
00001c  eb0604c9          ADD      r4,r6,r9,LSL #3
                  |L1.32|
000020  4659              MOV      r1,r11
000022  6860              LDR      r0,[r4,#4]
000024  f7fffffe          BL       I2C_GetFlagStatus
000028  b128              CBZ      r0,|L1.54|
;;;216    		{
;;;217    			if ((I2CTimeout--) == 0) 
00002a  4628              MOV      r0,r5
00002c  1e6d              SUBS     r5,r5,#1
00002e  d2f7              BCS      |L1.32|
                  |L1.48|
;;;218    			{
;;;219    				return 0;
;;;220    			}
;;;221    		}
;;;222    
;;;223    		/* 产生 I2C 起始信号 */
;;;224    		I2C_GenerateSTART(iicInfo[Dev].I2Cx, ENABLE);
;;;225    		I2CTimeout = I2CT_FLAG_TIMEOUT;
;;;226    		/* 检测 EV5 事件并清除标志*/
;;;227    		while (!I2C_CheckEvent(iicInfo[Dev].I2Cx, I2C_EVENT_MASTER_MODE_SELECT))
;;;228    		{
;;;229    			if ((I2CTimeout--) == 0) 
;;;230    			{
;;;231    				return 0;
;;;232    			}
;;;233    		}
;;;234    		/* 发送 设备地址 */
;;;235    		I2C_Send7bitAddress(iicInfo[Dev].I2Cx,iicInfo[Dev].DevAddr,I2C_Direction_Transmitter);
;;;236    		I2CTimeout = I2CT_FLAG_TIMEOUT;
;;;237    		/* 检测 EV6 事件并清除标志*/
;;;238    		while (!I2C_CheckEvent(iicInfo[Dev].I2Cx,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
;;;239    		{
;;;240    			if ((I2CTimeout--) == 0) 
;;;241    			{
;;;242    				return 0;
;;;243    			}
;;;244    		}
;;;245    
;;;246    		/* 发送要读取的内部寄存器地址 */
;;;247    		I2C_SendData(iicInfo[Dev].I2Cx, RegRdAddr);
;;;248    		I2CTimeout = I2CT_FLAG_TIMEOUT;
;;;249    		/* 检测 EV8 事件并清除标志*/
;;;250    		while (!I2C_CheckEvent(iicInfo[Dev].I2Cx,I2C_EVENT_MASTER_BYTE_TRANSMITTED))
;;;251    		{
;;;252    			if ((I2CTimeout--) == 0) 
;;;253    			{
;;;254    				return 0;
;;;255    			}
;;;256    		}
;;;257    		
;;;258    		/* 产生第二次 I2C 起始信号 */
;;;259    		I2C_GenerateSTART(iicInfo[Dev].I2Cx, ENABLE);
;;;260    		I2CTimeout = I2CT_FLAG_TIMEOUT;
;;;261    		/* 检测 EV5 事件并清除标志*/
;;;262    		while (!I2C_CheckEvent(iicInfo[Dev].I2Cx, I2C_EVENT_MASTER_MODE_SELECT))
;;;263    		{
;;;264    			if ((I2CTimeout--) == 0) 
;;;265    			{
;;;266    				return 0;
;;;267    			}
;;;268    		}
;;;269    
;;;270    		I2C_Send7bitAddress(iicInfo[Dev].I2Cx, iicInfo[Dev].DevAddr|I2C_RD, I2C_Direction_Receiver);//发送设备读操作指令
;;;271    		I2CTimeout = I2CT_FLAG_TIMEOUT;
;;;272    		/* 检测 EV6 事件并清除标志*/
;;;273    		while (!I2C_CheckEvent(iicInfo[Dev].I2Cx,I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))
;;;274    		{
;;;275    			if ((I2CTimeout--) == 0) 
;;;276    			{
;;;277    				return 0;
;;;278    			}
;;;279    		}
;;;280    		
;;;281    		for(Le_u_i = 0U;Le_u_i < NumByteToRead;Le_u_i++)
;;;282    		{/* 读取 NumByteToRead 个数据*/
;;;283    			I2CTimeout = I2CT_LONG_TIMEOUT;
;;;284    			while (I2C_CheckEvent(iicInfo[Dev].I2Cx, I2C_EVENT_MASTER_BYTE_RECEIVED)==0)
;;;285    			{
;;;286    				if ((I2CTimeout--) == 0) 
;;;287    				{
;;;288    					return 0;
;;;289    				}
;;;290    			}
;;;291    			if(Le_u_i < (NumByteToRead-1))
;;;292    			{	
;;;293    				*pBuffer = I2C_ReceiveData(iicInfo[Dev].I2Cx);/*通过 I2C，从设备中读取一个字节的数据 */
;;;294    				pBuffer++;/* 存储数据的指针指向下一个地址 */
;;;295    				I2C_AcknowledgeConfig(iicInfo[Dev].I2Cx, ENABLE);	/* 使能应答，方便下一次 I2C 传输 */	
;;;296    			}
;;;297    			else
;;;298    			{//接收最后1个字节
;;;299    				*pBuffer = I2C_ReceiveData(iicInfo[Dev].I2Cx);/*通过 I2C，从设备中读取一个字节的数据 */
;;;300    				I2C_AcknowledgeConfig(iicInfo[Dev].I2Cx, DISABLE);/* 发送非应答信号 */
;;;301    			}
;;;302    		}
;;;303    		I2C_GenerateSTOP(iicInfo[Dev].I2Cx, ENABLE);/* 发送停止信号 */	
;;;304    	}
;;;305    
;;;306    	return 1;
;;;307    }
000030  b004              ADD      sp,sp,#0x10
000032  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.54|
000036  46b3              MOV      r11,r6                ;224
000038  2101              MOVS     r1,#1                 ;224
00003a  6860              LDR      r0,[r4,#4]            ;224
00003c  f7fffffe          BL       I2C_GenerateSTART
000040  f44f5580          MOV      r5,#0x1000            ;225
000044  4e42              LDR      r6,|L1.336|
000046  e002              B        |L1.78|
                  |L1.72|
000048  4628              MOV      r0,r5                 ;229
00004a  1e6d              SUBS     r5,r5,#1              ;229
00004c  d3f0              BCC      |L1.48|
                  |L1.78|
00004e  4631              MOV      r1,r6                 ;227
000050  6860              LDR      r0,[r4,#4]            ;227
000052  f7fffffe          BL       I2C_CheckEvent
000056  2800              CMP      r0,#0                 ;227
000058  d0f6              BEQ      |L1.72|
00005a  f81b1039          LDRB     r1,[r11,r9,LSL #3]    ;235
00005e  2200              MOVS     r2,#0                 ;235
000060  6860              LDR      r0,[r4,#4]            ;235
000062  f7fffffe          BL       I2C_Send7bitAddress
000066  f44f5580          MOV      r5,#0x1000            ;236
00006a  e002              B        |L1.114|
                  |L1.108|
00006c  4628              MOV      r0,r5                 ;240
00006e  1e6d              SUBS     r5,r5,#1              ;240
000070  d3de              BCC      |L1.48|
                  |L1.114|
000072  4938              LDR      r1,|L1.340|
000074  6860              LDR      r0,[r4,#4]            ;238
000076  f7fffffe          BL       I2C_CheckEvent
00007a  2800              CMP      r0,#0                 ;238
00007c  d0f6              BEQ      |L1.108|
00007e  6860              LDR      r0,[r4,#4]            ;247
000080  9901              LDR      r1,[sp,#4]            ;247
000082  f7fffffe          BL       I2C_SendData
000086  f44f5b80          MOV      r11,#0x1000           ;248
00008a  465d              MOV      r5,r11                ;248
00008c  e002              B        |L1.148|
                  |L1.142|
00008e  4628              MOV      r0,r5                 ;252
000090  1e6d              SUBS     r5,r5,#1              ;252
000092  d3cd              BCC      |L1.48|
                  |L1.148|
000094  492f              LDR      r1,|L1.340|
000096  6860              LDR      r0,[r4,#4]            ;250
000098  1c89              ADDS     r1,r1,#2              ;250
00009a  f7fffffe          BL       I2C_CheckEvent
00009e  2800              CMP      r0,#0                 ;250
0000a0  d0f5              BEQ      |L1.142|
0000a2  2101              MOVS     r1,#1                 ;259
0000a4  6860              LDR      r0,[r4,#4]            ;259
0000a6  f7fffffe          BL       I2C_GenerateSTART
0000aa  465d              MOV      r5,r11                ;260
0000ac  4e27              LDR      r6,|L1.332|
0000ae  e002              B        |L1.182|
                  |L1.176|
0000b0  4628              MOV      r0,r5                 ;264
0000b2  1e6d              SUBS     r5,r5,#1              ;264
0000b4  d3bc              BCC      |L1.48|
                  |L1.182|
0000b6  4926              LDR      r1,|L1.336|
0000b8  6860              LDR      r0,[r4,#4]            ;262
0000ba  f7fffffe          BL       I2C_CheckEvent
0000be  2800              CMP      r0,#0                 ;262
0000c0  d0f6              BEQ      |L1.176|
0000c2  f8160039          LDRB     r0,[r6,r9,LSL #3]     ;270
0000c6  2201              MOVS     r2,#1                 ;270
0000c8  f0400101          ORR      r1,r0,#1              ;270
0000cc  6860              LDR      r0,[r4,#4]            ;270
0000ce  f7fffffe          BL       I2C_Send7bitAddress
0000d2  4e1f              LDR      r6,|L1.336|
0000d4  465d              MOV      r5,r11                ;271
0000d6  1c76              ADDS     r6,r6,#1              ;273
0000d8  e002              B        |L1.224|
                  |L1.218|
0000da  4628              MOV      r0,r5                 ;275
0000dc  1e6d              SUBS     r5,r5,#1              ;275
0000de  d3a7              BCC      |L1.48|
                  |L1.224|
0000e0  4631              MOV      r1,r6                 ;273
0000e2  6860              LDR      r0,[r4,#4]            ;273
0000e4  f7fffffe          BL       I2C_CheckEvent
0000e8  2800              CMP      r0,#0                 ;273
0000ea  d0f6              BEQ      |L1.218|
0000ec  2500              MOVS     r5,#0                 ;281
0000ee  e024              B        |L1.314|
                  |L1.240|
0000f0  f8df905c          LDR      r9,|L1.336|
0000f4  4656              MOV      r6,r10                ;283
0000f6  f109093f          ADD      r9,r9,#0x3f           ;284
0000fa  e003              B        |L1.260|
                  |L1.252|
0000fc  e023              B        |L1.326|
                  |L1.254|
0000fe  4630              MOV      r0,r6                 ;286
000100  1e76              SUBS     r6,r6,#1              ;286
000102  d395              BCC      |L1.48|
                  |L1.260|
000104  4649              MOV      r1,r9                 ;284
000106  6860              LDR      r0,[r4,#4]            ;284
000108  f7fffffe          BL       I2C_CheckEvent
00010c  2800              CMP      r0,#0                 ;284
00010e  d0f6              BEQ      |L1.254|
000110  f1a80001          SUB      r0,r8,#1              ;291
000114  4285              CMP      r5,r0                 ;291
000116  6860              LDR      r0,[r4,#4]            ;291
000118  da06              BGE      |L1.296|
00011a  f7fffffe          BL       I2C_ReceiveData
00011e  f8070b01          STRB     r0,[r7],#1            ;293
000122  2101              MOVS     r1,#1                 ;295
000124  6860              LDR      r0,[r4,#4]            ;295
000126  e004              B        |L1.306|
                  |L1.296|
000128  f7fffffe          BL       I2C_ReceiveData
00012c  7038              STRB     r0,[r7,#0]            ;299
00012e  2100              MOVS     r1,#0                 ;300
000130  6860              LDR      r0,[r4,#4]            ;300
                  |L1.306|
000132  f7fffffe          BL       I2C_AcknowledgeConfig
000136  1c6d              ADDS     r5,r5,#1              ;300
000138  b2ed              UXTB     r5,r5                 ;281
                  |L1.314|
00013a  4545              CMP      r5,r8                 ;281
00013c  d3d8              BCC      |L1.240|
00013e  2101              MOVS     r1,#1                 ;303
000140  6860              LDR      r0,[r4,#4]            ;303
000142  f7fffffe          BL       I2C_GenerateSTOP
                  |L1.326|
000146  2001              MOVS     r0,#1                 ;306
000148  e772              B        |L1.48|
;;;308    
                          ENDP

00014a  0000              DCW      0x0000
                  |L1.332|
                          DCD      ||.constdata||
                  |L1.336|
                          DCD      0x00030001
                  |L1.340|
                          DCD      0x00070082

                          AREA ||i.I2C_BytesWrite||, CODE, READONLY, ALIGN=2

                  I2C_BytesWrite PROC
;;;125    */
;;;126    uint8_t I2C_BytesWrite(uint8_t Dev,uint8_t RegWrAddr,uint8_t* pBuffer,uint8_t NumByteToWrite)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;127    {
000004  ea5f0803          MOVS     r8,r3
000008  4617              MOV      r7,r2
;;;128    	uint8_t Le_u_i;
;;;129    	uint32_t I2CTimeout = I2CT_LONG_TIMEOUT;
00000a  f44f4520          MOV      r5,#0xa000
00000e  d067              BEQ      |L2.224|
;;;130    
;;;131    	
;;;132    	if((0U != NumByteToWrite) && (NumByteToWrite <= 0xff))
;;;133    	{
;;;134    		while (I2C_GetFlagStatus(iicInfo[Dev].I2Cx, I2C_FLAG_BUSY))
000010  f8df90d0          LDR      r9,|L2.228|
000014  eb000680          ADD      r6,r0,r0,LSL #2
000018  f44f3a00          MOV      r10,#0x20000
00001c  eb0904c6          ADD      r4,r9,r6,LSL #3
                  |L2.32|
000020  4651              MOV      r1,r10
000022  6860              LDR      r0,[r4,#4]
000024  f7fffffe          BL       I2C_GetFlagStatus
000028  b128              CBZ      r0,|L2.54|
;;;135    		{
;;;136    			if ((I2CTimeout--) == 0)
00002a  4628              MOV      r0,r5
00002c  1e6d              SUBS     r5,r5,#1
00002e  d2f7              BCS      |L2.32|
                  |L2.48|
;;;137    			{
;;;138    				return 0;
;;;139    			}
;;;140    		}
;;;141    		/* 产生 I2C 起始信号 */
;;;142    		I2C_GenerateSTART(iicInfo[Dev].I2Cx, ENABLE);
;;;143    		/*设置超时等待时间*/
;;;144    		I2CTimeout = I2CT_FLAG_TIMEOUT;
;;;145    		/* 检测 EV5 事件并清除标志*/
;;;146    		while (!I2C_CheckEvent(iicInfo[Dev].I2Cx, I2C_EVENT_MASTER_MODE_SELECT))
;;;147    		{
;;;148    			if ((I2CTimeout--) == 0) 
;;;149    			{
;;;150    				return 0;
;;;151    			}
;;;152    		}
;;;153    		/* 发送设备写操作指令 */
;;;154    		I2C_Send7bitAddress(iicInfo[Dev].I2Cx, iicInfo[Dev].DevAddr|I2C_WR,I2C_Direction_Transmitter);
;;;155    		I2CTimeout = I2CT_FLAG_TIMEOUT;
;;;156    		/* 检测 EV6 事件并清除标志*/
;;;157    		while (!I2C_CheckEvent(iicInfo[Dev].I2Cx,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
;;;158    		{
;;;159    			if ((I2CTimeout--) == 0) 
;;;160    			{
;;;161    				return 0;
;;;162    			}
;;;163    		}
;;;164    		/* 发送要写入的寄存器起始地址 */
;;;165    		I2C_SendData(iicInfo[Dev].I2Cx, RegWrAddr);
;;;166    		I2CTimeout = I2CT_FLAG_TIMEOUT;
;;;167    		/* 检测 EV8 事件并清除标志*/
;;;168    		while (!I2C_CheckEvent(iicInfo[Dev].I2Cx,I2C_EVENT_MASTER_BYTE_TRANSMITTED))
;;;169    		{
;;;170    			if ((I2CTimeout--) == 0) 
;;;171    			{
;;;172    				return 0;
;;;173    			}
;;;174    		}
;;;175    		
;;;176    		/* 写数据 */
;;;177    		for (Le_u_i=0;Le_u_i < NumByteToWrite;Le_u_i++)
;;;178    		{		
;;;179    			/* 发送一字节要写入的数据 */
;;;180    			I2C_SendData(iicInfo[Dev].I2Cx, *pBuffer);
;;;181    			pBuffer++;
;;;182    			I2CTimeout = I2CT_FLAG_TIMEOUT;
;;;183    			/* 检测 EV8 事件并清除标志*/
;;;184    			while (!I2C_CheckEvent(iicInfo[Dev].I2Cx,I2C_EVENT_MASTER_BYTE_TRANSMITTED))
;;;185    			{
;;;186    				if ((I2CTimeout--) == 0) 
;;;187    				{
;;;188    					return 0;
;;;189    				}
;;;190    			}
;;;191    		}
;;;192    		/* 发送停止信号 */
;;;193    		I2C_GenerateSTOP(iicInfo[Dev].I2Cx, ENABLE);
;;;194    	}
;;;195    	
;;;196    	return 1;
;;;197    }
000030  b004              ADD      sp,sp,#0x10
000032  e8bd9ff0          POP      {r4-r12,pc}
                  |L2.54|
000036  46ca              MOV      r10,r9                ;142
000038  2101              MOVS     r1,#1                 ;142
00003a  6860              LDR      r0,[r4,#4]            ;142
00003c  f7fffffe          BL       I2C_GenerateSTART
000040  f44f5980          MOV      r9,#0x1000            ;144
000044  464d              MOV      r5,r9                 ;144
000046  f8dfb0a0          LDR      r11,|L2.232|
00004a  e002              B        |L2.82|
                  |L2.76|
00004c  4628              MOV      r0,r5                 ;148
00004e  1e6d              SUBS     r5,r5,#1              ;148
000050  d3ee              BCC      |L2.48|
                  |L2.82|
000052  4659              MOV      r1,r11                ;146
000054  6860              LDR      r0,[r4,#4]            ;146
000056  f7fffffe          BL       I2C_CheckEvent
00005a  2800              CMP      r0,#0                 ;146
00005c  d0f6              BEQ      |L2.76|
00005e  f81a1036          LDRB     r1,[r10,r6,LSL #3]    ;154
000062  2200              MOVS     r2,#0                 ;154
000064  6860              LDR      r0,[r4,#4]            ;154
000066  f7fffffe          BL       I2C_Send7bitAddress
00006a  464e              MOV      r6,r9                 ;155
00006c  464d              MOV      r5,r9                 ;155
00006e  f8df907c          LDR      r9,|L2.236|
000072  e002              B        |L2.122|
                  |L2.116|
000074  4628              MOV      r0,r5                 ;159
000076  1e6d              SUBS     r5,r5,#1              ;159
000078  d3da              BCC      |L2.48|
                  |L2.122|
00007a  4649              MOV      r1,r9                 ;157
00007c  6860              LDR      r0,[r4,#4]            ;157
00007e  f7fffffe          BL       I2C_CheckEvent
000082  2800              CMP      r0,#0                 ;157
000084  d0f6              BEQ      |L2.116|
000086  6860              LDR      r0,[r4,#4]            ;165
000088  9901              LDR      r1,[sp,#4]            ;165
00008a  f7fffffe          BL       I2C_SendData
00008e  46b2              MOV      r10,r6                ;166
000090  4635              MOV      r5,r6                 ;166
000092  4e16              LDR      r6,|L2.236|
000094  1cb6              ADDS     r6,r6,#2              ;168
000096  e002              B        |L2.158|
                  |L2.152|
000098  4628              MOV      r0,r5                 ;170
00009a  1e6d              SUBS     r5,r5,#1              ;170
00009c  d3c8              BCC      |L2.48|
                  |L2.158|
00009e  46b1              MOV      r9,r6                 ;168
0000a0  4631              MOV      r1,r6                 ;168
0000a2  6860              LDR      r0,[r4,#4]            ;168
0000a4  f7fffffe          BL       I2C_CheckEvent
0000a8  2800              CMP      r0,#0                 ;168
0000aa  d0f5              BEQ      |L2.152|
0000ac  2600              MOVS     r6,#0                 ;177
0000ae  e011              B        |L2.212|
                  |L2.176|
0000b0  7839              LDRB     r1,[r7,#0]            ;180
0000b2  6860              LDR      r0,[r4,#4]            ;180
0000b4  f7fffffe          BL       I2C_SendData
0000b8  4655              MOV      r5,r10                ;182
0000ba  1c7f              ADDS     r7,r7,#1              ;182
0000bc  e002              B        |L2.196|
                  |L2.190|
0000be  4628              MOV      r0,r5                 ;186
0000c0  1e6d              SUBS     r5,r5,#1              ;186
0000c2  d3b5              BCC      |L2.48|
                  |L2.196|
0000c4  4649              MOV      r1,r9                 ;184
0000c6  6860              LDR      r0,[r4,#4]            ;184
0000c8  f7fffffe          BL       I2C_CheckEvent
0000cc  2800              CMP      r0,#0                 ;184
0000ce  d0f6              BEQ      |L2.190|
0000d0  1c76              ADDS     r6,r6,#1              ;184
0000d2  b2f6              UXTB     r6,r6                 ;177
                  |L2.212|
0000d4  4546              CMP      r6,r8                 ;177
0000d6  d3eb              BCC      |L2.176|
0000d8  2101              MOVS     r1,#1                 ;193
0000da  6860              LDR      r0,[r4,#4]            ;193
0000dc  f7fffffe          BL       I2C_GenerateSTOP
                  |L2.224|
0000e0  2001              MOVS     r0,#1                 ;196
0000e2  e7a5              B        |L2.48|
;;;198    
                          ENDP

                  |L2.228|
                          DCD      ||.constdata||
                  |L2.232|
                          DCD      0x00030001
                  |L2.236|
                          DCD      0x00070082

                          AREA ||i.I2C_Mode_Config||, CODE, READONLY, ALIGN=2

                  I2C_Mode_Config PROC
;;;94     */
;;;95     void I2C_Mode_Config(uint8_t Dev)
000000  b51f              PUSH     {r0-r4,lr}
;;;96     {
;;;97     	I2C_InitTypeDef I2C_InitStructure;
;;;98     	/* I2C 配置 */
;;;99     	I2C_DeInit(iicInfo[Dev].I2Cx);
000002  eb000180          ADD      r1,r0,r0,LSL #2
000006  4811              LDR      r0,|L3.76|
000008  eb0004c1          ADD      r4,r0,r1,LSL #3
00000c  6860              LDR      r0,[r4,#4]
00000e  f7fffffe          BL       I2C_DeInit
;;;100    	I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
000012  2000              MOVS     r0,#0
000014  f8ad0004          STRH     r0,[sp,#4]
;;;101    	/*占空比*/
;;;102    	I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
000018  f64b70ff          MOV      r0,#0xbfff
00001c  f8ad0006          STRH     r0,[sp,#6]
;;;103    	/*I2C 自身地址*/
;;;104    	I2C_InitStructure.I2C_OwnAddress1 =I2C_OWN_ADDRESS7;
000020  200a              MOVS     r0,#0xa
000022  f8ad0008          STRH     r0,[sp,#8]
;;;105    	/*使能响应*/
;;;106    	I2C_InitStructure.I2C_Ack = I2C_Ack_Enable ;
000026  f44f6080          MOV      r0,#0x400
00002a  f8ad000a          STRH     r0,[sp,#0xa]
;;;107    	/* I2C 的寻址模式 */
;;;108    	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
00002e  0100              LSLS     r0,r0,#4
000030  f8ad000c          STRH     r0,[sp,#0xc]
;;;109    	/* 通信速率 */
;;;110    	I2C_InitStructure.I2C_ClockSpeed = iicInfo[Dev].I2C_ClkSpeed;
000034  68a0              LDR      r0,[r4,#8]
;;;111    	/*写入配置*/
;;;112    	I2C_Init(iicInfo[Dev].I2Cx, &I2C_InitStructure);
000036  9000              STR      r0,[sp,#0]
000038  4669              MOV      r1,sp
00003a  6860              LDR      r0,[r4,#4]
00003c  f7fffffe          BL       I2C_Init
;;;113    	/* 使能 I2C */
;;;114    	I2C_Cmd(iicInfo[Dev].I2Cx, ENABLE);
000040  2101              MOVS     r1,#1
000042  6860              LDR      r0,[r4,#4]
000044  f7fffffe          BL       I2C_Cmd
;;;115    }
000048  bd1f              POP      {r0-r4,pc}
;;;116    
                          ENDP

00004a  0000              DCW      0x0000
                  |L3.76|
                          DCD      ||.constdata||

                          AREA ||i.I2C_Write_Byte||, CODE, READONLY, ALIGN=1

                  I2C_Write_Byte PROC
;;;634    
;;;635    uint8_t I2C_Write_Byte(uint8_t ucDevAddr,uint8_t data)
000000  b570              PUSH     {r4-r6,lr}
;;;636    {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;637    	i2c_CfgGpio(IIC_LCD,I2C_TYPE_SIMULATE);		/* 配置GPIO */
000006  2101              MOVS     r1,#1
000008  2002              MOVS     r0,#2
00000a  f7fffffe          BL       i2c_CfgGpio
;;;638    
;;;639    	i2c_Start();		/* 发送启动信号 */
00000e  f7fffffe          BL       i2c_Start
;;;640    
;;;641    	/* 发送设备地址+读写控制bit（0 = w， 1 = r) bit7 先传 */
;;;642    	i2c_SendByte(  (ucDevAddr<<1)| I2C_WR);
000012  0660              LSLS     r0,r4,#25
000014  0e00              LSRS     r0,r0,#24
000016  f7fffffe          BL       i2c_SendByte
;;;643    	if (i2c_WaitAck() != 0)
00001a  f7fffffe          BL       i2c_WaitAck
00001e  b928              CBNZ     r0,|L4.44|
;;;644    	{
;;;645    		goto cmd_fail;	/* EEPROM器件无应答 */
;;;646    	}
;;;647    	i2c_SendByte(data);
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       i2c_SendByte
;;;648    	if (i2c_WaitAck() != 0)
000026  f7fffffe          BL       i2c_WaitAck
00002a  b118              CBZ      r0,|L4.52|
                  |L4.44|
;;;649    	{
;;;650    		goto cmd_fail;	/* EEPROM器件无应答 */
;;;651    	}
;;;652    	i2c_Stop();			/* 发送停止信号 */
;;;653    	
;;;654    	return 0;
;;;655    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;656    	/* 发送I2C总线停止信号 */
;;;657    	i2c_Stop();
00002c  f7fffffe          BL       i2c_Stop
;;;658    	return 1;
000030  2001              MOVS     r0,#1
;;;659    }
000032  bd70              POP      {r4-r6,pc}
                  |L4.52|
000034  f7fffffe          BL       i2c_Stop
000038  2000              MOVS     r0,#0                 ;654
00003a  bd70              POP      {r4-r6,pc}
;;;660    
                          ENDP


                          AREA ||i.i2c_Ack||, CODE, READONLY, ALIGN=2

                  i2c_Ack PROC
;;;502    */
;;;503    void i2c_Ack(void)
000000  b570              PUSH     {r4-r6,lr}
;;;504    {
;;;505    	EEPROM_I2C_SDA_0();	/* CPU驱动SDA = 0 */
000002  4d0e              LDR      r5,|L5.60|
000004  f44f7400          MOV      r4,#0x200
000008  4621              MOV      r1,r4
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       GPIO_ResetBits
;;;506    	i2c_Delay();
000010  f7fffffe          BL       i2c_Delay
;;;507    	EEPROM_I2C_SCL_1();	/* CPU产生1个时钟 */
000014  1066              ASRS     r6,r4,#1
000016  4631              MOV      r1,r6
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       GPIO_SetBits
;;;508    	i2c_Delay();
00001e  f7fffffe          BL       i2c_Delay
;;;509    	EEPROM_I2C_SCL_0();
000022  4631              MOV      r1,r6
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       GPIO_ResetBits
;;;510    	i2c_Delay();
00002a  f7fffffe          BL       i2c_Delay
;;;511    	EEPROM_I2C_SDA_1();	/* CPU释放SDA总线 */
00002e  4621              MOV      r1,r4
000030  4628              MOV      r0,r5
000032  e8bd4070          POP      {r4-r6,lr}
000036  f7ffbffe          B.W      GPIO_SetBits
;;;512    }
;;;513    
                          ENDP

00003a  0000              DCW      0x0000
                  |L5.60|
                          DCD      0x40020400

                          AREA ||i.i2c_CfgGpio||, CODE, READONLY, ALIGN=2

                  i2c_CfgGpio PROC
;;;47     */
;;;48     void i2c_CfgGpio(uint8_t Dev,uint8_t Le_u_workType)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;49     {
;;;50     	GPIO_InitTypeDef GPIO_InitStructure;
;;;51     	if(Dev < I2C_DEVICE_NUM)
000004  2804              CMP      r0,#4
000006  d21f              BCS      |L6.72|
;;;52     	{
;;;53     		if(I2C_TYPE_HARDWARE == Le_u_workType)
;;;54     		{
;;;55     			/*使能 I2C 外设时钟 */
;;;56     			RCC_APB1PeriphClockCmd(iicInfo[Dev].RCC_APB1Periph, ENABLE);
000008  4a26              LDR      r2,|L6.164|
00000a  2700              MOVS     r7,#0                 ;49
00000c  2502              MOVS     r5,#2                 ;49
00000e  2601              MOVS     r6,#1
000010  eb000080          ADD      r0,r0,r0,LSL #2
000014  eb0204c0          ADD      r4,r2,r0,LSL #3
000018  2902              CMP      r1,#2                 ;53
00001a  d017              BEQ      |L6.76|
;;;57     			/*使能 I2C 引脚的 GPIO 时钟*/
;;;58     			RCC_AHB1PeriphClockCmd(iicInfo[Dev].RCC_AHB1Periph, ENABLE);
;;;59     			/* Reset I2Cx IP */
;;;60     			RCC_APB1PeriphResetCmd(iicInfo[Dev].RCC_APB1Periph, ENABLE);
;;;61     			/* Release reset signal of I2Cx IP */
;;;62     			RCC_APB1PeriphResetCmd(iicInfo[Dev].RCC_APB1Periph, DISABLE);
;;;63     			/* 连接引脚源 PXx 到 I2C_SCL*/
;;;64     			GPIO_PinAFConfig(iicInfo[Dev].GPIOx, I2C_SCL_SOURCE,iicInfo[Dev].GPIO_AF);
;;;65     			/* 连接引脚源 PXx 到 to I2C_SDA*/
;;;66     			GPIO_PinAFConfig(iicInfo[Dev].GPIOx,I2C_SDA_SOURCE,iicInfo[Dev].GPIO_AF);
;;;67     			/*配置 SCL SDA引脚 */
;;;68     			GPIO_InitStructure.GPIO_Pin = iicInfo[Dev].SCL_pin | iicInfo[Dev].SDA_pin;
;;;69     			GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;70     			GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;71     			GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
;;;72     			GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;73     			GPIO_Init(iicInfo[Dev].GPIOx, &GPIO_InitStructure);
;;;74     		}
;;;75     		else
;;;76     		{
;;;77     			RCC_AHB1PeriphClockCmd(iicInfo[Dev].RCC_AHB1Periph, ENABLE);	/* 打开GPIO时钟 */
00001c  2101              MOVS     r1,#1
00001e  6920              LDR      r0,[r4,#0x10]
000020  f7fffffe          BL       RCC_AHB1PeriphClockCmd
000024  e9d40108          LDRD     r0,r1,[r4,#0x20]
;;;78     			GPIO_InitStructure.GPIO_Pin = iicInfo[Dev].SCL_pin | iicInfo[Dev].SDA_pin;
;;;79     			GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000028  f88d5005          STRB     r5,[sp,#5]
00002c  4308              ORRS     r0,r0,r1              ;78
;;;80     			GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;  	
00002e  f88d6004          STRB     r6,[sp,#4]
;;;81     			GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;  	/* 开漏输出 */
000032  f88d6006          STRB     r6,[sp,#6]
000036  9000              STR      r0,[sp,#0]            ;79
;;;82     			GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
000038  f88d7007          STRB     r7,[sp,#7]
;;;83     			GPIO_Init(iicInfo[Dev].GPIOx, &GPIO_InitStructure);
00003c  4669              MOV      r1,sp
00003e  6960              LDR      r0,[r4,#0x14]
000040  f7fffffe          BL       GPIO_Init
;;;84     			/* 给一个停止信号, 复位I2C总线上的所有设备到待机模式 */
;;;85     			i2c_Stop();
000044  f7fffffe          BL       i2c_Stop
                  |L6.72|
;;;86     		}
;;;87     	}
;;;88     }
000048  e8bd81fc          POP      {r2-r8,pc}
                  |L6.76|
00004c  2101              MOVS     r1,#1                 ;56
00004e  68e0              LDR      r0,[r4,#0xc]          ;56
000050  f7fffffe          BL       RCC_APB1PeriphClockCmd
000054  2101              MOVS     r1,#1                 ;58
000056  6920              LDR      r0,[r4,#0x10]         ;58
000058  f7fffffe          BL       RCC_AHB1PeriphClockCmd
00005c  2101              MOVS     r1,#1                 ;60
00005e  68e0              LDR      r0,[r4,#0xc]          ;60
000060  f7fffffe          BL       RCC_APB1PeriphResetCmd
000064  2100              MOVS     r1,#0                 ;62
000066  68e0              LDR      r0,[r4,#0xc]          ;62
000068  f7fffffe          BL       RCC_APB1PeriphResetCmd
00006c  7f22              LDRB     r2,[r4,#0x1c]         ;64
00006e  2108              MOVS     r1,#8                 ;64
000070  6960              LDR      r0,[r4,#0x14]         ;64
000072  f7fffffe          BL       GPIO_PinAFConfig
000076  7f22              LDRB     r2,[r4,#0x1c]         ;66
000078  2109              MOVS     r1,#9                 ;66
00007a  6960              LDR      r0,[r4,#0x14]         ;66
00007c  f7fffffe          BL       GPIO_PinAFConfig
000080  e9d40108          LDRD     r0,r1,[r4,#0x20]      ;66
000084  f88d5004          STRB     r5,[sp,#4]            ;69
000088  4308              ORRS     r0,r0,r1              ;68
00008a  f88d5005          STRB     r5,[sp,#5]            ;70
00008e  f88d6006          STRB     r6,[sp,#6]            ;71
000092  9000              STR      r0,[sp,#0]            ;69
000094  f88d7007          STRB     r7,[sp,#7]            ;72
000098  4669              MOV      r1,sp                 ;73
00009a  6960              LDR      r0,[r4,#0x14]         ;73
00009c  f7fffffe          BL       GPIO_Init
0000a0  e7d2              B        |L6.72|
;;;89     
                          ENDP

0000a2  0000              DCW      0x0000
                  |L6.164|
                          DCD      ||.constdata||

                          AREA ||i.i2c_CheckDevice||, CODE, READONLY, ALIGN=1

                  i2c_CheckDevice PROC
;;;539    */
;;;540    uint8_t i2c_CheckDevice(uint8_t _Address)
000000  b510              PUSH     {r4,lr}
;;;541    {
000002  4604              MOV      r4,r0
;;;542    	uint8_t ucAck;
;;;543    
;;;544    	//i2c_CfgGpio();		/* 配置GPIO */
;;;545    
;;;546    	
;;;547    	i2c_Start();		/* 发送启动信号 */
000004  f7fffffe          BL       i2c_Start
;;;548    
;;;549    	/* 发送设备地址+读写控制bit（0 = w， 1 = r) bit7 先传 */
;;;550    	i2c_SendByte(_Address | I2C_WR);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       i2c_SendByte
;;;551    	ucAck = i2c_WaitAck();	/* 检测设备的ACK应答 */
00000e  f7fffffe          BL       i2c_WaitAck
000012  4604              MOV      r4,r0
;;;552    
;;;553    	i2c_Stop();			/* 发送停止信号 */
000014  f7fffffe          BL       i2c_Stop
;;;554    
;;;555    	return ucAck;
000018  4620              MOV      r0,r4
;;;556    }
00001a  bd10              POP      {r4,pc}
;;;557    
                          ENDP


                          AREA ||i.i2c_Delay||, CODE, READONLY, ALIGN=1

                  i2c_Delay PROC
;;;318    */
;;;319    static void i2c_Delay(void)
000000  2000              MOVS     r0,#0
                  |L8.2|
;;;320    {
;;;321    	uint8_t i;
;;;322    
;;;323    	/*　可用逻辑分析仪测量I2C通讯时的频率
;;;324        工作条件：CPU主频168MHz ，MDK编译环境，1级优化经测试，循环次数为20~250时都能通讯正常*/
;;;325    	for (i = 0; i < 40; i++);
000002  1c40              ADDS     r0,r0,#1
000004  b2c0              UXTB     r0,r0
000006  2828              CMP      r0,#0x28
000008  d3fb              BCC      |L8.2|
;;;326    }
00000a  4770              BX       lr
;;;327    
                          ENDP


                          AREA ||i.i2c_NAck||, CODE, READONLY, ALIGN=2

                  i2c_NAck PROC
;;;521    */
;;;522    void i2c_NAck(void)
000000  b570              PUSH     {r4-r6,lr}
;;;523    {
;;;524    	EEPROM_I2C_SDA_1();	/* CPU驱动SDA = 1 */
000002  4c0b              LDR      r4,|L9.48|
000004  f44f7100          MOV      r1,#0x200
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetBits
;;;525    	i2c_Delay();
00000e  f7fffffe          BL       i2c_Delay
;;;526    	EEPROM_I2C_SCL_1();	/* CPU产生1个时钟 */
000012  15a5              ASRS     r5,r4,#22
000014  4629              MOV      r1,r5
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       GPIO_SetBits
;;;527    	i2c_Delay();
00001c  f7fffffe          BL       i2c_Delay
;;;528    	EEPROM_I2C_SCL_0();
000020  4629              MOV      r1,r5
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       GPIO_ResetBits
;;;529    	i2c_Delay();	
000028  e8bd4070          POP      {r4-r6,lr}
00002c  f7ffbffe          B.W      i2c_Delay
;;;530    }
;;;531    
                          ENDP

                  |L9.48|
                          DCD      0x40020400

                          AREA ||i.i2c_ReadByte||, CODE, READONLY, ALIGN=2

                  i2c_ReadByte PROC
;;;443    */
;;;444    uint8_t i2c_ReadByte(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;445    {
;;;446    	uint8_t i;
;;;447    	uint8_t value;
;;;448    
;;;449    	/* 读到第1个bit为数据的bit7 */
;;;450    	value = 0;
000004  2400              MOVS     r4,#0
;;;451    	for (i = 0; i < 8; i++)
;;;452    	{
;;;453    		value <<= 1;
;;;454    		EEPROM_I2C_SCL_1();
000006  4e11              LDR      r6,|L10.76|
000008  4625              MOV      r5,r4                 ;451
;;;455    		i2c_Delay();
;;;456    		if (EEPROM_I2C_SDA_READ())
00000a  f44f7800          MOV      r8,#0x200
00000e  f44f7780          MOV      r7,#0x100             ;454
                  |L10.18|
000012  0660              LSLS     r0,r4,#25             ;453
000014  0e04              LSRS     r4,r0,#24             ;453
000016  4639              MOV      r1,r7                 ;454
000018  4630              MOV      r0,r6                 ;454
00001a  f7fffffe          BL       GPIO_SetBits
00001e  f7fffffe          BL       i2c_Delay
000022  4641              MOV      r1,r8
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       GPIO_ReadInputDataBit
00002a  b108              CBZ      r0,|L10.48|
00002c  1c64              ADDS     r4,r4,#1
;;;457    		{
;;;458    			value++;
00002e  b2e4              UXTB     r4,r4
                  |L10.48|
;;;459    		}
;;;460    		EEPROM_I2C_SCL_0();
000030  4639              MOV      r1,r7
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       GPIO_ResetBits
;;;461    		i2c_Delay();
000038  f7fffffe          BL       i2c_Delay
00003c  1c6d              ADDS     r5,r5,#1
00003e  b2ed              UXTB     r5,r5                 ;451
000040  2d08              CMP      r5,#8                 ;451
000042  d3e6              BCC      |L10.18|
;;;462    	}
;;;463    	return value;
000044  4620              MOV      r0,r4
;;;464    }
000046  e8bd81f0          POP      {r4-r8,pc}
;;;465    
                          ENDP

00004a  0000              DCW      0x0000
                  |L10.76|
                          DCD      0x40020400

                          AREA ||i.i2c_SendByte||, CODE, READONLY, ALIGN=2

                  i2c_SendByte PROC
;;;372    */
;;;373    void i2c_SendByte(uint8_t _ucByte)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;374    {
;;;375    	uint8_t i;
;;;376    
;;;377    	/* 先发送字节的高位bit7 */
;;;378    	for (i = 0; i < 8; i++)
;;;379    	{		
;;;380    		if (_ucByte & 0x80)
;;;381    		{
;;;382    			EEPROM_I2C_SDA_1();
000004  4e15              LDR      r6,|L11.92|
000006  4605              MOV      r5,r0                 ;374
000008  2400              MOVS     r4,#0                 ;378
;;;383    		}
;;;384    		else
;;;385    		{
;;;386    			EEPROM_I2C_SDA_0();
;;;387    		}
;;;388    		i2c_Delay();
;;;389    		EEPROM_I2C_SCL_1();
00000a  f44f7780          MOV      r7,#0x100
00000e  f44f7800          MOV      r8,#0x200             ;382
                  |L11.18|
000012  0628              LSLS     r0,r5,#24             ;380
000014  4641              MOV      r1,r8                 ;386
000016  4630              MOV      r0,r6                 ;386
000018  d502              BPL      |L11.32|
00001a  f7fffffe          BL       GPIO_SetBits
00001e  e001              B        |L11.36|
                  |L11.32|
000020  f7fffffe          BL       GPIO_ResetBits
                  |L11.36|
000024  f7fffffe          BL       i2c_Delay
000028  4639              MOV      r1,r7
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       GPIO_SetBits
;;;390    		i2c_Delay();	
000030  f7fffffe          BL       i2c_Delay
;;;391    		EEPROM_I2C_SCL_0();
000034  4639              MOV      r1,r7
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       GPIO_ResetBits
;;;392    		if (i == 7)
00003c  2c07              CMP      r4,#7
00003e  d103              BNE      |L11.72|
;;;393    		{
;;;394    			 EEPROM_I2C_SDA_1(); // 释放总线
000040  4641              MOV      r1,r8
000042  4630              MOV      r0,r6
000044  f7fffffe          BL       GPIO_SetBits
                  |L11.72|
;;;395    		}
;;;396    		_ucByte <<= 1;	/* 左移一个bit */
000048  0668              LSLS     r0,r5,#25
00004a  0e05              LSRS     r5,r0,#24
;;;397    		i2c_Delay();
00004c  f7fffffe          BL       i2c_Delay
000050  1c64              ADDS     r4,r4,#1
000052  b2e4              UXTB     r4,r4                 ;378
000054  2c08              CMP      r4,#8                 ;378
000056  d3dc              BCC      |L11.18|
;;;398    	}
;;;399    }
000058  e8bd81f0          POP      {r4-r8,pc}
;;;400    
                          ENDP

                  |L11.92|
                          DCD      0x40020400

                          AREA ||i.i2c_Start||, CODE, READONLY, ALIGN=2

                  i2c_Start PROC
;;;335    */
;;;336    void i2c_Start(void)
000000  b570              PUSH     {r4-r6,lr}
;;;337    {
;;;338    	/* 当SCL高电平时，SDA出现一个下跳沿表示I2C总线启动信号 */
;;;339    	EEPROM_I2C_SDA_1();
000002  4d0e              LDR      r5,|L12.60|
000004  f44f7400          MOV      r4,#0x200
000008  4621              MOV      r1,r4
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       GPIO_SetBits
;;;340    	EEPROM_I2C_SCL_1();
000010  1066              ASRS     r6,r4,#1
000012  4631              MOV      r1,r6
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       GPIO_SetBits
;;;341    	i2c_Delay();
00001a  f7fffffe          BL       i2c_Delay
;;;342    	EEPROM_I2C_SDA_0();
00001e  4621              MOV      r1,r4
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       GPIO_ResetBits
;;;343    	i2c_Delay();
000026  f7fffffe          BL       i2c_Delay
;;;344    	EEPROM_I2C_SCL_0();
00002a  4631              MOV      r1,r6
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       GPIO_ResetBits
;;;345    	i2c_Delay();
000032  e8bd4070          POP      {r4-r6,lr}
000036  f7ffbffe          B.W      i2c_Delay
;;;346    }
;;;347    
                          ENDP

00003a  0000              DCW      0x0000
                  |L12.60|
                          DCD      0x40020400

                          AREA ||i.i2c_Stop||, CODE, READONLY, ALIGN=2

                  i2c_Stop PROC
;;;355    */
;;;356    void i2c_Stop(void)
000000  b570              PUSH     {r4-r6,lr}
;;;357    {
;;;358    	/* 当SCL高电平时，SDA出现一个上跳沿表示I2C总线停止信号 */
;;;359    	EEPROM_I2C_SDA_0();
000002  4d09              LDR      r5,|L13.40|
000004  f44f7400          MOV      r4,#0x200
000008  4621              MOV      r1,r4
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       GPIO_ResetBits
;;;360    	EEPROM_I2C_SCL_1();
000010  1061              ASRS     r1,r4,#1
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       GPIO_SetBits
;;;361    	i2c_Delay();
000018  f7fffffe          BL       i2c_Delay
;;;362    	EEPROM_I2C_SDA_1();
00001c  4621              MOV      r1,r4
00001e  4628              MOV      r0,r5
000020  e8bd4070          POP      {r4-r6,lr}
000024  f7ffbffe          B.W      GPIO_SetBits
;;;363    }
;;;364    
                          ENDP

                  |L13.40|
                          DCD      0x40020400

                          AREA ||i.i2c_WaitAck||, CODE, READONLY, ALIGN=2

                  i2c_WaitAck PROC
;;;473    */
;;;474    uint8_t i2c_WaitAck(void)
000000  b570              PUSH     {r4-r6,lr}
;;;475    {
;;;476    	uint8_t re;
;;;477    
;;;478    	EEPROM_I2C_SDA_1();	/* CPU释放SDA总线 */
000002  4d10              LDR      r5,|L14.68|
000004  f44f7400          MOV      r4,#0x200
000008  4621              MOV      r1,r4
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       GPIO_SetBits
;;;479    	i2c_Delay();
000010  f7fffffe          BL       i2c_Delay
;;;480    	EEPROM_I2C_SCL_1();	/* CPU驱动SCL = 1, 此时器件会返回ACK应答 */
000014  1066              ASRS     r6,r4,#1
000016  4631              MOV      r1,r6
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       GPIO_SetBits
;;;481    	i2c_Delay();
00001e  f7fffffe          BL       i2c_Delay
;;;482    	if (EEPROM_I2C_SDA_READ())	/* CPU读取SDA口线状态 */
000022  4621              MOV      r1,r4
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       GPIO_ReadInputDataBit
00002a  b108              CBZ      r0,|L14.48|
;;;483    	{
;;;484    		re = 1;
00002c  2401              MOVS     r4,#1
00002e  e000              B        |L14.50|
                  |L14.48|
;;;485    	}
;;;486    	else
;;;487    	{
;;;488    		re = 0;
000030  2400              MOVS     r4,#0
                  |L14.50|
;;;489    	}
;;;490    	EEPROM_I2C_SCL_0();
000032  4631              MOV      r1,r6
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       GPIO_ResetBits
;;;491    	i2c_Delay();
00003a  f7fffffe          BL       i2c_Delay
;;;492    	return re;
00003e  4620              MOV      r0,r4
;;;493    }
000040  bd70              POP      {r4-r6,pc}
;;;494    
                          ENDP

000042  0000              DCW      0x0000
                  |L14.68|
                          DCD      0x40020400

                          AREA ||i.i2c_master_reg8_recv||, CODE, READONLY, ALIGN=1

                  i2c_master_reg8_recv PROC
;;;591    
;;;592    uint8_t i2c_master_reg8_recv(uint8_t ucDevAddr, uint8_t ucRegAddr, uint8_t *pucBuf, uint8_t uclength)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;593    {
000004  4683              MOV      r11,r0
;;;594    	uint8_t ucRet = 1;
000006  f04f0901          MOV      r9,#1
00000a  469a              MOV      r10,r3                ;593
00000c  4615              MOV      r5,r2                 ;593
;;;595        uint8_t i,j,m;
;;;596    
;;;597    	i2c_CfgGpio(IIC_TOUCHKEY,I2C_TYPE_SIMULATE);		/* 配置GPIO */
00000e  4649              MOV      r1,r9
000010  2003              MOVS     r0,#3
000012  f7fffffe          BL       i2c_CfgGpio
;;;598    	for(i = 0; i < 20; i++)
000016  2700              MOVS     r7,#0
                  |L15.24|
;;;599    	{
;;;600    		i2c_Start();
000018  f7fffffe          BL       i2c_Start
;;;601    		  
;;;602    		if((send_byte(ucDevAddr)==0))
00001c  4658              MOV      r0,r11
00001e  f7fffffe          BL       send_byte
000022  bb40              CBNZ     r0,|L15.118|
;;;603    		{
;;;604    			  i = 200;
000024  27c8              MOVS     r7,#0xc8
;;;605    			  if (send_byte( ucRegAddr )==0)
000026  9801              LDR      r0,[sp,#4]
000028  f7fffffe          BL       send_byte
00002c  bb18              CBNZ     r0,|L15.118|
;;;606    			  {
;;;607    					i2c_Stop();
00002e  f7fffffe          BL       i2c_Stop
;;;608    				 
;;;609    					for(j = 0; j < 20;j++)
000032  2600              MOVS     r6,#0
;;;610    					{
;;;611    						i2c_Start();
;;;612    						if (send_byte(ucDevAddr + I2C_RD)==0)
000034  f10b0801          ADD      r8,r11,#1
                  |L15.56|
000038  f7fffffe          BL       i2c_Start
00003c  f00800ff          AND      r0,r8,#0xff
000040  f7fffffe          BL       send_byte
000044  b998              CBNZ     r0,|L15.110|
;;;613    						{
;;;614    							j = 200;
000046  26c8              MOVS     r6,#0xc8
;;;615    							ucRet = 0;
000048  f04f0900          MOV      r9,#0
;;;616    							for ( m = 1 ; m < uclength; m++, pucBuf++)
00004c  2401              MOVS     r4,#1
00004e  e007              B        |L15.96|
                  |L15.80|
;;;617    							{				
;;;618    								*pucBuf= i2c_ReadByte();
000050  f7fffffe          BL       i2c_ReadByte
000054  7028              STRB     r0,[r5,#0]
;;;619    								i2c_Ack();
000056  f7fffffe          BL       i2c_Ack
00005a  1c64              ADDS     r4,r4,#1
00005c  b2e4              UXTB     r4,r4                 ;616
00005e  1c6d              ADDS     r5,r5,#1              ;616
                  |L15.96|
000060  4554              CMP      r4,r10                ;616
000062  d3f5              BCC      |L15.80|
;;;620    							}
;;;621    							*pucBuf = i2c_ReadByte();
000064  f7fffffe          BL       i2c_ReadByte
000068  7028              STRB     r0,[r5,#0]
;;;622    							i2c_NAck();
00006a  f7fffffe          BL       i2c_NAck
                  |L15.110|
00006e  1c76              ADDS     r6,r6,#1
000070  b2f6              UXTB     r6,r6                 ;609
000072  2e14              CMP      r6,#0x14              ;609
000074  d3e0              BCC      |L15.56|
                  |L15.118|
000076  1c7f              ADDS     r7,r7,#1              ;609
000078  b2ff              UXTB     r7,r7                 ;598
00007a  2f14              CMP      r7,#0x14              ;598
00007c  d3cc              BCC      |L15.24|
;;;623    						}
;;;624    					}
;;;625    			  }
;;;626    		}
;;;627    	}
;;;628            
;;;629        i2c_Stop();
00007e  f7fffffe          BL       i2c_Stop
;;;630            
;;;631    	return ucRet;
;;;632    }
000082  b004              ADD      sp,sp,#0x10
000084  4648              MOV      r0,r9                 ;631
000086  e8bd9ff0          POP      {r4-r12,pc}
;;;633    
                          ENDP


                          AREA ||i.i2c_master_reg8_send||, CODE, READONLY, ALIGN=1

                  i2c_master_reg8_send PROC
;;;558    
;;;559    uint8_t i2c_master_reg8_send(uint8_t ucDevAddr, uint8_t ucRegAddr, uint8_t *pucBuf, uint8_t uclength)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;560    { 
000004  4688              MOV      r8,r1
000006  4604              MOV      r4,r0
;;;561    	uint8_t ucRet = 1;
000008  2601              MOVS     r6,#1
00000a  461f              MOV      r7,r3                 ;560
00000c  4615              MOV      r5,r2                 ;560
;;;562    	uint8_t i;
;;;563    	
;;;564    	i2c_CfgGpio(IIC_HYM8563,I2C_TYPE_SIMULATE);		/* 配置GPIO */
00000e  4631              MOV      r1,r6
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       i2c_CfgGpio
;;;565    	i2c_Stop();	
000016  f7fffffe          BL       i2c_Stop
;;;566    	i2c_Start();
00001a  f7fffffe          BL       i2c_Start
;;;567    	if((send_byte(ucDevAddr)==0)&& (uclength!=0))
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       send_byte
000024  b990              CBNZ     r0,|L16.76|
000026  b18f              CBZ      r7,|L16.76|
;;;568    	{
;;;569    		if ( send_byte(ucRegAddr)==0)
000028  4640              MOV      r0,r8
00002a  f7fffffe          BL       send_byte
00002e  b968              CBNZ     r0,|L16.76|
;;;570    		{
;;;571    			ucRet = 0;
000030  2600              MOVS     r6,#0
;;;572    			for ( i = 0 ; i  < uclength; i ++)
000032  4634              MOV      r4,r6
000034  e008              B        |L16.72|
                  |L16.54|
;;;573    			{
;;;574    				if (send_byte(*pucBuf)==0)
000036  7828              LDRB     r0,[r5,#0]
000038  f7fffffe          BL       send_byte
00003c  b108              CBZ      r0,|L16.66|
;;;575    				{
;;;576    					pucBuf ++;
;;;577                    
;;;578    				}			
;;;579    				else
;;;580    				{
;;;581    					ucRet = 1;
00003e  2601              MOVS     r6,#1
;;;582    					break;
000040  e004              B        |L16.76|
                  |L16.66|
000042  1c64              ADDS     r4,r4,#1
000044  b2e4              UXTB     r4,r4                 ;572
000046  1c6d              ADDS     r5,r5,#1              ;572
                  |L16.72|
000048  42bc              CMP      r4,r7                 ;572
00004a  d3f4              BCC      |L16.54|
                  |L16.76|
;;;583    				}
;;;584    			}
;;;585    		}
;;;586    	}
;;;587    	
;;;588    	i2c_Stop();	
00004c  f7fffffe          BL       i2c_Stop
;;;589    	return ucRet;
000050  4630              MOV      r0,r6
;;;590    }
000052  e8bd81f0          POP      {r4-r8,pc}
;;;591    
                          ENDP


                          AREA ||i.send_byte||, CODE, READONLY, ALIGN=2

                  send_byte PROC
;;;400    
;;;401    uint8_t send_byte(uint8_t _ucByte)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;402    {
;;;403    	uint8_t i;
;;;404    	uint8_t uRet = 1;
;;;405    	/* 先发送字节的高位bit7 */
;;;406    	for (i = 0; i < 8; i++)
;;;407    	{		
;;;408    		if (_ucByte & 0x80)
;;;409    		{
;;;410    			EEPROM_I2C_SDA_1();
000004  4e19              LDR      r6,|L17.108|
000006  4605              MOV      r5,r0                 ;402
000008  f04f0801          MOV      r8,#1                 ;404
00000c  2400              MOVS     r4,#0                 ;406
;;;411    		}
;;;412    		else
;;;413    		{
;;;414    			EEPROM_I2C_SDA_0();
;;;415    		}
;;;416    		i2c_Delay();
;;;417    		EEPROM_I2C_SCL_1();
00000e  f44f7780          MOV      r7,#0x100
000012  f44f7900          MOV      r9,#0x200             ;410
                  |L17.22|
000016  0628              LSLS     r0,r5,#24             ;408
000018  4649              MOV      r1,r9                 ;414
00001a  4630              MOV      r0,r6                 ;414
00001c  d502              BPL      |L17.36|
00001e  f7fffffe          BL       GPIO_SetBits
000022  e001              B        |L17.40|
                  |L17.36|
000024  f7fffffe          BL       GPIO_ResetBits
                  |L17.40|
000028  f7fffffe          BL       i2c_Delay
00002c  4639              MOV      r1,r7
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       GPIO_SetBits
;;;418    		i2c_Delay();	
000034  f7fffffe          BL       i2c_Delay
;;;419    		EEPROM_I2C_SCL_0();
000038  4639              MOV      r1,r7
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       GPIO_ResetBits
;;;420    		if (i == 7)
000040  2c07              CMP      r4,#7
000042  d103              BNE      |L17.76|
;;;421    		{
;;;422    			 EEPROM_I2C_SDA_1(); // 释放总线
000044  4649              MOV      r1,r9
000046  4630              MOV      r0,r6
000048  f7fffffe          BL       GPIO_SetBits
                  |L17.76|
;;;423    		}
;;;424    		_ucByte <<= 1;	/* 左移一个bit */
00004c  0668              LSLS     r0,r5,#25
00004e  0e05              LSRS     r5,r0,#24
;;;425    		i2c_Delay();
000050  f7fffffe          BL       i2c_Delay
000054  1c64              ADDS     r4,r4,#1
000056  b2e4              UXTB     r4,r4                 ;406
000058  2c08              CMP      r4,#8                 ;406
00005a  d3dc              BCC      |L17.22|
;;;426    	}
;;;427    	if (i2c_WaitAck() == 0)
00005c  f7fffffe          BL       i2c_WaitAck
000060  b908              CBNZ     r0,|L17.102|
;;;428    	{
;;;429    			uRet = 0;	/* EEPROM器件无应答 */
000062  f04f0800          MOV      r8,#0
                  |L17.102|
;;;430    	}
;;;431    	return uRet;
000066  4640              MOV      r0,r8
;;;432    
;;;433    }
000068  e8bd87f0          POP      {r4-r10,pc}
;;;434    
                          ENDP

                  |L17.108|
                          DCD      0x40020400

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  iicInfo
000000  a2000000          DCB      0xa2,0x00,0x00,0x00
                          DCD      0x40005400
                          DCD      0x00030d40
                          DCD      0x00200000
                          DCD      0x00000002
                          DCD      0x40020400
000018  00080009          DCW      0x0008,0x0009
00001c  04000000          DCB      0x04,0x00,0x00,0x00
                          DCD      0x00000100
                          DCD      0x00000200
000028  a2000000          DCB      0xa2,0x00,0x00,0x00
                          DCD      0x40005400
                          DCD      0x00030d40
                          DCD      0x00200000
                          DCD      0x00000002
                          DCD      0x40020400
000040  00080009          DCW      0x0008,0x0009
000044  04000000          DCB      0x04,0x00,0x00,0x00
                          DCD      0x00000100
                          DCD      0x00000200
000050  a2000000          DCB      0xa2,0x00,0x00,0x00
                          DCD      0x40005400
                          DCD      0x00030d40
                          DCD      0x00200000
                          DCD      0x00000002
                          DCD      0x40020400
000068  00080009          DCW      0x0008,0x0009
00006c  04000000          DCB      0x04,0x00,0x00,0x00
                          DCD      0x00000100
                          DCD      0x00000200
000078  a2000000          DCB      0xa2,0x00,0x00,0x00
                          DCD      0x40005400
                          DCD      0x00030d40
                          DCD      0x00200000
                          DCD      0x00000002
                          DCD      0x40020400
000090  00080009          DCW      0x0008,0x0009
000094  04000000          DCB      0x04,0x00,0x00,0x00
                          DCD      0x00000100
                          DCD      0x00000200

;*** Start embedded assembler ***

#line 1 "..\\..\\Complex\\i2c\\bsp_i2c_gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_bsp_i2c_gpio_c_iicInfo____REV16|
#line 138 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___14_bsp_i2c_gpio_c_iicInfo____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_bsp_i2c_gpio_c_iicInfo____REVSH|
#line 153
|__asm___14_bsp_i2c_gpio_c_iicInfo____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_bsp_i2c_gpio_c_iicInfo____RRX|
#line 328
|__asm___14_bsp_i2c_gpio_c_iicInfo____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

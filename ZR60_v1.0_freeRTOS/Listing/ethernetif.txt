; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\ethernetif.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\ethernetif.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\ZR60_v1.0_freeRTOS -I..\..\Lwip\App -I..\..\Lwip\Bsp -I..\..\Lwip\Bsp\LAN8742A -I..\..\Lwip\lwip-1.4.1 -I..\..\Lwip\lwip-1.4.1\port -I..\..\Lwip\lwip-1.4.1\port\arch -I..\..\Lwip\lwip-1.4.1\port\Standalone -I..\..\Lwip\lwip-1.4.1\src\include -I..\..\Lwip\lwip-1.4.1\src\include\ipv4 -I..\..\Lwip\lwip-1.4.1\src\include\lwip -I..\..\Lwip\lwip-1.4.1\src\include\netif -I..\..\Ecal\BtnFltr -I..\..\Ecal\UartComn -I..\..\Ecal\MemIf -I..\..\APP -I..\..\APP\BlackListMng -I..\..\APP\SeverNewsPush -I..\..\APP\NewsPull -I..\..\Ecal -I..\..\Ecal\JsonIf -I..\..\Ecal\Mcu_Init -I..\..\Service -I..\..\Complex -I..\..\Complex\FATFS -I..\..\FreeRTOS\Source\include -I..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\FreeRTOS -I.\RTE\_ZR60 -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=..\..\output\ethernetif.crf ..\..\Lwip\lwip-1.4.1\port\Standalone\ethernetif.c]
                          THUMB

                          AREA ||i.ethernetif_init||, CODE, READONLY, ALIGN=2

                  ethernetif_init PROC
;;;360     */
;;;361    err_t ethernetif_init(struct netif *netif)
000000  b510              PUSH     {r4,lr}
;;;362    {
000002  0004              MOVS     r4,r0
000004  d102              BNE      |L1.12|
;;;363      LWIP_ASSERT("netif != NULL", (netif != NULL));
000006  a009              ADR      r0,|L1.44|
000008  f7fffffe          BL       __2printf
                  |L1.12|
;;;364      
;;;365    #if LWIP_NETIF_HOSTNAME
;;;366      /* Initialize interface hostname */
;;;367      netif->hostname = "lwip";
;;;368    #endif /* LWIP_NETIF_HOSTNAME */
;;;369    
;;;370      netif->name[0] = IFNAME0;
00000c  2073              MOVS     r0,#0x73
00000e  f8840032          STRB     r0,[r4,#0x32]
;;;371      netif->name[1] = IFNAME1;
000012  2074              MOVS     r0,#0x74
000014  f8840033          STRB     r0,[r4,#0x33]
;;;372      /* We directly use etharp_output() here to save a function call.
;;;373       * You can instead declare your own function an call etharp_output()
;;;374       * from it if you have to do some checks before sending (e.g. if link
;;;375       * is available...) */
;;;376      netif->output = etharp_output;
000018  4808              LDR      r0,|L1.60|
;;;377      netif->linkoutput = low_level_output;
00001a  6160              STR      r0,[r4,#0x14]
00001c  4808              LDR      r0,|L1.64|
;;;378    
;;;379      /* initialize the hardware */
;;;380      low_level_init(netif);
00001e  61a0              STR      r0,[r4,#0x18]
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       low_level_init
;;;381    
;;;382      return ERR_OK;
000026  2000              MOVS     r0,#0
;;;383    }
000028  bd10              POP      {r4,pc}
                          ENDP

00002a  0000              DCW      0x0000
                  |L1.44|
00002c  6e657469          DCB      "netif != NULL",0
000030  6620213d
000034  204e554c
000038  4c00    
00003a  00                DCB      0
00003b  00                DCB      0
                  |L1.60|
                          DCD      etharp_output
                  |L1.64|
                          DCD      low_level_output

                          AREA ||i.ethernetif_input||, CODE, READONLY, ALIGN=1

                  ethernetif_input PROC
;;;326     */
;;;327    err_t ethernetif_input(struct netif *netif)
000000  b570              PUSH     {r4-r6,lr}
;;;328    {
000002  4605              MOV      r5,r0
;;;329      err_t err;
;;;330      struct pbuf *p;
;;;331    
;;;332      /* move received packet into a new pbuf */
;;;333      p = low_level_input(netif);
000004  f7fffffe          BL       low_level_input
000008  0004              MOVS     r4,r0
;;;334    
;;;335      /* no packet could be read, silently ignore this */
;;;336      if (p == NULL) return ERR_MEM;
00000a  d009              BEQ      |L2.32|
;;;337    
;;;338      /* entry point to the LwIP stack */
;;;339      err = netif->input(p, netif);
00000c  692a              LDR      r2,[r5,#0x10]
00000e  4629              MOV      r1,r5
000010  4790              BLX      r2
000012  0005              MOVS     r5,r0
;;;340      
;;;341      if (err != ERR_OK)
000014  d002              BEQ      |L2.28|
;;;342      {
;;;343        LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
;;;344        pbuf_free(p);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       pbuf_free
                  |L2.28|
;;;345      }
;;;346      return err;
00001c  4628              MOV      r0,r5
;;;347    }
00001e  bd70              POP      {r4-r6,pc}
                  |L2.32|
000020  f04f30ff          MOV      r0,#0xffffffff        ;336
000024  bd70              POP      {r4-r6,pc}
;;;348    
                          ENDP


                          AREA ||i.low_level_init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  low_level_init PROC
;;;75      */
;;;76     static void low_level_init(struct netif *netif)
000000  b5fe              PUSH     {r1-r7,lr}
;;;77     {
000002  4604              MOV      r4,r0
;;;78     #ifdef CHECKSUM_BY_HARDWARE
;;;79       int i; 
;;;80     #endif
;;;81       //static uint8_t addr[6U];
;;;82       /* set MAC hardware address length */
;;;83       netif->hwaddr_len = ETHARP_HWADDR_LEN;
000004  2006              MOVS     r0,#6
000006  f884002a          STRB     r0,[r4,#0x2a]
;;;84     
;;;85       //ETH_GetMACAddress(ETH_MAC_Address0,addr);
;;;86       
;;;87       
;;;88       /* set MAC hardware address */
;;;89       if(Se_u_BleMacFlg == 1)
00000a  4842              LDR      r0,|L3.276|
00000c  7800              LDRB     r0,[r0,#0]  ; Se_u_BleMacFlg
00000e  2801              CMP      r0,#1
000010  d04e              BEQ      |L3.176|
;;;90       {
;;;91     	  netif->hwaddr[0] =  (((Se_u_MacAddr[0] << 4U)&0xF0)|(Se_u_MacAddr[1] & 0x0F));
;;;92     	  netif->hwaddr[1] =  (((Se_u_MacAddr[2] << 4U)&0xF0)|(Se_u_MacAddr[3] & 0x0F));
;;;93     	  netif->hwaddr[2] =  (((Se_u_MacAddr[4] << 4U)&0xF0)|(Se_u_MacAddr[5] & 0x0F));
;;;94     	  netif->hwaddr[3] =  (((Se_u_MacAddr[6] << 4U)&0xF0)|(Se_u_MacAddr[7] & 0x0F));
;;;95     	  netif->hwaddr[4] =  (((Se_u_MacAddr[8] << 4U)&0xF0)|(Se_u_MacAddr[9] & 0x0F));
;;;96     	  netif->hwaddr[5] =  (((Se_u_MacAddr[10] << 4U)&0xF0)|(Se_u_MacAddr[11] & 0x0F));
;;;97       }
;;;98       else
;;;99       {
;;;100    	  netif->hwaddr[0] =  (Ve_h_tm.tm_year%1000);
000012  4841              LDR      r0,|L3.280|
000014  f44f727a          MOV      r2,#0x3e8
000018  6941              LDR      r1,[r0,#0x14]  ; Ve_h_tm
00001a  fb91f3f2          SDIV     r3,r1,r2
00001e  fb021113          MLS      r1,r2,r3,r1
000022  f884102b          STRB     r1,[r4,#0x2b]
;;;101    	  netif->hwaddr[1] =  Ve_h_tm.tm_mon;
000026  7c01              LDRB     r1,[r0,#0x10]  ; Ve_h_tm
000028  f884102c          STRB     r1,[r4,#0x2c]
;;;102    	  netif->hwaddr[2] =  Ve_h_tm.tm_mday;
00002c  7b01              LDRB     r1,[r0,#0xc]  ; Ve_h_tm
00002e  f884102d          STRB     r1,[r4,#0x2d]
;;;103    	  netif->hwaddr[3] =  Ve_h_tm.tm_hour;
000032  7a01              LDRB     r1,[r0,#8]  ; Ve_h_tm
000034  f884102e          STRB     r1,[r4,#0x2e]
;;;104    	  netif->hwaddr[4] =  Ve_h_tm.tm_min;
000038  7901              LDRB     r1,[r0,#4]  ; Ve_h_tm
00003a  f884102f          STRB     r1,[r4,#0x2f]
;;;105    	  netif->hwaddr[5] =  Ve_h_tm.tm_sec;
00003e  7800              LDRB     r0,[r0,#0]  ; Ve_h_tm
000040  f8840030          STRB     r0,[r4,#0x30]
                  |L3.68|
;;;106      }
;;;107      printf("MACµØÖ·: %x£º%x£º%x£º%x£º%x£º%x\n",netif->hwaddr[0],netif->hwaddr[1],netif->hwaddr[2],\
000044  f894002e          LDRB     r0,[r4,#0x2e]
000048  f8942030          LDRB     r2,[r4,#0x30]
00004c  f894102f          LDRB     r1,[r4,#0x2f]
000050  e88d0007          STM      sp,{r0-r2}
000054  f894302d          LDRB     r3,[r4,#0x2d]
000058  f894202c          LDRB     r2,[r4,#0x2c]
00005c  f894102b          LDRB     r1,[r4,#0x2b]
000060  a02e              ADR      r0,|L3.284|
000062  f7fffffe          BL       __2printf
;;;108    		 netif->hwaddr[3],netif->hwaddr[4],netif->hwaddr[5]);
;;;109      /* initialize MAC address in ethernet MAC */ 
;;;110      ETH_MACAddressConfig(ETH_MAC_Address0, netif->hwaddr); 
000066  f104012b          ADD      r1,r4,#0x2b
00006a  2000              MOVS     r0,#0
00006c  f7fffffe          BL       ETH_MACAddressConfig
;;;111      //ETH_GetMACAddress(ETH_MAC_Address0,addr);
;;;112      /* maximum transfer unit */
;;;113      netif->mtu = 1500;
000070  f24050dc          MOV      r0,#0x5dc
000074  8520              STRH     r0,[r4,#0x28]
;;;114    
;;;115      /* device capabilities */
;;;116      /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
;;;117      netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
000076  2022              MOVS     r0,#0x22
000078  f8840031          STRB     r0,[r4,#0x31]
;;;118    
;;;119      /* Initialize Tx Descriptors list: Chain Mode */
;;;120      ETH_DMATxDescChainInit(DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
00007c  2208              MOVS     r2,#8
00007e  4930              LDR      r1,|L3.320|
000080  4830              LDR      r0,|L3.324|
000082  f7fffffe          BL       ETH_DMATxDescChainInit
;;;121      /* Initialize Rx Descriptors list: Chain Mode  */
;;;122      ETH_DMARxDescChainInit(DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
000086  2210              MOVS     r2,#0x10
000088  492f              LDR      r1,|L3.328|
00008a  4830              LDR      r0,|L3.332|
00008c  f7fffffe          BL       ETH_DMARxDescChainInit
000090  4d2c              LDR      r5,|L3.324|
;;;123    
;;;124    #ifdef CHECKSUM_BY_HARDWARE
;;;125      /* Enable the TCP, UDP and ICMP checksum insertion for the Tx frames */
;;;126      for(i=0; i<ETH_TXBUFNB; i++)
000092  2400              MOVS     r4,#0
;;;127        {
;;;128          ETH_DMATxDescChecksumInsertionConfig(&DMATxDscrTab[i], ETH_DMATxDesc_ChecksumTCPUDPICMPFull);
000094  f44f0640          MOV      r6,#0xc00000
                  |L3.152|
000098  eb051044          ADD      r0,r5,r4,LSL #5
00009c  4631              MOV      r1,r6
00009e  f7fffffe          BL       ETH_DMATxDescChecksumInsertionConfig
0000a2  1c64              ADDS     r4,r4,#1
0000a4  2c08              CMP      r4,#8                 ;126
0000a6  dbf7              BLT      |L3.152|
;;;129        }
;;;130    #endif
;;;131    
;;;132       /* Note: TCP, UDP, ICMP checksum checking for received frame are enabled in DMA config */
;;;133    
;;;134      /* Enable MAC and DMA transmission and reception */
;;;135      ETH_Start();
0000a8  e8bd40fe          POP      {r1-r7,lr}
0000ac  f7ffbffe          B.W      ETH_Start
                  |L3.176|
0000b0  4827              LDR      r0,|L3.336|
0000b2  7842              LDRB     r2,[r0,#1]            ;91  ; Se_u_MacAddr
0000b4  7801              LDRB     r1,[r0,#0]            ;91  ; Se_u_MacAddr
0000b6  f002020f          AND      r2,r2,#0xf            ;91
0000ba  ea421101          ORR      r1,r2,r1,LSL #4       ;91
0000be  f884102b          STRB     r1,[r4,#0x2b]         ;91
0000c2  78c2              LDRB     r2,[r0,#3]            ;92  ; Se_u_MacAddr
0000c4  7881              LDRB     r1,[r0,#2]            ;92  ; Se_u_MacAddr
0000c6  f002020f          AND      r2,r2,#0xf            ;92
0000ca  ea421101          ORR      r1,r2,r1,LSL #4       ;92
0000ce  f884102c          STRB     r1,[r4,#0x2c]         ;92
0000d2  7942              LDRB     r2,[r0,#5]            ;93  ; Se_u_MacAddr
0000d4  7901              LDRB     r1,[r0,#4]            ;93  ; Se_u_MacAddr
0000d6  f002020f          AND      r2,r2,#0xf            ;93
0000da  ea421101          ORR      r1,r2,r1,LSL #4       ;93
0000de  f884102d          STRB     r1,[r4,#0x2d]         ;93
0000e2  79c2              LDRB     r2,[r0,#7]            ;94  ; Se_u_MacAddr
0000e4  7981              LDRB     r1,[r0,#6]            ;94  ; Se_u_MacAddr
0000e6  f002020f          AND      r2,r2,#0xf            ;94
0000ea  ea421101          ORR      r1,r2,r1,LSL #4       ;94
0000ee  f884102e          STRB     r1,[r4,#0x2e]         ;94
0000f2  7a42              LDRB     r2,[r0,#9]            ;95  ; Se_u_MacAddr
0000f4  7a01              LDRB     r1,[r0,#8]            ;95  ; Se_u_MacAddr
0000f6  f002020f          AND      r2,r2,#0xf            ;95
0000fa  ea421101          ORR      r1,r2,r1,LSL #4       ;95
0000fe  f884102f          STRB     r1,[r4,#0x2f]         ;95
000102  7a81              LDRB     r1,[r0,#0xa]          ;96  ; Se_u_MacAddr
000104  7ac0              LDRB     r0,[r0,#0xb]          ;96  ; Se_u_MacAddr
000106  f000000f          AND      r0,r0,#0xf            ;96
00010a  ea401101          ORR      r1,r0,r1,LSL #4       ;96
00010e  f8841030          STRB     r1,[r4,#0x30]         ;96
000112  e797              B        |L3.68|
;;;136    
;;;137    }
;;;138    
                          ENDP

                  |L3.276|
                          DCD      Se_u_BleMacFlg
                  |L3.280|
                          DCD      Ve_h_tm
                  |L3.284|
00011c  4d4143b5          DCB      "MAC",181,216,214,183,": %x",163,186,"%x",163,186,"%x",163
000120  d8d6b73a
000124  202578a3
000128  ba2578a3
00012c  ba2578a3
000130  ba2578a3          DCB      186,"%x",163,186,"%x",163,186,"%x\n",0
000134  ba2578a3
000138  ba25780a
00013c  00      
00013d  00                DCB      0
00013e  00                DCB      0
00013f  00                DCB      0
                  |L3.320|
                          DCD      Tx_Buff
                  |L3.324|
                          DCD      DMATxDscrTab
                  |L3.328|
                          DCD      Rx_Buff
                  |L3.332|
                          DCD      DMARxDscrTab
                  |L3.336|
                          DCD      Se_u_MacAddr

                          AREA ||i.low_level_input||, CODE, READONLY, ALIGN=2

                  low_level_input PROC
;;;242       */
;;;243    static struct pbuf * low_level_input(struct netif *netif)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;244    {
;;;245      struct pbuf *p, *q;
;;;246      uint32_t len;
;;;247      FrameTypeDef frame;
;;;248      u8 *buffer;
;;;249      __IO ETH_DMADESCTypeDef *DMARxDesc;
;;;250      uint32_t bufferoffset = 0;
000004  2400              MOVS     r4,#0
;;;251      uint32_t payloadoffset = 0;
;;;252      uint32_t byteslefttocopy = 0;
;;;253      uint32_t i=0;  
;;;254      
;;;255      /* get received frame */
;;;256      frame = ETH_Get_Received_Frame();
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       ETH_Get_Received_Frame
00000c  e89d0007          LDM      sp,{r0-r2}
;;;257      
;;;258      /* Obtain the size of the packet and put it into the "len" variable. */
;;;259      len = frame.length;
;;;260      buffer = (u8 *)frame.buffer;
000010  4689              MOV      r9,r1
;;;261      
;;;262      /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
;;;263      p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
000012  9203              STR      r2,[sp,#0xc]
000014  b281              UXTH     r1,r0
000016  2203              MOVS     r2,#3
000018  4610              MOV      r0,r2
00001a  f7fffffe          BL       pbuf_alloc
;;;264      
;;;265      if (p != NULL)
00001e  9001              STR      r0,[sp,#4]
000020  b320              CBZ      r0,|L4.108|
;;;266      {
;;;267        DMARxDesc = frame.descriptor;
;;;268        bufferoffset = 0;
;;;269        for(q = p; q != NULL; q = q->next)
;;;270        {
;;;271          byteslefttocopy = q->len;
;;;272          payloadoffset = 0;
;;;273          
;;;274          /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size*/
;;;275          while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
000022  9f03              LDR      r7,[sp,#0xc]
000024  4605              MOV      r5,r0                 ;269
000026  f2405bf4          MOV      r11,#0x5f4
                  |L4.42|
00002a  f8b5800a          LDRH     r8,[r5,#0xa]          ;271
00002e  2600              MOVS     r6,#0                 ;272
000030  e00d              B        |L4.78|
                  |L4.50|
;;;276          {
;;;277            /* Copy data to pbuf*/
;;;278            memcpy( (u8_t*)((u8_t*)q->payload + payloadoffset), (u8_t*)((u8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
000032  f2a452f4          SUB      r2,r4,#0x5f4
000036  4252              RSBS     r2,r2,#0
000038  f7fffffe          BL       __aeabi_memcpy
;;;279            
;;;280            /* Point to next descriptor */
;;;281            DMARxDesc = (ETH_DMADESCTypeDef *)(DMARxDesc->Buffer2NextDescAddr);
00003c  68ff              LDR      r7,[r7,#0xc]
;;;282            buffer = (unsigned char *)(DMARxDesc->Buffer1Addr);
00003e  f8d79008          LDR      r9,[r7,#8]
;;;283            
;;;284            byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
;;;285            payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
000042  1b36              SUBS     r6,r6,r4
000044  f2aa58f4          SUB      r8,r10,#0x5f4         ;284
;;;286            bufferoffset = 0;
000048  2400              MOVS     r4,#0
00004a  f20656f4          ADD      r6,r6,#0x5f4
                  |L4.78|
;;;287          }
;;;288          /* Copy remaining data in pbuf */
;;;289          memcpy( (u8_t*)((u8_t*)q->payload + payloadoffset), (u8_t*)((u8_t*)buffer + bufferoffset), byteslefttocopy);
00004e  6868              LDR      r0,[r5,#4]
000050  eb080a04          ADD      r10,r8,r4             ;275
000054  45da              CMP      r10,r11               ;275
000056  eb090104          ADD      r1,r9,r4
00005a  4430              ADD      r0,r0,r6
00005c  d8e9              BHI      |L4.50|
00005e  4642              MOV      r2,r8
000060  f7fffffe          BL       __aeabi_memcpy
000064  682d              LDR      r5,[r5,#0]            ;269
;;;290          bufferoffset = bufferoffset + byteslefttocopy;
000066  4444              ADD      r4,r4,r8
000068  2d00              CMP      r5,#0                 ;269
00006a  d1de              BNE      |L4.42|
                  |L4.108|
;;;291        }
;;;292      }
;;;293      
;;;294      /* Release descriptors to DMA */
;;;295      DMARxDesc =frame.descriptor;
;;;296    
;;;297      /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
;;;298      for (i=0; i<DMA_RX_FRAME_infos->Seg_Count; i++)
00006c  2100              MOVS     r1,#0
00006e  4b0d              LDR      r3,|L4.164|
;;;299      {  
;;;300        DMARxDesc->Status = ETH_DMARxDesc_OWN;
000070  f04f4200          MOV      r2,#0x80000000
000074  9803              LDR      r0,[sp,#0xc]          ;298
000076  e002              B        |L4.126|
                  |L4.120|
000078  6002              STR      r2,[r0,#0]
;;;301        DMARxDesc = (ETH_DMADESCTypeDef *)(DMARxDesc->Buffer2NextDescAddr);
00007a  68c0              LDR      r0,[r0,#0xc]
00007c  1c49              ADDS     r1,r1,#1
                  |L4.126|
00007e  681c              LDR      r4,[r3,#0]            ;298  ; DMA_RX_FRAME_infos
000080  68a4              LDR      r4,[r4,#8]            ;298
000082  428c              CMP      r4,r1                 ;298
000084  d8f8              BHI      |L4.120|
;;;302      }
;;;303      
;;;304      /* Clear Segment_Count */
;;;305      DMA_RX_FRAME_infos->Seg_Count =0;
000086  6819              LDR      r1,[r3,#0]  ; DMA_RX_FRAME_infos
000088  2000              MOVS     r0,#0
00008a  6088              STR      r0,[r1,#8]
;;;306      
;;;307      /* When Rx Buffer unavailable flag is set: clear it and resume reception */
;;;308      if ((ETH->DMASR & ETH_DMASR_RBUS) != (u32)RESET)  
00008c  4906              LDR      r1,|L4.168|
00008e  694a              LDR      r2,[r1,#0x14]
000090  0612              LSLS     r2,r2,#24
000092  d502              BPL      |L4.154|
;;;309      {
;;;310        /* Clear RBUS ETHERNET DMA flag */
;;;311        ETH->DMASR = ETH_DMASR_RBUS;
000094  2280              MOVS     r2,#0x80
000096  614a              STR      r2,[r1,#0x14]
;;;312        /* Resume DMA reception */
;;;313        ETH->DMARPDR = 0;
000098  6088              STR      r0,[r1,#8]
                  |L4.154|
;;;314      }
;;;315      return p;
00009a  9801              LDR      r0,[sp,#4]
;;;316    }
00009c  b004              ADD      sp,sp,#0x10
00009e  e8bd9ff0          POP      {r4-r12,pc}
;;;317    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L4.164|
                          DCD      DMA_RX_FRAME_infos
                  |L4.168|
                          DCD      0x40029000

                          AREA ||i.low_level_output||, CODE, READONLY, ALIGN=2

                  low_level_output PROC
;;;154    
;;;155    static err_t low_level_output(struct netif *netif, struct pbuf *p)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;156    {
;;;157      err_t errval;
;;;158      struct pbuf *q;
;;;159      u8 *buffer =  (u8 *)(DMATxDescToSet->Buffer1Addr);
000004  4827              LDR      r0,|L5.164|
000006  460e              MOV      r6,r1                 ;156
000008  6805              LDR      r5,[r0,#0]  ; DMATxDescToSet
;;;160      __IO ETH_DMADESCTypeDef *DmaTxDesc;
;;;161      uint16_t framelength = 0;
00000a  2000              MOVS     r0,#0
00000c  4681              MOV      r9,r0
;;;162      uint32_t bufferoffset = 0;
00000e  4604              MOV      r4,r0
000010  f8d5a008          LDR      r10,[r5,#8]           ;156
000014  e037              B        |L5.134|
                  |L5.22|
;;;163      uint32_t byteslefttocopy = 0;
;;;164      uint32_t payloadoffset = 0;
;;;165    
;;;166      DmaTxDesc = DMATxDescToSet;
;;;167      bufferoffset = 0;
;;;168    
;;;169      /* copy frame from pbufs to driver buffers */
;;;170      for(q = p; q != NULL; q = q->next)
;;;171        {
;;;172          /* Is this buffer available? If not, goto error */
;;;173          if((DmaTxDesc->Status & ETH_DMATxDesc_OWN) != (u32)RESET)
000016  6828              LDR      r0,[r5,#0]
000018  2800              CMP      r0,#0
00001a  da02              BGE      |L5.34|
;;;174          {
;;;175            errval = ERR_BUF;
00001c  f06f0001          MVN      r0,#1
;;;176            goto error;
000020  e036              B        |L5.144|
                  |L5.34|
;;;177          }
;;;178    
;;;179          /* Get bytes in current lwIP buffer */
;;;180          byteslefttocopy = q->len;
000022  f8b6800a          LDRH     r8,[r6,#0xa]
;;;181          payloadoffset = 0;
000026  2700              MOVS     r7,#0
;;;182    
;;;183          /* Check if the length of data to copy is bigger than Tx buffer size*/
;;;184          while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
000028  e019              B        |L5.94|
                  |L5.42|
;;;185          {
;;;186            /* Copy data to Tx buffer*/
;;;187            memcpy( (u8_t*)((u8_t*)buffer + bufferoffset), (u8_t*)((u8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
00002a  f2a452f4          SUB      r2,r4,#0x5f4
00002e  4252              RSBS     r2,r2,#0
000030  f7fffffe          BL       __aeabi_memcpy
;;;188    
;;;189            /* Point to next descriptor */
;;;190            DmaTxDesc = (ETH_DMADESCTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
000034  68ed              LDR      r5,[r5,#0xc]
;;;191    
;;;192            /* Check if the buffer is available */
;;;193            if((DmaTxDesc->Status & ETH_DMATxDesc_OWN) != (u32)RESET)
000036  6828              LDR      r0,[r5,#0]
000038  2800              CMP      r0,#0
00003a  da02              BGE      |L5.66|
;;;194            {
;;;195              errval = ERR_USE;
00003c  f06f0007          MVN      r0,#7
;;;196              goto error;
000040  e026              B        |L5.144|
                  |L5.66|
;;;197            }
;;;198    
;;;199            buffer = (u8 *)(DmaTxDesc->Buffer1Addr);
000042  f8d5a008          LDR      r10,[r5,#8]
;;;200    
;;;201            byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
;;;202            payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
;;;203            framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
000046  eba90004          SUB      r0,r9,r4
00004a  1b3f              SUBS     r7,r7,r4              ;202
00004c  f20050f4          ADD      r0,r0,#0x5f4
000050  f2ab58f4          SUB      r8,r11,#0x5f4         ;201
000054  fa1ff980          UXTH     r9,r0
;;;204            bufferoffset = 0;
000058  2400              MOVS     r4,#0
00005a  f20757f4          ADD      r7,r7,#0x5f4
                  |L5.94|
00005e  eb080b04          ADD      r11,r8,r4             ;184
000062  f24051f4          MOV      r1,#0x5f4             ;184
;;;205          }
;;;206    
;;;207          /* Copy the remaining bytes */
;;;208          memcpy( (u8_t*)((u8_t*)buffer + bufferoffset), (u8_t*)((u8_t*)q->payload + payloadoffset), byteslefttocopy );
000066  6870              LDR      r0,[r6,#4]
000068  458b              CMP      r11,r1                ;184
00006a  eb000107          ADD      r1,r0,r7
00006e  eb0a0004          ADD      r0,r10,r4
000072  d8da              BHI      |L5.42|
000074  4642              MOV      r2,r8
000076  f7fffffe          BL       __aeabi_memcpy
;;;209          bufferoffset = bufferoffset + byteslefttocopy;
;;;210          framelength = framelength + byteslefttocopy;
00007a  eb090008          ADD      r0,r9,r8
00007e  b280              UXTH     r0,r0
000080  6836              LDR      r6,[r6,#0]            ;170
000082  4444              ADD      r4,r4,r8              ;209
000084  4681              MOV      r9,r0
                  |L5.134|
000086  2e00              CMP      r6,#0                 ;170
000088  d1c5              BNE      |L5.22|
;;;211        }
;;;212      
;;;213      /* Note: padding and CRC for transmitted frame 
;;;214         are automatically inserted by DMA */
;;;215    
;;;216      /* Prepare transmit descriptors to give to DMA*/ 
;;;217      ETH_Prepare_Transmit_Descriptors(framelength);
00008a  f7fffffe          BL       ETH_Prepare_Transmit_Descriptors
;;;218    
;;;219      errval = ERR_OK;
00008e  2000              MOVS     r0,#0
                  |L5.144|
;;;220    
;;;221    error:
;;;222      
;;;223      /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
;;;224      if ((ETH->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
000090  4905              LDR      r1,|L5.168|
000092  694a              LDR      r2,[r1,#0x14]
000094  0692              LSLS     r2,r2,#26
000096  d503              BPL      |L5.160|
;;;225      {
;;;226        /* Clear TUS ETHERNET DMA flag */
;;;227        ETH->DMASR = ETH_DMASR_TUS;
000098  2220              MOVS     r2,#0x20
00009a  614a              STR      r2,[r1,#0x14]
;;;228    
;;;229        /* Resume DMA transmission*/
;;;230        ETH->DMATPDR = 0;
00009c  2200              MOVS     r2,#0
00009e  604a              STR      r2,[r1,#4]
                  |L5.160|
;;;231      }
;;;232      return errval;
;;;233    }
0000a0  e8bd9ff0          POP      {r4-r12,pc}
;;;234    
                          ENDP

                  |L5.164|
                          DCD      DMATxDescToSet
                  |L5.168|
                          DCD      0x40029000

;*** Start embedded assembler ***

#line 1 "..\\..\\Lwip\\lwip-1.4.1\\port\\Standalone\\ethernetif.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_ethernetif_c_1b991e46____REV16|
#line 138 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_ethernetif_c_1b991e46____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_ethernetif_c_1b991e46____REVSH|
#line 153
|__asm___12_ethernetif_c_1b991e46____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_ethernetif_c_1b991e46____RRX|
#line 328
|__asm___12_ethernetif_c_1b991e46____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\ip_addr.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\ip_addr.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\ZR60_v1.0_freeRTOS -I..\..\Lwip\App -I..\..\Lwip\Bsp -I..\..\Lwip\Bsp\LAN8742A -I..\..\Lwip\lwip-1.4.1 -I..\..\Lwip\lwip-1.4.1\port -I..\..\Lwip\lwip-1.4.1\port\arch -I..\..\Lwip\lwip-1.4.1\port\Standalone -I..\..\Lwip\lwip-1.4.1\src\include -I..\..\Lwip\lwip-1.4.1\src\include\ipv4 -I..\..\Lwip\lwip-1.4.1\src\include\lwip -I..\..\Lwip\lwip-1.4.1\src\include\netif -I..\..\Ecal\BtnFltr -I..\..\Ecal\UartComn -I..\..\Ecal\MemIf -I..\..\APP -I..\..\APP\BlackListMng -I..\..\APP\SeverNewsPush -I..\..\APP\NewsPull -I..\..\Ecal -I..\..\Ecal\JsonIf -I..\..\Ecal\Mcu_Init -I..\..\Service -I..\..\Complex -I..\..\Complex\FATFS -I..\..\FreeRTOS\Source\include -I..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\FreeRTOS -I.\RTE\_ZR60 -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=..\..\output\ip_addr.crf ..\..\Lwip\lwip-1.4.1\src\core\ipv4\ip_addr.c]
                          THUMB

                          AREA ||i.ip4_addr_isbroadcast||, CODE, READONLY, ALIGN=1

                  ip4_addr_isbroadcast PROC
;;;54     u8_t
;;;55     ip4_addr_isbroadcast(u32_t addr, const struct netif *netif)
000000  1c42              ADDS     r2,r0,#1
;;;56     {
000002  d012              BEQ      |L1.42|
;;;57       ip_addr_t ipaddr;
;;;58       ip4_addr_set_u32(&ipaddr, addr);
;;;59     
;;;60       /* all ones (broadcast) or all zeroes (old skool broadcast) */
;;;61       if ((~addr == IPADDR_ANY) ||
;;;62           (addr == IPADDR_ANY)) {
000004  b188              CBZ      r0,|L1.42|
;;;63         return 1;
;;;64       /* no broadcast support on this network interface? */
;;;65       } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
000006  f8912031          LDRB     r2,[r1,#0x31]
00000a  0792              LSLS     r2,r2,#30
00000c  d50b              BPL      |L1.38|
;;;66         /* the given address cannot be a broadcast address
;;;67          * nor can we check against any broadcast addresses */
;;;68         return 0;
;;;69       /* address matches network interface address exactly? => no broadcast */
;;;70       } else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
00000e  684a              LDR      r2,[r1,#4]
000010  4282              CMP      r2,r0
000012  d008              BEQ      |L1.38|
;;;71         return 0;
;;;72       /*  on the same (sub) network... */
;;;73       } else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
000014  6889              LDR      r1,[r1,#8]
000016  ea000301          AND      r3,r0,r1
00001a  400a              ANDS     r2,r2,r1
00001c  4293              CMP      r3,r2
00001e  d102              BNE      |L1.38|
;;;74              /* ...and host identifier bits are all ones? =>... */
;;;75               && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
000020  4301              ORRS     r1,r1,r0
000022  1c49              ADDS     r1,r1,#1
000024  d001              BEQ      |L1.42|
                  |L1.38|
;;;76                (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
;;;77         /* => network broadcast address */
;;;78         return 1;
;;;79       } else {
;;;80         return 0;
000026  2000              MOVS     r0,#0
;;;81       }
;;;82     }
000028  4770              BX       lr
                  |L1.42|
00002a  2001              MOVS     r0,#1                 ;78
00002c  4770              BX       lr
;;;83     
                          ENDP


                          AREA ||i.ip4_addr_netmask_valid||, CODE, READONLY, ALIGN=1

                  ip4_addr_netmask_valid PROC
;;;89     u8_t
;;;90     ip4_addr_netmask_valid(u32_t netmask)
000000  b510              PUSH     {r4,lr}
;;;91     {
;;;92       u32_t mask;
;;;93       u32_t nm_hostorder = lwip_htonl(netmask);
000002  f7fffffe          BL       lwip_htonl
;;;94     
;;;95       /* first, check for the first zero */
;;;96       for (mask = 1UL << 31 ; mask != 0; mask >>= 1) {
000006  f04f4100          MOV      r1,#0x80000000
                  |L2.10|
;;;97         if ((nm_hostorder & mask) == 0) {
00000a  4208              TST      r0,r1
00000c  d007              BEQ      |L2.30|
00000e  0849              LSRS     r1,r1,#1              ;96
000010  d1fb              BNE      |L2.10|
000012  e006              B        |L2.34|
                  |L2.20|
;;;98           break;
;;;99         }
;;;100      }
;;;101      /* then check that there is no one */
;;;102      for (; mask != 0; mask >>= 1) {
;;;103        if ((nm_hostorder & mask) != 0) {
000014  4208              TST      r0,r1
000016  d001              BEQ      |L2.28|
;;;104          /* there is a one after the first zero -> invalid */
;;;105          return 0;
000018  2000              MOVS     r0,#0
;;;106        }
;;;107      }
;;;108      /* no one after the first zero -> valid */
;;;109      return 1;
;;;110    }
00001a  bd10              POP      {r4,pc}
                  |L2.28|
00001c  0849              LSRS     r1,r1,#1              ;102
                  |L2.30|
00001e  2900              CMP      r1,#0                 ;102
000020  d1f8              BNE      |L2.20|
                  |L2.34|
000022  2001              MOVS     r0,#1                 ;109
000024  bd10              POP      {r4,pc}
;;;111    
                          ENDP


                          AREA ||i.ipaddr_addr||, CODE, READONLY, ALIGN=1

                  ipaddr_addr PROC
;;;129    u32_t
;;;130    ipaddr_addr(const char *cp)
000000  b508              PUSH     {r3,lr}
;;;131    {
;;;132      ip_addr_t val;
;;;133    
;;;134      if (ipaddr_aton(cp, &val)) {
000002  4669              MOV      r1,sp
000004  f7fffffe          BL       ipaddr_aton
000008  b108              CBZ      r0,|L3.14|
;;;135        return ip4_addr_get_u32(&val);
00000a  9800              LDR      r0,[sp,#0]
;;;136      }
;;;137      return (IPADDR_NONE);
;;;138    }
00000c  bd08              POP      {r3,pc}
                  |L3.14|
00000e  f04f30ff          MOV      r0,#0xffffffff        ;137
000012  bd08              POP      {r3,pc}
;;;139    
                          ENDP


                          AREA ||i.ipaddr_aton||, CODE, READONLY, ALIGN=2

                  ipaddr_aton PROC
;;;151    int
;;;152    ipaddr_aton(const char *cp, ip_addr_t *addr)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;153    {
;;;154      u32_t val;
;;;155      u8_t base;
;;;156      char c;
;;;157      u32_t parts[4];
;;;158      u32_t *pp = parts;
;;;159    
;;;160      c = *cp;
000004  7802              LDRB     r2,[r0,#0]
000006  460d              MOV      r5,r1                 ;153
000008  466b              MOV      r3,sp                 ;158
                  |L4.10|
;;;161      for (;;) {
;;;162        /*
;;;163         * Collect number up to ``.''.
;;;164         * Values are specified as for C:
;;;165         * 0x=hex, 0=octal, 1-9=decimal.
;;;166         */
;;;167        if (!isdigit(c))
00000a  f1a20130          SUB      r1,r2,#0x30
00000e  290a              CMP      r1,#0xa
000010  d25e              BCS      |L4.208|
;;;168          return (0);
;;;169        val = 0;
000012  2400              MOVS     r4,#0
;;;170        base = 10;
000014  210a              MOVS     r1,#0xa
;;;171        if (c == '0') {
000016  2a30              CMP      r2,#0x30
000018  d106              BNE      |L4.40|
;;;172          c = *++cp;
00001a  f8102f01          LDRB     r2,[r0,#1]!
;;;173          if (c == 'x' || c == 'X') {
00001e  2a78              CMP      r2,#0x78
000020  d009              BEQ      |L4.54|
000022  2a58              CMP      r2,#0x58
000024  d007              BEQ      |L4.54|
;;;174            base = 16;
;;;175            c = *++cp;
;;;176          } else
;;;177            base = 8;
000026  2108              MOVS     r1,#8
                  |L4.40|
;;;178        }
;;;179        for (;;) {
;;;180          if (isdigit(c)) {
000028  f1a20630          SUB      r6,r2,#0x30
00002c  2e09              CMP      r6,#9
00002e  d804              BHI      |L4.58|
;;;181            val = (val * base) + (int)(c - '0');
000030  fb046401          MLA      r4,r4,r1,r6
;;;182            c = *++cp;
000034  e014              B        |L4.96|
                  |L4.54|
000036  2110              MOVS     r1,#0x10              ;174
000038  e012              B        |L4.96|
                  |L4.58|
;;;183          } else if (base == 16 && isxdigit(c)) {
00003a  2910              CMP      r1,#0x10
00003c  d113              BNE      |L4.102|
00003e  f1a20661          SUB      r6,r2,#0x61
000042  2e05              CMP      r6,#5
000044  d903              BLS      |L4.78|
000046  f1a20741          SUB      r7,r2,#0x41
00004a  2f05              CMP      r7,#5
00004c  d80b              BHI      |L4.102|
                  |L4.78|
;;;184            val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
00004e  2e19              CMP      r6,#0x19
000050  d801              BHI      |L4.86|
000052  2661              MOVS     r6,#0x61
000054  e000              B        |L4.88|
                  |L4.86|
000056  2641              MOVS     r6,#0x41
                  |L4.88|
000058  1b92              SUBS     r2,r2,r6
00005a  320a              ADDS     r2,r2,#0xa
00005c  ea421404          ORR      r4,r2,r4,LSL #4
                  |L4.96|
000060  f8102f01          LDRB     r2,[r0,#1]!           ;175
000064  e7e0              B        |L4.40|
                  |L4.102|
;;;185            c = *++cp;
;;;186          } else
;;;187            break;
;;;188        }
;;;189        if (c == '.') {
000066  2a2e              CMP      r2,#0x2e
000068  d00d              BEQ      |L4.134|
;;;190          /*
;;;191           * Internet format:
;;;192           *  a.b.c.d
;;;193           *  a.b.c   (with c treated as 16 bits)
;;;194           *  a.b (with b treated as 24 bits)
;;;195           */
;;;196          if (pp >= parts + 3) {
;;;197            return (0);
;;;198          }
;;;199          *pp++ = val;
;;;200          c = *++cp;
;;;201        } else
;;;202          break;
;;;203      }
;;;204      /*
;;;205       * Check for trailing characters.
;;;206       */
;;;207      if (c != '\0' && !isspace(c)) {
00006a  b19a              CBZ      r2,|L4.148|
00006c  2a20              CMP      r2,#0x20
00006e  d011              BEQ      |L4.148|
000070  2a0c              CMP      r2,#0xc
000072  d00f              BEQ      |L4.148|
000074  2a0a              CMP      r2,#0xa
000076  d00d              BEQ      |L4.148|
000078  2a0d              CMP      r2,#0xd
00007a  d00b              BEQ      |L4.148|
00007c  2a09              CMP      r2,#9
00007e  d009              BEQ      |L4.148|
000080  2a0b              CMP      r2,#0xb
000082  d125              BNE      |L4.208|
000084  e006              B        |L4.148|
                  |L4.134|
000086  a903              ADD      r1,sp,#0xc
000088  428b              CMP      r3,r1                 ;196
00008a  d221              BCS      |L4.208|
00008c  c310              STM      r3!,{r4}              ;199
00008e  f8102f01          LDRB     r2,[r0,#1]!           ;200
000092  e7ba              B        |L4.10|
                  |L4.148|
;;;208        return (0);
;;;209      }
;;;210      /*
;;;211       * Concoct the address according to
;;;212       * the number of parts specified.
;;;213       */
;;;214      switch (pp - parts + 1) {
000094  4668              MOV      r0,sp
000096  1a18              SUBS     r0,r3,r0
000098  2101              MOVS     r1,#1
00009a  eb0100a0          ADD      r0,r1,r0,ASR #2
00009e  2805              CMP      r0,#5
0000a0  d224              BCS      |L4.236|
0000a2  e8dff000          TBB      [pc,r0]
0000a6  1526              DCB      0x15,0x26
0000a8  030a1300          DCB      0x03,0x0a,0x13,0x00
;;;215    
;;;216      case 0:
;;;217        return (0);       /* initial nondigit */
;;;218    
;;;219      case 1:             /* a -- 32 bits */
;;;220        break;
;;;221    
;;;222      case 2:             /* a.b -- 8.24 bits */
;;;223        if (val > 0xffffffUL) {
0000ac  f1b47f80          CMP      r4,#0x1000000
0000b0  d20e              BCS      |L4.208|
;;;224          return (0);
;;;225        }
;;;226        val |= parts[0] << 24;
0000b2  9800              LDR      r0,[sp,#0]
0000b4  ea446400          ORR      r4,r4,r0,LSL #24
;;;227        break;
0000b8  e01b              B        |L4.242|
;;;228    
;;;229      case 3:             /* a.b.c -- 8.8.16 bits */
;;;230        if (val > 0xffff) {
0000ba  f5b43f80          CMP      r4,#0x10000
0000be  d207              BCS      |L4.208|
;;;231          return (0);
;;;232        }
;;;233        val |= (parts[0] << 24) | (parts[1] << 16);
0000c0  9800              LDR      r0,[sp,#0]
0000c2  9901              LDR      r1,[sp,#4]
0000c4  0600              LSLS     r0,r0,#24
0000c6  ea404001          ORR      r0,r0,r1,LSL #16
;;;234        break;
0000ca  e00d              B        |L4.232|
;;;235    
;;;236      case 4:             /* a.b.c.d -- 8.8.8.8 bits */
;;;237        if (val > 0xff) {
0000cc  2cff              CMP      r4,#0xff
0000ce  d903              BLS      |L4.216|
                  |L4.208|
;;;238          return (0);
0000d0  2000              MOVS     r0,#0
                  |L4.210|
;;;239        }
;;;240        val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
;;;241        break;
;;;242      default:
;;;243        LWIP_ASSERT("unhandled", 0);
;;;244        break;
;;;245      }
;;;246      if (addr) {
;;;247        ip4_addr_set_u32(addr, htonl(val));
;;;248      }
;;;249      return (1);
;;;250    }
0000d2  b004              ADD      sp,sp,#0x10
0000d4  e8bd81f0          POP      {r4-r8,pc}
                  |L4.216|
0000d8  9800              LDR      r0,[sp,#0]            ;240
0000da  9901              LDR      r1,[sp,#4]            ;240
0000dc  0600              LSLS     r0,r0,#24             ;240
0000de  ea404001          ORR      r0,r0,r1,LSL #16      ;240
0000e2  9902              LDR      r1,[sp,#8]            ;240
0000e4  ea402001          ORR      r0,r0,r1,LSL #8       ;240
                  |L4.232|
0000e8  4304              ORRS     r4,r4,r0              ;233
0000ea  e002              B        |L4.242|
                  |L4.236|
0000ec  a004              ADR      r0,|L4.256|
0000ee  f7fffffe          BL       __2printf
                  |L4.242|
0000f2  b11d              CBZ      r5,|L4.252|
0000f4  4620              MOV      r0,r4                 ;247
0000f6  f7fffffe          BL       lwip_htonl
0000fa  6028              STR      r0,[r5,#0]            ;247
                  |L4.252|
0000fc  2001              MOVS     r0,#1                 ;249
0000fe  e7e8              B        |L4.210|
;;;251    
                          ENDP

                  |L4.256|
000100  756e6861          DCB      "unhandled",0
000104  6e646c65
000108  6400    
00010a  00                DCB      0
00010b  00                DCB      0

                          AREA ||i.ipaddr_ntoa||, CODE, READONLY, ALIGN=2

                  ipaddr_ntoa PROC
;;;260    char *
;;;261    ipaddr_ntoa(const ip_addr_t *addr)
000000  2210              MOVS     r2,#0x10
;;;262    {
;;;263      static char str[16];
;;;264      return ipaddr_ntoa_r(addr, str, 16);
000002  4901              LDR      r1,|L5.8|
000004  f7ffbffe          B.W      ipaddr_ntoa_r
;;;265    }
;;;266    
                          ENDP

                  |L5.8|
                          DCD      ||.bss||

                          AREA ||i.ipaddr_ntoa_r||, CODE, READONLY, ALIGN=1

                  ipaddr_ntoa_r PROC
;;;275     */
;;;276    char *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen)
000000  e92d43fc          PUSH     {r2-r9,lr}
;;;277    {
;;;278      u32_t s_addr;
;;;279      char inv[3];
;;;280      char *rp;
;;;281      u8_t *ap;
;;;282      u8_t rem;
;;;283      u8_t n;
;;;284      u8_t i;
;;;285      int len = 0;
000004  2300              MOVS     r3,#0
;;;286    
;;;287      s_addr = ip4_addr_get_u32(addr);
000006  6800              LDR      r0,[r0,#0]
000008  4689              MOV      r9,r1                 ;277
;;;288    
;;;289      rp = buf;
;;;290      ap = (u8_t *)&s_addr;
00000a  466c              MOV      r4,sp
;;;291      for(n = 0; n < 4; n++) {
00000c  461d              MOV      r5,r3
;;;292        i = 0;
;;;293        do {
;;;294          rem = *ap % (u8_t)10;
00000e  f04f080a          MOV      r8,#0xa
000012  af01              ADD      r7,sp,#4              ;279
000014  9000              STR      r0,[sp,#0]            ;279
                  |L6.22|
000016  2000              MOVS     r0,#0                 ;292
                  |L6.24|
000018  7826              LDRB     r6,[r4,#0]
00001a  fbb6fcf8          UDIV     r12,r6,r8
00001e  fb086c1c          MLS      r12,r8,r12,r6
;;;295          *ap /= (u8_t)10;
000022  fbb6f6f8          UDIV     r6,r6,r8
000026  7026              STRB     r6,[r4,#0]
000028  f10c0c30          ADD      r12,r12,#0x30
;;;296          inv[i++] = '0' + rem;
00002c  f807c000          STRB     r12,[r7,r0]
000030  1c40              ADDS     r0,r0,#1
000032  b2c0              UXTB     r0,r0
;;;297        } while(*ap);
000034  2e00              CMP      r6,#0
000036  d1ef              BNE      |L6.24|
000038  e006              B        |L6.72|
                  |L6.58|
;;;298        while(i--) {
;;;299          if (len++ >= buflen) {
00003a  461e              MOV      r6,r3
00003c  1c5b              ADDS     r3,r3,#1
00003e  4296              CMP      r6,r2
000040  da09              BGE      |L6.86|
;;;300            return NULL;
;;;301          }
;;;302          *rp++ = inv[i];
000042  5c3e              LDRB     r6,[r7,r0]
000044  f8016b01          STRB     r6,[r1],#1
                  |L6.72|
000048  1e40              SUBS     r0,r0,#1              ;298
00004a  b2c0              UXTB     r0,r0                 ;298
00004c  d2f5              BCS      |L6.58|
;;;303        }
;;;304        if (len++ >= buflen) {
00004e  4618              MOV      r0,r3
000050  1c5b              ADDS     r3,r3,#1
000052  4290              CMP      r0,r2
000054  db02              BLT      |L6.92|
                  |L6.86|
;;;305          return NULL;
000056  2000              MOVS     r0,#0
                  |L6.88|
;;;306        }
;;;307        *rp++ = '.';
;;;308        ap++;
;;;309      }
;;;310      *--rp = 0;
;;;311      return buf;
;;;312    }
000058  e8bd83fc          POP      {r2-r9,pc}
                  |L6.92|
00005c  202e              MOVS     r0,#0x2e              ;307
00005e  1c6d              ADDS     r5,r5,#1              ;307
000060  b2ed              UXTB     r5,r5                 ;291
000062  1c64              ADDS     r4,r4,#1              ;291
000064  f8010b01          STRB     r0,[r1],#1            ;307
000068  2d04              CMP      r5,#4                 ;291
00006a  d3d4              BCC      |L6.22|
00006c  2000              MOVS     r0,#0                 ;310
00006e  f8010c01          STRB     r0,[r1,#-1]           ;310
000072  4648              MOV      r0,r9                 ;311
000074  e7f0              B        |L6.88|
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ||str||
                          %        16

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  ip_addr_any
                          DCD      0x00000000

                          AREA ||area_number.11||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.constdata||
                  ip_addr_broadcast
                          DCD      0xffffffff

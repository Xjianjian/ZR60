; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\tcp.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\tcp.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\ZR60_v1.0_freeRTOS -I..\..\Lwip\App -I..\..\Lwip\Bsp -I..\..\Lwip\Bsp\LAN8742A -I..\..\Lwip\lwip-1.4.1 -I..\..\Lwip\lwip-1.4.1\port -I..\..\Lwip\lwip-1.4.1\port\arch -I..\..\Lwip\lwip-1.4.1\port\Standalone -I..\..\Lwip\lwip-1.4.1\src\include -I..\..\Lwip\lwip-1.4.1\src\include\ipv4 -I..\..\Lwip\lwip-1.4.1\src\include\lwip -I..\..\Lwip\lwip-1.4.1\src\include\netif -I..\..\Ecal\BtnFltr -I..\..\Ecal\UartComn -I..\..\Ecal\MemIf -I..\..\APP -I..\..\APP\BlackListMng -I..\..\APP\SeverNewsPush -I..\..\APP\NewsPull -I..\..\Ecal -I..\..\Ecal\JsonIf -I..\..\Ecal\Mcu_Init -I..\..\Service -I..\..\Complex -I..\..\Complex\FATFS -I..\..\FreeRTOS\Source\include -I..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\FreeRTOS -I.\RTE\_ZR60 -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=..\..\output\tcp.crf ..\..\Lwip\lwip-1.4.1\src\core\tcp.c]
                          THUMB

                          AREA ||i.tcp_abandon||, CODE, READONLY, ALIGN=2

                  tcp_abandon PROC
;;;369    void
;;;370    tcp_abandon(struct tcp_pcb *pcb, int reset)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;371    {
000004  4604              MOV      r4,r0
;;;372      u32_t seqno, ackno;
;;;373    #if LWIP_CALLBACK_API  
;;;374      tcp_err_fn errf;
;;;375    #endif /* LWIP_CALLBACK_API */
;;;376      void *errf_arg;
;;;377    
;;;378      /* pcb->state LISTEN not allowed here */
;;;379      LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
000006  7e00              LDRB     r0,[r0,#0x18]
000008  4688              MOV      r8,r1                 ;371
00000a  2801              CMP      r0,#1
00000c  d102              BNE      |L1.20|
00000e  a024              ADR      r0,|L1.160|
000010  f7fffffe          BL       __2printf
                  |L1.20|
;;;380        pcb->state != LISTEN);
;;;381      /* Figure out on which TCP PCB list we are, and remove us. If we
;;;382         are in an active state, call the receive function associated with
;;;383         the PCB with a NULL argument, and send an RST to the remote end. */
;;;384      if (pcb->state == TIME_WAIT) {
000014  7e20              LDRB     r0,[r4,#0x18]
000016  280a              CMP      r0,#0xa
000018  d034              BEQ      |L1.132|
;;;385        tcp_pcb_remove(&tcp_tw_pcbs, pcb);
;;;386        memp_free(MEMP_TCP_PCB, pcb);
;;;387    	TCP_DEBUG_USART_PRINTF_S("TIME_WAIT-> memp_free(MEMP_TCP_PCB, pcb)\n");
;;;388      } else {
;;;389        seqno = pcb->snd_nxt;
;;;390        ackno = pcb->rcv_nxt;
;;;391    #if LWIP_CALLBACK_API
;;;392        errf = pcb->errf;
;;;393    #endif /* LWIP_CALLBACK_API */
;;;394        errf_arg = pcb->callback_arg;
;;;395        TCP_PCB_REMOVE_ACTIVE(pcb);
00001a  4621              MOV      r1,r4
00001c  482d              LDR      r0,|L1.212|
00001e  f8d49050          LDR      r9,[r4,#0x50]
000022  6aa7              LDR      r7,[r4,#0x28]
000024  6926              LDR      r6,[r4,#0x10]
000026  f8d4508c          LDR      r5,[r4,#0x8c]
00002a  f7fffffe          BL       tcp_pcb_remove
00002e  4929              LDR      r1,|L1.212|
000030  2001              MOVS     r0,#1
000032  3918              SUBS     r1,r1,#0x18
000034  7008              STRB     r0,[r1,#0]
;;;396    	TCP_DEBUG_USART_PRINTF_S(" ! TIME_WAIT->TCP_PCB_REMOVE_ACTIVE(pcb)\n");
;;;397        if (pcb->unacked != NULL) {
000036  6f20              LDR      r0,[r4,#0x70]
000038  b108              CBZ      r0,|L1.62|
;;;398          tcp_segs_free(pcb->unacked);
00003a  f7fffffe          BL       tcp_segs_free
                  |L1.62|
;;;399    	  TCP_DEBUG_USART_PRINTF_S("  tcp_segs_free(pcb->unacked)_1;\n");
;;;400        }
;;;401        if (pcb->unsent != NULL) {
00003e  6ee0              LDR      r0,[r4,#0x6c]
000040  b108              CBZ      r0,|L1.70|
;;;402          tcp_segs_free(pcb->unsent);
000042  f7fffffe          BL       tcp_segs_free
                  |L1.70|
;;;403    	   TCP_DEBUG_USART_PRINTF_S("  tcp_segs_free(pcb->unsent);\n");
;;;404        }
;;;405    #if TCP_QUEUE_OOSEQ    
;;;406        if (pcb->ooseq != NULL) {
000046  6f60              LDR      r0,[r4,#0x74]
000048  b108              CBZ      r0,|L1.78|
;;;407          tcp_segs_free(pcb->ooseq);
00004a  f7fffffe          BL       tcp_segs_free
                  |L1.78|
;;;408    	  TCP_DEBUG_USART_PRINTF_S("tcp.c  tcp_segs_free(pcb->unsent)_1;\n");
;;;409        }
;;;410    #endif /* TCP_QUEUE_OOSEQ */
;;;411        if (reset) {
00004e  f1b80f00          CMP      r8,#0
000052  d009              BEQ      |L1.104|
;;;412          LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
;;;413          tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
000054  8ba1              LDRH     r1,[r4,#0x1c]
000056  8b60              LDRH     r0,[r4,#0x1a]
000058  e9cd0100          STRD     r0,r1,[sp,#0]
00005c  1d23              ADDS     r3,r4,#4
00005e  4622              MOV      r2,r4
000060  4639              MOV      r1,r7
000062  4648              MOV      r0,r9
000064  f7fffffe          BL       tcp_rst
                  |L1.104|
;;;414        }
;;;415        memp_free(MEMP_TCP_PCB, pcb);
000068  4621              MOV      r1,r4
00006a  2002              MOVS     r0,#2
00006c  f7fffffe          BL       memp_free
;;;416        TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
000070  2d00              CMP      r5,#0
000072  d012              BEQ      |L1.154|
000074  b002              ADD      sp,sp,#8
000076  4630              MOV      r0,r6
000078  46ac              MOV      r12,r5
00007a  e8bd47f0          POP      {r4-r10,lr}
00007e  f06f0109          MVN      r1,#9
000082  4760              BX       r12
                  |L1.132|
000084  4813              LDR      r0,|L1.212|
000086  4621              MOV      r1,r4                 ;385
000088  1d00              ADDS     r0,r0,#4              ;385
00008a  f7fffffe          BL       tcp_pcb_remove
00008e  4621              MOV      r1,r4                 ;386
000090  e8bd47fc          POP      {r2-r10,lr}           ;386
000094  2002              MOVS     r0,#2                 ;386
000096  f7ffbffe          B.W      memp_free
                  |L1.154|
;;;417    	TCP_DEBUG_USART_PRINTF_S(" ! TIME_WAIT-> memp_free(MEMP_TCP_PCB, pcb)\n");
;;;418      }
;;;419    }
00009a  e8bd87fc          POP      {r2-r10,pc}
;;;420    
                          ENDP

00009e  0000              DCW      0x0000
                  |L1.160|
0000a0  646f6e27          DCB      "don't call tcp_abort/tcp_abandon for listen-pcbs",0
0000a4  74206361
0000a8  6c6c2074
0000ac  63705f61
0000b0  626f7274
0000b4  2f746370
0000b8  5f616261
0000bc  6e646f6e
0000c0  20666f72
0000c4  206c6973
0000c8  74656e2d
0000cc  70636273
0000d0  00      
0000d1  00                DCB      0
0000d2  00                DCB      0
0000d3  00                DCB      0
                  |L1.212|
                          DCD      ||.data||+0x18

                          AREA ||i.tcp_abort||, CODE, READONLY, ALIGN=1

                  tcp_abort PROC
;;;431    void
;;;432    tcp_abort(struct tcp_pcb *pcb)
000000  2101              MOVS     r1,#1
;;;433    {
;;;434      tcp_abandon(pcb, 1);
000002  f7ffbffe          B.W      tcp_abandon
;;;435    }
;;;436    
                          ENDP


                          AREA ||i.tcp_accept||, CODE, READONLY, ALIGN=1

                  tcp_accept PROC
;;;1463   void
;;;1464   tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
000000  6141              STR      r1,[r0,#0x14]
;;;1465   {
;;;1466     /* This function is allowed to be called for both listen pcbs and
;;;1467        connection pcbs. */
;;;1468     pcb->accept = accept;
;;;1469   }
000002  4770              BX       lr
;;;1470   #endif /* LWIP_CALLBACK_API */
                          ENDP


                          AREA ||i.tcp_accept_null||, CODE, READONLY, ALIGN=1

                  tcp_accept_null PROC
;;;515    static err_t
;;;516    tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
000000  f06f0009          MVN      r0,#9
;;;517    {
;;;518      LWIP_UNUSED_ARG(arg);
;;;519      LWIP_UNUSED_ARG(pcb);
;;;520      LWIP_UNUSED_ARG(err);
;;;521    
;;;522      return ERR_ABRT;
;;;523    }
000004  4770              BX       lr
;;;524    #endif /* LWIP_CALLBACK_API */
                          ENDP


                          AREA ||i.tcp_alloc||, CODE, READONLY, ALIGN=2

                  tcp_alloc PROC
;;;1305   struct tcp_pcb *
;;;1306   tcp_alloc(u8_t prio)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1307   {
000004  4604              MOV      r4,r0
;;;1308     struct tcp_pcb *pcb;
;;;1309     u32_t iss;
;;;1310     
;;;1311     pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
000006  2002              MOVS     r0,#2
000008  f7fffffe          BL       memp_malloc
00000c  4d37              LDR      r5,|L5.236|
00000e  0006              MOVS     r6,r0
;;;1312     if (pcb == NULL) {
000010  d136              BNE      |L5.128|
000012  2300              MOVS     r3,#0
000014  461a              MOV      r2,r3
000016  68ee              LDR      r6,[r5,#0xc]
000018  69e8              LDR      r0,[r5,#0x1c]  ; tcp_tw_pcbs
00001a  e006              B        |L5.42|
                  |L5.28|
00001c  6a41              LDR      r1,[r0,#0x24]
00001e  1a71              SUBS     r1,r6,r1
000020  4299              CMP      r1,r3
000022  d301              BCC      |L5.40|
000024  460b              MOV      r3,r1
000026  4602              MOV      r2,r0
                  |L5.40|
000028  68c0              LDR      r0,[r0,#0xc]
                  |L5.42|
00002a  2800              CMP      r0,#0
00002c  d1f6              BNE      |L5.28|
00002e  b112              CBZ      r2,|L5.54|
000030  4610              MOV      r0,r2
000032  f7fffffe          BL       tcp_abort
                  |L5.54|
;;;1313       /* Try killing oldest connection in TIME-WAIT. */
;;;1314       LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
;;;1315       tcp_kill_timewait();
;;;1316       /* Try to allocate a tcp_pcb again. */
;;;1317       pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
000036  2002              MOVS     r0,#2
000038  f7fffffe          BL       memp_malloc
00003c  0006              MOVS     r6,r0
;;;1318       if (pcb == NULL) {
00003e  d11f              BNE      |L5.128|
000040  267f              MOVS     r6,#0x7f
000042  2700              MOVS     r7,#0
000044  463b              MOV      r3,r7
;;;1319         /* Try killing active connections with lower priority than the new one. */
;;;1320         LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
;;;1321         tcp_kill_prio(prio);
000046  f8d5c00c          LDR      r12,[r5,#0xc]
00004a  69a8              LDR      r0,[r5,#0x18]  ; tcp_active_pcbs
00004c  e00d              B        |L5.106|
                  |L5.78|
00004e  7e41              LDRB     r1,[r0,#0x19]
000050  42a1              CMP      r1,r4
000052  d809              BHI      |L5.104|
000054  42b1              CMP      r1,r6
000056  d807              BHI      |L5.104|
000058  6a42              LDR      r2,[r0,#0x24]
00005a  ebac0202          SUB      r2,r12,r2
00005e  42ba              CMP      r2,r7
000060  d302              BCC      |L5.104|
000062  4617              MOV      r7,r2
000064  4603              MOV      r3,r0
000066  460e              MOV      r6,r1
                  |L5.104|
000068  68c0              LDR      r0,[r0,#0xc]
                  |L5.106|
00006a  2800              CMP      r0,#0
00006c  d1ef              BNE      |L5.78|
00006e  b113              CBZ      r3,|L5.118|
000070  4618              MOV      r0,r3
000072  f7fffffe          BL       tcp_abort
                  |L5.118|
;;;1322         /* Try to allocate a tcp_pcb again. */
;;;1323         pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
000076  2002              MOVS     r0,#2
000078  f7fffffe          BL       memp_malloc
00007c  0006              MOVS     r6,r0
;;;1324         if (pcb != NULL) {
00007e  d032              BEQ      |L5.230|
                  |L5.128|
;;;1325           /* adjust err stats: memp_malloc failed twice before */
;;;1326           MEMP_STATS_DEC(err, MEMP_TCP_PCB);
;;;1327         }
;;;1328       }
;;;1329       if (pcb != NULL) {
;;;1330         /* adjust err stats: timewait PCB was freed above */
;;;1331         MEMP_STATS_DEC(err, MEMP_TCP_PCB);
;;;1332       }
;;;1333     }
;;;1334     if (pcb != NULL) {
;;;1335       memset(pcb, 0, sizeof(struct tcp_pcb));
000080  2198              MOVS     r1,#0x98
000082  f7fffffe          BL       __aeabi_memclr4
;;;1336       pcb->prio = prio;
000086  7674              STRB     r4,[r6,#0x19]
;;;1337       pcb->snd_buf = TCP_SND_BUF;
000088  f44f50aa          MOV      r0,#0x1540
00008c  f8a60066          STRH     r0,[r6,#0x66]
;;;1338       pcb->snd_queuelen = 0;
000090  2300              MOVS     r3,#0
000092  f8a63068          STRH     r3,[r6,#0x68]
;;;1339       pcb->rcv_wnd = TCP_WND;
000096  1040              ASRS     r0,r0,#1
000098  85b0              STRH     r0,[r6,#0x2c]
;;;1340       pcb->rcv_ann_wnd = TCP_WND;
00009a  85f0              STRH     r0,[r6,#0x2e]
;;;1341       pcb->tos = 0;
00009c  7273              STRB     r3,[r6,#9]
;;;1342       pcb->ttl = TCP_TTL;
00009e  20ff              MOVS     r0,#0xff
0000a0  72b0              STRB     r0,[r6,#0xa]
;;;1343       /* As initial send MSS, we use TCP_MSS but limit it to 536.
;;;1344          The send MSS is updated when an MSS option is received. */
;;;1345       pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
0000a2  f44f7006          MOV      r0,#0x218
0000a6  86f0              STRH     r0,[r6,#0x36]
;;;1346       pcb->rto = 3000 / TCP_SLOW_INTERVAL;
0000a8  2006              MOVS     r0,#6
0000aa  f8a60044          STRH     r0,[r6,#0x44]
;;;1347       pcb->sa = 0;
0000ae  f8a63040          STRH     r3,[r6,#0x40]
;;;1348       pcb->sv = 3000 / TCP_SLOW_INTERVAL;
0000b2  f8a60042          STRH     r0,[r6,#0x42]
;;;1349       pcb->rtime = -1;
0000b6  1fc0              SUBS     r0,r0,#7
0000b8  86b0              STRH     r0,[r6,#0x34]
;;;1350       pcb->cwnd = 1;
0000ba  2001              MOVS     r0,#1
0000bc  f8a6004c          STRH     r0,[r6,#0x4c]
0000c0  3614              ADDS     r6,r6,#0x14
;;;1351       iss = tcp_next_iss();
0000c2  f7fffffe          BL       tcp_next_iss
;;;1352       pcb->snd_wl2 = iss;
;;;1353       pcb->snd_nxt = iss;
0000c6  6470              STR      r0,[r6,#0x44]
;;;1354       pcb->lastack = iss;
0000c8  63f0              STR      r0,[r6,#0x3c]
;;;1355       pcb->snd_lbb = iss;   
0000ca  6370              STR      r0,[r6,#0x34]
;;;1356       pcb->tmr = tcp_ticks;
0000cc  64b0              STR      r0,[r6,#0x48]
0000ce  68e8              LDR      r0,[r5,#0xc]  ; tcp_ticks
;;;1357       pcb->last_timer = tcp_timer_ctr;
0000d0  6130              STR      r0,[r6,#0x10]
0000d2  78a8              LDRB     r0,[r5,#2]  ; tcp_timer_ctr
0000d4  7370              STRB     r0,[r6,#0xd]
;;;1358   
;;;1359       pcb->polltmr = 0;
0000d6  72f3              STRB     r3,[r6,#0xb]
;;;1360   
;;;1361   #if LWIP_CALLBACK_API
;;;1362       pcb->recv = tcp_recv_null;
0000d8  4805              LDR      r0,|L5.240|
;;;1363   #endif /* LWIP_CALLBACK_API */  
;;;1364       
;;;1365       /* Init KEEPALIVE timer */
;;;1366       pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
0000da  66f0              STR      r0,[r6,#0x6c]
0000dc  4805              LDR      r0,|L5.244|
;;;1367       
;;;1368   #if LWIP_TCP_KEEPALIVE
;;;1369       pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
;;;1370       pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
;;;1371   #endif /* LWIP_TCP_KEEPALIVE */
;;;1372   
;;;1373       pcb->keep_cnt_sent = 0;
0000de  67f0              STR      r0,[r6,#0x7c]
0000e0  f8863082          STRB     r3,[r6,#0x82]
0000e4  3e14              SUBS     r6,r6,#0x14
                  |L5.230|
;;;1374     }
;;;1375     return pcb;
0000e6  4630              MOV      r0,r6
;;;1376   }
0000e8  e8bd81f0          POP      {r4-r8,pc}
;;;1377   
                          ENDP

                  |L5.236|
                          DCD      ||.data||
                  |L5.240|
                          DCD      tcp_recv_null
                  |L5.244|
                          DCD      0x006ddd00

                          AREA ||i.tcp_arg||, CODE, READONLY, ALIGN=1

                  tcp_arg PROC
;;;1403   void
;;;1404   tcp_arg(struct tcp_pcb *pcb, void *arg)
000000  6101              STR      r1,[r0,#0x10]
;;;1405   {
;;;1406     /* This function is allowed to be called for both listen pcbs and
;;;1407        connection pcbs. */
;;;1408     pcb->callback_arg = arg;
;;;1409   }
000002  4770              BX       lr
;;;1410   #if LWIP_CALLBACK_API
                          ENDP


                          AREA ||i.tcp_bind||, CODE, READONLY, ALIGN=2

                  tcp_bind PROC
;;;451    err_t
;;;452    tcp_bind(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;453    {
000004  4605              MOV      r5,r0
;;;454      int i;
;;;455      int max_pcb_list = NUM_TCP_PCB_LISTS;
;;;456      struct tcp_pcb *cpcb;
;;;457    
;;;458      LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
000006  7e00              LDRB     r0,[r0,#0x18]
000008  460c              MOV      r4,r1                 ;453
00000a  2604              MOVS     r6,#4                 ;455
00000c  b130              CBZ      r0,|L7.28|
00000e  a01b              ADR      r0,|L7.124|
000010  f7fffffe          BL       __2printf
000014  f06f0005          MVN      r0,#5
                  |L7.24|
;;;459    
;;;460    #if SO_REUSE
;;;461      /* Unless the REUSEADDR flag is set,
;;;462         we have to check the pcbs in TIME-WAIT state, also.
;;;463         We do not dump TIME_WAIT pcb's; they can still be matched by incoming
;;;464         packets using both local and remote IP addresses and ports to distinguish.
;;;465       */
;;;466      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;467        max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
;;;468      }
;;;469    #endif /* SO_REUSE */
;;;470    
;;;471      if (port == 0) 
;;;472      {
;;;473        port = tcp_new_port();
;;;474        if (port == 0) 
;;;475    	{
;;;476          return ERR_BUF;
;;;477        }
;;;478      }
;;;479    
;;;480      /* Check if the address already is in use (on all lists) */
;;;481      for (i = 0; i < max_pcb_list; i++) {
;;;482        for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
;;;483          if (cpcb->local_port == port) {
;;;484    #if SO_REUSE
;;;485            /* Omit checking for the same port if both pcbs have REUSEADDR set.
;;;486               For SO_REUSEADDR, the duplicate-check for a 5-tuple is done in
;;;487               tcp_connect. */
;;;488            if (!ip_get_option(pcb, SOF_REUSEADDR) ||
;;;489                !ip_get_option(cpcb, SOF_REUSEADDR))
;;;490    #endif /* SO_REUSE */
;;;491            {
;;;492              if (ip_addr_isany(&(cpcb->local_ip)) ||
;;;493                  ip_addr_isany(ipaddr) ||
;;;494                  ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
;;;495                return ERR_USE;
;;;496              }
;;;497            }
;;;498          }
;;;499        }
;;;500      }
;;;501    
;;;502      if (!ip_addr_isany(ipaddr)) {
;;;503        pcb->local_ip = *ipaddr;
;;;504      }
;;;505      pcb->local_port = port;
;;;506      TCP_REG(&tcp_bound_pcbs, pcb);
;;;507      LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
;;;508    
;;;509      return ERR_OK;
;;;510    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L7.28|
00001c  b91a              CBNZ     r2,|L7.38|
00001e  f7fffffe          BL       tcp_new_port
000022  0002              MOVS     r2,r0                 ;473
000024  d006              BEQ      |L7.52|
                  |L7.38|
000026  f8dfc07c          LDR      r12,|L7.164|
00002a  2100              MOVS     r1,#0                 ;481
                  |L7.44|
00002c  f85c0021          LDR      r0,[r12,r1,LSL #2]    ;482
000030  6800              LDR      r0,[r0,#0]            ;482
000032  e011              B        |L7.88|
                  |L7.52|
000034  f06f0001          MVN      r0,#1                 ;476
000038  e7ee              B        |L7.24|
                  |L7.58|
00003a  8b43              LDRH     r3,[r0,#0x1a]         ;483
00003c  4293              CMP      r3,r2                 ;483
00003e  d10a              BNE      |L7.86|
000040  b130              CBZ      r0,|L7.80|
000042  6803              LDR      r3,[r0,#0]            ;492
000044  b123              CBZ      r3,|L7.80|
000046  b11c              CBZ      r4,|L7.80|
000048  6827              LDR      r7,[r4,#0]            ;493
00004a  b10f              CBZ      r7,|L7.80|
00004c  42bb              CMP      r3,r7                 ;494
00004e  d102              BNE      |L7.86|
                  |L7.80|
000050  f06f0007          MVN      r0,#7                 ;495
000054  e7e0              B        |L7.24|
                  |L7.86|
000056  68c0              LDR      r0,[r0,#0xc]          ;482
                  |L7.88|
000058  2800              CMP      r0,#0                 ;482
00005a  d1ee              BNE      |L7.58|
00005c  1c49              ADDS     r1,r1,#1              ;482
00005e  42b1              CMP      r1,r6                 ;481
000060  dbe4              BLT      |L7.44|
000062  b114              CBZ      r4,|L7.106|
000064  6820              LDR      r0,[r4,#0]            ;502
000066  b100              CBZ      r0,|L7.106|
000068  6028              STR      r0,[r5,#0]            ;503
                  |L7.106|
00006a  480f              LDR      r0,|L7.168|
00006c  836a              STRH     r2,[r5,#0x1a]         ;505
00006e  6901              LDR      r1,[r0,#0x10]         ;506  ; tcp_bound_pcbs
000070  60e9              STR      r1,[r5,#0xc]          ;506
000072  6105              STR      r5,[r0,#0x10]         ;506  ; tcp_bound_pcbs
000074  f7fffffe          BL       tcp_timer_needed
000078  2000              MOVS     r0,#0                 ;509
00007a  e7cd              B        |L7.24|
;;;511    #if LWIP_CALLBACK_API
                          ENDP

                  |L7.124|
00007c  7463705f          DCB      "tcp_bind: can only bind in state CLOSED",0
000080  62696e64
000084  3a206361
000088  6e206f6e
00008c  6c792062
000090  696e6420
000094  696e2073
000098  74617465
00009c  20434c4f
0000a0  53454400
                  |L7.164|
                          DCD      ||.constdata||+0x44
                  |L7.168|
                          DCD      ||.data||

                          AREA ||i.tcp_close||, CODE, READONLY, ALIGN=1

                  tcp_close PROC
;;;297    err_t
;;;298    tcp_close(struct tcp_pcb *pcb)
000000  7e01              LDRB     r1,[r0,#0x18]
;;;299    {
;;;300    #if TCP_DEBUG
;;;301      LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
;;;302      tcp_debug_print_state(pcb->state);
;;;303    #endif /* TCP_DEBUG */
;;;304    
;;;305      if (pcb->state != LISTEN) {
000002  2901              CMP      r1,#1
000004  d003              BEQ      |L8.14|
;;;306        /* Set a flag not to receive any more data... */
;;;307        pcb->flags |= TF_RXCLOSED;
000006  7f81              LDRB     r1,[r0,#0x1e]
000008  f0410110          ORR      r1,r1,#0x10
00000c  7781              STRB     r1,[r0,#0x1e]
                  |L8.14|
;;;308      }
;;;309      /* ... and close */
;;;310      return tcp_close_shutdown(pcb, 1);
00000e  2101              MOVS     r1,#1
000010  f7ffbffe          B.W      tcp_close_shutdown
;;;311    }
;;;312    
                          ENDP


                          AREA ||i.tcp_close_shutdown||, CODE, READONLY, ALIGN=2

                  tcp_close_shutdown PROC
;;;171    static err_t
;;;172    tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;173    {
000004  4604              MOV      r4,r0
;;;174      err_t err;
;;;175    
;;;176      if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) 
000006  7e00              LDRB     r0,[r0,#0x18]
;;;177      {
;;;178    		if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
;;;179          /* Not all data received by application, send RST to tell the remote
;;;180             side about this. */
;;;181          LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
;;;182    
;;;183          /* don't call tcp_abort here: we must not deallocate the pcb since
;;;184             that might not be expected when calling tcp_close */
;;;185          tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
;;;186            pcb->local_port, pcb->remote_port);
;;;187    
;;;188          tcp_pcb_purge(pcb);
;;;189          TCP_RMV_ACTIVE(pcb);
000008  4e48              LDR      r6,|L9.300|
00000a  f04f0900          MOV      r9,#0                 ;173
00000e  2701              MOVS     r7,#1
000010  b3b9              CBZ      r1,|L9.130|
000012  2804              CMP      r0,#4                 ;176
000014  d001              BEQ      |L9.26|
000016  2807              CMP      r0,#7                 ;176
000018  d13c              BNE      |L9.148|
                  |L9.26|
00001a  6fa1              LDR      r1,[r4,#0x78]         ;178
00001c  b919              CBNZ     r1,|L9.38|
00001e  8da1              LDRH     r1,[r4,#0x2c]         ;178
000020  f5b16f2a          CMP      r1,#0xaa0             ;178
000024  d036              BEQ      |L9.148|
                  |L9.38|
000026  7fa0              LDRB     r0,[r4,#0x1e]         ;181
000028  06c0              LSLS     r0,r0,#27             ;181
00002a  d402              BMI      |L9.50|
00002c  a040              ADR      r0,|L9.304|
00002e  f7fffffe          BL       __2printf
                  |L9.50|
000032  8ba1              LDRH     r1,[r4,#0x1c]         ;185
000034  8b60              LDRH     r0,[r4,#0x1a]         ;185
000036  e9cd0100          STRD     r0,r1,[sp,#0]         ;185
00003a  1d23              ADDS     r3,r4,#4              ;185
00003c  4622              MOV      r2,r4                 ;185
00003e  6aa1              LDR      r1,[r4,#0x28]         ;185
000040  6d20              LDR      r0,[r4,#0x50]         ;185
000042  f7fffffe          BL       tcp_rst
000046  4620              MOV      r0,r4                 ;188
000048  f7fffffe          BL       tcp_pcb_purge
00004c  69b0              LDR      r0,[r6,#0x18]  ; tcp_active_pcbs
00004e  42a0              CMP      r0,r4
000050  d102              BNE      |L9.88|
000052  68c0              LDR      r0,[r0,#0xc]
000054  61b0              STR      r0,[r6,#0x18]  ; tcp_active_pcbs
000056  e007              B        |L9.104|
                  |L9.88|
000058  6230              STR      r0,[r6,#0x20]  ; tcp_tmp_pcb
00005a  b128              CBZ      r0,|L9.104|
00005c  68c0              LDR      r0,[r0,#0xc]
00005e  42a0              CMP      r0,r4
000060  d1fa              BNE      |L9.88|
000062  6a31              LDR      r1,[r6,#0x20]  ; tcp_tmp_pcb
000064  68e0              LDR      r0,[r4,#0xc]
000066  60c8              STR      r0,[r1,#0xc]
                  |L9.104|
000068  f8c4900c          STR      r9,[r4,#0xc]
00006c  7037              STRB     r7,[r6,#0]
;;;190    	  TCP_DEBUG_USART_PRINTF_S("tcp_close_shutdown -> TCP_RMV_ACTIVE(pcb)\n");
;;;191          if (pcb->state == ESTABLISHED) {
00006e  7e20              LDRB     r0,[r4,#0x18]
000070  2804              CMP      r0,#4
000072  d007              BEQ      |L9.132|
;;;192            /* move to TIME_WAIT since we close actively */
;;;193            pcb->state = TIME_WAIT;
;;;194    		TCP_DEBUG_USART_PRINTF_S("tcp_close_shutdown->pcb->state = TIME_WAIT;\n");
;;;195            TCP_REG(&tcp_tw_pcbs, pcb);
;;;196          } else {
;;;197            /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
;;;198            memp_free(MEMP_TCP_PCB, pcb);
000074  4621              MOV      r1,r4
000076  2002              MOVS     r0,#2
000078  f7fffffe          BL       memp_free
                  |L9.124|
;;;199    		pcb = NULL;//by liujian 20180521
;;;200    		TCP_DEBUG_USART_PRINTF_S("tcp_close_shutdown-> memp_free(MEMP_TCP_PCB, pcb)\n");
;;;201          }
;;;202          return ERR_OK;
00007c  2000              MOVS     r0,#0
                  |L9.126|
;;;203        }
;;;204      }
;;;205    
;;;206      switch (pcb->state) {
;;;207      case CLOSED:
;;;208        /* Closing a pcb in the CLOSED state might seem erroneous,
;;;209         * however, it is in this state once allocated and as yet unused
;;;210         * and the user needs some way to free it should the need arise.
;;;211         * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
;;;212         * or for a pcb that has been used and then entered the CLOSED state 
;;;213         * is erroneous, but this should never happen as the pcb has in those cases
;;;214         * been freed, and so any remaining handles are bogus. */
;;;215        err = ERR_OK;
;;;216        if (pcb->local_port != 0) {
;;;217          TCP_RMV(&tcp_bound_pcbs, pcb);
;;;218    
;;;219        }
;;;220        memp_free(MEMP_TCP_PCB, pcb);
;;;221    	TCP_DEBUG_USART_PRINTF_S("CLOSED -->memp_free(MEMP_TCP_PCB, pcb);\n");
;;;222        pcb = NULL;
;;;223        break;
;;;224      case LISTEN:
;;;225        err = ERR_OK;
;;;226        tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
;;;227        memp_free(MEMP_TCP_PCB_LISTEN, pcb);
;;;228        pcb = NULL;
;;;229    	TCP_DEBUG_USART_PRINTF_S("LISTEN-> memp_free(MEMP_TCP_PCB, pcb)\n");
;;;230        break;
;;;231      case SYN_SENT:
;;;232        err = ERR_OK;
;;;233        TCP_PCB_REMOVE_ACTIVE(pcb);
;;;234    	TCP_DEBUG_USART_PRINTF_S("SYN_SENT->TCP_PCB_REMOVE_ACTIVE(pcb)\n");
;;;235        memp_free(MEMP_TCP_PCB, pcb);
;;;236        pcb = NULL;
;;;237        snmp_inc_tcpattemptfails();
;;;238    	TCP_DEBUG_USART_PRINTF_S("SYN_SENT-> memp_free(MEMP_TCP_PCB, pcb)\n");
;;;239        break;
;;;240      case SYN_RCVD:
;;;241        err = tcp_send_fin(pcb);
;;;242        if (err == ERR_OK) {
;;;243          snmp_inc_tcpattemptfails();
;;;244          pcb->state = FIN_WAIT_1;
;;;245        }
;;;246        break;
;;;247      case ESTABLISHED:
;;;248        err = tcp_send_fin(pcb);
;;;249        if (err == ERR_OK) {
;;;250          snmp_inc_tcpestabresets();
;;;251          pcb->state = FIN_WAIT_1;
;;;252    	  TCP_DEBUG_USART_PRINTF_S("from ESTABLISHED to FIN_WAIT_1\n");
;;;253        }
;;;254        break;
;;;255      case CLOSE_WAIT:
;;;256        err = tcp_send_fin(pcb);
;;;257        if (err == ERR_OK) {
;;;258          snmp_inc_tcpestabresets();
;;;259          pcb->state = LAST_ACK;
;;;260        }
;;;261        break;
;;;262      default:
;;;263        /* Has already been closed, do nothing. */
;;;264        err = ERR_OK;
;;;265        pcb = NULL;
;;;266        break;
;;;267      }
;;;268    
;;;269      if (pcb != NULL && err == ERR_OK) {
;;;270        /* To ensure all data has been sent when tcp_close returns, we have
;;;271           to make sure tcp_output doesn't fail.
;;;272           Since we don't really have to ensure all data has been sent when tcp_close
;;;273           returns (unsent data is sent from tcp timer functions, also), we don't care
;;;274           for the return value of tcp_output for now. */
;;;275        /* @todo: When implementing SO_LINGER, this must be changed somehow:
;;;276           If SOF_LINGER is set, the data should be sent and acked before close returns.
;;;277           This can only be valid for sequential APIs, not for the raw API. */
;;;278        tcp_output(pcb);
;;;279      }
;;;280      return err;
;;;281    }
00007e  e8bd87fc          POP      {r2-r10,pc}
                  |L9.130|
000082  e007              B        |L9.148|
                  |L9.132|
000084  200a              MOVS     r0,#0xa               ;193
000086  7620              STRB     r0,[r4,#0x18]         ;193
000088  69f0              LDR      r0,[r6,#0x1c]         ;195  ; tcp_tw_pcbs
00008a  60e0              STR      r0,[r4,#0xc]          ;195
00008c  61f4              STR      r4,[r6,#0x1c]         ;195  ; tcp_tw_pcbs
00008e  f7fffffe          BL       tcp_timer_needed
000092  e7f3              B        |L9.124|
                  |L9.148|
000094  f04f0805          MOV      r8,#5                 ;244
000098  2808              CMP      r0,#8                 ;206
00009a  d240              BCS      |L9.286|
00009c  e8dff000          TBB      [pc,r0]               ;206
0000a0  041c252d          DCB      0x04,0x1c,0x25,0x2d
0000a4  2d3f3f35          DCB      0x2d,0x3f,0x3f,0x35
0000a8  8b60              LDRH     r0,[r4,#0x1a]         ;216
0000aa  2500              MOVS     r5,#0                 ;215
0000ac  b178              CBZ      r0,|L9.206|
0000ae  6930              LDR      r0,[r6,#0x10]         ;217  ; tcp_bound_pcbs
0000b0  42a0              CMP      r0,r4                 ;217
0000b2  d102              BNE      |L9.186|
0000b4  68c0              LDR      r0,[r0,#0xc]          ;217
0000b6  6130              STR      r0,[r6,#0x10]         ;217  ; tcp_bound_pcbs
0000b8  e007              B        |L9.202|
                  |L9.186|
0000ba  6230              STR      r0,[r6,#0x20]         ;217  ; tcp_tmp_pcb
0000bc  b128              CBZ      r0,|L9.202|
0000be  68c0              LDR      r0,[r0,#0xc]          ;217
0000c0  42a0              CMP      r0,r4                 ;217
0000c2  d1fa              BNE      |L9.186|
0000c4  6a31              LDR      r1,[r6,#0x20]         ;217  ; tcp_tmp_pcb
0000c6  68e0              LDR      r0,[r4,#0xc]          ;217
0000c8  60c8              STR      r0,[r1,#0xc]          ;217
                  |L9.202|
0000ca  f8c4900c          STR      r9,[r4,#0xc]          ;217
                  |L9.206|
0000ce  4621              MOV      r1,r4                 ;220
0000d0  2002              MOVS     r0,#2                 ;220
                  |L9.210|
0000d2  f7fffffe          BL       memp_free
0000d6  e027              B        |L9.296|
0000d8  4814              LDR      r0,|L9.300|
0000da  2500              MOVS     r5,#0                 ;225
0000dc  4621              MOV      r1,r4                 ;226
0000de  3014              ADDS     r0,r0,#0x14           ;226
0000e0  f7fffffe          BL       tcp_pcb_remove
0000e4  4621              MOV      r1,r4                 ;227
0000e6  2003              MOVS     r0,#3                 ;227
0000e8  e7f3              B        |L9.210|
0000ea  4810              LDR      r0,|L9.300|
0000ec  2500              MOVS     r5,#0                 ;232
0000ee  4621              MOV      r1,r4                 ;233
0000f0  3018              ADDS     r0,r0,#0x18           ;233
0000f2  f7fffffe          BL       tcp_pcb_remove
0000f6  7037              STRB     r7,[r6,#0]            ;233
0000f8  e7e9              B        |L9.206|
0000fa  4620              MOV      r0,r4                 ;248
0000fc  f7fffffe          BL       tcp_send_fin
000100  0005              MOVS     r5,r0                 ;248
000102  d109              BNE      |L9.280|
000104  f8848018          STRB     r8,[r4,#0x18]         ;251
000108  e006              B        |L9.280|
00010a  4620              MOV      r0,r4                 ;256
00010c  f7fffffe          BL       tcp_send_fin
000110  0005              MOVS     r5,r0                 ;256
000112  d101              BNE      |L9.280|
000114  2009              MOVS     r0,#9                 ;259
000116  7620              STRB     r0,[r4,#0x18]         ;259
                  |L9.280|
000118  b134              CBZ      r4,|L9.296|
00011a  b115              CBZ      r5,|L9.290|
00011c  e004              B        |L9.296|
                  |L9.286|
00011e  2500              MOVS     r5,#0                 ;264
000120  e002              B        |L9.296|
                  |L9.290|
000122  4620              MOV      r0,r4                 ;278
000124  f7fffffe          BL       tcp_output
                  |L9.296|
000128  4628              MOV      r0,r5                 ;280
00012a  e7a8              B        |L9.126|
;;;282    
                          ENDP

                  |L9.300|
                          DCD      ||.data||
                  |L9.304|
000130  7063622d          DCB      "pcb->flags & TF_RXCLOSED",0
000134  3e666c61
000138  67732026
00013c  2054465f
000140  5258434c
000144  4f534544
000148  00      
000149  00                DCB      0
00014a  00                DCB      0
00014b  00                DCB      0

                          AREA ||i.tcp_connect||, CODE, READONLY, ALIGN=2

                  tcp_connect PROC
;;;706    err_t
;;;707    tcp_connect(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;708          tcp_connected_fn connected)
;;;709    {
000004  4604              MOV      r4,r0
;;;710      err_t ret;
;;;711      u32_t iss;
;;;712      u16_t old_local_port;
;;;713    
;;;714      LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
000006  7e00              LDRB     r0,[r0,#0x18]
000008  4698              MOV      r8,r3                 ;709
00000a  460e              MOV      r6,r1                 ;709
00000c  b130              CBZ      r0,|L10.28|
00000e  a03b              ADR      r0,|L10.252|
000010  f7fffffe          BL       __2printf
000014  f06f0008          MVN      r0,#8
                  |L10.24|
;;;715    
;;;716      LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
;;;717      if (ipaddr != NULL) {
;;;718        pcb->remote_ip = *ipaddr;
;;;719      } else {
;;;720        return ERR_VAL;
;;;721      }
;;;722      pcb->remote_port = port;
;;;723    
;;;724      /* check if we have a route to the remote host */
;;;725      if (ip_addr_isany(&(pcb->local_ip))) {
;;;726        /* no local IP address set, yet. */
;;;727        struct netif *netif = ip_route(&(pcb->remote_ip));
;;;728        if (netif == NULL) {
;;;729          /* Don't even try to send a SYN packet if we have no route
;;;730             since that will fail. */
;;;731          return ERR_RTE;
;;;732        }
;;;733        /* Use the netif's IP address as local address. */
;;;734        ip_addr_copy(pcb->local_ip, netif->ip_addr);
;;;735      }
;;;736    
;;;737      old_local_port = pcb->local_port;
;;;738      if (pcb->local_port == 0) {
;;;739        pcb->local_port = tcp_new_port();
;;;740        if (pcb->local_port == 0) {
;;;741          return ERR_BUF;
;;;742        }
;;;743      }
;;;744    #if SO_REUSE
;;;745      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;746        /* Since SOF_REUSEADDR allows reusing a local address, we have to make sure
;;;747           now that the 5-tuple is unique. */
;;;748        struct tcp_pcb *cpcb;
;;;749        int i;
;;;750        /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
;;;751        for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
;;;752          for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
;;;753            if ((cpcb->local_port == pcb->local_port) &&
;;;754                (cpcb->remote_port == port) &&
;;;755                ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
;;;756                ip_addr_cmp(&cpcb->remote_ip, ipaddr)) {
;;;757              /* linux returns EISCONN here, but ERR_USE should be OK for us */
;;;758              return ERR_USE;
;;;759            }
;;;760          }
;;;761        }
;;;762      }
;;;763    #endif /* SO_REUSE */
;;;764      iss = tcp_next_iss();
;;;765      pcb->rcv_nxt = 0;
;;;766      pcb->snd_nxt = iss;
;;;767      pcb->lastack = iss - 1;
;;;768      pcb->snd_lbb = iss - 1;
;;;769      pcb->rcv_wnd = TCP_WND;
;;;770      pcb->rcv_ann_wnd = TCP_WND;
;;;771      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
;;;772      pcb->snd_wnd = TCP_WND;
;;;773      /* As initial send MSS, we use TCP_MSS but limit it to 536.
;;;774         The send MSS is updated when an MSS option is received. */
;;;775      pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
;;;776    #if TCP_CALCULATE_EFF_SEND_MSS
;;;777      pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
;;;778    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;779      pcb->cwnd = 1;
;;;780      pcb->ssthresh = pcb->mss * 10;
;;;781    #if LWIP_CALLBACK_API
;;;782      pcb->connected = connected;
;;;783    #else /* LWIP_CALLBACK_API */  
;;;784      LWIP_UNUSED_ARG(connected);
;;;785    #endif /* LWIP_CALLBACK_API */
;;;786    
;;;787      /* Send a SYN together with the MSS option. */
;;;788      ret = tcp_enqueue_flags(pcb, TCP_SYN);
;;;789      if (ret == ERR_OK) {
;;;790        /* SYN segment was enqueued, changed the pcbs state now */
;;;791        pcb->state = SYN_SENT;
;;;792    
;;;793        if (old_local_port != 0) {
;;;794          TCP_RMV(&tcp_bound_pcbs, pcb);
;;;795        }
;;;796        TCP_REG_ACTIVE(pcb);
;;;797        snmp_inc_tcpactiveopens();
;;;798    
;;;799        tcp_output(pcb);
;;;800      }
;;;801      return ret;
;;;802    }
000018  e8bd87f0          POP      {r4-r10,pc}
                  |L10.28|
00001c  b136              CBZ      r6,|L10.44|
00001e  6830              LDR      r0,[r6,#0]            ;718
000020  6060              STR      r0,[r4,#4]            ;722
000022  83a2              STRH     r2,[r4,#0x1c]         ;722
000024  b12c              CBZ      r4,|L10.50|
000026  6820              LDR      r0,[r4,#0]            ;725
000028  b118              CBZ      r0,|L10.50|
00002a  e008              B        |L10.62|
                  |L10.44|
00002c  f06f0005          MVN      r0,#5                 ;720
000030  e7f2              B        |L10.24|
                  |L10.50|
000032  1d20              ADDS     r0,r4,#4              ;727
000034  f7fffffe          BL       ip_route
000038  b120              CBZ      r0,|L10.68|
00003a  6840              LDR      r0,[r0,#4]            ;734
00003c  6020              STR      r0,[r4,#0]            ;734
                  |L10.62|
00003e  8b65              LDRH     r5,[r4,#0x1a]         ;737
000040  b11d              CBZ      r5,|L10.74|
000042  e006              B        |L10.82|
                  |L10.68|
000044  f06f0003          MVN      r0,#3                 ;731
000048  e7e6              B        |L10.24|
                  |L10.74|
00004a  f7fffffe          BL       tcp_new_port
00004e  8360              STRH     r0,[r4,#0x1a]         ;739
000050  b350              CBZ      r0,|L10.168|
                  |L10.82|
000052  f7fffffe          BL       tcp_next_iss
000056  f04f0900          MOV      r9,#0                 ;765
00005a  f8449f28          STR      r9,[r4,#0x28]!        ;765
00005e  4631              MOV      r1,r6                 ;777
000060  62a0              STR      r0,[r4,#0x28]         ;766
000062  1e40              SUBS     r0,r0,#1              ;766
000064  6220              STR      r0,[r4,#0x20]         ;768
000066  6360              STR      r0,[r4,#0x34]         ;769
000068  f44f602a          MOV      r0,#0xaa0             ;769
00006c  80a0              STRH     r0,[r4,#4]            ;769
00006e  80e0              STRH     r0,[r4,#6]            ;770
000070  f8c49008          STR      r9,[r4,#8]            ;772
000074  8720              STRH     r0,[r4,#0x38]         ;772
000076  f44f7006          MOV      r0,#0x218             ;775
00007a  81e0              STRH     r0,[r4,#0xe]          ;775
00007c  f7fffffe          BL       tcp_eff_send_mss
000080  81e0              STRH     r0,[r4,#0xe]          ;777
000082  eb000080          ADD      r0,r0,r0,LSL #2       ;780
000086  f64f71ff          MOV      r1,#0xffff            ;780
00008a  2701              MOVS     r7,#1                 ;779
00008c  ea010040          AND      r0,r1,r0,LSL #1       ;780
000090  84a7              STRH     r7,[r4,#0x24]         ;779
000092  84e0              STRH     r0,[r4,#0x26]         ;780
000094  f8c4805c          STR      r8,[r4,#0x5c]         ;788
000098  3c28              SUBS     r4,r4,#0x28           ;788
00009a  2102              MOVS     r1,#2                 ;788
00009c  4620              MOV      r0,r4                 ;788
00009e  f7fffffe          BL       tcp_enqueue_flags
0000a2  0006              MOVS     r6,r0                 ;788
0000a4  d003              BEQ      |L10.174|
0000a6  e027              B        |L10.248|
                  |L10.168|
0000a8  f06f0001          MVN      r0,#1                 ;741
0000ac  e7b4              B        |L10.24|
                  |L10.174|
0000ae  2002              MOVS     r0,#2                 ;791
0000b0  f8df8078          LDR      r8,|L10.300|
0000b4  7620              STRB     r0,[r4,#0x18]         ;791
0000b6  b19d              CBZ      r5,|L10.224|
0000b8  f8d80010          LDR      r0,[r8,#0x10]         ;794  ; tcp_bound_pcbs
0000bc  42a0              CMP      r0,r4                 ;794
0000be  d103              BNE      |L10.200|
0000c0  68c0              LDR      r0,[r0,#0xc]          ;794
0000c2  f8c80010          STR      r0,[r8,#0x10]         ;794  ; tcp_bound_pcbs
0000c6  e009              B        |L10.220|
                  |L10.200|
0000c8  f8c80020          STR      r0,[r8,#0x20]         ;794  ; tcp_tmp_pcb
0000cc  b130              CBZ      r0,|L10.220|
0000ce  68c0              LDR      r0,[r0,#0xc]          ;794
0000d0  42a0              CMP      r0,r4                 ;794
0000d2  d1f9              BNE      |L10.200|
0000d4  f8d81020          LDR      r1,[r8,#0x20]         ;794  ; tcp_tmp_pcb
0000d8  68e0              LDR      r0,[r4,#0xc]          ;794
0000da  60c8              STR      r0,[r1,#0xc]          ;794
                  |L10.220|
0000dc  f8c4900c          STR      r9,[r4,#0xc]          ;794
                  |L10.224|
0000e0  f8d80018          LDR      r0,[r8,#0x18]         ;796  ; tcp_active_pcbs
0000e4  60e0              STR      r0,[r4,#0xc]          ;796
0000e6  f8c84018          STR      r4,[r8,#0x18]         ;796  ; tcp_active_pcbs
0000ea  f7fffffe          BL       tcp_timer_needed
0000ee  f8887000          STRB     r7,[r8,#0]            ;796
0000f2  4620              MOV      r0,r4                 ;799
0000f4  f7fffffe          BL       tcp_output
                  |L10.248|
0000f8  4630              MOV      r0,r6                 ;801
0000fa  e78d              B        |L10.24|
;;;803    
                          ENDP

                  |L10.252|
0000fc  7463705f          DCB      "tcp_connect: can only connect from state CLOSED",0
000100  636f6e6e
000104  6563743a
000108  2063616e
00010c  206f6e6c
000110  7920636f
000114  6e6e6563
000118  74206672
00011c  6f6d2073
000120  74617465
000124  20434c4f
000128  53454400
                  |L10.300|
                          DCD      ||.data||

                          AREA ||i.tcp_debug_state_str||, CODE, READONLY, ALIGN=2

                  tcp_debug_state_str PROC
;;;1635   const char*
;;;1636   tcp_debug_state_str(enum tcp_state s)
000000  4901              LDR      r1,|L11.8|
;;;1637   {
;;;1638     return tcp_state_str[s];
000002  f8510020          LDR      r0,[r1,r0,LSL #2]
;;;1639   }
000006  4770              BX       lr
;;;1640   
                          ENDP

                  |L11.8|
                          DCD      ||.constdata||+0x8

                          AREA ||i.tcp_eff_send_mss||, CODE, READONLY, ALIGN=1

                  tcp_eff_send_mss PROC
;;;1616   u16_t
;;;1617   tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
000000  b510              PUSH     {r4,lr}
;;;1618   {
000002  4604              MOV      r4,r0
;;;1619     u16_t mss_s;
;;;1620     struct netif *outif;
;;;1621   
;;;1622     outif = ip_route(addr);
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       ip_route
;;;1623     if ((outif != NULL) && (outif->mtu != 0)) {
00000a  b138              CBZ      r0,|L12.28|
00000c  8d00              LDRH     r0,[r0,#0x28]
00000e  b128              CBZ      r0,|L12.28|
000010  3828              SUBS     r0,r0,#0x28
;;;1624       mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
000012  b280              UXTH     r0,r0
;;;1625       /* RFC 1122, chap 4.2.2.6:
;;;1626        * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
;;;1627        * We correct for TCP options in tcp_write(), and don't support IP options.
;;;1628        */
;;;1629       sendmss = LWIP_MIN(sendmss, mss_s);
000014  4284              CMP      r4,r0
000016  d200              BCS      |L12.26|
000018  4620              MOV      r0,r4
                  |L12.26|
00001a  4604              MOV      r4,r0
                  |L12.28|
;;;1630     }
;;;1631     return sendmss;
00001c  4620              MOV      r0,r4
;;;1632   }
00001e  bd10              POP      {r4,pc}
;;;1633   #endif /* TCP_CALCULATE_EFF_SEND_MSS */
                          ENDP


                          AREA ||i.tcp_err||, CODE, READONLY, ALIGN=2

                  tcp_err PROC
;;;1448   void
;;;1449   tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
000000  b570              PUSH     {r4-r6,lr}
;;;1450   {
000002  4604              MOV      r4,r0
;;;1451     LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
000004  7e00              LDRB     r0,[r0,#0x18]
000006  460d              MOV      r5,r1                 ;1450
000008  2801              CMP      r0,#1
00000a  d102              BNE      |L13.18|
00000c  a002              ADR      r0,|L13.24|
00000e  f7fffffe          BL       __2printf
                  |L13.18|
;;;1452     pcb->errf = err;
000012  f8c4508c          STR      r5,[r4,#0x8c]
;;;1453   }
000016  bd70              POP      {r4-r6,pc}
;;;1454   
                          ENDP

                  |L13.24|
000018  696e7661          DCB      "invalid socket state for err callback",0
00001c  6c696420
000020  736f636b
000024  65742073
000028  74617465
00002c  20666f72
000030  20657272
000034  2063616c
000038  6c626163
00003c  6b00    
00003e  00                DCB      0
00003f  00                DCB      0

                          AREA ||i.tcp_fasttmr||, CODE, READONLY, ALIGN=2

                  tcp_fasttmr PROC
;;;1072   void
;;;1073   tcp_fasttmr(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1074   {
;;;1075     struct tcp_pcb *pcb;
;;;1076   
;;;1077     ++tcp_timer_ctr;
000004  4e14              LDR      r6,|L14.88|
000006  78b0              LDRB     r0,[r6,#2]  ; tcp_timer_ctr
000008  1c40              ADDS     r0,r0,#1
00000a  70b0              STRB     r0,[r6,#2]
                  |L14.12|
;;;1078   
;;;1079   tcp_fasttmr_start:
;;;1080     pcb = tcp_active_pcbs;
00000c  2700              MOVS     r7,#0
;;;1081   
;;;1082     while(pcb != NULL) {
00000e  69b4              LDR      r4,[r6,#0x18]  ; tcp_active_pcbs
000010  e01e              B        |L14.80|
                  |L14.18|
;;;1083       if (pcb->last_timer != tcp_timer_ctr) {
000012  f8941021          LDRB     r1,[r4,#0x21]
000016  78b0              LDRB     r0,[r6,#2]  ; tcp_timer_ctr
000018  4281              CMP      r1,r0
00001a  d019              BEQ      |L14.80|
;;;1084         struct tcp_pcb *next;
;;;1085         pcb->last_timer = tcp_timer_ctr;
00001c  f8840021          STRB     r0,[r4,#0x21]
;;;1086         /* send delayed ACKs */
;;;1087         if (pcb->flags & TF_ACK_DELAY) {
000020  7fa0              LDRB     r0,[r4,#0x1e]
000022  07c1              LSLS     r1,r0,#31
000024  d009              BEQ      |L14.58|
;;;1088           LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
;;;1089           tcp_ack_now(pcb);
000026  f0400002          ORR      r0,r0,#2
00002a  77a0              STRB     r0,[r4,#0x1e]
;;;1090           tcp_output(pcb);
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       tcp_output
;;;1091           pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
000032  7fa0              LDRB     r0,[r4,#0x1e]
000034  f0200003          BIC      r0,r0,#3
000038  77a0              STRB     r0,[r4,#0x1e]
                  |L14.58|
;;;1092         }
;;;1093   
;;;1094         next = pcb->next;
;;;1095   
;;;1096         /* If there is data which was previously "refused" by upper layer */
;;;1097         if (pcb->refused_data != NULL) {
00003a  68e5              LDR      r5,[r4,#0xc]
00003c  6fa0              LDR      r0,[r4,#0x78]
00003e  b130              CBZ      r0,|L14.78|
;;;1098           tcp_active_pcbs_changed = 0;
000040  7037              STRB     r7,[r6,#0]
;;;1099           tcp_process_refused_data(pcb);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       tcp_process_refused_data
;;;1100           if (tcp_active_pcbs_changed) {
000048  7830              LDRB     r0,[r6,#0]  ; tcp_active_pcbs_changed
00004a  2800              CMP      r0,#0
00004c  d1de              BNE      |L14.12|
                  |L14.78|
;;;1101             /* application callback has changed the pcb list: restart the loop */
;;;1102             goto tcp_fasttmr_start;
;;;1103           }
;;;1104         }
;;;1105         pcb = next;
00004e  462c              MOV      r4,r5
                  |L14.80|
000050  2c00              CMP      r4,#0                 ;1082
000052  d1de              BNE      |L14.18|
;;;1106       }
;;;1107     }
;;;1108   }
000054  e8bd81f0          POP      {r4-r8,pc}
;;;1109   
                          ENDP

                  |L14.88|
                          DCD      ||.data||

                          AREA ||i.tcp_init||, CODE, READONLY, ALIGN=1

                  tcp_init PROC
;;;129    void
;;;130    tcp_init(void)
000000  4770              BX       lr
;;;131    {
;;;132    #if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
;;;133      tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
;;;134    #endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
;;;135    }
;;;136    
                          ENDP


                          AREA ||i.tcp_listen_with_backlog||, CODE, READONLY, ALIGN=2

                  tcp_listen_with_backlog PROC
;;;540    struct tcp_pcb *
;;;541    tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
000000  b570              PUSH     {r4-r6,lr}
;;;542    {
000002  4604              MOV      r4,r0
;;;543      struct tcp_pcb_listen *lpcb;
;;;544    
;;;545      LWIP_UNUSED_ARG(backlog);
;;;546      LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
000004  7e00              LDRB     r0,[r0,#0x18]
000006  b120              CBZ      r0,|L16.18|
000008  a01e              ADR      r0,|L16.132|
00000a  f7fffffe          BL       __2printf
00000e  2000              MOVS     r0,#0
                  |L16.16|
;;;547    
;;;548      /* already listening? */
;;;549      if (pcb->state == LISTEN) {
;;;550        return pcb;
;;;551      }
;;;552    #if SO_REUSE
;;;553      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;554        /* Since SOF_REUSEADDR allows reusing a local address before the pcb's usage
;;;555           is declared (listen-/connection-pcb), we have to make sure now that
;;;556           this port is only used once for every local IP. */
;;;557        for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
;;;558          if (lpcb->local_port == pcb->local_port) {
;;;559            if (ip_addr_cmp(&lpcb->local_ip, &pcb->local_ip)) {
;;;560              /* this address/port is already used */
;;;561              return NULL;
;;;562            }
;;;563          }
;;;564        }
;;;565      }
;;;566    #endif /* SO_REUSE */
;;;567      lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
;;;568      if (lpcb == NULL) {
;;;569        return NULL;
;;;570      }
;;;571      lpcb->callback_arg = pcb->callback_arg;
;;;572      lpcb->local_port = pcb->local_port;
;;;573      lpcb->state = LISTEN;
;;;574      lpcb->prio = pcb->prio;
;;;575      lpcb->so_options = pcb->so_options;
;;;576      ip_set_option(lpcb, SOF_ACCEPTCONN);
;;;577      lpcb->ttl = pcb->ttl;
;;;578      lpcb->tos = pcb->tos;
;;;579      ip_addr_copy(lpcb->local_ip, pcb->local_ip);
;;;580      if (pcb->local_port != 0) {
;;;581        TCP_RMV(&tcp_bound_pcbs, pcb);
;;;582      }
;;;583      memp_free(MEMP_TCP_PCB, pcb);
;;;584      TCP_DEBUG_USART_PRINTF_S("tcp_listen_with_backlog -> memp_free(MEMP_TCP_PCB, pcb)\n");
;;;585    #if LWIP_CALLBACK_API
;;;586      lpcb->accept = tcp_accept_null;
;;;587    #endif /* LWIP_CALLBACK_API */
;;;588    #if TCP_LISTEN_BACKLOG
;;;589      lpcb->accepts_pending = 0;
;;;590      lpcb->backlog = (backlog ? backlog : 1);
;;;591    #endif /* TCP_LISTEN_BACKLOG */
;;;592      TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
;;;593      return (struct tcp_pcb *)lpcb;
;;;594    }
000010  bd70              POP      {r4-r6,pc}
                  |L16.18|
000012  2003              MOVS     r0,#3                 ;567
000014  f7fffffe          BL       memp_malloc
000018  1e05              SUBS     r5,r0,#0              ;567
00001a  d0f9              BEQ      |L16.16|
00001c  6920              LDR      r0,[r4,#0x10]         ;571
00001e  6128              STR      r0,[r5,#0x10]         ;572
000020  8b60              LDRH     r0,[r4,#0x1a]         ;572
000022  8368              STRH     r0,[r5,#0x1a]         ;572
000024  2001              MOVS     r0,#1                 ;573
000026  7628              STRB     r0,[r5,#0x18]         ;573
000028  7e60              LDRB     r0,[r4,#0x19]         ;574
00002a  7668              STRB     r0,[r5,#0x19]         ;574
00002c  7a20              LDRB     r0,[r4,#8]            ;575
00002e  f0400002          ORR      r0,r0,#2              ;576
000032  7228              STRB     r0,[r5,#8]            ;576
000034  7aa0              LDRB     r0,[r4,#0xa]          ;577
000036  72a8              STRB     r0,[r5,#0xa]          ;577
000038  7a60              LDRB     r0,[r4,#9]            ;578
00003a  7268              STRB     r0,[r5,#9]            ;578
00003c  6820              LDR      r0,[r4,#0]            ;579
00003e  6028              STR      r0,[r5,#0]            ;580
000040  8b60              LDRH     r0,[r4,#0x1a]         ;580
000042  b180              CBZ      r0,|L16.102|
000044  4918              LDR      r1,|L16.168|
000046  6908              LDR      r0,[r1,#0x10]         ;581  ; tcp_bound_pcbs
000048  42a0              CMP      r0,r4                 ;581
00004a  d102              BNE      |L16.82|
00004c  68c0              LDR      r0,[r0,#0xc]          ;581
00004e  6108              STR      r0,[r1,#0x10]         ;581  ; tcp_bound_pcbs
000050  e007              B        |L16.98|
                  |L16.82|
000052  6208              STR      r0,[r1,#0x20]         ;581  ; tcp_tmp_pcb
000054  b128              CBZ      r0,|L16.98|
000056  68c0              LDR      r0,[r0,#0xc]          ;581
000058  42a0              CMP      r0,r4                 ;581
00005a  d1fa              BNE      |L16.82|
00005c  6a09              LDR      r1,[r1,#0x20]         ;581  ; tcp_tmp_pcb
00005e  68e0              LDR      r0,[r4,#0xc]          ;581
000060  60c8              STR      r0,[r1,#0xc]          ;581
                  |L16.98|
000062  2000              MOVS     r0,#0                 ;581
000064  60e0              STR      r0,[r4,#0xc]          ;581
                  |L16.102|
000066  4621              MOV      r1,r4                 ;583
000068  2002              MOVS     r0,#2                 ;583
00006a  f7fffffe          BL       memp_free
00006e  480f              LDR      r0,|L16.172|
000070  6168              STR      r0,[r5,#0x14]         ;592
000072  480d              LDR      r0,|L16.168|
000074  3014              ADDS     r0,r0,#0x14           ;592
000076  6801              LDR      r1,[r0,#0]            ;592  ; tcp_listen_pcbs
000078  60e9              STR      r1,[r5,#0xc]          ;592
00007a  6005              STR      r5,[r0,#0]            ;592  ; tcp_listen_pcbs
00007c  f7fffffe          BL       tcp_timer_needed
000080  4628              MOV      r0,r5                 ;593
000082  bd70              POP      {r4-r6,pc}
;;;595    
                          ENDP

                  |L16.132|
000084  7463705f          DCB      "tcp_listen: pcb already connected",0
000088  6c697374
00008c  656e3a20
000090  70636220
000094  616c7265
000098  61647920
00009c  636f6e6e
0000a0  65637465
0000a4  6400    
0000a6  00                DCB      0
0000a7  00                DCB      0
                  |L16.168|
                          DCD      ||.data||
                  |L16.172|
                          DCD      tcp_accept_null

                          AREA ||i.tcp_new||, CODE, READONLY, ALIGN=1

                  tcp_new PROC
;;;1390   struct tcp_pcb *
;;;1391   tcp_new(void)
000000  2040              MOVS     r0,#0x40
;;;1392   {
;;;1393     return tcp_alloc(TCP_PRIO_NORMAL);
000002  f7ffbffe          B.W      tcp_alloc
;;;1394   }
;;;1395   
                          ENDP


                          AREA ||i.tcp_new_port||, CODE, READONLY, ALIGN=2

                  tcp_new_port PROC
;;;669    static u16_t
;;;670    tcp_new_port(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;671    {
;;;672      u8_t i;
;;;673      u16_t n = 0;
;;;674      struct tcp_pcb *pcb;
;;;675      
;;;676    again:
;;;677      if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
;;;678        tcp_port = TCP_LOCAL_PORT_RANGE_START;
;;;679      }
;;;680      /* Check all PCB lists. */
;;;681      for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
;;;682        for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
000002  4d14              LDR      r5,|L18.84|
000004  4e14              LDR      r6,|L18.88|
000006  2400              MOVS     r4,#0                 ;673
000008  f64f77ff          MOV      r7,#0xffff            ;677
00000c  f44f4c40          MOV      r12,#0xc000           ;678
;;;683          if (pcb->local_port == tcp_port) {
;;;684            if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
000010  f44f4e80          MOV      lr,#0x4000
                  |L18.20|
000014  88b0              LDRH     r0,[r6,#4]            ;677  ; tcp_port
000016  1c41              ADDS     r1,r0,#1              ;677
000018  80b1              STRH     r1,[r6,#4]            ;677
00001a  42b8              CMP      r0,r7                 ;677
00001c  d101              BNE      |L18.34|
00001e  f8a6c004          STRH     r12,[r6,#4]           ;678
                  |L18.34|
000022  88b2              LDRH     r2,[r6,#4]            ;677
000024  2100              MOVS     r1,#0                 ;681
                  |L18.38|
000026  f8550021          LDR      r0,[r5,r1,LSL #2]     ;682
00002a  6800              LDR      r0,[r0,#0]            ;682
00002c  e009              B        |L18.66|
                  |L18.46|
00002e  8b43              LDRH     r3,[r0,#0x1a]         ;683
000030  4293              CMP      r3,r2                 ;683
000032  d105              BNE      |L18.64|
000034  1c64              ADDS     r4,r4,#1              ;683
000036  b2a4              UXTH     r4,r4
000038  4574              CMP      r4,lr
00003a  d3eb              BCC      |L18.20|
;;;685              return 0;
00003c  2000              MOVS     r0,#0
;;;686            }
;;;687            goto again;
;;;688          }
;;;689        }
;;;690      }
;;;691      return tcp_port;
;;;692    }
00003e  bdf0              POP      {r4-r7,pc}
                  |L18.64|
000040  68c0              LDR      r0,[r0,#0xc]          ;682
                  |L18.66|
000042  2800              CMP      r0,#0                 ;682
000044  d1f3              BNE      |L18.46|
000046  1c49              ADDS     r1,r1,#1              ;682
000048  b2c9              UXTB     r1,r1                 ;681
00004a  2904              CMP      r1,#4                 ;681
00004c  d3eb              BCC      |L18.38|
00004e  b290              UXTH     r0,r2                 ;691
000050  bdf0              POP      {r4-r7,pc}
;;;693    
                          ENDP

000052  0000              DCW      0x0000
                  |L18.84|
                          DCD      ||.constdata||+0x44
                  |L18.88|
                          DCD      ||.data||

                          AREA ||i.tcp_next_iss||, CODE, READONLY, ALIGN=2

                  tcp_next_iss PROC
;;;1601   u32_t
;;;1602   tcp_next_iss(void)
000000  4902              LDR      r1,|L19.12|
;;;1603   {
;;;1604     static u32_t iss = 6510;
;;;1605     
;;;1606     iss += tcp_ticks;       /* XXX */
000002  e9d10202          LDRD     r0,r2,[r1,#8]
000006  4410              ADD      r0,r0,r2
000008  6088              STR      r0,[r1,#8]  ; iss
;;;1607     return iss;
;;;1608   }
00000a  4770              BX       lr
;;;1609   
                          ENDP

                  |L19.12|
                          DCD      ||.data||

                          AREA ||i.tcp_pcb_purge||, CODE, READONLY, ALIGN=1

                  tcp_pcb_purge PROC
;;;1497   void
;;;1498   tcp_pcb_purge(struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;1499   {
000002  4604              MOV      r4,r0
;;;1500     if (pcb->state != CLOSED &&
000004  7e00              LDRB     r0,[r0,#0x18]
000006  2800              CMP      r0,#0                 ;1499
000008  d01a              BEQ      |L20.64|
;;;1501        pcb->state != TIME_WAIT &&
00000a  280a              CMP      r0,#0xa
00000c  d018              BEQ      |L20.64|
;;;1502        pcb->state != LISTEN) {
00000e  2801              CMP      r0,#1
000010  d016              BEQ      |L20.64|
;;;1503   
;;;1504       LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));
;;;1505   
;;;1506   #if TCP_LISTEN_BACKLOG
;;;1507       if (pcb->state == SYN_RCVD) {
;;;1508         /* Need to find the corresponding listen_pcb and decrease its accepts_pending */
;;;1509         struct tcp_pcb_listen *lpcb;
;;;1510         LWIP_ASSERT("tcp_pcb_purge: pcb->state == SYN_RCVD but tcp_listen_pcbs is NULL",
;;;1511           tcp_listen_pcbs.listen_pcbs != NULL);
;;;1512         for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
;;;1513           if ((lpcb->local_port == pcb->local_port) &&
;;;1514               (ip_addr_isany(&lpcb->local_ip) ||
;;;1515                ip_addr_cmp(&pcb->local_ip, &lpcb->local_ip))) {
;;;1516               /* port and address of the listen pcb match the timed-out pcb */
;;;1517               LWIP_ASSERT("tcp_pcb_purge: listen pcb does not have accepts pending",
;;;1518                 lpcb->accepts_pending > 0);
;;;1519               lpcb->accepts_pending--;
;;;1520               break;
;;;1521             }
;;;1522         }
;;;1523       }
;;;1524   #endif /* TCP_LISTEN_BACKLOG */
;;;1525   
;;;1526   
;;;1527       if (pcb->refused_data != NULL) {
000012  6fa0              LDR      r0,[r4,#0x78]
000014  2500              MOVS     r5,#0
000016  b110              CBZ      r0,|L20.30|
;;;1528         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
;;;1529         pbuf_free(pcb->refused_data);
000018  f7fffffe          BL       pbuf_free
;;;1530         pcb->refused_data = NULL;
00001c  67a5              STR      r5,[r4,#0x78]
                  |L20.30|
;;;1531       }
;;;1532       if (pcb->unsent != NULL) {
;;;1533         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: not all data sent\n"));
;;;1534       }
;;;1535       if (pcb->unacked != NULL) {
;;;1536         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->unacked\n"));
;;;1537       }
;;;1538   #if TCP_QUEUE_OOSEQ
;;;1539       if (pcb->ooseq != NULL) {
;;;1540         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
;;;1541       }
;;;1542       tcp_segs_free(pcb->ooseq);
00001e  6f60              LDR      r0,[r4,#0x74]
000020  f7fffffe          BL       tcp_segs_free
;;;1543       pcb->ooseq = NULL;
;;;1544   	TCP_DEBUG_USART_PRINTF_S("tcp.c  tcp_segs_free(pcb->unsent)_3;\n");
;;;1545   #endif /* TCP_QUEUE_OOSEQ */
;;;1546   
;;;1547       /* Stop the retransmission timer as it will expect data on unacked
;;;1548          queue if it fires */
;;;1549       pcb->rtime = -1;
000024  f04f30ff          MOV      r0,#0xffffffff
000028  6765              STR      r5,[r4,#0x74]
00002a  86a0              STRH     r0,[r4,#0x34]
;;;1550   
;;;1551       tcp_segs_free(pcb->unsent);
00002c  6ee0              LDR      r0,[r4,#0x6c]
00002e  f7fffffe          BL       tcp_segs_free
;;;1552       tcp_segs_free(pcb->unacked);
000032  6f20              LDR      r0,[r4,#0x70]
000034  f7fffffe          BL       tcp_segs_free
;;;1553   	TCP_DEBUG_USART_PRINTF_S("  tcp_segs_free(pcb->unsent)_2;\n");
;;;1554   	TCP_DEBUG_USART_PRINTF_S("  tcp_segs_free(pcb->unacked)_2;\n");
;;;1555       pcb->unacked = pcb->unsent = NULL;
000038  66e5              STR      r5,[r4,#0x6c]
;;;1556   #if TCP_OVERSIZE
;;;1557       pcb->unsent_oversize = 0;
00003a  6725              STR      r5,[r4,#0x70]
00003c  f8a4506a          STRH     r5,[r4,#0x6a]
                  |L20.64|
;;;1558   #endif /* TCP_OVERSIZE */
;;;1559     }
;;;1560   }
000040  bd70              POP      {r4-r6,pc}
;;;1561   
                          ENDP


                          AREA ||i.tcp_pcb_remove||, CODE, READONLY, ALIGN=2

                  tcp_pcb_remove PROC
;;;1568   void
;;;1569   tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;1570   {
000002  460c              MOV      r4,r1
000004  4601              MOV      r1,r0
;;;1571     TCP_RMV(pcblist, pcb);
000006  6800              LDR      r0,[r0,#0]
000008  42a0              CMP      r0,r4
00000a  d102              BNE      |L21.18|
00000c  68c0              LDR      r0,[r0,#0xc]
00000e  6008              STR      r0,[r1,#0]
000010  e00b              B        |L21.42|
                  |L21.18|
000012  4919              LDR      r1,|L21.120|
000014  e006              B        |L21.36|
                  |L21.22|
000016  68c0              LDR      r0,[r0,#0xc]
000018  42a0              CMP      r0,r4
00001a  d103              BNE      |L21.36|
00001c  6a09              LDR      r1,[r1,#0x20]  ; tcp_tmp_pcb
00001e  68e0              LDR      r0,[r4,#0xc]
000020  60c8              STR      r0,[r1,#0xc]
000022  e002              B        |L21.42|
                  |L21.36|
000024  6208              STR      r0,[r1,#0x20]  ; tcp_tmp_pcb
000026  2800              CMP      r0,#0
000028  d1f5              BNE      |L21.22|
                  |L21.42|
00002a  2500              MOVS     r5,#0
;;;1572   
;;;1573     tcp_pcb_purge(pcb);
00002c  4620              MOV      r0,r4
00002e  60e5              STR      r5,[r4,#0xc]
000030  f7fffffe          BL       tcp_pcb_purge
;;;1574     
;;;1575     /* if there is an outstanding delayed ACKs, send it */
;;;1576     if (pcb->state != TIME_WAIT &&
000034  7e20              LDRB     r0,[r4,#0x18]
000036  280a              CMP      r0,#0xa
000038  d00d              BEQ      |L21.86|
;;;1577        pcb->state != LISTEN &&
00003a  2801              CMP      r0,#1
00003c  d01a              BEQ      |L21.116|
;;;1578        pcb->flags & TF_ACK_DELAY) {
00003e  7fa0              LDRB     r0,[r4,#0x1e]
000040  07c1              LSLS     r1,r0,#31
000042  d008              BEQ      |L21.86|
;;;1579       pcb->flags |= TF_ACK_NOW;
000044  f0400002          ORR      r0,r0,#2
000048  77a0              STRB     r0,[r4,#0x1e]
;;;1580       tcp_output(pcb);
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       tcp_output
;;;1581     }
;;;1582   
;;;1583     if (pcb->state != LISTEN) {
000050  7e20              LDRB     r0,[r4,#0x18]
000052  2801              CMP      r0,#1
000054  d00e              BEQ      |L21.116|
                  |L21.86|
;;;1584       LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
000056  6ee0              LDR      r0,[r4,#0x6c]
000058  b110              CBZ      r0,|L21.96|
00005a  a008              ADR      r0,|L21.124|
00005c  f7fffffe          BL       __2printf
                  |L21.96|
;;;1585       LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
000060  6f20              LDR      r0,[r4,#0x70]
000062  b110              CBZ      r0,|L21.106|
000064  a00b              ADR      r0,|L21.148|
000066  f7fffffe          BL       __2printf
                  |L21.106|
;;;1586   #if TCP_QUEUE_OOSEQ
;;;1587       LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
00006a  6f60              LDR      r0,[r4,#0x74]
00006c  b110              CBZ      r0,|L21.116|
00006e  a010              ADR      r0,|L21.176|
000070  f7fffffe          BL       __2printf
                  |L21.116|
;;;1588   #endif /* TCP_QUEUE_OOSEQ */
;;;1589     }
;;;1590   
;;;1591     pcb->state = CLOSED;
000074  7625              STRB     r5,[r4,#0x18]
;;;1592     TCP_DEBUG_USART_PRINTF_S("pcb->state = CLOSED\n");
;;;1593     LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
;;;1594   }
000076  bd70              POP      {r4-r6,pc}
;;;1595   
                          ENDP

                  |L21.120|
                          DCD      ||.data||
                  |L21.124|
00007c  756e7365          DCB      "unsent segments leaking",0
000080  6e742073
000084  65676d65
000088  6e747320
00008c  6c65616b
000090  696e6700
                  |L21.148|
000094  756e6163          DCB      "unacked segments leaking",0
000098  6b656420
00009c  7365676d
0000a0  656e7473
0000a4  206c6561
0000a8  6b696e67
0000ac  00      
0000ad  00                DCB      0
0000ae  00                DCB      0
0000af  00                DCB      0
                  |L21.176|
0000b0  6f6f7365          DCB      "ooseq segments leaking",0
0000b4  71207365
0000b8  676d656e
0000bc  7473206c
0000c0  65616b69
0000c4  6e6700  
0000c7  00                DCB      0

                          AREA ||i.tcp_poll||, CODE, READONLY, ALIGN=2

                  tcp_poll PROC
;;;1479   void
;;;1480   tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
000000  b570              PUSH     {r4-r6,lr}
;;;1481   {
000002  4604              MOV      r4,r0
;;;1482     LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
000004  7e00              LDRB     r0,[r0,#0x18]
000006  4616              MOV      r6,r2                 ;1481
000008  460d              MOV      r5,r1                 ;1481
00000a  2801              CMP      r0,#1
00000c  d102              BNE      |L22.20|
00000e  a004              ADR      r0,|L22.32|
000010  f7fffffe          BL       __2printf
                  |L22.20|
;;;1483   #if LWIP_CALLBACK_API
;;;1484     pcb->poll = poll;
;;;1485   #else /* LWIP_CALLBACK_API */  
;;;1486     LWIP_UNUSED_ARG(poll);
;;;1487   #endif /* LWIP_CALLBACK_API */  
;;;1488     pcb->pollinterval = interval;
000014  f8c45088          STR      r5,[r4,#0x88]
000018  f8846020          STRB     r6,[r4,#0x20]
;;;1489   }
00001c  bd70              POP      {r4-r6,pc}
;;;1490   
                          ENDP

00001e  0000              DCW      0x0000
                  |L22.32|
000020  696e7661          DCB      "invalid socket state for poll",0
000024  6c696420
000028  736f636b
00002c  65742073
000030  74617465
000034  20666f72
000038  20706f6c
00003c  6c00    
00003e  00                DCB      0
00003f  00                DCB      0

                          AREA ||i.tcp_process_refused_data||, CODE, READONLY, ALIGN=1

                  tcp_process_refused_data PROC
;;;1111   err_t
;;;1112   tcp_process_refused_data(struct tcp_pcb *pcb)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1113   {
;;;1114     err_t err;
;;;1115     u8_t refused_flags = pcb->refused_data->flags;
000004  6f85              LDR      r5,[r0,#0x78]
000006  4604              MOV      r4,r0                 ;1113
;;;1116     /* set pcb->refused_data to NULL in case the callback frees it and then
;;;1117        closes the pcb */
;;;1118     struct pbuf *refused_data = pcb->refused_data;
;;;1119     pcb->refused_data = NULL;
000008  2000              MOVS     r0,#0
00000a  7b6e              LDRB     r6,[r5,#0xd]          ;1115
;;;1120     /* Notify again application with data previously received. */
;;;1121     LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
;;;1122     TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
00000c  67a0              STR      r0,[r4,#0x78]
00000e  f8d47080          LDR      r7,[r4,#0x80]         ;1113
000012  b12f              CBZ      r7,|L23.32|
000014  2300              MOVS     r3,#0
000016  462a              MOV      r2,r5
000018  4621              MOV      r1,r4
00001a  6920              LDR      r0,[r4,#0x10]
00001c  47b8              BLX      r7
00001e  e005              B        |L23.44|
                  |L23.32|
000020  2300              MOVS     r3,#0
000022  462a              MOV      r2,r5
000024  4621              MOV      r1,r4
000026  4618              MOV      r0,r3
000028  f7fffffe          BL       tcp_recv_null
                  |L23.44|
;;;1123     if (err == ERR_OK) {
;;;1124       /* did refused_data include a FIN? */
;;;1125       if (refused_flags & PBUF_FLAG_TCP_FIN) {
;;;1126         /* correct rcv_wnd as the application won't call tcp_recved()
;;;1127            for the FIN's seqno */
;;;1128         if (pcb->rcv_wnd != TCP_WND) {
;;;1129           pcb->rcv_wnd++;
;;;1130         }
;;;1131         TCP_EVENT_CLOSED(pcb, err);
;;;1132         if (err == ERR_ABRT) {
00002c  f06f0709          MVN      r7,#9
000030  b128              CBZ      r0,|L23.62|
000032  300a              ADDS     r0,r0,#0xa            ;1123
;;;1133           return ERR_ABRT;
;;;1134         }
;;;1135       }
;;;1136     } else if (err == ERR_ABRT) {
000034  d015              BEQ      |L23.98|
;;;1137       /* if err == ERR_ABRT, 'pcb' is already deallocated */
;;;1138       /* Drop incoming packets because pcb is "full" (only if the incoming
;;;1139          segment contains data). */
;;;1140       LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
;;;1141       return ERR_ABRT;
;;;1142     } else {
;;;1143       /* data is still refused, pbuf is still valid (go on for ACK-only packets) */
;;;1144       pcb->refused_data = refused_data;
000036  67a5              STR      r5,[r4,#0x78]
                  |L23.56|
;;;1145     }
;;;1146     return ERR_OK;
000038  2000              MOVS     r0,#0
                  |L23.58|
;;;1147   }
00003a  e8bd81f0          POP      {r4-r8,pc}
                  |L23.62|
00003e  06b1              LSLS     r1,r6,#26             ;1125
000040  d5fa              BPL      |L23.56|
000042  8da1              LDRH     r1,[r4,#0x2c]         ;1128
000044  f5b16f2a          CMP      r1,#0xaa0             ;1128
000048  d001              BEQ      |L23.78|
00004a  1c49              ADDS     r1,r1,#1              ;1128
00004c  85a1              STRH     r1,[r4,#0x2c]         ;1129
                  |L23.78|
00004e  f8d45080          LDR      r5,[r4,#0x80]         ;1131
000052  b125              CBZ      r5,|L23.94|
000054  2300              MOVS     r3,#0                 ;1131
000056  461a              MOV      r2,r3                 ;1131
000058  4621              MOV      r1,r4                 ;1131
00005a  6920              LDR      r0,[r4,#0x10]         ;1131
00005c  47a8              BLX      r5                    ;1131
                  |L23.94|
00005e  300a              ADDS     r0,r0,#0xa            ;1131
000060  d1ea              BNE      |L23.56|
                  |L23.98|
000062  4638              MOV      r0,r7                 ;1141
000064  e7e9              B        |L23.58|
;;;1148   
                          ENDP


                          AREA ||i.tcp_recv||, CODE, READONLY, ALIGN=2

                  tcp_recv PROC
;;;1419   void
;;;1420   tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
000000  b570              PUSH     {r4-r6,lr}
;;;1421   {
000002  4604              MOV      r4,r0
;;;1422     LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
000004  7e00              LDRB     r0,[r0,#0x18]
000006  460d              MOV      r5,r1                 ;1421
000008  2801              CMP      r0,#1
00000a  d102              BNE      |L24.18|
00000c  a002              ADR      r0,|L24.24|
00000e  f7fffffe          BL       __2printf
                  |L24.18|
;;;1423     pcb->recv = recv;
000012  f8c45080          STR      r5,[r4,#0x80]
;;;1424   }
000016  bd70              POP      {r4-r6,pc}
;;;1425   
                          ENDP

                  |L24.24|
000018  696e7661          DCB      "invalid socket state for recv callback",0
00001c  6c696420
000020  736f636b
000024  65742073
000028  74617465
00002c  20666f72
000030  20726563
000034  76206361
000038  6c6c6261
00003c  636b00  
00003f  00                DCB      0

                          AREA ||i.tcp_recv_null||, CODE, READONLY, ALIGN=1

                  tcp_recv_null PROC
;;;1224   err_t
;;;1225   tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
000000  b510              PUSH     {r4,lr}
;;;1226   {
000002  0014              MOVS     r4,r2
000004  4608              MOV      r0,r1
000006  d006              BEQ      |L25.22|
;;;1227     LWIP_UNUSED_ARG(arg);
;;;1228     if (p != NULL) {
;;;1229       tcp_recved(pcb, p->tot_len);
000008  8921              LDRH     r1,[r4,#8]
00000a  f7fffffe          BL       tcp_recved
;;;1230       pbuf_free(p);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       pbuf_free
000014  e000              B        |L25.24|
                  |L25.22|
;;;1231     } else if (err == ERR_OK) {
000016  b10b              CBZ      r3,|L25.28|
                  |L25.24|
;;;1232       return tcp_close(pcb);
;;;1233     }
;;;1234     return ERR_OK;
000018  2000              MOVS     r0,#0
;;;1235   }
00001a  bd10              POP      {r4,pc}
                  |L25.28|
00001c  e8bd4010          POP      {r4,lr}               ;1232
000020  f7ffbffe          B.W      tcp_close
;;;1236   #endif /* LWIP_CALLBACK_API */
                          ENDP


                          AREA ||i.tcp_recved||, CODE, READONLY, ALIGN=2

                  tcp_recved PROC
;;;633    void
;;;634    tcp_recved(struct tcp_pcb *pcb, u16_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;635    {
000002  4604              MOV      r4,r0
;;;636      int wnd_inflation;
;;;637    
;;;638      /* pcb->state LISTEN not allowed here */
;;;639      LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
000004  7e00              LDRB     r0,[r0,#0x18]
000006  460d              MOV      r5,r1                 ;635
000008  2801              CMP      r0,#1
00000a  d102              BNE      |L26.18|
00000c  a012              ADR      r0,|L26.88|
00000e  f7fffffe          BL       __2printf
                  |L26.18|
;;;640        pcb->state != LISTEN);
;;;641      LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
000012  8da0              LDRH     r0,[r4,#0x2c]
000014  f64f71ff          MOV      r1,#0xffff
000018  1a08              SUBS     r0,r1,r0
00001a  42a8              CMP      r0,r5
00001c  d202              BCS      |L26.36|
00001e  a018              ADR      r0,|L26.128|
000020  f7fffffe          BL       __2printf
                  |L26.36|
;;;642                  len <= 0xffff - pcb->rcv_wnd );
;;;643    
;;;644      pcb->rcv_wnd += len;
000024  8da0              LDRH     r0,[r4,#0x2c]
;;;645      if (pcb->rcv_wnd > TCP_WND) {
000026  f44f612a          MOV      r1,#0xaa0
00002a  4428              ADD      r0,r0,r5              ;644
00002c  b280              UXTH     r0,r0                 ;644
00002e  85a0              STRH     r0,[r4,#0x2c]         ;644
000030  4288              CMP      r0,r1
000032  d900              BLS      |L26.54|
;;;646        pcb->rcv_wnd = TCP_WND;
000034  85a1              STRH     r1,[r4,#0x2c]
                  |L26.54|
;;;647      }
;;;648    
;;;649      wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       tcp_update_rcv_ann_wnd
;;;650    
;;;651      /* If the change in the right edge of window is significant (default
;;;652       * watermark is TCP_WND/4), then send an explicit update now.
;;;653       * Otherwise wait for a packet to be sent in the normal course of
;;;654       * events (or more window to be available later) */
;;;655      if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
00003c  f5b07f2a          CMP      r0,#0x2a8
000040  db08              BLT      |L26.84|
;;;656        tcp_ack_now(pcb);
000042  7fa0              LDRB     r0,[r4,#0x1e]
000044  f0400002          ORR      r0,r0,#2
000048  77a0              STRB     r0,[r4,#0x1e]
;;;657        tcp_output(pcb);
00004a  4620              MOV      r0,r4
00004c  e8bd4070          POP      {r4-r6,lr}
000050  f7ffbffe          B.W      tcp_output
                  |L26.84|
;;;658      }
;;;659    
;;;660      LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
;;;661             len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
;;;662    }
000054  bd70              POP      {r4-r6,pc}
;;;663    
                          ENDP

000056  0000              DCW      0x0000
                  |L26.88|
000058  646f6e27          DCB      "don't call tcp_recved for listen-pcbs",0
00005c  74206361
000060  6c6c2074
000064  63705f72
000068  65637665
00006c  6420666f
000070  72206c69
000074  7374656e
000078  2d706362
00007c  7300    
00007e  00                DCB      0
00007f  00                DCB      0
                  |L26.128|
000080  7463705f          DCB      "tcp_recved: len would wrap rcv_wnd\n",0
000084  72656376
000088  65643a20
00008c  6c656e20
000090  776f756c
000094  64207772
000098  61702072
00009c  63765f77
0000a0  6e640a00

                          AREA ||i.tcp_seg_copy||, CODE, READONLY, ALIGN=1

                  tcp_seg_copy PROC
;;;1204   struct tcp_seg *
;;;1205   tcp_seg_copy(struct tcp_seg *seg)
000000  b570              PUSH     {r4-r6,lr}
;;;1206   {
000002  4604              MOV      r4,r0
;;;1207     struct tcp_seg *cseg;
;;;1208   
;;;1209     cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       memp_malloc
00000a  1e05              SUBS     r5,r0,#0
;;;1210     if (cseg == NULL) {
00000c  d009              BEQ      |L27.34|
;;;1211       return NULL;
;;;1212     }
;;;1213     SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
00000e  cc04              LDM      r4!,{r2}
000010  e894000b          LDM      r4,{r0,r1,r3}
000014  c504              STM      r5!,{r2}
000016  e885000b          STM      r5,{r0,r1,r3}
00001a  1f2d              SUBS     r5,r5,#4
;;;1214     pbuf_ref(cseg->p);
00001c  f7fffffe          BL       pbuf_ref
;;;1215     return cseg;
000020  4628              MOV      r0,r5
                  |L27.34|
;;;1216   }
000022  bd70              POP      {r4-r6,pc}
;;;1217   #endif /* TCP_QUEUE_OOSEQ */
                          ENDP


                          AREA ||i.tcp_seg_free||, CODE, READONLY, ALIGN=1

                  tcp_seg_free PROC
;;;1169   void
;;;1170   tcp_seg_free(struct tcp_seg *seg)
000000  b510              PUSH     {r4,lr}
;;;1171   {
000002  0004              MOVS     r4,r0
000004  d009              BEQ      |L28.26|
;;;1172     if (seg != NULL) {
;;;1173       if (seg->p != NULL) {
000006  6860              LDR      r0,[r4,#4]
000008  b108              CBZ      r0,|L28.14|
;;;1174         pbuf_free(seg->p);
00000a  f7fffffe          BL       pbuf_free
                  |L28.14|
;;;1175   #if TCP_DEBUG
;;;1176         seg->p = NULL;
;;;1177   #endif /* TCP_DEBUG */
;;;1178       }
;;;1179       memp_free(MEMP_TCP_SEG, seg);
00000e  4621              MOV      r1,r4
000010  e8bd4010          POP      {r4,lr}
000014  2004              MOVS     r0,#4
000016  f7ffbffe          B.W      memp_free
                  |L28.26|
;;;1180   
;;;1181     }
;;;1182   }
00001a  bd10              POP      {r4,pc}
;;;1183   
                          ENDP


                          AREA ||i.tcp_segs_free||, CODE, READONLY, ALIGN=1

                  tcp_segs_free PROC
;;;1154   void
;;;1155   tcp_segs_free(struct tcp_seg *seg)
000000  b510              PUSH     {r4,lr}
;;;1156   {
;;;1157     while (seg != NULL) {
;;;1158       struct tcp_seg *next = seg->next;
;;;1159       tcp_seg_free(seg);
;;;1160       seg = next;
;;;1161     }
000002  e003              B        |L29.12|
                  |L29.4|
000004  6804              LDR      r4,[r0,#0]            ;1159
000006  f7fffffe          BL       tcp_seg_free
00000a  4620              MOV      r0,r4                 ;1160
                  |L29.12|
00000c  2800              CMP      r0,#0                 ;1157
00000e  d1f9              BNE      |L29.4|
;;;1162   }
000010  bd10              POP      {r4,pc}
;;;1163   
                          ENDP


                          AREA ||i.tcp_sent||, CODE, READONLY, ALIGN=2

                  tcp_sent PROC
;;;1433   void
;;;1434   tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
000000  b570              PUSH     {r4-r6,lr}
;;;1435   {
000002  4604              MOV      r4,r0
;;;1436     LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
000004  7e00              LDRB     r0,[r0,#0x18]
000006  460d              MOV      r5,r1                 ;1435
000008  2801              CMP      r0,#1
00000a  d102              BNE      |L30.18|
00000c  a002              ADR      r0,|L30.24|
00000e  f7fffffe          BL       __2printf
                  |L30.18|
;;;1437     pcb->sent = sent;
000012  67e5              STR      r5,[r4,#0x7c]
;;;1438   }
000014  bd70              POP      {r4-r6,pc}
;;;1439   
                          ENDP

000016  0000              DCW      0x0000
                  |L30.24|
000018  696e7661          DCB      "invalid socket state for sent callback",0
00001c  6c696420
000020  736f636b
000024  65742073
000028  74617465
00002c  20666f72
000030  2073656e
000034  74206361
000038  6c6c6261
00003c  636b00  
00003f  00                DCB      0

                          AREA ||i.tcp_setprio||, CODE, READONLY, ALIGN=1

                  tcp_setprio PROC
;;;1190   void
;;;1191   tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
000000  7641              STRB     r1,[r0,#0x19]
;;;1192   {
;;;1193     pcb->prio = prio;
;;;1194   }
000002  4770              BX       lr
;;;1195   
                          ENDP


                          AREA ||i.tcp_shutdown||, CODE, READONLY, ALIGN=1

                  tcp_shutdown PROC
;;;325    err_t
;;;326    tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
000000  b510              PUSH     {r4,lr}
;;;327    {
000002  4604              MOV      r4,r0
;;;328      if (pcb->state == LISTEN) {
000004  7e00              LDRB     r0,[r0,#0x18]
;;;329        return ERR_CONN;
000006  f06f030c          MVN      r3,#0xc
00000a  2801              CMP      r0,#1                 ;328
00000c  d015              BEQ      |L32.58|
;;;330      }
;;;331      if (shut_rx) {
00000e  b169              CBZ      r1,|L32.44|
;;;332        /* shut down the receive side: set a flag not to receive any more data... */
;;;333        pcb->flags |= TF_RXCLOSED;
000010  7fa0              LDRB     r0,[r4,#0x1e]
000012  f0400010          ORR      r0,r0,#0x10
000016  77a0              STRB     r0,[r4,#0x1e]
;;;334        if (shut_tx) {
000018  b10a              CBZ      r2,|L32.30|
;;;335          /* shutting down the tx AND rx side is the same as closing for the raw API */
;;;336          return tcp_close_shutdown(pcb, 1);
00001a  2101              MOVS     r1,#1
00001c  e010              B        |L32.64|
                  |L32.30|
;;;337        }
;;;338        /* ... and free buffered data */
;;;339        if (pcb->refused_data != NULL) {
00001e  6fa0              LDR      r0,[r4,#0x78]
000020  b198              CBZ      r0,|L32.74|
;;;340          pbuf_free(pcb->refused_data);
000022  f7fffffe          BL       pbuf_free
;;;341          pcb->refused_data = NULL;
000026  2000              MOVS     r0,#0
000028  67a0              STR      r0,[r4,#0x78]
00002a  e00e              B        |L32.74|
                  |L32.44|
;;;342        }
;;;343      }
;;;344      if (shut_tx) {
00002c  b16a              CBZ      r2,|L32.74|
;;;345        /* This can't happen twice since if it succeeds, the pcb's state is changed.
;;;346           Only close in these states as the others directly deallocate the PCB */
;;;347        switch (pcb->state) {
00002e  2803              CMP      r0,#3
000030  d005              BEQ      |L32.62|
000032  2804              CMP      r0,#4
000034  d003              BEQ      |L32.62|
000036  2807              CMP      r0,#7
000038  d001              BEQ      |L32.62|
                  |L32.58|
;;;348        case SYN_RCVD:
;;;349        case ESTABLISHED:
;;;350        case CLOSE_WAIT:
;;;351          return tcp_close_shutdown(pcb, shut_rx);
;;;352        default:
;;;353          /* Not (yet?) connected, cannot shutdown the TX side as that would bring us
;;;354            into CLOSED state, where the PCB is deallocated. */
;;;355          return ERR_CONN;
00003a  4618              MOV      r0,r3
;;;356        }
;;;357      }
;;;358      return ERR_OK;
;;;359    }
00003c  bd10              POP      {r4,pc}
                  |L32.62|
00003e  b2c9              UXTB     r1,r1                 ;351
                  |L32.64|
000040  4620              MOV      r0,r4                 ;351
000042  e8bd4010          POP      {r4,lr}               ;351
000046  f7ffbffe          B.W      tcp_close_shutdown
                  |L32.74|
00004a  2000              MOVS     r0,#0                 ;358
00004c  bd10              POP      {r4,pc}
;;;360    
                          ENDP


                          AREA ||i.tcp_slowtmr||, CODE, READONLY, ALIGN=2

                  tcp_slowtmr PROC
;;;811    void
;;;812    tcp_slowtmr(void)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;813    {
;;;814      struct tcp_pcb *pcb, *prev;
;;;815      u16_t eff_wnd;
;;;816      u8_t pcb_remove;      /* flag if a PCB should be removed */
;;;817      u8_t pcb_reset;       /* flag if a RST should be sent when removing */
;;;818      err_t err;
;;;819    
;;;820      err = ERR_OK;
;;;821    
;;;822      ++tcp_ticks;
000004  4fb3              LDR      r7,|L33.724|
;;;823      ++tcp_timer_ctr;
;;;824    
;;;825    tcp_slowtmr_start:
;;;826      /* Steps through all of the active PCBs. */
;;;827      prev = NULL;
;;;828      pcb = tcp_active_pcbs;
;;;829      if (pcb == NULL) {
;;;830        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
;;;831      }
;;;832      while (pcb != NULL) {
;;;833        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
;;;834        LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
;;;835        LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
;;;836        LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
;;;837        if (pcb->last_timer == tcp_timer_ctr) {
;;;838          /* skip this pcb, we have already processed it */
;;;839    	  prev = pcb;
;;;840          pcb = pcb->next;
;;;841          continue;
;;;842        }
;;;843        pcb->last_timer = tcp_timer_ctr;
;;;844    
;;;845        pcb_remove = 0;
;;;846        pcb_reset = 0;
;;;847    
;;;848        if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
;;;849          ++pcb_remove;
;;;850          LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
;;;851        }
;;;852        else if (pcb->nrtx == TCP_MAXRTX) {
;;;853          ++pcb_remove;
;;;854          LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
;;;855        } else {
;;;856          if (pcb->persist_backoff > 0) {
;;;857            /* If snd_wnd is zero, use persist timer to send 1 byte probes
;;;858             * instead of using the standard retransmission mechanism. */
;;;859            pcb->persist_cnt++;
;;;860            if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
;;;861              pcb->persist_cnt = 0;
;;;862              if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
;;;863                pcb->persist_backoff++;
;;;864              }
;;;865              tcp_zero_window_probe(pcb);
;;;866            }
;;;867          } else {
;;;868            /* Increase the retransmission timer if it is running */
;;;869            if(pcb->rtime >= 0) {
;;;870              ++pcb->rtime;
;;;871            }
;;;872    
;;;873            if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
;;;874              /* Time for a retransmission. */
;;;875              LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_slowtmr: rtime %"S16_F
;;;876                                          " pcb->rto %"S16_F"\n",
;;;877                                          pcb->rtime, pcb->rto));
;;;878    
;;;879              /* Double retransmission time-out unless we are trying to
;;;880               * connect to somebody (i.e., we are in SYN_SENT). */
;;;881              if (pcb->state != SYN_SENT) {
;;;882                pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
;;;883              }
;;;884    
;;;885              /* Reset the retransmission timer. */
;;;886              pcb->rtime = 0;
;;;887    
;;;888              /* Reduce congestion window and ssthresh. */
;;;889              eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
;;;890              pcb->ssthresh = eff_wnd >> 1;
;;;891              if (pcb->ssthresh < (pcb->mss << 1)) {
;;;892                pcb->ssthresh = (pcb->mss << 1);
;;;893              }
;;;894              pcb->cwnd = pcb->mss;
;;;895              LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: cwnd %"U16_F
;;;896                                           " ssthresh %"U16_F"\n",
;;;897                                           pcb->cwnd, pcb->ssthresh));
;;;898     
;;;899              /* The following needs to be called AFTER cwnd is set to one
;;;900                 mss - STJ */
;;;901              tcp_rexmit_rto(pcb);
;;;902            }
;;;903          }
;;;904        }
;;;905        /* Check if this PCB has stayed too long in FIN-WAIT-2 */
;;;906        if (pcb->state == FIN_WAIT_2) {
;;;907          /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
;;;908          if (pcb->flags & TF_RXCLOSED) {
;;;909            /* PCB was fully closed (either through close() or SHUT_RDWR):
;;;910               normal FIN-WAIT timeout handling. */
;;;911            if ((u32_t)(tcp_ticks - pcb->tmr) >
;;;912                TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
;;;913              ++pcb_remove;
;;;914              LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
;;;915            }
;;;916          }
;;;917        }
;;;918    
;;;919        /* Check if KEEPALIVE should be sent */
;;;920        if(ip_get_option(pcb, SOF_KEEPALIVE) &&
;;;921           ((pcb->state == ESTABLISHED) ||
;;;922            (pcb->state == CLOSE_WAIT))) {
;;;923          if((u32_t)(tcp_ticks - pcb->tmr) >
000006  f44f7afa          MOV      r10,#0x1f4
00000a  f04f0900          MOV      r9,#0
00000e  68f8              LDR      r0,[r7,#0xc]          ;822  ; tcp_ticks
000010  1c40              ADDS     r0,r0,#1              ;822
000012  60f8              STR      r0,[r7,#0xc]          ;823  ; tcp_ticks
000014  78b8              LDRB     r0,[r7,#2]            ;823  ; tcp_timer_ctr
000016  1c40              ADDS     r0,r0,#1              ;823
000018  70b8              STRB     r0,[r7,#2]            ;823
                  |L33.26|
00001a  2600              MOVS     r6,#0                 ;827
00001c  69bc              LDR      r4,[r7,#0x18]         ;832  ; tcp_active_pcbs
00001e  e127              B        |L33.624|
                  |L33.32|
000020  7e20              LDRB     r0,[r4,#0x18]         ;834
000022  b910              CBNZ     r0,|L33.42|
000024  a0ac              ADR      r0,|L33.728|
000026  f7fffffe          BL       __2printf
                  |L33.42|
00002a  7e20              LDRB     r0,[r4,#0x18]         ;835
00002c  2801              CMP      r0,#1                 ;835
00002e  d102              BNE      |L33.54|
000030  a0b4              ADR      r0,|L33.772|
000032  f7fffffe          BL       __2printf
                  |L33.54|
000036  7e20              LDRB     r0,[r4,#0x18]         ;836
000038  280a              CMP      r0,#0xa               ;836
00003a  d102              BNE      |L33.66|
00003c  a0bc              ADR      r0,|L33.816|
00003e  f7fffffe          BL       __2printf
                  |L33.66|
000042  f8941021          LDRB     r1,[r4,#0x21]         ;837
000046  78b8              LDRB     r0,[r7,#2]            ;837  ; tcp_timer_ctr
000048  4281              CMP      r1,r0                 ;837
00004a  d102              BNE      |L33.82|
00004c  4626              MOV      r6,r4                 ;839
00004e  68e4              LDR      r4,[r4,#0xc]          ;840
000050  e10e              B        |L33.624|
                  |L33.82|
000052  f8840021          STRB     r0,[r4,#0x21]         ;843
000056  2500              MOVS     r5,#0                 ;845
000058  7e22              LDRB     r2,[r4,#0x18]         ;848
00005a  46a8              MOV      r8,r5                 ;846
00005c  2a02              CMP      r2,#2                 ;848
00005e  d103              BNE      |L33.104|
000060  f8940046          LDRB     r0,[r4,#0x46]         ;848
000064  2806              CMP      r0,#6                 ;848
000066  d01b              BEQ      |L33.160|
                  |L33.104|
000068  f8941046          LDRB     r1,[r4,#0x46]         ;852
00006c  290c              CMP      r1,#0xc               ;852
00006e  d019              BEQ      |L33.164|
000070  f8940095          LDRB     r0,[r4,#0x95]         ;856
000074  b1c0              CBZ      r0,|L33.168|
000076  f8941094          LDRB     r1,[r4,#0x94]         ;859
00007a  4ab9              LDR      r2,|L33.864|
00007c  1c49              ADDS     r1,r1,#1              ;859
00007e  b2c9              UXTB     r1,r1                 ;859
000080  f8841094          STRB     r1,[r4,#0x94]         ;859
000084  5c82              LDRB     r2,[r0,r2]            ;860
000086  4291              CMP      r1,r2                 ;860
000088  d344              BCC      |L33.276|
00008a  f8849094          STRB     r9,[r4,#0x94]         ;861
00008e  2807              CMP      r0,#7                 ;862
000090  d202              BCS      |L33.152|
000092  1c40              ADDS     r0,r0,#1              ;862
000094  f8840095          STRB     r0,[r4,#0x95]         ;863
                  |L33.152|
000098  4620              MOV      r0,r4                 ;865
00009a  f7fffffe          BL       tcp_zero_window_probe
00009e  e039              B        |L33.276|
                  |L33.160|
0000a0  2501              MOVS     r5,#1                 ;849
0000a2  e043              B        |L33.300|
                  |L33.164|
0000a4  2501              MOVS     r5,#1                 ;853
0000a6  e035              B        |L33.276|
                  |L33.168|
0000a8  f9b40034          LDRSH    r0,[r4,#0x34]         ;869
0000ac  2800              CMP      r0,#0                 ;869
0000ae  db01              BLT      |L33.180|
0000b0  1c40              ADDS     r0,r0,#1              ;869
0000b2  86a0              STRH     r0,[r4,#0x34]         ;870
                  |L33.180|
0000b4  6f20              LDR      r0,[r4,#0x70]         ;873
0000b6  b368              CBZ      r0,|L33.276|
0000b8  f9b40034          LDRSH    r0,[r4,#0x34]         ;873
0000bc  f9b43044          LDRSH    r3,[r4,#0x44]         ;873
0000c0  4298              CMP      r0,r3                 ;873
0000c2  db27              BLT      |L33.276|
0000c4  2a02              CMP      r2,#2                 ;881
0000c6  d00a              BEQ      |L33.222|
0000c8  f8b40042          LDRH     r0,[r4,#0x42]         ;882
0000cc  f9b42040          LDRSH    r2,[r4,#0x40]         ;882
0000d0  eb0000e2          ADD      r0,r0,r2,ASR #3       ;882
0000d4  4aa3              LDR      r2,|L33.868|
0000d6  5c51              LDRB     r1,[r2,r1]            ;882
0000d8  4088              LSLS     r0,r0,r1              ;882
0000da  f8a40044          STRH     r0,[r4,#0x44]         ;882
                  |L33.222|
0000de  f8a49034          STRH     r9,[r4,#0x34]         ;886
0000e2  f8b4004c          LDRH     r0,[r4,#0x4c]         ;889
0000e6  f8b41060          LDRH     r1,[r4,#0x60]         ;889
0000ea  4288              CMP      r0,r1                 ;889
0000ec  d300              BCC      |L33.240|
0000ee  4608              MOV      r0,r1                 ;889
                  |L33.240|
0000f0  0841              LSRS     r1,r0,#1              ;890
0000f2  f8a4104e          STRH     r1,[r4,#0x4e]         ;890
0000f6  8ee0              LDRH     r0,[r4,#0x36]         ;891
0000f8  ebb10f40          CMP      r1,r0,LSL #1          ;891
0000fc  d205              BCS      |L33.266|
0000fe  f64f71ff          MOV      r1,#0xffff            ;892
000102  ea010140          AND      r1,r1,r0,LSL #1       ;892
000106  f8a4104e          STRH     r1,[r4,#0x4e]         ;892
                  |L33.266|
00010a  f8a4004c          STRH     r0,[r4,#0x4c]         ;894
00010e  4620              MOV      r0,r4                 ;901
000110  f7fffffe          BL       tcp_rexmit_rto
                  |L33.276|
000114  7e20              LDRB     r0,[r4,#0x18]         ;906
000116  2806              CMP      r0,#6                 ;906
000118  d108              BNE      |L33.300|
00011a  7fa0              LDRB     r0,[r4,#0x1e]         ;908
00011c  06c0              LSLS     r0,r0,#27             ;908
00011e  d505              BPL      |L33.300|
000120  6a60              LDR      r0,[r4,#0x24]         ;911
000122  68f9              LDR      r1,[r7,#0xc]          ;911  ; tcp_ticks
000124  1a08              SUBS     r0,r1,r0              ;911
000126  2828              CMP      r0,#0x28              ;911
000128  d900              BLS      |L33.300|
00012a  1c6d              ADDS     r5,r5,#1              ;911
                  |L33.300|
00012c  7a20              LDRB     r0,[r4,#8]            ;920
00012e  0700              LSLS     r0,r0,#28             ;920
000130  d529              BPL      |L33.390|
000132  7e20              LDRB     r0,[r4,#0x18]         ;921
000134  2804              CMP      r0,#4                 ;921
000136  d001              BEQ      |L33.316|
000138  2807              CMP      r0,#7                 ;922
00013a  d124              BNE      |L33.390|
                  |L33.316|
00013c  488a              LDR      r0,|L33.872|
00013e  f8d41090          LDR      r1,[r4,#0x90]
000142  f8d7c00c          LDR      r12,[r7,#0xc]  ; tcp_ticks
000146  4408              ADD      r0,r0,r1
000148  fbb0f2fa          UDIV     r2,r0,r10
00014c  6a60              LDR      r0,[r4,#0x24]
00014e  ebac0000          SUB      r0,r12,r0
000152  4282              CMP      r2,r0
000154  d203              BCS      |L33.350|
;;;924             (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
;;;925          {
;;;926            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
;;;927                                    ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
;;;928                                    ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
;;;929            
;;;930            ++pcb_remove;
;;;931            ++pcb_reset;
000156  f04f0801          MOV      r8,#1
00015a  1c6d              ADDS     r5,r5,#1
00015c  e013              B        |L33.390|
                  |L33.350|
;;;932          }
;;;933          else if((u32_t)(tcp_ticks - pcb->tmr) > 
00015e  f8942096          LDRB     r2,[r4,#0x96]
000162  f2424c9f          MOV      r12,#0x249f
000166  fb12f20c          SMULBB   r2,r2,r12
00016a  eb0101c2          ADD      r1,r1,r2,LSL #3
00016e  fbb1f1fa          UDIV     r1,r1,r10
000172  4281              CMP      r1,r0
000174  d207              BCS      |L33.390|
;;;934                  (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
;;;935                  / TCP_SLOW_INTERVAL)
;;;936          {
;;;937            tcp_keepalive(pcb);
000176  4620              MOV      r0,r4
000178  f7fffffe          BL       tcp_keepalive
;;;938            pcb->keep_cnt_sent++;
00017c  f8940096          LDRB     r0,[r4,#0x96]
000180  1c40              ADDS     r0,r0,#1
000182  f8840096          STRB     r0,[r4,#0x96]
                  |L33.390|
;;;939          }
;;;940        }
;;;941    
;;;942        /* If this PCB has queued out of sequence data, but has been
;;;943           inactive for too long, will drop the data (it will eventually
;;;944           be retransmitted). */
;;;945    #if TCP_QUEUE_OOSEQ
;;;946        if (pcb->ooseq != NULL &&
000186  6f60              LDR      r0,[r4,#0x74]
000188  b168              CBZ      r0,|L33.422|
;;;947            (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
00018a  6a61              LDR      r1,[r4,#0x24]
00018c  68fa              LDR      r2,[r7,#0xc]  ; tcp_ticks
00018e  1a52              SUBS     r2,r2,r1
000190  f9b41044          LDRSH    r1,[r4,#0x44]
000194  eb010141          ADD      r1,r1,r1,LSL #1
000198  ebb20f41          CMP      r2,r1,LSL #1
00019c  d303              BCC      |L33.422|
;;;948          tcp_segs_free(pcb->ooseq);
00019e  f7fffffe          BL       tcp_segs_free
;;;949    	  TCP_DEBUG_USART_PRINTF_S("tcp.c  tcp_segs_free(pcb->unsent)_2;\n");
;;;950          pcb->ooseq = NULL;
0001a2  f8c49074          STR      r9,[r4,#0x74]
                  |L33.422|
;;;951          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
;;;952        }
;;;953    #endif /* TCP_QUEUE_OOSEQ */
;;;954    
;;;955        /* Check if this PCB has stayed too long in SYN-RCVD */
;;;956        if (pcb->state == SYN_RCVD) {
0001a6  7e20              LDRB     r0,[r4,#0x18]
0001a8  2803              CMP      r0,#3
0001aa  d002              BEQ      |L33.434|
;;;957          if ((u32_t)(tcp_ticks - pcb->tmr) >
;;;958              TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
;;;959            ++pcb_remove;
;;;960            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
;;;961          }
;;;962        }
;;;963    
;;;964        /* Check if this PCB has stayed too long in LAST-ACK */
;;;965        if (pcb->state == LAST_ACK) {
0001ac  2809              CMP      r0,#9
0001ae  d007              BEQ      |L33.448|
0001b0  e00b              B        |L33.458|
                  |L33.434|
0001b2  6a60              LDR      r0,[r4,#0x24]         ;957
0001b4  68f9              LDR      r1,[r7,#0xc]          ;957  ; tcp_ticks
0001b6  1a08              SUBS     r0,r1,r0              ;957
0001b8  2828              CMP      r0,#0x28              ;957
0001ba  d906              BLS      |L33.458|
                  |L33.444|
0001bc  1c6d              ADDS     r5,r5,#1              ;957
0001be  e004              B        |L33.458|
                  |L33.448|
;;;966          if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
0001c0  6a60              LDR      r0,[r4,#0x24]
0001c2  68f9              LDR      r1,[r7,#0xc]  ; tcp_ticks
0001c4  1a08              SUBS     r0,r1,r0
0001c6  280a              CMP      r0,#0xa
0001c8  d8f8              BHI      |L33.444|
                  |L33.458|
;;;967            ++pcb_remove;
;;;968            LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
;;;969          }
;;;970        }
;;;971    
;;;972        /* If the PCB should be removed, do it. */
;;;973        if (pcb_remove) {
0001ca  b3ad              CBZ      r5,|L33.568|
;;;974          struct tcp_pcb *pcb2;
;;;975          tcp_err_fn err_fn;
;;;976          void *err_arg;
;;;977          tcp_pcb_purge(pcb);
0001cc  4620              MOV      r0,r4
0001ce  f7fffffe          BL       tcp_pcb_purge
;;;978          /* Remove PCB from tcp_active_pcbs list. */
;;;979          if (prev != NULL) {
0001d2  69b8              LDR      r0,[r7,#0x18]  ; tcp_active_pcbs
0001d4  b13e              CBZ      r6,|L33.486|
;;;980            LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
0001d6  4284              CMP      r4,r0
0001d8  d102              BNE      |L33.480|
0001da  a064              ADR      r0,|L33.876|
0001dc  f7fffffe          BL       __2printf
                  |L33.480|
;;;981            prev->next = pcb->next;
0001e0  68e0              LDR      r0,[r4,#0xc]
0001e2  60f0              STR      r0,[r6,#0xc]
0001e4  e006              B        |L33.500|
                  |L33.486|
;;;982          } else {
;;;983            /* This PCB was the first. */
;;;984            LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
0001e6  42a0              CMP      r0,r4
0001e8  d002              BEQ      |L33.496|
0001ea  a06b              ADR      r0,|L33.920|
0001ec  f7fffffe          BL       __2printf
                  |L33.496|
;;;985            tcp_active_pcbs = pcb->next;
0001f0  68e0              LDR      r0,[r4,#0xc]
0001f2  61b8              STR      r0,[r7,#0x18]  ; tcp_active_pcbs
                  |L33.500|
;;;986          }
;;;987    
;;;988          if (pcb_reset) {
0001f4  f1b80f00          CMP      r8,#0
0001f8  d009              BEQ      |L33.526|
;;;989            tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
0001fa  8ba1              LDRH     r1,[r4,#0x1c]
0001fc  8b60              LDRH     r0,[r4,#0x1a]
0001fe  e9cd0100          STRD     r0,r1,[sp,#0]
000202  1d23              ADDS     r3,r4,#4
000204  4622              MOV      r2,r4
000206  6aa1              LDR      r1,[r4,#0x28]
000208  6d20              LDR      r0,[r4,#0x50]
00020a  f7fffffe          BL       tcp_rst
                  |L33.526|
;;;990              pcb->local_port, pcb->remote_port);
;;;991          }
;;;992    
;;;993          err_fn = pcb->errf;
;;;994          err_arg = pcb->callback_arg;
;;;995          pcb2 = pcb;
00020e  4621              MOV      r1,r4
;;;996          pcb = pcb->next;
000210  f8d48010          LDR      r8,[r4,#0x10]
000214  f8d4508c          LDR      r5,[r4,#0x8c]
000218  68e4              LDR      r4,[r4,#0xc]
;;;997          memp_free(MEMP_TCP_PCB, pcb2);
00021a  2002              MOVS     r0,#2
00021c  f7fffffe          BL       memp_free
;;;998    	  TCP_DEBUG_USART_PRINTF_S("pcb_remove_1 -> memp_free(MEMP_TCP_PCB, pcb)\n");
;;;999          tcp_active_pcbs_changed = 0;
000220  f8879000          STRB     r9,[r7,#0]
;;;1000         TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
000224  b325              CBZ      r5,|L33.624|
000226  f06f0109          MVN      r1,#9
00022a  4640              MOV      r0,r8
00022c  47a8              BLX      r5
;;;1001         if (tcp_active_pcbs_changed) {
00022e  7838              LDRB     r0,[r7,#0]  ; tcp_active_pcbs_changed
000230  2800              CMP      r0,#0                 ;1000
                  |L33.562|
000232  f47faef2          BNE      |L33.26|
000236  e01b              B        |L33.624|
                  |L33.568|
000238  e7ff              B        |L33.570|
                  |L33.570|
;;;1002           goto tcp_slowtmr_start;
;;;1003         }
;;;1004       } else {
;;;1005         /* get the 'next' element now and work with 'prev' below (in case of abort) */
;;;1006         prev = pcb;
00023a  4626              MOV      r6,r4
;;;1007         pcb = pcb->next;
00023c  68e4              LDR      r4,[r4,#0xc]
;;;1008   
;;;1009         /* We check if we should poll the connection. */
;;;1010         ++prev->polltmr;
00023e  7ff0              LDRB     r0,[r6,#0x1f]
000240  1c40              ADDS     r0,r0,#1
000242  b2c0              UXTB     r0,r0
000244  77f0              STRB     r0,[r6,#0x1f]
;;;1011         if (prev->polltmr >= prev->pollinterval) {
000246  f8961020          LDRB     r1,[r6,#0x20]
00024a  4288              CMP      r0,r1
00024c  d310              BCC      |L33.624|
;;;1012           prev->polltmr = 0;
00024e  f886901f          STRB     r9,[r6,#0x1f]
;;;1013           LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
;;;1014           tcp_active_pcbs_changed = 0;
000252  f8879000          STRB     r9,[r7,#0]
;;;1015           TCP_EVENT_POLL(prev, err);
000256  f8d62088          LDR      r2,[r6,#0x88]
00025a  b132              CBZ      r2,|L33.618|
00025c  4631              MOV      r1,r6
00025e  6930              LDR      r0,[r6,#0x10]
000260  4790              BLX      r2
;;;1016           if (tcp_active_pcbs_changed) {
000262  7839              LDRB     r1,[r7,#0]  ; tcp_active_pcbs_changed
000264  2900              CMP      r1,#0                 ;1015
000266  d1e4              BNE      |L33.562|
;;;1017             goto tcp_slowtmr_start;
;;;1018           }
;;;1019           /* if err == ERR_ABRT, 'prev' is already deallocated */
;;;1020           if (err == ERR_OK) {
000268  b910              CBNZ     r0,|L33.624|
                  |L33.618|
;;;1021             tcp_output(prev);
00026a  4630              MOV      r0,r6
00026c  f7fffffe          BL       tcp_output
                  |L33.624|
000270  2c00              CMP      r4,#0                 ;832
000272  f47faed5          BNE      |L33.32|
;;;1022           }
;;;1023         }
;;;1024       }
;;;1025     }
;;;1026   
;;;1027     
;;;1028     /* Steps through all of the TIME-WAIT PCBs. */
;;;1029     prev = NULL;
000276  2500              MOVS     r5,#0
;;;1030     pcb = tcp_tw_pcbs;
;;;1031     while (pcb != NULL) {
000278  69fc              LDR      r4,[r7,#0x1c]  ; tcp_tw_pcbs
00027a  e026              B        |L33.714|
                  |L33.636|
;;;1032       LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
00027c  7e20              LDRB     r0,[r4,#0x18]
00027e  280a              CMP      r0,#0xa
000280  d002              BEQ      |L33.648|
000282  a050              ADR      r0,|L33.964|
000284  f7fffffe          BL       __2printf
                  |L33.648|
;;;1033       pcb_remove = 0;
;;;1034   
;;;1035       /* Check if this PCB has stayed long enough in TIME-WAIT */
;;;1036       if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
000288  6a60              LDR      r0,[r4,#0x24]
00028a  68f9              LDR      r1,[r7,#0xc]  ; tcp_ticks
00028c  1a08              SUBS     r0,r1,r0
00028e  280a              CMP      r0,#0xa
000290  d919              BLS      |L33.710|
;;;1037         ++pcb_remove;
;;;1038       }
;;;1039       
;;;1040   
;;;1041   
;;;1042       /* If the PCB should be removed, do it. */
;;;1043       if (pcb_remove) {
;;;1044         struct tcp_pcb *pcb2;
;;;1045         tcp_pcb_purge(pcb);
000292  4620              MOV      r0,r4
000294  f7fffffe          BL       tcp_pcb_purge
000298  69f8              LDR      r0,[r7,#0x1c]         ;1037  ; tcp_tw_pcbs
00029a  b13d              CBZ      r5,|L33.684|
;;;1046         /* Remove PCB from tcp_tw_pcbs list. */
;;;1047         if (prev != NULL) {
;;;1048           LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
00029c  4284              CMP      r4,r0
00029e  d102              BNE      |L33.678|
0002a0  a054              ADR      r0,|L33.1012|
0002a2  f7fffffe          BL       __2printf
                  |L33.678|
;;;1049           prev->next = pcb->next;
0002a6  68e0              LDR      r0,[r4,#0xc]
0002a8  60e8              STR      r0,[r5,#0xc]
0002aa  e006              B        |L33.698|
                  |L33.684|
;;;1050         } else {
;;;1051           /* This PCB was the first. */
;;;1052           LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
0002ac  42a0              CMP      r0,r4
0002ae  d002              BEQ      |L33.694|
0002b0  a05a              ADR      r0,|L33.1052|
0002b2  f7fffffe          BL       __2printf
                  |L33.694|
;;;1053           tcp_tw_pcbs = pcb->next;
0002b6  68e0              LDR      r0,[r4,#0xc]
0002b8  61f8              STR      r0,[r7,#0x1c]  ; tcp_tw_pcbs
                  |L33.698|
;;;1054         }
;;;1055         pcb2 = pcb;
;;;1056         pcb = pcb->next;
0002ba  4621              MOV      r1,r4
0002bc  68e4              LDR      r4,[r4,#0xc]
;;;1057         memp_free(MEMP_TCP_PCB, pcb2);
0002be  2002              MOVS     r0,#2
0002c0  f7fffffe          BL       memp_free
;;;1058   	  TCP_DEBUG_USART_PRINTF_S("pcb_remove_2 -> memp_free(MEMP_TCP_PCB, pcb)\n");
;;;1059       } else {
0002c4  e001              B        |L33.714|
                  |L33.710|
;;;1060         prev = pcb;
0002c6  4625              MOV      r5,r4
;;;1061         pcb = pcb->next;
0002c8  68e4              LDR      r4,[r4,#0xc]
                  |L33.714|
0002ca  2c00              CMP      r4,#0                 ;1031
0002cc  d1d6              BNE      |L33.636|
;;;1062       }
;;;1063     }
;;;1064   }
0002ce  e8bd87fc          POP      {r2-r10,pc}
;;;1065   
                          ENDP

0002d2  0000              DCW      0x0000
                  |L33.724|
                          DCD      ||.data||
                  |L33.728|
0002d8  7463705f          DCB      "tcp_slowtmr: active pcb->state != CLOSED\n",0
0002dc  736c6f77
0002e0  746d723a
0002e4  20616374
0002e8  69766520
0002ec  7063622d
0002f0  3e737461
0002f4  74652021
0002f8  3d20434c
0002fc  4f534544
000300  0a00    
000302  00                DCB      0
000303  00                DCB      0
                  |L33.772|
000304  7463705f          DCB      "tcp_slowtmr: active pcb->state != LISTEN\n",0
000308  736c6f77
00030c  746d723a
000310  20616374
000314  69766520
000318  7063622d
00031c  3e737461
000320  74652021
000324  3d204c49
000328  5354454e
00032c  0a00    
00032e  00                DCB      0
00032f  00                DCB      0
                  |L33.816|
000330  7463705f          DCB      "tcp_slowtmr: active pcb->state != TIME-WAIT\n",0
000334  736c6f77
000338  746d723a
00033c  20616374
000340  69766520
000344  7063622d
000348  3e737461
00034c  74652021
000350  3d205449
000354  4d452d57
000358  4149540a
00035c  00      
00035d  00                DCB      0
00035e  00                DCB      0
00035f  00                DCB      0
                  |L33.864|
                          DCD      ||.constdata||-0x1
                  |L33.868|
                          DCD      ||.constdata||+0x34
                  |L33.872|
                          DCD      0x000a4cb8
                  |L33.876|
00036c  7463705f          DCB      "tcp_slowtmr: middle tcp != tcp_active_pcbs",0
000370  736c6f77
000374  746d723a
000378  206d6964
00037c  646c6520
000380  74637020
000384  213d2074
000388  63705f61
00038c  63746976
000390  655f7063
000394  627300  
000397  00                DCB      0
                  |L33.920|
000398  7463705f          DCB      "tcp_slowtmr: first pcb == tcp_active_pcbs",0
00039c  736c6f77
0003a0  746d723a
0003a4  20666972
0003a8  73742070
0003ac  6362203d
0003b0  3d207463
0003b4  705f6163
0003b8  74697665
0003bc  5f706362
0003c0  7300    
0003c2  00                DCB      0
0003c3  00                DCB      0
                  |L33.964|
0003c4  7463705f          DCB      "tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT",0
0003c8  736c6f77
0003cc  746d723a
0003d0  2054494d
0003d4  452d5741
0003d8  49542070
0003dc  63622d3e
0003e0  73746174
0003e4  65203d3d
0003e8  2054494d
0003ec  452d5741
0003f0  495400  
0003f3  00                DCB      0
                  |L33.1012|
0003f4  7463705f          DCB      "tcp_slowtmr: middle tcp != tcp_tw_pcbs",0
0003f8  736c6f77
0003fc  746d723a
000400  206d6964
000404  646c6520
000408  74637020
00040c  213d2074
000410  63705f74
000414  775f7063
000418  627300  
00041b  00                DCB      0
                  |L33.1052|
00041c  7463705f          DCB      "tcp_slowtmr: first pcb == tcp_tw_pcbs",0
000420  736c6f77
000424  746d723a
000428  20666972
00042c  73742070
000430  6362203d
000434  3d207463
000438  705f7477
00043c  5f706362
000440  7300    
000442  00                DCB      0
000443  00                DCB      0

                          AREA ||i.tcp_tmr||, CODE, READONLY, ALIGN=2

                  tcp_tmr PROC
;;;140    void
;;;141    tcp_tmr(void)
000000  b510              PUSH     {r4,lr}
;;;142    {
;;;143      /* Call tcp_fasttmr() every 250 ms */
;;;144      tcp_fasttmr();
000002  f7fffffe          BL       tcp_fasttmr
;;;145    
;;;146      if (++tcp_timer & 1)
000006  4906              LDR      r1,|L34.32|
000008  7848              LDRB     r0,[r1,#1]  ; tcp_timer
00000a  1c40              ADDS     r0,r0,#1
00000c  7048              STRB     r0,[r1,#1]
00000e  07c0              LSLS     r0,r0,#31
000010  d005              BEQ      |L34.30|
;;;147      {
;;;148        /* Call tcp_tmr() every 500 ms, i.e., every other timer
;;;149           tcp_tmr() is called. */
;;;150    		tcp_timer = 0U;
000012  2000              MOVS     r0,#0
000014  7048              STRB     r0,[r1,#1]
;;;151    		tcp_slowtmr();
000016  e8bd4010          POP      {r4,lr}
00001a  f7ffbffe          B.W      tcp_slowtmr
                  |L34.30|
;;;152      }
;;;153    }
00001e  bd10              POP      {r4,pc}
;;;154    
                          ENDP

                  |L34.32|
                          DCD      ||.data||

                          AREA ||i.tcp_update_rcv_ann_wnd||, CODE, READONLY, ALIGN=2

                  tcp_update_rcv_ann_wnd PROC
;;;601     */
;;;602    u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;603    {
000002  4604              MOV      r4,r0
;;;604      u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
000004  8d85              LDRH     r5,[r0,#0x2c]
000006  6a81              LDR      r1,[r0,#0x28]
;;;605    
;;;606      if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
000008  8ee3              LDRH     r3,[r4,#0x36]
00000a  194a              ADDS     r2,r1,r5              ;604
00000c  6b00              LDR      r0,[r0,#0x30]
00000e  f44f66aa          MOV      r6,#0x550
000012  42b3              CMP      r3,r6
000014  d900              BLS      |L35.24|
000016  4633              MOV      r3,r6
                  |L35.24|
000018  4403              ADD      r3,r3,r0
00001a  1ad3              SUBS     r3,r2,r3
00001c  d402              BMI      |L35.36|
;;;607        /* we can advertise more window */
;;;608        pcb->rcv_ann_wnd = pcb->rcv_wnd;
00001e  85e5              STRH     r5,[r4,#0x2e]
;;;609        return new_right_edge - pcb->rcv_ann_right_edge;
000020  1a10              SUBS     r0,r2,r0
;;;610      } else {
;;;611        if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
;;;612          /* Can happen due to other end sending out of advertised window,
;;;613           * but within actual available (but not yet advertised) window */
;;;614          pcb->rcv_ann_wnd = 0;
;;;615        } else {
;;;616          /* keep the right edge of window constant */
;;;617          u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
;;;618          LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
;;;619          pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
;;;620        }
;;;621        return 0;
;;;622      }
;;;623    }
000022  bd70              POP      {r4-r6,pc}
                  |L35.36|
000024  1a0a              SUBS     r2,r1,r0              ;611
000026  2a00              CMP      r2,#0                 ;611
000028  dd02              BLE      |L35.48|
00002a  2000              MOVS     r0,#0                 ;614
00002c  85e0              STRH     r0,[r4,#0x2e]         ;614
00002e  e007              B        |L35.64|
                  |L35.48|
000030  1a45              SUBS     r5,r0,r1              ;617
000032  f5b53f80          CMP      r5,#0x10000           ;618
000036  d302              BCC      |L35.62|
000038  a002              ADR      r0,|L35.68|
00003a  f7fffffe          BL       __2printf
                  |L35.62|
00003e  85e5              STRH     r5,[r4,#0x2e]         ;619
                  |L35.64|
000040  2000              MOVS     r0,#0                 ;621
000042  bd70              POP      {r4-r6,pc}
;;;624    
                          ENDP

                  |L35.68|
000044  6e65775f          DCB      "new_rcv_ann_wnd <= 0xffff",0
000048  7263765f
00004c  616e6e5f
000050  776e6420
000054  3c3d2030
000058  78666666
00005c  6600    
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  tcp_persist_backoff
000000  03060c18          DCB      0x03,0x06,0x0c,0x18
000004  30607800          DCB      0x30,0x60,0x78,0x00
                  tcp_state_str
                          DCD      ||.conststring||
                          DCD      ||.conststring||+0x8
                          DCD      ||.conststring||+0x10
                          DCD      ||.conststring||+0x1c
                          DCD      ||.conststring||+0x28
                          DCD      ||.conststring||+0x34
                          DCD      ||.conststring||+0x40
                          DCD      ||.conststring||+0x4c
                          DCD      ||.conststring||+0x58
                          DCD      ||.conststring||+0x60
                          DCD      ||.conststring||+0x6c
                  tcp_backoff
000034  01020304          DCB      0x01,0x02,0x03,0x04
000038  05060707          DCB      0x05,0x06,0x07,0x07
00003c  07070707          DCB      0x07,0x07,0x07,0x07
000040  07000000          DCB      0x07,0x00,0x00,0x00
                  tcp_pcb_lists
                          DCD      tcp_listen_pcbs
                          DCD      tcp_bound_pcbs
                          DCD      tcp_active_pcbs
                          DCD      tcp_tw_pcbs

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  434c4f53          DCB      "CLOSED",0
000004  454400  
000007  00                DCB      0
000008  4c495354          DCB      "LISTEN",0
00000c  454e00  
00000f  00                DCB      0
000010  53594e5f          DCB      "SYN_SENT",0
000014  53454e54
000018  00      
000019  00                DCB      0
00001a  00                DCB      0
00001b  00                DCB      0
00001c  53594e5f          DCB      "SYN_RCVD",0
000020  52435644
000024  00      
000025  00                DCB      0
000026  00                DCB      0
000027  00                DCB      0
000028  45535441          DCB      "ESTABLISHED",0
00002c  424c4953
000030  48454400
000034  46494e5f          DCB      "FIN_WAIT_1",0
000038  57414954
00003c  5f3100  
00003f  00                DCB      0
000040  46494e5f          DCB      "FIN_WAIT_2",0
000044  57414954
000048  5f3200  
00004b  00                DCB      0
00004c  434c4f53          DCB      "CLOSE_WAIT",0
000050  455f5741
000054  495400  
000057  00                DCB      0
000058  434c4f53          DCB      "CLOSING",0
00005c  494e4700
000060  4c415354          DCB      "LAST_ACK",0
000064  5f41434b
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0
00006c  54494d45          DCB      "TIME_WAIT",0
000070  5f574149
000074  5400    

                          AREA ||.data||, DATA, ALIGN=2

                  tcp_active_pcbs_changed
000000  00                DCB      0x00
                  tcp_timer
000001  00                DCB      0x00
                  tcp_timer_ctr
000002  0000              DCB      0x00,0x00
                  tcp_port
000004  c000              DCW      0xc000
000006  0000              DCB      0x00,0x00
                  iss
                          DCD      0x0000196e
                  tcp_ticks
                          DCD      0x00000000
                  tcp_bound_pcbs
                          DCD      0x00000000
                  tcp_listen_pcbs
                          DCD      0x00000000
                  tcp_active_pcbs
                          DCD      0x00000000
                  tcp_tw_pcbs
                          DCD      0x00000000
                  tcp_tmp_pcb
                          DCD      0x00000000

L 1 "..\..\FreeRTOS\Source\tasks.c"
N/*
N    FreeRTOS V8.2.2 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N/* Standard includes. */
N#include <stdlib.h>
L 1 "d:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060019
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 72 "..\..\FreeRTOS\Source\tasks.c" 2
N#include <string.h>
L 1 "d:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060019
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 73 "..\..\FreeRTOS\Source\tasks.c" 2
N
N/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
Nall the API functions to use the MPU wrappers.  That should only be done when
Ntask.h is included from an application file. */
N#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
N
N/* FreeRTOS includes. */
N#include "FreeRTOS.h"
L 1 "..\..\FreeRTOS\Source\include\FreeRTOS.h" 1
N/*
N    FreeRTOS V8.2.2 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef INC_FREERTOS_H
N#define INC_FREERTOS_H
N
N/*
N * Include the generic headers required for the FreeRTOS port being used.
N */
N#include <stddef.h>
L 1 "d:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199901L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 77 "..\..\FreeRTOS\Source\include\FreeRTOS.h" 2
N
N/*
N * If stdint.h cannot be located then:
N *   + If using GCC ensure the -nostdint options is *not* being used.
N *   + Ensure the project's include path includes the directory in which your
N *     compiler stores stdint.h.
N *   + Set any compiler options necessary for it to support C99, as technically
N *     stdint.h is only mandatory with C99 (FreeRTOS does not require C99 in any
N *     other way).
N *   + The FreeRTOS download includes a simple stdint.h definition that can be
N *     used in cases where none is provided by the compiler.  The files only
N *     contains the typedefs required to build FreeRTOS.  Read the instructions
N *     in FreeRTOS/source/stdint.readme for more information.
N */
N#include <stdint.h> /* READ COMMENT ABOVE. */
L 1 "d:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 92 "..\..\FreeRTOS\Source\include\FreeRTOS.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Application specific configuration options. */
N#include "FreeRTOSConfig.h"
L 1 "..\..\FreeRTOS\FreeRTOSConfig.h" 1
N/*
N    FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
N    All rights reserved
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N    This file is part of the FreeRTOS distribution.
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N    1 tab == 4 spaces!
N*/
N 
N 
N#ifndef FREERTOS_CONFIG_H
N#define FREERTOS_CONFIG_H
N 
N/*-----------------------------------------------------------
N * Application specific definitions.
N *
N * These definitions should be adjusted for your particular hardware and
N * application requirements.
N *
N * THESE PARAMETERS ARE DESCRIBED WITHIN THE 'CONFIGURATION' SECTION OF THE
N * FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE.
N *
N * See http://www.freertos.org/a00110.html.
N *----------------------------------------------------------*/
N 
N/* Ensure stdint is only used by the compiler, and not the assembler. */
N#if defined(__ICCARM__) || defined(__CC_ARM) ||defined(__GUNC__)
X#if 0L || 1L ||0L
N#include <stdint.h>
Nextern uint32_t SystemCoreClock;
N#endif
N 
N#define configUSE_PREEMPTION			1
N#define configUSE_IDLE_HOOK				0
N#define configUSE_TICK_HOOK				0
N#define configCPU_CLOCK_HZ				( (uint32_t) 168000000)
N#define configTICK_RATE_HZ				( ( TickType_t ) 1000 )
N#define configMAX_PRIORITIES			( 5 )
N#define configMINIMAL_STACK_SIZE		( ( unsigned short ) 128 )
N#define configTOTAL_HEAP_SIZE			( ( size_t ) ( 20 * 1024 ) )
N#define configMAX_TASK_NAME_LEN			( 16 )
N#define configUSE_16_BIT_TICKS			0
N#define configIDLE_SHOULD_YIELD			1
N#define configUSE_MUTEXES				1
N//#define configQUEUE_REGISTRY_SIZE		8
N#define configCHECK_FOR_STACK_OVERFLOW	0
N//#define configUSE_RECURSIVE_MUTEXES		1
N#define configUSE_MALLOC_FAILED_HOOK	0
N//#define configUSE_APPLICATION_TASK_TAG	0
N#define configUSE_COUNTING_SEMAPHORES	1
N
N
N#define configGENERATE_RUN_TIME_STATS	0
N#define configUSE_TRACE_FACILITY		0
N#define configUSE_STATS_FORMATTING_FUNCTIONS 0
N#if freeRTOS_RUN_DEBUG
Sextern volatile uint64_t ulHighFrequencyTimerTicks ;
S#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()     (ulHighFrequencyTimerTicks = 0ul) 
S#define portGET_RUN_TIME_COUNTER_VALUE()             ulHighFrequencyTimerTicks
N#endif 
N
N/* Co-routine definitions. */
N#define configUSE_CO_ROUTINES 		0
N#define configMAX_CO_ROUTINE_PRIORITIES ( 2 )
N 
N 
N/* Set the following definitions to 1 to include the API function, or zero
Nto exclude the API function. */
N#define INCLUDE_vTaskPrioritySet		1
N#define INCLUDE_uxTaskPriorityGet		1
N#define INCLUDE_vTaskDelete				1
N#define INCLUDE_vTaskCleanUpResources	1
N#define INCLUDE_vTaskSuspend			1
N#define INCLUDE_vTaskDelayUntil			1
N#define INCLUDE_vTaskDelay				1
N 
N#define INCLUDE_xEventGroupSetBitsFromISR						1
N#define INCLUDE_xTimerPendFunctionCall							1
N 
N/* Cortex-M specific definitions. */
N#ifdef __NVIC_PRIO_BITS
S	/* __BVIC_PRIO_BITS will be specified when CMSIS is being used. */
S	#define configPRIO_BITS       		__NVIC_PRIO_BITS
N#else
N	#define configPRIO_BITS       		4        /* 15 priority levels */
N#endif
N 
N/* The lowest interrupt priority that can be used in a call to a "set priority"
Nfunction. */
N#define configLIBRARY_LOWEST_INTERRUPT_PRIORITY			0xf
N 
N/* The highest interrupt priority that can be used by any interrupt service
Nroutine that makes calls to interrupt safe FreeRTOS API functions.  DO NOT CALL
NINTERRUPT SAFE FREERTOS API FUNCTIONS FROM ANY INTERRUPT THAT HAS A HIGHER
NPRIORITY THAN THIS! (higher priorities are lower numeric values. */
N#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY	0x01// 1  15  FreeRTOS  API 
N 
N/* Interrupt priorities used by the kernel port layer itself.  These are generic
Nto all Cortex-M ports, and do not rely on any particular library functions. */
N#define configKERNEL_INTERRUPT_PRIORITY 		( configLIBRARY_LOWEST_INTERRUPT_PRIORITY << (8 - configPRIO_BITS) )
N/* !!!! configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero !!!!
NSee http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. */
N#define configMAX_SYSCALL_INTERRUPT_PRIORITY 	( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY << (8 - configPRIO_BITS) )
N	
N/* Normal assert() semantics without relying on the provision of an assert.h
Nheader file. */
N//#define configASSERT( x ) if( ( x ) == 0 ) { taskDISABLE_INTERRUPTS(); for( ;; ); }	
N 
N/* used by software timers */
N#define configUSE_TIMERS          0
N#define configSUPPORT_DYNAMIC_ALLOCATION 1
N#define configTIMER_TASK_PRIORITY  2
N#define configTIMER_QUEUE_LENGTH   10
N#define configTIMER_TASK_STACK_DEPTH        configMINIMAL_STACK_SIZE
N/* used by software timers */
N 
N	
N/* Definitions that map the FreeRTOS port interrupt handlers to their CMSIS
Nstandard names. */
N#define vPortSVCHandler SVC_Handler
N#define xPortPendSVHandler PendSV_Handler
N#define xPortSysTickHandler SysTick_Handler
N 
N#endif /* FREERTOS_CONFIG_H */
L 99 "..\..\FreeRTOS\Source\include\FreeRTOS.h" 2
N
N/* Basic FreeRTOS definitions. */
N#include "projdefs.h"
L 1 "..\..\FreeRTOS\Source\include\projdefs.h" 1
N/*
N    FreeRTOS V8.2.2 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef PROJDEFS_H
N#define PROJDEFS_H
N
N/*
N * Defines the prototype to which task functions must conform.  Defined in this
N * file to ensure the type is known before portable.h is included.
N */
Ntypedef void (*TaskFunction_t)( void * );
N
N/* Converts a time in milliseconds to a time in ticks. */
N#define pdMS_TO_TICKS( xTimeInMs ) ( ( TickType_t ) ( ( ( TickType_t ) ( xTimeInMs ) * ( TickType_t ) configTICK_RATE_HZ ) / ( TickType_t ) 1000 ) )
N
N#define pdFALSE			( ( BaseType_t ) 0 )
N#define pdTRUE			( ( BaseType_t ) 1 )
N
N#define pdPASS			( pdTRUE )
N#define pdFAIL			( pdFALSE )
N#define errQUEUE_EMPTY	( ( BaseType_t ) 0 )
N#define errQUEUE_FULL	( ( BaseType_t ) 0 )
N
N/* FreeRTOS error definitions. */
N#define errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY	( -1 )
N#define errQUEUE_BLOCKED						( -4 )
N#define errQUEUE_YIELD							( -5 )
N
N/* Macros used for basic data corruption checks. */
N#ifndef configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES
N	#define configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES 0
N#endif
N
N#if( configUSE_16_BIT_TICKS == 1 )
X#if( 0 == 1 )
S	#define pdINTEGRITY_CHECK_VALUE 0x5a5a
N#else
N	#define pdINTEGRITY_CHECK_VALUE 0x5a5a5a5aUL
N#endif
N
N/* The following errno values are used by FreeRTOS+ components, not FreeRTOS
Nitself. */
N#define pdFREERTOS_ERRNO_NONE			0	/* No errors */
N#define	pdFREERTOS_ERRNO_ENOENT			2	/* No such file or directory */
N#define	pdFREERTOS_ERRNO_EIO			5	/* I/O error */
N#define	pdFREERTOS_ERRNO_ENXIO			6	/* No such device or address */
N#define	pdFREERTOS_ERRNO_EBADF			9	/* Bad file number */
N#define	pdFREERTOS_ERRNO_EAGAIN			11	/* No more processes */
N#define	pdFREERTOS_ERRNO_EWOULDBLOCK	11	/* Operation would block */
N#define	pdFREERTOS_ERRNO_ENOMEM			12	/* Not enough memory */
N#define	pdFREERTOS_ERRNO_EACCES			13	/* Permission denied */
N#define	pdFREERTOS_ERRNO_EFAULT			14	/* Bad address */
N#define	pdFREERTOS_ERRNO_EBUSY			16	/* Mount device busy */
N#define	pdFREERTOS_ERRNO_EEXIST			17	/* File exists */
N#define	pdFREERTOS_ERRNO_EXDEV			18	/* Cross-device link */
N#define	pdFREERTOS_ERRNO_ENODEV			19	/* No such device */
N#define	pdFREERTOS_ERRNO_ENOTDIR		20	/* Not a directory */
N#define	pdFREERTOS_ERRNO_EISDIR			21	/* Is a directory */
N#define	pdFREERTOS_ERRNO_EINVAL			22	/* Invalid argument */
N#define	pdFREERTOS_ERRNO_ENOSPC			28	/* No space left on device */
N#define	pdFREERTOS_ERRNO_ESPIPE			29	/* Illegal seek */
N#define	pdFREERTOS_ERRNO_EROFS			30	/* Read only file system */
N#define	pdFREERTOS_ERRNO_EUNATCH		42	/* Protocol driver not attached */
N#define	pdFREERTOS_ERRNO_EBADE			50	/* Invalid exchange */
N#define	pdFREERTOS_ERRNO_EFTYPE			79	/* Inappropriate file type or format */
N#define	pdFREERTOS_ERRNO_ENMFILE		89	/* No more files */
N#define	pdFREERTOS_ERRNO_ENOTEMPTY		90	/* Directory not empty */
N#define	pdFREERTOS_ERRNO_ENAMETOOLONG 	91	/* File or path name too long */
N#define	pdFREERTOS_ERRNO_EOPNOTSUPP		95	/* Operation not supported on transport endpoint */
N#define	pdFREERTOS_ERRNO_ENOBUFS		105	/* No buffer space available */
N#define	pdFREERTOS_ERRNO_ENOPROTOOPT	109	/* Protocol not available */
N#define	pdFREERTOS_ERRNO_EADDRINUSE		112	/* Address already in use */
N#define	pdFREERTOS_ERRNO_ETIMEDOUT		116	/* Connection timed out */
N#define	pdFREERTOS_ERRNO_EINPROGRESS	119	/* Connection already in progress */
N#define	pdFREERTOS_ERRNO_EALREADY		120	/* Socket already connected */
N#define	pdFREERTOS_ERRNO_EADDRNOTAVAIL 	125	/* Address not available */
N#define	pdFREERTOS_ERRNO_EISCONN		127	/* Socket is already connected */
N#define	pdFREERTOS_ERRNO_ENOTCONN		128	/* Socket is not connected */
N#define	pdFREERTOS_ERRNO_ENOMEDIUM		135	/* No medium inserted */
N#define	pdFREERTOS_ERRNO_EILSEQ			138	/* An invalid UTF-16 sequence was encountered. */
N#define	pdFREERTOS_ERRNO_ECANCELED		140	/* Operation canceled. */
N
N/* The following endian values are used by FreeRTOS+ components, not FreeRTOS
Nitself. */
N#define pdFREERTOS_LITTLE_ENDIAN	0
N#define pdFREERTOS_BIG_ENDIAN		1
N
N#endif /* PROJDEFS_H */
N
N
N
L 102 "..\..\FreeRTOS\Source\include\FreeRTOS.h" 2
N
N/* Definitions specific to the port being used. */
N#include "portable.h"
L 1 "..\..\FreeRTOS\Source\include\portable.h" 1
N/*
N    FreeRTOS V8.2.2 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N/*-----------------------------------------------------------
N * Portable layer API.  Each function must be defined for each port.
N *----------------------------------------------------------*/
N
N#ifndef PORTABLE_H
N#define PORTABLE_H
N
N/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
Npre-processor definition was used to ensure the pre-processor found the correct
Nportmacro.h file for the port being used.  That scheme was deprecated in favour
Nof setting the compiler's include path such that it found the correct
Nportmacro.h file - removing the need for the constant and allowing the
Nportmacro.h file to be located anywhere in relation to the port being used.
NPurely for reasons of backward compatibility the old method is still valid, but
Nto make it clear that new projects should not use it, support for the port
Nspecific constants has been moved into the deprecated_definitions.h header
Nfile. */
N#include "deprecated_definitions.h"
L 1 "..\..\FreeRTOS\Source\include\deprecated_definitions.h" 1
N/*
N    FreeRTOS V8.2.2 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef DEPRECATED_DEFINITIONS_H
N#define DEPRECATED_DEFINITIONS_H
N
N
N/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
Npre-processor definition was used to ensure the pre-processor found the correct
Nportmacro.h file for the port being used.  That scheme was deprecated in favour
Nof setting the compiler's include path such that it found the correct
Nportmacro.h file - removing the need for the constant and allowing the
Nportmacro.h file to be located anywhere in relation to the port being used.  The
Ndefinitions below remain in the code for backward compatibility only.  New
Nprojects should not use them. */
N
N#ifdef OPEN_WATCOM_INDUSTRIAL_PC_PORT
S	#include "..\..\Source\portable\owatcom\16bitdos\pc\portmacro.h"
S	typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef OPEN_WATCOM_FLASH_LITE_186_PORT
S	#include "..\..\Source\portable\owatcom\16bitdos\flsh186\portmacro.h"
S	typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef GCC_MEGA_AVR
S	#include "../portable/GCC/ATMega323/portmacro.h"
N#endif
N
N#ifdef IAR_MEGA_AVR
S	#include "../portable/IAR/ATMega323/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC24_PORT
S	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
N#endif
N
N#ifdef MPLAB_DSPIC_PORT
S	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC18F_PORT
S	#include "../../Source/portable/MPLAB/PIC18F/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC32MX_PORT
S	#include "../../Source/portable/MPLAB/PIC32MX/portmacro.h"
N#endif
N
N#ifdef _FEDPICC
S	#include "libFreeRTOS/Include/portmacro.h"
N#endif
N
N#ifdef SDCC_CYGNAL
S	#include "../../Source/portable/SDCC/Cygnal/portmacro.h"
N#endif
N
N#ifdef GCC_ARM7
S	#include "../../Source/portable/GCC/ARM7_LPC2000/portmacro.h"
N#endif
N
N#ifdef GCC_ARM7_ECLIPSE
S	#include "portmacro.h"
N#endif
N
N#ifdef ROWLEY_LPC23xx
S	#include "../../Source/portable/GCC/ARM7_LPC23xx/portmacro.h"
N#endif
N
N#ifdef IAR_MSP430
S	#include "..\..\Source\portable\IAR\MSP430\portmacro.h"
N#endif
N
N#ifdef GCC_MSP430
S	#include "../../Source/portable/GCC/MSP430F449/portmacro.h"
N#endif
N
N#ifdef ROWLEY_MSP430
S	#include "../../Source/portable/Rowley/MSP430F449/portmacro.h"
N#endif
N
N#ifdef ARM7_LPC21xx_KEIL_RVDS
S	#include "..\..\Source\portable\RVDS\ARM7_LPC21xx\portmacro.h"
N#endif
N
N#ifdef SAM7_GCC
S	#include "../../Source/portable/GCC/ARM7_AT91SAM7S/portmacro.h"
N#endif
N
N#ifdef SAM7_IAR
S	#include "..\..\Source\portable\IAR\AtmelSAM7S64\portmacro.h"
N#endif
N
N#ifdef SAM9XE_IAR
S	#include "..\..\Source\portable\IAR\AtmelSAM9XE\portmacro.h"
N#endif
N
N#ifdef LPC2000_IAR
S	#include "..\..\Source\portable\IAR\LPC2000\portmacro.h"
N#endif
N
N#ifdef STR71X_IAR
S	#include "..\..\Source\portable\IAR\STR71x\portmacro.h"
N#endif
N
N#ifdef STR75X_IAR
S	#include "..\..\Source\portable\IAR\STR75x\portmacro.h"
N#endif
N
N#ifdef STR75X_GCC
S	#include "..\..\Source\portable\GCC\STR75x\portmacro.h"
N#endif
N
N#ifdef STR91X_IAR
S	#include "..\..\Source\portable\IAR\STR91x\portmacro.h"
N#endif
N
N#ifdef GCC_H8S
S	#include "../../Source/portable/GCC/H8S2329/portmacro.h"
N#endif
N
N#ifdef GCC_AT91FR40008
S	#include "../../Source/portable/GCC/ARM7_AT91FR40008/portmacro.h"
N#endif
N
N#ifdef RVDS_ARMCM3_LM3S102
S	#include "../../Source/portable/RVDS/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef GCC_ARMCM3_LM3S102
S	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef GCC_ARMCM3
S	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef IAR_ARM_CM3
S	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef IAR_ARMCM3_LM
S	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef HCS12_CODE_WARRIOR
S	#include "../../Source/portable/CodeWarrior/HCS12/portmacro.h"
N#endif
N
N#ifdef MICROBLAZE_GCC
S	#include "../../Source/portable/GCC/MicroBlaze/portmacro.h"
N#endif
N
N#ifdef TERN_EE
S	#include "..\..\Source\portable\Paradigm\Tern_EE\small\portmacro.h"
N#endif
N
N#ifdef GCC_HCS12
S	#include "../../Source/portable/GCC/HCS12/portmacro.h"
N#endif
N
N#ifdef GCC_MCF5235
S    #include "../../Source/portable/GCC/MCF5235/portmacro.h"
N#endif
N
N#ifdef COLDFIRE_V2_GCC
S	#include "../../../Source/portable/GCC/ColdFire_V2/portmacro.h"
N#endif
N
N#ifdef COLDFIRE_V2_CODEWARRIOR
S	#include "../../Source/portable/CodeWarrior/ColdFire_V2/portmacro.h"
N#endif
N
N#ifdef GCC_PPC405
S	#include "../../Source/portable/GCC/PPC405_Xilinx/portmacro.h"
N#endif
N
N#ifdef GCC_PPC440
S	#include "../../Source/portable/GCC/PPC440_Xilinx/portmacro.h"
N#endif
N
N#ifdef _16FX_SOFTUNE
S	#include "..\..\Source\portable\Softune\MB96340\portmacro.h"
N#endif
N
N#ifdef BCC_INDUSTRIAL_PC_PORT
S	/* A short file name has to be used in place of the normal
S	FreeRTOSConfig.h when using the Borland compiler. */
S	#include "frconfig.h"
S	#include "..\portable\BCC\16BitDOS\PC\prtmacro.h"
S    typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef BCC_FLASH_LITE_186_PORT
S	/* A short file name has to be used in place of the normal
S	FreeRTOSConfig.h when using the Borland compiler. */
S	#include "frconfig.h"
S	#include "..\portable\BCC\16BitDOS\flsh186\prtmacro.h"
S    typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef __GNUC__
S   #ifdef __AVR32_AVR32A__
S	   #include "portmacro.h"
S   #endif
N#endif
N
N#ifdef __ICCAVR32__
S   #ifdef __CORE__
S      #if __CORE__ == __AVR32A__
S	      #include "portmacro.h"
S      #endif
S   #endif
N#endif
N
N#ifdef __91467D
S	#include "portmacro.h"
N#endif
N
N#ifdef __96340
S	#include "portmacro.h"
N#endif
N
N
N#ifdef __IAR_V850ES_Fx3__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx3__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx3_L__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx2__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Hx2__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_78K0R_Kx3__
S	#include "../../Source/portable/IAR/78K0R/portmacro.h"
N#endif
N
N#ifdef __IAR_78K0R_Kx3L__
S	#include "../../Source/portable/IAR/78K0R/portmacro.h"
N#endif
N
N#endif /* DEPRECATED_DEFINITIONS_H */
N
L 88 "..\..\FreeRTOS\Source\include\portable.h" 2
N
N/* If portENTER_CRITICAL is not defined then including deprecated_definitions.h
Ndid not result in a portmacro.h header file being included - and it should be
Nincluded here.  In this case the path to the correct portmacro.h header file
Nmust be set in the compiler's include path. */
N#ifndef portENTER_CRITICAL
N	#include "portmacro.h"
L 1 "..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F\portmacro.h" 1
N/*
N    FreeRTOS V8.2.2 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef PORTMACRO_H
N#define PORTMACRO_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*-----------------------------------------------------------
N * Port specific definitions.
N *
N * The settings in this file configure FreeRTOS correctly for the
N * given hardware and compiler.
N *
N * These settings should not be altered.
N *-----------------------------------------------------------
N */
N
N/* Type definitions. */
N#define portCHAR		char
N#define portFLOAT		float
N#define portDOUBLE		double
N#define portLONG		long
N#define portSHORT		short
N#define portSTACK_TYPE	uint32_t
N#define portBASE_TYPE	long
N
Ntypedef portSTACK_TYPE StackType_t;
Xtypedef uint32_t StackType_t;
Ntypedef long BaseType_t;
Ntypedef unsigned long UBaseType_t;
N
N#if( configUSE_16_BIT_TICKS == 1 )
X#if( 0 == 1 )
S	typedef uint16_t TickType_t;
S	#define portMAX_DELAY ( TickType_t ) 0xffff
N#else
N	typedef uint32_t TickType_t;
N	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
N
N	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
N	not need to be guarded with a critical section. */
N	#define portTICK_TYPE_IS_ATOMIC 1
N#endif
N/*-----------------------------------------------------------*/
N
N/* Architecture specifics. */
N#define portSTACK_GROWTH			( -1 )
N#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
N#define portBYTE_ALIGNMENT			8
N
N/* Constants used with memory barrier intrinsics. */
N#define portSY_FULL_READ_WRITE		( 15 )
N
N/*-----------------------------------------------------------*/
N
N/* Scheduler utilities. */
N#define portYIELD()																\
N{																				\
N	/* Set a PendSV to request a context switch. */								\
N	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
N																				\
N	/* Barriers are normally not required but do ensure the code is completely	\
N	within the specified behaviour for the architecture. */						\
N	__dsb( portSY_FULL_READ_WRITE );											\
N	__isb( portSY_FULL_READ_WRITE );											\
N}
X#define portYIELD()																{																					 									portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;																													 							__dsb( portSY_FULL_READ_WRITE );												__isb( portSY_FULL_READ_WRITE );											}
N/*-----------------------------------------------------------*/
N
N#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
N#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
N#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
N#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
N/*-----------------------------------------------------------*/
N
N/* Critical section management. */
Nextern void vPortEnterCritical( void );
Nextern void vPortExitCritical( void );
N
N#define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
N#define portENABLE_INTERRUPTS()					vPortSetBASEPRI( 0 )
N#define portENTER_CRITICAL()					vPortEnterCritical()
N#define portEXIT_CRITICAL()						vPortExitCritical()
N#define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
N#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
N
N/*-----------------------------------------------------------*/
N
N/* Tickless idle/low power functionality. */
N#ifndef portSUPPRESS_TICKS_AND_SLEEP
N	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
N	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
N#endif
N/*-----------------------------------------------------------*/
N
N/* Port specific optimisations. */
N#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
N	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
N#endif
N
N#if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
X#if 1 == 1
N
N	/* Check the configuration. */
N	#if( configMAX_PRIORITIES > 32 )
X	#if( ( 5 ) > 32 )
S		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
N	#endif
N
N	/* Store/clear the ready priorities in a bit map. */
N	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
N	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
N
N	/*-----------------------------------------------------------*/
N
N	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31 - __clz( ( uxReadyPriorities ) ) )
N
N#endif /* taskRECORD_READY_PRIORITY */
N/*-----------------------------------------------------------*/
N
N/* Task function macros as described on the FreeRTOS.org WEB site.  These are
Nnot necessary for to use this port.  They are defined so the common demo files
N(which build with all the ports) will build. */
N#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
N#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
N/*-----------------------------------------------------------*/
N
N#ifdef configASSERT
S	void vPortValidateInterruptPriority( void );
S	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
N#endif
N
N/* portNOP() is not required by this port. */
N#define portNOP()
N
N#ifndef portFORCE_INLINE
N	#define portFORCE_INLINE __forceinline
N#endif
N
N/*-----------------------------------------------------------*/
N
Nstatic portFORCE_INLINE void vPortSetBASEPRI( uint32_t ulBASEPRI )
Xstatic __forceinline void vPortSetBASEPRI( uint32_t ulBASEPRI )
N{
N	__asm
N	{
N		/* Barrier instructions are not used as this function is only used to
N		lower the BASEPRI value. */
N		msr basepri, ulBASEPRI
N	}
N}
N/*-----------------------------------------------------------*/
N
Nstatic portFORCE_INLINE void vPortRaiseBASEPRI( void )
Xstatic __forceinline void vPortRaiseBASEPRI( void )
N{
Nuint32_t ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;
Xuint32_t ulNewBASEPRI = ( 0x01 << (8 - 4) );
N
N	__asm
N	{
N		/* Set BASEPRI to the max syscall priority to effect a critical
N		section. */
N		msr basepri, ulNewBASEPRI
N		dsb
N		isb
N	}
N}
N/*-----------------------------------------------------------*/
N
Nstatic portFORCE_INLINE uint32_t ulPortRaiseBASEPRI( void )
Xstatic __forceinline uint32_t ulPortRaiseBASEPRI( void )
N{
Nuint32_t ulReturn, ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;
Xuint32_t ulReturn, ulNewBASEPRI = ( 0x01 << (8 - 4) );
N
N	__asm
N	{
N		/* Set BASEPRI to the max syscall priority to effect a critical
N		section. */
N		mrs ulReturn, basepri
N		msr basepri, ulNewBASEPRI
N		dsb
N		isb
N	}
N
N	return ulReturn;
N}
N/*-----------------------------------------------------------*/
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* PORTMACRO_H */
N
L 95 "..\..\FreeRTOS\Source\include\portable.h" 2
N#endif
N
N#if portBYTE_ALIGNMENT == 32
X#if 8 == 32
S	#define portBYTE_ALIGNMENT_MASK ( 0x001f )
N#endif
N
N#if portBYTE_ALIGNMENT == 16
X#if 8 == 16
S	#define portBYTE_ALIGNMENT_MASK ( 0x000f )
N#endif
N
N#if portBYTE_ALIGNMENT == 8
X#if 8 == 8
N	#define portBYTE_ALIGNMENT_MASK ( 0x0007 )
N#endif
N
N#if portBYTE_ALIGNMENT == 4
X#if 8 == 4
S	#define portBYTE_ALIGNMENT_MASK	( 0x0003 )
N#endif
N
N#if portBYTE_ALIGNMENT == 2
X#if 8 == 2
S	#define portBYTE_ALIGNMENT_MASK	( 0x0001 )
N#endif
N
N#if portBYTE_ALIGNMENT == 1
X#if 8 == 1
S	#define portBYTE_ALIGNMENT_MASK	( 0x0000 )
N#endif
N
N#ifndef portBYTE_ALIGNMENT_MASK
S	#error "Invalid portBYTE_ALIGNMENT definition"
N#endif
N
N#ifndef portNUM_CONFIGURABLE_REGIONS
N	#define portNUM_CONFIGURABLE_REGIONS 1
N#endif
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "mpu_wrappers.h"
L 1 "..\..\FreeRTOS\Source\include\mpu_wrappers.h" 1
N/*
N    FreeRTOS V8.2.2 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef MPU_WRAPPERS_H
N#define MPU_WRAPPERS_H
N
N/* This file redefines API functions to be called through a wrapper macro, but
Nonly for ports that are using the MPU. */
N#ifdef portUSING_MPU_WRAPPERS
S
S	/* MPU_WRAPPERS_INCLUDED_FROM_API_FILE will be defined when this file is
S	included from queue.c or task.c to prevent it from having an effect within
S	those files. */
S	#ifndef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
S
S		#define xTaskGenericCreate				MPU_xTaskGenericCreate
S		#define vTaskAllocateMPURegions			MPU_vTaskAllocateMPURegions
S		#define vTaskDelete						MPU_vTaskDelete
S		#define vTaskDelayUntil					MPU_vTaskDelayUntil
S		#define vTaskDelay						MPU_vTaskDelay
S		#define uxTaskPriorityGet				MPU_uxTaskPriorityGet
S		#define vTaskPrioritySet				MPU_vTaskPrioritySet
S		#define eTaskGetState					MPU_eTaskGetState
S		#define vTaskSuspend					MPU_vTaskSuspend
S		#define vTaskResume						MPU_vTaskResume
S		#define vTaskSuspendAll					MPU_vTaskSuspendAll
S		#define xTaskResumeAll					MPU_xTaskResumeAll
S		#define xTaskGetTickCount				MPU_xTaskGetTickCount
S		#define uxTaskGetNumberOfTasks			MPU_uxTaskGetNumberOfTasks
S		#define vTaskList						MPU_vTaskList
S		#define vTaskGetRunTimeStats			MPU_vTaskGetRunTimeStats
S		#define vTaskSetApplicationTaskTag		MPU_vTaskSetApplicationTaskTag
S		#define xTaskGetApplicationTaskTag		MPU_xTaskGetApplicationTaskTag
S		#define xTaskCallApplicationTaskHook	MPU_xTaskCallApplicationTaskHook
S		#define uxTaskGetStackHighWaterMark		MPU_uxTaskGetStackHighWaterMark
S		#define xTaskGetCurrentTaskHandle		MPU_xTaskGetCurrentTaskHandle
S		#define xTaskGetSchedulerState			MPU_xTaskGetSchedulerState
S		#define xTaskGetIdleTaskHandle			MPU_xTaskGetIdleTaskHandle
S		#define uxTaskGetSystemState			MPU_uxTaskGetSystemState
S		#define xTaskGenericNotify				MPU_xTaskGenericNotify
S		#define xTaskNotifyWait					MPU_xTaskNotifyWait
S		#define ulTaskNotifyTake				MPU_ulTaskNotifyTake
S
S		#define xQueueGenericCreate				MPU_xQueueGenericCreate
S		#define xQueueCreateMutex				MPU_xQueueCreateMutex
S		#define xQueueGiveMutexRecursive		MPU_xQueueGiveMutexRecursive
S		#define xQueueTakeMutexRecursive		MPU_xQueueTakeMutexRecursive
S		#define xQueueCreateCountingSemaphore	MPU_xQueueCreateCountingSemaphore
S		#define xQueueGenericSend				MPU_xQueueGenericSend
S		#define xQueueAltGenericSend			MPU_xQueueAltGenericSend
S		#define xQueueAltGenericReceive			MPU_xQueueAltGenericReceive
S		#define xQueueGenericReceive			MPU_xQueueGenericReceive
S		#define uxQueueMessagesWaiting			MPU_uxQueueMessagesWaiting
S		#define vQueueDelete					MPU_vQueueDelete
S		#define xQueueGenericReset				MPU_xQueueGenericReset
S		#define xQueueCreateSet					MPU_xQueueCreateSet
S		#define xQueueSelectFromSet				MPU_xQueueSelectFromSet
S		#define xQueueAddToSet					MPU_xQueueAddToSet
S		#define xQueueRemoveFromSet				MPU_xQueueRemoveFromSet
S		#define xQueueGetMutexHolder			MPU_xQueueGetMutexHolder
S		#define xQueueGetMutexHolder			MPU_xQueueGetMutexHolder
S
S		#define pvPortMalloc					MPU_pvPortMalloc
S		#define vPortFree						MPU_vPortFree
S		#define xPortGetFreeHeapSize			MPU_xPortGetFreeHeapSize
S		#define vPortInitialiseBlocks			MPU_vPortInitialiseBlocks
S		#define xPortGetMinimumEverFreeHeapSize	MPU_xPortGetMinimumEverFreeHeapSize
S
S		#if configQUEUE_REGISTRY_SIZE > 0
S			#define vQueueAddToRegistry				MPU_vQueueAddToRegistry
S			#define vQueueUnregisterQueue			MPU_vQueueUnregisterQueue
S		#endif
S
S		#define xTimerCreate					MPU_xTimerCreate
S		#define pvTimerGetTimerID				MPU_pvTimerGetTimerID
S		#define vTimerSetTimerID				MPU_vTimerSetTimerID
S		#define xTimerIsTimerActive				MPU_xTimerIsTimerActive
S		#define xTimerGetTimerDaemonTaskHandle	MPU_xTimerGetTimerDaemonTaskHandle
S		#define xTimerPendFunctionCall			MPU_xTimerPendFunctionCall
S		#define pcTimerGetTimerName				MPU_pcTimerGetTimerName
S		#define xTimerGenericCommand			MPU_xTimerGenericCommand
S
S		#define xEventGroupCreate				MPU_xEventGroupCreate
S		#define xEventGroupWaitBits				MPU_xEventGroupWaitBits
S		#define xEventGroupClearBits			MPU_xEventGroupClearBits
S		#define xEventGroupSetBits				MPU_xEventGroupSetBits
S		#define xEventGroupSync					MPU_xEventGroupSync
S		#define vEventGroupDelete				MPU_vEventGroupDelete
S
S		/* Remove the privileged function macro. */
S		#define PRIVILEGED_FUNCTION
S
S	#else /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
S
S		/* Ensure API functions go in the privileged execution section. */
S		#define PRIVILEGED_FUNCTION __attribute__((section("privileged_functions")))
S		#define PRIVILEGED_DATA __attribute__((section("privileged_data")))
S
S	#endif /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
S
N#else /* portUSING_MPU_WRAPPERS */
N
N	#define PRIVILEGED_FUNCTION
N	#define PRIVILEGED_DATA
N	#define portUSING_MPU_WRAPPERS 0
N
N#endif /* portUSING_MPU_WRAPPERS */
N
N
N#endif /* MPU_WRAPPERS_H */
N
L 134 "..\..\FreeRTOS\Source\include\portable.h" 2
N
N/*
N * Setup the stack of a new task so it is ready to be placed under the
N * scheduler control.  The registers have to be placed on the stack in
N * the order that the port expects to find them.
N *
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged ) PRIVILEGED_FUNCTION;
N#else
N	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) PRIVILEGED_FUNCTION;
X	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) ;
N#endif
N
N/* Used by heap_5.c. */
Ntypedef struct HeapRegion
N{
N	uint8_t *pucStartAddress;
N	size_t xSizeInBytes;
N} HeapRegion_t;
N
N/*
N * Used to define multiple heap regions for use by heap_5.c.  This function
N * must be called before any calls to pvPortMalloc() - not creating a task,
N * queue, semaphore, mutex, software timer, event group, etc. will result in
N * pvPortMalloc being called.
N *
N * pxHeapRegions passes in an array of HeapRegion_t structures - each of which
N * defines a region of memory that can be used as the heap.  The array is
N * terminated by a HeapRegions_t structure that has a size of 0.  The region
N * with the lowest start address must appear first in the array.
N */
Nvoid vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) PRIVILEGED_FUNCTION;
Xvoid vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) ;
N
N
N/*
N * Map to the memory management routines required for the port.
N */
Nvoid *pvPortMalloc( size_t xSize ) PRIVILEGED_FUNCTION;
Xvoid *pvPortMalloc( size_t xSize ) ;
Nvoid vPortFree( void *pv ) PRIVILEGED_FUNCTION;
Xvoid vPortFree( void *pv ) ;
Nvoid vPortInitialiseBlocks( void ) PRIVILEGED_FUNCTION;
Xvoid vPortInitialiseBlocks( void ) ;
Nsize_t xPortGetFreeHeapSize( void ) PRIVILEGED_FUNCTION;
Xsize_t xPortGetFreeHeapSize( void ) ;
Nsize_t xPortGetMinimumEverFreeHeapSize( void ) PRIVILEGED_FUNCTION;
Xsize_t xPortGetMinimumEverFreeHeapSize( void ) ;
N
N/*
N * Setup the hardware ready for the scheduler to take control.  This generally
N * sets up a tick interrupt and sets timers for the correct tick frequency.
N */
NBaseType_t xPortStartScheduler( void ) PRIVILEGED_FUNCTION;
XBaseType_t xPortStartScheduler( void ) ;
N
N/*
N * Undo any hardware/ISR setup that was performed by xPortStartScheduler() so
N * the hardware is left in its original condition after the scheduler stops
N * executing.
N */
Nvoid vPortEndScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vPortEndScheduler( void ) ;
N
N/*
N * The structures and methods of manipulating the MPU are contained within the
N * port layer.
N *
N * Fills the xMPUSettings structure with the memory region information
N * contained in xRegions.
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	struct xMEMORY_REGION;
S	void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint16_t usStackDepth ) PRIVILEGED_FUNCTION;
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* PORTABLE_H */
N
L 105 "..\..\FreeRTOS\Source\include\FreeRTOS.h" 2
N
N/*
N * Check all the required application specific macros have been defined.
N * These macros are application specific and (as downloaded) are defined
N * within FreeRTOSConfig.h.
N */
N
N#ifndef configMINIMAL_STACK_SIZE
S	#error Missing definition:  configMINIMAL_STACK_SIZE must be defined in FreeRTOSConfig.h.  configMINIMAL_STACK_SIZE defines the size (in words) of the stack allocated to the idle task.  Refer to the demo project provided for your port for a suitable value.
N#endif
N
N#ifndef configMAX_PRIORITIES
S	#error Missing definition:  configMAX_PRIORITIES must be defined in FreeRTOSConfig.h.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_PREEMPTION
S	#error Missing definition:  configUSE_PREEMPTION must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_IDLE_HOOK
S	#error Missing definition:  configUSE_IDLE_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_TICK_HOOK
S	#error Missing definition:  configUSE_TICK_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_vTaskPrioritySet
S	#error Missing definition:  INCLUDE_vTaskPrioritySet must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_uxTaskPriorityGet
S	#error Missing definition:  INCLUDE_uxTaskPriorityGet must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_vTaskDelete
S	#error Missing definition:  INCLUDE_vTaskDelete must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_vTaskSuspend
S	#error Missing definition:  INCLUDE_vTaskSuspend must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_vTaskDelayUntil
S	#error Missing definition:  INCLUDE_vTaskDelayUntil must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_vTaskDelay
S	#error Missing definition:  INCLUDE_vTaskDelay must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_16_BIT_TICKS
S	#error Missing definition:  configUSE_16_BIT_TICKS must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configMAX_PRIORITIES
S	#error configMAX_PRIORITIES must be defined to be greater than or equal to 1.
N#endif
N
N#ifndef configUSE_CO_ROUTINES
S	#define configUSE_CO_ROUTINES 0
N#endif
N
N#if configUSE_CO_ROUTINES != 0
X#if 0 != 0
S	#ifndef configMAX_CO_ROUTINE_PRIORITIES
S		#error configMAX_CO_ROUTINE_PRIORITIES must be greater than or equal to 1.
S	#endif
N#endif
N
N#ifndef INCLUDE_xTaskGetIdleTaskHandle
N	#define INCLUDE_xTaskGetIdleTaskHandle 0
N#endif
N
N#ifndef INCLUDE_xTimerGetTimerDaemonTaskHandle
N	#define INCLUDE_xTimerGetTimerDaemonTaskHandle 0
N#endif
N
N#ifndef INCLUDE_xQueueGetMutexHolder
N	#define INCLUDE_xQueueGetMutexHolder 0
N#endif
N
N#ifndef INCLUDE_xSemaphoreGetMutexHolder
N	#define INCLUDE_xSemaphoreGetMutexHolder INCLUDE_xQueueGetMutexHolder
N#endif
N
N#ifndef INCLUDE_pcTaskGetTaskName
N	#define INCLUDE_pcTaskGetTaskName 0
N#endif
N
N#ifndef configUSE_APPLICATION_TASK_TAG
N	#define configUSE_APPLICATION_TASK_TAG 0
N#endif
N
N#ifndef configNUM_THREAD_LOCAL_STORAGE_POINTERS
N	#define configNUM_THREAD_LOCAL_STORAGE_POINTERS 0
N#endif
N
N#ifndef INCLUDE_uxTaskGetStackHighWaterMark
N	#define INCLUDE_uxTaskGetStackHighWaterMark 0
N#endif
N
N#ifndef INCLUDE_eTaskGetState
N	#define INCLUDE_eTaskGetState 0
N#endif
N
N#ifndef configUSE_RECURSIVE_MUTEXES
N	#define configUSE_RECURSIVE_MUTEXES 0
N#endif
N
N#ifndef configUSE_MUTEXES
S	#define configUSE_MUTEXES 0
N#endif
N
N#ifndef configUSE_TIMERS
S	#define configUSE_TIMERS 0
N#endif
N
N#ifndef configUSE_COUNTING_SEMAPHORES
S	#define configUSE_COUNTING_SEMAPHORES 0
N#endif
N
N#ifndef configUSE_ALTERNATIVE_API
N	#define configUSE_ALTERNATIVE_API 0
N#endif
N
N#ifndef portCRITICAL_NESTING_IN_TCB
N	#define portCRITICAL_NESTING_IN_TCB 0
N#endif
N
N#ifndef configMAX_TASK_NAME_LEN
S	#define configMAX_TASK_NAME_LEN 16
N#endif
N
N#ifndef configIDLE_SHOULD_YIELD
S	#define configIDLE_SHOULD_YIELD		1
N#endif
N
N#if configMAX_TASK_NAME_LEN < 1
X#if ( 16 ) < 1
S	#error configMAX_TASK_NAME_LEN must be set to a minimum of 1 in FreeRTOSConfig.h
N#endif
N
N#ifndef INCLUDE_xTaskResumeFromISR
N	#define INCLUDE_xTaskResumeFromISR 1
N#endif
N
N#ifndef INCLUDE_xEventGroupSetBitFromISR
N	#define INCLUDE_xEventGroupSetBitFromISR 0
N#endif
N
N#ifndef INCLUDE_xTimerPendFunctionCall
S	#define INCLUDE_xTimerPendFunctionCall 0
N#endif
N
N#ifndef configASSERT
N	#define configASSERT( x )
N	#define configASSERT_DEFINED 0
N#else
S	#define configASSERT_DEFINED 1
N#endif
N
N/* The timers module relies on xTaskGetSchedulerState(). */
N#if configUSE_TIMERS == 1
X#if 0 == 1
S
S	#ifndef configTIMER_TASK_PRIORITY
S		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_PRIORITY must also be defined.
S	#endif /* configTIMER_TASK_PRIORITY */
S
S	#ifndef configTIMER_QUEUE_LENGTH
S		#error If configUSE_TIMERS is set to 1 then configTIMER_QUEUE_LENGTH must also be defined.
S	#endif /* configTIMER_QUEUE_LENGTH */
S
S	#ifndef configTIMER_TASK_STACK_DEPTH
S		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_STACK_DEPTH must also be defined.
S	#endif /* configTIMER_TASK_STACK_DEPTH */
S
N#endif /* configUSE_TIMERS */
N
N#ifndef INCLUDE_xTaskGetSchedulerState
N	#define INCLUDE_xTaskGetSchedulerState 0
N#endif
N
N#ifndef INCLUDE_xTaskGetCurrentTaskHandle
N	#define INCLUDE_xTaskGetCurrentTaskHandle 0
N#endif
N
N
N#ifndef portSET_INTERRUPT_MASK_FROM_ISR
S	#define portSET_INTERRUPT_MASK_FROM_ISR() 0
N#endif
N
N#ifndef portCLEAR_INTERRUPT_MASK_FROM_ISR
S	#define portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedStatusValue ) ( void ) uxSavedStatusValue
N#endif
N
N#ifndef portCLEAN_UP_TCB
N	#define portCLEAN_UP_TCB( pxTCB ) ( void ) pxTCB
N#endif
N
N#ifndef portPRE_TASK_DELETE_HOOK
N	#define portPRE_TASK_DELETE_HOOK( pvTaskToDelete, pxYieldPending )
N#endif
N
N#ifndef portSETUP_TCB
N	#define portSETUP_TCB( pxTCB ) ( void ) pxTCB
N#endif
N
N#ifndef configQUEUE_REGISTRY_SIZE
N	#define configQUEUE_REGISTRY_SIZE 0U
N#endif
N
N#if ( configQUEUE_REGISTRY_SIZE < 1 )
X#if ( 0U < 1 )
N	#define vQueueAddToRegistry( xQueue, pcName )
N	#define vQueueUnregisterQueue( xQueue )
N#endif
N
N#ifndef portPOINTER_SIZE_TYPE
N	#define portPOINTER_SIZE_TYPE uint32_t
N#endif
N
N/* Remove any unused trace macros. */
N#ifndef traceSTART
N	/* Used to perform any necessary initialisation - for example, open a file
N	into which trace is to be written. */
N	#define traceSTART()
N#endif
N
N#ifndef traceEND
N	/* Use to close a trace, for example close a file into which trace has been
N	written. */
N	#define traceEND()
N#endif
N
N#ifndef traceTASK_SWITCHED_IN
N	/* Called after a task has been selected to run.  pxCurrentTCB holds a pointer
N	to the task control block of the selected task. */
N	#define traceTASK_SWITCHED_IN()
N#endif
N
N#ifndef traceINCREASE_TICK_COUNT
N	/* Called before stepping the tick count after waking from tickless idle
N	sleep. */
N	#define traceINCREASE_TICK_COUNT( x )
N#endif
N
N#ifndef traceLOW_POWER_IDLE_BEGIN
N	/* Called immediately before entering tickless idle. */
N	#define traceLOW_POWER_IDLE_BEGIN()
N#endif
N
N#ifndef	traceLOW_POWER_IDLE_END
N	/* Called when returning to the Idle task after a tickless idle. */
N	#define traceLOW_POWER_IDLE_END()
N#endif
N
N#ifndef traceTASK_SWITCHED_OUT
N	/* Called before a task has been selected to run.  pxCurrentTCB holds a pointer
N	to the task control block of the task being switched out. */
N	#define traceTASK_SWITCHED_OUT()
N#endif
N
N#ifndef traceTASK_PRIORITY_INHERIT
N	/* Called when a task attempts to take a mutex that is already held by a
N	lower priority task.  pxTCBOfMutexHolder is a pointer to the TCB of the task
N	that holds the mutex.  uxInheritedPriority is the priority the mutex holder
N	will inherit (the priority of the task that is attempting to obtain the
N	muted. */
N	#define traceTASK_PRIORITY_INHERIT( pxTCBOfMutexHolder, uxInheritedPriority )
N#endif
N
N#ifndef traceTASK_PRIORITY_DISINHERIT
N	/* Called when a task releases a mutex, the holding of which had resulted in
N	the task inheriting the priority of a higher priority task.
N	pxTCBOfMutexHolder is a pointer to the TCB of the task that is releasing the
N	mutex.  uxOriginalPriority is the task's configured (base) priority. */
N	#define traceTASK_PRIORITY_DISINHERIT( pxTCBOfMutexHolder, uxOriginalPriority )
N#endif
N
N#ifndef traceBLOCKING_ON_QUEUE_RECEIVE
N	/* Task is about to block because it cannot read from a
N	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
N	upon which the read was attempted.  pxCurrentTCB points to the TCB of the
N	task that attempted the read. */
N	#define traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue )
N#endif
N
N#ifndef traceBLOCKING_ON_QUEUE_SEND
N	/* Task is about to block because it cannot write to a
N	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
N	upon which the write was attempted.  pxCurrentTCB points to the TCB of the
N	task that attempted the write. */
N	#define traceBLOCKING_ON_QUEUE_SEND( pxQueue )
N#endif
N
N#ifndef configCHECK_FOR_STACK_OVERFLOW
S	#define configCHECK_FOR_STACK_OVERFLOW 0
N#endif
N
N/* The following event macros are embedded in the kernel API calls. */
N
N#ifndef traceMOVED_TASK_TO_READY_STATE
N	#define traceMOVED_TASK_TO_READY_STATE( pxTCB )
N#endif
N
N#ifndef traceQUEUE_CREATE
N	#define traceQUEUE_CREATE( pxNewQueue )
N#endif
N
N#ifndef traceQUEUE_CREATE_FAILED
N	#define traceQUEUE_CREATE_FAILED( ucQueueType )
N#endif
N
N#ifndef traceCREATE_MUTEX
N	#define traceCREATE_MUTEX( pxNewQueue )
N#endif
N
N#ifndef traceCREATE_MUTEX_FAILED
N	#define traceCREATE_MUTEX_FAILED()
N#endif
N
N#ifndef traceGIVE_MUTEX_RECURSIVE
N	#define traceGIVE_MUTEX_RECURSIVE( pxMutex )
N#endif
N
N#ifndef traceGIVE_MUTEX_RECURSIVE_FAILED
N	#define traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex )
N#endif
N
N#ifndef traceTAKE_MUTEX_RECURSIVE
N	#define traceTAKE_MUTEX_RECURSIVE( pxMutex )
N#endif
N
N#ifndef traceTAKE_MUTEX_RECURSIVE_FAILED
N	#define traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex )
N#endif
N
N#ifndef traceCREATE_COUNTING_SEMAPHORE
N	#define traceCREATE_COUNTING_SEMAPHORE()
N#endif
N
N#ifndef traceCREATE_COUNTING_SEMAPHORE_FAILED
N	#define traceCREATE_COUNTING_SEMAPHORE_FAILED()
N#endif
N
N#ifndef traceQUEUE_SEND
N	#define traceQUEUE_SEND( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FAILED
N	#define traceQUEUE_SEND_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE
N	#define traceQUEUE_RECEIVE( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK
N	#define traceQUEUE_PEEK( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK_FROM_ISR
N	#define traceQUEUE_PEEK_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FAILED
N	#define traceQUEUE_RECEIVE_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FROM_ISR
N	#define traceQUEUE_SEND_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FROM_ISR_FAILED
N	#define traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FROM_ISR
N	#define traceQUEUE_RECEIVE_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FROM_ISR_FAILED
N	#define traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK_FROM_ISR_FAILED
N	#define traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_DELETE
N	#define traceQUEUE_DELETE( pxQueue )
N#endif
N
N#ifndef traceTASK_CREATE
N	#define traceTASK_CREATE( pxNewTCB )
N#endif
N
N#ifndef traceTASK_CREATE_FAILED
N	#define traceTASK_CREATE_FAILED()
N#endif
N
N#ifndef traceTASK_DELETE
N	#define traceTASK_DELETE( pxTaskToDelete )
N#endif
N
N#ifndef traceTASK_DELAY_UNTIL
N	#define traceTASK_DELAY_UNTIL()
N#endif
N
N#ifndef traceTASK_DELAY
N	#define traceTASK_DELAY()
N#endif
N
N#ifndef traceTASK_PRIORITY_SET
N	#define traceTASK_PRIORITY_SET( pxTask, uxNewPriority )
N#endif
N
N#ifndef traceTASK_SUSPEND
N	#define traceTASK_SUSPEND( pxTaskToSuspend )
N#endif
N
N#ifndef traceTASK_RESUME
N	#define traceTASK_RESUME( pxTaskToResume )
N#endif
N
N#ifndef traceTASK_RESUME_FROM_ISR
N	#define traceTASK_RESUME_FROM_ISR( pxTaskToResume )
N#endif
N
N#ifndef traceTASK_INCREMENT_TICK
N	#define traceTASK_INCREMENT_TICK( xTickCount )
N#endif
N
N#ifndef traceTIMER_CREATE
N	#define traceTIMER_CREATE( pxNewTimer )
N#endif
N
N#ifndef traceTIMER_CREATE_FAILED
N	#define traceTIMER_CREATE_FAILED()
N#endif
N
N#ifndef traceTIMER_COMMAND_SEND
N	#define traceTIMER_COMMAND_SEND( xTimer, xMessageID, xMessageValueValue, xReturn )
N#endif
N
N#ifndef traceTIMER_EXPIRED
N	#define traceTIMER_EXPIRED( pxTimer )
N#endif
N
N#ifndef traceTIMER_COMMAND_RECEIVED
N	#define traceTIMER_COMMAND_RECEIVED( pxTimer, xMessageID, xMessageValue )
N#endif
N
N#ifndef traceMALLOC
N    #define traceMALLOC( pvAddress, uiSize )
N#endif
N
N#ifndef traceFREE
N    #define traceFREE( pvAddress, uiSize )
N#endif
N
N#ifndef traceEVENT_GROUP_CREATE
N	#define traceEVENT_GROUP_CREATE( xEventGroup )
N#endif
N
N#ifndef traceEVENT_GROUP_CREATE_FAILED
N	#define traceEVENT_GROUP_CREATE_FAILED()
N#endif
N
N#ifndef traceEVENT_GROUP_SYNC_BLOCK
N	#define traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor )
N#endif
N
N#ifndef traceEVENT_GROUP_SYNC_END
N	#define traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
N#endif
N
N#ifndef traceEVENT_GROUP_WAIT_BITS_BLOCK
N	#define traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor )
N#endif
N
N#ifndef traceEVENT_GROUP_WAIT_BITS_END
N	#define traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
N#endif
N
N#ifndef traceEVENT_GROUP_CLEAR_BITS
N	#define traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear )
N#endif
N
N#ifndef traceEVENT_GROUP_CLEAR_BITS_FROM_ISR
N	#define traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear )
N#endif
N
N#ifndef traceEVENT_GROUP_SET_BITS
N	#define traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet )
N#endif
N
N#ifndef traceEVENT_GROUP_SET_BITS_FROM_ISR
N	#define traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet )
N#endif
N
N#ifndef traceEVENT_GROUP_DELETE
N	#define traceEVENT_GROUP_DELETE( xEventGroup )
N#endif
N
N#ifndef tracePEND_FUNC_CALL
N	#define tracePEND_FUNC_CALL(xFunctionToPend, pvParameter1, ulParameter2, ret)
N#endif
N
N#ifndef tracePEND_FUNC_CALL_FROM_ISR
N	#define tracePEND_FUNC_CALL_FROM_ISR(xFunctionToPend, pvParameter1, ulParameter2, ret)
N#endif
N
N#ifndef traceQUEUE_REGISTRY_ADD
N	#define traceQUEUE_REGISTRY_ADD(xQueue, pcQueueName)
N#endif
N
N#ifndef traceTASK_NOTIFY_TAKE_BLOCK
N	#define traceTASK_NOTIFY_TAKE_BLOCK()
N#endif
N
N#ifndef traceTASK_NOTIFY_TAKE
N	#define traceTASK_NOTIFY_TAKE()
N#endif
N
N#ifndef traceTASK_NOTIFY_WAIT_BLOCK
N	#define traceTASK_NOTIFY_WAIT_BLOCK()
N#endif
N
N#ifndef traceTASK_NOTIFY_WAIT
N	#define traceTASK_NOTIFY_WAIT()
N#endif
N
N#ifndef traceTASK_NOTIFY
N	#define traceTASK_NOTIFY()
N#endif
N
N#ifndef traceTASK_NOTIFY_FROM_ISR
N	#define traceTASK_NOTIFY_FROM_ISR()
N#endif
N
N#ifndef traceTASK_NOTIFY_GIVE_FROM_ISR
N	#define traceTASK_NOTIFY_GIVE_FROM_ISR()
N#endif
N
N#ifndef traceTASK_DELAY_SUSPEND
N	#define traceTASK_DELAY_SUSPEND( pxCurrentTCB )
N#endif
N
N#ifndef configGENERATE_RUN_TIME_STATS
S	#define configGENERATE_RUN_TIME_STATS 0
N#endif
N
N#if ( configGENERATE_RUN_TIME_STATS == 1 )
X#if ( 0 == 1 )
S
S	#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
S		#error If configGENERATE_RUN_TIME_STATS is defined then portCONFIGURE_TIMER_FOR_RUN_TIME_STATS must also be defined.  portCONFIGURE_TIMER_FOR_RUN_TIME_STATS should call a port layer function to setup a peripheral timer/counter that can then be used as the run time counter time base.
S	#endif /* portCONFIGURE_TIMER_FOR_RUN_TIME_STATS */
S
S	#ifndef portGET_RUN_TIME_COUNTER_VALUE
S		#ifndef portALT_GET_RUN_TIME_COUNTER_VALUE
S			#error If configGENERATE_RUN_TIME_STATS is defined then either portGET_RUN_TIME_COUNTER_VALUE or portALT_GET_RUN_TIME_COUNTER_VALUE must also be defined.  See the examples provided and the FreeRTOS web site for more information.
S		#endif /* portALT_GET_RUN_TIME_COUNTER_VALUE */
S	#endif /* portGET_RUN_TIME_COUNTER_VALUE */
S
N#endif /* configGENERATE_RUN_TIME_STATS */
N
N#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
N	#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()
N#endif
N
N#ifndef configUSE_MALLOC_FAILED_HOOK
S	#define configUSE_MALLOC_FAILED_HOOK 0
N#endif
N
N#ifndef portPRIVILEGE_BIT
N	#define portPRIVILEGE_BIT ( ( UBaseType_t ) 0x00 )
N#endif
N
N#ifndef portYIELD_WITHIN_API
N	#define portYIELD_WITHIN_API portYIELD
N#endif
N
N#ifndef pvPortMallocAligned
N	#define pvPortMallocAligned( x, puxStackBuffer ) ( ( ( puxStackBuffer ) == NULL ) ? ( pvPortMalloc( ( x ) ) ) : ( puxStackBuffer ) )
N#endif
N
N#ifndef vPortFreeAligned
N	#define vPortFreeAligned( pvBlockToFree ) vPortFree( pvBlockToFree )
N#endif
N
N#ifndef portSUPPRESS_TICKS_AND_SLEEP
S	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )
N#endif
N
N#ifndef configEXPECTED_IDLE_TIME_BEFORE_SLEEP
N	#define configEXPECTED_IDLE_TIME_BEFORE_SLEEP 2
N#endif
N
N#if configEXPECTED_IDLE_TIME_BEFORE_SLEEP < 2
X#if 2 < 2
S	#error configEXPECTED_IDLE_TIME_BEFORE_SLEEP must not be less than 2
N#endif
N
N#ifndef configUSE_TICKLESS_IDLE
N	#define configUSE_TICKLESS_IDLE 0
N#endif
N
N#ifndef configPRE_SLEEP_PROCESSING
N	#define configPRE_SLEEP_PROCESSING( x )
N#endif
N
N#ifndef configPOST_SLEEP_PROCESSING
N	#define configPOST_SLEEP_PROCESSING( x )
N#endif
N
N#ifndef configUSE_QUEUE_SETS
N	#define configUSE_QUEUE_SETS 0
N#endif
N
N#ifndef portTASK_USES_FLOATING_POINT
N	#define portTASK_USES_FLOATING_POINT()
N#endif
N
N#ifndef configUSE_TIME_SLICING
N	#define configUSE_TIME_SLICING 1
N#endif
N
N#ifndef configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS
N	#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0
N#endif
N
N#ifndef configUSE_NEWLIB_REENTRANT
N	#define configUSE_NEWLIB_REENTRANT 0
N#endif
N
N#ifndef configUSE_STATS_FORMATTING_FUNCTIONS
S	#define configUSE_STATS_FORMATTING_FUNCTIONS 0
N#endif
N
N#ifndef portASSERT_IF_INTERRUPT_PRIORITY_INVALID
N	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()
N#endif
N
N#ifndef configUSE_TRACE_FACILITY
S	#define configUSE_TRACE_FACILITY 0
N#endif
N
N#ifndef mtCOVERAGE_TEST_MARKER
N	#define mtCOVERAGE_TEST_MARKER()
N#endif
N
N#ifndef mtCOVERAGE_TEST_DELAY
N	#define mtCOVERAGE_TEST_DELAY()
N#endif
N
N#ifndef portASSERT_IF_IN_ISR
N	#define portASSERT_IF_IN_ISR()
N#endif
N
N#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
S	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0
N#endif
N
N#ifndef configAPPLICATION_ALLOCATED_HEAP
N	#define configAPPLICATION_ALLOCATED_HEAP 0
N#endif
N
N#ifndef configUSE_TASK_NOTIFICATIONS
N	#define configUSE_TASK_NOTIFICATIONS 1
N#endif
N
N#ifndef portTICK_TYPE_IS_ATOMIC
S	#define portTICK_TYPE_IS_ATOMIC 0
N#endif
N
N#if( portTICK_TYPE_IS_ATOMIC == 0 )
X#if( 1 == 0 )
S	/* Either variables of tick type cannot be read atomically, or
S	portTICK_TYPE_IS_ATOMIC was not set - map the critical sections used when
S	the tick count is returned to the standard critical section macros. */
S	#define portTICK_TYPE_ENTER_CRITICAL() portENTER_CRITICAL()
S	#define portTICK_TYPE_EXIT_CRITICAL() portEXIT_CRITICAL()
S	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
S	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( ( x ) )
N#else
N	/* The tick type can be read atomically, so critical sections used when the
N	tick count is returned can be defined away. */
N	#define portTICK_TYPE_ENTER_CRITICAL()
N	#define portTICK_TYPE_EXIT_CRITICAL()
N	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() 0
N	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) ( void ) x
N#endif
N
N/* Definitions to allow backward compatibility with FreeRTOS versions prior to
NV8 if desired. */
N#ifndef configENABLE_BACKWARD_COMPATIBILITY
N	#define configENABLE_BACKWARD_COMPATIBILITY 1
N#endif
N
N#if configENABLE_BACKWARD_COMPATIBILITY == 1
X#if 1 == 1
N	#define eTaskStateGet eTaskGetState
N	#define portTickType TickType_t
N	#define xTaskHandle TaskHandle_t
N	#define xQueueHandle QueueHandle_t
N	#define xSemaphoreHandle SemaphoreHandle_t
N	#define xQueueSetHandle QueueSetHandle_t
N	#define xQueueSetMemberHandle QueueSetMemberHandle_t
N	#define xTimeOutType TimeOut_t
N	#define xMemoryRegion MemoryRegion_t
N	#define xTaskParameters TaskParameters_t
N	#define xTaskStatusType	TaskStatus_t
N	#define xTimerHandle TimerHandle_t
N	#define xCoRoutineHandle CoRoutineHandle_t
N	#define pdTASK_HOOK_CODE TaskHookFunction_t
N	#define portTICK_RATE_MS portTICK_PERIOD_MS
N
N	/* Backward compatibility within the scheduler code only - these definitions
N	are not really required but are included for completeness. */
N	#define tmrTIMER_CALLBACK TimerCallbackFunction_t
N	#define pdTASK_CODE TaskFunction_t
N	#define xListItem ListItem_t
N	#define xList List_t
N#endif /* configENABLE_BACKWARD_COMPATIBILITY */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* INC_FREERTOS_H */
N
L 81 "..\..\FreeRTOS\Source\tasks.c" 2
N#include "task.h"
L 1 "..\..\FreeRTOS\Source\include\task.h" 1
N/*
N    FreeRTOS V8.2.2 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N
N#ifndef INC_TASK_H
N#define INC_TASK_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h must appear in source files before include task.h"
N#endif
N
N#include "list.h"
L 1 "..\..\FreeRTOS\Source\include\list.h" 1
N/*
N    FreeRTOS V8.2.2 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N/*
N * This is the list implementation used by the scheduler.  While it is tailored
N * heavily for the schedulers needs, it is also available for use by
N * application code.
N *
N * list_ts can only store pointers to list_item_ts.  Each ListItem_t contains a
N * numeric value (xItemValue).  Most of the time the lists are sorted in
N * descending item value order.
N *
N * Lists are created already containing one list item.  The value of this
N * item is the maximum possible that can be stored, it is therefore always at
N * the end of the list and acts as a marker.  The list member pxHead always
N * points to this marker - even though it is at the tail of the list.  This
N * is because the tail contains a wrap back pointer to the true head of
N * the list.
N *
N * In addition to it's value, each list item contains a pointer to the next
N * item in the list (pxNext), a pointer to the list it is in (pxContainer)
N * and a pointer to back to the object that contains it.  These later two
N * pointers are included for efficiency of list manipulation.  There is
N * effectively a two way link between the object containing the list item and
N * the list item itself.
N *
N *
N * \page ListIntroduction List Implementation
N * \ingroup FreeRTOSIntro
N */
N
N#ifndef INC_FREERTOS_H
S	#error FreeRTOS.h must be included before list.h
N#endif
N
N#ifndef LIST_H
N#define LIST_H
N
N/*
N * The list structure members are modified from within interrupts, and therefore
N * by rights should be declared volatile.  However, they are only modified in a
N * functionally atomic way (within critical sections of with the scheduler
N * suspended) and are either passed by reference into a function or indexed via
N * a volatile variable.  Therefore, in all use cases tested so far, the volatile
N * qualifier can be omitted in order to provide a moderate performance
N * improvement without adversely affecting functional behaviour.  The assembly
N * instructions generated by the IAR, ARM and GCC compilers when the respective
N * compiler's options were set for maximum optimisation has been inspected and
N * deemed to be as intended.  That said, as compiler technology advances, and
N * especially if aggressive cross module optimisation is used (a use case that
N * has not been exercised to any great extend) then it is feasible that the
N * volatile qualifier will be needed for correct optimisation.  It is expected
N * that a compiler removing essential code because, without the volatile
N * qualifier on the list structure members and with aggressive cross module
N * optimisation, the compiler deemed the code unnecessary will result in
N * complete and obvious failure of the scheduler.  If this is ever experienced
N * then the volatile qualifier can be inserted in the relevant places within the
N * list structures by simply defining configLIST_VOLATILE to volatile in
N * FreeRTOSConfig.h (as per the example at the bottom of this comment block).
N * If configLIST_VOLATILE is not defined then the preprocessor directives below
N * will simply #define configLIST_VOLATILE away completely.
N *
N * To use volatile list structure members then add the following line to
N * FreeRTOSConfig.h (without the quotes):
N * "#define configLIST_VOLATILE volatile"
N */
N#ifndef configLIST_VOLATILE
N	#define configLIST_VOLATILE
N#endif /* configSUPPORT_CROSS_MODULE_OPTIMISATION */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Macros that can be used to place known values within the list structures,
Nthen check that the known values do not get corrupted during the execution of
Nthe application.   These may catch the list data structures being overwritten in
Nmemory.  They will not catch data errors caused by incorrect configuration or
Nuse of FreeRTOS.*/
N#if( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 0 )
X#if( 0 == 0 )
N	/* Define the macros to do nothing. */
N	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE
N	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE
N	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE
N	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE
N	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
N	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
N	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )
N	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )
N	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )
N	#define listTEST_LIST_INTEGRITY( pxList )
N#else
S	/* Define macros that add new members into the list structures. */
S	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue1;
S	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue2;
S	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue1;
S	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue2;
S
S	/* Define macros that set the new structure members to known values. */
S	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )		( pxItem )->xListItemIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )	( pxItem )->xListItemIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )		( pxList )->xListIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )		( pxList )->xListIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
S
S	/* Define macros that will assert if one of the structure members does not
S	contain its expected value. */
S	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )		configASSERT( ( ( pxItem )->xListItemIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxItem )->xListItemIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
S	#define listTEST_LIST_INTEGRITY( pxList )			configASSERT( ( ( pxList )->xListIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxList )->xListIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
N#endif /* configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES */
N
N
N/*
N * Definition of the only type of object that a list can contain.
N */
Nstruct xLIST_ITEM
N{
N	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N	configLIST_VOLATILE TickType_t xItemValue;			/*< The value being listed.  In most cases this is used to sort the list in descending order. */
X	 TickType_t xItemValue;			 
N	struct xLIST_ITEM * configLIST_VOLATILE pxNext;		/*< Pointer to the next ListItem_t in the list. */
X	struct xLIST_ITEM *  pxNext;		 
N	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;	/*< Pointer to the previous ListItem_t in the list. */
X	struct xLIST_ITEM *  pxPrevious;	 
N	void * pvOwner;										/*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */
N	void * configLIST_VOLATILE pvContainer;				/*< Pointer to the list in which this list item is placed (if any). */
X	void *  pvContainer;				 
N	listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N};
Ntypedef struct xLIST_ITEM ListItem_t;					/* For some reason lint wants this as two separate definitions. */
N
Nstruct xMINI_LIST_ITEM
N{
N	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N	configLIST_VOLATILE TickType_t xItemValue;
X	 TickType_t xItemValue;
N	struct xLIST_ITEM * configLIST_VOLATILE pxNext;
X	struct xLIST_ITEM *  pxNext;
N	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;
X	struct xLIST_ITEM *  pxPrevious;
N};
Ntypedef struct xMINI_LIST_ITEM MiniListItem_t;
N
N/*
N * Definition of the type of queue used by the scheduler.
N */
Ntypedef struct xLIST
N{
N	listFIRST_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X					 
N	configLIST_VOLATILE UBaseType_t uxNumberOfItems;
X	 UBaseType_t uxNumberOfItems;
N	ListItem_t * configLIST_VOLATILE pxIndex;			/*< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). */
X	ListItem_t *  pxIndex;			 
N	MiniListItem_t xListEnd;							/*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */
N	listSECOND_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X					 
N} List_t;
N
N/*
N * Access macro to set the owner of a list item.  The owner of a list item
N * is the object (usually a TCB) that contains the list item.
N *
N * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
N * \ingroup LinkedList
N */
N#define listSET_LIST_ITEM_OWNER( pxListItem, pxOwner )		( ( pxListItem )->pvOwner = ( void * ) ( pxOwner ) )
N
N/*
N * Access macro to get the owner of a list item.  The owner of a list item
N * is the object (usually a TCB) that contains the list item.
N *
N * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
N * \ingroup LinkedList
N */
N#define listGET_LIST_ITEM_OWNER( pxListItem )	( ( pxListItem )->pvOwner )
N
N/*
N * Access macro to set the value of the list item.  In most cases the value is
N * used to sort the list in descending order.
N *
N * \page listSET_LIST_ITEM_VALUE listSET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listSET_LIST_ITEM_VALUE( pxListItem, xValue )	( ( pxListItem )->xItemValue = ( xValue ) )
N
N/*
N * Access macro to retrieve the value of the list item.  The value can
N * represent anything - for example the priority of a task, or the time at
N * which a task should be unblocked.
N *
N * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listGET_LIST_ITEM_VALUE( pxListItem )	( ( pxListItem )->xItemValue )
N
N/*
N * Access macro to retrieve the value of the list item at the head of a given
N * list.
N *
N * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext->xItemValue )
N
N/*
N * Return the list item at the head of the list.
N *
N * \page listGET_HEAD_ENTRY listGET_HEAD_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext )
N
N/*
N * Return the list item at the head of the list.
N *
N * \page listGET_NEXT listGET_NEXT
N * \ingroup LinkedList
N */
N#define listGET_NEXT( pxListItem )	( ( pxListItem )->pxNext )
N
N/*
N * Return the list item that marks the end of the list
N *
N * \page listGET_END_MARKER listGET_END_MARKER
N * \ingroup LinkedList
N */
N#define listGET_END_MARKER( pxList )	( ( ListItem_t const * ) ( &( ( pxList )->xListEnd ) ) )
N
N/*
N * Access macro to determine if a list contains any items.  The macro will
N * only have the value true if the list is empty.
N *
N * \page listLIST_IS_EMPTY listLIST_IS_EMPTY
N * \ingroup LinkedList
N */
N#define listLIST_IS_EMPTY( pxList )	( ( BaseType_t ) ( ( pxList )->uxNumberOfItems == ( UBaseType_t ) 0 ) )
N
N/*
N * Access macro to return the number of items in the list.
N */
N#define listCURRENT_LIST_LENGTH( pxList )	( ( pxList )->uxNumberOfItems )
N
N/*
N * Access function to obtain the owner of the next entry in a list.
N *
N * The list member pxIndex is used to walk through a list.  Calling
N * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list
N * and returns that entry's pxOwner parameter.  Using multiple calls to this
N * function it is therefore possible to move through every item contained in
N * a list.
N *
N * The pxOwner parameter of a list item is a pointer to the object that owns
N * the list item.  In the scheduler this is normally a task control block.
N * The pxOwner parameter effectively creates a two way link between the list
N * item and its owner.
N *
N * @param pxTCB pxTCB is set to the address of the owner of the next list item.
N * @param pxList The list from which the next item owner is to be returned.
N *
N * \page listGET_OWNER_OF_NEXT_ENTRY listGET_OWNER_OF_NEXT_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										\
N{																							\
NList_t * const pxConstList = ( pxList );													\
N	/* Increment the index to the next item and return the item, ensuring */				\
N	/* we don't return the marker used at the end of the list.  */							\
N	( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							\
N	if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )	\
N	{																						\
N		( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;						\
N	}																						\
N	( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											\
N}
X#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										{																							List_t * const pxConstList = ( pxList );														 					 								( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;								if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )		{																								( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							}																							( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											}
N
N
N/*
N * Access function to obtain the owner of the first entry in a list.  Lists
N * are normally sorted in ascending item value order.
N *
N * This function returns the pxOwner member of the first item in the list.
N * The pxOwner parameter of a list item is a pointer to the object that owns
N * the list item.  In the scheduler this is normally a task control block.
N * The pxOwner parameter effectively creates a two way link between the list
N * item and its owner.
N *
N * @param pxList The list from which the owner of the head item is to be
N * returned.
N *
N * \page listGET_OWNER_OF_HEAD_ENTRY listGET_OWNER_OF_HEAD_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_OWNER_OF_HEAD_ENTRY( pxList )  ( (&( ( pxList )->xListEnd ))->pxNext->pvOwner )
N
N/*
N * Check to see if a list item is within a list.  The list item maintains a
N * "container" pointer that points to the list it is in.  All this macro does
N * is check to see if the container and the list match.
N *
N * @param pxList The list we want to know if the list item is within.
N * @param pxListItem The list item we want to know if is in the list.
N * @return pdTRUE if the list item is in the list, otherwise pdFALSE.
N */
N#define listIS_CONTAINED_WITHIN( pxList, pxListItem ) ( ( BaseType_t ) ( ( pxListItem )->pvContainer == ( void * ) ( pxList ) ) )
N
N/*
N * Return the list a list item is contained within (referenced from).
N *
N * @param pxListItem The list item being queried.
N * @return A pointer to the List_t object that references the pxListItem
N */
N#define listLIST_ITEM_CONTAINER( pxListItem ) ( ( pxListItem )->pvContainer )
N
N/*
N * This provides a crude means of knowing if a list has been initialised, as
N * pxList->xListEnd.xItemValue is set to portMAX_DELAY by the vListInitialise()
N * function.
N */
N#define listLIST_IS_INITIALISED( pxList ) ( ( pxList )->xListEnd.xItemValue == portMAX_DELAY )
N
N/*
N * Must be called before a list is used!  This initialises all the members
N * of the list structure and inserts the xListEnd item into the list as a
N * marker to the back of the list.
N *
N * @param pxList Pointer to the list being initialised.
N *
N * \page vListInitialise vListInitialise
N * \ingroup LinkedList
N */
Nvoid vListInitialise( List_t * const pxList ) PRIVILEGED_FUNCTION;
Xvoid vListInitialise( List_t * const pxList ) ;
N
N/*
N * Must be called before a list item is used.  This sets the list container to
N * null so the item does not think that it is already contained in a list.
N *
N * @param pxItem Pointer to the list item being initialised.
N *
N * \page vListInitialiseItem vListInitialiseItem
N * \ingroup LinkedList
N */
Nvoid vListInitialiseItem( ListItem_t * const pxItem ) PRIVILEGED_FUNCTION;
Xvoid vListInitialiseItem( ListItem_t * const pxItem ) ;
N
N/*
N * Insert a list item into a list.  The item will be inserted into the list in
N * a position determined by its item value (descending item value order).
N *
N * @param pxList The list into which the item is to be inserted.
N *
N * @param pxNewListItem The item that is to be placed in the list.
N *
N * \page vListInsert vListInsert
N * \ingroup LinkedList
N */
Nvoid vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
Xvoid vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) ;
N
N/*
N * Insert a list item into a list.  The item will be inserted in a position
N * such that it will be the last item within the list returned by multiple
N * calls to listGET_OWNER_OF_NEXT_ENTRY.
N *
N * The list member pvIndex is used to walk through a list.  Calling
N * listGET_OWNER_OF_NEXT_ENTRY increments pvIndex to the next item in the list.
N * Placing an item in a list using vListInsertEnd effectively places the item
N * in the list position pointed to by pvIndex.  This means that every other
N * item within the list will be returned by listGET_OWNER_OF_NEXT_ENTRY before
N * the pvIndex parameter again points to the item being inserted.
N *
N * @param pxList The list into which the item is to be inserted.
N *
N * @param pxNewListItem The list item to be inserted into the list.
N *
N * \page vListInsertEnd vListInsertEnd
N * \ingroup LinkedList
N */
Nvoid vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
Xvoid vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) ;
N
N/*
N * Remove an item from a list.  The list item has a pointer to the list that
N * it is in, so only the list item need be passed into the function.
N *
N * @param uxListRemove The item to be removed.  The item will remove itself from
N * the list pointed to by it's pxContainer parameter.
N *
N * @return The number of items that remain in the list after the list item has
N * been removed.
N *
N * \page uxListRemove uxListRemove
N * \ingroup LinkedList
N */
NUBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) PRIVILEGED_FUNCTION;
XUBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) ;
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
L 79 "..\..\FreeRTOS\Source\include\task.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*-----------------------------------------------------------
N * MACROS AND DEFINITIONS
N *----------------------------------------------------------*/
N
N#define tskKERNEL_VERSION_NUMBER "V8.2.2"
N#define tskKERNEL_VERSION_MAJOR 8
N#define tskKERNEL_VERSION_MINOR 2
N#define tskKERNEL_VERSION_BUILD 2
N
N/**
N * task. h
N *
N * Type by which tasks are referenced.  For example, a call to xTaskCreate
N * returns (via a pointer parameter) an TaskHandle_t variable that can then
N * be used as a parameter to vTaskDelete to delete the task.
N *
N * \defgroup TaskHandle_t TaskHandle_t
N * \ingroup Tasks
N */
Ntypedef void * TaskHandle_t;
N
N/*
N * Defines the prototype to which the application task hook function must
N * conform.
N */
Ntypedef BaseType_t (*TaskHookFunction_t)( void * );
N
N/* Task states returned by eTaskGetState. */
Ntypedef enum
N{
N	eRunning = 0,	/* A task is querying the state of itself, so must be running. */
N	eReady,			/* The task being queried is in a read or pending ready list. */
N	eBlocked,		/* The task being queried is in the Blocked state. */
N	eSuspended,		/* The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */
N	eDeleted		/* The task being queried has been deleted, but its TCB has not yet been freed. */
N} eTaskState;
N
N/* Actions that can be performed when vTaskNotify() is called. */
Ntypedef enum
N{
N	eNoAction = 0,				/* Notify the task without updating its notify value. */
N	eSetBits,					/* Set bits in the task's notification value. */
N	eIncrement,					/* Increment the task's notification value. */
N	eSetValueWithOverwrite,		/* Set the task's notification value to a specific value even if the previous value has not yet been read by the task. */
N	eSetValueWithoutOverwrite	/* Set the task's notification value if the previous value has been read by the task. */
N} eNotifyAction;
N
N/*
N * Used internally only.
N */
Ntypedef struct xTIME_OUT
N{
N	BaseType_t xOverflowCount;
N	TickType_t xTimeOnEntering;
N} TimeOut_t;
N
N/*
N * Defines the memory ranges allocated to the task when an MPU is used.
N */
Ntypedef struct xMEMORY_REGION
N{
N	void *pvBaseAddress;
N	uint32_t ulLengthInBytes;
N	uint32_t ulParameters;
N} MemoryRegion_t;
N
N/*
N * Parameters required to create an MPU protected task.
N */
Ntypedef struct xTASK_PARAMETERS
N{
N	TaskFunction_t pvTaskCode;
N	const char * const pcName;	/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N	uint16_t usStackDepth;
N	void *pvParameters;
N	UBaseType_t uxPriority;
N	StackType_t *puxStackBuffer;
N	MemoryRegion_t xRegions[ portNUM_CONFIGURABLE_REGIONS ];
X	MemoryRegion_t xRegions[ 1 ];
N} TaskParameters_t;
N
N/* Used with the uxTaskGetSystemState() function to return the state of each task
Nin the system. */
Ntypedef struct xTASK_STATUS
N{
N	TaskHandle_t xHandle;			/* The handle of the task to which the rest of the information in the structure relates. */
N	const char *pcTaskName;			/* A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N	UBaseType_t xTaskNumber;		/* A number unique to the task. */
N	eTaskState eCurrentState;		/* The state in which the task existed when the structure was populated. */
N	UBaseType_t uxCurrentPriority;	/* The priority at which the task was running (may be inherited) when the structure was populated. */
N	UBaseType_t uxBasePriority;		/* The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. */
N	uint32_t ulRunTimeCounter;		/* The total run time allocated to the task so far, as defined by the run time stats clock.  See http://www.freertos.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. */
N	uint16_t usStackHighWaterMark;	/* The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. */
N} TaskStatus_t;
N
N/* Possible return values for eTaskConfirmSleepModeStatus(). */
Ntypedef enum
N{
N	eAbortSleep = 0,		/* A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. */
N	eStandardSleep,			/* Enter a sleep mode that will not last any longer than the expected idle time. */
N	eNoTasksWaitingTimeout	/* No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. */
N} eSleepModeStatus;
N
N
N/**
N * Defines the priority used by the idle task.  This must not be modified.
N *
N * \ingroup TaskUtils
N */
N#define tskIDLE_PRIORITY			( ( UBaseType_t ) 0U )
N
N/**
N * task. h
N *
N * Macro for forcing a context switch.
N *
N * \defgroup taskYIELD taskYIELD
N * \ingroup SchedulerControl
N */
N#define taskYIELD()					portYIELD()
N
N/**
N * task. h
N *
N * Macro to mark the start of a critical code region.  Preemptive context
N * switches cannot occur when in a critical region.
N *
N * NOTE: This may alter the stack (depending on the portable implementation)
N * so must be used with care!
N *
N * \defgroup taskENTER_CRITICAL taskENTER_CRITICAL
N * \ingroup SchedulerControl
N */
N#define taskENTER_CRITICAL()		portENTER_CRITICAL()
N#define taskENTER_CRITICAL_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
N
N/**
N * task. h
N *
N * Macro to mark the end of a critical code region.  Preemptive context
N * switches cannot occur when in a critical region.
N *
N * NOTE: This may alter the stack (depending on the portable implementation)
N * so must be used with care!
N *
N * \defgroup taskEXIT_CRITICAL taskEXIT_CRITICAL
N * \ingroup SchedulerControl
N */
N#define taskEXIT_CRITICAL()			portEXIT_CRITICAL()
N#define taskEXIT_CRITICAL_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( x )
N/**
N * task. h
N *
N * Macro to disable all maskable interrupts.
N *
N * \defgroup taskDISABLE_INTERRUPTS taskDISABLE_INTERRUPTS
N * \ingroup SchedulerControl
N */
N#define taskDISABLE_INTERRUPTS()	portDISABLE_INTERRUPTS()
N
N/**
N * task. h
N *
N * Macro to enable microcontroller interrupts.
N *
N * \defgroup taskENABLE_INTERRUPTS taskENABLE_INTERRUPTS
N * \ingroup SchedulerControl
N */
N#define taskENABLE_INTERRUPTS()		portENABLE_INTERRUPTS()
N
N/* Definitions returned by xTaskGetSchedulerState().  taskSCHEDULER_SUSPENDED is
N0 to generate more optimal code when configASSERT() is defined as the constant
Nis used in assert() statements. */
N#define taskSCHEDULER_SUSPENDED		( ( BaseType_t ) 0 )
N#define taskSCHEDULER_NOT_STARTED	( ( BaseType_t ) 1 )
N#define taskSCHEDULER_RUNNING		( ( BaseType_t ) 2 )
N
N
N/*-----------------------------------------------------------
N * TASK CREATION API
N *----------------------------------------------------------*/
N
N/**
N * task. h
N *<pre>
N BaseType_t xTaskCreate(
N							  TaskFunction_t pvTaskCode,
N							  const char * const pcName,
N							  uint16_t usStackDepth,
N							  void *pvParameters,
N							  UBaseType_t uxPriority,
N							  TaskHandle_t *pvCreatedTask
N						  );</pre>
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N *
N * xTaskCreate() can only be used to create a task that has unrestricted
N * access to the entire microcontroller memory map.  Systems that include MPU
N * support can alternatively create an MPU constrained task using
N * xTaskCreateRestricted().
N *
N * @param pvTaskCode Pointer to the task entry function.  Tasks
N * must be implemented to never return (i.e. continuous loop).
N *
N * @param pcName A descriptive name for the task.  This is mainly used to
N * facilitate debugging.  Max length defined by configMAX_TASK_NAME_LEN - default
N * is 16.
N *
N * @param usStackDepth The size of the task stack specified as the number of
N * variables the stack can hold - not the number of bytes.  For example, if
N * the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes
N * will be allocated for stack storage.
N *
N * @param pvParameters Pointer that will be used as the parameter for the task
N * being created.
N *
N * @param uxPriority The priority at which the task should run.  Systems that
N * include MPU support can optionally create tasks in a privileged (system)
N * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For
N * example, to create a privileged task at priority 2 the uxPriority parameter
N * should be set to ( 2 | portPRIVILEGE_BIT ).
N *
N * @param pvCreatedTask Used to pass back a handle by which the created task
N * can be referenced.
N *
N * @return pdPASS if the task was successfully created and added to a ready
N * list, otherwise an error code defined in the file projdefs.h
N *
N * Example usage:
N   <pre>
N // Task to be created.
N void vTaskCode( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N	 }
N }
N
N // Function that creates a task.
N void vOtherFunction( void )
N {
N static uint8_t ucParameterToPass;
N TaskHandle_t xHandle = NULL;
N
N	 // Create the task, storing the handle.  Note that the passed parameter ucParameterToPass
N	 // must exist for the lifetime of the task, so in this case is declared static.  If it was just an
N	 // an automatic stack variable it might no longer exist, or at least have been corrupted, by the time
N	 // the new task attempts to access it.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, &ucParameterToPass, tskIDLE_PRIORITY, &xHandle );
N     configASSERT( xHandle );
N
N	 // Use the handle to delete the task.
N     if( xHandle != NULL )
N     {
N	     vTaskDelete( xHandle );
N     }
N }
N   </pre>
N * \defgroup xTaskCreate xTaskCreate
N * \ingroup Tasks
N */
N#define xTaskCreate( pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask ) xTaskGenericCreate( ( pvTaskCode ), ( pcName ), ( usStackDepth ), ( pvParameters ), ( uxPriority ), ( pxCreatedTask ), ( NULL ), ( NULL ) )
N
N/**
N * task. h
N *<pre>
N BaseType_t xTaskCreateRestricted( TaskParameters_t *pxTaskDefinition, TaskHandle_t *pxCreatedTask );</pre>
N *
N * xTaskCreateRestricted() should only be used in systems that include an MPU
N * implementation.
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N * The function parameters define the memory regions and associated access
N * permissions allocated to the task.
N *
N * @param pxTaskDefinition Pointer to a structure that contains a member
N * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API
N * documentation) plus an optional stack buffer and the memory region
N * definitions.
N *
N * @param pxCreatedTask Used to pass back a handle by which the created task
N * can be referenced.
N *
N * @return pdPASS if the task was successfully created and added to a ready
N * list, otherwise an error code defined in the file projdefs.h
N *
N * Example usage:
N   <pre>
N// Create an TaskParameters_t structure that defines the task to be created.
Nstatic const TaskParameters_t xCheckTaskParameters =
N{
N	vATask,		// pvTaskCode - the function that implements the task.
N	"ATask",	// pcName - just a text name for the task to assist debugging.
N	100,		// usStackDepth	- the stack size DEFINED IN WORDS.
N	NULL,		// pvParameters - passed into the task function as the function parameters.
N	( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.
N	cStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.
N
N	// xRegions - Allocate up to three separate memory regions for access by
N	// the task, with appropriate access permissions.  Different processors have
N	// different memory alignment requirements - refer to the FreeRTOS documentation
N	// for full information.
N	{
N		// Base address					Length	Parameters
N        { cReadWriteArray,				32,		portMPU_REGION_READ_WRITE },
N        { cReadOnlyArray,				32,		portMPU_REGION_READ_ONLY },
N        { cPrivilegedOnlyAccessArray,	128,	portMPU_REGION_PRIVILEGED_READ_WRITE }
N	}
N};
N
Nint main( void )
N{
NTaskHandle_t xHandle;
N
N	// Create a task from the const structure defined above.  The task handle
N	// is requested (the second parameter is not NULL) but in this case just for
N	// demonstration purposes as its not actually used.
N	xTaskCreateRestricted( &xRegTest1Parameters, &xHandle );
N
N	// Start the scheduler.
N	vTaskStartScheduler();
N
N	// Will only get here if there was insufficient memory to create the idle
N	// and/or timer task.
N	for( ;; );
N}
N   </pre>
N * \defgroup xTaskCreateRestricted xTaskCreateRestricted
N * \ingroup Tasks
N */
N#define xTaskCreateRestricted( x, pxCreatedTask ) xTaskGenericCreate( ((x)->pvTaskCode), ((x)->pcName), ((x)->usStackDepth), ((x)->pvParameters), ((x)->uxPriority), (pxCreatedTask), ((x)->puxStackBuffer), ((x)->xRegions) )
N
N/**
N * task. h
N *<pre>
N void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions );</pre>
N *
N * Memory regions are assigned to a restricted task when the task is created by
N * a call to xTaskCreateRestricted().  These regions can be redefined using
N * vTaskAllocateMPURegions().
N *
N * @param xTask The handle of the task being updated.
N *
N * @param xRegions A pointer to an MemoryRegion_t structure that contains the
N * new memory region definitions.
N *
N * Example usage:
N   <pre>
N// Define an array of MemoryRegion_t structures that configures an MPU region
N// allowing read/write access for 1024 bytes starting at the beginning of the
N// ucOneKByte array.  The other two of the maximum 3 definable regions are
N// unused so set to zero.
Nstatic const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] =
N{
N	// Base address		Length		Parameters
N	{ ucOneKByte,		1024,		portMPU_REGION_READ_WRITE },
N	{ 0,				0,			0 },
N	{ 0,				0,			0 }
N};
N
Nvoid vATask( void *pvParameters )
N{
N	// This task was created such that it has access to certain regions of
N	// memory as defined by the MPU configuration.  At some point it is
N	// desired that these MPU regions are replaced with that defined in the
N	// xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()
N	// for this purpose.  NULL is used as the task handle to indicate that this
N	// function should modify the MPU regions of the calling task.
N	vTaskAllocateMPURegions( NULL, xAltRegions );
N
N	// Now the task can continue its function, but from this point on can only
N	// access its stack and the ucOneKByte array (unless any other statically
N	// defined or shared regions have been declared elsewhere).
N}
N   </pre>
N * \defgroup xTaskCreateRestricted xTaskCreateRestricted
N * \ingroup Tasks
N */
Nvoid vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) PRIVILEGED_FUNCTION;
Xvoid vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) ;
N
N/**
N * task. h
N * <pre>void vTaskDelete( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_vTaskDelete must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Remove a task from the RTOS real time kernel's management.  The task being
N * deleted will be removed from all ready, blocked, suspended and event lists.
N *
N * NOTE:  The idle task is responsible for freeing the kernel allocated
N * memory from tasks that have been deleted.  It is therefore important that
N * the idle task is not starved of microcontroller processing time if your
N * application makes any calls to vTaskDelete ().  Memory allocated by the
N * task code is not automatically freed, and should be freed before the task
N * is deleted.
N *
N * See the demo application file death.c for sample code that utilises
N * vTaskDelete ().
N *
N * @param xTask The handle of the task to be deleted.  Passing NULL will
N * cause the calling task to be deleted.
N *
N * Example usage:
N   <pre>
N void vOtherFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create the task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // Use the handle to delete the task.
N	 vTaskDelete( xHandle );
N }
N   </pre>
N * \defgroup vTaskDelete vTaskDelete
N * \ingroup Tasks
N */
Nvoid vTaskDelete( TaskHandle_t xTaskToDelete ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelete( TaskHandle_t xTaskToDelete ) ;
N
N/*-----------------------------------------------------------
N * TASK CONTROL API
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <pre>void vTaskDelay( const TickType_t xTicksToDelay );</pre>
N *
N * Delay a task for a given number of ticks.  The actual time that the
N * task remains blocked depends on the tick rate.  The constant
N * portTICK_PERIOD_MS can be used to calculate real time from the tick
N * rate - with the resolution of one tick period.
N *
N * INCLUDE_vTaskDelay must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N *
N * vTaskDelay() specifies a time at which the task wishes to unblock relative to
N * the time at which vTaskDelay() is called.  For example, specifying a block
N * period of 100 ticks will cause the task to unblock 100 ticks after
N * vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method
N * of controlling the frequency of a periodic task as the path taken through the
N * code, as well as other task and interrupt activity, will effect the frequency
N * at which vTaskDelay() gets called and therefore the time at which the task
N * next executes.  See vTaskDelayUntil() for an alternative API function designed
N * to facilitate fixed frequency execution.  It does this by specifying an
N * absolute time (rather than a relative time) at which the calling task should
N * unblock.
N *
N * @param xTicksToDelay The amount of time, in tick periods, that
N * the calling task should block.
N *
N * Example usage:
N
N void vTaskFunction( void * pvParameters )
N {
N // Block for 500ms.
N const TickType_t xDelay = 500 / portTICK_PERIOD_MS;
N
N	 for( ;; )
N	 {
N		 // Simply toggle the LED every 500ms, blocking between each toggle.
N		 vToggleLED();
N		 vTaskDelay( xDelay );
N	 }
N }
N
N * \defgroup vTaskDelay vTaskDelay
N * \ingroup TaskCtrl
N */
Nvoid vTaskDelay( const TickType_t xTicksToDelay ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelay( const TickType_t xTicksToDelay ) ;
N
N/**
N * task. h
N * <pre>void vTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement );</pre>
N *
N * INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Delay a task until a specified time.  This function can be used by periodic
N * tasks to ensure a constant execution frequency.
N *
N * This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will
N * cause a task to block for the specified number of ticks from the time vTaskDelay () is
N * called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed
N * execution frequency as the time between a task starting to execute and that task
N * calling vTaskDelay () may not be fixed [the task may take a different path though the
N * code between calls, or may get interrupted or preempted a different number of times
N * each time it executes].
N *
N * Whereas vTaskDelay () specifies a wake time relative to the time at which the function
N * is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to
N * unblock.
N *
N * The constant portTICK_PERIOD_MS can be used to calculate real time from the tick
N * rate - with the resolution of one tick period.
N *
N * @param pxPreviousWakeTime Pointer to a variable that holds the time at which the
N * task was last unblocked.  The variable must be initialised with the current time
N * prior to its first use (see the example below).  Following this the variable is
N * automatically updated within vTaskDelayUntil ().
N *
N * @param xTimeIncrement The cycle time period.  The task will be unblocked at
N * time *pxPreviousWakeTime + xTimeIncrement.  Calling vTaskDelayUntil with the
N * same xTimeIncrement parameter value will cause the task to execute with
N * a fixed interface period.
N *
N * Example usage:
N   <pre>
N // Perform an action every 10 ticks.
N void vTaskFunction( void * pvParameters )
N {
N TickType_t xLastWakeTime;
N const TickType_t xFrequency = 10;
N
N	 // Initialise the xLastWakeTime variable with the current time.
N	 xLastWakeTime = xTaskGetTickCount ();
N	 for( ;; )
N	 {
N		 // Wait for the next cycle.
N		 vTaskDelayUntil( &xLastWakeTime, xFrequency );
N
N		 // Perform action here.
N	 }
N }
N   </pre>
N * \defgroup vTaskDelayUntil vTaskDelayUntil
N * \ingroup TaskCtrl
N */
Nvoid vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) ;
N
N/**
N * task. h
N * <pre>UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Obtain the priority of any task.
N *
N * @param xTask Handle of the task to be queried.  Passing a NULL
N * handle results in the priority of the calling task being returned.
N *
N * @return The priority of xTask.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to obtain the priority of the created task.
N	 // It was created with tskIDLE_PRIORITY, but may have changed
N	 // it itself.
N	 if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )
N	 {
N		 // The task has changed it's priority.
N	 }
N
N	 // ...
N
N	 // Is our priority higher than the created task?
N	 if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )
N	 {
N		 // Our priority (obtained using NULL handle) is higher.
N	 }
N }
N   </pre>
N * \defgroup uxTaskPriorityGet uxTaskPriorityGet
N * \ingroup TaskCtrl
N */
NUBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask );</pre>
N *
N * A version of uxTaskPriorityGet() that can be used from an ISR.
N */
NUBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>eTaskState eTaskGetState( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_eTaskGetState must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Obtain the state of any task.  States are encoded by the eTaskState
N * enumerated type.
N *
N * @param xTask Handle of the task to be queried.
N *
N * @return The state of xTask at the time the function was called.  Note the
N * state of the task might change between the function being called, and the
N * functions return value being tested by the calling task.
N */
NeTaskState eTaskGetState( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XeTaskState eTaskGetState( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority );</pre>
N *
N * INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Set the priority of any task.
N *
N * A context switch will occur before the function returns if the priority
N * being set is higher than the currently executing task.
N *
N * @param xTask Handle to the task for which the priority is being set.
N * Passing a NULL handle results in the priority of the calling task being set.
N *
N * @param uxNewPriority The priority to which the task will be set.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to raise the priority of the created task.
N	 vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );
N
N	 // ...
N
N	 // Use a NULL handle to raise our priority to the same value.
N	 vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );
N }
N   </pre>
N * \defgroup vTaskPrioritySet vTaskPrioritySet
N * \ingroup TaskCtrl
N */
Nvoid vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) PRIVILEGED_FUNCTION;
Xvoid vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) ;
N
N/**
N * task. h
N * <pre>void vTaskSuspend( TaskHandle_t xTaskToSuspend );</pre>
N *
N * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Suspend any task.  When suspended a task will never get any microcontroller
N * processing time, no matter what its priority.
N *
N * Calls to vTaskSuspend are not accumulative -
N * i.e. calling vTaskSuspend () twice on the same task still only requires one
N * call to vTaskResume () to ready the suspended task.
N *
N * @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL
N * handle will cause the calling task to be suspended.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to suspend the created task.
N	 vTaskSuspend( xHandle );
N
N	 // ...
N
N	 // The created task will not run during this period, unless
N	 // another task calls vTaskResume( xHandle ).
N
N	 //...
N
N
N	 // Suspend ourselves.
N	 vTaskSuspend( NULL );
N
N	 // We cannot get here unless another task calls vTaskResume
N	 // with our handle as the parameter.
N }
N   </pre>
N * \defgroup vTaskSuspend vTaskSuspend
N * \ingroup TaskCtrl
N */
Nvoid vTaskSuspend( TaskHandle_t xTaskToSuspend ) PRIVILEGED_FUNCTION;
Xvoid vTaskSuspend( TaskHandle_t xTaskToSuspend ) ;
N
N/**
N * task. h
N * <pre>void vTaskResume( TaskHandle_t xTaskToResume );</pre>
N *
N * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Resumes a suspended task.
N *
N * A task that has been suspended by one or more calls to vTaskSuspend ()
N * will be made available for running again by a single call to
N * vTaskResume ().
N *
N * @param xTaskToResume Handle to the task being readied.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to suspend the created task.
N	 vTaskSuspend( xHandle );
N
N	 // ...
N
N	 // The created task will not run during this period, unless
N	 // another task calls vTaskResume( xHandle ).
N
N	 //...
N
N
N	 // Resume the suspended task ourselves.
N	 vTaskResume( xHandle );
N
N	 // The created task will once again get microcontroller processing
N	 // time in accordance with its priority within the system.
N }
N   </pre>
N * \defgroup vTaskResume vTaskResume
N * \ingroup TaskCtrl
N */
Nvoid vTaskResume( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
Xvoid vTaskResume( TaskHandle_t xTaskToResume ) ;
N
N/**
N * task. h
N * <pre>void xTaskResumeFromISR( TaskHandle_t xTaskToResume );</pre>
N *
N * INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be
N * available.  See the configuration section for more information.
N *
N * An implementation of vTaskResume() that can be called from within an ISR.
N *
N * A task that has been suspended by one or more calls to vTaskSuspend ()
N * will be made available for running again by a single call to
N * xTaskResumeFromISR ().
N *
N * xTaskResumeFromISR() should not be used to synchronise a task with an
N * interrupt if there is a chance that the interrupt could arrive prior to the
N * task being suspended - as this can lead to interrupts being missed. Use of a
N * semaphore as a synchronisation mechanism would avoid this eventuality.
N *
N * @param xTaskToResume Handle to the task being readied.
N *
N * @return pdTRUE if resuming the task should result in a context switch,
N * otherwise pdFALSE. This is used by the ISR to determine if a context switch
N * may be required following the ISR.
N *
N * \defgroup vTaskResumeFromISR vTaskResumeFromISR
N * \ingroup TaskCtrl
N */
NBaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) ;
N
N/*-----------------------------------------------------------
N * SCHEDULER CONTROL
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <pre>void vTaskStartScheduler( void );</pre>
N *
N * Starts the real time kernel tick processing.  After calling the kernel
N * has control over which tasks are executed and when.
N *
N * See the demo application file main.c for an example of creating
N * tasks and starting the kernel.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N	 // Create at least one task before starting the kernel.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
N
N	 // Start the real time kernel with preemption.
N	 vTaskStartScheduler ();
N
N	 // Will not get here unless a task calls vTaskEndScheduler ()
N }
N   </pre>
N *
N * \defgroup vTaskStartScheduler vTaskStartScheduler
N * \ingroup SchedulerControl
N */
Nvoid vTaskStartScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskStartScheduler( void ) ;
N
N/**
N * task. h
N * <pre>void vTaskEndScheduler( void );</pre>
N *
N * NOTE:  At the time of writing only the x86 real mode port, which runs on a PC
N * in place of DOS, implements this function.
N *
N * Stops the real time kernel tick.  All created tasks will be automatically
N * deleted and multitasking (either preemptive or cooperative) will
N * stop.  Execution then resumes from the point where vTaskStartScheduler ()
N * was called, as if vTaskStartScheduler () had just returned.
N *
N * See the demo application file main. c in the demo/PC directory for an
N * example that uses vTaskEndScheduler ().
N *
N * vTaskEndScheduler () requires an exit function to be defined within the
N * portable layer (see vPortEndScheduler () in port. c for the PC port).  This
N * performs hardware specific operations such as stopping the kernel tick.
N *
N * vTaskEndScheduler () will cause all of the resources allocated by the
N * kernel to be freed - but will not free resources allocated by application
N * tasks.
N *
N * Example usage:
N   <pre>
N void vTaskCode( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // At some point we want to end the real time kernel processing
N		 // so call ...
N		 vTaskEndScheduler ();
N	 }
N }
N
N void vAFunction( void )
N {
N	 // Create at least one task before starting the kernel.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
N
N	 // Start the real time kernel with preemption.
N	 vTaskStartScheduler ();
N
N	 // Will only get here when the vTaskCode () task has called
N	 // vTaskEndScheduler ().  When we get here we are back to single task
N	 // execution.
N }
N   </pre>
N *
N * \defgroup vTaskEndScheduler vTaskEndScheduler
N * \ingroup SchedulerControl
N */
Nvoid vTaskEndScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskEndScheduler( void ) ;
N
N/**
N * task. h
N * <pre>void vTaskSuspendAll( void );</pre>
N *
N * Suspends the scheduler without disabling interrupts.  Context switches will
N * not occur while the scheduler is suspended.
N *
N * After calling vTaskSuspendAll () the calling task will continue to execute
N * without risk of being swapped out until a call to xTaskResumeAll () has been
N * made.
N *
N * API functions that have the potential to cause a context switch (for example,
N * vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler
N * is suspended.
N *
N * Example usage:
N   <pre>
N void vTask1( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // ...
N
N		 // At some point the task wants to perform a long operation during
N		 // which it does not want to get swapped out.  It cannot use
N		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
N		 // operation may cause interrupts to be missed - including the
N		 // ticks.
N
N		 // Prevent the real time kernel swapping out the task.
N		 vTaskSuspendAll ();
N
N		 // Perform the operation here.  There is no need to use critical
N		 // sections as we have all the microcontroller processing time.
N		 // During this time interrupts will still operate and the kernel
N		 // tick count will be maintained.
N
N		 // ...
N
N		 // The operation is complete.  Restart the kernel.
N		 xTaskResumeAll ();
N	 }
N }
N   </pre>
N * \defgroup vTaskSuspendAll vTaskSuspendAll
N * \ingroup SchedulerControl
N */
Nvoid vTaskSuspendAll( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskSuspendAll( void ) ;
N
N/**
N * task. h
N * <pre>BaseType_t xTaskResumeAll( void );</pre>
N *
N * Resumes scheduler activity after it was suspended by a call to
N * vTaskSuspendAll().
N *
N * xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks
N * that were previously suspended by a call to vTaskSuspend().
N *
N * @return If resuming the scheduler caused a context switch then pdTRUE is
N *		  returned, otherwise pdFALSE is returned.
N *
N * Example usage:
N   <pre>
N void vTask1( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // ...
N
N		 // At some point the task wants to perform a long operation during
N		 // which it does not want to get swapped out.  It cannot use
N		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
N		 // operation may cause interrupts to be missed - including the
N		 // ticks.
N
N		 // Prevent the real time kernel swapping out the task.
N		 vTaskSuspendAll ();
N
N		 // Perform the operation here.  There is no need to use critical
N		 // sections as we have all the microcontroller processing time.
N		 // During this time interrupts will still operate and the real
N		 // time kernel tick count will be maintained.
N
N		 // ...
N
N		 // The operation is complete.  Restart the kernel.  We want to force
N		 // a context switch - but there is no point if resuming the scheduler
N		 // caused a context switch already.
N		 if( !xTaskResumeAll () )
N		 {
N			  taskYIELD ();
N		 }
N	 }
N }
N   </pre>
N * \defgroup xTaskResumeAll xTaskResumeAll
N * \ingroup SchedulerControl
N */
NBaseType_t xTaskResumeAll( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskResumeAll( void ) ;
N
N/*-----------------------------------------------------------
N * TASK UTILITIES
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <PRE>TickType_t xTaskGetTickCount( void );</PRE>
N *
N * @return The count of ticks since vTaskStartScheduler was called.
N *
N * \defgroup xTaskGetTickCount xTaskGetTickCount
N * \ingroup TaskUtils
N */
NTickType_t xTaskGetTickCount( void ) PRIVILEGED_FUNCTION;
XTickType_t xTaskGetTickCount( void ) ;
N
N/**
N * task. h
N * <PRE>TickType_t xTaskGetTickCountFromISR( void );</PRE>
N *
N * @return The count of ticks since vTaskStartScheduler was called.
N *
N * This is a version of xTaskGetTickCount() that is safe to be called from an
N * ISR - provided that TickType_t is the natural word size of the
N * microcontroller being used or interrupt nesting is either not supported or
N * not being used.
N *
N * \defgroup xTaskGetTickCountFromISR xTaskGetTickCountFromISR
N * \ingroup TaskUtils
N */
NTickType_t xTaskGetTickCountFromISR( void ) PRIVILEGED_FUNCTION;
XTickType_t xTaskGetTickCountFromISR( void ) ;
N
N/**
N * task. h
N * <PRE>uint16_t uxTaskGetNumberOfTasks( void );</PRE>
N *
N * @return The number of tasks that the real time kernel is currently managing.
N * This includes all ready, blocked and suspended tasks.  A task that
N * has been deleted but not yet freed by the idle task will also be
N * included in the count.
N *
N * \defgroup uxTaskGetNumberOfTasks uxTaskGetNumberOfTasks
N * \ingroup TaskUtils
N */
NUBaseType_t uxTaskGetNumberOfTasks( void ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetNumberOfTasks( void ) ;
N
N/**
N * task. h
N * <PRE>char *pcTaskGetTaskName( TaskHandle_t xTaskToQuery );</PRE>
N *
N * @return The text (human readable) name of the task referenced by the handle
N * xTaskToQuery.  A task can query its own name by either passing in its own
N * handle, or by setting xTaskToQuery to NULL.  INCLUDE_pcTaskGetTaskName must be
N * set to 1 in FreeRTOSConfig.h for pcTaskGetTaskName() to be available.
N *
N * \defgroup pcTaskGetTaskName pcTaskGetTaskName
N * \ingroup TaskUtils
N */
Nchar *pcTaskGetTaskName( TaskHandle_t xTaskToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xchar *pcTaskGetTaskName( TaskHandle_t xTaskToQuery ) ;  
N
N/**
N * task.h
N * <PRE>UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );</PRE>
N *
N * INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for
N * this function to be available.
N *
N * Returns the high water mark of the stack associated with xTask.  That is,
N * the minimum free stack space there has been (in words, so on a 32 bit machine
N * a value of 1 means 4 bytes) since the task started.  The smaller the returned
N * number the closer the task has come to overflowing its stack.
N *
N * @param xTask Handle of the task associated with the stack to be checked.
N * Set xTask to NULL to check the stack of the calling task.
N *
N * @return The smallest amount of free stack space there has been (in words, so
N * actual spaces on the stack rather than bytes) since the task referenced by
N * xTask was created.
N */
NUBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) ;
N
N/* When using trace macros it is sometimes necessary to include task.h before
NFreeRTOS.h.  When this is done TaskHookFunction_t will not yet have been defined,
Nso the following two prototypes will cause a compilation error.  This can be
Nfixed by simply guarding against the inclusion of these two prototypes unless
Nthey are explicitly required by the configUSE_APPLICATION_TASK_TAG configuration
Nconstant. */
N#ifdef configUSE_APPLICATION_TASK_TAG
N	#if configUSE_APPLICATION_TASK_TAG == 1
X	#if 0 == 1
S		/**
S		 * task.h
S		 * <pre>void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction );</pre>
S		 *
S		 * Sets pxHookFunction to be the task hook function used by the task xTask.
S		 * Passing xTask as NULL has the effect of setting the calling tasks hook
S		 * function.
S		 */
S		void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction ) PRIVILEGED_FUNCTION;
S
S		/**
S		 * task.h
S		 * <pre>void xTaskGetApplicationTaskTag( TaskHandle_t xTask );</pre>
S		 *
S		 * Returns the pxHookFunction value assigned to the task xTask.
S		 */
S		TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
N	#endif /* configUSE_APPLICATION_TASK_TAG ==1 */
N#endif /* ifdef configUSE_APPLICATION_TASK_TAG */
N
N#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
X#if( 0 > 0 )
S
S	/* Each task contains an array of pointers that is dimensioned by the
S	configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.  The
S	kernel does not use the pointers itself, so the application writer can use
S	the pointers for any purpose they wish.  The following two functions are
S	used to set and query a pointer respectively. */
S	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue ) PRIVILEGED_FUNCTION;
S	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex ) PRIVILEGED_FUNCTION;
S
N#endif
N
N/**
N * task.h
N * <pre>BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter );</pre>
N *
N * Calls the hook function associated with xTask.  Passing xTask as NULL has
N * the effect of calling the Running tasks (the calling task) hook function.
N *
N * pvParameter is passed to the hook function for the task to interpret as it
N * wants.  The return value is the value returned by the task hook function
N * registered by the user.
N */
NBaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) ;
N
N/**
N * xTaskGetIdleTaskHandle() is only available if
N * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.
N *
N * Simply returns the handle of the idle task.  It is not valid to call
N * xTaskGetIdleTaskHandle() before the scheduler has been started.
N */
NTaskHandle_t xTaskGetIdleTaskHandle( void ) PRIVILEGED_FUNCTION;
XTaskHandle_t xTaskGetIdleTaskHandle( void ) ;
N
N/**
N * configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for
N * uxTaskGetSystemState() to be available.
N *
N * uxTaskGetSystemState() populates an TaskStatus_t structure for each task in
N * the system.  TaskStatus_t structures contain, among other things, members
N * for the task handle, task name, task priority, task state, and total amount
N * of run time consumed by the task.  See the TaskStatus_t structure
N * definition in this file for the full member list.
N *
N * NOTE:  This function is intended for debugging use only as its use results in
N * the scheduler remaining suspended for an extended period.
N *
N * @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures.
N * The array must contain at least one TaskStatus_t structure for each task
N * that is under the control of the RTOS.  The number of tasks under the control
N * of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.
N *
N * @param uxArraySize The size of the array pointed to by the pxTaskStatusArray
N * parameter.  The size is specified as the number of indexes in the array, or
N * the number of TaskStatus_t structures contained in the array, not by the
N * number of bytes in the array.
N *
N * @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in
N * FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the
N * total run time (as defined by the run time stats clock, see
N * http://www.freertos.org/rtos-run-time-stats.html) since the target booted.
N * pulTotalRunTime can be set to NULL to omit the total run time information.
N *
N * @return The number of TaskStatus_t structures that were populated by
N * uxTaskGetSystemState().  This should equal the number returned by the
N * uxTaskGetNumberOfTasks() API function, but will be zero if the value passed
N * in the uxArraySize parameter was too small.
N *
N * Example usage:
N   <pre>
N    // This example demonstrates how a human readable table of run time stats
N	// information is generated from raw data provided by uxTaskGetSystemState().
N	// The human readable table is written to pcWriteBuffer
N	void vTaskGetRunTimeStats( char *pcWriteBuffer )
N	{
N	TaskStatus_t *pxTaskStatusArray;
N	volatile UBaseType_t uxArraySize, x;
N	uint32_t ulTotalRunTime, ulStatsAsPercentage;
N
N		// Make sure the write buffer does not contain a string.
N		*pcWriteBuffer = 0x00;
N
N		// Take a snapshot of the number of tasks in case it changes while this
N		// function is executing.
N		uxArraySize = uxTaskGetNumberOfTasks();
N
N		// Allocate a TaskStatus_t structure for each task.  An array could be
N		// allocated statically at compile time.
N		pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );
N
N		if( pxTaskStatusArray != NULL )
N		{
N			// Generate raw status information about each task.
N			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );
N
N			// For percentage calculations.
N			ulTotalRunTime /= 100UL;
N
N			// Avoid divide by zero errors.
N			if( ulTotalRunTime > 0 )
N			{
N				// For each populated position in the pxTaskStatusArray array,
N				// format the raw data as human readable ASCII data
N				for( x = 0; x < uxArraySize; x++ )
N				{
N					// What percentage of the total run time has the task used?
N					// This will always be rounded down to the nearest integer.
N					// ulTotalRunTimeDiv100 has already been divided by 100.
N					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;
N
N					if( ulStatsAsPercentage > 0UL )
N					{
N						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
N					}
N					else
N					{
N						// If the percentage is zero here then the task has
N						// consumed less than 1% of the total run time.
N						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );
N					}
N
N					pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );
N				}
N			}
N
N			// The array is no longer needed, free the memory it consumes.
N			vPortFree( pxTaskStatusArray );
N		}
N	}
N	</pre>
N */
NUBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) ;
N
N/**
N * task. h
N * <PRE>void vTaskList( char *pcWriteBuffer );</PRE>
N *
N * configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must
N * both be defined as 1 for this function to be available.  See the
N * configuration section of the FreeRTOS.org website for more information.
N *
N * NOTE 1: This function will disable interrupts for its duration.  It is
N * not intended for normal application runtime use but as a debug aid.
N *
N * Lists all the current tasks, along with their current state and stack
N * usage high water mark.
N *
N * Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or
N * suspended ('S').
N *
N * PLEASE NOTE:
N *
N * This function is provided for convenience only, and is used by many of the
N * demo applications.  Do not consider it to be part of the scheduler.
N *
N * vTaskList() calls uxTaskGetSystemState(), then formats part of the
N * uxTaskGetSystemState() output into a human readable table that displays task
N * names, states and stack usage.
N *
N * vTaskList() has a dependency on the sprintf() C library function that might
N * bloat the code size, use a lot of stack, and provide different results on
N * different platforms.  An alternative, tiny, third party, and limited
N * functionality implementation of sprintf() is provided in many of the
N * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
N * printf-stdarg.c does not provide a full snprintf() implementation!).
N *
N * It is recommended that production systems call uxTaskGetSystemState()
N * directly to get access to raw stats data, rather than indirectly through a
N * call to vTaskList().
N *
N * @param pcWriteBuffer A buffer into which the above mentioned details
N * will be written, in ASCII form.  This buffer is assumed to be large
N * enough to contain the generated report.  Approximately 40 bytes per
N * task should be sufficient.
N *
N * \defgroup vTaskList vTaskList
N * \ingroup TaskUtils
N */
Nvoid vTaskList( char * pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xvoid vTaskList( char * pcWriteBuffer ) ;  
N
N/**
N * task. h
N * <PRE>void vTaskGetRunTimeStats( char *pcWriteBuffer );</PRE>
N *
N * configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS
N * must both be defined as 1 for this function to be available.  The application
N * must also then provide definitions for
N * portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()
N * to configure a peripheral timer/counter and return the timers current count
N * value respectively.  The counter should be at least 10 times the frequency of
N * the tick count.
N *
N * NOTE 1: This function will disable interrupts for its duration.  It is
N * not intended for normal application runtime use but as a debug aid.
N *
N * Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total
N * accumulated execution time being stored for each task.  The resolution
N * of the accumulated time value depends on the frequency of the timer
N * configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.
N * Calling vTaskGetRunTimeStats() writes the total execution time of each
N * task into a buffer, both as an absolute count value and as a percentage
N * of the total system execution time.
N *
N * NOTE 2:
N *
N * This function is provided for convenience only, and is used by many of the
N * demo applications.  Do not consider it to be part of the scheduler.
N *
N * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the
N * uxTaskGetSystemState() output into a human readable table that displays the
N * amount of time each task has spent in the Running state in both absolute and
N * percentage terms.
N *
N * vTaskGetRunTimeStats() has a dependency on the sprintf() C library function
N * that might bloat the code size, use a lot of stack, and provide different
N * results on different platforms.  An alternative, tiny, third party, and
N * limited functionality implementation of sprintf() is provided in many of the
N * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
N * printf-stdarg.c does not provide a full snprintf() implementation!).
N *
N * It is recommended that production systems call uxTaskGetSystemState() directly
N * to get access to raw stats data, rather than indirectly through a call to
N * vTaskGetRunTimeStats().
N *
N * @param pcWriteBuffer A buffer into which the execution times will be
N * written, in ASCII form.  This buffer is assumed to be large enough to
N * contain the generated report.  Approximately 40 bytes per task should
N * be sufficient.
N *
N * \defgroup vTaskGetRunTimeStats vTaskGetRunTimeStats
N * \ingroup TaskUtils
N */
Nvoid vTaskGetRunTimeStats( char *pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xvoid vTaskGetRunTimeStats( char *pcWriteBuffer ) ;  
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param ulValue Data that can be sent with the notification.  How the data is
N * used depends on the value of the eAction parameter.
N *
N * @param eAction Specifies how the notification updates the task's notification
N * value, if at all.  Valid values for eAction are as follows:
N *
N * eSetBits -
N * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
N * always returns pdPASS in this case.
N *
N * eIncrement -
N * The task's notification value is incremented.  ulValue is not used and
N * xTaskNotify() always returns pdPASS in this case.
N *
N * eSetValueWithOverwrite -
N * The task's notification value is set to the value of ulValue, even if the
N * task being notified had not yet processed the previous notification (the
N * task already had a notification pending).  xTaskNotify() always returns
N * pdPASS in this case.
N *
N * eSetValueWithoutOverwrite -
N * If the task being notified did not already have a notification pending then
N * the task's notification value is set to ulValue and xTaskNotify() will
N * return pdPASS.  If the task being notified already had a notification
N * pending then no action is performed and pdFAIL is returned.
N *
N * eNoAction -
N * The task receives a notification without its notification value being
N * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
N * this case.
N *
N *  pulPreviousNotificationValue -
N *  Can be used to pass out the subject task's notification value before any
N *  bits are modified by the notify function.
N *
N * @return Dependent on the value of eAction.  See the description of the
N * eAction parameter.
N *
N * \defgroup xTaskNotify xTaskNotify
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) ;
N#define xTaskNotify( xTaskToNotify, ulValue, eAction ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL )
N#define xTaskNotifyAndQuery( xTaskToNotify, ulValue, eAction, pulPreviousNotifyValue ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotifyValue ) )
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * A version of xTaskNotify() that can be used from an interrupt service routine
N * (ISR).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param ulValue Data that can be sent with the notification.  How the data is
N * used depends on the value of the eAction parameter.
N *
N * @param eAction Specifies how the notification updates the task's notification
N * value, if at all.  Valid values for eAction are as follows:
N *
N * eSetBits -
N * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
N * always returns pdPASS in this case.
N *
N * eIncrement -
N * The task's notification value is incremented.  ulValue is not used and
N * xTaskNotify() always returns pdPASS in this case.
N *
N * eSetValueWithOverwrite -
N * The task's notification value is set to the value of ulValue, even if the
N * task being notified had not yet processed the previous notification (the
N * task already had a notification pending).  xTaskNotify() always returns
N * pdPASS in this case.
N *
N * eSetValueWithoutOverwrite -
N * If the task being notified did not already have a notification pending then
N * the task's notification value is set to ulValue and xTaskNotify() will
N * return pdPASS.  If the task being notified already had a notification
N * pending then no action is performed and pdFAIL is returned.
N *
N * eNoAction -
N * The task receives a notification without its notification value being
N * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
N * this case.
N *
N * @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
N * task to which the notification was sent to leave the Blocked state, and the
N * unblocked task has a priority higher than the currently running task.  If
N * xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should
N * be requested before the interrupt is exited.  How a context switch is
N * requested from an ISR is dependent on the port - see the documentation page
N * for the port in use.
N *
N * @return Dependent on the value of eAction.  See the description of the
N * eAction parameter.
N *
N * \defgroup xTaskNotify xTaskNotify
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) ;
N#define xTaskNotifyFromISR( xTaskToNotify, ulValue, eAction, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL, ( pxHigherPriorityTaskWoken ) )
N#define xTaskNotifyAndQueryFromISR( xTaskToNotify, ulValue, eAction, pulPreviousNotificationValue, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotificationValue ), ( pxHigherPriorityTaskWoken ) )
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );</pre>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value
N * will be cleared in the calling task's notification value before the task
N * checks to see if any notifications are pending, and optionally blocks if no
N * notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if
N * limits.h is included) or 0xffffffffUL (if limits.h is not included) will have
N * the effect of resetting the task's notification value to 0.  Setting
N * ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged.
N *
N * @param ulBitsToClearOnExit If a notification is pending or received before
N * the calling task exits the xTaskNotifyWait() function then the task's
N * notification value (see the xTaskNotify() API function) is passed out using
N * the pulNotificationValue parameter.  Then any bits that are set in
N * ulBitsToClearOnExit will be cleared in the task's notification value (note
N * *pulNotificationValue is set before any bits are cleared).  Setting
N * ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL
N * (if limits.h is not included) will have the effect of resetting the task's
N * notification value to 0 before the function exits.  Setting
N * ulBitsToClearOnExit to 0 will leave the task's notification value unchanged
N * when the function exits (in which case the value passed out in
N * pulNotificationValue will match the task's notification value).
N *
N * @param pulNotificationValue Used to pass the task's notification value out
N * of the function.  Note the value passed out will not be effected by the
N * clearing of any bits caused by ulBitsToClearOnExit being non-zero.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait in
N * the Blocked state for a notification to be received, should a notification
N * not already be pending when xTaskNotifyWait() was called.  The task
N * will not consume any processing time while it is in the Blocked state.  This
N * is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be
N * used to convert a time specified in milliseconds to a time specified in
N * ticks.
N *
N * @return If a notification was received (including notifications that were
N * already pending when xTaskNotifyWait was called) then pdPASS is
N * returned.  Otherwise pdFAIL is returned.
N *
N * \defgroup xTaskNotifyWait xTaskNotifyWait
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) ;
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyGive( TaskHandle_t xTaskToNotify );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
N * to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * xTaskNotifyGive() is a helper macro intended for use when task notifications
N * are used as light weight and faster binary or counting semaphore equivalents.
N * Actual FreeRTOS semaphores are given using the xSemaphoreGive() API function,
N * the equivalent action that instead uses a task notification is
N * xTaskNotifyGive().
N *
N * When task notifications are being used as a binary or counting semaphore
N * equivalent then the task being notified should wait for the notification
N * using the ulTaskNotificationTake() API function rather than the
N * xTaskNotifyWait() API function.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @return xTaskNotifyGive() is a macro that calls xTaskNotify() with the
N * eAction parameter set to eIncrement - so pdPASS is always returned.
N *
N * \defgroup xTaskNotifyGive xTaskNotifyGive
N * \ingroup TaskNotifications
N */
N#define xTaskNotifyGive( xTaskToNotify ) xTaskGenericNotify( ( xTaskToNotify ), ( 0 ), eIncrement, NULL )
N
N/**
N * task. h
N * <PRE>void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
N * to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * A version of xTaskNotifyGive() that can be called from an interrupt service
N * routine (ISR).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * vTaskNotifyGiveFromISR() is intended for use when task notifications are
N * used as light weight and faster binary or counting semaphore equivalents.
N * Actual FreeRTOS semaphores are given from an ISR using the
N * xSemaphoreGiveFromISR() API function, the equivalent action that instead uses
N * a task notification is vTaskNotifyGiveFromISR().
N *
N * When task notifications are being used as a binary or counting semaphore
N * equivalent then the task being notified should wait for the notification
N * using the ulTaskNotificationTake() API function rather than the
N * xTaskNotifyWait() API function.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
N * task to which the notification was sent to leave the Blocked state, and the
N * unblocked task has a priority higher than the currently running task.  If
N * vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch
N * should be requested before the interrupt is exited.  How a context switch is
N * requested from an ISR is dependent on the port - see the documentation page
N * for the port in use.
N *
N * \defgroup xTaskNotifyWait xTaskNotifyWait
N * \ingroup TaskNotifications
N */
Nvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
Xvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) ;
N
N/**
N * task. h
N * <PRE>uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );</pre>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * ulTaskNotifyTake() is intended for use when a task notification is used as a
N * faster and lighter weight binary or counting semaphore alternative.  Actual
N * FreeRTOS semaphores are taken using the xSemaphoreTake() API function, the
N * equivalent action that instead uses a task notification is
N * ulTaskNotifyTake().
N *
N * When a task is using its notification value as a binary or counting semaphore
N * other tasks should send notifications to it using the xTaskNotifyGive()
N * macro, or xTaskNotify() function with the eAction parameter set to
N * eIncrement.
N *
N * ulTaskNotifyTake() can either clear the task's notification value to
N * zero on exit, in which case the notification value acts like a binary
N * semaphore, or decrement the task's notification value on exit, in which case
N * the notification value acts like a counting semaphore.
N *
N * A task can use ulTaskNotifyTake() to [optionally] block to wait for a
N * the task's notification value to be non-zero.  The task does not consume any
N * CPU time while it is in the Blocked state.
N *
N * Where as xTaskNotifyWait() will return when a notification is pending,
N * ulTaskNotifyTake() will return when the task's notification value is
N * not zero.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's
N * notification value is decremented when the function exits.  In this way the
N * notification value acts like a counting semaphore.  If xClearCountOnExit is
N * not pdFALSE then the task's notification value is cleared to zero when the
N * function exits.  In this way the notification value acts like a binary
N * semaphore.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait in
N * the Blocked state for the task's notification value to be greater than zero,
N * should the count not already be greater than zero when
N * ulTaskNotifyTake() was called.  The task will not consume any processing
N * time while it is in the Blocked state.  This is specified in kernel ticks,
N * the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time
N * specified in milliseconds to a time specified in ticks.
N *
N * @return The task's notification count before it is either cleared to zero or
N * decremented (see the xClearCountOnExit parameter).
N *
N * \defgroup ulTaskNotifyTake ulTaskNotifyTake
N * \ingroup TaskNotifications
N */
Nuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) ;
N
N/*-----------------------------------------------------------
N * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
N *----------------------------------------------------------*/
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
N * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
N * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * Called from the real time kernel tick (either preemptive or cooperative),
N * this increments the tick count and checks if any tasks that are blocked
N * for a finite period required removing from a blocked list and placing on
N * a ready list.  If a non-zero value is returned then a context switch is
N * required because either:
N *   + A task was removed from a blocked list because its timeout had expired,
N *     or
N *   + Time slicing is in use and there is a task of equal priority to the
N *     currently running task.
N */
NBaseType_t xTaskIncrementTick( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskIncrementTick( void ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * Removes the calling task from the ready list and places it both
N * on the list of tasks waiting for a particular event, and the
N * list of delayed tasks.  The task will be removed from both lists
N * and replaced on the ready list should either the event occur (and
N * there be no higher priority tasks waiting on the same event) or
N * the delay period expires.
N *
N * The 'unordered' version replaces the event list item value with the
N * xItemValue value, and inserts the list item at the end of the list.
N *
N * The 'ordered' version uses the existing event list item value (which is the
N * owning tasks priority) to insert the list item into the event list is task
N * priority order.
N *
N * @param pxEventList The list containing tasks that are blocked waiting
N * for the event to occur.
N *
N * @param xItemValue The item value to use for the event list item when the
N * event list is not ordered by task priority.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait
N * for the event to occur.  This is specified in kernel ticks,the constant
N * portTICK_PERIOD_MS can be used to convert kernel ticks into a real time
N * period.
N */
Nvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) ;
Nvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * This function performs nearly the same function as vTaskPlaceOnEventList().
N * The difference being that this function does not permit tasks to block
N * indefinitely, whereas vTaskPlaceOnEventList() does.
N *
N */
Nvoid vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * Removes a task from both the specified event list and the list of blocked
N * tasks, and places it on a ready queue.
N *
N * xTaskRemoveFromEventList()/xTaskRemoveFromUnorderedEventList() will be called
N * if either an event occurs to unblock a task, or the block timeout period
N * expires.
N *
N * xTaskRemoveFromEventList() is used when the event list is in task priority
N * order.  It removes the list item from the head of the event list as that will
N * have the highest priority owning task of all the tasks on the event list.
N * xTaskRemoveFromUnorderedEventList() is used when the event list is not
N * ordered and the event list items hold something other than the owning tasks
N * priority.  In this case the event list item value is updated to the value
N * passed in the xItemValue parameter.
N *
N * @return pdTRUE if the task being removed has a higher priority than the task
N * making the call, otherwise pdFALSE.
N */
NBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) ;
NBaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
N * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
N * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * Sets the pointer to the current TCB to the TCB of the highest priority task
N * that is ready to run.
N */
Nvoid vTaskSwitchContext( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskSwitchContext( void ) ;
N
N/*
N * THESE FUNCTIONS MUST NOT BE USED FROM APPLICATION CODE.  THEY ARE USED BY
N * THE EVENT BITS MODULE.
N */
NTickType_t uxTaskResetEventItemValue( void ) PRIVILEGED_FUNCTION;
XTickType_t uxTaskResetEventItemValue( void ) ;
N
N/*
N * Return the handle of the calling task.
N */
NTaskHandle_t xTaskGetCurrentTaskHandle( void ) PRIVILEGED_FUNCTION;
XTaskHandle_t xTaskGetCurrentTaskHandle( void ) ;
N
N/*
N * Capture the current time status for future reference.
N */
Nvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;
Xvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) ;
N
N/*
N * Compare the time status now with that previously captured to see if the
N * timeout has expired.
N */
NBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) ;
N
N/*
N * Shortcut used by the queue implementation to prevent unnecessary call to
N * taskYIELD();
N */
Nvoid vTaskMissedYield( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskMissedYield( void ) ;
N
N/*
N * Returns the scheduler state as taskSCHEDULER_RUNNING,
N * taskSCHEDULER_NOT_STARTED or taskSCHEDULER_SUSPENDED.
N */
NBaseType_t xTaskGetSchedulerState( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGetSchedulerState( void ) ;
N
N/*
N * Raises the priority of the mutex holder to that of the calling task should
N * the mutex holder have a priority less than the calling task.
N */
Nvoid vTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
Xvoid vTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) ;
N
N/*
N * Set the priority of a task back to its proper priority in the case that it
N * inherited a higher priority while it was holding a semaphore.
N */
NBaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) ;
N
N/*
N * Generic version of the task creation function which is in turn called by the
N * xTaskCreate() and xTaskCreateRestricted() macros.
N */
NBaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
XBaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) ;  
N
N/*
N * Get the uxTCBNumber assigned to the task referenced by the xTask parameter.
N */
NUBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) ;
N
N/*
N * Set the uxTaskNumber of the task referenced by the xTask parameter to
N * uxHandle.
N */
Nvoid vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) PRIVILEGED_FUNCTION;
Xvoid vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) ;
N
N/*
N * Only available when configUSE_TICKLESS_IDLE is set to 1.
N * If tickless mode is being used, or a low power mode is implemented, then
N * the tick interrupt will not execute during idle periods.  When this is the
N * case, the tick count value maintained by the scheduler needs to be kept up
N * to date with the actual execution time by being skipped forward by a time
N * equal to the idle period.
N */
Nvoid vTaskStepTick( const TickType_t xTicksToJump ) PRIVILEGED_FUNCTION;
Xvoid vTaskStepTick( const TickType_t xTicksToJump ) ;
N
N/*
N * Only avilable when configUSE_TICKLESS_IDLE is set to 1.
N * Provided for use within portSUPPRESS_TICKS_AND_SLEEP() to allow the port
N * specific sleep function to determine if it is ok to proceed with the sleep,
N * and if it is ok to proceed, if it is ok to sleep indefinitely.
N *
N * This function is necessary because portSUPPRESS_TICKS_AND_SLEEP() is only
N * called with the scheduler suspended, not from within a critical section.  It
N * is therefore possible for an interrupt to request a context switch between
N * portSUPPRESS_TICKS_AND_SLEEP() and the low power mode actually being
N * entered.  eTaskConfirmSleepModeStatus() should be called from a short
N * critical section between the timer being stopped and the sleep mode being
N * entered to ensure it is ok to proceed into the sleep mode.
N */
NeSleepModeStatus eTaskConfirmSleepModeStatus( void ) PRIVILEGED_FUNCTION;
XeSleepModeStatus eTaskConfirmSleepModeStatus( void ) ;
N
N/*
N * For internal use only.  Increment the mutex held count when a mutex is
N * taken and return the handle of the task that has taken the mutex.
N */
Nvoid *pvTaskIncrementMutexHeldCount( void ) PRIVILEGED_FUNCTION;
Xvoid *pvTaskIncrementMutexHeldCount( void ) ;
N
N#ifdef __cplusplus
S}
N#endif
N#endif /* INC_TASK_H */
N
N
N
L 82 "..\..\FreeRTOS\Source\tasks.c" 2
N#include "timers.h"
L 1 "..\..\Lwip\lwip-1.4.1\src\include\lwip\timers.h" 1
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *         Simon Goldschmidt
N *
N */
N#ifndef __LWIP_TIMERS_H__
N#define __LWIP_TIMERS_H__
N
N#include "lwip/opt.h"
L 1 "..\..\Lwip\lwip-1.4.1\src\include\lwip/opt.h" 1
N/**
N * @file
N *
N * lwIP Options Configuration
N */
N
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_OPT_H__
N#define __LWIP_OPT_H__
N
N/*
N * Include user defined options first. Anything not defined in these files
N * will be set to standard values. Override anything you dont like!
N */
N#include "lwipopts.h"
L 1 "..\..\Lwip\App\lwipopts.h" 1
N/**
N  ******************************************************************************
N  * @file    lwipopts.h
N  * @author  MCD Application Team
N  * @version V1.1.0
N  * @date    31-July-2013
N  * @brief   lwIP Options Configuration.
N  *          This file is based on Utilities\lwip_v1.4.1\src\include\lwip\opt.h 
N  *          and contains the lwIP configuration for the STM32F4x7 demonstration.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N#ifndef __LWIPOPTS_H__
N#define __LWIPOPTS_H__
N
N/**
N * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
N * critical regions during buffer allocation, deallocation and memory
N * allocation and deallocation.
N */
N#define SYS_LIGHTWEIGHT_PROT    0
N
N/**
N * NO_SYS==1: Provides VERY minimal functionality. Otherwise,
N * use lwIP facilities.
N */
N#define NO_SYS                  1
N
N/**
N * NO_SYS_NO_TIMERS==1: Drop support for sys_timeout when NO_SYS==1
N * Mainly for compatibility to old versions.
N */
N#define NO_SYS_NO_TIMERS        1
N
N/* ---------- Memory options ---------- */
N/* MEM_ALIGNMENT: should be set to the alignment of the CPU for which
N   lwIP is compiled. 4 byte alignment -> define MEM_ALIGNMENT to 4, 2
N   byte alignment -> define MEM_ALIGNMENT to 2. */
N#define MEM_ALIGNMENT           4
N
N/* MEM_SIZE: the size of the heap memory. If the application will send
Na lot of data that needs to be copied, this should be set high. */
N#define MEM_SIZE                (20*1024)
N
N/* MEMP_NUM_PBUF: the number of memp struct pbufs. If the application
N   sends a lot of data out of ROM (or other static memory), this
N   should be set high. */
N//#define MEMP_NUM_PBUF           100
N/* MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
N   per active UDP "connection". */
N#define MEMP_NUM_UDP_PCB        12
N/* MEMP_NUM_TCP_PCB: the number of simulatenously active TCP
N   connections. */
N#define MEMP_NUM_TCP_PCB        6
N/* MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP
N   connections. */
N#define MEMP_NUM_TCP_PCB_LISTEN  1
N/* MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP
N   segments. */
N#define MEMP_NUM_TCP_SEG        40
N/* MEMP_NUM_SYS_TIMEOUT: the number of simulateously active
N   timeouts. */
N#define MEMP_NUM_SYS_TIMEOUT    10
N
N
N/* ---------- Pbuf options ---------- */
N/* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */
N#define PBUF_POOL_SIZE          8
N
N/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
N#define PBUF_POOL_BUFSIZE       (1500 - 40)/* TCP_MSS = (Ethernet MTU - IP header size - TCP header size) */
N
N#define LWIP_DNS                 1
N
N/* ---------- TCP options ---------- */
N#define LWIP_TCP                1
N#define TCP_TTL                 255
N
N/* Controls if TCP should queue segments that arrive out of
N   order. Define to 0 if your device is low on memory. */
N#define TCP_QUEUE_OOSEQ         1
N
N/* TCP Maximum segment size. */
N#define TCP_MSS                 (1500 - 140)/* TCP_MSS = (Ethernet MTU - IP header size - TCP header size) */
N
N/* TCP sender buffer space (bytes). */
N#define TCP_SND_BUF             (4*TCP_MSS)
N
N/*  TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least
N  as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work. */
N
N#define TCP_SND_QUEUELEN        (4* TCP_SND_BUF/TCP_MSS)
N
N/* TCP receive window. */
N#define TCP_WND                 (2*TCP_MSS)
N
N
N/* ---------- ICMP options ---------- */
N#define LWIP_ICMP                       1
N
N#define LWIP_ARP                  1 //1
N/* ---------- DHCP options ---------- */
N/* Define LWIP_DHCP to 1 if you want DHCP configuration of
N   interfaces. DHCP is not implemented in lwIP 0.5.1, however, so
N   turning this on does currently not work. */
N#define LWIP_DHCP               1
N
N
N/* ---------- UDP options ---------- */
N#define LWIP_UDP                1
N#define UDP_TTL                 255
N/* ---------- DNS options ---------- */
N#define DNS_TABLE_SIZE               10
N#define DNS_LOCAL_HOSTLIST_IS_DYNAMIC   1
N#define DNS_MAX_TTL               604800//
N/* ---------- Statistics options ---------- */
N#define LWIP_STATS 0
N#define LWIP_PROVIDE_ERRNO     1
N
N/* ---------- link callback options ---------- */
N/* LWIP_NETIF_LINK_CALLBACK==1: Support a callback function from an interface
N * whenever the link changes (i.e., link down)
N */
N#define LWIP_NETIF_LINK_CALLBACK        1
N
N/*
N   --------------------------------------
N   ---------- Checksum options ----------
N   --------------------------------------
N*/
N
N/* 
NThe STM32F4x7 allows computing and verifying the IP, UDP, TCP and ICMP checksums by hardware:
N - To use this feature let the following define uncommented.
N - To disable it and process by CPU comment the  the checksum.
N*/
N#define CHECKSUM_BY_HARDWARE 
N
N
N#ifdef CHECKSUM_BY_HARDWARE
N  /* CHECKSUM_GEN_IP==0: Generate checksums by hardware for outgoing IP packets.*/
N  #define CHECKSUM_GEN_IP                 0
N  /* CHECKSUM_GEN_UDP==0: Generate checksums by hardware for outgoing UDP packets.*/
N  #define CHECKSUM_GEN_UDP                0
N  /* CHECKSUM_GEN_TCP==0: Generate checksums by hardware for outgoing TCP packets.*/
N  #define CHECKSUM_GEN_TCP                0 
N  /* CHECKSUM_CHECK_IP==0: Check checksums by hardware for incoming IP packets.*/
N  #define CHECKSUM_CHECK_IP               0
N  /* CHECKSUM_CHECK_UDP==0: Check checksums by hardware for incoming UDP packets.*/
N  #define CHECKSUM_CHECK_UDP              0
N  /* CHECKSUM_CHECK_TCP==0: Check checksums by hardware for incoming TCP packets.*/
N  #define CHECKSUM_CHECK_TCP              0
N  /* CHECKSUM_CHECK_ICMP==0: Check checksums by hardware for incoming ICMP packets.*/
N  #define CHECKSUM_GEN_ICMP               0
N#else
S  /* CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.*/
S  #define CHECKSUM_GEN_IP                 1
S  /* CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.*/
S  #define CHECKSUM_GEN_UDP                1
S  /* CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.*/
S  #define CHECKSUM_GEN_TCP                1
S  /* CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.*/
S  #define CHECKSUM_CHECK_IP               1
S  /* CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.*/
S  #define CHECKSUM_CHECK_UDP              1
S  /* CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.*/
S  #define CHECKSUM_CHECK_TCP              1
S  /* CHECKSUM_CHECK_ICMP==1: Check checksums by hardware for incoming ICMP packets.*/
S  #define CHECKSUM_GEN_ICMP               1
N#endif
N
N
N/*
N   ----------------------------------------------
N   ---------- Sequential layer options ----------
N   ----------------------------------------------
N*/
N/**
N * LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c)
N */
N#define LWIP_NETCONN                    0
N
N/*
N   ------------------------------------
N   ---------- Socket options ----------
N   ------------------------------------
N*/
N/**
N * LWIP_SOCKET==1: Enable Socket API (require to use sockets.c)
N */
N#define LWIP_SOCKET                     0
N
N#if 0
S/*
S   ----------------------------------------
S   ---------- Lwip Debug options ----------
S   ----------------------------------------
S*/
S//#define LWIP_DEBUG                      1
S#ifndef U8_F
S#define U8_F "c"
S#endif
S
S#ifndef S8_F
S#define S8_F "c"
S#endif
S
S#ifndef X8_F
S#define X8_F "x"
S#endif
S
S#ifndef U16_F
S#define U16_F "u"
S#endif
S
S#ifndef S16_F
S#define S16_F "d"
S#endif
S
S#ifndef X16_F
S#define X16_F "x"
S#endif
S#ifndef U32_F
S#define U32_F "u"
S#endif
S#ifndef S32_F
S#define S32_F "d"
S#endif
S#ifndef X32_F
S#define X32_F "x"
S#endif
S
S
S//extern void UARTprintf(const char *pcString, ...);
S#define LWIP_PLATFORM_DIAG(x) {printf(x);}
S#define LWIP_DEBUG
S
S
S
S#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_OFF
S//#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_WARNING
S//#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_SERIOUS
S//#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_SEVERE
S
S//#define LWIP_DBG_TYPES_ON               LWIP_DBG_ON
S#define LWIP_DBG_TYPES_ON               (LWIP_DBG_ON|LWIP_DBG_TRACE|LWIP_DBG_STATE|LWIP_DBG_FRESH)
S
S//#define ETHARP_DEBUG                    LWIP_DBG_ON     
S//#define NETIF_DEBUG                     LWIP_DBG_ON     
S//#define PBUF_DEBUG                      LWIP_DBG_ON
S//#define API_LIB_DEBUG                   LWIP_DBG_ON
S//#define API_MSG_DEBUG                   LWIP_DBG_ON
S//#define SOCKETS_DEBUG                   LWIP_DBG_ON
S//#define ICMP_DEBUG                      LWIP_DBG_ON
S//#define IGMP_DEBUG                      LWIP_DBG_ON
S//#define INET_DEBUG                      LWIP_DBG_ON
S#define IP_DEBUG                        LWIP_DBG_ON     
S//#define IP_REASS_DEBUG                  LWIP_DBG_ON
S//#define RAW_DEBUG                       LWIP_DBG_ON
S//#define MEM_DEBUG                       LWIP_DBG_ON
S//#define MEMP_DEBUG                      LWIP_DBG_ON
S//#define SYS_DEBUG                       LWIP_DBG_ON
S#define TCP_DEBUG                       LWIP_DBG_ON
S//#define TCP_INPUT_DEBUG                 LWIP_DBG_ON
S//#define TCP_FR_DEBUG                    LWIP_DBG_ON
S//#define TCP_RTO_DEBUG                   LWIP_DBG_ON
S//#define TCP_CWND_DEBUG                  LWIP_DBG_ON
S//#define TCP_WND_DEBUG                   LWIP_DBG_ON
S#define TCP_OUTPUT_DEBUG                LWIP_DBG_ON
S//#define TCP_RST_DEBUG                   LWIP_DBG_ON
S//#define TCP_QLEN_DEBUG                  LWIP_DBG_ON
S//#define UDP_DEBUG                       LWIP_DBG_ON     
S//#define TCPIP_DEBUG                     LWIP_DBG_ON
S//#define PPP_DEBUG                       LWIP_DBG_ON
S//#define SLIP_DEBUG                      LWIP_DBG_ON
S//#define DHCP_DEBUG                      LWIP_DBG_ON     
S//#define AUTOIP_DEBUG                    LWIP_DBG_ON
S//#define SNMP_MSG_DEBUG                  LWIP_DBG_ON
S//#define SNMP_MIB_DEBUG                  LWIP_DBG_ON
S//#define DNS_DEBUG                       LWIP_DBG_ON
N#endif
N#endif /* __LWIPOPTS_H__ */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 46 "..\..\Lwip\lwip-1.4.1\src\include\lwip/opt.h" 2
N#include "lwip/debug.h"
L 1 "..\..\Lwip\lwip-1.4.1\src\include\lwip/debug.h" 1
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_DEBUG_H__
N#define __LWIP_DEBUG_H__
N
N#include "lwip/arch.h"
L 1 "..\..\Lwip\lwip-1.4.1\src\include\lwip/arch.h" 1
N/*
N * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __LWIP_ARCH_H__
N#define __LWIP_ARCH_H__
N
N#ifndef LITTLE_ENDIAN
N#define LITTLE_ENDIAN 1234
N#endif
N
N#ifndef BIG_ENDIAN
N#define BIG_ENDIAN 4321
N#endif
N
N#include "arch/cc.h"
L 1 "..\..\Lwip\lwip-1.4.1\port\arch/cc.h" 1
N/*
N * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __CC_H__
N#define __CC_H__
N
N#include "cpu.h"
L 1 "..\..\Lwip\lwip-1.4.1\port\arch/cpu.h" 1
N/*
N * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
N * All rights reserved. 
N * 
N * Redistribution and use in source and binary forms, with or without modification, 
N * are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote products
N *    derived from this software without specific prior written permission. 
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
N * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
N * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
N * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
N * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
N * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
N * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
N * OF SUCH DAMAGE.
N *
N * This file is part of the lwIP TCP/IP stack.
N * 
N * Author: Adam Dunkels <adam@sics.se>
N *
N */
N#ifndef __CPU_H__
N#define __CPU_H__
N
N#define BYTE_ORDER LITTLE_ENDIAN
N
N#endif /* __CPU_H__ */
L 36 "..\..\Lwip\lwip-1.4.1\port\arch/cc.h" 2
N
Ntypedef unsigned   char    u8_t;
Ntypedef signed     char    s8_t;
Ntypedef unsigned   short   u16_t;
Ntypedef signed     short   s16_t;
Ntypedef unsigned   long    u32_t;
Ntypedef signed     long    s32_t;
Ntypedef u32_t mem_ptr_t;
Ntypedef int sys_prot_t;
N
N#ifndef U16_F
N#define U16_F "hu"
N#endif
N
N#ifndef S16_F
N#define S16_F "d"
N#endif
N
N#ifndef X16_F
N#define X16_F "hx"
N#endif
N
N#ifndef U32_F
N#define U32_F "u"
N#endif
N
N#ifndef S32_F
N#define S32_F "d"
N#endif
N
N#ifndef X32_F
N#define X32_F "x"
N#endif
N
N#ifndef SZT_F
N#define SZT_F "uz" 
N#endif
N
N
N
N
N
N
N
N
N
N/* define compiler specific symbols */
N#if defined (__ICCARM__)
X#if 0L
S
S#define PACK_STRUCT_BEGIN
S#define PACK_STRUCT_STRUCT 
S#define PACK_STRUCT_END
S#define PACK_STRUCT_FIELD(x) x
S#define PACK_STRUCT_USE_INCLUDES
S
N#elif defined (__CC_ARM)
X#elif 1L
N
N#define PACK_STRUCT_BEGIN __packed
N#define PACK_STRUCT_STRUCT 
N#define PACK_STRUCT_END
N#define PACK_STRUCT_FIELD(x) x
N
N#elif defined (__GNUC__)
S
S#define PACK_STRUCT_BEGIN
S#define PACK_STRUCT_STRUCT __attribute__ ((__packed__))
S#define PACK_STRUCT_END
S#define PACK_STRUCT_FIELD(x) x
S
S#elif defined (__TASKING__)
S
S#define PACK_STRUCT_BEGIN
S#define PACK_STRUCT_STRUCT
S#define PACK_STRUCT_END
S#define PACK_STRUCT_FIELD(x) x
S
N#endif
N
N#define LWIP_PLATFORM_ASSERT(x) printf(x)
N
N#endif /* __CC_H__ */
L 44 "..\..\Lwip\lwip-1.4.1\src\include\lwip/arch.h" 2
N
N/** Temporary: define format string for size_t if not defined in cc.h */
N#ifndef SZT_F
S#define SZT_F U32_F
N#endif /* SZT_F */
N/** Temporary upgrade helper: define format string for u8_t as hex if not
N    defined in cc.h */
N#ifndef X8_F
N#define X8_F  "02x"
N#endif /* X8_F */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#ifndef PACK_STRUCT_BEGIN
S#define PACK_STRUCT_BEGIN
N#endif /* PACK_STRUCT_BEGIN */
N
N#ifndef PACK_STRUCT_END
S#define PACK_STRUCT_END
N#endif /* PACK_STRUCT_END */
N
N#ifndef PACK_STRUCT_FIELD
S#define PACK_STRUCT_FIELD(x) x
N#endif /* PACK_STRUCT_FIELD */
N
N
N#ifndef LWIP_UNUSED_ARG
N#define LWIP_UNUSED_ARG(x) (void)x
N#endif /* LWIP_UNUSED_ARG */ 
N
N
N#ifdef LWIP_PROVIDE_ERRNO
N
N#define  EPERM         1  /* Operation not permitted */
N#define  ENOENT        2  /* No such file or directory */
N#define  ESRCH         3  /* No such process */
N#define  EINTR         4  /* Interrupted system call */
N#define  EIO           5  /* I/O error */
N#define  ENXIO         6  /* No such device or address */
N#define  E2BIG         7  /* Arg list too long */
N#define  ENOEXEC       8  /* Exec format error */
N#define  EBADF         9  /* Bad file number */
N#define  ECHILD       10  /* No child processes */
N#define  EAGAIN       11  /* Try again */
N#define  ENOMEM       12  /* Out of memory */
N#define  EACCES       13  /* Permission denied */
N#define  EFAULT       14  /* Bad address */
N#define  ENOTBLK      15  /* Block device required */
N#define  EBUSY        16  /* Device or resource busy */
N#define  EEXIST       17  /* File exists */
N#define  EXDEV        18  /* Cross-device link */
N#define  ENODEV       19  /* No such device */
N#define  ENOTDIR      20  /* Not a directory */
N#define  EISDIR       21  /* Is a directory */
N#define  EINVAL       22  /* Invalid argument */
N#define  ENFILE       23  /* File table overflow */
N#define  EMFILE       24  /* Too many open files */
N#define  ENOTTY       25  /* Not a typewriter */
N#define  ETXTBSY      26  /* Text file busy */
N#define  EFBIG        27  /* File too large */
N#define  ENOSPC       28  /* No space left on device */
N#define  ESPIPE       29  /* Illegal seek */
N#define  EROFS        30  /* Read-only file system */
N#define  EMLINK       31  /* Too many links */
N#define  EPIPE        32  /* Broken pipe */
N#define  EDOM         33  /* Math argument out of domain of func */
N#define  ERANGE       34  /* Math result not representable */
N#define  EDEADLK      35  /* Resource deadlock would occur */
N#define  ENAMETOOLONG 36  /* File name too long */
N#define  ENOLCK       37  /* No record locks available */
N#define  ENOSYS       38  /* Function not implemented */
N#define  ENOTEMPTY    39  /* Directory not empty */
N#define  ELOOP        40  /* Too many symbolic links encountered */
N#define  EWOULDBLOCK  EAGAIN  /* Operation would block */
N#define  ENOMSG       42  /* No message of desired type */
N#define  EIDRM        43  /* Identifier removed */
N#define  ECHRNG       44  /* Channel number out of range */
N#define  EL2NSYNC     45  /* Level 2 not synchronized */
N#define  EL3HLT       46  /* Level 3 halted */
N#define  EL3RST       47  /* Level 3 reset */
N#define  ELNRNG       48  /* Link number out of range */
N#define  EUNATCH      49  /* Protocol driver not attached */
N#define  ENOCSI       50  /* No CSI structure available */
N#define  EL2HLT       51  /* Level 2 halted */
N#define  EBADE        52  /* Invalid exchange */
N#define  EBADR        53  /* Invalid request descriptor */
N#define  EXFULL       54  /* Exchange full */
N#define  ENOANO       55  /* No anode */
N#define  EBADRQC      56  /* Invalid request code */
N#define  EBADSLT      57  /* Invalid slot */
N
N#define  EDEADLOCK    EDEADLK
N
N#define  EBFONT       59  /* Bad font file format */
N#define  ENOSTR       60  /* Device not a stream */
N#define  ENODATA      61  /* No data available */
N#define  ETIME        62  /* Timer expired */
N#define  ENOSR        63  /* Out of streams resources */
N#define  ENONET       64  /* Machine is not on the network */
N#define  ENOPKG       65  /* Package not installed */
N#define  EREMOTE      66  /* Object is remote */
N#define  ENOLINK      67  /* Link has been severed */
N#define  EADV         68  /* Advertise error */
N#define  ESRMNT       69  /* Srmount error */
N#define  ECOMM        70  /* Communication error on send */
N#define  EPROTO       71  /* Protocol error */
N#define  EMULTIHOP    72  /* Multihop attempted */
N#define  EDOTDOT      73  /* RFS specific error */
N#define  EBADMSG      74  /* Not a data message */
N#define  EOVERFLOW    75  /* Value too large for defined data type */
N#define  ENOTUNIQ     76  /* Name not unique on network */
N#define  EBADFD       77  /* File descriptor in bad state */
N#define  EREMCHG      78  /* Remote address changed */
N#define  ELIBACC      79  /* Can not access a needed shared library */
N#define  ELIBBAD      80  /* Accessing a corrupted shared library */
N#define  ELIBSCN      81  /* .lib section in a.out corrupted */
N#define  ELIBMAX      82  /* Attempting to link in too many shared libraries */
N#define  ELIBEXEC     83  /* Cannot exec a shared library directly */
N#define  EILSEQ       84  /* Illegal byte sequence */
N#define  ERESTART     85  /* Interrupted system call should be restarted */
N#define  ESTRPIPE     86  /* Streams pipe error */
N#define  EUSERS       87  /* Too many users */
N#define  ENOTSOCK     88  /* Socket operation on non-socket */
N#define  EDESTADDRREQ 89  /* Destination address required */
N#define  EMSGSIZE     90  /* Message too long */
N#define  EPROTOTYPE   91  /* Protocol wrong type for socket */
N#define  ENOPROTOOPT  92  /* Protocol not available */
N#define  EPROTONOSUPPORT 93  /* Protocol not supported */
N#define  ESOCKTNOSUPPORT 94  /* Socket type not supported */
N#define  EOPNOTSUPP      95  /* Operation not supported on transport endpoint */
N#define  EPFNOSUPPORT    96  /* Protocol family not supported */
N#define  EAFNOSUPPORT    97  /* Address family not supported by protocol */
N#define  EADDRINUSE      98  /* Address already in use */
N#define  EADDRNOTAVAIL   99  /* Cannot assign requested address */
N#define  ENETDOWN       100  /* Network is down */
N#define  ENETUNREACH    101  /* Network is unreachable */
N#define  ENETRESET      102  /* Network dropped connection because of reset */
N#define  ECONNABORTED   103  /* Software caused connection abort */
N#define  ECONNRESET     104  /* Connection reset by peer */
N#define  ENOBUFS        105  /* No buffer space available */
N#define  EISCONN        106  /* Transport endpoint is already connected */
N#define  ENOTCONN       107  /* Transport endpoint is not connected */
N#define  ESHUTDOWN      108  /* Cannot send after transport endpoint shutdown */
N#define  ETOOMANYREFS   109  /* Too many references: cannot splice */
N#define  ETIMEDOUT      110  /* Connection timed out */
N#define  ECONNREFUSED   111  /* Connection refused */
N#define  EHOSTDOWN      112  /* Host is down */
N#define  EHOSTUNREACH   113  /* No route to host */
N#define  EALREADY       114  /* Operation already in progress */
N#define  EINPROGRESS    115  /* Operation now in progress */
N#define  ESTALE         116  /* Stale NFS file handle */
N#define  EUCLEAN        117  /* Structure needs cleaning */
N#define  ENOTNAM        118  /* Not a XENIX named type file */
N#define  ENAVAIL        119  /* No XENIX semaphores available */
N#define  EISNAM         120  /* Is a named type file */
N#define  EREMOTEIO      121  /* Remote I/O error */
N#define  EDQUOT         122  /* Quota exceeded */
N
N#define  ENOMEDIUM      123  /* No medium found */
N#define  EMEDIUMTYPE    124  /* Wrong medium type */
N
N#ifndef errno
Nextern int errno;
N#endif
N
N#endif /* LWIP_PROVIDE_ERRNO */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __LWIP_ARCH_H__ */
L 36 "..\..\Lwip\lwip-1.4.1\src\include\lwip/debug.h" 2
N//#include "opt.h"
N/*C*/
N#include <string.h>
N#include <stdlib.h>
N#include <stdio.h>
L 1 "d:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060019
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 41 "..\..\Lwip\lwip-1.4.1\src\include\lwip/debug.h" 2
N#include "lwipopts.h"
N
N//#define TCP_DEBUG_USART_PRINTF_S(x)    printf("%s\n",x)
N#define TCP_DEBUG_USART_PRINTF_S(x) 
N
N/** lower two bits indicate debug level
N * - 0 all
N * - 1 warning
N * - 2 serious
N * - 3 severe
N */
N#define LWIP_DBG_LEVEL_ALL     0x00
N#define LWIP_DBG_LEVEL_OFF     LWIP_DBG_LEVEL_ALL /* compatibility define only */
N#define LWIP_DBG_LEVEL_WARNING 0x01 /* bad checksums, dropped packets, ... */
N#define LWIP_DBG_LEVEL_SERIOUS 0x02 /* memory allocation failures, ... */
N#define LWIP_DBG_LEVEL_SEVERE  0x03
N#define LWIP_DBG_MASK_LEVEL    0x03
N
N/** flag for LWIP_DEBUGF to enable that debug message */
N#define LWIP_DBG_ON            0x80U
N/** flag for LWIP_DEBUGF to disable that debug message */
N#define LWIP_DBG_OFF           0x00U
N
N/** flag for LWIP_DEBUGF indicating a tracing message (to follow program flow) */
N#define LWIP_DBG_TRACE         0x40U
N/** flag for LWIP_DEBUGF indicating a state debug message (to follow module states) */
N#define LWIP_DBG_STATE         0x20U
N/** flag for LWIP_DEBUGF indicating newly added code, not thoroughly tested yet */
N#define LWIP_DBG_FRESH         0x10U
N/** flag for LWIP_DEBUGF to halt after printing this debug message */
N#define LWIP_DBG_HALT          0x08U
N
N#ifndef LWIP_NOASSERT
N#define LWIP_ASSERT(message, assertion) do { if(!(assertion)) \
N  LWIP_PLATFORM_ASSERT(message); } while(0)
X#define LWIP_ASSERT(message, assertion) do { if(!(assertion))   LWIP_PLATFORM_ASSERT(message); } while(0)
N#else  /* LWIP_NOASSERT */
S#define LWIP_ASSERT(message, assertion) 
N#endif /* LWIP_NOASSERT */
N
N/** if "expression" isn't true, then print "message" and execute "handler" expression */
N#ifndef LWIP_ERROR
N#define LWIP_ERROR(message, expression, handler) do { if (!(expression)) { \
N  LWIP_PLATFORM_ASSERT(message); handler;}} while(0)
X#define LWIP_ERROR(message, expression, handler) do { if (!(expression)) {   LWIP_PLATFORM_ASSERT(message); handler;}} while(0)
N#endif /* LWIP_ERROR */
N
N
N
N//#define LWIP_DEBUG
N#ifdef LWIP_DEBUG
S/** print debug message only if debug message type is enabled...
S *  AND is of correct type AND is at least LWIP_DBG_LEVEL
S */
S#ifndef U8_F
S#define U8_F "c"
S#endif
S
S#ifndef S8_F
S#define S8_F "c"
S#endif
S
S#ifndef X8_F
S#define X8_F "x"
S#endif
S
S#ifndef U16_F
S#define U16_F "u"
S#endif
S
S#ifndef S16_F
S#define S16_F "d"
S#endif
S
S#ifndef X16_F
S#define X16_F "x"
S#endif
S#ifndef U32_F
S#define U32_F "u"
S#endif
S#ifndef S32_F
S#define S32_F "d"
S#endif
S#ifndef X32_F
S#define X32_F "x"
S#endif
S
S#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_OFF
S//#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_WARNING
S//#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_SERIOUS
S//#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_SEVERE
S
S#define LWIP_DBG_TYPES_ON               (LWIP_DBG_ON|LWIP_DBG_TRACE|LWIP_DBG_STATE|LWIP_DBG_FRESH)
S//#define ETHARP_DEBUG                    LWIP_DBG_ON     
S//#define NETIF_DEBUG                     LWIP_DBG_ON     
S//#define PBUF_DEBUG                      LWIP_DBG_ON
S//#define API_LIB_DEBUG                   LWIP_DBG_ON
S//#define API_MSG_DEBUG                   LWIP_DBG_ON
S//#define SOCKETS_DEBUG                   LWIP_DBG_ON
S//#define ICMP_DEBUG                      LWIP_DBG_ON
S//#define IGMP_DEBUG                      LWIP_DBG_ON
S//#define INET_DEBUG                      LWIP_DBG_ON
S//#define IP_DEBUG                        LWIP_DBG_ON     
S//#define IP_REASS_DEBUG                  LWIP_DBG_ON
S#define RAW_DEBUG                       LWIP_DBG_ON
S//#define MEM_DEBUG                       LWIP_DBG_ON
S//#define MEMP_DEBUG                      LWIP_DBG_ON
S//#define SYS_DEBUG                       LWIP_DBG_ON
S#define TCP_DEBUG                       LWIP_DBG_ON
S#define TCP_INPUT_DEBUG                 LWIP_DBG_ON
S#define TCP_FR_DEBUG                    LWIP_DBG_ON
S#define TCP_RTO_DEBUG                   LWIP_DBG_ON
S#define TCP_CWND_DEBUG                  LWIP_DBG_ON
S#define TCP_WND_DEBUG                   LWIP_DBG_ON
S#define TCP_OUTPUT_DEBUG                LWIP_DBG_ON
S#define TCP_RST_DEBUG                   LWIP_DBG_ON
S#define TCP_QLEN_DEBUG                  LWIP_DBG_ON
S//#define UDP_DEBUG                       LWIP_DBG_ON     
S//#define TCPIP_DEBUG                     LWIP_DBG_ON
S//#define PPP_DEBUG                       LWIP_DBG_ON
S//#define SLIP_DEBUG                      LWIP_DBG_ON
S//#define DHCP_DEBUG                      LWIP_DBG_ON     
S//#define AUTOIP_DEBUG                    LWIP_DBG_ON
S//#define SNMP_MSG_DEBUG                  LWIP_DBG_ON
S//#define SNMP_MIB_DEBUG                  LWIP_DBG_ON
S//#define DNS_DEBUG                       LWIP_DBG_ON
S
S#define LWIP_PLATFORM_DIAG printf
S#define LWIP_DEBUGF(debug, message) do { \
S                               if ( \
S                                   ((debug) & LWIP_DBG_ON) && \
S                                   ((debug) & LWIP_DBG_TYPES_ON) && \
S                                   ((s16_t)((debug) & LWIP_DBG_MASK_LEVEL) >= LWIP_DBG_MIN_LEVEL)) { \
S                                 LWIP_PLATFORM_DIAG message; \
S                                 if ((debug) & LWIP_DBG_HALT) { \
S                                   while(1); \
S                                 } \
S                               } \
S                             } while(0)
X#define LWIP_DEBUGF(debug, message) do {                                if (                                    ((debug) & LWIP_DBG_ON) &&                                    ((debug) & LWIP_DBG_TYPES_ON) &&                                    ((s16_t)((debug) & LWIP_DBG_MASK_LEVEL) >= LWIP_DBG_MIN_LEVEL)) {                                  LWIP_PLATFORM_DIAG message;                                  if ((debug) & LWIP_DBG_HALT) {                                    while(1);                                  }                                }                              } while(0)
S
N#else  /* LWIP_DEBUG */
N#define LWIP_DEBUGF(debug, message) 
N#endif /* LWIP_DEBUG */
N
N#endif /* __LWIP_DEBUG_H__ */
N
L 47 "..\..\Lwip\lwip-1.4.1\src\include\lwip/opt.h" 2
N
N/*
N   -----------------------------------------------
N   ---------- Platform specific locking ----------
N   -----------------------------------------------
N*/
N
N/**
N * SYS_LIGHTWEIGHT_PROT==1: if you want inter-task protection for certain
N * critical regions during buffer allocation, deallocation and memory
N * allocation and deallocation.
N */
N#ifndef SYS_LIGHTWEIGHT_PROT
S#define SYS_LIGHTWEIGHT_PROT            0
N#endif
N
N/** 
N * NO_SYS==1: Provides VERY minimal functionality. Otherwise,
N * use lwIP facilities.
N */
N#ifndef NO_SYS
S#define NO_SYS                          0
N#endif
N
N/**
N * NO_SYS_NO_TIMERS==1: Drop support for sys_timeout when NO_SYS==1
N * Mainly for compatibility to old versions.
N */
N#ifndef NO_SYS_NO_TIMERS
S#define NO_SYS_NO_TIMERS                0
N#endif
N
N/**
N * MEMCPY: override this if you have a faster implementation at hand than the
N * one included in your C library
N */
N#ifndef MEMCPY
N#define MEMCPY(dst,src,len)             memcpy(dst,src,len)
N#endif
N
N/**
N * SMEMCPY: override this with care! Some compilers (e.g. gcc) can inline a
N * call to memcpy() if the length is known at compile time and is small.
N */
N#ifndef SMEMCPY
N#define SMEMCPY(dst,src,len)            memcpy(dst,src,len)
N#endif
N
N/*
N   ------------------------------------
N   ---------- Memory options ----------
N   ------------------------------------
N*/
N/**
N * MEM_LIBC_MALLOC==1: Use malloc/free/realloc provided by your C-library
N * instead of the lwip internal allocator. Can save code size if you
N * already use it.
N */
N#ifndef MEM_LIBC_MALLOC
N#define MEM_LIBC_MALLOC                 0
N#endif
N
N/**
N* MEMP_MEM_MALLOC==1: Use mem_malloc/mem_free instead of the lwip pool allocator.
N* Especially useful with MEM_LIBC_MALLOC but handle with care regarding execution
N* speed and usage from interrupts!
N*/
N#ifndef MEMP_MEM_MALLOC
N#define MEMP_MEM_MALLOC                 0
N#endif
N
N/**
N * MEM_ALIGNMENT: should be set to the alignment of the CPU
N *    4 byte alignment -> #define MEM_ALIGNMENT 4
N *    2 byte alignment -> #define MEM_ALIGNMENT 2
N */
N#ifndef MEM_ALIGNMENT
S#define MEM_ALIGNMENT                   1
N#endif
N
N/**
N * MEM_SIZE: the size of the heap memory. If the application will send
N * a lot of data that needs to be copied, this should be set high.
N */
N#ifndef MEM_SIZE
S#define MEM_SIZE                        1600
N#endif
N
N/**
N * MEMP_SEPARATE_POOLS: if defined to 1, each pool is placed in its own array.
N * This can be used to individually change the location of each pool.
N * Default is one big array for all pools
N */
N#ifndef MEMP_SEPARATE_POOLS
N#define MEMP_SEPARATE_POOLS             0
N#endif
N
N/**
N * MEMP_OVERFLOW_CHECK: memp overflow protection reserves a configurable
N * amount of bytes before and after each memp element in every pool and fills
N * it with a prominent default value.
N *    MEMP_OVERFLOW_CHECK == 0 no checking
N *    MEMP_OVERFLOW_CHECK == 1 checks each element when it is freed
N *    MEMP_OVERFLOW_CHECK >= 2 checks each element in every pool every time
N *      memp_malloc() or memp_free() is called (useful but slow!)
N */
N#ifndef MEMP_OVERFLOW_CHECK
N#define MEMP_OVERFLOW_CHECK             0
N#endif
N
N/**
N * MEMP_SANITY_CHECK==1: run a sanity check after each memp_free() to make
N * sure that there are no cycles in the linked lists.
N */
N#ifndef MEMP_SANITY_CHECK
N#define MEMP_SANITY_CHECK               0
N#endif
N
N/**
N * MEM_USE_POOLS==1: Use an alternative to malloc() by allocating from a set
N * of memory pools of various sizes. When mem_malloc is called, an element of
N * the smallest pool that can provide the length needed is returned.
N * To use this, MEMP_USE_CUSTOM_POOLS also has to be enabled.
N */
N#ifndef MEM_USE_POOLS
N#define MEM_USE_POOLS                   0
N#endif
N
N/**
N * MEM_USE_POOLS_TRY_BIGGER_POOL==1: if one malloc-pool is empty, try the next
N * bigger pool - WARNING: THIS MIGHT WASTE MEMORY but it can make a system more
N * reliable. */
N#ifndef MEM_USE_POOLS_TRY_BIGGER_POOL
N#define MEM_USE_POOLS_TRY_BIGGER_POOL   0
N#endif
N
N/**
N * MEMP_USE_CUSTOM_POOLS==1: whether to include a user file lwippools.h
N * that defines additional pools beyond the "standard" ones required
N * by lwIP. If you set this to 1, you must have lwippools.h in your 
N * inlude path somewhere. 
N */
N#ifndef MEMP_USE_CUSTOM_POOLS
N#define MEMP_USE_CUSTOM_POOLS           0
N#endif
N
N/**
N * Set this to 1 if you want to free PBUF_RAM pbufs (or call mem_free()) from
N * interrupt context (or another context that doesn't allow waiting for a
N * semaphore).
N * If set to 1, mem_malloc will be protected by a semaphore and SYS_ARCH_PROTECT,
N * while mem_free will only use SYS_ARCH_PROTECT. mem_malloc SYS_ARCH_UNPROTECTs
N * with each loop so that mem_free can run.
N *
N * ATTENTION: As you can see from the above description, this leads to dis-/
N * enabling interrupts often, which can be slow! Also, on low memory, mem_malloc
N * can need longer.
N *
N * If you don't want that, at least for NO_SYS=0, you can still use the following
N * functions to enqueue a deallocation call which then runs in the tcpip_thread
N * context:
N * - pbuf_free_callback(p);
N * - mem_free_callback(m);
N */
N#ifndef LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
N#define LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT 0
N#endif
N
N/*
N   ------------------------------------------------
N   ---------- Internal Memory Pool Sizes ----------
N   ------------------------------------------------
N*/
N/**
N * MEMP_NUM_PBUF: the number of memp struct pbufs (used for PBUF_ROM and PBUF_REF).
N * If the application sends a lot of data out of ROM (or other static memory),
N * this should be set high.
N */
N#ifndef MEMP_NUM_PBUF
N#define MEMP_NUM_PBUF                   16
N#endif
N
N/**
N * MEMP_NUM_RAW_PCB: Number of raw connection PCBs
N * (requires the LWIP_RAW option)
N */
N#ifndef MEMP_NUM_RAW_PCB
N#define MEMP_NUM_RAW_PCB                4
N#endif
N
N/**
N * MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
N * per active UDP "connection".
N * (requires the LWIP_UDP option)
N */
N#ifndef MEMP_NUM_UDP_PCB
S#define MEMP_NUM_UDP_PCB                4
N#endif
N
N/**
N * MEMP_NUM_TCP_PCB: the number of simulatenously active TCP connections.
N * (requires the LWIP_TCP option)
N */
N#ifndef MEMP_NUM_TCP_PCB
S#define MEMP_NUM_TCP_PCB                5
N#endif
N
N/**
N * MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP connections.
N * (requires the LWIP_TCP option)
N */
N#ifndef MEMP_NUM_TCP_PCB_LISTEN
S#define MEMP_NUM_TCP_PCB_LISTEN         8
N#endif
N
N/**
N * MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP segments.
N * (requires the LWIP_TCP option)
N */
N#ifndef MEMP_NUM_TCP_SEG
S#define MEMP_NUM_TCP_SEG                16
N#endif
N
N/**
N * MEMP_NUM_REASSDATA: the number of IP packets simultaneously queued for
N * reassembly (whole packets, not fragments!)
N */
N#ifndef MEMP_NUM_REASSDATA
N#define MEMP_NUM_REASSDATA              5
N#endif
N
N/**
N * MEMP_NUM_FRAG_PBUF: the number of IP fragments simultaneously sent
N * (fragments, not whole packets!).
N * This is only used with IP_FRAG_USES_STATIC_BUF==0 and
N * LWIP_NETIF_TX_SINGLE_PBUF==0 and only has to be > 1 with DMA-enabled MACs
N * where the packet is not yet sent when netif->output returns.
N */
N#ifndef MEMP_NUM_FRAG_PBUF
N#define MEMP_NUM_FRAG_PBUF              15
N#endif
N
N/**
N * MEMP_NUM_ARP_QUEUE: the number of simulateously queued outgoing
N * packets (pbufs) that are waiting for an ARP request (to resolve
N * their destination address) to finish.
N * (requires the ARP_QUEUEING option)
N */
N#ifndef MEMP_NUM_ARP_QUEUE
N#define MEMP_NUM_ARP_QUEUE              30
N#endif
N
N/**
N * MEMP_NUM_IGMP_GROUP: The number of multicast groups whose network interfaces
N * can be members et the same time (one per netif - allsystems group -, plus one
N * per netif membership).
N * (requires the LWIP_IGMP option)
N */
N#ifndef MEMP_NUM_IGMP_GROUP
N#define MEMP_NUM_IGMP_GROUP             8
N#endif
N
N/**
N * MEMP_NUM_SYS_TIMEOUT: the number of simulateously active timeouts.
N * (requires NO_SYS==0)
N * The default number of timeouts is calculated here for all enabled modules.
N * The formula expects settings to be either '0' or '1'.
N */
N#ifndef MEMP_NUM_SYS_TIMEOUT
S#define MEMP_NUM_SYS_TIMEOUT            (LWIP_TCP + IP_REASSEMBLY + LWIP_ARP + (2*LWIP_DHCP) + LWIP_AUTOIP + LWIP_IGMP + LWIP_DNS + PPP_SUPPORT)
N#endif
N
N/**
N * MEMP_NUM_NETBUF: the number of struct netbufs.
N * (only needed if you use the sequential API, like api_lib.c)
N */
N#ifndef MEMP_NUM_NETBUF
N#define MEMP_NUM_NETBUF                 2
N#endif
N
N/**
N * MEMP_NUM_NETCONN: the number of struct netconns.
N * (only needed if you use the sequential API, like api_lib.c)
N */
N#ifndef MEMP_NUM_NETCONN
N#define MEMP_NUM_NETCONN                4
N#endif
N
N/**
N * MEMP_NUM_TCPIP_MSG_API: the number of struct tcpip_msg, which are used
N * for callback/timeout API communication. 
N * (only needed if you use tcpip.c)
N */
N#ifndef MEMP_NUM_TCPIP_MSG_API
N#define MEMP_NUM_TCPIP_MSG_API          8
N#endif
N
N/**
N * MEMP_NUM_TCPIP_MSG_INPKT: the number of struct tcpip_msg, which are used
N * for incoming packets. 
N * (only needed if you use tcpip.c)
N */
N#ifndef MEMP_NUM_TCPIP_MSG_INPKT
N#define MEMP_NUM_TCPIP_MSG_INPKT        8
N#endif
N
N/**
N * MEMP_NUM_SNMP_NODE: the number of leafs in the SNMP tree.
N */
N#ifndef MEMP_NUM_SNMP_NODE
N#define MEMP_NUM_SNMP_NODE              50
N#endif
N
N/**
N * MEMP_NUM_SNMP_ROOTNODE: the number of branches in the SNMP tree.
N * Every branch has one leaf (MEMP_NUM_SNMP_NODE) at least!
N */
N#ifndef MEMP_NUM_SNMP_ROOTNODE
N#define MEMP_NUM_SNMP_ROOTNODE          30
N#endif
N
N/**
N * MEMP_NUM_SNMP_VARBIND: the number of concurrent requests (does not have to
N * be changed normally) - 2 of these are used per request (1 for input,
N * 1 for output)
N */
N#ifndef MEMP_NUM_SNMP_VARBIND
N#define MEMP_NUM_SNMP_VARBIND           2
N#endif
N
N/**
N * MEMP_NUM_SNMP_VALUE: the number of OID or values concurrently used
N * (does not have to be changed normally) - 3 of these are used per request
N * (1 for the value read and 2 for OIDs - input and output)
N */
N#ifndef MEMP_NUM_SNMP_VALUE
N#define MEMP_NUM_SNMP_VALUE             3
N#endif
N
N/**
N * MEMP_NUM_NETDB: the number of concurrently running lwip_addrinfo() calls
N * (before freeing the corresponding memory using lwip_freeaddrinfo()).
N */
N#ifndef MEMP_NUM_NETDB
N#define MEMP_NUM_NETDB                  1
N#endif
N
N/**
N * MEMP_NUM_LOCALHOSTLIST: the number of host entries in the local host list
N * if DNS_LOCAL_HOSTLIST_IS_DYNAMIC==1.
N */
N#ifndef MEMP_NUM_LOCALHOSTLIST
N#define MEMP_NUM_LOCALHOSTLIST          1
N#endif
N
N/**
N * MEMP_NUM_PPPOE_INTERFACES: the number of concurrently active PPPoE
N * interfaces (only used with PPPOE_SUPPORT==1)
N */
N#ifndef MEMP_NUM_PPPOE_INTERFACES
N#define MEMP_NUM_PPPOE_INTERFACES       1
N#endif
N
N/**
N * PBUF_POOL_SIZE: the number of buffers in the pbuf pool. 
N */
N#ifndef PBUF_POOL_SIZE
S#define PBUF_POOL_SIZE                  16
N#endif
N
N/*
N   ---------------------------------
N   ---------- ARP options ----------
N   ---------------------------------
N*/
N/**
N * LWIP_ARP==1: Enable ARP functionality.
N */
N#ifndef LWIP_ARP
S#define LWIP_ARP                        1
N#endif
N
N/**
N * ARP_TABLE_SIZE: Number of active MAC-IP address pairs cached.
N */
N#ifndef ARP_TABLE_SIZE
N#define ARP_TABLE_SIZE                  10
N#endif
N
N/**
N * ARP_QUEUEING==1: Multiple outgoing packets are queued during hardware address
N * resolution. By default, only the most recent packet is queued per IP address.
N * This is sufficient for most protocols and mainly reduces TCP connection
N * startup time. Set this to 1 if you know your application sends more than one
N * packet in a row to an IP address that is not in the ARP cache.
N */
N#ifndef ARP_QUEUEING
N#define ARP_QUEUEING                    0
N#endif
N
N/**
N * ETHARP_TRUST_IP_MAC==1: Incoming IP packets cause the ARP table to be
N * updated with the source MAC and IP addresses supplied in the packet.
N * You may want to disable this if you do not trust LAN peers to have the
N * correct addresses, or as a limited approach to attempt to handle
N * spoofing. If disabled, lwIP will need to make a new ARP request if
N * the peer is not already in the ARP table, adding a little latency.
N * The peer *is* in the ARP table if it requested our address before.
N * Also notice that this slows down input processing of every IP packet!
N */
N#ifndef ETHARP_TRUST_IP_MAC
N#define ETHARP_TRUST_IP_MAC             0
N#endif
N
N/**
N * ETHARP_SUPPORT_VLAN==1: support receiving ethernet packets with VLAN header.
N * Additionally, you can define ETHARP_VLAN_CHECK to an u16_t VLAN ID to check.
N * If ETHARP_VLAN_CHECK is defined, only VLAN-traffic for this VLAN is accepted.
N * If ETHARP_VLAN_CHECK is not defined, all traffic is accepted.
N * Alternatively, define a function/define ETHARP_VLAN_CHECK_FN(eth_hdr, vlan)
N * that returns 1 to accept a packet or 0 to drop a packet.
N */
N#ifndef ETHARP_SUPPORT_VLAN
N#define ETHARP_SUPPORT_VLAN             0
N#endif
N
N/** LWIP_ETHERNET==1: enable ethernet support for PPPoE even though ARP
N * might be disabled
N */
N#ifndef LWIP_ETHERNET
N#define LWIP_ETHERNET                   (LWIP_ARP || PPPOE_SUPPORT)
N#endif
N
N/** ETH_PAD_SIZE: number of bytes added before the ethernet header to ensure
N * alignment of payload after that header. Since the header is 14 bytes long,
N * without this padding e.g. addresses in the IP header will not be aligned
N * on a 32-bit boundary, so setting this to 2 can speed up 32-bit-platforms.
N */
N#ifndef ETH_PAD_SIZE
N#define ETH_PAD_SIZE                    0
N#endif
N
N/** ETHARP_SUPPORT_STATIC_ENTRIES==1: enable code to support static ARP table
N * entries (using etharp_add_static_entry/etharp_remove_static_entry).
N */
N#ifndef ETHARP_SUPPORT_STATIC_ENTRIES
N#define ETHARP_SUPPORT_STATIC_ENTRIES   0
N#endif
N
N
N/*
N   --------------------------------
N   ---------- IP options ----------
N   --------------------------------
N*/
N/**
N * IP_FORWARD==1: Enables the ability to forward IP packets across network
N * interfaces. If you are going to run lwIP on a device with only one network
N * interface, define this to 0.
N */
N#ifndef IP_FORWARD
N#define IP_FORWARD                      0
N#endif
N
N/**
N * IP_OPTIONS_ALLOWED: Defines the behavior for IP options.
N *      IP_OPTIONS_ALLOWED==0: All packets with IP options are dropped.
N *      IP_OPTIONS_ALLOWED==1: IP options are allowed (but not parsed).
N */
N#ifndef IP_OPTIONS_ALLOWED
N#define IP_OPTIONS_ALLOWED              1
N#endif
N
N/**
N * IP_REASSEMBLY==1: Reassemble incoming fragmented IP packets. Note that
N * this option does not affect outgoing packet sizes, which can be controlled
N * via IP_FRAG.
N */
N#ifndef IP_REASSEMBLY
N#define IP_REASSEMBLY                   1
N#endif
N
N/**
N * IP_FRAG==1: Fragment outgoing IP packets if their size exceeds MTU. Note
N * that this option does not affect incoming packet sizes, which can be
N * controlled via IP_REASSEMBLY.
N */
N#ifndef IP_FRAG
N#define IP_FRAG                         1
N#endif
N
N/**
N * IP_REASS_MAXAGE: Maximum time (in multiples of IP_TMR_INTERVAL - so seconds, normally)
N * a fragmented IP packet waits for all fragments to arrive. If not all fragments arrived
N * in this time, the whole packet is discarded.
N */
N#ifndef IP_REASS_MAXAGE
N#define IP_REASS_MAXAGE                 3
N#endif
N
N/**
N * IP_REASS_MAX_PBUFS: Total maximum amount of pbufs waiting to be reassembled.
N * Since the received pbufs are enqueued, be sure to configure
N * PBUF_POOL_SIZE > IP_REASS_MAX_PBUFS so that the stack is still able to receive
N * packets even if the maximum amount of fragments is enqueued for reassembly!
N */
N#ifndef IP_REASS_MAX_PBUFS
N#define IP_REASS_MAX_PBUFS              10
N#endif
N
N/**
N * IP_FRAG_USES_STATIC_BUF==1: Use a static MTU-sized buffer for IP
N * fragmentation. Otherwise pbufs are allocated and reference the original
N * packet data to be fragmented (or with LWIP_NETIF_TX_SINGLE_PBUF==1,
N * new PBUF_RAM pbufs are used for fragments).
N * ATTENTION: IP_FRAG_USES_STATIC_BUF==1 may not be used for DMA-enabled MACs!
N */
N#ifndef IP_FRAG_USES_STATIC_BUF
N#define IP_FRAG_USES_STATIC_BUF         0
N#endif
N
N/**
N * IP_FRAG_MAX_MTU: Assumed max MTU on any interface for IP frag buffer
N * (requires IP_FRAG_USES_STATIC_BUF==1)
N */
N#if IP_FRAG_USES_STATIC_BUF && !defined(IP_FRAG_MAX_MTU)
X#if 0 && !0L
S#define IP_FRAG_MAX_MTU                 1500
N#endif
N
N/**
N * IP_DEFAULT_TTL: Default value for Time-To-Live used by transport layers.
N */
N#ifndef IP_DEFAULT_TTL
N#define IP_DEFAULT_TTL                  255
N#endif
N
N/**
N * IP_SOF_BROADCAST=1: Use the SOF_BROADCAST field to enable broadcast
N * filter per pcb on udp and raw send operations. To enable broadcast filter
N * on recv operations, you also have to set IP_SOF_BROADCAST_RECV=1.
N */
N#ifndef IP_SOF_BROADCAST
N#define IP_SOF_BROADCAST                0
N#endif
N
N/**
N * IP_SOF_BROADCAST_RECV (requires IP_SOF_BROADCAST=1) enable the broadcast
N * filter on recv operations.
N */
N#ifndef IP_SOF_BROADCAST_RECV
N#define IP_SOF_BROADCAST_RECV           0
N#endif
N
N/**
N * IP_FORWARD_ALLOW_TX_ON_RX_NETIF==1: allow ip_forward() to send packets back
N * out on the netif where it was received. This should only be used for
N * wireless networks.
N * ATTENTION: When this is 1, make sure your netif driver correctly marks incoming
N * link-layer-broadcast/multicast packets as such using the corresponding pbuf flags!
N */
N#ifndef IP_FORWARD_ALLOW_TX_ON_RX_NETIF
N#define IP_FORWARD_ALLOW_TX_ON_RX_NETIF 0
N#endif
N
N/**
N * LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS==1: randomize the local port for the first
N * local TCP/UDP pcb (default==0). This can prevent creating predictable port
N * numbers after booting a device.
N */
N#ifndef LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS
N#define LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS 0
N#endif
N
N/*
N   ----------------------------------
N   ---------- ICMP options ----------
N   ----------------------------------
N*/
N/**
N * LWIP_ICMP==1: Enable ICMP module inside the IP stack.
N * Be careful, disable that make your product non-compliant to RFC1122
N */
N#ifndef LWIP_ICMP
S#define LWIP_ICMP                       1
N#endif
N
N/**
N * ICMP_TTL: Default value for Time-To-Live used by ICMP packets.
N */
N#ifndef ICMP_TTL
N#define ICMP_TTL                       (IP_DEFAULT_TTL)
N#endif
N
N/**
N * LWIP_BROADCAST_PING==1: respond to broadcast pings (default is unicast only)
N */
N#ifndef LWIP_BROADCAST_PING
N#define LWIP_BROADCAST_PING             0
N#endif
N
N/**
N * LWIP_MULTICAST_PING==1: respond to multicast pings (default is unicast only)
N */
N#ifndef LWIP_MULTICAST_PING
N#define LWIP_MULTICAST_PING             0
N#endif
N
N/*
N   ---------------------------------
N   ---------- RAW options ----------
N   ---------------------------------
N*/
N/**
N * LWIP_RAW==1: Enable application layer to hook into the IP layer itself.
N */
N#ifndef LWIP_RAW
N#define LWIP_RAW                        1
N#endif
N
N/**
N * LWIP_RAW==1: Enable application layer to hook into the IP layer itself.
N */
N#ifndef RAW_TTL
N#define RAW_TTL                        (IP_DEFAULT_TTL)
N#endif
N
N/*
N   ----------------------------------
N   ---------- DHCP options ----------
N   ----------------------------------
N*/
N/**
N * LWIP_DHCP==1: Enable DHCP module.
N */
N#ifndef LWIP_DHCP
S#define LWIP_DHCP                       0
N#endif
N
N/**
N * DHCP_DOES_ARP_CHECK==1: Do an ARP check on the offered address.
N */
N#ifndef DHCP_DOES_ARP_CHECK
N#define DHCP_DOES_ARP_CHECK             ((LWIP_DHCP) && (LWIP_ARP))
N#endif
N
N/*
N   ------------------------------------
N   ---------- AUTOIP options ----------
N   ------------------------------------
N*/
N/**
N * LWIP_AUTOIP==1: Enable AUTOIP module.
N */
N#ifndef LWIP_AUTOIP
N#define LWIP_AUTOIP                     0
N#endif
N
N/**
N * LWIP_DHCP_AUTOIP_COOP==1: Allow DHCP and AUTOIP to be both enabled on
N * the same interface at the same time.
N */
N#ifndef LWIP_DHCP_AUTOIP_COOP
N#define LWIP_DHCP_AUTOIP_COOP           0
N#endif
N
N/**
N * LWIP_DHCP_AUTOIP_COOP_TRIES: Set to the number of DHCP DISCOVER probes
N * that should be sent before falling back on AUTOIP. This can be set
N * as low as 1 to get an AutoIP address very quickly, but you should
N * be prepared to handle a changing IP address when DHCP overrides
N * AutoIP.
N */
N#ifndef LWIP_DHCP_AUTOIP_COOP_TRIES
N#define LWIP_DHCP_AUTOIP_COOP_TRIES     9
N#endif
N
N/*
N   ----------------------------------
N   ---------- SNMP options ----------
N   ----------------------------------
N*/
N/**
N * LWIP_SNMP==1: Turn on SNMP module. UDP must be available for SNMP
N * transport.
N */
N#ifndef LWIP_SNMP
N#define LWIP_SNMP                       0
N#endif
N
N/**
N * SNMP_CONCURRENT_REQUESTS: Number of concurrent requests the module will
N * allow. At least one request buffer is required.
N * Does not have to be changed unless external MIBs answer request asynchronously
N */
N#ifndef SNMP_CONCURRENT_REQUESTS
N#define SNMP_CONCURRENT_REQUESTS        1
N#endif
N
N/**
N * SNMP_TRAP_DESTINATIONS: Number of trap destinations. At least one trap
N * destination is required
N */
N#ifndef SNMP_TRAP_DESTINATIONS
N#define SNMP_TRAP_DESTINATIONS          1
N#endif
N
N/**
N * SNMP_PRIVATE_MIB: 
N * When using a private MIB, you have to create a file 'private_mib.h' that contains
N * a 'struct mib_array_node mib_private' which contains your MIB.
N */
N#ifndef SNMP_PRIVATE_MIB
N#define SNMP_PRIVATE_MIB                0
N#endif
N
N/**
N * Only allow SNMP write actions that are 'safe' (e.g. disabeling netifs is not
N * a safe action and disabled when SNMP_SAFE_REQUESTS = 1).
N * Unsafe requests are disabled by default!
N */
N#ifndef SNMP_SAFE_REQUESTS
N#define SNMP_SAFE_REQUESTS              1
N#endif
N
N/**
N * The maximum length of strings used. This affects the size of
N * MEMP_SNMP_VALUE elements.
N */
N#ifndef SNMP_MAX_OCTET_STRING_LEN
N#define SNMP_MAX_OCTET_STRING_LEN       127
N#endif
N
N/**
N * The maximum depth of the SNMP tree.
N * With private MIBs enabled, this depends on your MIB!
N * This affects the size of MEMP_SNMP_VALUE elements.
N */
N#ifndef SNMP_MAX_TREE_DEPTH
N#define SNMP_MAX_TREE_DEPTH             15
N#endif
N
N/**
N * The size of the MEMP_SNMP_VALUE elements, normally calculated from
N * SNMP_MAX_OCTET_STRING_LEN and SNMP_MAX_TREE_DEPTH.
N */
N#ifndef SNMP_MAX_VALUE_SIZE
N#define SNMP_MAX_VALUE_SIZE             LWIP_MAX((SNMP_MAX_OCTET_STRING_LEN)+1, sizeof(s32_t)*(SNMP_MAX_TREE_DEPTH))
N#endif
N
N/*
N   ----------------------------------
N   ---------- IGMP options ----------
N   ----------------------------------
N*/
N/**
N * LWIP_IGMP==1: Turn on IGMP module. 
N */
N#ifndef LWIP_IGMP
N#define LWIP_IGMP                       0
N#endif
N
N/*
N   ----------------------------------
N   ---------- DNS options -----------
N   ----------------------------------
N*/
N/**
N * LWIP_DNS==1: Turn on DNS module. UDP must be available for DNS
N * transport.
N */
N#ifndef LWIP_DNS
S#define LWIP_DNS                        0
N#endif
N
N/** DNS maximum number of entries to maintain locally. */
N#ifndef DNS_TABLE_SIZE
S#define DNS_TABLE_SIZE                  4
N#endif
N
N/** DNS maximum host name length supported in the name table. */
N#ifndef DNS_MAX_NAME_LENGTH
N#define DNS_MAX_NAME_LENGTH             256
N#endif
N
N/** The maximum of DNS servers */
N#ifndef DNS_MAX_SERVERS
N#define DNS_MAX_SERVERS                 2
N#endif
N
N/** DNS do a name checking between the query and the response. */
N#ifndef DNS_DOES_NAME_CHECK
N#define DNS_DOES_NAME_CHECK             1
N#endif
N
N/** DNS message max. size. Default value is RFC compliant. */
N#ifndef DNS_MSG_SIZE
N#define DNS_MSG_SIZE                    512
N#endif
N
N/** DNS_LOCAL_HOSTLIST: Implements a local host-to-address list. If enabled,
N *  you have to define
N *    #define DNS_LOCAL_HOSTLIST_INIT {{"host1", 0x123}, {"host2", 0x234}}
N *  (an array of structs name/address, where address is an u32_t in network
N *  byte order).
N *
N *  Instead, you can also use an external function:
N *  #define DNS_LOOKUP_LOCAL_EXTERN(x) extern u32_t my_lookup_function(const char *name)
N *  that returns the IP address or INADDR_NONE if not found.
N */
N#ifndef DNS_LOCAL_HOSTLIST
N#define DNS_LOCAL_HOSTLIST              0
N#endif /* DNS_LOCAL_HOSTLIST */
N
N/** If this is turned on, the local host-list can be dynamically changed
N *  at runtime. */
N#ifndef DNS_LOCAL_HOSTLIST_IS_DYNAMIC
S#define DNS_LOCAL_HOSTLIST_IS_DYNAMIC   0
N#endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
N
N/*
N   ---------------------------------
N   ---------- UDP options ----------
N   ---------------------------------
N*/
N/**
N * LWIP_UDP==1: Turn on UDP.
N */
N#ifndef LWIP_UDP
S#define LWIP_UDP                        1
N#endif
N
N/**
N * LWIP_UDPLITE==1: Turn on UDP-Lite. (Requires LWIP_UDP)
N */
N#ifndef LWIP_UDPLITE
N#define LWIP_UDPLITE                    0
N#endif
N
N/**
N * UDP_TTL: Default Time-To-Live value.
N */
N#ifndef UDP_TTL
S#define UDP_TTL                         (IP_DEFAULT_TTL)
N#endif
N
N/**
N * LWIP_NETBUF_RECVINFO==1: append destination addr and port to every netbuf.
N */
N#ifndef LWIP_NETBUF_RECVINFO
N#define LWIP_NETBUF_RECVINFO            0
N#endif
N
N/*
N   ---------------------------------
N   ---------- TCP options ----------
N   ---------------------------------
N*/
N/**
N * LWIP_TCP==1: Turn on TCP.
N */
N#ifndef LWIP_TCP
S#define LWIP_TCP                        1
N#endif
N
N/**
N * TCP_TTL: Default Time-To-Live value.
N */
N#ifndef TCP_TTL
S#define TCP_TTL                         (IP_DEFAULT_TTL)
N#endif
N
N/**
N * TCP_WND: The size of a TCP window.  This must be at least 
N * (2 * TCP_MSS) for things to work well
N */
N#ifndef TCP_WND
S#define TCP_WND                         (4 * TCP_MSS)
N#endif 
N
N/**
N * TCP_MAXRTX: Maximum number of retransmissions of data segments.
N */
N#ifndef TCP_MAXRTX
N#define TCP_MAXRTX                      12
N#endif
N
N/**
N * TCP_SYNMAXRTX: Maximum number of retransmissions of SYN segments.
N */
N#ifndef TCP_SYNMAXRTX
N#define TCP_SYNMAXRTX                   6
N#endif
N
N/**
N * TCP_QUEUE_OOSEQ==1: TCP will queue segments that arrive out of order.
N * Define to 0 if your device is low on memory.
N */
N#ifndef TCP_QUEUE_OOSEQ
S#define TCP_QUEUE_OOSEQ                 (LWIP_TCP)
N#endif
N
N/**
N * TCP_MSS: TCP Maximum segment size. (default is 536, a conservative default,
N * you might want to increase this.)
N * For the receive side, this MSS is advertised to the remote side
N * when opening a connection. For the transmit size, this MSS sets
N * an upper limit on the MSS advertised by the remote host.
N */
N#ifndef TCP_MSS
S#define TCP_MSS                         536
N#endif
N
N/**
N * TCP_CALCULATE_EFF_SEND_MSS: "The maximum size of a segment that TCP really
N * sends, the 'effective send MSS,' MUST be the smaller of the send MSS (which
N * reflects the available reassembly buffer size at the remote host) and the
N * largest size permitted by the IP layer" (RFC 1122)
N * Setting this to 1 enables code that checks TCP_MSS against the MTU of the
N * netif used for a connection and limits the MSS if it would be too big otherwise.
N */
N#ifndef TCP_CALCULATE_EFF_SEND_MSS
N#define TCP_CALCULATE_EFF_SEND_MSS      1
N#endif
N
N
N/**
N * TCP_SND_BUF: TCP sender buffer space (bytes).
N * To achieve good performance, this should be at least 2 * TCP_MSS.
N */
N#ifndef TCP_SND_BUF
S#define TCP_SND_BUF                     (2 * TCP_MSS)
N#endif
N
N/**
N * TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least
N * as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work.
N */
N#ifndef TCP_SND_QUEUELEN
S#define TCP_SND_QUEUELEN                ((4 * (TCP_SND_BUF) + (TCP_MSS - 1))/(TCP_MSS))
N#endif
N
N/**
N * TCP_SNDLOWAT: TCP writable space (bytes). This must be less than
N * TCP_SND_BUF. It is the amount of space which must be available in the
N * TCP snd_buf for select to return writable (combined with TCP_SNDQUEUELOWAT).
N */
N#ifndef TCP_SNDLOWAT
N#define TCP_SNDLOWAT                    LWIP_MIN(LWIP_MAX(((TCP_SND_BUF)/2), (2 * TCP_MSS) + 1), (TCP_SND_BUF) - 1)
N#endif
N
N/**
N * TCP_SNDQUEUELOWAT: TCP writable bufs (pbuf count). This must be less
N * than TCP_SND_QUEUELEN. If the number of pbufs queued on a pcb drops below
N * this number, select returns writable (combined with TCP_SNDLOWAT).
N */
N#ifndef TCP_SNDQUEUELOWAT
N#define TCP_SNDQUEUELOWAT               LWIP_MAX(((TCP_SND_QUEUELEN)/2), 5)
N#endif
N
N/**
N * TCP_OOSEQ_MAX_BYTES: The maximum number of bytes queued on ooseq per pcb.
N * Default is 0 (no limit). Only valid for TCP_QUEUE_OOSEQ==0.
N */
N#ifndef TCP_OOSEQ_MAX_BYTES
N#define TCP_OOSEQ_MAX_BYTES             0
N#endif
N
N/**
N * TCP_OOSEQ_MAX_PBUFS: The maximum number of pbufs queued on ooseq per pcb.
N * Default is 0 (no limit). Only valid for TCP_QUEUE_OOSEQ==0.
N */
N#ifndef TCP_OOSEQ_MAX_PBUFS
N#define TCP_OOSEQ_MAX_PBUFS             0
N#endif
N
N/**
N * TCP_LISTEN_BACKLOG: Enable the backlog option for tcp listen pcb.
N */
N#ifndef TCP_LISTEN_BACKLOG
N#define TCP_LISTEN_BACKLOG              0
N#endif
N
N/**
N * The maximum allowed backlog for TCP listen netconns.
N * This backlog is used unless another is explicitly specified.
N * 0xff is the maximum (u8_t).
N */
N#ifndef TCP_DEFAULT_LISTEN_BACKLOG
N#define TCP_DEFAULT_LISTEN_BACKLOG      0xff
N#endif
N
N/**
N * TCP_OVERSIZE: The maximum number of bytes that tcp_write may
N * allocate ahead of time in an attempt to create shorter pbuf chains
N * for transmission. The meaningful range is 0 to TCP_MSS. Some
N * suggested values are:
N *
N * 0:         Disable oversized allocation. Each tcp_write() allocates a new
N              pbuf (old behaviour).
N * 1:         Allocate size-aligned pbufs with minimal excess. Use this if your
N *            scatter-gather DMA requires aligned fragments.
N * 128:       Limit the pbuf/memory overhead to 20%.
N * TCP_MSS:   Try to create unfragmented TCP packets.
N * TCP_MSS/4: Try to create 4 fragments or less per TCP packet.
N */
N#ifndef TCP_OVERSIZE
N#define TCP_OVERSIZE                    TCP_MSS
N#endif
N
N/**
N * LWIP_TCP_TIMESTAMPS==1: support the TCP timestamp option.
N */
N#ifndef LWIP_TCP_TIMESTAMPS
N#define LWIP_TCP_TIMESTAMPS             0
N#endif
N
N/**
N * TCP_WND_UPDATE_THRESHOLD: difference in window to trigger an
N * explicit window update
N */
N#ifndef TCP_WND_UPDATE_THRESHOLD
N#define TCP_WND_UPDATE_THRESHOLD   (TCP_WND / 4)
N#endif
N
N/**
N * LWIP_EVENT_API and LWIP_CALLBACK_API: Only one of these should be set to 1.
N *     LWIP_EVENT_API==1: The user defines lwip_tcp_event() to receive all
N *         events (accept, sent, etc) that happen in the system.
N *     LWIP_CALLBACK_API==1: The PCB callback function is called directly
N *         for the event. This is the default.
N */
N#if !defined(LWIP_EVENT_API) && !defined(LWIP_CALLBACK_API)
X#if !0L && !0L
N#define LWIP_EVENT_API                  0
N#define LWIP_CALLBACK_API               1
N#endif
N
N
N/*
N   ----------------------------------
N   ---------- Pbuf options ----------
N   ----------------------------------
N*/
N/**
N * PBUF_LINK_HLEN: the number of bytes that should be allocated for a
N * link level header. The default is 14, the standard value for
N * Ethernet.
N */
N#ifndef PBUF_LINK_HLEN
N#define PBUF_LINK_HLEN                  (14 + ETH_PAD_SIZE)
N#endif
N
N/**
N * PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. The default is
N * designed to accomodate single full size TCP frame in one pbuf, including
N * TCP_MSS, IP header, and link header.
N */
N#ifndef PBUF_POOL_BUFSIZE
S#define PBUF_POOL_BUFSIZE               LWIP_MEM_ALIGN_SIZE(TCP_MSS+40+PBUF_LINK_HLEN)
N#endif
N
N/*
N   ------------------------------------------------
N   ---------- Network Interfaces options ----------
N   ------------------------------------------------
N*/
N/**
N * LWIP_NETIF_HOSTNAME==1: use DHCP_OPTION_HOSTNAME with netif's hostname
N * field.
N */
N#ifndef LWIP_NETIF_HOSTNAME
N#define LWIP_NETIF_HOSTNAME             0
N#endif
N
N/**
N * LWIP_NETIF_API==1: Support netif api (in netifapi.c)
N */
N#ifndef LWIP_NETIF_API
N#define LWIP_NETIF_API                  0
N#endif
N
N/**
N * LWIP_NETIF_STATUS_CALLBACK==1: Support a callback function whenever an interface
N * changes its up/down status (i.e., due to DHCP IP acquistion)
N */
N#ifndef LWIP_NETIF_STATUS_CALLBACK
N#define LWIP_NETIF_STATUS_CALLBACK      0
N#endif
N
N/**
N * LWIP_NETIF_LINK_CALLBACK==1: Support a callback function from an interface
N * whenever the link changes (i.e., link down)
N */
N#ifndef LWIP_NETIF_LINK_CALLBACK
S#define LWIP_NETIF_LINK_CALLBACK        0
N#endif
N
N/**
N * LWIP_NETIF_REMOVE_CALLBACK==1: Support a callback function that is called
N * when a netif has been removed
N */
N#ifndef LWIP_NETIF_REMOVE_CALLBACK
N#define LWIP_NETIF_REMOVE_CALLBACK      0
N#endif
N
N/**
N * LWIP_NETIF_HWADDRHINT==1: Cache link-layer-address hints (e.g. table
N * indices) in struct netif. TCP and UDP can make use of this to prevent
N * scanning the ARP table for every sent packet. While this is faster for big
N * ARP tables or many concurrent connections, it might be counterproductive
N * if you have a tiny ARP table or if there never are concurrent connections.
N */
N#ifndef LWIP_NETIF_HWADDRHINT
N#define LWIP_NETIF_HWADDRHINT           0
N#endif
N
N/**
N * LWIP_NETIF_LOOPBACK==1: Support sending packets with a destination IP
N * address equal to the netif IP address, looping them back up the stack.
N */
N#ifndef LWIP_NETIF_LOOPBACK
N#define LWIP_NETIF_LOOPBACK             0
N#endif
N
N/**
N * LWIP_LOOPBACK_MAX_PBUFS: Maximum number of pbufs on queue for loopback
N * sending for each netif (0 = disabled)
N */
N#ifndef LWIP_LOOPBACK_MAX_PBUFS
N#define LWIP_LOOPBACK_MAX_PBUFS         0
N#endif
N
N/**
N * LWIP_NETIF_LOOPBACK_MULTITHREADING: Indicates whether threading is enabled in
N * the system, as netifs must change how they behave depending on this setting
N * for the LWIP_NETIF_LOOPBACK option to work.
N * Setting this is needed to avoid reentering non-reentrant functions like
N * tcp_input().
N *    LWIP_NETIF_LOOPBACK_MULTITHREADING==1: Indicates that the user is using a
N *       multithreaded environment like tcpip.c. In this case, netif->input()
N *       is called directly.
N *    LWIP_NETIF_LOOPBACK_MULTITHREADING==0: Indicates a polling (or NO_SYS) setup.
N *       The packets are put on a list and netif_poll() must be called in
N *       the main application loop.
N */
N#ifndef LWIP_NETIF_LOOPBACK_MULTITHREADING
N#define LWIP_NETIF_LOOPBACK_MULTITHREADING    (!NO_SYS)
N#endif
N
N/**
N * LWIP_NETIF_TX_SINGLE_PBUF: if this is set to 1, lwIP tries to put all data
N * to be sent into one single pbuf. This is for compatibility with DMA-enabled
N * MACs that do not support scatter-gather.
N * Beware that this might involve CPU-memcpy before transmitting that would not
N * be needed without this flag! Use this only if you need to!
N *
N * @todo: TCP and IP-frag do not work with this, yet:
N */
N#ifndef LWIP_NETIF_TX_SINGLE_PBUF
N#define LWIP_NETIF_TX_SINGLE_PBUF             0
N#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
N
N/*
N   ------------------------------------
N   ---------- LOOPIF options ----------
N   ------------------------------------
N*/
N/**
N * LWIP_HAVE_LOOPIF==1: Support loop interface (127.0.0.1) and loopif.c
N */
N#ifndef LWIP_HAVE_LOOPIF
N#define LWIP_HAVE_LOOPIF                0
N#endif
N
N/*
N   ------------------------------------
N   ---------- SLIPIF options ----------
N   ------------------------------------
N*/
N/**
N * LWIP_HAVE_SLIPIF==1: Support slip interface and slipif.c
N */
N#ifndef LWIP_HAVE_SLIPIF
N#define LWIP_HAVE_SLIPIF                0
N#endif
N
N/*
N   ------------------------------------
N   ---------- Thread options ----------
N   ------------------------------------
N*/
N/**
N * TCPIP_THREAD_NAME: The name assigned to the main tcpip thread.
N */
N#ifndef TCPIP_THREAD_NAME
N#define TCPIP_THREAD_NAME              "tcpip_thread"
N#endif
N
N/**
N * TCPIP_THREAD_STACKSIZE: The stack size used by the main tcpip thread.
N * The stack size value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef TCPIP_THREAD_STACKSIZE
N#define TCPIP_THREAD_STACKSIZE          0
N#endif
N
N/**
N * TCPIP_THREAD_PRIO: The priority assigned to the main tcpip thread.
N * The priority value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef TCPIP_THREAD_PRIO
N#define TCPIP_THREAD_PRIO               1
N#endif
N
N/**
N * TCPIP_MBOX_SIZE: The mailbox size for the tcpip thread messages
N * The queue size value itself is platform-dependent, but is passed to
N * sys_mbox_new() when tcpip_init is called.
N */
N#ifndef TCPIP_MBOX_SIZE
N#define TCPIP_MBOX_SIZE                 0
N#endif
N
N/**
N * SLIPIF_THREAD_NAME: The name assigned to the slipif_loop thread.
N */
N#ifndef SLIPIF_THREAD_NAME
N#define SLIPIF_THREAD_NAME             "slipif_loop"
N#endif
N
N/**
N * SLIP_THREAD_STACKSIZE: The stack size used by the slipif_loop thread.
N * The stack size value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef SLIPIF_THREAD_STACKSIZE
N#define SLIPIF_THREAD_STACKSIZE         0
N#endif
N
N/**
N * SLIPIF_THREAD_PRIO: The priority assigned to the slipif_loop thread.
N * The priority value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef SLIPIF_THREAD_PRIO
N#define SLIPIF_THREAD_PRIO              1
N#endif
N
N/**
N * PPP_THREAD_NAME: The name assigned to the pppInputThread.
N */
N#ifndef PPP_THREAD_NAME
N#define PPP_THREAD_NAME                "pppInputThread"
N#endif
N
N/**
N * PPP_THREAD_STACKSIZE: The stack size used by the pppInputThread.
N * The stack size value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef PPP_THREAD_STACKSIZE
N#define PPP_THREAD_STACKSIZE            0
N#endif
N
N/**
N * PPP_THREAD_PRIO: The priority assigned to the pppInputThread.
N * The priority value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef PPP_THREAD_PRIO
N#define PPP_THREAD_PRIO                 1
N#endif
N
N/**
N * DEFAULT_THREAD_NAME: The name assigned to any other lwIP thread.
N */
N#ifndef DEFAULT_THREAD_NAME
N#define DEFAULT_THREAD_NAME            "lwIP"
N#endif
N
N/**
N * DEFAULT_THREAD_STACKSIZE: The stack size used by any other lwIP thread.
N * The stack size value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef DEFAULT_THREAD_STACKSIZE
N#define DEFAULT_THREAD_STACKSIZE        0
N#endif
N
N/**
N * DEFAULT_THREAD_PRIO: The priority assigned to any other lwIP thread.
N * The priority value itself is platform-dependent, but is passed to
N * sys_thread_new() when the thread is created.
N */
N#ifndef DEFAULT_THREAD_PRIO
N#define DEFAULT_THREAD_PRIO             1
N#endif
N
N/**
N * DEFAULT_RAW_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
N * NETCONN_RAW. The queue size value itself is platform-dependent, but is passed
N * to sys_mbox_new() when the recvmbox is created.
N */
N#ifndef DEFAULT_RAW_RECVMBOX_SIZE
N#define DEFAULT_RAW_RECVMBOX_SIZE       0
N#endif
N
N/**
N * DEFAULT_UDP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
N * NETCONN_UDP. The queue size value itself is platform-dependent, but is passed
N * to sys_mbox_new() when the recvmbox is created.
N */
N#ifndef DEFAULT_UDP_RECVMBOX_SIZE
N#define DEFAULT_UDP_RECVMBOX_SIZE       0
N#endif
N
N/**
N * DEFAULT_TCP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
N * NETCONN_TCP. The queue size value itself is platform-dependent, but is passed
N * to sys_mbox_new() when the recvmbox is created.
N */
N#ifndef DEFAULT_TCP_RECVMBOX_SIZE
N#define DEFAULT_TCP_RECVMBOX_SIZE       0
N#endif
N
N/**
N * DEFAULT_ACCEPTMBOX_SIZE: The mailbox size for the incoming connections.
N * The queue size value itself is platform-dependent, but is passed to
N * sys_mbox_new() when the acceptmbox is created.
N */
N#ifndef DEFAULT_ACCEPTMBOX_SIZE
N#define DEFAULT_ACCEPTMBOX_SIZE         0
N#endif
N
N/*
N   ----------------------------------------------
N   ---------- Sequential layer options ----------
N   ----------------------------------------------
N*/
N/**
N * LWIP_TCPIP_CORE_LOCKING: (EXPERIMENTAL!)
N * Don't use it if you're not an active lwIP project member
N */
N#ifndef LWIP_TCPIP_CORE_LOCKING
N#define LWIP_TCPIP_CORE_LOCKING         0
N#endif
N
N/**
N * LWIP_TCPIP_CORE_LOCKING_INPUT: (EXPERIMENTAL!)
N * Don't use it if you're not an active lwIP project member
N */
N#ifndef LWIP_TCPIP_CORE_LOCKING_INPUT
N#define LWIP_TCPIP_CORE_LOCKING_INPUT   0
N#endif
N
N/**
N * LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c)
N */
N#ifndef LWIP_NETCONN
S#define LWIP_NETCONN                    1
N#endif
N
N/** LWIP_TCPIP_TIMEOUT==1: Enable tcpip_timeout/tcpip_untimeout tod create
N * timers running in tcpip_thread from another thread.
N */
N#ifndef LWIP_TCPIP_TIMEOUT
N#define LWIP_TCPIP_TIMEOUT              1
N#endif
N
N/*
N   ------------------------------------
N   ---------- Socket options ----------
N   ------------------------------------
N*/
N/**
N * LWIP_SOCKET==1: Enable Socket API (require to use sockets.c)
N */
N#ifndef LWIP_SOCKET
S#define LWIP_SOCKET                     1
N#endif
N
N/**
N * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
N * (only used if you use sockets.c)
N */
N#ifndef LWIP_COMPAT_SOCKETS
N#define LWIP_COMPAT_SOCKETS             1
N#endif
N
N/**
N * LWIP_POSIX_SOCKETS_IO_NAMES==1: Enable POSIX-style sockets functions names.
N * Disable this option if you use a POSIX operating system that uses the same
N * names (read, write & close). (only used if you use sockets.c)
N */
N#ifndef LWIP_POSIX_SOCKETS_IO_NAMES
N#define LWIP_POSIX_SOCKETS_IO_NAMES     1
N#endif
N
N/**
N * LWIP_TCP_KEEPALIVE==1: Enable TCP_KEEPIDLE, TCP_KEEPINTVL and TCP_KEEPCNT
N * options processing. Note that TCP_KEEPIDLE and TCP_KEEPINTVL have to be set
N * in seconds. (does not require sockets.c, and will affect tcp.c)
N */
N#ifndef LWIP_TCP_KEEPALIVE
N#define LWIP_TCP_KEEPALIVE              0
N#endif
N
N/**
N * LWIP_SO_SNDTIMEO==1: Enable send timeout for sockets/netconns and
N * SO_SNDTIMEO processing.
N */
N#ifndef LWIP_SO_SNDTIMEO
N#define LWIP_SO_SNDTIMEO                0
N#endif
N
N/**
N * LWIP_SO_RCVTIMEO==1: Enable receive timeout for sockets/netconns and
N * SO_RCVTIMEO processing.
N */
N#ifndef LWIP_SO_RCVTIMEO
N#define LWIP_SO_RCVTIMEO                0
N#endif
N
N/**
N * LWIP_SO_RCVBUF==1: Enable SO_RCVBUF processing.
N */
N#ifndef LWIP_SO_RCVBUF
N#define LWIP_SO_RCVBUF                  0
N#endif
N
N/**
N * If LWIP_SO_RCVBUF is used, this is the default value for recv_bufsize.
N */
N#ifndef RECV_BUFSIZE_DEFAULT
N#define RECV_BUFSIZE_DEFAULT            INT_MAX
N#endif
N
N/**
N * SO_REUSE==1: Enable SO_REUSEADDR option.
N */
N#ifndef SO_REUSE
N#define SO_REUSE                        0
N#endif
N
N/**
N * SO_REUSE_RXTOALL==1: Pass a copy of incoming broadcast/multicast packets
N * to all local matches if SO_REUSEADDR is turned on.
N * WARNING: Adds a memcpy for every packet if passing to more than one pcb!
N */
N#ifndef SO_REUSE_RXTOALL
N#define SO_REUSE_RXTOALL                0
N#endif
N
N/*
N   ----------------------------------------
N   ---------- Statistics options ----------
N   ----------------------------------------
N*/
N/**
N * LWIP_STATS==1: Enable statistics collection in lwip_stats.
N */
N#ifndef LWIP_STATS
S#define LWIP_STATS                      1
N#endif
N
N#if LWIP_STATS
X#if 0
S
S/**
S * LWIP_STATS_DISPLAY==1: Compile in the statistics output functions.
S */
S#ifndef LWIP_STATS_DISPLAY
S#define LWIP_STATS_DISPLAY              0
S#endif
S
S/**
S * LINK_STATS==1: Enable link stats.
S */
S#ifndef LINK_STATS
S#define LINK_STATS                      1
S#endif
S
S/**
S * ETHARP_STATS==1: Enable etharp stats.
S */
S#ifndef ETHARP_STATS
S#define ETHARP_STATS                    (LWIP_ARP)
S#endif
S
S/**
S * IP_STATS==1: Enable IP stats.
S */
S#ifndef IP_STATS
S#define IP_STATS                        1
S#endif
S
S/**
S * IPFRAG_STATS==1: Enable IP fragmentation stats. Default is
S * on if using either frag or reass.
S */
S#ifndef IPFRAG_STATS
S#define IPFRAG_STATS                    (IP_REASSEMBLY || IP_FRAG)
S#endif
S
S/**
S * ICMP_STATS==1: Enable ICMP stats.
S */
S#ifndef ICMP_STATS
S#define ICMP_STATS                      1
S#endif
S
S/**
S * IGMP_STATS==1: Enable IGMP stats.
S */
S#ifndef IGMP_STATS
S#define IGMP_STATS                      (LWIP_IGMP)
S#endif
S
S/**
S * UDP_STATS==1: Enable UDP stats. Default is on if
S * UDP enabled, otherwise off.
S */
S#ifndef UDP_STATS
S#define UDP_STATS                       (LWIP_UDP)
S#endif
S
S/**
S * TCP_STATS==1: Enable TCP stats. Default is on if TCP
S * enabled, otherwise off.
S */
S#ifndef TCP_STATS
S#define TCP_STATS                       (LWIP_TCP)
S#endif
S
S/**
S * MEM_STATS==1: Enable mem.c stats.
S */
S#ifndef MEM_STATS
S#define MEM_STATS                       ((MEM_LIBC_MALLOC == 0) && (MEM_USE_POOLS == 0))
S#endif
S
S/**
S * MEMP_STATS==1: Enable memp.c pool stats.
S */
S#ifndef MEMP_STATS
S#define MEMP_STATS                      (MEMP_MEM_MALLOC == 0)
S#endif
S
S/**
S * SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
S */
S#ifndef SYS_STATS
S#define SYS_STATS                       (NO_SYS == 0)
S#endif
S
N#else
N
N#define LINK_STATS                      0
N#define IP_STATS                        0
N#define IPFRAG_STATS                    0
N#define ICMP_STATS                      0
N#define IGMP_STATS                      0
N#define UDP_STATS                       0
N#define TCP_STATS                       0
N#define MEM_STATS                       0
N#define MEMP_STATS                      0
N#define SYS_STATS                       0
N#define LWIP_STATS_DISPLAY              0
N
N#endif /* LWIP_STATS */
N
N/*
N   ---------------------------------
N   ---------- PPP options ----------
N   ---------------------------------
N*/
N/**
N * PPP_SUPPORT==1: Enable PPP.
N */
N#ifndef PPP_SUPPORT
N#define PPP_SUPPORT                     0
N#endif
N
N/**
N * PPPOE_SUPPORT==1: Enable PPP Over Ethernet
N */
N#ifndef PPPOE_SUPPORT
N#define PPPOE_SUPPORT                   0
N#endif
N
N/**
N * PPPOS_SUPPORT==1: Enable PPP Over Serial
N */
N#ifndef PPPOS_SUPPORT
N#define PPPOS_SUPPORT                   PPP_SUPPORT
N#endif
N
N#if PPP_SUPPORT
X#if 0
S
S/**
S * NUM_PPP: Max PPP sessions.
S */
S#ifndef NUM_PPP
S#define NUM_PPP                         1
S#endif
S
S/**
S * PAP_SUPPORT==1: Support PAP.
S */
S#ifndef PAP_SUPPORT
S#define PAP_SUPPORT                     0
S#endif
S
S/**
S * CHAP_SUPPORT==1: Support CHAP.
S */
S#ifndef CHAP_SUPPORT
S#define CHAP_SUPPORT                    0
S#endif
S
S/**
S * MSCHAP_SUPPORT==1: Support MSCHAP. CURRENTLY NOT SUPPORTED! DO NOT SET!
S */
S#ifndef MSCHAP_SUPPORT
S#define MSCHAP_SUPPORT                  0
S#endif
S
S/**
S * CBCP_SUPPORT==1: Support CBCP. CURRENTLY NOT SUPPORTED! DO NOT SET!
S */
S#ifndef CBCP_SUPPORT
S#define CBCP_SUPPORT                    0
S#endif
S
S/**
S * CCP_SUPPORT==1: Support CCP. CURRENTLY NOT SUPPORTED! DO NOT SET!
S */
S#ifndef CCP_SUPPORT
S#define CCP_SUPPORT                     0
S#endif
S
S/**
S * VJ_SUPPORT==1: Support VJ header compression.
S */
S#ifndef VJ_SUPPORT
S#define VJ_SUPPORT                      0
S#endif
S
S/**
S * MD5_SUPPORT==1: Support MD5 (see also CHAP).
S */
S#ifndef MD5_SUPPORT
S#define MD5_SUPPORT                     0
S#endif
S
S/*
S * Timeouts
S */
S#ifndef FSM_DEFTIMEOUT
S#define FSM_DEFTIMEOUT                  6       /* Timeout time in seconds */
S#endif
S
S#ifndef FSM_DEFMAXTERMREQS
S#define FSM_DEFMAXTERMREQS              2       /* Maximum Terminate-Request transmissions */
S#endif
S
S#ifndef FSM_DEFMAXCONFREQS
S#define FSM_DEFMAXCONFREQS              10      /* Maximum Configure-Request transmissions */
S#endif
S
S#ifndef FSM_DEFMAXNAKLOOPS
S#define FSM_DEFMAXNAKLOOPS              5       /* Maximum number of nak loops */
S#endif
S
S#ifndef UPAP_DEFTIMEOUT
S#define UPAP_DEFTIMEOUT                 6       /* Timeout (seconds) for retransmitting req */
S#endif
S
S#ifndef UPAP_DEFREQTIME
S#define UPAP_DEFREQTIME                 30      /* Time to wait for auth-req from peer */
S#endif
S
S#ifndef CHAP_DEFTIMEOUT
S#define CHAP_DEFTIMEOUT                 6       /* Timeout time in seconds */
S#endif
S
S#ifndef CHAP_DEFTRANSMITS
S#define CHAP_DEFTRANSMITS               10      /* max # times to send challenge */
S#endif
S
S/* Interval in seconds between keepalive echo requests, 0 to disable. */
S#ifndef LCP_ECHOINTERVAL
S#define LCP_ECHOINTERVAL                0
S#endif
S
S/* Number of unanswered echo requests before failure. */
S#ifndef LCP_MAXECHOFAILS
S#define LCP_MAXECHOFAILS                3
S#endif
S
S/* Max Xmit idle time (in jiffies) before resend flag char. */
S#ifndef PPP_MAXIDLEFLAG
S#define PPP_MAXIDLEFLAG                 100
S#endif
S
S/*
S * Packet sizes
S *
S * Note - lcp shouldn't be allowed to negotiate stuff outside these
S *    limits.  See lcp.h in the pppd directory.
S * (XXX - these constants should simply be shared by lcp.c instead
S *    of living in lcp.h)
S */
S#define PPP_MTU                         1500     /* Default MTU (size of Info field) */
S#ifndef PPP_MAXMTU
S/* #define PPP_MAXMTU  65535 - (PPP_HDRLEN + PPP_FCSLEN) */
S#define PPP_MAXMTU                      1500 /* Largest MTU we allow */
S#endif
S#define PPP_MINMTU                      64
S#define PPP_MRU                         1500     /* default MRU = max length of info field */
S#define PPP_MAXMRU                      1500     /* Largest MRU we allow */
S#ifndef PPP_DEFMRU
S#define PPP_DEFMRU                      296             /* Try for this */
S#endif
S#define PPP_MINMRU                      128             /* No MRUs below this */
S
S#ifndef MAXNAMELEN
S#define MAXNAMELEN                      256     /* max length of hostname or name for auth */
S#endif
S#ifndef MAXSECRETLEN
S#define MAXSECRETLEN                    256     /* max length of password or secret */
S#endif
S
N#endif /* PPP_SUPPORT */
N
N/*
N   --------------------------------------
N   ---------- Checksum options ----------
N   --------------------------------------
N*/
N/**
N * CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.
N */
N#ifndef CHECKSUM_GEN_IP
S#define CHECKSUM_GEN_IP                 1
N#endif
N 
N/**
N * CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.
N */
N#ifndef CHECKSUM_GEN_UDP
S#define CHECKSUM_GEN_UDP                1
N#endif
N 
N/**
N * CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.
N */
N#ifndef CHECKSUM_GEN_TCP
S#define CHECKSUM_GEN_TCP                1
N#endif
N
N/**
N * CHECKSUM_GEN_ICMP==1: Generate checksums in software for outgoing ICMP packets.
N */
N#ifndef CHECKSUM_GEN_ICMP
S#define CHECKSUM_GEN_ICMP               1
N#endif
N 
N/**
N * CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.
N */
N#ifndef CHECKSUM_CHECK_IP
S#define CHECKSUM_CHECK_IP               1
N#endif
N 
N/**
N * CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.
N */
N#ifndef CHECKSUM_CHECK_UDP
S#define CHECKSUM_CHECK_UDP              1
N#endif
N
N/**
N * CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.
N */
N#ifndef CHECKSUM_CHECK_TCP
S#define CHECKSUM_CHECK_TCP              1
N#endif
N
N/**
N * LWIP_CHECKSUM_ON_COPY==1: Calculate checksum when copying data from
N * application buffers to pbufs.
N */
N#ifndef LWIP_CHECKSUM_ON_COPY
N#define LWIP_CHECKSUM_ON_COPY           0
N#endif
N
N/*
N   ---------------------------------------
N   ---------- Hook options ---------------
N   ---------------------------------------
N*/
N
N/* Hooks are undefined by default, define them to a function if you need them. */
N
N/**
N * LWIP_HOOK_IP4_INPUT(pbuf, input_netif):
N * - called from ip_input() (IPv4)
N * - pbuf: received struct pbuf passed to ip_input()
N * - input_netif: struct netif on which the packet has been received
N * Return values:
N * - 0: Hook has not consumed the packet, packet is processed as normal
N * - != 0: Hook has consumed the packet.
N * If the hook consumed the packet, 'pbuf' is in the responsibility of the hook
N * (i.e. free it when done).
N */
N
N/**
N * LWIP_HOOK_IP4_ROUTE(dest):
N * - called from ip_route() (IPv4)
N * - dest: destination IPv4 address
N * Returns the destination netif or NULL if no destination netif is found. In
N * that case, ip_route() continues as normal.
N */
N
N/*
N   ---------------------------------------
N   ---------- Debugging options ----------
N   ---------------------------------------
N*/
N/**
N * LWIP_DBG_MIN_LEVEL: After masking, the value of the debug is
N * compared against this value. If it is smaller, then debugging
N * messages are written.
N */
N#ifndef LWIP_DBG_MIN_LEVEL
N#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_ALL
N#endif
N
N/**
N * LWIP_DBG_TYPES_ON: A mask that can be used to globally enable/disable
N * debug messages of certain types.
N */
N#ifndef LWIP_DBG_TYPES_ON
N#define LWIP_DBG_TYPES_ON               LWIP_DBG_ON
N#endif
N
N/**
N * ETHARP_DEBUG: Enable debugging in etharp.c.
N */
N#ifndef ETHARP_DEBUG
N#define ETHARP_DEBUG                    LWIP_DBG_OFF
N#endif
N
N/**
N * NETIF_DEBUG: Enable debugging in netif.c.
N */
N#ifndef NETIF_DEBUG
N#define NETIF_DEBUG                     LWIP_DBG_OFF
N#endif
N
N/**
N * PBUF_DEBUG: Enable debugging in pbuf.c.
N */
N#ifndef PBUF_DEBUG
N#define PBUF_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * API_LIB_DEBUG: Enable debugging in api_lib.c.
N */
N#ifndef API_LIB_DEBUG
N#define API_LIB_DEBUG                   LWIP_DBG_OFF
N#endif
N
N/**
N * API_MSG_DEBUG: Enable debugging in api_msg.c.
N */
N#ifndef API_MSG_DEBUG
N#define API_MSG_DEBUG                   LWIP_DBG_OFF
N#endif
N
N/**
N * SOCKETS_DEBUG: Enable debugging in sockets.c.
N */
N#ifndef SOCKETS_DEBUG
N#define SOCKETS_DEBUG                   LWIP_DBG_OFF
N#endif
N
N/**
N * ICMP_DEBUG: Enable debugging in icmp.c.
N */
N#ifndef ICMP_DEBUG
N#define ICMP_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * IGMP_DEBUG: Enable debugging in igmp.c.
N */
N#ifndef IGMP_DEBUG
N#define IGMP_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * INET_DEBUG: Enable debugging in inet.c.
N */
N#ifndef INET_DEBUG
N#define INET_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * IP_DEBUG: Enable debugging for IP.
N */
N#ifndef IP_DEBUG
N#define IP_DEBUG                        LWIP_DBG_OFF
N#endif
N
N/**
N * IP_REASS_DEBUG: Enable debugging in ip_frag.c for both frag & reass.
N */
N#ifndef IP_REASS_DEBUG
N#define IP_REASS_DEBUG                  LWIP_DBG_OFF
N#endif
N
N/**
N * RAW_DEBUG: Enable debugging in raw.c.
N */
N#ifndef RAW_DEBUG
N#define RAW_DEBUG                       LWIP_DBG_OFF
N#endif
N
N/**
N * MEM_DEBUG: Enable debugging in mem.c.
N */
N#ifndef MEM_DEBUG
N#define MEM_DEBUG                       LWIP_DBG_OFF
N#endif
N
N/**
N * MEMP_DEBUG: Enable debugging in memp.c.
N */
N#ifndef MEMP_DEBUG
N#define MEMP_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * SYS_DEBUG: Enable debugging in sys.c.
N */
N#ifndef SYS_DEBUG
N#define SYS_DEBUG                       LWIP_DBG_OFF
N#endif
N
N/**
N * TIMERS_DEBUG: Enable debugging in timers.c.
N */
N#ifndef TIMERS_DEBUG
N#define TIMERS_DEBUG                    LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_DEBUG: Enable debugging for TCP.
N */
N#ifndef TCP_DEBUG
N#define TCP_DEBUG                       LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_INPUT_DEBUG: Enable debugging in tcp_in.c for incoming debug.
N */
N#ifndef TCP_INPUT_DEBUG
N#define TCP_INPUT_DEBUG                 LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_FR_DEBUG: Enable debugging in tcp_in.c for fast retransmit.
N */
N#ifndef TCP_FR_DEBUG
N#define TCP_FR_DEBUG                    LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_RTO_DEBUG: Enable debugging in TCP for retransmit
N * timeout.
N */
N#ifndef TCP_RTO_DEBUG
N#define TCP_RTO_DEBUG                   LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_CWND_DEBUG: Enable debugging for TCP congestion window.
N */
N#ifndef TCP_CWND_DEBUG
N#define TCP_CWND_DEBUG                  LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_WND_DEBUG: Enable debugging in tcp_in.c for window updating.
N */
N#ifndef TCP_WND_DEBUG
N#define TCP_WND_DEBUG                   LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_OUTPUT_DEBUG: Enable debugging in tcp_out.c output functions.
N */
N#ifndef TCP_OUTPUT_DEBUG
N#define TCP_OUTPUT_DEBUG                LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_RST_DEBUG: Enable debugging for TCP with the RST message.
N */
N#ifndef TCP_RST_DEBUG
N#define TCP_RST_DEBUG                   LWIP_DBG_OFF
N#endif
N
N/**
N * TCP_QLEN_DEBUG: Enable debugging for TCP queue lengths.
N */
N#ifndef TCP_QLEN_DEBUG
N#define TCP_QLEN_DEBUG                  LWIP_DBG_OFF
N#endif
N
N/**
N * UDP_DEBUG: Enable debugging in UDP.
N */
N#ifndef UDP_DEBUG
N#define UDP_DEBUG                       LWIP_DBG_OFF
N#endif
N
N/**
N * TCPIP_DEBUG: Enable debugging in tcpip.c.
N */
N#ifndef TCPIP_DEBUG
N#define TCPIP_DEBUG                     LWIP_DBG_OFF
N#endif
N
N/**
N * PPP_DEBUG: Enable debugging for PPP.
N */
N#ifndef PPP_DEBUG
N#define PPP_DEBUG                       LWIP_DBG_OFF
N#endif
N
N/**
N * SLIP_DEBUG: Enable debugging in slipif.c.
N */
N#ifndef SLIP_DEBUG
N#define SLIP_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * DHCP_DEBUG: Enable debugging in dhcp.c.
N */
N#ifndef DHCP_DEBUG
N#define DHCP_DEBUG                      LWIP_DBG_OFF
N#endif
N
N/**
N * AUTOIP_DEBUG: Enable debugging in autoip.c.
N */
N#ifndef AUTOIP_DEBUG
N#define AUTOIP_DEBUG                    LWIP_DBG_OFF
N#endif
N
N/**
N * SNMP_MSG_DEBUG: Enable debugging for SNMP messages.
N */
N#ifndef SNMP_MSG_DEBUG
N#define SNMP_MSG_DEBUG                  LWIP_DBG_OFF
N#endif
N
N/**
N * SNMP_MIB_DEBUG: Enable debugging for SNMP MIBs.
N */
N#ifndef SNMP_MIB_DEBUG
N#define SNMP_MIB_DEBUG                  LWIP_DBG_OFF
N#endif
N
N/**
N * DNS_DEBUG: Enable debugging for DNS.
N */
N#ifndef DNS_DEBUG
N#define DNS_DEBUG                       LWIP_DBG_OFF
N#endif
N
N#endif /* __LWIP_OPT_H__ */
L 37 "..\..\Lwip\lwip-1.4.1\src\include\lwip\timers.h" 2
N
N/* Timers are not supported when NO_SYS==1 and NO_SYS_NO_TIMERS==1 */
N#define LWIP_TIMERS (!NO_SYS || (NO_SYS && !NO_SYS_NO_TIMERS))
N
N#if LWIP_TIMERS
X#if (!1 || (1 && !1))
S
S#include "lwip/err.h"
S#if !NO_SYS
S#include "lwip/sys.h"
S#endif
S
S#ifdef __cplusplus
Sextern "C" {
S#endif
S
S#ifndef LWIP_DEBUG_TIMERNAMES
S#ifdef LWIP_DEBUG
S#define LWIP_DEBUG_TIMERNAMES SYS_DEBUG
S#else /* LWIP_DEBUG */
S#define LWIP_DEBUG_TIMERNAMES 0
S#endif /* LWIP_DEBUG*/
S#endif
S
S/** Function prototype for a timeout callback function. Register such a function
S * using sys_timeout().
S *
S * @param arg Additional argument to pass to the function - set up by sys_timeout()
S */
Stypedef void (* sys_timeout_handler)(void *arg);
S
Sstruct sys_timeo {
S  struct sys_timeo *next;
S  u32_t time;
S  sys_timeout_handler h;
S  void *arg;
S#if LWIP_DEBUG_TIMERNAMES
S  const char* handler_name;
S#endif /* LWIP_DEBUG_TIMERNAMES */
S};
S
Svoid sys_timeouts_init(void);
S
S#if LWIP_DEBUG_TIMERNAMES
Svoid sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char* handler_name);
S#define sys_timeout(msecs, handler, arg) sys_timeout_debug(msecs, handler, arg, #handler)
S#else /* LWIP_DEBUG_TIMERNAMES */
Svoid sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg);
S#endif /* LWIP_DEBUG_TIMERNAMES */
S
Svoid sys_untimeout(sys_timeout_handler handler, void *arg);
S#if NO_SYS
Svoid sys_check_timeouts(void);
Svoid sys_restart_timeouts(void);
S#else /* NO_SYS */
Svoid sys_timeouts_mbox_fetch(sys_mbox_t *mbox, void **msg);
S#endif /* NO_SYS */
S
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* LWIP_TIMERS */
N#endif /* __LWIP_TIMERS_H__ */
L 83 "..\..\FreeRTOS\Source\tasks.c" 2
N#include "StackMacros.h"
L 1 "..\..\FreeRTOS\Source\include\StackMacros.h" 1
N/*
N    FreeRTOS V8.2.2 - Copyright (C) 2015 Real Time Engineers Ltd.
N    All rights reserved
N
N    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
N
N    ***************************************************************************
N    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
N    >>!   distribute a combined work that includes FreeRTOS without being   !<<
N    >>!   obliged to provide the source code for proprietary components     !<<
N    >>!   outside of the FreeRTOS kernel.                                   !<<
N    ***************************************************************************
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
N    link: http://www.freertos.org/a00114.html
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS provides completely free yet professionally developed,    *
N     *    robust, strictly quality controlled, supported, and cross          *
N     *    platform software that is more than just the market leader, it     *
N     *    is the industry's de facto standard.                               *
N     *                                                                       *
N     *    Help yourself get started quickly while simultaneously helping     *
N     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
N     *    tutorial book, reference manual, or both:                          *
N     *    http://www.FreeRTOS.org/Documentation                              *
N     *                                                                       *
N    ***************************************************************************
N
N    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
N    the FAQ page "My application does not run, what could be wrong?".  Have you
N    defined configASSERT()?
N
N    http://www.FreeRTOS.org/support - In return for receiving this top quality
N    embedded software for free we request you assist our global community by
N    participating in the support forum.
N
N    http://www.FreeRTOS.org/training - Investing in training allows your team to
N    be as productive as possible as early as possible.  Now you can receive
N    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
N    Ltd, and the world's leading authority on the world's leading RTOS.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
N    compatible FAT file system, and our tiny thread aware UDP/IP stack.
N
N    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
N    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
N    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
N    licenses offer ticketed support, indemnification and commercial middleware.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N
N    1 tab == 4 spaces!
N*/
N
N#ifndef STACK_MACROS_H
N#define STACK_MACROS_H
N
N/*
N * Call the stack overflow hook function if the stack of the task being swapped
N * out is currently overflowed, or looks like it might have overflowed in the
N * past.
N *
N * Setting configCHECK_FOR_STACK_OVERFLOW to 1 will cause the macro to check
N * the current stack state only - comparing the current top of stack value to
N * the stack limit.  Setting configCHECK_FOR_STACK_OVERFLOW to greater than 1
N * will also cause the last few stack bytes to be checked to ensure the value
N * to which the bytes were set when the task was created have not been
N * overwritten.  Note this second test does not guarantee that an overflowed
N * stack will always be recognised.
N */
N
N/*-----------------------------------------------------------*/
N
N#if( configCHECK_FOR_STACK_OVERFLOW == 0 )
X#if( 0 == 0 )
N
N	/* FreeRTOSConfig.h is not set to check for stack overflows. */
N	#define taskFIRST_CHECK_FOR_STACK_OVERFLOW()
N	#define taskSECOND_CHECK_FOR_STACK_OVERFLOW()
N
N#endif /* configCHECK_FOR_STACK_OVERFLOW == 0 */
N/*-----------------------------------------------------------*/
N
N#if( configCHECK_FOR_STACK_OVERFLOW == 1 )
X#if( 0 == 1 )
S
S	/* FreeRTOSConfig.h is only set to use the first method of
S	overflow checking. */
S	#define taskSECOND_CHECK_FOR_STACK_OVERFLOW()
S
N#endif
N/*-----------------------------------------------------------*/
N
N#if( ( configCHECK_FOR_STACK_OVERFLOW > 0 ) && ( portSTACK_GROWTH < 0 ) )
X#if( ( 0 > 0 ) && ( ( -1 ) < 0 ) )
S
S	/* Only the current stack state is to be checked. */
S	#define taskFIRST_CHECK_FOR_STACK_OVERFLOW()														\
S	{																									\
S		/* Is the currently saved stack pointer within the stack limit? */								\
S		if( pxCurrentTCB->pxTopOfStack <= pxCurrentTCB->pxStack )										\
S		{																								\
S			vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB->pcTaskName );	\
S		}																								\
S	}
X	#define taskFIRST_CHECK_FOR_STACK_OVERFLOW()															{																											 										if( pxCurrentTCB->pxTopOfStack <= pxCurrentTCB->pxStack )												{																											vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB->pcTaskName );			}																									}
S
N#endif /* configCHECK_FOR_STACK_OVERFLOW > 0 */
N/*-----------------------------------------------------------*/
N
N#if( ( configCHECK_FOR_STACK_OVERFLOW > 0 ) && ( portSTACK_GROWTH > 0 ) )
X#if( ( 0 > 0 ) && ( ( -1 ) > 0 ) )
S
S	/* Only the current stack state is to be checked. */
S	#define taskFIRST_CHECK_FOR_STACK_OVERFLOW()														\
S	{																									\
S																										\
S		/* Is the currently saved stack pointer within the stack limit? */								\
S		if( pxCurrentTCB->pxTopOfStack >= pxCurrentTCB->pxEndOfStack )									\
S		{																								\
S			vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB->pcTaskName );	\
S		}																								\
S	}
X	#define taskFIRST_CHECK_FOR_STACK_OVERFLOW()															{																																																					 										if( pxCurrentTCB->pxTopOfStack >= pxCurrentTCB->pxEndOfStack )											{																											vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB->pcTaskName );			}																									}
S
N#endif /* configCHECK_FOR_STACK_OVERFLOW == 1 */
N/*-----------------------------------------------------------*/
N
N#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) && ( portSTACK_GROWTH < 0 ) )
X#if( ( 0 > 1 ) && ( ( -1 ) < 0 ) )
S
S	#define taskSECOND_CHECK_FOR_STACK_OVERFLOW()																						\
S	{																																	\
S	static const uint8_t ucExpectedStackBytes[] = {	tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,		\
S													tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,		\
S													tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,		\
S													tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,		\
S													tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE };	\
S																																		\
S																																		\
S		/* Has the extremity of the task stack ever been written over? */																\
S		if( memcmp( ( void * ) pxCurrentTCB->pxStack, ( void * ) ucExpectedStackBytes, sizeof( ucExpectedStackBytes ) ) != 0 )			\
S		{																																\
S			vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB->pcTaskName );									\
S		}																																\
S	}
X	#define taskSECOND_CHECK_FOR_STACK_OVERFLOW()																							{																																		static const uint8_t ucExpectedStackBytes[] = {	tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,															tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,															tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,															tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,															tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE };																																																																							 																		if( memcmp( ( void * ) pxCurrentTCB->pxStack, ( void * ) ucExpectedStackBytes, sizeof( ucExpectedStackBytes ) ) != 0 )					{																																			vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB->pcTaskName );											}																																	}
S
N#endif /* #if( configCHECK_FOR_STACK_OVERFLOW > 1 ) */
N/*-----------------------------------------------------------*/
N
N#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) && ( portSTACK_GROWTH > 0 ) )
X#if( ( 0 > 1 ) && ( ( -1 ) > 0 ) )
S
S	#define taskSECOND_CHECK_FOR_STACK_OVERFLOW()																						\
S	{																																	\
S	int8_t *pcEndOfStack = ( int8_t * ) pxCurrentTCB->pxEndOfStack;																		\
S	static const uint8_t ucExpectedStackBytes[] = {	tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,		\
S													tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,		\
S													tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,		\
S													tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,		\
S													tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE };	\
S																																		\
S																																		\
S		pcEndOfStack -= sizeof( ucExpectedStackBytes );																					\
S																																		\
S		/* Has the extremity of the task stack ever been written over? */																\
S		if( memcmp( ( void * ) pcEndOfStack, ( void * ) ucExpectedStackBytes, sizeof( ucExpectedStackBytes ) ) != 0 )					\
S		{																																\
S			vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB->pcTaskName );									\
S		}																																\
S	}
X	#define taskSECOND_CHECK_FOR_STACK_OVERFLOW()																							{																																		int8_t *pcEndOfStack = ( int8_t * ) pxCurrentTCB->pxEndOfStack;																			static const uint8_t ucExpectedStackBytes[] = {	tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,															tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,															tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,															tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE,															tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE };																																																																							pcEndOfStack -= sizeof( ucExpectedStackBytes );																																																									 																		if( memcmp( ( void * ) pcEndOfStack, ( void * ) ucExpectedStackBytes, sizeof( ucExpectedStackBytes ) ) != 0 )							{																																			vApplicationStackOverflowHook( ( TaskHandle_t ) pxCurrentTCB, pxCurrentTCB->pcTaskName );											}																																	}
S
N#endif /* #if( configCHECK_FOR_STACK_OVERFLOW > 1 ) */
N/*-----------------------------------------------------------*/
N
N#endif /* STACK_MACROS_H */
N
L 84 "..\..\FreeRTOS\Source\tasks.c" 2
N
N/* Lint e961 and e750 are suppressed as a MISRA exception justified because the
NMPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
Nheader files above, but not in this file, in order to generate the correct
Nprivileged Vs unprivileged linkage and placement. */
N#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
N
N/* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
Nfunctions but without including stdio.h here. */
N#if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
X#if ( 0 == 1 )
S	/* At the bottom of this file are two optional functions that can be used
S	to generate human readable text from the raw data generated by the
S	uxTaskGetSystemState() function.  Note the formatting functions are provided
S	for convenience only, and are NOT considered part of the kernel. */
S	#include <stdio.h>
N#endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
N
N/* Sanity check the configuration. */
N#if( configUSE_TICKLESS_IDLE != 0 )
X#if( 0 != 0 )
S	#if( INCLUDE_vTaskSuspend != 1 )
S		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
S	#endif /* INCLUDE_vTaskSuspend */
N#endif /* configUSE_TICKLESS_IDLE */
N
N/*
N * Defines the size, in words, of the stack allocated to the idle task.
N */
N#define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
N
N#if( configUSE_PREEMPTION == 0 )
X#if( 1 == 0 )
S	/* If the cooperative scheduler is being used then a yield should not be
S	performed just because a higher priority task has been woken. */
S	#define taskYIELD_IF_USING_PREEMPTION()
N#else
N	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
N#endif
N
N/* Value that can be assigned to the eNotifyState member of the TCB. */
Ntypedef enum
N{
N	eNotWaitingNotification = 0,
N	eWaitingNotification,
N	eNotified
N} eNotifyValue;
N
N/*
N * Task control block.  A task control block (TCB) is allocated for each task,
N * and stores task state information, including a pointer to the task's context
N * (the task's run time environment, including register values)
N */
Ntypedef struct tskTaskControlBlock
N{
N	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
N
N	#if ( portUSING_MPU_WRAPPERS == 1 )
X	#if ( 0 == 1 )
S		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
S		BaseType_t		xUsingStaticallyAllocatedStack; /* Set to pdTRUE if the stack is a statically allocated array, and pdFALSE if the stack is dynamically allocated. */
N	#endif
N
N	ListItem_t			xGenericListItem;	/*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
N	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
N	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
N	StackType_t			*pxStack;			/*< Points to the start of the stack. */
N	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.  Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
X	char				pcTaskName[ ( 16 ) ];   
N
N	#if ( portSTACK_GROWTH > 0 )
X	#if ( ( -1 ) > 0 )
S		StackType_t		*pxEndOfStack;		/*< Points to the end of the stack on architectures where the stack grows up from low memory. */
N	#endif
N
N	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
X	#if ( 0 == 1 )
S		UBaseType_t 	uxCriticalNesting; 	/*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
N	#endif
N
N	#if ( configUSE_TRACE_FACILITY == 1 )
X	#if ( 0 == 1 )
S		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
S		UBaseType_t  	uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. */
N	#endif
N
N	#if ( configUSE_MUTEXES == 1 )
X	#if ( 1 == 1 )
N		UBaseType_t 	uxBasePriority;		/*< The priority last assigned to the task - used by the priority inheritance mechanism. */
N		UBaseType_t 	uxMutexesHeld;
N	#endif
N
N	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
X	#if ( 0 == 1 )
S		TaskHookFunction_t pxTaskTag;
N	#endif
N
N	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
X	#if( 0 > 0 )
S		void *pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
N	#endif
N
N	#if ( configGENERATE_RUN_TIME_STATS == 1 )
X	#if ( 0 == 1 )
S		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state. */
N	#endif
N
N	#if ( configUSE_NEWLIB_REENTRANT == 1 )
X	#if ( 0 == 1 )
S		/* Allocate a Newlib reent structure that is specific to this task.
S		Note Newlib support has been included by popular demand, but is not
S		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
S		responsible for resulting newlib operation.  User must be familiar with
S		newlib and must provide system-wide implementations of the necessary
S		stubs. Be warned that (at the time of writing) the current newlib design
S		implements a system-wide malloc() that must be provided with locks. */
S		struct 	_reent xNewLib_reent;
N	#endif
N
N	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
X	#if ( 1 == 1 )
N		volatile uint32_t ulNotifiedValue;
N		volatile eNotifyValue eNotifyState;
N	#endif
N
N} tskTCB;
N
N/* The old tskTCB name is maintained above then typedefed to the new TCB_t name
Nbelow to enable the use of older kernel aware debuggers. */
Ntypedef tskTCB TCB_t;
N
N/*
N * Some kernel aware debuggers require the data the debugger needs access to to
N * be global, rather than file scope.
N */
N#ifdef portREMOVE_STATIC_QUALIFIER
S	#define static
N#endif
N
N/*lint -e956 A manual analysis and inspection has been used to determine which
Nstatic variables must be declared volatile. */
N
NPRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
X TCB_t * volatile pxCurrentTCB = 0;
N
N/* Lists for ready and blocked tasks. --------------------*/
NPRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks. */
X static List_t pxReadyTasksLists[ ( 5 ) ]; 
NPRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
X static List_t xDelayedTaskList1;						 
NPRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
X static List_t xDelayedTaskList2;						 
NPRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list currently being used. */
X static List_t * volatile pxDelayedTaskList;				 
NPRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
X static List_t * volatile pxOverflowDelayedTaskList;		 
NPRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
X static List_t xPendingReadyList;						 
N
N#if ( INCLUDE_vTaskDelete == 1 )
X#if ( 1 == 1 )
N
N	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but their memory not yet freed. */
X	 static List_t xTasksWaitingTermination;				 
N	PRIVILEGED_DATA static volatile UBaseType_t uxTasksDeleted = ( UBaseType_t ) 0U;
X	 static volatile UBaseType_t uxTasksDeleted = ( UBaseType_t ) 0U;
N
N#endif
N
N#if ( INCLUDE_vTaskSuspend == 1 )
X#if ( 1 == 1 )
N
N	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
X	 static List_t xSuspendedTaskList;					 
N
N#endif
N
N#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
X#if ( 0 == 1 )
S
S	PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL;			/*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */
S
N#endif
N
N/* Other file private variables. --------------------------------*/
NPRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
X static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
NPRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) 0U;
X static volatile TickType_t xTickCount 				= ( TickType_t ) 0U;
NPRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
X static volatile UBaseType_t uxTopReadyPriority 		= ( ( UBaseType_t ) 0U );
NPRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
X static volatile BaseType_t xSchedulerRunning 		= ( ( BaseType_t ) 0 );
NPRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
X static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
NPRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
X static volatile BaseType_t xYieldPending 			= ( ( BaseType_t ) 0 );
NPRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
X static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
NPRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
X static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
NPRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialised to portMAX_DELAY; before the scheduler starts. */
X static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U;  
N
N/* Context switches are held pending while the scheduler is suspended.  Also,
Ninterrupts must not manipulate the xGenericListItem of a TCB, or any of the
Nlists the xGenericListItem can be referenced from, if the scheduler is suspended.
NIf an interrupt needs to unblock a task while the scheduler is suspended then it
Nmoves the task's event list item into the xPendingReadyList, ready for the
Nkernel to move the task from the pending ready list into the real ready list
Nwhen the scheduler is unsuspended.  The pending ready list itself can only be
Naccessed from a critical section. */
NPRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
X static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) ( ( BaseType_t ) 0 );
N
N#if ( configGENERATE_RUN_TIME_STATS == 1 )
X#if ( 0 == 1 )
S
S	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter the last time a task was switched in. */
S	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution time as defined by the run time counter clock. */
S
N#endif
N
N/*lint +e956 */
N
N/* Debugging and trace facilities private variables and macros. ------------*/
N
N/*
N * The value used to fill the stack of a task when the task is created.  This
N * is used purely for checking the high water mark for tasks.
N */
N#define tskSTACK_FILL_BYTE	( 0xa5U )
N
N/*
N * Macros used by vListTask to indicate which state a task is in.
N */
N#define tskBLOCKED_CHAR		( 'B' )
N#define tskREADY_CHAR		( 'R' )
N#define tskDELETED_CHAR		( 'D' )
N#define tskSUSPENDED_CHAR	( 'S' )
N
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
X#if ( 1 == 0 )
S
S	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
S	performed in a generic way that is not optimised to any particular
S	microcontroller architecture. */
S
S	/* uxTopReadyPriority holds the priority of the highest priority ready
S	state task. */
S	#define taskRECORD_READY_PRIORITY( uxPriority )														\
S	{																									\
S		if( ( uxPriority ) > uxTopReadyPriority )														\
S		{																								\
S			uxTopReadyPriority = ( uxPriority );														\
S		}																								\
S	} /* taskRECORD_READY_PRIORITY */
X	#define taskRECORD_READY_PRIORITY( uxPriority )															{																											if( ( uxPriority ) > uxTopReadyPriority )																{																											uxTopReadyPriority = ( uxPriority );																}																									}  
S
S	/*-----------------------------------------------------------*/
S
S	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
S	{																									\
S		/* Find the highest priority queue that contains ready tasks. */								\
S		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )						\
S		{																								\
S			configASSERT( uxTopReadyPriority );															\
S			--uxTopReadyPriority;																		\
S		}																								\
S																										\
S		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
S		the	same priority get an equal share of the processor time. */									\
S		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );		\
S	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
X	#define taskSELECT_HIGHEST_PRIORITY_TASK()																{																											 										while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )								{																											configASSERT( uxTopReadyPriority );																		--uxTopReadyPriority;																				}																																																				 											listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );			}  
S
S	/*-----------------------------------------------------------*/
S
S	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
S	they are only required when a port optimised method of task selection is
S	being used. */
S	#define taskRESET_READY_PRIORITY( uxPriority )
S	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
S
N#else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
N
N	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
N	performed in a way that is tailored to the particular microcontroller
N	architecture being used. */
N
N	/* A port optimised version is provided.  Call the port defined macros. */
N	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )
N
N	/*-----------------------------------------------------------*/
N
N	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
N	{																								\
N	UBaseType_t uxTopPriority;																		\
N																									\
N		/* Find the highest priority queue that contains ready tasks. */							\
N		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
N		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
N		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
N	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
X	#define taskSELECT_HIGHEST_PRIORITY_TASK()															{																									UBaseType_t uxTopPriority;																																													 									portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );										configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );				listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );			}  
N
N	/*-----------------------------------------------------------*/
N
N	/* A port optimised version is provided, call it only if the TCB being reset
N	is being referenced from a ready list.  If it is referenced from a delayed
N	or suspended list then it won't be in a ready list. */
N	#define taskRESET_READY_PRIORITY( uxPriority )														\
N	{																									\
N		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
N		{																								\
N			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
N		}																								\
N	}
X	#define taskRESET_READY_PRIORITY( uxPriority )															{																											if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )			{																											portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );									}																									}
N
N#endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
N
N/*-----------------------------------------------------------*/
N
N/* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
Ncount overflows. */
N#define taskSWITCH_DELAYED_LISTS()																	\
N{																									\
N	List_t *pxTemp;																					\
N																									\
N	/* The delayed tasks list should be empty when the lists are switched. */						\
N	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
N																									\
N	pxTemp = pxDelayedTaskList;																		\
N	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
N	pxOverflowDelayedTaskList = pxTemp;																\
N	xNumOfOverflows++;																				\
N	prvResetNextTaskUnblockTime();																	\
N}
X#define taskSWITCH_DELAYED_LISTS()																	{																										List_t *pxTemp;																																															 							configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );																																				pxTemp = pxDelayedTaskList;																			pxDelayedTaskList = pxOverflowDelayedTaskList;														pxOverflowDelayedTaskList = pxTemp;																	xNumOfOverflows++;																					prvResetNextTaskUnblockTime();																	}
N
N/*-----------------------------------------------------------*/
N
N/*
N * Place the task represented by pxTCB into the appropriate ready list for
N * the task.  It is inserted at the end of the list.
N */
N#define prvAddTaskToReadyList( pxTCB )																\
N	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
N	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
N	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) )
X#define prvAddTaskToReadyList( pxTCB )																	traceMOVED_TASK_TO_READY_STATE( pxTCB );															taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );													vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) )
N/*-----------------------------------------------------------*/
N
N/*
N * Several functions take an TaskHandle_t parameter that can optionally be NULL,
N * where NULL is used to indicate that the handle of the currently executing
N * task should be used in place of the parameter.  This macro simply checks to
N * see if the parameter is NULL and returns a pointer to the appropriate TCB.
N */
N#define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( TCB_t * ) ( pxHandle ) )
N
N/* The item value of the event list item is normally used to hold the priority
Nof the task to which it belongs (coded to allow it to be held in reverse
Npriority order).  However, it is occasionally borrowed for other purposes.  It
Nis important its value is not updated due to a task priority change while it is
Nbeing used for another purpose.  The following bit definition is used to inform
Nthe scheduler that the value should not be changed - in which case it is the
Nresponsibility of whichever module is using the value to ensure it gets set back
Nto its original value when it is released. */
N#if configUSE_16_BIT_TICKS == 1
X#if 0 == 1
S	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
N#else
N	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
N#endif
N
N/* Callback function prototypes. --------------------------*/
N#if configCHECK_FOR_STACK_OVERFLOW > 0
X#if 0 > 0
S	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
N#endif
N
N#if configUSE_TICK_HOOK > 0
X#if 0 > 0
S	extern void vApplicationTickHook( void );
N#endif
N
N/* File private functions. --------------------------------*/
N
N/*
N * Utility to ready a TCB for a given task.  Mainly just copies the parameters
N * into the TCB structure.
N */
Nstatic void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xstatic void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) ;  
N
N/**
N * Utility task that simply returns pdTRUE if the task referenced by xTask is
N * currently in the Suspended state, or pdFALSE if the task referenced by xTask
N * is in any other state.
N */
N#if ( INCLUDE_vTaskSuspend == 1 )
X#if ( 1 == 1 )
N	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
X	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) ;
N#endif /* INCLUDE_vTaskSuspend */
N
N/*
N * Utility to ready all the lists used by the scheduler.  This is called
N * automatically upon the creation of the first task.
N */
Nstatic void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
Xstatic void prvInitialiseTaskLists( void ) ;
N
N/*
N * The idle task, which as all tasks is implemented as a never ending loop.
N * The idle task is automatically created and added to the ready lists upon
N * creation of the first user task.
N *
N * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
N * language extensions.  The equivalent prototype for this function is:
N *
N * void prvIdleTask( void *pvParameters );
N *
N */
Nstatic portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
Xstatic void prvIdleTask( void *pvParameters );
N
N/*
N * Utility to free all memory allocated by the scheduler to hold a TCB,
N * including the stack pointed to by the TCB.
N *
N * This does not free memory allocated by the task itself (i.e. memory
N * allocated by calls to pvPortMalloc from within the tasks application code).
N */
N#if ( INCLUDE_vTaskDelete == 1 )
X#if ( 1 == 1 )
N
N	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
X	static void prvDeleteTCB( TCB_t *pxTCB ) ;
N
N#endif
N
N/*
N * Used only by the idle task.  This checks to see if anything has been placed
N * in the list of tasks waiting to be deleted.  If so the task is cleaned up
N * and its TCB deleted.
N */
Nstatic void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
Xstatic void prvCheckTasksWaitingTermination( void ) ;
N
N/*
N * The currently executing task is entering the Blocked state.  Add the task to
N * either the current or the overflow delayed task list.
N */
Nstatic void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake ) PRIVILEGED_FUNCTION;
Xstatic void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake ) ;
N
N/*
N * Allocates memory from the heap for a TCB and associated stack.  Checks the
N * allocation was successful.
N */
Nstatic TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer ) PRIVILEGED_FUNCTION;
Xstatic TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer ) ;
N
N/*
N * Fills an TaskStatus_t structure with information on each task that is
N * referenced from the pxList list (which may be a ready list, a delayed list,
N * a suspended list, etc.).
N *
N * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
N * NORMAL APPLICATION CODE.
N */
N#if ( configUSE_TRACE_FACILITY == 1 )
X#if ( 0 == 1 )
S
S	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState ) PRIVILEGED_FUNCTION;
S
N#endif
N
N/*
N * When a task is created, the stack of the task is filled with a known value.
N * This function determines the 'high water mark' of the task stack by
N * determining how much of the stack remains at the original preset value.
N */
N#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
X#if ( ( 0 == 1 ) || ( 0 == 1 ) )
S
S	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
S
N#endif
N
N/*
N * Return the amount of time, in ticks, that will pass before the kernel will
N * next move a task from the Blocked state to the Running state.
N *
N * This conditional compilation should use inequality to 0, not equality to 1.
N * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
N * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
N * set to a value other than 1.
N */
N#if ( configUSE_TICKLESS_IDLE != 0 )
X#if ( 0 != 0 )
S
S	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
S
N#endif
N
N/*
N * Set xNextTaskUnblockTime to the time at which the next Blocked state task
N * will exit the Blocked state.
N */
Nstatic void prvResetNextTaskUnblockTime( void );
N
N#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
X#if ( ( 0 == 1 ) && ( 0 > 0 ) )
S
S	/*
S	 * Helper function used to pad task names with spaces when printing out
S	 * human readable tables of task information.
S	 */
S	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName );
S
N#endif
N/*-----------------------------------------------------------*/
N
NBaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N{
NBaseType_t xReturn;
NTCB_t * pxNewTCB;
NStackType_t *pxTopOfStack;
N
N	configASSERT( pxTaskCode );
X	;
N	configASSERT( ( ( uxPriority & ( UBaseType_t ) ( ~portPRIVILEGE_BIT ) ) < ( UBaseType_t ) configMAX_PRIORITIES ) );
X	;
N
N	/* Allocate the memory required by the TCB and stack for the new task,
N	checking that the allocation was successful. */
N	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
N
N	if( pxNewTCB != NULL )
X	if( pxNewTCB != 0 )
N	{
N		#if( portUSING_MPU_WRAPPERS == 1 )
X		#if( 0 == 1 )
S			/* Should the task be created in privileged mode? */
S			BaseType_t xRunPrivileged;
S			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
S			{
S				xRunPrivileged = pdTRUE;
S			}
S			else
S			{
S				xRunPrivileged = pdFALSE;
S			}
S			uxPriority &= ~portPRIVILEGE_BIT;
S
S			if( puxStackBuffer != NULL )
S			{
S				/* The application provided its own stack.  Note this so no
S				attempt is made to delete the stack should that task be
S				deleted. */
S				pxNewTCB->xUsingStaticallyAllocatedStack = pdTRUE;
S			}
S			else
S			{
S				/* The stack was allocated dynamically.  Note this so it can be
S				deleted again if the task is deleted. */
S				pxNewTCB->xUsingStaticallyAllocatedStack = pdFALSE;
S			}
N		#endif /* portUSING_MPU_WRAPPERS == 1 */
N
N		/* Calculate the top of stack address.  This depends on whether the
N		stack grows from high memory to low (as per the 80x86) or vice versa.
N		portSTACK_GROWTH is used to make the result positive or negative as
N		required by the port. */
N		#if( portSTACK_GROWTH < 0 )
X		#if( ( -1 ) < 0 )
N		{
N			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
N			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
X			pxTopOfStack = ( StackType_t * ) ( ( ( uint32_t ) pxTopOfStack ) & ( ~( ( uint32_t ) ( 0x0007 ) ) ) );  
N
N			/* Check the alignment of the calculated top of stack is correct. */
N			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
X			;
N		}
N		#else /* portSTACK_GROWTH */
S		{
S			pxTopOfStack = pxNewTCB->pxStack;
S
S			/* Check the alignment of the stack buffer is correct. */
S			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
S
S			/* If we want to use stack checking on architectures that use
S			a positive stack growth direction then we also need to store the
S			other extreme of the stack space. */
S			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
S		}
N		#endif /* portSTACK_GROWTH */
N
N		/* Setup the newly allocated TCB with the initial state of the task. */
N		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
N
N		/* Initialize the TCB stack to look as if the task was already running,
N		but had been interrupted by the scheduler.  The return address is set
N		to the start of the task function. Once the stack has been initialised
N		the	top of stack variable is updated. */
N		#if( portUSING_MPU_WRAPPERS == 1 )
X		#if( 0 == 1 )
S		{
S			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
S		}
N		#else /* portUSING_MPU_WRAPPERS */
N		{
N			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
N		}
N		#endif /* portUSING_MPU_WRAPPERS */
N
N		if( ( void * ) pxCreatedTask != NULL )
X		if( ( void * ) pxCreatedTask != 0 )
N		{
N			/* Pass the TCB out - in an anonymous way.  The calling function/
N			task can use this as a handle to delete the task later if
N			required.*/
N			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
N		}
N		else
N		{
N			mtCOVERAGE_TEST_MARKER();
X			;
N		}
N
N		/* Ensure interrupts don't access the task lists while they are being
N		updated. */
N		taskENTER_CRITICAL();
X		vPortEnterCritical();
N		{
N			uxCurrentNumberOfTasks++;
N			if( pxCurrentTCB == NULL )
X			if( pxCurrentTCB == 0 )
N			{
N				/* There are no other tasks, or all the other tasks are in
N				the suspended state - make this the current task. */
N				pxCurrentTCB =  pxNewTCB;
N
N				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
N				{
N					/* This is the first task to be created so do the preliminary
N					initialisation required.  We will not recover if this call
N					fails, but we will report the failure. */
N					prvInitialiseTaskLists();
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N			}
N			else
N			{
N				/* If the scheduler is not already running, make this task the
N				current task if it is the highest priority task to be created
N				so far. */
N				if( xSchedulerRunning == pdFALSE )
X				if( xSchedulerRunning == ( ( BaseType_t ) 0 ) )
N				{
N					if( pxCurrentTCB->uxPriority <= uxPriority )
N					{
N						pxCurrentTCB = pxNewTCB;
N					}
N					else
N					{
N						mtCOVERAGE_TEST_MARKER();
X						;
N					}
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N			}
N
N			uxTaskNumber++;
N
N			#if ( configUSE_TRACE_FACILITY == 1 )
X			#if ( 0 == 1 )
S			{
S				/* Add a counter into the TCB for tracing only. */
S				pxNewTCB->uxTCBNumber = uxTaskNumber;
S			}
N			#endif /* configUSE_TRACE_FACILITY */
N			traceTASK_CREATE( pxNewTCB );
X			;
N
N			prvAddTaskToReadyList( pxNewTCB );
X			; ( uxTopReadyPriority ) |= ( 1UL << ( ( pxNewTCB )->uxPriority ) ); vListInsertEnd( &( pxReadyTasksLists[ ( pxNewTCB )->uxPriority ] ), &( ( pxNewTCB )->xGenericListItem ) );
N
N			xReturn = pdPASS;
X			xReturn = ( ( ( BaseType_t ) 1 ) );
N			portSETUP_TCB( pxNewTCB );
X			( void ) pxNewTCB;
N		}
N		taskEXIT_CRITICAL();
X		vPortExitCritical();
N	}
N	else
N	{
N		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
X		xReturn = ( -1 );
N		traceTASK_CREATE_FAILED();
X		;
N	}
N
N	if( xReturn == pdPASS )
X	if( xReturn == ( ( ( BaseType_t ) 1 ) ) )
N	{
N		if( xSchedulerRunning != pdFALSE )
X		if( xSchedulerRunning != ( ( BaseType_t ) 0 ) )
N		{
N			/* If the created task is of a higher priority than the current task
N			then it should run now. */
N			if( pxCurrentTCB->uxPriority < uxPriority )
N			{
N				taskYIELD_IF_USING_PREEMPTION();
X				{ ( * ( ( volatile uint32_t * ) 0xe000ed04 ) ) = ( 1UL << 28UL ); __dsb( ( 15 ) ); __isb( ( 15 ) ); };
N			}
N			else
N			{
N				mtCOVERAGE_TEST_MARKER();
X				;
N			}
N		}
N		else
N		{
N			mtCOVERAGE_TEST_MARKER();
X			;
N		}
N	}
N
N	return xReturn;
N}
N/*-----------------------------------------------------------*/
N
N#if ( INCLUDE_vTaskDelete == 1 )
X#if ( 1 == 1 )
N
N	void vTaskDelete( TaskHandle_t xTaskToDelete )
N	{
N	TCB_t *pxTCB;
N
N		taskENTER_CRITICAL();
X		vPortEnterCritical();
N		{
N			/* If null is passed in here then it is the calling task that is
N			being deleted. */
N			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
X			pxTCB = ( ( ( xTaskToDelete ) == 0 ) ? ( TCB_t * ) pxCurrentTCB : ( TCB_t * ) ( xTaskToDelete ) );
N
N			/* Remove task from the ready list and place in the	termination list.
N			This will stop the task from be scheduled.  The idle task will check
N			the termination list and free up any memory allocated by the
N			scheduler for the TCB and stack. */
N			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
N			{
N				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
X				{ if( ( ( &( pxReadyTasksLists[ ( pxTCB->uxPriority ) ] ) )->uxNumberOfItems ) == ( UBaseType_t ) 0 ) { ( ( uxTopReadyPriority ) ) &= ~( 1UL << ( ( pxTCB->uxPriority ) ) ); } };
N			}
N			else
N			{
N				mtCOVERAGE_TEST_MARKER();
X				;
N			}
N
N			/* Is the task waiting on an event also? */
N			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
X			if( ( ( &( pxTCB->xEventListItem ) )->pvContainer ) != 0 )
N			{
N				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
N			}
N			else
N			{
N				mtCOVERAGE_TEST_MARKER();
X				;
N			}
N
N			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
N
N			/* Increment the ucTasksDeleted variable so the idle task knows
N			there is a task that has been deleted and that it should therefore
N			check the xTasksWaitingTermination list. */
N			++uxTasksDeleted;
N
N			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
N			can detect that the task lists need re-generating. */
N			uxTaskNumber++;
N
N			traceTASK_DELETE( pxTCB );
X			;
N		}
N		taskEXIT_CRITICAL();
X		vPortExitCritical();
N
N		/* Force a reschedule if it is the currently running task that has just
N		been deleted. */
N		if( xSchedulerRunning != pdFALSE )
X		if( xSchedulerRunning != ( ( BaseType_t ) 0 ) )
N		{
N			if( pxTCB == pxCurrentTCB )
N			{
N				configASSERT( uxSchedulerSuspended == 0 );
X				;
N
N				/* The pre-delete hook is primarily for the Windows simulator,
N				in which Windows specific clean up operations are performed,
N				after which it is not possible to yield away from this task -
N				hence xYieldPending is used to latch that a context switch is
N				required. */
N				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
X				;
N				portYIELD_WITHIN_API();
X				{ ( * ( ( volatile uint32_t * ) 0xe000ed04 ) ) = ( 1UL << 28UL ); __dsb( ( 15 ) ); __isb( ( 15 ) ); };
N			}
N			else
N			{
N				/* Reset the next expected unblock time in case it referred to
N				the task that has just been deleted. */
N				taskENTER_CRITICAL();
X				vPortEnterCritical();
N				{
N					prvResetNextTaskUnblockTime();
N				}
N				taskEXIT_CRITICAL();
X				vPortExitCritical();
N			}
N		}
N	}
N
N#endif /* INCLUDE_vTaskDelete */
N/*-----------------------------------------------------------*/
N
N#if ( INCLUDE_vTaskDelayUntil == 1 )
X#if ( 1 == 1 )
N
N	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
N	{
N	TickType_t xTimeToWake;
N	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
X	BaseType_t xAlreadyYielded, xShouldDelay = ( ( BaseType_t ) 0 );
N
N		configASSERT( pxPreviousWakeTime );
X		;
N		configASSERT( ( xTimeIncrement > 0U ) );
X		;
N		configASSERT( uxSchedulerSuspended == 0 );
X		;
N
N		vTaskSuspendAll();
N		{
N			/* Minor optimisation.  The tick count cannot change in this
N			block. */
N			const TickType_t xConstTickCount = xTickCount;
N
N			/* Generate the tick time at which the task wants to wake. */
N			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
N
N			if( xConstTickCount < *pxPreviousWakeTime )
N			{
N				/* The tick count has overflowed since this function was
N				lasted called.  In this case the only time we should ever
N				actually delay is if the wake time has also	overflowed,
N				and the wake time is greater than the tick time.  When this
N				is the case it is as if neither time had overflowed. */
N				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
N				{
N					xShouldDelay = pdTRUE;
X					xShouldDelay = ( ( BaseType_t ) 1 );
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N			}
N			else
N			{
N				/* The tick time has not overflowed.  In this case we will
N				delay if either the wake time has overflowed, and/or the
N				tick time is less than the wake time. */
N				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
N				{
N					xShouldDelay = pdTRUE;
X					xShouldDelay = ( ( BaseType_t ) 1 );
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N			}
N
N			/* Update the wake time ready for the next call. */
N			*pxPreviousWakeTime = xTimeToWake;
N
N			if( xShouldDelay != pdFALSE )
X			if( xShouldDelay != ( ( BaseType_t ) 0 ) )
N			{
N				traceTASK_DELAY_UNTIL();
X				;
N
N				/* Remove the task from the ready list before adding it to the
N				blocked list as the same list item is used for both lists. */
N				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
N				{
N					/* The current task must be in a ready list, so there is
N					no need to check, and the port reset macro can be called
N					directly. */
N					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
X					( uxTopReadyPriority ) &= ~( 1UL << ( pxCurrentTCB->uxPriority ) );
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N
N				prvAddCurrentTaskToDelayedList( xTimeToWake );
N			}
N			else
N			{
N				mtCOVERAGE_TEST_MARKER();
X				;
N			}
N		}
N		xAlreadyYielded = xTaskResumeAll();
N
N		/* Force a reschedule if xTaskResumeAll has not already done so, we may
N		have put ourselves to sleep. */
N		if( xAlreadyYielded == pdFALSE )
X		if( xAlreadyYielded == ( ( BaseType_t ) 0 ) )
N		{
N			portYIELD_WITHIN_API();
X			{ ( * ( ( volatile uint32_t * ) 0xe000ed04 ) ) = ( 1UL << 28UL ); __dsb( ( 15 ) ); __isb( ( 15 ) ); };
N		}
N		else
N		{
N			mtCOVERAGE_TEST_MARKER();
X			;
N		}
N	}
N
N#endif /* INCLUDE_vTaskDelayUntil */
N/*-----------------------------------------------------------*/
N
N#if ( INCLUDE_vTaskDelay == 1 )
X#if ( 1 == 1 )
N
N	void vTaskDelay( const TickType_t xTicksToDelay )
N	{
N	TickType_t xTimeToWake;
N	BaseType_t xAlreadyYielded = pdFALSE;
X	BaseType_t xAlreadyYielded = ( ( BaseType_t ) 0 );
N
N
N		/* A delay time of zero just forces a reschedule. */
N		if( xTicksToDelay > ( TickType_t ) 0U )
N		{
N			configASSERT( uxSchedulerSuspended == 0 );
X			;
N			vTaskSuspendAll();
N			{
N				traceTASK_DELAY();
X				;
N
N				/* A task that is removed from the event list while the
N				scheduler is suspended will not get placed in the ready
N				list or removed from the blocked list until the scheduler
N				is resumed.
N
N				This task cannot be in an event list as it is the currently
N				executing task. */
N
N				/* Calculate the time to wake - this may overflow but this is
N				not a problem. */
N				xTimeToWake = xTickCount + xTicksToDelay;
N
N				/* We must remove ourselves from the ready list before adding
N				ourselves to the blocked list as the same list item is used for
N				both lists. */
N				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
N				{
N					/* The current task must be in a ready list, so there is
N					no need to check, and the port reset macro can be called
N					directly. */
N					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
X					( uxTopReadyPriority ) &= ~( 1UL << ( pxCurrentTCB->uxPriority ) );
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N				prvAddCurrentTaskToDelayedList( xTimeToWake );
N			}
N			xAlreadyYielded = xTaskResumeAll();
N		}
N		else
N		{
N			mtCOVERAGE_TEST_MARKER();
X			;
N		}
N
N		/* Force a reschedule if xTaskResumeAll has not already done so, we may
N		have put ourselves to sleep. */
N		if( xAlreadyYielded == pdFALSE )
X		if( xAlreadyYielded == ( ( BaseType_t ) 0 ) )
N		{
N			portYIELD_WITHIN_API();
X			{ ( * ( ( volatile uint32_t * ) 0xe000ed04 ) ) = ( 1UL << 28UL ); __dsb( ( 15 ) ); __isb( ( 15 ) ); };
N		}
N		else
N		{
N			mtCOVERAGE_TEST_MARKER();
X			;
N		}
N	}
N
N#endif /* INCLUDE_vTaskDelay */
N/*-----------------------------------------------------------*/
N
N#if ( INCLUDE_eTaskGetState == 1 )
X#if ( 0 == 1 )
S
S	eTaskState eTaskGetState( TaskHandle_t xTask )
S	{
S	eTaskState eReturn;
S	List_t *pxStateList;
S	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
S
S		configASSERT( pxTCB );
S
S		if( pxTCB == pxCurrentTCB )
S		{
S			/* The task calling this function is querying its own state. */
S			eReturn = eRunning;
S		}
S		else
S		{
S			taskENTER_CRITICAL();
S			{
S				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
S			}
S			taskEXIT_CRITICAL();
S
S			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
S			{
S				/* The task being queried is referenced from one of the Blocked
S				lists. */
S				eReturn = eBlocked;
S			}
S
S			#if ( INCLUDE_vTaskSuspend == 1 )
S				else if( pxStateList == &xSuspendedTaskList )
S				{
S					/* The task being queried is referenced from the suspended
S					list.  Is it genuinely suspended or is it block
S					indefinitely? */
S					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
S					{
S						eReturn = eSuspended;
S					}
S					else
S					{
S						eReturn = eBlocked;
S					}
S				}
S			#endif
S
S			#if ( INCLUDE_vTaskDelete == 1 )
S				else if( pxStateList == &xTasksWaitingTermination )
S				{
S					/* The task being queried is referenced from the deleted
S					tasks list. */
S					eReturn = eDeleted;
S				}
S			#endif
S
S			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
S			{
S				/* If the task is not in any other state, it must be in the
S				Ready (including pending ready) state. */
S				eReturn = eReady;
S			}
S		}
S
S		return eReturn;
S	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
S
N#endif /* INCLUDE_eTaskGetState */
N/*-----------------------------------------------------------*/
N
N#if ( INCLUDE_uxTaskPriorityGet == 1 )
X#if ( 1 == 1 )
N
N	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
N	{
N	TCB_t *pxTCB;
N	UBaseType_t uxReturn;
N
N		taskENTER_CRITICAL();
X		vPortEnterCritical();
N		{
N			/* If null is passed in here then it is the priority of the that
N			called uxTaskPriorityGet() that is being queried. */
N			pxTCB = prvGetTCBFromHandle( xTask );
X			pxTCB = ( ( ( xTask ) == 0 ) ? ( TCB_t * ) pxCurrentTCB : ( TCB_t * ) ( xTask ) );
N			uxReturn = pxTCB->uxPriority;
N		}
N		taskEXIT_CRITICAL();
X		vPortExitCritical();
N
N		return uxReturn;
N	}
N
N#endif /* INCLUDE_uxTaskPriorityGet */
N/*-----------------------------------------------------------*/
N
N#if ( INCLUDE_uxTaskPriorityGet == 1 )
X#if ( 1 == 1 )
N
N	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
N	{
N	TCB_t *pxTCB;
N	UBaseType_t uxReturn, uxSavedInterruptState;
N
N		/* RTOS ports that support interrupt nesting have the concept of a
N		maximum	system call (or maximum API call) interrupt priority.
N		Interrupts that are	above the maximum system call priority are keep
N		permanently enabled, even when the RTOS kernel is in a critical section,
N		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
N		is defined in FreeRTOSConfig.h then
N		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
N		failure if a FreeRTOS API function is called from an interrupt that has
N		been assigned a priority above the configured maximum system call
N		priority.  Only FreeRTOS functions that end in FromISR can be called
N		from interrupts	that have been assigned a priority at or (logically)
N		below the maximum system call interrupt priority.  FreeRTOS maintains a
N		separate interrupt safe API to ensure interrupt entry is as fast and as
N		simple as possible.  More information (albeit Cortex-M specific) is
N		provided on the following link:
N		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
N		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
X		;
N
N		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
X		uxSavedInterruptState = ulPortRaiseBASEPRI();
N		{
N			/* If null is passed in here then it is the priority of the calling
N			task that is being queried. */
N			pxTCB = prvGetTCBFromHandle( xTask );
X			pxTCB = ( ( ( xTask ) == 0 ) ? ( TCB_t * ) pxCurrentTCB : ( TCB_t * ) ( xTask ) );
N			uxReturn = pxTCB->uxPriority;
N		}
N		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
X		vPortSetBASEPRI(uxSavedInterruptState);
N
N		return uxReturn;
N	}
N
N#endif /* INCLUDE_uxTaskPriorityGet */
N/*-----------------------------------------------------------*/
N
N#if ( INCLUDE_vTaskPrioritySet == 1 )
X#if ( 1 == 1 )
N
N	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
N	{
N	TCB_t *pxTCB;
N	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
N	BaseType_t xYieldRequired = pdFALSE;
X	BaseType_t xYieldRequired = ( ( BaseType_t ) 0 );
N
N		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
X		;
N
N		/* Ensure the new priority is valid. */
N		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
X		if( uxNewPriority >= ( UBaseType_t ) ( 5 ) )
N		{
N			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
X			uxNewPriority = ( UBaseType_t ) ( 5 ) - ( UBaseType_t ) 1U;
N		}
N		else
N		{
N			mtCOVERAGE_TEST_MARKER();
X			;
N		}
N
N		taskENTER_CRITICAL();
X		vPortEnterCritical();
N		{
N			/* If null is passed in here then it is the priority of the calling
N			task that is being changed. */
N			pxTCB = prvGetTCBFromHandle( xTask );
X			pxTCB = ( ( ( xTask ) == 0 ) ? ( TCB_t * ) pxCurrentTCB : ( TCB_t * ) ( xTask ) );
N
N			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
X			;
N
N			#if ( configUSE_MUTEXES == 1 )
X			#if ( 1 == 1 )
N			{
N				uxCurrentBasePriority = pxTCB->uxBasePriority;
N			}
N			#else
S			{
S				uxCurrentBasePriority = pxTCB->uxPriority;
S			}
N			#endif
N
N			if( uxCurrentBasePriority != uxNewPriority )
N			{
N				/* The priority change may have readied a task of higher
N				priority than the calling task. */
N				if( uxNewPriority > uxCurrentBasePriority )
N				{
N					if( pxTCB != pxCurrentTCB )
N					{
N						/* The priority of a task other than the currently
N						running task is being raised.  Is the priority being
N						raised above that of the running task? */
N						if( uxNewPriority >= pxCurrentTCB->uxPriority )
N						{
N							xYieldRequired = pdTRUE;
X							xYieldRequired = ( ( BaseType_t ) 1 );
N						}
N						else
N						{
N							mtCOVERAGE_TEST_MARKER();
X							;
N						}
N					}
N					else
N					{
N						/* The priority of the running task is being raised,
N						but the running task must already be the highest
N						priority task able to run so no yield is required. */
N					}
N				}
N				else if( pxTCB == pxCurrentTCB )
N				{
N					/* Setting the priority of the running task down means
N					there may now be another task of higher priority that
N					is ready to execute. */
N					xYieldRequired = pdTRUE;
X					xYieldRequired = ( ( BaseType_t ) 1 );
N				}
N				else
N				{
N					/* Setting the priority of any other task down does not
N					require a yield as the running task must be above the
N					new priority of the task being modified. */
N				}
N
N				/* Remember the ready list the task might be referenced from
N				before its uxPriority member is changed so the
N				taskRESET_READY_PRIORITY() macro can function correctly. */
N				uxPriorityUsedOnEntry = pxTCB->uxPriority;
N
N				#if ( configUSE_MUTEXES == 1 )
X				#if ( 1 == 1 )
N				{
N					/* Only change the priority being used if the task is not
N					currently using an inherited priority. */
N					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
N					{
N						pxTCB->uxPriority = uxNewPriority;
N					}
N					else
N					{
N						mtCOVERAGE_TEST_MARKER();
X						;
N					}
N
N					/* The base priority gets set whatever. */
N					pxTCB->uxBasePriority = uxNewPriority;
N				}
N				#else
S				{
S					pxTCB->uxPriority = uxNewPriority;
S				}
N				#endif
N
N				/* Only reset the event list item value if the value is not
N				being used for anything else. */
N				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
X				if( ( ( ( &( pxTCB->xEventListItem ) )->xItemValue ) & 0x80000000UL ) == 0UL )
N				{
N					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
X					( ( &( pxTCB->xEventListItem ) )->xItemValue = ( ( ( TickType_t ) ( 5 ) - ( TickType_t ) uxNewPriority ) ) );  
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N
N				/* If the task is in the blocked or suspended list we need do
N				nothing more than change it's priority variable. However, if
N				the task is in a ready list it needs to be removed and placed
N				in the list appropriate to its new priority. */
N				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
X				if( ( ( BaseType_t ) ( ( &( pxTCB->xGenericListItem ) )->pvContainer == ( void * ) ( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ) ) ) ) != ( ( BaseType_t ) 0 ) )
N				{
N					/* The task is currently in its ready list - remove before adding
N					it to it's new ready list.  As we are in a critical section we
N					can do this even if the scheduler is suspended. */
N					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
N					{
N						/* It is known that the task is in its ready list so
N						there is no need to check again and the port level
N						reset macro can be called directly. */
N						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
X						( uxTopReadyPriority ) &= ~( 1UL << ( uxPriorityUsedOnEntry ) );
N					}
N					else
N					{
N						mtCOVERAGE_TEST_MARKER();
X						;
N					}
N					prvAddTaskToReadyList( pxTCB );
X					; ( uxTopReadyPriority ) |= ( 1UL << ( ( pxTCB )->uxPriority ) ); vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) );
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N
N				if( xYieldRequired == pdTRUE )
X				if( xYieldRequired == ( ( BaseType_t ) 1 ) )
N				{
N					taskYIELD_IF_USING_PREEMPTION();
X					{ ( * ( ( volatile uint32_t * ) 0xe000ed04 ) ) = ( 1UL << 28UL ); __dsb( ( 15 ) ); __isb( ( 15 ) ); };
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N
N				/* Remove compiler warning about unused variables when the port
N				optimised task selection is not being used. */
N				( void ) uxPriorityUsedOnEntry;
N			}
N		}
N		taskEXIT_CRITICAL();
X		vPortExitCritical();
N	}
N
N#endif /* INCLUDE_vTaskPrioritySet */
N/*-----------------------------------------------------------*/
N
N#if ( INCLUDE_vTaskSuspend == 1 )
X#if ( 1 == 1 )
N
N	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
N	{
N	TCB_t *pxTCB;
N
N		taskENTER_CRITICAL();
X		vPortEnterCritical();
N		{
N			/* If null is passed in here then it is the running task that is
N			being suspended. */
N			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
X			pxTCB = ( ( ( xTaskToSuspend ) == 0 ) ? ( TCB_t * ) pxCurrentTCB : ( TCB_t * ) ( xTaskToSuspend ) );
N
N			traceTASK_SUSPEND( pxTCB );
X			;
N
N			/* Remove task from the ready/delayed list and place in the
N			suspended list. */
N			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
N			{
N				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
X				{ if( ( ( &( pxReadyTasksLists[ ( pxTCB->uxPriority ) ] ) )->uxNumberOfItems ) == ( UBaseType_t ) 0 ) { ( ( uxTopReadyPriority ) ) &= ~( 1UL << ( ( pxTCB->uxPriority ) ) ); } };
N			}
N			else
N			{
N				mtCOVERAGE_TEST_MARKER();
X				;
N			}
N
N			/* Is the task waiting on an event also? */
N			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
X			if( ( ( &( pxTCB->xEventListItem ) )->pvContainer ) != 0 )
N			{
N				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
N			}
N			else
N			{
N				mtCOVERAGE_TEST_MARKER();
X				;
N			}
N
N			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
N		}
N		taskEXIT_CRITICAL();
X		vPortExitCritical();
N
N		if( pxTCB == pxCurrentTCB )
N		{
N			if( xSchedulerRunning != pdFALSE )
X			if( xSchedulerRunning != ( ( BaseType_t ) 0 ) )
N			{
N				/* The current task has just been suspended. */
N				configASSERT( uxSchedulerSuspended == 0 );
X				;
N				portYIELD_WITHIN_API();
X				{ ( * ( ( volatile uint32_t * ) 0xe000ed04 ) ) = ( 1UL << 28UL ); __dsb( ( 15 ) ); __isb( ( 15 ) ); };
N			}
N			else
N			{
N				/* The scheduler is not running, but the task that was pointed
N				to by pxCurrentTCB has just been suspended and pxCurrentTCB
N				must be adjusted to point to a different task. */
N				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
X				if( ( ( &xSuspendedTaskList )->uxNumberOfItems ) == uxCurrentNumberOfTasks )
N				{
N					/* No other tasks are ready, so set pxCurrentTCB back to
N					NULL so when the next task is created pxCurrentTCB will
N					be set to point to it no matter what its relative priority
N					is. */
N					pxCurrentTCB = NULL;
X					pxCurrentTCB = 0;
N				}
N				else
N				{
N					vTaskSwitchContext();
N				}
N			}
N		}
N		else
N		{
N			if( xSchedulerRunning != pdFALSE )
X			if( xSchedulerRunning != ( ( BaseType_t ) 0 ) )
N			{
N				/* A task other than the currently running task was suspended,
N				reset the next expected unblock time in case it referred to the
N				task that is now in the Suspended state. */
N				taskENTER_CRITICAL();
X				vPortEnterCritical();
N				{
N					prvResetNextTaskUnblockTime();
N				}
N				taskEXIT_CRITICAL();
X				vPortExitCritical();
N			}
N			else
N			{
N				mtCOVERAGE_TEST_MARKER();
X				;
N			}
N		}
N	}
N
N#endif /* INCLUDE_vTaskSuspend */
N/*-----------------------------------------------------------*/
N
N#if ( INCLUDE_vTaskSuspend == 1 )
X#if ( 1 == 1 )
N
N	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
N	{
N	BaseType_t xReturn = pdFALSE;
X	BaseType_t xReturn = ( ( BaseType_t ) 0 );
N	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
N
N		/* Accesses xPendingReadyList so must be called from a critical
N		section. */
N
N		/* It does not make sense to check if the calling task is suspended. */
N		configASSERT( xTask );
X		;
N
N		/* Is the task being resumed actually in the suspended list? */
N		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
X		if( ( ( BaseType_t ) ( ( &( pxTCB->xGenericListItem ) )->pvContainer == ( void * ) ( &xSuspendedTaskList ) ) ) != ( ( BaseType_t ) 0 ) )
N		{
N			/* Has the task already been resumed from within an ISR? */
N			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
X			if( ( ( BaseType_t ) ( ( &( pxTCB->xEventListItem ) )->pvContainer == ( void * ) ( &xPendingReadyList ) ) ) == ( ( BaseType_t ) 0 ) )
N			{
N				/* Is it in the suspended list because it is in the	Suspended
N				state, or because is is blocked with no timeout? */
N				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
X				if( ( ( BaseType_t ) ( ( &( pxTCB->xEventListItem ) )->pvContainer == ( void * ) ( 0 ) ) ) != ( ( BaseType_t ) 0 ) )
N				{
N					xReturn = pdTRUE;
X					xReturn = ( ( BaseType_t ) 1 );
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N			}
N			else
N			{
N				mtCOVERAGE_TEST_MARKER();
X				;
N			}
N		}
N		else
N		{
N			mtCOVERAGE_TEST_MARKER();
X			;
N		}
N
N		return xReturn;
N	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
N
N#endif /* INCLUDE_vTaskSuspend */
N/*-----------------------------------------------------------*/
N
N#if ( INCLUDE_vTaskSuspend == 1 )
X#if ( 1 == 1 )
N
N	void vTaskResume( TaskHandle_t xTaskToResume )
N	{
N	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
N
N		/* It does not make sense to resume the calling task. */
N		configASSERT( xTaskToResume );
X		;
N
N		/* The parameter cannot be NULL as it is impossible to resume the
N		currently executing task. */
N		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
X		if( ( pxTCB != 0 ) && ( pxTCB != pxCurrentTCB ) )
N		{
N			taskENTER_CRITICAL();
X			vPortEnterCritical();
N			{
N				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
X				if( prvTaskIsTaskSuspended( pxTCB ) == ( ( BaseType_t ) 1 ) )
N				{
N					traceTASK_RESUME( pxTCB );
X					;
N
N					/* As we are in a critical section we can access the ready
N					lists even if the scheduler is suspended. */
N					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
N					prvAddTaskToReadyList( pxTCB );
X					; ( uxTopReadyPriority ) |= ( 1UL << ( ( pxTCB )->uxPriority ) ); vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) );
N
N					/* We may have just resumed a higher priority task. */
N					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
N					{
N						/* This yield may not cause the task just resumed to run,
N						but will leave the lists in the correct state for the
N						next yield. */
N						taskYIELD_IF_USING_PREEMPTION();
X						{ ( * ( ( volatile uint32_t * ) 0xe000ed04 ) ) = ( 1UL << 28UL ); __dsb( ( 15 ) ); __isb( ( 15 ) ); };
N					}
N					else
N					{
N						mtCOVERAGE_TEST_MARKER();
X						;
N					}
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N			}
N			taskEXIT_CRITICAL();
X			vPortExitCritical();
N		}
N		else
N		{
N			mtCOVERAGE_TEST_MARKER();
X			;
N		}
N	}
N
N#endif /* INCLUDE_vTaskSuspend */
N
N/*-----------------------------------------------------------*/
N
N#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
X#if ( ( 1 == 1 ) && ( 1 == 1 ) )
N
N	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
N	{
N	BaseType_t xYieldRequired = pdFALSE;
X	BaseType_t xYieldRequired = ( ( BaseType_t ) 0 );
N	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
N	UBaseType_t uxSavedInterruptStatus;
N
N		configASSERT( xTaskToResume );
X		;
N
N		/* RTOS ports that support interrupt nesting have the concept of a
N		maximum	system call (or maximum API call) interrupt priority.
N		Interrupts that are	above the maximum system call priority are keep
N		permanently enabled, even when the RTOS kernel is in a critical section,
N		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
N		is defined in FreeRTOSConfig.h then
N		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
N		failure if a FreeRTOS API function is called from an interrupt that has
N		been assigned a priority above the configured maximum system call
N		priority.  Only FreeRTOS functions that end in FromISR can be called
N		from interrupts	that have been assigned a priority at or (logically)
N		below the maximum system call interrupt priority.  FreeRTOS maintains a
N		separate interrupt safe API to ensure interrupt entry is as fast and as
N		simple as possible.  More information (albeit Cortex-M specific) is
N		provided on the following link:
N		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
N		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
X		;
N
N		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
X		uxSavedInterruptStatus = ulPortRaiseBASEPRI();
N		{
N			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
X			if( prvTaskIsTaskSuspended( pxTCB ) == ( ( BaseType_t ) 1 ) )
N			{
N				traceTASK_RESUME_FROM_ISR( pxTCB );
X				;
N
N				/* Check the ready lists can be accessed. */
N				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
X				if( uxSchedulerSuspended == ( UBaseType_t ) ( ( BaseType_t ) 0 ) )
N				{
N					/* Ready lists can be accessed so move the task from the
N					suspended list to the ready list directly. */
N					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
N					{
N						xYieldRequired = pdTRUE;
X						xYieldRequired = ( ( BaseType_t ) 1 );
N					}
N					else
N					{
N						mtCOVERAGE_TEST_MARKER();
X						;
N					}
N
N					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
N					prvAddTaskToReadyList( pxTCB );
X					; ( uxTopReadyPriority ) |= ( 1UL << ( ( pxTCB )->uxPriority ) ); vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) );
N				}
N				else
N				{
N					/* The delayed or ready lists cannot be accessed so the task
N					is held in the pending ready list until the scheduler is
N					unsuspended. */
N					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
N				}
N			}
N			else
N			{
N				mtCOVERAGE_TEST_MARKER();
X				;
N			}
N		}
N		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
X		vPortSetBASEPRI(uxSavedInterruptStatus);
N
N		return xYieldRequired;
N	}
N
N#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
N/*-----------------------------------------------------------*/
N
Nvoid vTaskStartScheduler( void )
N{
NBaseType_t xReturn;
N
N	/* Add the idle task at the lowest priority. */
N	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
X	#if ( 0 == 1 )
S	{
S		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
S		be returned by the xTaskGetIdleTaskHandle() function. */
S		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
S	}
N	#else
N	{
N		/* Create the idle task without storing its handle. */
N		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
X		xReturn = xTaskGenericCreate( ( prvIdleTask ), ( "IDLE" ), ( ( ( unsigned short ) 128 ) ), ( ( void * ) 0 ), ( ( ( ( UBaseType_t ) 0U ) | ( ( UBaseType_t ) 0x00 ) ) ), ( 0 ), ( 0 ), ( 0 ) );   
N	}
N	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
N
N	#if ( configUSE_TIMERS == 1 )
X	#if ( 0 == 1 )
S	{
S		if( xReturn == pdPASS )
S		{
S			xReturn = xTimerCreateTimerTask();
S		}
S		else
S		{
S			mtCOVERAGE_TEST_MARKER();
S		}
S	}
N	#endif /* configUSE_TIMERS */
N
N	if( xReturn == pdPASS )
X	if( xReturn == ( ( ( BaseType_t ) 1 ) ) )
N	{
N		/* Interrupts are turned off here, to ensure a tick does not occur
N		before or during the call to xPortStartScheduler().  The stacks of
N		the created tasks contain a status word with interrupts switched on
N		so interrupts will automatically get re-enabled when the first task
N		starts to run. */
N		portDISABLE_INTERRUPTS();
X		vPortRaiseBASEPRI();
N
N		#if ( configUSE_NEWLIB_REENTRANT == 1 )
X		#if ( 0 == 1 )
S		{
S			/* Switch Newlib's _impure_ptr variable to point to the _reent
S			structure specific to the task that will run first. */
S			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
S		}
N		#endif /* configUSE_NEWLIB_REENTRANT */
N
N		xNextTaskUnblockTime = portMAX_DELAY;
X		xNextTaskUnblockTime = ( TickType_t ) 0xffffffffUL;
N		xSchedulerRunning = pdTRUE;
X		xSchedulerRunning = ( ( BaseType_t ) 1 );
N		xTickCount = ( TickType_t ) 0U;
N
N		/* If configGENERATE_RUN_TIME_STATS is defined then the following
N		macro must be defined to configure the timer/counter used to generate
N		the run time counter time base. */
N		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
X		;
N
N		/* Setting up the timer tick is hardware specific and thus in the
N		portable interface. */
N		if( xPortStartScheduler() != pdFALSE )
X		if( xPortStartScheduler() != ( ( BaseType_t ) 0 ) )
N		{
N			/* Should not reach here as if the scheduler is running the
N			function will not return. */
N		}
N		else
N		{
N			/* Should only reach here if a task calls xTaskEndScheduler(). */
N		}
N	}
N	else
N	{
N		/* This line will only be reached if the kernel could not be started,
N		because there was not enough FreeRTOS heap to create the idle task
N		or the timer task. */
N		configASSERT( xReturn );
X		;
N	}
N}
N/*-----------------------------------------------------------*/
N
Nvoid vTaskEndScheduler( void )
N{
N	/* Stop the scheduler interrupts and call the portable scheduler end
N	routine so the original ISRs can be restored if necessary.  The port
N	layer must ensure interrupts enable	bit is left in the correct state. */
N	portDISABLE_INTERRUPTS();
X	vPortRaiseBASEPRI();
N	xSchedulerRunning = pdFALSE;
X	xSchedulerRunning = ( ( BaseType_t ) 0 );
N	vPortEndScheduler();
N}
N/*----------------------------------------------------------*/
N
Nvoid vTaskSuspendAll( void )
N{
N	/* A critical section is not required as the variable is of type
N	BaseType_t.  Please read Richard Barry's reply in the following link to a
N	post in the FreeRTOS support forum before reporting this as a bug! -
N	http://goo.gl/wu4acr */
N	++uxSchedulerSuspended;
N}
N/*----------------------------------------------------------*/
N
N#if ( configUSE_TICKLESS_IDLE != 0 )
X#if ( 0 != 0 )
S
S	static TickType_t prvGetExpectedIdleTime( void )
S	{
S	TickType_t xReturn;
S
S		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
S		{
S			xReturn = 0;
S		}
S		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
S		{
S			/* There are other idle priority tasks in the ready state.  If
S			time slicing is used then the very next tick interrupt must be
S			processed. */
S			xReturn = 0;
S		}
S		else
S		{
S			xReturn = xNextTaskUnblockTime - xTickCount;
S		}
S
S		return xReturn;
S	}
S
N#endif /* configUSE_TICKLESS_IDLE */
N/*----------------------------------------------------------*/
N
NBaseType_t xTaskResumeAll( void )
N{
NTCB_t *pxTCB;
NBaseType_t xAlreadyYielded = pdFALSE;
XBaseType_t xAlreadyYielded = ( ( BaseType_t ) 0 );
N
N	/* If uxSchedulerSuspended is zero then this function does not match a
N	previous call to vTaskSuspendAll(). */
N	configASSERT( uxSchedulerSuspended );
X	;
N
N	/* It is possible that an ISR caused a task to be removed from an event
N	list while the scheduler was suspended.  If this was the case then the
N	removed task will have been added to the xPendingReadyList.  Once the
N	scheduler has been resumed it is safe to move all the pending ready
N	tasks from this list into their appropriate ready list. */
N	taskENTER_CRITICAL();
X	vPortEnterCritical();
N	{
N		--uxSchedulerSuspended;
N
N		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
X		if( uxSchedulerSuspended == ( UBaseType_t ) ( ( BaseType_t ) 0 ) )
N		{
N			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
N			{
N				/* Move any readied tasks from the pending list into the
N				appropriate ready list. */
N				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
X				while( ( ( BaseType_t ) ( ( &xPendingReadyList )->uxNumberOfItems == ( UBaseType_t ) 0 ) ) == ( ( BaseType_t ) 0 ) )
N				{
N					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
X					pxTCB = ( TCB_t * ) ( (&( ( ( &xPendingReadyList ) )->xListEnd ))->pxNext->pvOwner );
N					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
N					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
N					prvAddTaskToReadyList( pxTCB );
X					; ( uxTopReadyPriority ) |= ( 1UL << ( ( pxTCB )->uxPriority ) ); vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) );
N
N					/* If the moved task has a priority higher than the current
N					task then a yield must be performed. */
N					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
N					{
N						xYieldPending = pdTRUE;
X						xYieldPending = ( ( BaseType_t ) 1 );
N					}
N					else
N					{
N						mtCOVERAGE_TEST_MARKER();
X						;
N					}
N				}
N
N				/* If any ticks occurred while the scheduler was suspended then
N				they should be processed now.  This ensures the tick count does
N				not	slip, and that any delayed tasks are resumed at the correct
N				time. */
N				if( uxPendedTicks > ( UBaseType_t ) 0U )
N				{
N					while( uxPendedTicks > ( UBaseType_t ) 0U )
N					{
N						if( xTaskIncrementTick() != pdFALSE )
X						if( xTaskIncrementTick() != ( ( BaseType_t ) 0 ) )
N						{
N							xYieldPending = pdTRUE;
X							xYieldPending = ( ( BaseType_t ) 1 );
N						}
N						else
N						{
N							mtCOVERAGE_TEST_MARKER();
X							;
N						}
N						--uxPendedTicks;
N					}
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N
N				if( xYieldPending == pdTRUE )
X				if( xYieldPending == ( ( BaseType_t ) 1 ) )
N				{
N					#if( configUSE_PREEMPTION != 0 )
X					#if( 1 != 0 )
N					{
N						xAlreadyYielded = pdTRUE;
X						xAlreadyYielded = ( ( BaseType_t ) 1 );
N					}
N					#endif
N					taskYIELD_IF_USING_PREEMPTION();
X					{ ( * ( ( volatile uint32_t * ) 0xe000ed04 ) ) = ( 1UL << 28UL ); __dsb( ( 15 ) ); __isb( ( 15 ) ); };
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N			}
N		}
N		else
N		{
N			mtCOVERAGE_TEST_MARKER();
X			;
N		}
N	}
N	taskEXIT_CRITICAL();
X	vPortExitCritical();
N
N	return xAlreadyYielded;
N}
N/*-----------------------------------------------------------*/
N
NTickType_t xTaskGetTickCount( void )
N{
NTickType_t xTicks;
N
N	/* Critical section required if running on a 16 bit processor. */
N	portTICK_TYPE_ENTER_CRITICAL();
X	;
N	{
N		xTicks = xTickCount;
N	}
N	portTICK_TYPE_EXIT_CRITICAL();
X	;
N
N	return xTicks;
N}
N/*-----------------------------------------------------------*/
N
NTickType_t xTaskGetTickCountFromISR( void )
N{
NTickType_t xReturn;
NUBaseType_t uxSavedInterruptStatus;
N
N	/* RTOS ports that support interrupt nesting have the concept of a maximum
N	system call (or maximum API call) interrupt priority.  Interrupts that are
N	above the maximum system call priority are kept permanently enabled, even
N	when the RTOS kernel is in a critical section, but cannot make any calls to
N	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
N	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
N	failure if a FreeRTOS API function is called from an interrupt that has been
N	assigned a priority above the configured maximum system call priority.
N	Only FreeRTOS functions that end in FromISR can be called from interrupts
N	that have been assigned a priority at or (logically) below the maximum
N	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
N	safe API to ensure interrupt entry is as fast and as simple as possible.
N	More information (albeit Cortex-M specific) is provided on the following
N	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
N	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
X	;
N
N	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
X	uxSavedInterruptStatus = 0;
N	{
N		xReturn = xTickCount;
N	}
N	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
X	( void ) uxSavedInterruptStatus;
N
N	return xReturn;
N}
N/*-----------------------------------------------------------*/
N
NUBaseType_t uxTaskGetNumberOfTasks( void )
N{
N	/* A critical section is not required because the variables are of type
N	BaseType_t. */
N	return uxCurrentNumberOfTasks;
N}
N/*-----------------------------------------------------------*/
N
N#if ( INCLUDE_pcTaskGetTaskName == 1 )
X#if ( 0 == 1 )
S
S	char *pcTaskGetTaskName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
S	{
S	TCB_t *pxTCB;
S
S		/* If null is passed in here then the name of the calling task is being queried. */
S		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
S		configASSERT( pxTCB );
S		return &( pxTCB->pcTaskName[ 0 ] );
S	}
S
N#endif /* INCLUDE_pcTaskGetTaskName */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_TRACE_FACILITY == 1 )
X#if ( 0 == 1 )
S
S	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
S	{
S	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
S
S		vTaskSuspendAll();
S		{
S			/* Is there a space in the array for each task in the system? */
S			if( uxArraySize >= uxCurrentNumberOfTasks )
S			{
S				/* Fill in an TaskStatus_t structure with information on each
S				task in the Ready state. */
S				do
S				{
S					uxQueue--;
S					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
S
S				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
S
S				/* Fill in an TaskStatus_t structure with information on each
S				task in the Blocked state. */
S				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
S				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
S
S				#if( INCLUDE_vTaskDelete == 1 )
S				{
S					/* Fill in an TaskStatus_t structure with information on
S					each task that has been deleted but not yet cleaned up. */
S					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
S				}
S				#endif
S
S				#if ( INCLUDE_vTaskSuspend == 1 )
S				{
S					/* Fill in an TaskStatus_t structure with information on
S					each task in the Suspended state. */
S					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
S				}
S				#endif
S
S				#if ( configGENERATE_RUN_TIME_STATS == 1)
S				{
S					if( pulTotalRunTime != NULL )
S					{
S						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
S							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
S						#else
S							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
S						#endif
S					}
S				}
S				#else
S				{
S					if( pulTotalRunTime != NULL )
S					{
S						*pulTotalRunTime = 0;
S					}
S				}
S				#endif
S			}
S			else
S			{
S				mtCOVERAGE_TEST_MARKER();
S			}
S		}
S		( void ) xTaskResumeAll();
S
S		return uxTask;
S	}
S
N#endif /* configUSE_TRACE_FACILITY */
N/*----------------------------------------------------------*/
N
N#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
X#if ( 0 == 1 )
S
S	TaskHandle_t xTaskGetIdleTaskHandle( void )
S	{
S		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
S		started, then xIdleTaskHandle will be NULL. */
S		configASSERT( ( xIdleTaskHandle != NULL ) );
S		return xIdleTaskHandle;
S	}
S
N#endif /* INCLUDE_xTaskGetIdleTaskHandle */
N/*----------------------------------------------------------*/
N
N/* This conditional compilation should use inequality to 0, not equality to 1.
NThis is to ensure vTaskStepTick() is available when user defined low power mode
Nimplementations require configUSE_TICKLESS_IDLE to be set to a value other than
N1. */
N#if ( configUSE_TICKLESS_IDLE != 0 )
X#if ( 0 != 0 )
S
S	void vTaskStepTick( const TickType_t xTicksToJump )
S	{
S		/* Correct the tick count value after a period during which the tick
S		was suppressed.  Note this does *not* call the tick hook function for
S		each stepped tick. */
S		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
S		xTickCount += xTicksToJump;
S		traceINCREASE_TICK_COUNT( xTicksToJump );
S	}
S
N#endif /* configUSE_TICKLESS_IDLE */
N/*----------------------------------------------------------*/
N
NBaseType_t xTaskIncrementTick( void )
N{
NTCB_t * pxTCB;
NTickType_t xItemValue;
NBaseType_t xSwitchRequired = pdFALSE;
XBaseType_t xSwitchRequired = ( ( BaseType_t ) 0 );
N
N	/* Called by the portable layer each time a tick interrupt occurs.
N	Increments the tick then checks to see if the new tick value will cause any
N	tasks to be unblocked. */
N	traceTASK_INCREMENT_TICK( xTickCount );
X	;
N	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
X	if( uxSchedulerSuspended == ( UBaseType_t ) ( ( BaseType_t ) 0 ) )
N	{
N		/* Increment the RTOS tick, switching the delayed and overflowed
N		delayed lists if it wraps to 0. */
N		++xTickCount;
N
N		{
N			/* Minor optimisation.  The tick count cannot change in this
N			block. */
N			const TickType_t xConstTickCount = xTickCount;
N
N			if( xConstTickCount == ( TickType_t ) 0U )
N			{
N				taskSWITCH_DELAYED_LISTS();
X				{ List_t *pxTemp; ; pxTemp = pxDelayedTaskList; pxDelayedTaskList = pxOverflowDelayedTaskList; pxOverflowDelayedTaskList = pxTemp; xNumOfOverflows++; prvResetNextTaskUnblockTime(); };
N			}
N			else
N			{
N				mtCOVERAGE_TEST_MARKER();
X				;
N			}
N
N			/* See if this tick has made a timeout expire.  Tasks are stored in
N			the	queue in the order of their wake time - meaning once one task
N			has been found whose block time has not expired there is no need to
N			look any further down the list. */
N			if( xConstTickCount >= xNextTaskUnblockTime )
N			{
N				for( ;; )
N				{
N					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
X					if( ( ( BaseType_t ) ( ( pxDelayedTaskList )->uxNumberOfItems == ( UBaseType_t ) 0 ) ) != ( ( BaseType_t ) 0 ) )
N					{
N						/* The delayed list is empty.  Set xNextTaskUnblockTime
N						to the maximum possible value so it is extremely
N						unlikely that the
N						if( xTickCount >= xNextTaskUnblockTime ) test will pass
N						next time through. */
N						xNextTaskUnblockTime = portMAX_DELAY;
X						xNextTaskUnblockTime = ( TickType_t ) 0xffffffffUL;
N						break;
N					}
N					else
N					{
N						/* The delayed list is not empty, get the value of the
N						item at the head of the delayed list.  This is the time
N						at which the task at the head of the delayed list must
N						be removed from the Blocked state. */
N						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
X						pxTCB = ( TCB_t * ) ( (&( ( pxDelayedTaskList )->xListEnd ))->pxNext->pvOwner );
N						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
X						xItemValue = ( ( &( pxTCB->xGenericListItem ) )->xItemValue );
N
N						if( xConstTickCount < xItemValue )
N						{
N							/* It is not time to unblock this item yet, but the
N							item value is the time at which the task at the head
N							of the blocked list must be removed from the Blocked
N							state -	so record the item value in
N							xNextTaskUnblockTime. */
N							xNextTaskUnblockTime = xItemValue;
N							break;
N						}
N						else
N						{
N							mtCOVERAGE_TEST_MARKER();
X							;
N						}
N
N						/* It is time to remove the item from the Blocked state. */
N						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
N
N						/* Is the task waiting on an event also?  If so remove
N						it from the event list. */
N						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
X						if( ( ( &( pxTCB->xEventListItem ) )->pvContainer ) != 0 )
N						{
N							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
N						}
N						else
N						{
N							mtCOVERAGE_TEST_MARKER();
X							;
N						}
N
N						/* Place the unblocked task into the appropriate ready
N						list. */
N						prvAddTaskToReadyList( pxTCB );
X						; ( uxTopReadyPriority ) |= ( 1UL << ( ( pxTCB )->uxPriority ) ); vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) );
N
N						/* A task being unblocked cannot cause an immediate
N						context switch if preemption is turned off. */
N						#if (  configUSE_PREEMPTION == 1 )
X						#if (  1 == 1 )
N						{
N							/* Preemption is on, but a context switch should
N							only be performed if the unblocked task has a
N							priority that is equal to or higher than the
N							currently executing task. */
N							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
N							{
N								xSwitchRequired = pdTRUE;
X								xSwitchRequired = ( ( BaseType_t ) 1 );
N							}
N							else
N							{
N								mtCOVERAGE_TEST_MARKER();
X								;
N							}
N						}
N						#endif /* configUSE_PREEMPTION */
N					}
N				}
N			}
N		}
N
N		/* Tasks of equal priority to the currently running task will share
N		processing time (time slice) if preemption is on, and the application
N		writer has not explicitly turned time slicing off. */
N		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
X		#if ( ( 1 == 1 ) && ( 1 == 1 ) )
N		{
N			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
X			if( ( ( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) )->uxNumberOfItems ) > ( UBaseType_t ) 1 )
N			{
N				xSwitchRequired = pdTRUE;
X				xSwitchRequired = ( ( BaseType_t ) 1 );
N			}
N			else
N			{
N				mtCOVERAGE_TEST_MARKER();
X				;
N			}
N		}
N		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
N
N		#if ( configUSE_TICK_HOOK == 1 )
X		#if ( 0 == 1 )
S		{
S			/* Guard against the tick hook being called when the pended tick
S			count is being unwound (when the scheduler is being unlocked). */
S			if( uxPendedTicks == ( UBaseType_t ) 0U )
S			{
S				vApplicationTickHook();
S			}
S			else
S			{
S				mtCOVERAGE_TEST_MARKER();
S			}
S		}
N		#endif /* configUSE_TICK_HOOK */
N	}
N	else
N	{
N		++uxPendedTicks;
N
N		/* The tick hook gets called at regular intervals, even if the
N		scheduler is locked. */
N		#if ( configUSE_TICK_HOOK == 1 )
X		#if ( 0 == 1 )
S		{
S			vApplicationTickHook();
S		}
N		#endif
N	}
N
N	#if ( configUSE_PREEMPTION == 1 )
X	#if ( 1 == 1 )
N	{
N		if( xYieldPending != pdFALSE )
X		if( xYieldPending != ( ( BaseType_t ) 0 ) )
N		{
N			xSwitchRequired = pdTRUE;
X			xSwitchRequired = ( ( BaseType_t ) 1 );
N		}
N		else
N		{
N			mtCOVERAGE_TEST_MARKER();
X			;
N		}
N	}
N	#endif /* configUSE_PREEMPTION */
N
N	return xSwitchRequired;
N}
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_APPLICATION_TASK_TAG == 1 )
X#if ( 0 == 1 )
S
S	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
S	{
S	TCB_t *xTCB;
S
S		/* If xTask is NULL then it is the task hook of the calling task that is
S		getting set. */
S		if( xTask == NULL )
S		{
S			xTCB = ( TCB_t * ) pxCurrentTCB;
S		}
S		else
S		{
S			xTCB = ( TCB_t * ) xTask;
S		}
S
S		/* Save the hook function in the TCB.  A critical section is required as
S		the value can be accessed from an interrupt. */
S		taskENTER_CRITICAL();
S			xTCB->pxTaskTag = pxHookFunction;
S		taskEXIT_CRITICAL();
S	}
S
N#endif /* configUSE_APPLICATION_TASK_TAG */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_APPLICATION_TASK_TAG == 1 )
X#if ( 0 == 1 )
S
S	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
S	{
S	TCB_t *xTCB;
S	TaskHookFunction_t xReturn;
S
S		/* If xTask is NULL then we are setting our own task hook. */
S		if( xTask == NULL )
S		{
S			xTCB = ( TCB_t * ) pxCurrentTCB;
S		}
S		else
S		{
S			xTCB = ( TCB_t * ) xTask;
S		}
S
S		/* Save the hook function in the TCB.  A critical section is required as
S		the value can be accessed from an interrupt. */
S		taskENTER_CRITICAL();
S		{
S			xReturn = xTCB->pxTaskTag;
S		}
S		taskEXIT_CRITICAL();
S
S		return xReturn;
S	}
S
N#endif /* configUSE_APPLICATION_TASK_TAG */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_APPLICATION_TASK_TAG == 1 )
X#if ( 0 == 1 )
S
S	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
S	{
S	TCB_t *xTCB;
S	BaseType_t xReturn;
S
S		/* If xTask is NULL then we are calling our own task hook. */
S		if( xTask == NULL )
S		{
S			xTCB = ( TCB_t * ) pxCurrentTCB;
S		}
S		else
S		{
S			xTCB = ( TCB_t * ) xTask;
S		}
S
S		if( xTCB->pxTaskTag != NULL )
S		{
S			xReturn = xTCB->pxTaskTag( pvParameter );
S		}
S		else
S		{
S			xReturn = pdFAIL;
S		}
S
S		return xReturn;
S	}
S
N#endif /* configUSE_APPLICATION_TASK_TAG */
N/*-----------------------------------------------------------*/
N
Nvoid vTaskSwitchContext( void )
N{
N	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
X	if( uxSchedulerSuspended != ( UBaseType_t ) ( ( BaseType_t ) 0 ) )
N	{
N		/* The scheduler is currently suspended - do not allow a context
N		switch. */
N		xYieldPending = pdTRUE;
X		xYieldPending = ( ( BaseType_t ) 1 );
N	}
N	else
N	{
N		xYieldPending = pdFALSE;
X		xYieldPending = ( ( BaseType_t ) 0 );
N		traceTASK_SWITCHED_OUT();
X		;
N
N		#if ( configGENERATE_RUN_TIME_STATS == 1 )
X		#if ( 0 == 1 )
S		{
S				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
S					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
S				#else
S					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
S				#endif
S
S				/* Add the amount of time the task has been running to the
S				accumulated	time so far.  The time the task started running was
S				stored in ulTaskSwitchedInTime.  Note that there is no overflow
S				protection here	so count values are only valid until the timer
S				overflows.  The guard against negative values is to protect
S				against suspect run time stat counter implementations - which
S				are provided by the application, not the kernel. */
S				if( ulTotalRunTime > ulTaskSwitchedInTime )
S				{
S					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
S				}
S				else
S				{
S					mtCOVERAGE_TEST_MARKER();
S				}
S				ulTaskSwitchedInTime = ulTotalRunTime;
S		}
N		#endif /* configGENERATE_RUN_TIME_STATS */
N
N		/* Check for stack overflow, if configured. */
N		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
X		;
N		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
X		;
N
N		/* Select a new task to run using either the generic C or port
N		optimised asm code. */
N		taskSELECT_HIGHEST_PRIORITY_TASK();
X		{ UBaseType_t uxTopPriority; uxTopPriority = ( 31 - __clz( ( uxTopReadyPriority ) ) ); ; { List_t * const pxConstList = ( &( pxReadyTasksLists[ uxTopPriority ] ) ); ( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext; if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) ) { ( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext; } ( pxCurrentTCB ) = ( pxConstList )->pxIndex->pvOwner; }; };
N		traceTASK_SWITCHED_IN();
X		;
N
N		#if ( configUSE_NEWLIB_REENTRANT == 1 )
X		#if ( 0 == 1 )
S		{
S			/* Switch Newlib's _impure_ptr variable to point to the _reent
S			structure specific to this task. */
S			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
S		}
N		#endif /* configUSE_NEWLIB_REENTRANT */
N	}
N}
N/*-----------------------------------------------------------*/
N
Nvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
N{
NTickType_t xTimeToWake;
N
N	configASSERT( pxEventList );
X	;
N
N	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
N	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
N
N	/* Place the event list item of the TCB in the appropriate event list.
N	This is placed in the list in priority order so the highest priority task
N	is the first to be woken by the event.  The queue that contains the event
N	list is locked, preventing simultaneous access from interrupts. */
N	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
N
N	/* The task must be removed from from the ready list before it is added to
N	the blocked list as the same list item is used for both lists.  Exclusive
N	access to the ready lists guaranteed because the scheduler is locked. */
N	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
N	{
N		/* The current task must be in a ready list, so there is no need to
N		check, and the port reset macro can be called directly. */
N		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
X		( uxTopReadyPriority ) &= ~( 1UL << ( pxCurrentTCB->uxPriority ) );
N	}
N	else
N	{
N		mtCOVERAGE_TEST_MARKER();
X		;
N	}
N
N	#if ( INCLUDE_vTaskSuspend == 1 )
X	#if ( 1 == 1 )
N	{
N		if( xTicksToWait == portMAX_DELAY )
X		if( xTicksToWait == ( TickType_t ) 0xffffffffUL )
N		{
N			/* Add the task to the suspended task list instead of a delayed task
N			list to ensure the task is not woken by a timing event.  It will
N			block indefinitely. */
N			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
N		}
N		else
N		{
N			/* Calculate the time at which the task should be woken if the event
N			does not occur.  This may overflow but this doesn't matter, the
N			scheduler will handle it. */
N			xTimeToWake = xTickCount + xTicksToWait;
N			prvAddCurrentTaskToDelayedList( xTimeToWake );
N		}
N	}
N	#else /* INCLUDE_vTaskSuspend */
S	{
S			/* Calculate the time at which the task should be woken if the event does
S			not occur.  This may overflow but this doesn't matter, the scheduler
S			will handle it. */
S			xTimeToWake = xTickCount + xTicksToWait;
S			prvAddCurrentTaskToDelayedList( xTimeToWake );
S	}
N	#endif /* INCLUDE_vTaskSuspend */
N}
N/*-----------------------------------------------------------*/
N
Nvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
N{
NTickType_t xTimeToWake;
N
N	configASSERT( pxEventList );
X	;
N
N	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
N	the event groups implementation. */
N	configASSERT( uxSchedulerSuspended != 0 );
X	;
N
N	/* Store the item value in the event list item.  It is safe to access the
N	event list item here as interrupts won't access the event list item of a
N	task that is not in the Blocked state. */
N	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
X	( ( &( pxCurrentTCB->xEventListItem ) )->xItemValue = ( xItemValue | 0x80000000UL ) );
N
N	/* Place the event list item of the TCB at the end of the appropriate event
N	list.  It is safe to access the event list here because it is part of an
N	event group implementation - and interrupts don't access event groups
N	directly (instead they access them indirectly by pending function calls to
N	the task level). */
N	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
N
N	/* The task must be removed from the ready list before it is added to the
N	blocked list.  Exclusive access can be assured to the ready list as the
N	scheduler is locked. */
N	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
N	{
N		/* The current task must be in a ready list, so there is no need to
N		check, and the port reset macro can be called directly. */
N		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
X		( uxTopReadyPriority ) &= ~( 1UL << ( pxCurrentTCB->uxPriority ) );
N	}
N	else
N	{
N		mtCOVERAGE_TEST_MARKER();
X		;
N	}
N
N	#if ( INCLUDE_vTaskSuspend == 1 )
X	#if ( 1 == 1 )
N	{
N		if( xTicksToWait == portMAX_DELAY )
X		if( xTicksToWait == ( TickType_t ) 0xffffffffUL )
N		{
N			/* Add the task to the suspended task list instead of a delayed task
N			list to ensure it is not woken by a timing event.  It will block
N			indefinitely. */
N			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
N		}
N		else
N		{
N			/* Calculate the time at which the task should be woken if the event
N			does not occur.  This may overflow but this doesn't matter, the
N			kernel will manage it correctly. */
N			xTimeToWake = xTickCount + xTicksToWait;
N			prvAddCurrentTaskToDelayedList( xTimeToWake );
N		}
N	}
N	#else /* INCLUDE_vTaskSuspend */
S	{
S			/* Calculate the time at which the task should be woken if the event does
S			not occur.  This may overflow but this doesn't matter, the kernel
S			will manage it correctly. */
S			xTimeToWake = xTickCount + xTicksToWait;
S			prvAddCurrentTaskToDelayedList( xTimeToWake );
S	}
N	#endif /* INCLUDE_vTaskSuspend */
N}
N/*-----------------------------------------------------------*/
N
N#if configUSE_TIMERS == 1
X#if 0 == 1
S
S	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
S	{
S	TickType_t xTimeToWake;
S
S		configASSERT( pxEventList );
S
S		/* This function should not be called by application code hence the
S		'Restricted' in its name.  It is not part of the public API.  It is
S		designed for use by kernel code, and has special calling requirements -
S		it should be called with the scheduler suspended. */
S
S
S		/* Place the event list item of the TCB in the appropriate event list.
S		In this case it is assume that this is the only task that is going to
S		be waiting on this event list, so the faster vListInsertEnd() function
S		can be used in place of vListInsert. */
S		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
S
S		/* We must remove this task from the ready list before adding it to the
S		blocked list as the same list item is used for both lists.  This
S		function is called with the scheduler locked so interrupts will not
S		access the lists at the same time. */
S		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
S		{
S			/* The current task must be in a ready list, so there is no need to
S			check, and the port reset macro can be called directly. */
S			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
S		}
S		else
S		{
S			mtCOVERAGE_TEST_MARKER();
S		}
S
S		/* If vTaskSuspend() is available then the suspended task list is also
S		available and a task that is blocking indefinitely can enter the
S		suspended state (it is not really suspended as it will re-enter the
S		Ready state when the event it is waiting indefinitely for occurs).
S		Blocking indefinitely is useful when using tickless idle mode as when
S		all tasks are blocked indefinitely all timers can be turned off. */
S		#if( INCLUDE_vTaskSuspend == 1 )
S		{
S			if( xWaitIndefinitely == pdTRUE )
S			{
S				/* Add the task to the suspended task list instead of a delayed
S				task list to ensure the task is not woken by a timing event.  It
S				will block indefinitely. */
S				traceTASK_DELAY_SUSPEND( pxCurrentTCB );
S				vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
S			}
S			else
S			{
S				/* Calculate the time at which the task should be woken if the
S				event does not occur.  This may overflow but this doesn't
S				matter. */
S				xTimeToWake = xTickCount + xTicksToWait;
S				traceTASK_DELAY_UNTIL();
S				prvAddCurrentTaskToDelayedList( xTimeToWake );
S			}
S		}
S		#else
S		{
S			/* Calculate the time at which the task should be woken if the event
S			does not occur.  This may overflow but this doesn't matter. */
S			xTimeToWake = xTickCount + xTicksToWait;
S			traceTASK_DELAY_UNTIL();
S			prvAddCurrentTaskToDelayedList( xTimeToWake );
S
S			/* Remove compiler warnings when INCLUDE_vTaskSuspend() is not
S			defined. */
S			( void ) xWaitIndefinitely;
S		}
S		#endif
S	}
S
N#endif /* configUSE_TIMERS */
N/*-----------------------------------------------------------*/
N
NBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
N{
NTCB_t *pxUnblockedTCB;
NBaseType_t xReturn;
N
N	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
N	called from a critical section within an ISR. */
N
N	/* The event list is sorted in priority order, so the first in the list can
N	be removed as it is known to be the highest priority.  Remove the TCB from
N	the delayed list, and add it to the ready list.
N
N	If an event is for a queue that is locked then this function will never
N	get called - the lock count on the queue will get modified instead.  This
N	means exclusive access to the event list is guaranteed here.
N
N	This function assumes that a check has already been made to ensure that
N	pxEventList is not empty. */
N	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
X	pxUnblockedTCB = ( TCB_t * ) ( (&( ( pxEventList )->xListEnd ))->pxNext->pvOwner );
N	configASSERT( pxUnblockedTCB );
X	;
N	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
N
N	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
X	if( uxSchedulerSuspended == ( UBaseType_t ) ( ( BaseType_t ) 0 ) )
N	{
N		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
N		prvAddTaskToReadyList( pxUnblockedTCB );
X		; ( uxTopReadyPriority ) |= ( 1UL << ( ( pxUnblockedTCB )->uxPriority ) ); vListInsertEnd( &( pxReadyTasksLists[ ( pxUnblockedTCB )->uxPriority ] ), &( ( pxUnblockedTCB )->xGenericListItem ) );
N	}
N	else
N	{
N		/* The delayed and ready lists cannot be accessed, so hold this task
N		pending until the scheduler is resumed. */
N		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
N	}
N
N	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
N	{
N		/* Return true if the task removed from the event list has a higher
N		priority than the calling task.  This allows the calling task to know if
N		it should force a context switch now. */
N		xReturn = pdTRUE;
X		xReturn = ( ( BaseType_t ) 1 );
N
N		/* Mark that a yield is pending in case the user is not using the
N		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
N		xYieldPending = pdTRUE;
X		xYieldPending = ( ( BaseType_t ) 1 );
N	}
N	else
N	{
N		xReturn = pdFALSE;
X		xReturn = ( ( BaseType_t ) 0 );
N	}
N
N	#if( configUSE_TICKLESS_IDLE != 0 )
X	#if( 0 != 0 )
S	{
S		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
S		might be set to the blocked task's time out time.  If the task is
S		unblocked for a reason other than a timeout xNextTaskUnblockTime is
S		normally left unchanged, because it is automatically reset to a new
S		value when the tick count equals xNextTaskUnblockTime.  However if
S		tickless idling is used it might be more important to enter sleep mode
S		at the earliest possible time - so reset xNextTaskUnblockTime here to
S		ensure it is updated at the earliest possible time. */
S		prvResetNextTaskUnblockTime();
S	}
N	#endif
N
N	return xReturn;
N}
N/*-----------------------------------------------------------*/
N
NBaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
N{
NTCB_t *pxUnblockedTCB;
NBaseType_t xReturn;
N
N	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
N	the event flags implementation. */
N	configASSERT( uxSchedulerSuspended != pdFALSE );
X	;
N
N	/* Store the new item value in the event list. */
N	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
X	( ( pxEventListItem )->xItemValue = ( xItemValue | 0x80000000UL ) );
N
N	/* Remove the event list form the event flag.  Interrupts do not access
N	event flags. */
N	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
X	pxUnblockedTCB = ( TCB_t * ) ( ( pxEventListItem )->pvOwner );
N	configASSERT( pxUnblockedTCB );
X	;
N	( void ) uxListRemove( pxEventListItem );
N
N	/* Remove the task from the delayed list and add it to the ready list.  The
N	scheduler is suspended so interrupts will not be accessing the ready
N	lists. */
N	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
N	prvAddTaskToReadyList( pxUnblockedTCB );
X	; ( uxTopReadyPriority ) |= ( 1UL << ( ( pxUnblockedTCB )->uxPriority ) ); vListInsertEnd( &( pxReadyTasksLists[ ( pxUnblockedTCB )->uxPriority ] ), &( ( pxUnblockedTCB )->xGenericListItem ) );
N
N	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
N	{
N		/* Return true if the task removed from the event list has
N		a higher priority than the calling task.  This allows
N		the calling task to know if it should force a context
N		switch now. */
N		xReturn = pdTRUE;
X		xReturn = ( ( BaseType_t ) 1 );
N
N		/* Mark that a yield is pending in case the user is not using the
N		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
N		xYieldPending = pdTRUE;
X		xYieldPending = ( ( BaseType_t ) 1 );
N	}
N	else
N	{
N		xReturn = pdFALSE;
X		xReturn = ( ( BaseType_t ) 0 );
N	}
N
N	return xReturn;
N}
N/*-----------------------------------------------------------*/
N
Nvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
N{
N	configASSERT( pxTimeOut );
X	;
N	pxTimeOut->xOverflowCount = xNumOfOverflows;
N	pxTimeOut->xTimeOnEntering = xTickCount;
N}
N/*-----------------------------------------------------------*/
N
NBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
N{
NBaseType_t xReturn;
N
N	configASSERT( pxTimeOut );
X	;
N	configASSERT( pxTicksToWait );
X	;
N
N	taskENTER_CRITICAL();
X	vPortEnterCritical();
N	{
N		/* Minor optimisation.  The tick count cannot change in this block. */
N		const TickType_t xConstTickCount = xTickCount;
N
N		#if ( INCLUDE_vTaskSuspend == 1 )
X		#if ( 1 == 1 )
N			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
N			the maximum block time then the task should block indefinitely, and
N			therefore never time out. */
N			if( *pxTicksToWait == portMAX_DELAY )
X			if( *pxTicksToWait == ( TickType_t ) 0xffffffffUL )
N			{
N				xReturn = pdFALSE;
X				xReturn = ( ( BaseType_t ) 0 );
N			}
N			else /* We are not blocking indefinitely, perform the checks below. */
N		#endif
N
N		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
N		{
N			/* The tick count is greater than the time at which vTaskSetTimeout()
N			was called, but has also overflowed since vTaskSetTimeOut() was called.
N			It must have wrapped all the way around and gone past us again. This
N			passed since vTaskSetTimeout() was called. */
N			xReturn = pdTRUE;
X			xReturn = ( ( BaseType_t ) 1 );
N		}
N		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
N		{
N			/* Not a genuine timeout. Adjust parameters for time remaining. */
N			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
N			vTaskSetTimeOutState( pxTimeOut );
N			xReturn = pdFALSE;
X			xReturn = ( ( BaseType_t ) 0 );
N		}
N		else
N		{
N			xReturn = pdTRUE;
X			xReturn = ( ( BaseType_t ) 1 );
N		}
N	}
N	taskEXIT_CRITICAL();
X	vPortExitCritical();
N
N	return xReturn;
N}
N/*-----------------------------------------------------------*/
N
Nvoid vTaskMissedYield( void )
N{
N	xYieldPending = pdTRUE;
X	xYieldPending = ( ( BaseType_t ) 1 );
N}
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_TRACE_FACILITY == 1 )
X#if ( 0 == 1 )
S
S	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
S	{
S	UBaseType_t uxReturn;
S	TCB_t *pxTCB;
S
S		if( xTask != NULL )
S		{
S			pxTCB = ( TCB_t * ) xTask;
S			uxReturn = pxTCB->uxTaskNumber;
S		}
S		else
S		{
S			uxReturn = 0U;
S		}
S
S		return uxReturn;
S	}
S
N#endif /* configUSE_TRACE_FACILITY */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_TRACE_FACILITY == 1 )
X#if ( 0 == 1 )
S
S	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
S	{
S	TCB_t *pxTCB;
S
S		if( xTask != NULL )
S		{
S			pxTCB = ( TCB_t * ) xTask;
S			pxTCB->uxTaskNumber = uxHandle;
S		}
S	}
S
N#endif /* configUSE_TRACE_FACILITY */
N
N/*
N * -----------------------------------------------------------
N * The Idle task.
N * ----------------------------------------------------------
N *
N * The portTASK_FUNCTION() macro is used to allow port/compiler specific
N * language extensions.  The equivalent prototype for this function is:
N *
N * void prvIdleTask( void *pvParameters );
N *
N */
Nstatic portTASK_FUNCTION( prvIdleTask, pvParameters )
Xstatic void prvIdleTask( void *pvParameters )
N{
N	/* Stop warnings. */
N	( void ) pvParameters;
N
N	for( ;; )
N	{
N		/* See if any tasks have been deleted. */
N		prvCheckTasksWaitingTermination();
N
N		#if ( configUSE_PREEMPTION == 0 )
X		#if ( 1 == 0 )
S		{
S			/* If we are not using preemption we keep forcing a task switch to
S			see if any other task has become available.  If we are using
S			preemption we don't need to do this as any task becoming available
S			will automatically get the processor anyway. */
S			taskYIELD();
S		}
N		#endif /* configUSE_PREEMPTION */
N
N		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
X		#if ( ( 1 == 1 ) && ( 1 == 1 ) )
N		{
N			/* When using preemption tasks of equal priority will be
N			timesliced.  If a task that is sharing the idle priority is ready
N			to run then the idle task should yield before the end of the
N			timeslice.
N
N			A critical region is not required here as we are just reading from
N			the list, and an occasional incorrect value will not matter.  If
N			the ready list at the idle priority contains more than one task
N			then a task other than the idle task is ready to execute. */
N			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
X			if( ( ( &( pxReadyTasksLists[ ( ( UBaseType_t ) 0U ) ] ) )->uxNumberOfItems ) > ( UBaseType_t ) 1 )
N			{
N				taskYIELD();
X				{ ( * ( ( volatile uint32_t * ) 0xe000ed04 ) ) = ( 1UL << 28UL ); __dsb( ( 15 ) ); __isb( ( 15 ) ); };
N			}
N			else
N			{
N				mtCOVERAGE_TEST_MARKER();
X				;
N			}
N		}
N		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
N
N		#if ( configUSE_IDLE_HOOK == 1 )
X		#if ( 0 == 1 )
S		{
S			extern void vApplicationIdleHook( void );
S
S			/* Call the user defined function from within the idle task.  This
S			allows the application designer to add background functionality
S			without the overhead of a separate task.
S			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
S			CALL A FUNCTION THAT MIGHT BLOCK. */
S			vApplicationIdleHook();
S		}
N		#endif /* configUSE_IDLE_HOOK */
N
N		/* This conditional compilation should use inequality to 0, not equality
N		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
N		user defined low power mode	implementations require
N		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
N		#if ( configUSE_TICKLESS_IDLE != 0 )
X		#if ( 0 != 0 )
S		{
S		TickType_t xExpectedIdleTime;
S
S			/* It is not desirable to suspend then resume the scheduler on
S			each iteration of the idle task.  Therefore, a preliminary
S			test of the expected idle time is performed without the
S			scheduler suspended.  The result here is not necessarily
S			valid. */
S			xExpectedIdleTime = prvGetExpectedIdleTime();
S
S			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
S			{
S				vTaskSuspendAll();
S				{
S					/* Now the scheduler is suspended, the expected idle
S					time can be sampled again, and this time its value can
S					be used. */
S					configASSERT( xNextTaskUnblockTime >= xTickCount );
S					xExpectedIdleTime = prvGetExpectedIdleTime();
S
S					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
S					{
S						traceLOW_POWER_IDLE_BEGIN();
S						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
S						traceLOW_POWER_IDLE_END();
S					}
S					else
S					{
S						mtCOVERAGE_TEST_MARKER();
S					}
S				}
S				( void ) xTaskResumeAll();
S			}
S			else
S			{
S				mtCOVERAGE_TEST_MARKER();
S			}
S		}
N		#endif /* configUSE_TICKLESS_IDLE */
N	}
N}
N/*-----------------------------------------------------------*/
N
N#if( configUSE_TICKLESS_IDLE != 0 )
X#if( 0 != 0 )
S
S	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
S	{
S	/* The idle task exists in addition to the application tasks. */
S	const UBaseType_t uxNonApplicationTasks = 1;
S	eSleepModeStatus eReturn = eStandardSleep;
S
S		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
S		{
S			/* A task was made ready while the scheduler was suspended. */
S			eReturn = eAbortSleep;
S		}
S		else if( xYieldPending != pdFALSE )
S		{
S			/* A yield was pended while the scheduler was suspended. */
S			eReturn = eAbortSleep;
S		}
S		else
S		{
S			/* If all the tasks are in the suspended list (which might mean they
S			have an infinite block time rather than actually being suspended)
S			then it is safe to turn all clocks off and just wait for external
S			interrupts. */
S			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
S			{
S				eReturn = eNoTasksWaitingTimeout;
S			}
S			else
S			{
S				mtCOVERAGE_TEST_MARKER();
S			}
S		}
S
S		return eReturn;
S	}
S
N#endif /* configUSE_TICKLESS_IDLE */
N/*-----------------------------------------------------------*/
N
Nstatic void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N{
NUBaseType_t x;
N
N	/* Store the task name in the TCB. */
N	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
X	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) ( 16 ); x++ )
N	{
N		pxTCB->pcTaskName[ x ] = pcName[ x ];
N
N		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
N		configMAX_TASK_NAME_LEN characters just in case the memory after the
N		string is not accessible (extremely unlikely). */
N		if( pcName[ x ] == 0x00 )
N		{
N			break;
N		}
N		else
N		{
N			mtCOVERAGE_TEST_MARKER();
X			;
N		}
N	}
N
N	/* Ensure the name string is terminated in the case that the string length
N	was greater or equal to configMAX_TASK_NAME_LEN. */
N	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
X	pxTCB->pcTaskName[ ( 16 ) - 1 ] = '\0';
N
N	/* This is used as an array index so must ensure it's not too large.  First
N	remove the privilege bit if one is present. */
N	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
X	if( uxPriority >= ( UBaseType_t ) ( 5 ) )
N	{
N		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
X		uxPriority = ( UBaseType_t ) ( 5 ) - ( UBaseType_t ) 1U;
N	}
N	else
N	{
N		mtCOVERAGE_TEST_MARKER();
X		;
N	}
N
N	pxTCB->uxPriority = uxPriority;
N	#if ( configUSE_MUTEXES == 1 )
X	#if ( 1 == 1 )
N	{
N		pxTCB->uxBasePriority = uxPriority;
N		pxTCB->uxMutexesHeld = 0;
N	}
N	#endif /* configUSE_MUTEXES */
N
N	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
N	vListInitialiseItem( &( pxTCB->xEventListItem ) );
N
N	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
N	back to	the containing TCB from a generic item in a list. */
N	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
X	( ( &( pxTCB->xGenericListItem ) )->pvOwner = ( void * ) ( pxTCB ) );
N
N	/* Event lists are always in priority order. */
N	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
X	( ( &( pxTCB->xEventListItem ) )->xItemValue = ( ( TickType_t ) ( 5 ) - ( TickType_t ) uxPriority ) );  
N	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
X	( ( &( pxTCB->xEventListItem ) )->pvOwner = ( void * ) ( pxTCB ) );
N
N	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
X	#if ( 0 == 1 )
S	{
S		pxTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
S	}
N	#endif /* portCRITICAL_NESTING_IN_TCB */
N
N	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
X	#if ( 0 == 1 )
S	{
S		pxTCB->pxTaskTag = NULL;
S	}
N	#endif /* configUSE_APPLICATION_TASK_TAG */
N
N	#if ( configGENERATE_RUN_TIME_STATS == 1 )
X	#if ( 0 == 1 )
S	{
S		pxTCB->ulRunTimeCounter = 0UL;
S	}
N	#endif /* configGENERATE_RUN_TIME_STATS */
N
N	#if ( portUSING_MPU_WRAPPERS == 1 )
X	#if ( 0 == 1 )
S	{
S		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
S	}
N	#else /* portUSING_MPU_WRAPPERS */
N	{
N		( void ) xRegions;
N		( void ) usStackDepth;
N	}
N	#endif /* portUSING_MPU_WRAPPERS */
N
N	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
X	#if( 0 != 0 )
S	{
S		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
S		{
S			pxTCB->pvThreadLocalStoragePointers[ x ] = NULL;
S		}
S	}
N	#endif
N
N	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
X	#if ( 1 == 1 )
N	{
N		pxTCB->ulNotifiedValue = 0;
N		pxTCB->eNotifyState = eNotWaitingNotification;
N	}
N	#endif
N
N	#if ( configUSE_NEWLIB_REENTRANT == 1 )
X	#if ( 0 == 1 )
S	{
S		/* Initialise this task's Newlib reent structure. */
S		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
S	}
N	#endif /* configUSE_NEWLIB_REENTRANT */
N}
N/*-----------------------------------------------------------*/
N
N#if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
X#if ( 0 != 0 )
S
S	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue )
S	{
S	TCB_t *pxTCB;
S
S		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
S		{
S			pxTCB = prvGetTCBFromHandle( xTaskToSet );
S			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
S		}
S	}
S
N#endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
N/*-----------------------------------------------------------*/
N
N#if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
X#if ( 0 != 0 )
S
S	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
S	{
S	void *pvReturn = NULL;
S	TCB_t *pxTCB;
S
S		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
S		{
S			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
S			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
S		}
S		else
S		{
S			pvReturn = NULL;
S		}
S
S		return pvReturn;
S	}
S
N#endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
N/*-----------------------------------------------------------*/
N
N#if ( portUSING_MPU_WRAPPERS == 1 )
X#if ( 0 == 1 )
S
S	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
S	{
S	TCB_t *pxTCB;
S
S		/* If null is passed in here then we are modifying the MPU settings of
S		the calling task. */
S		pxTCB = prvGetTCBFromHandle( xTaskToModify );
S
S        vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
S	}
S
N#endif /* portUSING_MPU_WRAPPERS */
N/*-----------------------------------------------------------*/
N
Nstatic void prvInitialiseTaskLists( void )
N{
NUBaseType_t uxPriority;
N
N	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
X	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) ( 5 ); uxPriority++ )
N	{
N		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
N	}
N
N	vListInitialise( &xDelayedTaskList1 );
N	vListInitialise( &xDelayedTaskList2 );
N	vListInitialise( &xPendingReadyList );
N
N	#if ( INCLUDE_vTaskDelete == 1 )
X	#if ( 1 == 1 )
N	{
N		vListInitialise( &xTasksWaitingTermination );
N	}
N	#endif /* INCLUDE_vTaskDelete */
N
N	#if ( INCLUDE_vTaskSuspend == 1 )
X	#if ( 1 == 1 )
N	{
N		vListInitialise( &xSuspendedTaskList );
N	}
N	#endif /* INCLUDE_vTaskSuspend */
N
N	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
N	using list2. */
N	pxDelayedTaskList = &xDelayedTaskList1;
N	pxOverflowDelayedTaskList = &xDelayedTaskList2;
N}
N/*-----------------------------------------------------------*/
N
Nstatic void prvCheckTasksWaitingTermination( void )
N{
N	#if ( INCLUDE_vTaskDelete == 1 )
X	#if ( 1 == 1 )
N	{
N		BaseType_t xListIsEmpty;
N
N		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
N		too often in the idle task. */
N		while( uxTasksDeleted > ( UBaseType_t ) 0U )
N		{
N			vTaskSuspendAll();
N			{
N				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
X				xListIsEmpty = ( ( BaseType_t ) ( ( &xTasksWaitingTermination )->uxNumberOfItems == ( UBaseType_t ) 0 ) );
N			}
N			( void ) xTaskResumeAll();
N
N			if( xListIsEmpty == pdFALSE )
X			if( xListIsEmpty == ( ( BaseType_t ) 0 ) )
N			{
N				TCB_t *pxTCB;
N
N				taskENTER_CRITICAL();
X				vPortEnterCritical();
N				{
N					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
X					pxTCB = ( TCB_t * ) ( (&( ( ( &xTasksWaitingTermination ) )->xListEnd ))->pxNext->pvOwner );
N					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
N					--uxCurrentNumberOfTasks;
N					--uxTasksDeleted;
N				}
N				taskEXIT_CRITICAL();
X				vPortExitCritical();
N
N				prvDeleteTCB( pxTCB );
N			}
N			else
N			{
N				mtCOVERAGE_TEST_MARKER();
X				;
N			}
N		}
N	}
N	#endif /* vTaskDelete */
N}
N/*-----------------------------------------------------------*/
N
Nstatic void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
N{
N	/* The list item will be inserted in wake time order. */
N	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
X	( ( &( pxCurrentTCB->xGenericListItem ) )->xItemValue = ( xTimeToWake ) );
N
N	if( xTimeToWake < xTickCount )
N	{
N		/* Wake time has overflowed.  Place this item in the overflow list. */
N		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
N	}
N	else
N	{
N		/* The wake time has not overflowed, so the current block list is used. */
N		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
N
N		/* If the task entering the blocked state was placed at the head of the
N		list of blocked tasks then xNextTaskUnblockTime needs to be updated
N		too. */
N		if( xTimeToWake < xNextTaskUnblockTime )
N		{
N			xNextTaskUnblockTime = xTimeToWake;
N		}
N		else
N		{
N			mtCOVERAGE_TEST_MARKER();
X			;
N		}
N	}
N}
N/*-----------------------------------------------------------*/
N
Nstatic TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
N{
NTCB_t *pxNewTCB;
N
N	/* If the stack grows down then allocate the stack then the TCB so the stack
N	does not grow into the TCB.  Likewise if the stack grows up then allocate
N	the TCB then the stack. */
N	#if( portSTACK_GROWTH > 0 )
X	#if( ( -1 ) > 0 )
S	{
S		/* Allocate space for the TCB.  Where the memory comes from depends on
S		the implementation of the port malloc function. */
S		pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
S
S		if( pxNewTCB != NULL )
S		{
S			/* Allocate space for the stack used by the task being created.
S			The base of the stack memory stored in the TCB so the task can
S			be deleted later if required. */
S			pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
S
S			if( pxNewTCB->pxStack == NULL )
S			{
S				/* Could not allocate the stack.  Delete the allocated TCB. */
S				vPortFree( pxNewTCB );
S				pxNewTCB = NULL;
S			}
S		}
S	}
N	#else /* portSTACK_GROWTH */
N	{
N	StackType_t *pxStack;
N
N		/* Allocate space for the stack used by the task being created. */
N		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
X		pxStack = ( StackType_t * ) ( ( ( puxStackBuffer ) == 0 ) ? ( pvPortMalloc( ( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ) ) ) : ( puxStackBuffer ) );  
N
N		if( pxStack != NULL )
X		if( pxStack != 0 )
N		{
N			/* Allocate space for the TCB.  Where the memory comes from depends
N			on the implementation of the port malloc function. */
N			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
N
N			if( pxNewTCB != NULL )
X			if( pxNewTCB != 0 )
N			{
N				/* Store the stack location in the TCB. */
N				pxNewTCB->pxStack = pxStack;
N			}
N			else
N			{
N				/* The stack cannot be used as the TCB was not created.  Free it
N				again. */
N				vPortFree( pxStack );
N			}
N		}
N		else
N		{
N			pxNewTCB = NULL;
X			pxNewTCB = 0;
N		}
N	}
N	#endif /* portSTACK_GROWTH */
N
N	if( pxNewTCB != NULL )
X	if( pxNewTCB != 0 )
N	{
N		/* Avoid dependency on memset() if it is not required. */
N		#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
X		#if( ( 0 > 1 ) || ( 0 == 1 ) || ( 0 == 1 ) )
S		{
S			/* Just to help debugging. */
S			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
S		}
N		#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
N	}
N
N	return pxNewTCB;
N}
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_TRACE_FACILITY == 1 )
X#if ( 0 == 1 )
S
S	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
S	{
S	volatile TCB_t *pxNextTCB, *pxFirstTCB;
S	UBaseType_t uxTask = 0;
S
S		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
S		{
S			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
S
S			/* Populate an TaskStatus_t structure within the
S			pxTaskStatusArray array for each task that is referenced from
S			pxList.  See the definition of TaskStatus_t in task.h for the
S			meaning of each TaskStatus_t structure member. */
S			do
S			{
S				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
S
S				pxTaskStatusArray[ uxTask ].xHandle = ( TaskHandle_t ) pxNextTCB;
S				pxTaskStatusArray[ uxTask ].pcTaskName = ( const char * ) &( pxNextTCB->pcTaskName [ 0 ] );
S				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
S				pxTaskStatusArray[ uxTask ].eCurrentState = eState;
S				pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriority;
S
S				#if ( INCLUDE_vTaskSuspend == 1 )
S				{
S					/* If the task is in the suspended list then there is a chance
S					it is actually just blocked indefinitely - so really it should
S					be reported as being in the Blocked state. */
S					if( eState == eSuspended )
S					{
S						if( listLIST_ITEM_CONTAINER( &( pxNextTCB->xEventListItem ) ) != NULL )
S						{
S							pxTaskStatusArray[ uxTask ].eCurrentState = eBlocked;
S						}
S					}
S				}
S				#endif /* INCLUDE_vTaskSuspend */
S
S				#if ( configUSE_MUTEXES == 1 )
S				{
S					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
S				}
S				#else
S				{
S					pxTaskStatusArray[ uxTask ].uxBasePriority = 0;
S				}
S				#endif
S
S				#if ( configGENERATE_RUN_TIME_STATS == 1 )
S				{
S					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
S				}
S				#else
S				{
S					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
S				}
S				#endif
S
S				#if ( portSTACK_GROWTH > 0 )
S				{
S					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxEndOfStack );
S				}
S				#else
S				{
S					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxStack );
S				}
S				#endif
S
S				uxTask++;
S
S			} while( pxNextTCB != pxFirstTCB );
S		}
S		else
S		{
S			mtCOVERAGE_TEST_MARKER();
S		}
S
S		return uxTask;
S	}
S
N#endif /* configUSE_TRACE_FACILITY */
N/*-----------------------------------------------------------*/
N
N#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
X#if ( ( 0 == 1 ) || ( 0 == 1 ) )
S
S	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
S	{
S	uint32_t ulCount = 0U;
S
S		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
S		{
S			pucStackByte -= portSTACK_GROWTH;
S			ulCount++;
S		}
S
S		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
S
S		return ( uint16_t ) ulCount;
S	}
S
N#endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
N/*-----------------------------------------------------------*/
N
N#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
X#if ( 0 == 1 )
S
S	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
S	{
S	TCB_t *pxTCB;
S	uint8_t *pucEndOfStack;
S	UBaseType_t uxReturn;
S
S		pxTCB = prvGetTCBFromHandle( xTask );
S
S		#if portSTACK_GROWTH < 0
S		{
S			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
S		}
S		#else
S		{
S			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
S		}
S		#endif
S
S		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
S
S		return uxReturn;
S	}
S
N#endif /* INCLUDE_uxTaskGetStackHighWaterMark */
N/*-----------------------------------------------------------*/
N
N#if ( INCLUDE_vTaskDelete == 1 )
X#if ( 1 == 1 )
N
N	static void prvDeleteTCB( TCB_t *pxTCB )
N	{
N		/* This call is required specifically for the TriCore port.  It must be
N		above the vPortFree() calls.  The call is also used by ports/demos that
N		want to allocate and clean RAM statically. */
N		portCLEAN_UP_TCB( pxTCB );
X		( void ) pxTCB;
N
N		/* Free up the memory allocated by the scheduler for the task.  It is up
N		to the task to free any memory allocated at the application level. */
N		#if ( configUSE_NEWLIB_REENTRANT == 1 )
X		#if ( 0 == 1 )
S		{
S			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
S		}
N		#endif /* configUSE_NEWLIB_REENTRANT */
N
N		#if( portUSING_MPU_WRAPPERS == 1 )
X		#if( 0 == 1 )
S		{
S			/* Only free the stack if it was allocated dynamically in the first
S			place. */
S			if( pxTCB->xUsingStaticallyAllocatedStack == pdFALSE )
S			{
S				vPortFreeAligned( pxTCB->pxStack );
S			}
S		}
N		#else
N		{
N			vPortFreeAligned( pxTCB->pxStack );
X			vPortFree( pxTCB->pxStack );
N		}
N		#endif
N
N		vPortFree( pxTCB );
N	}
N
N#endif /* INCLUDE_vTaskDelete */
N/*-----------------------------------------------------------*/
N
Nstatic void prvResetNextTaskUnblockTime( void )
N{
NTCB_t *pxTCB;
N
N	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
X	if( ( ( BaseType_t ) ( ( pxDelayedTaskList )->uxNumberOfItems == ( UBaseType_t ) 0 ) ) != ( ( BaseType_t ) 0 ) )
N	{
N		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
N		the maximum possible value so it is	extremely unlikely that the
N		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
N		there is an item in the delayed list. */
N		xNextTaskUnblockTime = portMAX_DELAY;
X		xNextTaskUnblockTime = ( TickType_t ) 0xffffffffUL;
N	}
N	else
N	{
N		/* The new current delayed list is not empty, get the value of
N		the item at the head of the delayed list.  This is the time at
N		which the task at the head of the delayed list should be removed
N		from the Blocked state. */
N		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
X		( pxTCB ) = ( TCB_t * ) ( (&( ( pxDelayedTaskList )->xListEnd ))->pxNext->pvOwner );
N		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
X		xNextTaskUnblockTime = ( ( &( ( pxTCB )->xGenericListItem ) )->xItemValue );
N	}
N}
N/*-----------------------------------------------------------*/
N
N#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
X#if ( ( 0 == 1 ) || ( 1 == 1 ) )
N
N	TaskHandle_t xTaskGetCurrentTaskHandle( void )
N	{
N	TaskHandle_t xReturn;
N
N		/* A critical section is not required as this is not called from
N		an interrupt and the current TCB will always be the same for any
N		individual execution thread. */
N		xReturn = pxCurrentTCB;
N
N		return xReturn;
N	}
N
N#endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
N/*-----------------------------------------------------------*/
N
N#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
X#if ( ( 0 == 1 ) || ( 0 == 1 ) )
S
S	BaseType_t xTaskGetSchedulerState( void )
S	{
S	BaseType_t xReturn;
S
S		if( xSchedulerRunning == pdFALSE )
S		{
S			xReturn = taskSCHEDULER_NOT_STARTED;
S		}
S		else
S		{
S			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
S			{
S				xReturn = taskSCHEDULER_RUNNING;
S			}
S			else
S			{
S				xReturn = taskSCHEDULER_SUSPENDED;
S			}
S		}
S
S		return xReturn;
S	}
S
N#endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_MUTEXES == 1 )
X#if ( 1 == 1 )
N
N	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
N	{
N	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
N
N		/* If the mutex was given back by an interrupt while the queue was
N		locked then the mutex holder might now be NULL. */
N		if( pxMutexHolder != NULL )
X		if( pxMutexHolder != 0 )
N		{
N			/* If the holder of the mutex has a priority below the priority of
N			the task attempting to obtain the mutex then it will temporarily
N			inherit the priority of the task attempting to obtain the mutex. */
N			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
N			{
N				/* Adjust the mutex holder state to account for its new
N				priority.  Only reset the event list item value if the value is
N				not	being used for anything else. */
N				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
X				if( ( ( ( &( pxTCB->xEventListItem ) )->xItemValue ) & 0x80000000UL ) == 0UL )
N				{
N					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
X					( ( &( pxTCB->xEventListItem ) )->xItemValue = ( ( TickType_t ) ( 5 ) - ( TickType_t ) pxCurrentTCB->uxPriority ) );  
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N
N				/* If the task being modified is in the ready state it will need
N				to be moved into a new list. */
N				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
X				if( ( ( BaseType_t ) ( ( &( pxTCB->xGenericListItem ) )->pvContainer == ( void * ) ( &( pxReadyTasksLists[ pxTCB->uxPriority ] ) ) ) ) != ( ( BaseType_t ) 0 ) )
N				{
N					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
N					{
N						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
X						{ if( ( ( &( pxReadyTasksLists[ ( pxTCB->uxPriority ) ] ) )->uxNumberOfItems ) == ( UBaseType_t ) 0 ) { ( ( uxTopReadyPriority ) ) &= ~( 1UL << ( ( pxTCB->uxPriority ) ) ); } };
N					}
N					else
N					{
N						mtCOVERAGE_TEST_MARKER();
X						;
N					}
N
N					/* Inherit the priority before being moved into the new list. */
N					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
N					prvAddTaskToReadyList( pxTCB );
X					; ( uxTopReadyPriority ) |= ( 1UL << ( ( pxTCB )->uxPriority ) ); vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) );
N				}
N				else
N				{
N					/* Just inherit the priority. */
N					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
N				}
N
N				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
X				;
N			}
N			else
N			{
N				mtCOVERAGE_TEST_MARKER();
X				;
N			}
N		}
N		else
N		{
N			mtCOVERAGE_TEST_MARKER();
X			;
N		}
N	}
N
N#endif /* configUSE_MUTEXES */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_MUTEXES == 1 )
X#if ( 1 == 1 )
N
N	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
N	{
N	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
N	BaseType_t xReturn = pdFALSE;
X	BaseType_t xReturn = ( ( BaseType_t ) 0 );
N
N		if( pxMutexHolder != NULL )
X		if( pxMutexHolder != 0 )
N		{
N			/* A task can only have an inherited priority if it holds the mutex.
N			If the mutex is held by a task then it cannot be given from an
N			interrupt, and if a mutex is given by the holding task then it must
N			be the running state task. */
N			configASSERT( pxTCB == pxCurrentTCB );
X			;
N
N			configASSERT( pxTCB->uxMutexesHeld );
X			;
N			( pxTCB->uxMutexesHeld )--;
N
N			/* Has the holder of the mutex inherited the priority of another
N			task? */
N			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
N			{
N				/* Only disinherit if no other mutexes are held. */
N				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
N				{
N					/* A task can only have an inherited priority if it holds
N					the mutex.  If the mutex is held by a task then it cannot be
N					given from an interrupt, and if a mutex is given by the
N					holding	task then it must be the running state task.  Remove
N					the	holding task from the ready	list. */
N					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
N					{
N						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
X						{ if( ( ( &( pxReadyTasksLists[ ( pxTCB->uxPriority ) ] ) )->uxNumberOfItems ) == ( UBaseType_t ) 0 ) { ( ( uxTopReadyPriority ) ) &= ~( 1UL << ( ( pxTCB->uxPriority ) ) ); } };
N					}
N					else
N					{
N						mtCOVERAGE_TEST_MARKER();
X						;
N					}
N
N					/* Disinherit the priority before adding the task into the
N					new	ready list. */
N					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
X					;
N					pxTCB->uxPriority = pxTCB->uxBasePriority;
N
N					/* Reset the event list item value.  It cannot be in use for
N					any other purpose if this task is running, and it must be
N					running to give back the mutex. */
N					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
X					( ( &( pxTCB->xEventListItem ) )->xItemValue = ( ( TickType_t ) ( 5 ) - ( TickType_t ) pxTCB->uxPriority ) );  
N					prvAddTaskToReadyList( pxTCB );
X					; ( uxTopReadyPriority ) |= ( 1UL << ( ( pxTCB )->uxPriority ) ); vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) );
N
N					/* Return true to indicate that a context switch is required.
N					This is only actually required in the corner case whereby
N					multiple mutexes were held and the mutexes were given back
N					in an order different to that in which they were taken.
N					If a context switch did not occur when the first mutex was
N					returned, even if a task was waiting on it, then a context
N					switch should occur when the last mutex is returned whether
N					a task is waiting on it or not. */
N					xReturn = pdTRUE;
X					xReturn = ( ( BaseType_t ) 1 );
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N			}
N			else
N			{
N				mtCOVERAGE_TEST_MARKER();
X				;
N			}
N		}
N		else
N		{
N			mtCOVERAGE_TEST_MARKER();
X			;
N		}
N
N		return xReturn;
N	}
N
N#endif /* configUSE_MUTEXES */
N/*-----------------------------------------------------------*/
N
N#if ( portCRITICAL_NESTING_IN_TCB == 1 )
X#if ( 0 == 1 )
S
S	void vTaskEnterCritical( void )
S	{
S		portDISABLE_INTERRUPTS();
S
S		if( xSchedulerRunning != pdFALSE )
S		{
S			( pxCurrentTCB->uxCriticalNesting )++;
S
S			/* This is not the interrupt safe version of the enter critical
S			function so	assert() if it is being called from an interrupt
S			context.  Only API functions that end in "FromISR" can be used in an
S			interrupt.  Only assert if the critical nesting count is 1 to
S			protect against recursive calls if the assert function also uses a
S			critical section. */
S			if( pxCurrentTCB->uxCriticalNesting == 1 )
S			{
S				portASSERT_IF_IN_ISR();
S			}
S
S		}
S		else
S		{
S			mtCOVERAGE_TEST_MARKER();
S		}
S	}
S
N#endif /* portCRITICAL_NESTING_IN_TCB */
N/*-----------------------------------------------------------*/
N
N#if ( portCRITICAL_NESTING_IN_TCB == 1 )
X#if ( 0 == 1 )
S
S	void vTaskExitCritical( void )
S	{
S		if( xSchedulerRunning != pdFALSE )
S		{
S			if( pxCurrentTCB->uxCriticalNesting > 0U )
S			{
S				( pxCurrentTCB->uxCriticalNesting )--;
S
S				if( pxCurrentTCB->uxCriticalNesting == 0U )
S				{
S					portENABLE_INTERRUPTS();
S				}
S				else
S				{
S					mtCOVERAGE_TEST_MARKER();
S				}
S			}
S			else
S			{
S				mtCOVERAGE_TEST_MARKER();
S			}
S		}
S		else
S		{
S			mtCOVERAGE_TEST_MARKER();
S		}
S	}
S
N#endif /* portCRITICAL_NESTING_IN_TCB */
N/*-----------------------------------------------------------*/
N
N#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
X#if ( ( 0 == 1 ) && ( 0 > 0 ) )
S
S	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
S	{
S	BaseType_t x;
S
S		/* Start by copying the entire string. */
S		strcpy( pcBuffer, pcTaskName );
S
S		/* Pad the end of the string with spaces to ensure columns line up when
S		printed out. */
S		for( x = strlen( pcBuffer ); x < ( configMAX_TASK_NAME_LEN - 1 ); x++ )
S		{
S			pcBuffer[ x ] = ' ';
S		}
S
S		/* Terminate. */
S		pcBuffer[ x ] = 0x00;
S
S		/* Return the new end of string. */
S		return &( pcBuffer[ x ] );
S	}
S
N#endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
N/*-----------------------------------------------------------*/
N
N#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
X#if ( ( 0 == 1 ) && ( 0 > 0 ) )
S
S	void vTaskList( char * pcWriteBuffer )
S	{
S	TaskStatus_t *pxTaskStatusArray;
S	volatile UBaseType_t uxArraySize, x;
S	char cStatus;
S
S		/*
S		 * PLEASE NOTE:
S		 *
S		 * This function is provided for convenience only, and is used by many
S		 * of the demo applications.  Do not consider it to be part of the
S		 * scheduler.
S		 *
S		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
S		 * uxTaskGetSystemState() output into a human readable table that
S		 * displays task names, states and stack usage.
S		 *
S		 * vTaskList() has a dependency on the sprintf() C library function that
S		 * might bloat the code size, use a lot of stack, and provide different
S		 * results on different platforms.  An alternative, tiny, third party,
S		 * and limited functionality implementation of sprintf() is provided in
S		 * many of the FreeRTOS/Demo sub-directories in a file called
S		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
S		 * snprintf() implementation!).
S		 *
S		 * It is recommended that production systems call uxTaskGetSystemState()
S		 * directly to get access to raw stats data, rather than indirectly
S		 * through a call to vTaskList().
S		 */
S
S
S		/* Make sure the write buffer does not contain a string. */
S		*pcWriteBuffer = 0x00;
S
S		/* Take a snapshot of the number of tasks in case it changes while this
S		function is executing. */
S		uxArraySize = uxCurrentNumberOfTasks;
S
S		/* Allocate an array index for each task. */
S		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
S
S		if( pxTaskStatusArray != NULL )
S		{
S			/* Generate the (binary) data. */
S			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
S
S			/* Create a human readable table from the binary data. */
S			for( x = 0; x < uxArraySize; x++ )
S			{
S				switch( pxTaskStatusArray[ x ].eCurrentState )
S				{
S					case eReady:		cStatus = tskREADY_CHAR;
S										break;
S
S					case eBlocked:		cStatus = tskBLOCKED_CHAR;
S										break;
S
S					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
S										break;
S
S					case eDeleted:		cStatus = tskDELETED_CHAR;
S										break;
S
S					default:			/* Should not get here, but it is included
S										to prevent static checking errors. */
S										cStatus = 0x00;
S										break;
S				}
S
S				/* Write the task name to the string, padding with spaces so it
S				can be printed in tabular form more easily. */
S				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
S
S				/* Write the rest of the string. */
S				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
S				pcWriteBuffer += strlen( pcWriteBuffer );
S			}
S
S			/* Free the array again. */
S			vPortFree( pxTaskStatusArray );
S		}
S		else
S		{
S			mtCOVERAGE_TEST_MARKER();
S		}
S	}
S
N#endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
N/*----------------------------------------------------------*/
N
N#if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
X#if ( ( 0 == 1 ) && ( 0 > 0 ) )
S
S	void vTaskGetRunTimeStats( char *pcWriteBuffer )
S	{
S	TaskStatus_t *pxTaskStatusArray;
S	volatile UBaseType_t uxArraySize, x;
S	uint32_t ulTotalTime, ulStatsAsPercentage;
S
S		#if( configUSE_TRACE_FACILITY != 1 )
S		{
S			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().
S		}
S		#endif
S
S		/*
S		 * PLEASE NOTE:
S		 *
S		 * This function is provided for convenience only, and is used by many
S		 * of the demo applications.  Do not consider it to be part of the
S		 * scheduler.
S		 *
S		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
S		 * of the uxTaskGetSystemState() output into a human readable table that
S		 * displays the amount of time each task has spent in the Running state
S		 * in both absolute and percentage terms.
S		 *
S		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
S		 * function that might bloat the code size, use a lot of stack, and
S		 * provide different results on different platforms.  An alternative,
S		 * tiny, third party, and limited functionality implementation of
S		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
S		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
S		 * a full snprintf() implementation!).
S		 *
S		 * It is recommended that production systems call uxTaskGetSystemState()
S		 * directly to get access to raw stats data, rather than indirectly
S		 * through a call to vTaskGetRunTimeStats().
S		 */
S
S		/* Make sure the write buffer does not contain a string. */
S		*pcWriteBuffer = 0x00;
S
S		/* Take a snapshot of the number of tasks in case it changes while this
S		function is executing. */
S		uxArraySize = uxCurrentNumberOfTasks;
S
S		/* Allocate an array index for each task. */
S		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
S
S		if( pxTaskStatusArray != NULL )
S		{
S			/* Generate the (binary) data. */
S			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
S
S			/* For percentage calculations. */
S			ulTotalTime /= 100UL;
S
S			/* Avoid divide by zero errors. */
S			if( ulTotalTime > 0 )
S			{
S				/* Create a human readable table from the binary data. */
S				for( x = 0; x < uxArraySize; x++ )
S				{
S					/* What percentage of the total run time has the task used?
S					This will always be rounded down to the nearest integer.
S					ulTotalRunTimeDiv100 has already been divided by 100. */
S					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
S
S					/* Write the task name to the string, padding with
S					spaces so it can be printed in tabular form more
S					easily. */
S					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
S
S					if( ulStatsAsPercentage > 0UL )
S					{
S						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
S						{
S							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
S						}
S						#else
S						{
S							/* sizeof( int ) == sizeof( long ) so a smaller
S							printf() library can be used. */
S							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
S						}
S						#endif
S					}
S					else
S					{
S						/* If the percentage is zero here then the task has
S						consumed less than 1% of the total run time. */
S						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
S						{
S							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
S						}
S						#else
S						{
S							/* sizeof( int ) == sizeof( long ) so a smaller
S							printf() library can be used. */
S							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter );
S						}
S						#endif
S					}
S
S					pcWriteBuffer += strlen( pcWriteBuffer );
S				}
S			}
S			else
S			{
S				mtCOVERAGE_TEST_MARKER();
S			}
S
S			/* Free the array again. */
S			vPortFree( pxTaskStatusArray );
S		}
S		else
S		{
S			mtCOVERAGE_TEST_MARKER();
S		}
S	}
S
N#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
N/*-----------------------------------------------------------*/
N
NTickType_t uxTaskResetEventItemValue( void )
N{
NTickType_t uxReturn;
N
N	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
X	uxReturn = ( ( &( pxCurrentTCB->xEventListItem ) )->xItemValue );
N
N	/* Reset the event list item to its normal value - so it can be used with
N	queues and semaphores. */
N	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
X	( ( &( pxCurrentTCB->xEventListItem ) )->xItemValue = ( ( ( TickType_t ) ( 5 ) - ( TickType_t ) pxCurrentTCB->uxPriority ) ) );  
N
N	return uxReturn;
N}
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_MUTEXES == 1 )
X#if ( 1 == 1 )
N
N	void *pvTaskIncrementMutexHeldCount( void )
N	{
N		/* If xSemaphoreCreateMutex() is called before any tasks have been created
N		then pxCurrentTCB will be NULL. */
N		if( pxCurrentTCB != NULL )
X		if( pxCurrentTCB != 0 )
N		{
N			( pxCurrentTCB->uxMutexesHeld )++;
N		}
N
N		return pxCurrentTCB;
N	}
N
N#endif /* configUSE_MUTEXES */
N/*-----------------------------------------------------------*/
N
N#if( configUSE_TASK_NOTIFICATIONS == 1 )
X#if( 1 == 1 )
N
N	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
N	{
N	TickType_t xTimeToWake;
N	uint32_t ulReturn;
N
N		taskENTER_CRITICAL();
X		vPortEnterCritical();
N		{
N			/* Only block if the notification count is not already non-zero. */
N			if( pxCurrentTCB->ulNotifiedValue == 0UL )
N			{
N				/* Mark this task as waiting for a notification. */
N				pxCurrentTCB->eNotifyState = eWaitingNotification;
N
N				if( xTicksToWait > ( TickType_t ) 0 )
N				{
N					/* The task is going to block.  First it must be removed
N					from the ready list. */
N					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
N					{
N						/* The current task must be in a ready list, so there is
N						no need to check, and the port reset macro can be called
N						directly. */
N						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
X						( uxTopReadyPriority ) &= ~( 1UL << ( pxCurrentTCB->uxPriority ) );
N					}
N					else
N					{
N						mtCOVERAGE_TEST_MARKER();
X						;
N					}
N
N					#if ( INCLUDE_vTaskSuspend == 1 )
X					#if ( 1 == 1 )
N					{
N						if( xTicksToWait == portMAX_DELAY )
X						if( xTicksToWait == ( TickType_t ) 0xffffffffUL )
N						{
N							/* Add the task to the suspended task list instead
N							of a delayed task list to ensure the task is not
N							woken by a timing event.  It will block
N							indefinitely. */
N							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
N						}
N						else
N						{
N							/* Calculate the time at which the task should be
N							woken if no notification events occur.  This may
N							overflow but this doesn't matter, the scheduler will
N							handle it. */
N							xTimeToWake = xTickCount + xTicksToWait;
N							prvAddCurrentTaskToDelayedList( xTimeToWake );
N						}
N					}
N					#else /* INCLUDE_vTaskSuspend */
S					{
S							/* Calculate the time at which the task should be
S							woken if the event does not occur.  This may
S							overflow but this doesn't matter, the scheduler will
S							handle it. */
S							xTimeToWake = xTickCount + xTicksToWait;
S							prvAddCurrentTaskToDelayedList( xTimeToWake );
S					}
N					#endif /* INCLUDE_vTaskSuspend */
N
N					traceTASK_NOTIFY_TAKE_BLOCK();
X					;
N
N					/* All ports are written to allow a yield in a critical
N					section (some will yield immediately, others wait until the
N					critical section exits) - but it is not something that
N					application code should ever do. */
N					portYIELD_WITHIN_API();
X					{ ( * ( ( volatile uint32_t * ) 0xe000ed04 ) ) = ( 1UL << 28UL ); __dsb( ( 15 ) ); __isb( ( 15 ) ); };
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N			}
N			else
N			{
N				mtCOVERAGE_TEST_MARKER();
X				;
N			}
N		}
N		taskEXIT_CRITICAL();
X		vPortExitCritical();
N
N		taskENTER_CRITICAL();
X		vPortEnterCritical();
N		{
N			traceTASK_NOTIFY_TAKE();
X			;
N			ulReturn = pxCurrentTCB->ulNotifiedValue;
N
N			if( ulReturn != 0UL )
N			{
N				if( xClearCountOnExit != pdFALSE )
X				if( xClearCountOnExit != ( ( BaseType_t ) 0 ) )
N				{
N					pxCurrentTCB->ulNotifiedValue = 0UL;
N				}
N				else
N				{
N					( pxCurrentTCB->ulNotifiedValue )--;
N				}
N			}
N			else
N			{
N				mtCOVERAGE_TEST_MARKER();
X				;
N			}
N
N			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
N		}
N		taskEXIT_CRITICAL();
X		vPortExitCritical();
N
N		return ulReturn;
N	}
N
N#endif /* configUSE_TASK_NOTIFICATIONS */
N/*-----------------------------------------------------------*/
N
N#if( configUSE_TASK_NOTIFICATIONS == 1 )
X#if( 1 == 1 )
N
N	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
N	{
N	TickType_t xTimeToWake;
N	BaseType_t xReturn;
N
N		taskENTER_CRITICAL();
X		vPortEnterCritical();
N		{
N			/* Only block if a notification is not already pending. */
N			if( pxCurrentTCB->eNotifyState != eNotified )
N			{
N				/* Clear bits in the task's notification value as bits may get
N				set	by the notifying task or interrupt.  This can be used to
N				clear the value to zero. */
N				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
N
N				/* Mark this task as waiting for a notification. */
N				pxCurrentTCB->eNotifyState = eWaitingNotification;
N
N				if( xTicksToWait > ( TickType_t ) 0 )
N				{
N					/* The task is going to block.  First it must be removed
N					from the	ready list. */
N					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
N					{
N						/* The current task must be in a ready list, so there is
N						no need to check, and the port reset macro can be called
N						directly. */
N						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
X						( uxTopReadyPriority ) &= ~( 1UL << ( pxCurrentTCB->uxPriority ) );
N					}
N					else
N					{
N						mtCOVERAGE_TEST_MARKER();
X						;
N					}
N
N					#if ( INCLUDE_vTaskSuspend == 1 )
X					#if ( 1 == 1 )
N					{
N						if( xTicksToWait == portMAX_DELAY )
X						if( xTicksToWait == ( TickType_t ) 0xffffffffUL )
N						{
N							/* Add the task to the suspended task list instead
N							of a delayed task list to ensure the task is not
N							woken by a timing event.  It will block
N							indefinitely. */
N							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
N						}
N						else
N						{
N							/* Calculate the time at which the task should be
N							woken if no notification events occur.  This may
N							overflow but this doesn't matter, the scheduler will
N							handle it. */
N							xTimeToWake = xTickCount + xTicksToWait;
N							prvAddCurrentTaskToDelayedList( xTimeToWake );
N						}
N					}
N					#else /* INCLUDE_vTaskSuspend */
S					{
S							/* Calculate the time at which the task should be
S							woken if the event does not occur.  This may
S							overflow but this doesn't matter, the scheduler will
S							handle it. */
S							xTimeToWake = xTickCount + xTicksToWait;
S							prvAddCurrentTaskToDelayedList( xTimeToWake );
S					}
N					#endif /* INCLUDE_vTaskSuspend */
N
N					traceTASK_NOTIFY_WAIT_BLOCK();
X					;
N					
N					/* All ports are written to allow a yield in a critical
N					section (some will yield immediately, others wait until the
N					critical section exits) - but it is not something that
N					application code should ever do. */
N					portYIELD_WITHIN_API();
X					{ ( * ( ( volatile uint32_t * ) 0xe000ed04 ) ) = ( 1UL << 28UL ); __dsb( ( 15 ) ); __isb( ( 15 ) ); };
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N			}
N			else
N			{
N				mtCOVERAGE_TEST_MARKER();
X				;
N			}
N		}
N		taskEXIT_CRITICAL();
X		vPortExitCritical();
N
N		taskENTER_CRITICAL();
X		vPortEnterCritical();
N		{
N			traceTASK_NOTIFY_WAIT();
X			;
N			
N			if( pulNotificationValue != NULL )
X			if( pulNotificationValue != 0 )
N			{
N				/* Output the current notification value, which may or may not
N				have changed. */
N				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
N			}
N
N			/* If eNotifyValue is set then either the task never entered the
N			blocked state (because a notification was already pending) or the
N			task unblocked because of a notification.  Otherwise the task
N			unblocked because of a timeout. */
N			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
N			{
N				/* A notification was not received. */
N				xReturn = pdFALSE;
X				xReturn = ( ( BaseType_t ) 0 );
N			}
N			else
N			{
N				/* A notification was already pending or a notification was
N				received while the task was waiting. */
N				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
N				xReturn = pdTRUE;
X				xReturn = ( ( BaseType_t ) 1 );
N			}
N
N			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
N		}
N		taskEXIT_CRITICAL();
X		vPortExitCritical();
N
N		return xReturn;
N	}
N
N#endif /* configUSE_TASK_NOTIFICATIONS */
N/*-----------------------------------------------------------*/
N
N#if( configUSE_TASK_NOTIFICATIONS == 1 )
X#if( 1 == 1 )
N
N	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
N	{
N	TCB_t * pxTCB;
N	eNotifyValue eOriginalNotifyState;
N	BaseType_t xReturn = pdPASS;
X	BaseType_t xReturn = ( ( ( BaseType_t ) 1 ) );
N
N		configASSERT( xTaskToNotify );
X		;
N		pxTCB = ( TCB_t * ) xTaskToNotify;
N
N		taskENTER_CRITICAL();
X		vPortEnterCritical();
N		{
N			if( pulPreviousNotificationValue != NULL )
X			if( pulPreviousNotificationValue != 0 )
N			{
N				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
N			}
N
N			eOriginalNotifyState = pxTCB->eNotifyState;
N
N			pxTCB->eNotifyState = eNotified;
N
N			switch( eAction )
N			{
N				case eSetBits	:
N					pxTCB->ulNotifiedValue |= ulValue;
N					break;
N
N				case eIncrement	:
N					( pxTCB->ulNotifiedValue )++;
N					break;
N
N				case eSetValueWithOverwrite	:
N					pxTCB->ulNotifiedValue = ulValue;
N					break;
N
N				case eSetValueWithoutOverwrite :
N					if( eOriginalNotifyState != eNotified )
N					{
N						pxTCB->ulNotifiedValue = ulValue;
N					}
N					else
N					{
N						/* The value could not be written to the task. */
N						xReturn = pdFAIL;
X						xReturn = ( ( ( BaseType_t ) 0 ) );
N					}
N					break;
N
N				case eNoAction:
N					/* The task is being notified without its notify value being
N					updated. */
N					break;
N			}
N
N			traceTASK_NOTIFY();
X			;
N
N			/* If the task is in the blocked state specifically to wait for a
N			notification then unblock it now. */
N			if( eOriginalNotifyState == eWaitingNotification )
N			{
N				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
N				prvAddTaskToReadyList( pxTCB );
X				; ( uxTopReadyPriority ) |= ( 1UL << ( ( pxTCB )->uxPriority ) ); vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) );
N
N				/* The task should not have been on an event list. */
N				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
X				;
N
N				#if( configUSE_TICKLESS_IDLE != 0 )
X				#if( 0 != 0 )
S				{
S					/* If a task is blocked waiting for a notification then
S					xNextTaskUnblockTime might be set to the blocked task's time
S					out time.  If the task is unblocked for a reason other than
S					a timeout xNextTaskUnblockTime is normally left unchanged,
S					because it will automatically get reset to a new value when
S					the tick count equals xNextTaskUnblockTime.  However if
S					tickless idling is used it might be more important to enter
S					sleep mode at the earliest possible time - so reset
S					xNextTaskUnblockTime here to ensure it is updated at the
S					earliest possible time. */
S					prvResetNextTaskUnblockTime();
S				}
N				#endif
N
N				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
N				{
N					/* The notified task has a priority above the currently
N					executing task so a yield is required. */
N					taskYIELD_IF_USING_PREEMPTION();
X					{ ( * ( ( volatile uint32_t * ) 0xe000ed04 ) ) = ( 1UL << 28UL ); __dsb( ( 15 ) ); __isb( ( 15 ) ); };
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N			}
N			else
N			{
N				mtCOVERAGE_TEST_MARKER();
X				;
N			}
N		}
N		taskEXIT_CRITICAL();
X		vPortExitCritical();
N
N		return xReturn;
N	}
N
N#endif /* configUSE_TASK_NOTIFICATIONS */
N/*-----------------------------------------------------------*/
N
N#if( configUSE_TASK_NOTIFICATIONS == 1 )
X#if( 1 == 1 )
N
N	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
N	{
N	TCB_t * pxTCB;
N	eNotifyValue eOriginalNotifyState;
N	BaseType_t xReturn = pdPASS;
X	BaseType_t xReturn = ( ( ( BaseType_t ) 1 ) );
N	UBaseType_t uxSavedInterruptStatus;
N
N		configASSERT( xTaskToNotify );
X		;
N
N		/* RTOS ports that support interrupt nesting have the concept of a
N		maximum	system call (or maximum API call) interrupt priority.
N		Interrupts that are	above the maximum system call priority are keep
N		permanently enabled, even when the RTOS kernel is in a critical section,
N		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
N		is defined in FreeRTOSConfig.h then
N		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
N		failure if a FreeRTOS API function is called from an interrupt that has
N		been assigned a priority above the configured maximum system call
N		priority.  Only FreeRTOS functions that end in FromISR can be called
N		from interrupts	that have been assigned a priority at or (logically)
N		below the maximum system call interrupt priority.  FreeRTOS maintains a
N		separate interrupt safe API to ensure interrupt entry is as fast and as
N		simple as possible.  More information (albeit Cortex-M specific) is
N		provided on the following link:
N		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
N		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
X		;
N
N		pxTCB = ( TCB_t * ) xTaskToNotify;
N
N		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
X		uxSavedInterruptStatus = ulPortRaiseBASEPRI();
N		{
N			if( pulPreviousNotificationValue != NULL )
X			if( pulPreviousNotificationValue != 0 )
N			{
N				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
N			}
N
N			eOriginalNotifyState = pxTCB->eNotifyState;
N			pxTCB->eNotifyState = eNotified;
N
N			switch( eAction )
N			{
N				case eSetBits	:
N					pxTCB->ulNotifiedValue |= ulValue;
N					break;
N
N				case eIncrement	:
N					( pxTCB->ulNotifiedValue )++;
N					break;
N
N				case eSetValueWithOverwrite	:
N					pxTCB->ulNotifiedValue = ulValue;
N					break;
N
N				case eSetValueWithoutOverwrite :
N					if( eOriginalNotifyState != eNotified )
N					{
N						pxTCB->ulNotifiedValue = ulValue;
N					}
N					else
N					{
N						/* The value could not be written to the task. */
N						xReturn = pdFAIL;
X						xReturn = ( ( ( BaseType_t ) 0 ) );
N					}
N					break;
N
N				case eNoAction :
N					/* The task is being notified without its notify value being
N					updated. */
N					break;
N			}
N
N			traceTASK_NOTIFY_FROM_ISR();
X			;
N			
N			/* If the task is in the blocked state specifically to wait for a
N			notification then unblock it now. */
N			if( eOriginalNotifyState == eWaitingNotification )
N			{
N				/* The task should not have been on an event list. */
N				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
X				;
N
N				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
X				if( uxSchedulerSuspended == ( UBaseType_t ) ( ( BaseType_t ) 0 ) )
N				{
N					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
N					prvAddTaskToReadyList( pxTCB );
X					; ( uxTopReadyPriority ) |= ( 1UL << ( ( pxTCB )->uxPriority ) ); vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) );
N				}
N				else
N				{
N					/* The delayed and ready lists cannot be accessed, so hold
N					this task pending until the scheduler is resumed. */
N					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
N				}
N
N				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
N				{
N					/* The notified task has a priority above the currently
N					executing task so a yield is required. */
N					if( pxHigherPriorityTaskWoken != NULL )
X					if( pxHigherPriorityTaskWoken != 0 )
N					{
N						*pxHigherPriorityTaskWoken = pdTRUE;
X						*pxHigherPriorityTaskWoken = ( ( BaseType_t ) 1 );
N					}
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N			}
N		}
N		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
X		vPortSetBASEPRI(uxSavedInterruptStatus);
N
N		return xReturn;
N	}
N
N#endif /* configUSE_TASK_NOTIFICATIONS */
N/*-----------------------------------------------------------*/
N
N#if( configUSE_TASK_NOTIFICATIONS == 1 )
X#if( 1 == 1 )
N
N	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
N	{
N	TCB_t * pxTCB;
N	eNotifyValue eOriginalNotifyState;
N	UBaseType_t uxSavedInterruptStatus;
N
N		configASSERT( xTaskToNotify );
X		;
N
N		/* RTOS ports that support interrupt nesting have the concept of a
N		maximum	system call (or maximum API call) interrupt priority.
N		Interrupts that are	above the maximum system call priority are keep
N		permanently enabled, even when the RTOS kernel is in a critical section,
N		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
N		is defined in FreeRTOSConfig.h then
N		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
N		failure if a FreeRTOS API function is called from an interrupt that has
N		been assigned a priority above the configured maximum system call
N		priority.  Only FreeRTOS functions that end in FromISR can be called
N		from interrupts	that have been assigned a priority at or (logically)
N		below the maximum system call interrupt priority.  FreeRTOS maintains a
N		separate interrupt safe API to ensure interrupt entry is as fast and as
N		simple as possible.  More information (albeit Cortex-M specific) is
N		provided on the following link:
N		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
N		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
X		;
N
N		pxTCB = ( TCB_t * ) xTaskToNotify;
N
N		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
X		uxSavedInterruptStatus = ulPortRaiseBASEPRI();
N		{
N			eOriginalNotifyState = pxTCB->eNotifyState;
N			pxTCB->eNotifyState = eNotified;
N
N			/* 'Giving' is equivalent to incrementing a count in a counting
N			semaphore. */
N			( pxTCB->ulNotifiedValue )++;
N			
N			traceTASK_NOTIFY_GIVE_FROM_ISR();
X			;
N
N			/* If the task is in the blocked state specifically to wait for a
N			notification then unblock it now. */
N			if( eOriginalNotifyState == eWaitingNotification )
N			{
N				/* The task should not have been on an event list. */
N				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
X				;
N
N				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
X				if( uxSchedulerSuspended == ( UBaseType_t ) ( ( BaseType_t ) 0 ) )
N				{
N					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
N					prvAddTaskToReadyList( pxTCB );
X					; ( uxTopReadyPriority ) |= ( 1UL << ( ( pxTCB )->uxPriority ) ); vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) );
N				}
N				else
N				{
N					/* The delayed and ready lists cannot be accessed, so hold
N					this task pending until the scheduler is resumed. */
N					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
N				}
N
N				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
N				{
N					/* The notified task has a priority above the currently
N					executing task so a yield is required. */
N					if( pxHigherPriorityTaskWoken != NULL )
X					if( pxHigherPriorityTaskWoken != 0 )
N					{
N						*pxHigherPriorityTaskWoken = pdTRUE;
X						*pxHigherPriorityTaskWoken = ( ( BaseType_t ) 1 );
N					}
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N			}
N		}
N		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
X		vPortSetBASEPRI(uxSavedInterruptStatus);
N	}
N
N#endif /* configUSE_TASK_NOTIFICATIONS */
N
N/*-----------------------------------------------------------*/
N
N
N#ifdef FREERTOS_MODULE_TEST
S	#include "tasks_test_access_functions.h"
N#endif
N

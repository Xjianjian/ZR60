; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\stm32f4xx_pwr.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\stm32f4xx_pwr.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\ZR60_v1.0_freeRTOS -I..\..\Lwip\App -I..\..\Lwip\Bsp -I..\..\Lwip\Bsp\LAN8742A -I..\..\Lwip\lwip-1.4.1 -I..\..\Lwip\lwip-1.4.1\port -I..\..\Lwip\lwip-1.4.1\port\arch -I..\..\Lwip\lwip-1.4.1\port\Standalone -I..\..\Lwip\lwip-1.4.1\src\include -I..\..\Lwip\lwip-1.4.1\src\include\ipv4 -I..\..\Lwip\lwip-1.4.1\src\include\lwip -I..\..\Lwip\lwip-1.4.1\src\include\netif -I..\..\Ecal\BtnFltr -I..\..\Ecal\UartComn -I..\..\Ecal\MemIf -I..\..\APP -I..\..\APP\BlackListMng -I..\..\APP\SeverNewsPush -I..\..\APP\NewsPull -I..\..\Ecal -I..\..\Ecal\JsonIf -I..\..\Ecal\Mcu_Init -I..\..\Service -I..\..\Complex -I..\..\Complex\FATFS -I..\..\FreeRTOS\Source\include -I..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\FreeRTOS -I.\RTE\_ZR60 -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=..\..\output\stm32f4xx_pwr.crf ..\..\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_pwr.c]
                          THUMB

                          AREA ||i.PWR_BackupAccessCmd||, CODE, READONLY, ALIGN=2

                  PWR_BackupAccessCmd PROC
;;;182      */
;;;183    void PWR_BackupAccessCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L1.8|
;;;184    {
;;;185      /* Check the parameters */
;;;186      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;187      
;;;188      *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
000002  6208              STR      r0,[r1,#0x20]
;;;189    }
000004  4770              BX       lr
;;;190    
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x420e0000

                          AREA ||i.PWR_BackupRegulatorCmd||, CODE, READONLY, ALIGN=2

                  PWR_BackupRegulatorCmd PROC
;;;422      */
;;;423    void PWR_BackupRegulatorCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L2.8|
;;;424    {
;;;425      /* Check the parameters */
;;;426      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;427    
;;;428      *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)NewState;
000002  f8c100a4          STR      r0,[r1,#0xa4]
;;;429    }
000006  4770              BX       lr
;;;430    
                          ENDP

                  |L2.8|
                          DCD      0x420e0000

                          AREA ||i.PWR_ClearFlag||, CODE, READONLY, ALIGN=2

                  PWR_ClearFlag PROC
;;;1015     */
;;;1016   void PWR_ClearFlag(uint32_t PWR_FLAG)
000000  4902              LDR      r1,|L3.12|
;;;1017   {
;;;1018     /* Check the parameters */
;;;1019     assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
;;;1020     
;;;1021   #if defined (STM32F427_437xx) || defined (STM32F429_439xx)
;;;1022     if (PWR_FLAG != PWR_FLAG_UDRDY)
;;;1023     {
;;;1024       PWR->CR |=  PWR_FLAG << 2;
;;;1025     }
;;;1026     else
;;;1027     {
;;;1028       PWR->CSR |= PWR_FLAG_UDRDY;
;;;1029     }
;;;1030   #endif /* STM32F427_437xx ||  STM32F429_439xx */
;;;1031   
;;;1032   #if defined (STM32F40_41xxx) || defined (STM32F401xx) || defined (STM32F410xx) || defined (STM32F411xE) || defined(STM32F412xG) || defined(STM32F413_423xx)
;;;1033     PWR->CR |=  PWR_FLAG << 2;
000002  680a              LDR      r2,[r1,#0]
000004  ea420080          ORR      r0,r2,r0,LSL #2
000008  6008              STR      r0,[r1,#0]
;;;1034   #endif /* STM32F40_41xxx  || STM32F401xx || STM32F410xx || STM32F411xE || STM32F412xG || STM32F413_423xx */
;;;1035   }
00000a  4770              BX       lr
;;;1036   
                          ENDP

                  |L3.12|
                          DCD      0x40007000

                          AREA ||i.PWR_DeInit||, CODE, READONLY, ALIGN=1

                  PWR_DeInit PROC
;;;167      */
;;;168    void PWR_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;169    {
;;;170      RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
000002  2101              MOVS     r1,#1
000004  070c              LSLS     r4,r1,#28
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;171      RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
00000c  4620              MOV      r0,r4
00000e  e8bd4010          POP      {r4,lr}
000012  2100              MOVS     r1,#0
000014  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
;;;172    }
;;;173    
                          ENDP


                          AREA ||i.PWR_EnterSTANDBYMode||, CODE, READONLY, ALIGN=2

                  PWR_EnterSTANDBYMode PROC
;;;927      */
;;;928    void PWR_EnterSTANDBYMode(void)
000000  4805              LDR      r0,|L5.24|
;;;929    {
;;;930      /* Select STANDBY mode */
;;;931      PWR->CR |= PWR_CR_PDDS;
000002  6801              LDR      r1,[r0,#0]
000004  f0410102          ORR      r1,r1,#2
000008  6001              STR      r1,[r0,#0]
;;;932      
;;;933      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;934      SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
00000a  4804              LDR      r0,|L5.28|
00000c  6801              LDR      r1,[r0,#0]
00000e  f0410104          ORR      r1,r1,#4
000012  6001              STR      r1,[r0,#0]
;;;935      
;;;936      /* This option is used to ensure that store operations are completed */
;;;937    #if defined ( __CC_ARM   )
;;;938      __force_stores();
;;;939    #endif
;;;940      /* Request Wait For Interrupt */
;;;941      __WFI();
000014  bf30              WFI      
;;;942    }
000016  4770              BX       lr
;;;943    
                          ENDP

                  |L5.24|
                          DCD      0x40007000
                  |L5.28|
                          DCD      0xe000ed10

                          AREA ||i.PWR_EnterSTOPMode||, CODE, READONLY, ALIGN=2

                  PWR_EnterSTOPMode PROC
;;;814      */
;;;815    void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
000000  4b0b              LDR      r3,|L6.48|
;;;816    {
000002  b510              PUSH     {r4,lr}
;;;817      uint32_t tmpreg = 0;
;;;818      
;;;819      /* Check the parameters */
;;;820      assert_param(IS_PWR_REGULATOR(PWR_Regulator));
;;;821      assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
;;;822      
;;;823      /* Select the regulator state in STOP mode ---------------------------------*/
;;;824      tmpreg = PWR->CR;
000004  681a              LDR      r2,[r3,#0]
;;;825      /* Clear PDDS and LPDS bits */
;;;826      tmpreg &= CR_DS_MASK;
000006  f6404403          MOV      r4,#0xc03
00000a  43a2              BICS     r2,r2,r4
;;;827      
;;;828      /* Set LPDS, MRLVDS and LPLVDS bits according to PWR_Regulator value */
;;;829      tmpreg |= PWR_Regulator;
00000c  4302              ORRS     r2,r2,r0
;;;830      
;;;831      /* Store the new value */
;;;832      PWR->CR = tmpreg;
00000e  601a              STR      r2,[r3,#0]
;;;833      
;;;834      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;835      SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000010  4808              LDR      r0,|L6.52|
000012  6802              LDR      r2,[r0,#0]
000014  f0420204          ORR      r2,r2,#4
000018  6002              STR      r2,[r0,#0]
;;;836      
;;;837      /* Select STOP mode entry --------------------------------------------------*/
;;;838      if(PWR_STOPEntry == PWR_STOPEntry_WFI)
00001a  2901              CMP      r1,#1
00001c  d005              BEQ      |L6.42|
;;;839      {   
;;;840        /* Request Wait For Interrupt */
;;;841        __WFI();
;;;842      }
;;;843      else
;;;844      {
;;;845        /* Request Wait For Event */
;;;846        __WFE();
00001e  bf20              WFE      
                  |L6.32|
;;;847      }
;;;848      /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;849      SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
000020  6801              LDR      r1,[r0,#0]
000022  f0210104          BIC      r1,r1,#4
000026  6001              STR      r1,[r0,#0]
;;;850    }
000028  bd10              POP      {r4,pc}
                  |L6.42|
00002a  bf30              WFI                            ;841
00002c  e7f8              B        |L6.32|
;;;851    
                          ENDP

00002e  0000              DCW      0x0000
                  |L6.48|
                          DCD      0x40007000
                  |L6.52|
                          DCD      0xe000ed10

                          AREA ||i.PWR_EnterUnderDriveSTOPMode||, CODE, READONLY, ALIGN=2

                  PWR_EnterUnderDriveSTOPMode PROC
;;;878      */
;;;879    void PWR_EnterUnderDriveSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
000000  4b0b              LDR      r3,|L7.48|
;;;880    {
000002  b510              PUSH     {r4,lr}
;;;881      uint32_t tmpreg = 0;
;;;882      
;;;883      /* Check the parameters */
;;;884      assert_param(IS_PWR_REGULATOR_UNDERDRIVE(PWR_Regulator));
;;;885      assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
;;;886      
;;;887      /* Select the regulator state in STOP mode ---------------------------------*/
;;;888      tmpreg = PWR->CR;
000004  681a              LDR      r2,[r3,#0]
;;;889      /* Clear PDDS and LPDS bits */
;;;890      tmpreg &= CR_DS_MASK;
000006  f6404403          MOV      r4,#0xc03
00000a  43a2              BICS     r2,r2,r4
;;;891      
;;;892      /* Set LPDS, MRLUDS and LPLUDS bits according to PWR_Regulator value */
;;;893      tmpreg |= PWR_Regulator;
00000c  4302              ORRS     r2,r2,r0
;;;894      
;;;895      /* Store the new value */
;;;896      PWR->CR = tmpreg;
00000e  601a              STR      r2,[r3,#0]
;;;897      
;;;898      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;899      SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000010  4808              LDR      r0,|L7.52|
000012  6802              LDR      r2,[r0,#0]
000014  f0420204          ORR      r2,r2,#4
000018  6002              STR      r2,[r0,#0]
;;;900      
;;;901      /* Select STOP mode entry --------------------------------------------------*/
;;;902      if(PWR_STOPEntry == PWR_STOPEntry_WFI)
00001a  2901              CMP      r1,#1
00001c  d005              BEQ      |L7.42|
;;;903      {   
;;;904        /* Request Wait For Interrupt */
;;;905        __WFI();
;;;906      }
;;;907      else
;;;908      {
;;;909        /* Request Wait For Event */
;;;910        __WFE();
00001e  bf20              WFE      
                  |L7.32|
;;;911      }
;;;912      /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;913      SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
000020  6801              LDR      r1,[r0,#0]
000022  f0210104          BIC      r1,r1,#4
000026  6001              STR      r1,[r0,#0]
;;;914    }
000028  bd10              POP      {r4,pc}
                  |L7.42|
00002a  bf30              WFI                            ;905
00002c  e7f8              B        |L7.32|
;;;915    
                          ENDP

00002e  0000              DCW      0x0000
                  |L7.48|
                          DCD      0x40007000
                  |L7.52|
                          DCD      0xe000ed10

                          AREA ||i.PWR_FlashPowerDownCmd||, CODE, READONLY, ALIGN=2

                  PWR_FlashPowerDownCmd PROC
;;;668      */
;;;669    void PWR_FlashPowerDownCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L8.8|
;;;670    {
;;;671      /* Check the parameters */
;;;672      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;673    
;;;674      *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)NewState;
000002  6248              STR      r0,[r1,#0x24]
;;;675    }
000004  4770              BX       lr
;;;676    
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      0x420e0000

                          AREA ||i.PWR_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  PWR_GetFlagStatus PROC
;;;987      */
;;;988    FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)
000000  4a03              LDR      r2,|L9.16|
;;;989    {
000002  4601              MOV      r1,r0
;;;990      FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;991      
;;;992      /* Check the parameters */
;;;993      assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
;;;994      
;;;995      if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
000006  6852              LDR      r2,[r2,#4]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L9.14|
;;;996      {
;;;997        bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L9.14|
;;;998      }
;;;999      else
;;;1000     {
;;;1001       bitstatus = RESET;
;;;1002     }
;;;1003     /* Return the flag status */
;;;1004     return bitstatus;
;;;1005   }
00000e  4770              BX       lr
;;;1006   
                          ENDP

                  |L9.16|
                          DCD      0x40007000

                          AREA ||i.PWR_MainRegulatorModeConfig||, CODE, READONLY, ALIGN=2

                  PWR_MainRegulatorModeConfig PROC
;;;444      */
;;;445    void PWR_MainRegulatorModeConfig(uint32_t PWR_Regulator_Voltage)
000000  4a03              LDR      r2,|L10.16|
;;;446    {
;;;447      uint32_t tmpreg = 0;
;;;448    	
;;;449      /* Check the parameters */
;;;450      assert_param(IS_PWR_REGULATOR_VOLTAGE(PWR_Regulator_Voltage));
;;;451    
;;;452      tmpreg = PWR->CR;
000002  6811              LDR      r1,[r2,#0]
;;;453      
;;;454      /* Clear VOS[15:14] bits */
;;;455      tmpreg &= CR_VOS_MASK;
000004  f4214140          BIC      r1,r1,#0xc000
;;;456      
;;;457      /* Set VOS[15:14] bits according to PWR_Regulator_Voltage value */
;;;458      tmpreg |= PWR_Regulator_Voltage;
000008  4301              ORRS     r1,r1,r0
;;;459      
;;;460      /* Store the new value */
;;;461      PWR->CR = tmpreg;
00000a  6011              STR      r1,[r2,#0]
;;;462    }
00000c  4770              BX       lr
;;;463    
                          ENDP

00000e  0000              DCW      0x0000
                  |L10.16|
                          DCD      0x40007000

                          AREA ||i.PWR_OverDriveCmd||, CODE, READONLY, ALIGN=2

                  PWR_OverDriveCmd PROC
;;;479      */
;;;480    void PWR_OverDriveCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L11.8|
;;;481    {
;;;482      /* Check the parameters */
;;;483      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;484      
;;;485      /* Set/Reset the ODEN bit to enable/disable the Over Drive mode */
;;;486      *(__IO uint32_t *) CR_ODEN_BB = (uint32_t)NewState;
000002  6408              STR      r0,[r1,#0x40]
;;;487    }
000004  4770              BX       lr
;;;488    
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      0x420e0000

                          AREA ||i.PWR_OverDriveSWCmd||, CODE, READONLY, ALIGN=2

                  PWR_OverDriveSWCmd PROC
;;;497      */
;;;498    void PWR_OverDriveSWCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L12.8|
;;;499    {
;;;500      /* Check the parameters */
;;;501      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;502    
;;;503      /* Set/Reset the ODSWEN bit to enable/disable the Over Drive switching mode */
;;;504      *(__IO uint32_t *) CR_ODSWEN_BB = (uint32_t)NewState;
000002  6448              STR      r0,[r1,#0x44]
;;;505    }
000004  4770              BX       lr
;;;506    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      0x420e0000

                          AREA ||i.PWR_PVDCmd||, CODE, READONLY, ALIGN=2

                  PWR_PVDCmd PROC
;;;255      */
;;;256    void PWR_PVDCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L13.8|
;;;257    {
;;;258      /* Check the parameters */
;;;259      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;260      
;;;261      *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;
000002  6108              STR      r0,[r1,#0x10]
;;;262    }
000004  4770              BX       lr
;;;263    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x420e0000

                          AREA ||i.PWR_PVDLevelConfig||, CODE, READONLY, ALIGN=2

                  PWR_PVDLevelConfig PROC
;;;230      */
;;;231    void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
000000  4a03              LDR      r2,|L14.16|
;;;232    {
;;;233      uint32_t tmpreg = 0;
;;;234      
;;;235      /* Check the parameters */
;;;236      assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
;;;237      
;;;238      tmpreg = PWR->CR;
000002  6811              LDR      r1,[r2,#0]
;;;239      
;;;240      /* Clear PLS[7:5] bits */
;;;241      tmpreg &= CR_PLS_MASK;
000004  f02101e0          BIC      r1,r1,#0xe0
;;;242      
;;;243      /* Set PLS[7:5] bits according to PWR_PVDLevel value */
;;;244      tmpreg |= PWR_PVDLevel;
000008  4301              ORRS     r1,r1,r0
;;;245      
;;;246      /* Store the new value */
;;;247      PWR->CR = tmpreg;
00000a  6011              STR      r1,[r2,#0]
;;;248    }
00000c  4770              BX       lr
;;;249    
                          ENDP

00000e  0000              DCW      0x0000
                  |L14.16|
                          DCD      0x40007000

                          AREA ||i.PWR_UnderDriveCmd||, CODE, READONLY, ALIGN=2

                  PWR_UnderDriveCmd PROC
;;;524      */
;;;525    void PWR_UnderDriveCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L15.24|
;;;526    {
;;;527      /* Check the parameters */
;;;528      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;529    
;;;530      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;531      {
;;;532        /* Set the UDEN[1:0] bits to enable the Under Drive mode */
;;;533        PWR->CR |= (uint32_t)PWR_CR_UDEN;
;;;534      }
;;;535      else
;;;536      {
;;;537        /* Reset the UDEN[1:0] bits to disable the Under Drive mode */
;;;538        PWR->CR &= (uint32_t)(~PWR_CR_UDEN);
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L15.14|
000008  f4402040          ORR      r0,r0,#0xc0000        ;533
00000c  e001              B        |L15.18|
                  |L15.14|
00000e  f4202040          BIC      r0,r0,#0xc0000
                  |L15.18|
000012  6008              STR      r0,[r1,#0]            ;533
;;;539      }
;;;540    }
000014  4770              BX       lr
;;;541    
                          ENDP

000016  0000              DCW      0x0000
                  |L15.24|
                          DCD      0x40007000

                          AREA ||i.PWR_WakeUpPinCmd||, CODE, READONLY, ALIGN=2

                  PWR_WakeUpPinCmd PROC
;;;290      */
;;;291    void PWR_WakeUpPinCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L16.8|
;;;292    {
;;;293      /* Check the parameters */  
;;;294      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;295    
;;;296      *(__IO uint32_t *) CSR_EWUP_BB = (uint32_t)NewState;
000002  f8c100a0          STR      r0,[r1,#0xa0]
;;;297    }
000006  4770              BX       lr
;;;298    #endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F401xx || STM32F411xE */
                          ENDP

                  |L16.8|
                          DCD      0x420e0000

;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_pwr.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_pwr_c_0c2a8b75____REV16|
#line 138 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_pwr_c_0c2a8b75____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_pwr_c_0c2a8b75____REVSH|
#line 153
|__asm___15_stm32f4xx_pwr_c_0c2a8b75____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_pwr_c_0c2a8b75____RRX|
#line 328
|__asm___15_stm32f4xx_pwr_c_0c2a8b75____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\bsp_wm8978.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\bsp_wm8978.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\ZR60_v1.0_freeRTOS -I..\..\Lwip\App -I..\..\Lwip\Bsp -I..\..\Lwip\Bsp\LAN8742A -I..\..\Lwip\lwip-1.4.1 -I..\..\Lwip\lwip-1.4.1\port -I..\..\Lwip\lwip-1.4.1\port\arch -I..\..\Lwip\lwip-1.4.1\port\Standalone -I..\..\Lwip\lwip-1.4.1\src\include -I..\..\Lwip\lwip-1.4.1\src\include\ipv4 -I..\..\Lwip\lwip-1.4.1\src\include\lwip -I..\..\Lwip\lwip-1.4.1\src\include\netif -I..\..\Ecal\BtnFltr -I..\..\Ecal\UartComn -I..\..\Ecal\MemIf -I..\..\APP -I..\..\APP\BlackListMng -I..\..\APP\SeverNewsPush -I..\..\APP\NewsPull -I..\..\Ecal -I..\..\Ecal\JsonIf -I..\..\Ecal\Mcu_Init -I..\..\Service -I..\..\Complex -I..\..\Complex\FATFS -I..\..\FreeRTOS\Source\include -I..\..\FreeRTOS\Source\portable\RVDS\ARM_CM4F -I..\..\FreeRTOS -I.\RTE\_ZR60 -Id:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.12.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -Id:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=523 -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx --omf_browse=..\..\output\bsp_wm8978.crf ..\..\Complex\wm8978\bsp_wm8978.c]
                          THUMB

                          AREA ||i.DMA1_Stream3_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA1_Stream3_IRQHandler PROC
;;;1165   	*/
;;;1166   void I2Sxext_RX_DMA_STREAM_IRQFUN(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1167   {      
;;;1168   	if(DMA_GetITStatus(I2Sxext_RX_DMA_STREAM,I2Sxext_RX_DMA_IT_TCIF)==SET)////DMA1_Stream3,传输完成标志
000002  4c09              LDR      r4,|L1.40|
000004  4d09              LDR      r5,|L1.44|
000006  4621              MOV      r1,r4
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       DMA_GetITStatus
00000e  2801              CMP      r0,#1
000010  d108              BNE      |L1.36|
;;;1169   	{ 
;;;1170   		DMA_ClearITPendingBit(I2Sxext_RX_DMA_STREAM,I2Sxext_RX_DMA_IT_TCIF);
000012  4621              MOV      r1,r4
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       DMA_ClearITPendingBit
;;;1171       I2S_DMA_RX_Callback();	//执行回调函数,读取数据等操作在这里面处理  		
00001a  4805              LDR      r0,|L1.48|
00001c  6840              LDR      r0,[r0,#4]  ; I2S_DMA_RX_Callback
00001e  e8bd4070          POP      {r4-r6,lr}
000022  4700              BX       r0
                  |L1.36|
;;;1172   	}   											 
;;;1173   }
000024  bd70              POP      {r4-r6,pc}
;;;1174   
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      0x18008000
                  |L1.44|
                          DCD      0x40026058
                  |L1.48|
                          DCD      ||.data||

                          AREA ||i.DMA1_Stream4_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA1_Stream4_IRQHandler PROC
;;;1050   	*/
;;;1051   void I2Sx_TX_DMA_STREAM_IRQFUN(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1052   {      
;;;1053   	if(DMA_GetITStatus(I2Sx_TX_DMA_STREAM,I2Sx_TX_DMA_IT_TCIF)==SET)//DMA传输完成标志
000002  4c09              LDR      r4,|L2.40|
000004  4d09              LDR      r5,|L2.44|
000006  4621              MOV      r1,r4
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       DMA_GetITStatus
00000e  2801              CMP      r0,#1
000010  d108              BNE      |L2.36|
;;;1054   	{ 
;;;1055   		DMA_ClearITPendingBit(I2Sx_TX_DMA_STREAM,I2Sx_TX_DMA_IT_TCIF);//清DMA传输完成标准
000012  4621              MOV      r1,r4
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       DMA_ClearITPendingBit
;;;1056       I2S_DMA_TX_Callback();	//执行回调函数,读取数据等操作在这里面处理  
00001a  4805              LDR      r0,|L2.48|
00001c  6800              LDR      r0,[r0,#0]  ; I2S_DMA_TX_Callback
00001e  e8bd4070          POP      {r4-r6,lr}
000022  4700              BX       r0
                  |L2.36|
;;;1057   	}   											 
;;;1058   } 
000024  bd70              POP      {r4-r6,pc}
;;;1059   /**
                          ENDP

000026  0000              DCW      0x0000
                  |L2.40|
                          DCD      0x20008020
                  |L2.44|
                          DCD      0x40026070
                  |L2.48|
                          DCD      ||.data||

                          AREA ||i.I2S_GPIO_Config||, CODE, READONLY, ALIGN=2

                  I2S_GPIO_Config PROC
;;;865    	*/
;;;866    void I2S_GPIO_Config(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;867    {
;;;868    	GPIO_InitTypeDef GPIO_InitStructure;
;;;869    
;;;870    /**
;;;871    	* I2S总线传输音频数据口线
;;;872    	* WM8978_LRC    -> PB12/I2S2_WS
;;;873    	* WM8978_BCLK   -> PD3/I2S2_CK
;;;874    	* WM8978_ADCDAT -> PC2/I2S2ext_SD
;;;875    	* WM8978_DACDAT -> PI3/I2S2_SD
;;;876    	* WM8978_MCLK   -> PC6/I2S2_MCK
;;;877    	*/	
;;;878    	/* Enable GPIO clock */
;;;879    	RCC_AHB1PeriphClockCmd(WM8978_LRC_GPIO_CLK|WM8978_BCLK_GPIO_CLK| \
000002  2101              MOVS     r1,#1
000004  2006              MOVS     r0,#6
000006  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;880                             WM8978_ADCDAT_GPIO_CLK|WM8978_DACDAT_GPIO_CLK| \
;;;881    	                       WM8978_MCLK_GPIO_CLK, ENABLE);
;;;882    
;;;883    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
00000a  2002              MOVS     r0,#2
00000c  f88d0004          STRB     r0,[sp,#4]
;;;884    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000010  f88d0005          STRB     r0,[sp,#5]
;;;885    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000014  2000              MOVS     r0,#0
000016  f88d0006          STRB     r0,[sp,#6]
;;;886    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
00001a  f88d0007          STRB     r0,[sp,#7]
;;;887    
;;;888    	GPIO_InitStructure.GPIO_Pin = WM8978_LRC_PIN;
00001e  f44f5080          MOV      r0,#0x1000
;;;889    	GPIO_Init(WM8978_LRC_PORT, &GPIO_InitStructure);
000022  4c1e              LDR      r4,|L3.156|
000024  9000              STR      r0,[sp,#0]
000026  4669              MOV      r1,sp
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       GPIO_Init
;;;890    
;;;891    	GPIO_InitStructure.GPIO_Pin = WM8978_BCLK_PIN;
00002e  f44f5100          MOV      r1,#0x2000
;;;892    	GPIO_Init(WM8978_BCLK_PORT, &GPIO_InitStructure);
000032  9100              STR      r1,[sp,#0]
000034  4669              MOV      r1,sp
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       GPIO_Init
;;;893    	
;;;894    	GPIO_InitStructure.GPIO_Pin = WM8978_ADCDAT_PIN;
00003c  f44f4180          MOV      r1,#0x4000
;;;895    	GPIO_Init(WM8978_ADCDAT_PORT, &GPIO_InitStructure);
000040  9100              STR      r1,[sp,#0]
000042  4669              MOV      r1,sp
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       GPIO_Init
;;;896    	
;;;897    	GPIO_InitStructure.GPIO_Pin = WM8978_DACDAT_PIN;
00004a  f44f4100          MOV      r1,#0x8000
;;;898    	GPIO_Init(WM8978_DACDAT_PORT, &GPIO_InitStructure);
00004e  9100              STR      r1,[sp,#0]
000050  4669              MOV      r1,sp
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       GPIO_Init
;;;899    	
;;;900    	GPIO_InitStructure.GPIO_Pin = WM8978_MCLK_PIN;
000058  2040              MOVS     r0,#0x40
;;;901    	GPIO_Init(WM8978_MCLK_PORT, &GPIO_InitStructure);
00005a  4d11              LDR      r5,|L3.160|
00005c  9000              STR      r0,[sp,#0]
00005e  4669              MOV      r1,sp
000060  4628              MOV      r0,r5
000062  f7fffffe          BL       GPIO_Init
;;;902    	
;;;903    	/* Connect pins to I2S peripheral  */
;;;904    	GPIO_PinAFConfig(WM8978_LRC_PORT,    WM8978_LRC_SOURCE,    WM8978_LRC_AF);
000066  2205              MOVS     r2,#5
000068  210c              MOVS     r1,#0xc
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       GPIO_PinAFConfig
;;;905    	GPIO_PinAFConfig(WM8978_BCLK_PORT,   WM8978_BCLK_SOURCE,   WM8978_BCLK_AF);
000070  2205              MOVS     r2,#5
000072  210d              MOVS     r1,#0xd
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       GPIO_PinAFConfig
;;;906    	GPIO_PinAFConfig(WM8978_ADCDAT_PORT, WM8978_ADCDAT_SOURCE, WM8978_ADCDAT_AF);
00007a  2206              MOVS     r2,#6
00007c  210e              MOVS     r1,#0xe
00007e  4620              MOV      r0,r4
000080  f7fffffe          BL       GPIO_PinAFConfig
;;;907    	GPIO_PinAFConfig(WM8978_DACDAT_PORT, WM8978_DACDAT_SOURCE, WM8978_DACDAT_AF);
000084  2205              MOVS     r2,#5
000086  210f              MOVS     r1,#0xf
000088  4620              MOV      r0,r4
00008a  f7fffffe          BL       GPIO_PinAFConfig
;;;908    	GPIO_PinAFConfig(WM8978_MCLK_PORT,   WM8978_MCLK_SOURCE,   WM8978_MCLK_AF);
00008e  2205              MOVS     r2,#5
000090  2106              MOVS     r1,#6
000092  4628              MOV      r0,r5
000094  f7fffffe          BL       GPIO_PinAFConfig
;;;909    }
000098  bd7c              POP      {r2-r6,pc}
;;;910    
                          ENDP

00009a  0000              DCW      0x0000
                  |L3.156|
                          DCD      0x40020400
                  |L3.160|
                          DCD      0x40020800

                          AREA ||i.I2S_Play_Start||, CODE, READONLY, ALIGN=2

                  I2S_Play_Start PROC
;;;1063   	*/
;;;1064   void I2S_Play_Start(void)
000000  2101              MOVS     r1,#1
;;;1065   {   	  
;;;1066   	DMA_Cmd(I2Sx_TX_DMA_STREAM,ENABLE);//开启DMA TX传输,开始播放 	
000002  4801              LDR      r0,|L4.8|
000004  f7ffbffe          B.W      DMA_Cmd
;;;1067   }
;;;1068   
                          ENDP

                  |L4.8|
                          DCD      0x40026070

                          AREA ||i.I2S_Play_Stop||, CODE, READONLY, ALIGN=2

                  I2S_Play_Stop PROC
;;;1073   	*/
;;;1074   void I2S_Play_Stop(void)
000000  2100              MOVS     r1,#0
;;;1075   {   	 
;;;1076   	DMA_Cmd(I2Sx_TX_DMA_STREAM,DISABLE);//关闭DMA TX传输,结束播放 
000002  4801              LDR      r0,|L5.8|
000004  f7ffbffe          B.W      DMA_Cmd
;;;1077   }
;;;1078   
                          ENDP

                  |L5.8|
                          DCD      0x40026070

                          AREA ||i.I2S_Stop||, CODE, READONLY, ALIGN=2

                  I2S_Stop PROC
;;;915    	*/
;;;916    void I2S_Stop(void)
000000  b510              PUSH     {r4,lr}
;;;917    {
;;;918    	DMA_Cmd(I2Sx_TX_DMA_STREAM,DISABLE);//关闭DMA,结束播放
000002  2100              MOVS     r1,#0
000004  4804              LDR      r0,|L6.24|
000006  f7fffffe          BL       DMA_Cmd
;;;919    	DMA_Cmd(I2Sxext_RX_DMA_STREAM,DISABLE);//关闭DMA,结束播放
00000a  4803              LDR      r0,|L6.24|
00000c  2100              MOVS     r1,#0
00000e  e8bd4010          POP      {r4,lr}
000012  3818              SUBS     r0,r0,#0x18
000014  f7ffbffe          B.W      DMA_Cmd
;;;920    }
;;;921    
                          ENDP

                  |L6.24|
                          DCD      0x40026070

                          AREA ||i.I2Sx_Mode_Config||, CODE, READONLY, ALIGN=2

                  I2Sx_Mode_Config PROC
;;;930    	*/
;;;931    void I2Sx_Mode_Config(const uint16_t _usStandard,const uint16_t _usWordLen,const uint32_t _usAudioFreq)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;932    {
000004  4607              MOV      r7,r0
;;;933    	I2S_InitTypeDef I2S_InitStructure;
;;;934    	uint32_t n = 0;
000006  2400              MOVS     r4,#0
000008  4690              MOV      r8,r2                 ;932
00000a  460e              MOV      r6,r1                 ;932
;;;935    	FlagStatus status = RESET;
;;;936    /**
;;;937    	*	For I2S mode, make sure that either:
;;;938    	*		- I2S PLL is configured using the functions RCC_I2SCLKConfig(RCC_I2S2CLKSource_PLLI2S),
;;;939    	*		RCC_PLLI2SCmd(ENABLE) and RCC_GetFlagStatus(RCC_FLAG_PLLI2SRDY).
;;;940    	*/
;;;941    	RCC_I2SCLKConfig(RCC_I2S2CLKSource_PLLI2S);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       RCC_I2SCLKConfig
;;;942    	RCC_PLLI2SCmd(ENABLE);
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       RCC_PLLI2SCmd
;;;943    	for (n = 0; n < 500; n++)
000018  f44f75fa          MOV      r5,#0x1f4
                  |L7.28|
;;;944    	{
;;;945    		status = RCC_GetFlagStatus(RCC_FLAG_PLLI2SRDY);
00001c  203b              MOVS     r0,#0x3b
00001e  f7fffffe          BL       RCC_GetFlagStatus
;;;946    		if (status == 1)break;
000022  2801              CMP      r0,#1
000024  d002              BEQ      |L7.44|
000026  1c64              ADDS     r4,r4,#1
000028  42ac              CMP      r4,r5                 ;943
00002a  d3f7              BCC      |L7.28|
                  |L7.44|
;;;947    	}
;;;948    	/* 打开 I2S2 APB1 时钟 */
;;;949    	RCC_APB1PeriphClockCmd(WM8978_CLK, ENABLE);
00002c  2101              MOVS     r1,#1
00002e  0388              LSLS     r0,r1,#14
000030  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;950    
;;;951    	/* 复位 SPI2 外设到缺省状态 */
;;;952    	SPI_I2S_DeInit(WM8978_I2Sx_SPI);
000034  4c0d              LDR      r4,|L7.108|
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       SPI_I2S_DeInit
;;;953    
;;;954    	/* I2S2 外设配置 */
;;;955    	/* 配置I2S工作模式 */
;;;956    	I2S_InitStructure.I2S_Mode = I2S_Mode_MasterTx;		
00003c  1560              ASRS     r0,r4,#21
00003e  f8ad0000          STRH     r0,[sp,#0]
;;;957    	/* 接口标准 */
;;;958    	I2S_InitStructure.I2S_Standard = _usStandard;			
;;;959    	/* 数据格式，16bit */
;;;960    	I2S_InitStructure.I2S_DataFormat = _usWordLen;			
000042  f8ad6004          STRH     r6,[sp,#4]
;;;961    	/* 主时钟模式 */
;;;962    	I2S_InitStructure.I2S_MCLKOutput = I2S_MCLKOutput_Enable;	
000046  f8ad0006          STRH     r0,[sp,#6]
;;;963    	/* 音频采样频率 */
;;;964    	I2S_InitStructure.I2S_AudioFreq = _usAudioFreq;			
;;;965    	I2S_InitStructure.I2S_CPOL = I2S_CPOL_Low;
00004a  2000              MOVS     r0,#0
00004c  f8ad000c          STRH     r0,[sp,#0xc]
000050  f8ad7002          STRH     r7,[sp,#2]            ;958
000054  f8cd8008          STR      r8,[sp,#8]
;;;966    	I2S_Init(WM8978_I2Sx_SPI, &I2S_InitStructure);
000058  4669              MOV      r1,sp
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       I2S_Init
;;;967    	
;;;968    	/* 使能 SPI2/I2S2 外设 */
;;;969    	I2S_Cmd(WM8978_I2Sx_SPI, ENABLE);
000060  2101              MOVS     r1,#1
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       I2S_Cmd
;;;970    }
000068  e8bd81ff          POP      {r0-r8,pc}
;;;971    
                          ENDP

                  |L7.108|
                          DCD      0x40003800

                          AREA ||i.I2Sx_TX_DMA_Init||, CODE, READONLY, ALIGN=2

                  I2Sx_TX_DMA_Init PROC
;;;978    	*/
;;;979    void I2Sx_TX_DMA_Init(const uint16_t *buffer0,const uint16_t *buffer1,const uint32_t num,int n)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;980    {  
000004  4683              MOV      r11,r0
;;;981    	NVIC_InitTypeDef   NVIC_InitStructure;
;;;982    	DMA_InitTypeDef  DMA_InitStructure;
;;;983    	
;;;984     
;;;985      RCC_AHB1PeriphClockCmd(I2Sx_DMA_CLK,ENABLE);//DMA1时钟使能 
000006  2101              MOVS     r1,#1
000008  b091              SUB      sp,sp,#0x44           ;980
00000a  4698              MOV      r8,r3                 ;980
00000c  4616              MOV      r6,r2                 ;980
00000e  0548              LSLS     r0,r1,#21
000010  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;986    	
;;;987    	DMA_DeInit(I2Sx_TX_DMA_STREAM);
000014  4d30              LDR      r5,|L8.216|
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       DMA_DeInit
                  |L8.28|
;;;988    	while (DMA_GetCmdStatus(I2Sx_TX_DMA_STREAM) != DISABLE){}//等待DMA1_Stream4可配置 
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       DMA_GetCmdStatus
000022  2800              CMP      r0,#0
000024  d1fa              BNE      |L8.28|
;;;989    		
;;;990    	DMA_ClearITPendingBit(I2Sx_TX_DMA_STREAM,DMA_IT_FEIF4|DMA_IT_DMEIF4|DMA_IT_TEIF4|DMA_IT_HTIF4|DMA_IT_TCIF4);//清空DMA1_Stream4上所有中断标志
000026  492d              LDR      r1,|L8.220|
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       DMA_ClearITPendingBit
;;;991    
;;;992      /* 配置 DMA Stream */
;;;993      DMA_InitStructure.DMA_Channel = I2Sx_TX_DMA_CHANNEL;  //通道0 SPIx_TX通道 
;;;994      DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&WM8978_I2Sx_SPI->DR;//外设地址为:(u32)&SPI2->DR
00002e  482c              LDR      r0,|L8.224|
000030  2400              MOVS     r4,#0                 ;993
;;;995      DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)buffer0;//DMA 存储器0地址
000032  e9cd4000          STRD     r4,r0,[sp,#0]
000036  f8cdb008          STR      r11,[sp,#8]
;;;996      DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;//存储器到外设模式
00003a  2040              MOVS     r0,#0x40
00003c  e9cd0603          STRD     r0,r6,[sp,#0xc]
;;;997      DMA_InitStructure.DMA_BufferSize = num;//数据传输量 
;;;998      DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;//外设非增量模式
;;;999      DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;//存储器增量模式
000040  0100              LSLS     r0,r0,#4
000042  e9cd4005          STRD     r4,r0,[sp,#0x14]
;;;1000     DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;//外设数据长度:16位
000046  0040              LSLS     r0,r0,#1
;;;1001     DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;//存储器数据长度：16位 
000048  9007              STR      r0,[sp,#0x1c]
00004a  0080              LSLS     r0,r0,#2
;;;1002     DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;// 使用循环模式 
00004c  9008              STR      r0,[sp,#0x20]
00004e  1140              ASRS     r0,r0,#5
;;;1003     DMA_InitStructure.DMA_Priority = DMA_Priority_High;//高优先级
000050  9009              STR      r0,[sp,#0x24]
000052  0240              LSLS     r0,r0,#9
000054  e9cd040a          STRD     r0,r4,[sp,#0x28]
;;;1004     DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable; //不使用FIFO模式        
;;;1005     DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;
;;;1006     DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;//外设突发单次传输
000058  940c              STR      r4,[sp,#0x30]
;;;1007     DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;//存储器突发单次传输
00005a  940d              STR      r4,[sp,#0x34]
;;;1008     DMA_Init(I2Sx_TX_DMA_STREAM, &DMA_InitStructure);//初始化DMA Stream
00005c  4669              MOV      r1,sp
00005e  4628              MOV      r0,r5
000060  940e              STR      r4,[sp,#0x38]
000062  f7fffffe          BL       DMA_Init
;;;1009   		
;;;1010   	if(n == 1)
;;;1011   	{
;;;1012   		DMA_DoubleBufferModeConfig(I2Sx_TX_DMA_STREAM,(uint32_t)buffer0,DMA_Memory_0);//双缓冲模式配置
;;;1013   		DMA_DoubleBufferModeConfig(I2Sx_TX_DMA_STREAM,(uint32_t)buffer1,DMA_Memory_1);//双缓冲模式配置
;;;1014   	 
;;;1015   		DMA_DoubleBufferModeCmd(I2Sx_TX_DMA_STREAM,ENABLE);//双缓冲模式开启
;;;1016   	 
;;;1017   		DMA_ITConfig(I2Sx_TX_DMA_STREAM,DMA_IT_TC,ENABLE);//开启传输完成中断
;;;1018   		
;;;1019   		SPI_I2S_DMACmd(WM8978_I2Sx_SPI,SPI_I2S_DMAReq_Tx,ENABLE);//SPI2 TX DMA请求使能.
000066  f8dfa078          LDR      r10,|L8.224|
00006a  2601              MOVS     r6,#1                 ;985
;;;1020   		
;;;1021   		NVIC_InitStructure.NVIC_IRQChannel = I2Sx_TX_DMA_STREAM_IRQn; 
00006c  270f              MOVS     r7,#0xf
00006e  f44f2900          MOV      r9,#0x80000           ;1013
000072  f1aa0a0c          SUB      r10,r10,#0xc          ;1019
000076  f1b80f01          CMP      r8,#1                 ;1010
00007a  d020              BEQ      |L8.190|
;;;1022   		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;//抢占优先级1
;;;1023   		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;//子优先级2
;;;1024   		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;//使能外部中断通道
;;;1025   		NVIC_Init(&NVIC_InitStructure);//配置	
;;;1026   	}
;;;1027   	else
;;;1028   	{
;;;1029   			DMA_DoubleBufferModeConfig(I2Sx_TX_DMA_STREAM,(uint32_t)buffer1,DMA_Memory_1);//双缓冲模式配置
00007c  464a              MOV      r2,r9
00007e  4628              MOV      r0,r5
000080  9912              LDR      r1,[sp,#0x48]
000082  f7fffffe          BL       DMA_DoubleBufferModeConfig
;;;1030   		 
;;;1031   			DMA_DoubleBufferModeCmd(I2Sx_TX_DMA_STREAM,DISABLE);//双缓冲模式开启
000086  2100              MOVS     r1,#0
                  |L8.136|
000088  4628              MOV      r0,r5                 ;1015
00008a  f7fffffe          BL       DMA_DoubleBufferModeCmd
00008e  2201              MOVS     r2,#1                 ;1017
000090  2110              MOVS     r1,#0x10              ;1017
000092  4628              MOV      r0,r5                 ;1017
000094  f7fffffe          BL       DMA_ITConfig
000098  2201              MOVS     r2,#1                 ;1019
00009a  2102              MOVS     r1,#2                 ;1019
00009c  4650              MOV      r0,r10                ;1019
00009e  f7fffffe          BL       SPI_I2S_DMACmd
0000a2  f88d703c          STRB     r7,[sp,#0x3c]         ;1021
0000a6  f88d403d          STRB     r4,[sp,#0x3d]         ;1022
0000aa  f88d603e          STRB     r6,[sp,#0x3e]         ;1023
0000ae  f88d603f          STRB     r6,[sp,#0x3f]         ;1024
0000b2  a80f              ADD      r0,sp,#0x3c           ;1025
0000b4  f7fffffe          BL       NVIC_Init
;;;1032   		 
;;;1033   			DMA_ITConfig(I2Sx_TX_DMA_STREAM,DMA_IT_TC,ENABLE);//开启传输完成中断
;;;1034   			
;;;1035   			SPI_I2S_DMACmd(WM8978_I2Sx_SPI,SPI_I2S_DMAReq_Tx,ENABLE);//SPI2 TX DMA请求使能.
;;;1036   			
;;;1037   			NVIC_InitStructure.NVIC_IRQChannel = I2Sx_TX_DMA_STREAM_IRQn; 
;;;1038   			NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;//抢占优先级1
;;;1039   			NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;//子优先级2
;;;1040   			NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;//使能外部中断通道
;;;1041   			NVIC_Init(&NVIC_InitStructure);//配置		
;;;1042   	}
;;;1043   
;;;1044   }
0000b8  b015              ADD      sp,sp,#0x54
0000ba  e8bd8ff0          POP      {r4-r11,pc}
                  |L8.190|
0000be  2200              MOVS     r2,#0                 ;1012
0000c0  4659              MOV      r1,r11                ;1012
0000c2  4628              MOV      r0,r5                 ;1012
0000c4  f7fffffe          BL       DMA_DoubleBufferModeConfig
0000c8  464a              MOV      r2,r9                 ;1013
0000ca  4628              MOV      r0,r5                 ;1013
0000cc  9912              LDR      r1,[sp,#0x48]         ;1013
0000ce  f7fffffe          BL       DMA_DoubleBufferModeConfig
0000d2  2101              MOVS     r1,#1                 ;1015
0000d4  e7d8              B        |L8.136|
;;;1045   
                          ENDP

0000d6  0000              DCW      0x0000
                  |L8.216|
                          DCD      0x40026070
                  |L8.220|
                          DCD      0xa000f03d
                  |L8.224|
                          DCD      0x4000380c

                          AREA ||i.I2Sxext_Mode_Config||, CODE, READONLY, ALIGN=2

                  I2Sxext_Mode_Config PROC
;;;1088   	*/
;;;1089   void I2Sxext_Mode_Config(const uint16_t _usStandard, const uint16_t _usWordLen,const uint32_t _usAudioFreq)
000000  b51f              PUSH     {r0-r4,lr}
;;;1090   {
;;;1091   	I2S_InitTypeDef I2Sext_InitStructure;
;;;1092   
;;;1093   	/* I2S2 外设配置 */
;;;1094   	I2Sext_InitStructure.I2S_Mode = I2S_Mode_MasterTx;			/* 配置I2S工作模式 */
000002  f44f7300          MOV      r3,#0x200
000006  f8ad3000          STRH     r3,[sp,#0]
;;;1095   	I2Sext_InitStructure.I2S_Standard = _usStandard;			/* 接口标准 */
00000a  f8ad0002          STRH     r0,[sp,#2]
;;;1096   	I2Sext_InitStructure.I2S_DataFormat = _usWordLen;			/* 数据格式，16bit */
00000e  f8ad1004          STRH     r1,[sp,#4]
;;;1097   	I2Sext_InitStructure.I2S_MCLKOutput = I2S_MCLKOutput_Enable;	/* 主时钟模式 */
;;;1098   	I2Sext_InitStructure.I2S_AudioFreq = _usAudioFreq;			/* 音频采样频率 */
;;;1099   	I2Sext_InitStructure.I2S_CPOL = I2S_CPOL_Low;
000012  2000              MOVS     r0,#0
;;;1100   	
;;;1101   	I2S_FullDuplexConfig(WM8978_I2Sx_ext, &I2Sext_InitStructure);
000014  4c07              LDR      r4,|L9.52|
000016  f8ad000c          STRH     r0,[sp,#0xc]          ;1099
00001a  f8ad3006          STRH     r3,[sp,#6]            ;1097
00001e  9202              STR      r2,[sp,#8]            ;1099
000020  4669              MOV      r1,sp
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       I2S_FullDuplexConfig
;;;1102   	
;;;1103   	/* 使能 SPI2/I2S2 外设 */
;;;1104   	I2S_Cmd(WM8978_I2Sx_ext, ENABLE);
000028  2101              MOVS     r1,#1
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       I2S_Cmd
;;;1105   }
000030  bd1f              POP      {r0-r4,pc}
;;;1106   
                          ENDP

000032  0000              DCW      0x0000
                  |L9.52|
                          DCD      0x40003400

                          AREA ||i.I2Sxext_RX_DMA_Init||, CODE, READONLY, ALIGN=2

                  I2Sxext_RX_DMA_Init PROC
;;;1113   	*/
;;;1114   void I2Sxext_RX_DMA_Init(const uint16_t *buffer0,const uint16_t *buffer1,const uint32_t num)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1115   {  
000004  4688              MOV      r8,r1
000006  4605              MOV      r5,r0
;;;1116   	NVIC_InitTypeDef   NVIC_InitStructure;
;;;1117   	DMA_InitTypeDef  DMA_InitStructure;	
;;;1118    
;;;1119     RCC_AHB1PeriphClockCmd(I2Sx_DMA_CLK,ENABLE);//DMA1时钟使能 
000008  2101              MOVS     r1,#1
00000a  b090              SUB      sp,sp,#0x40           ;1115
00000c  4616              MOV      r6,r2                 ;1115
00000e  0548              LSLS     r0,r1,#21
000010  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;1120   	
;;;1121   	DMA_DeInit(I2Sxext_RX_DMA_STREAM);
000014  4f29              LDR      r7,|L10.188|
000016  4638              MOV      r0,r7
000018  f7fffffe          BL       DMA_DeInit
                  |L10.28|
;;;1122   	while (DMA_GetCmdStatus(I2Sxext_RX_DMA_STREAM) != DISABLE){}//等待DMA1_Stream3可配置 
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       DMA_GetCmdStatus
000022  2800              CMP      r0,#0
000024  d1fa              BNE      |L10.28|
;;;1123   		
;;;1124   	DMA_ClearITPendingBit(I2Sxext_RX_DMA_STREAM,DMA_IT_FEIF3|DMA_IT_DMEIF3|DMA_IT_TEIF3|DMA_IT_HTIF3|DMA_IT_TCIF3);//清空DMA1_Stream3上所有中断标志
000026  4926              LDR      r1,|L10.192|
000028  4638              MOV      r0,r7
00002a  f7fffffe          BL       DMA_ClearITPendingBit
;;;1125   
;;;1126     /* 配置 DMA Stream */
;;;1127     DMA_InitStructure.DMA_Channel = I2Sxext_RX_DMA_CHANNEL;  //通道0 SPIx_TX通道 
00002e  f04f60c0          MOV      r0,#0x6000000
;;;1128     DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&WM8978_I2Sx_ext->DR;//外设地址为:(u32)&SPI2->DR
000032  9000              STR      r0,[sp,#0]
;;;1129     DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)buffer0;//DMA 存储器0地址
;;;1130     DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;//外设到存储器模式
000034  2400              MOVS     r4,#0
000036  4823              LDR      r0,|L10.196|
;;;1131     DMA_InitStructure.DMA_BufferSize = num;//数据传输量 
000038  e9cd5402          STRD     r5,r4,[sp,#8]
00003c  9001              STR      r0,[sp,#4]
00003e  9604              STR      r6,[sp,#0x10]
;;;1132     DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;//外设非增量模式
;;;1133     DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;//存储器增量模式
000040  1500              ASRS     r0,r0,#20
000042  e9cd4005          STRD     r4,r0,[sp,#0x14]
;;;1134     DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;//外设数据长度:16位
000046  0040              LSLS     r0,r0,#1
;;;1135     DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;//存储器数据长度：16位 
000048  9007              STR      r0,[sp,#0x1c]
00004a  0080              LSLS     r0,r0,#2
;;;1136     DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;// 使用循环模式 
00004c  9008              STR      r0,[sp,#0x20]
00004e  1140              ASRS     r0,r0,#5
;;;1137     DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;//中等优先级
000050  9009              STR      r0,[sp,#0x24]
000052  0200              LSLS     r0,r0,#8
000054  e9cd040a          STRD     r0,r4,[sp,#0x28]
;;;1138     DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable; //不使用FIFO模式        
;;;1139     DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;
;;;1140     DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;//外设突发单次传输
000058  940c              STR      r4,[sp,#0x30]
;;;1141     DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;//存储器突发单次传输
00005a  940d              STR      r4,[sp,#0x34]
;;;1142     DMA_Init(I2Sxext_RX_DMA_STREAM, &DMA_InitStructure);//初始化DMA Stream
00005c  4669              MOV      r1,sp
00005e  4638              MOV      r0,r7
000060  940e              STR      r4,[sp,#0x38]
000062  f7fffffe          BL       DMA_Init
;;;1143   		
;;;1144   	DMA_DoubleBufferModeConfig(I2Sxext_RX_DMA_STREAM,(uint32_t)buffer0,DMA_Memory_0);//双缓冲模式配置
000066  2200              MOVS     r2,#0
000068  4629              MOV      r1,r5
00006a  4638              MOV      r0,r7
00006c  f7fffffe          BL       DMA_DoubleBufferModeConfig
;;;1145   	DMA_DoubleBufferModeConfig(I2Sxext_RX_DMA_STREAM,(uint32_t)buffer1,DMA_Memory_1);//双缓冲模式配置
000070  f44f2200          MOV      r2,#0x80000
000074  4641              MOV      r1,r8
000076  4638              MOV      r0,r7
000078  f7fffffe          BL       DMA_DoubleBufferModeConfig
;;;1146    
;;;1147     DMA_DoubleBufferModeCmd(I2Sxext_RX_DMA_STREAM,ENABLE);//双缓冲模式开启
00007c  2101              MOVS     r1,#1
00007e  4638              MOV      r0,r7
000080  f7fffffe          BL       DMA_DoubleBufferModeCmd
;;;1148    
;;;1149     DMA_ITConfig(I2Sxext_RX_DMA_STREAM,DMA_IT_TC,ENABLE);//开启传输完成中断
000084  2201              MOVS     r2,#1
000086  2110              MOVS     r1,#0x10
000088  4638              MOV      r0,r7
00008a  f7fffffe          BL       DMA_ITConfig
;;;1150   	
;;;1151    	SPI_I2S_DMACmd(WM8978_I2Sx_ext,SPI_I2S_DMAReq_Rx,ENABLE);//SPI2 RX DMA请求使能.
00008e  480d              LDR      r0,|L10.196|
000090  2201              MOVS     r2,#1
000092  4611              MOV      r1,r2
000094  380c              SUBS     r0,r0,#0xc
000096  f7fffffe          BL       SPI_I2S_DMACmd
;;;1152   	
;;;1153   	NVIC_InitStructure.NVIC_IRQChannel = I2Sxext_RX_DMA_STREAM_IRQn; 
00009a  200e              MOVS     r0,#0xe
00009c  f88d003c          STRB     r0,[sp,#0x3c]
;;;1154     NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;//抢占优先级0
0000a0  f88d403d          STRB     r4,[sp,#0x3d]
;;;1155     NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;//子优先级2
0000a4  2002              MOVS     r0,#2
0000a6  f88d003e          STRB     r0,[sp,#0x3e]
;;;1156     NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;//使能外部中断通道
0000aa  2001              MOVS     r0,#1
0000ac  f88d003f          STRB     r0,[sp,#0x3f]
;;;1157     NVIC_Init(&NVIC_InitStructure);//配置
0000b0  a80f              ADD      r0,sp,#0x3c
0000b2  f7fffffe          BL       NVIC_Init
;;;1158   }
0000b6  b010              ADD      sp,sp,#0x40
0000b8  e8bd81f0          POP      {r4-r8,pc}
;;;1159   
                          ENDP

                  |L10.188|
                          DCD      0x40026058
                  |L10.192|
                          DCD      0x9f40f000
                  |L10.196|
                          DCD      0x4000340c

                          AREA ||i.I2Sxext_Recorde_Start||, CODE, READONLY, ALIGN=2

                  I2Sxext_Recorde_Start PROC
;;;1179   	*/
;;;1180   void I2Sxext_Recorde_Start(void)
000000  2101              MOVS     r1,#1
;;;1181   {   	  
;;;1182   	DMA_Cmd(I2Sxext_RX_DMA_STREAM,ENABLE);//开启DMA RX传输,开始录音
000002  4801              LDR      r0,|L11.8|
000004  f7ffbffe          B.W      DMA_Cmd
;;;1183   }
;;;1184   
                          ENDP

                  |L11.8|
                          DCD      0x40026058

                          AREA ||i.I2Sxext_Recorde_Stop||, CODE, READONLY, ALIGN=2

                  I2Sxext_Recorde_Stop PROC
;;;1189   	*/
;;;1190   void I2Sxext_Recorde_Stop(void)
000000  2100              MOVS     r1,#0
;;;1191   {   	 
;;;1192   	DMA_Cmd(I2Sxext_RX_DMA_STREAM,DISABLE);//关闭DMA RX传输,结束录音
000002  4801              LDR      r0,|L12.8|
000004  f7ffbffe          B.W      DMA_Cmd
;;;1193   }
;;;1194   
                          ENDP

                  |L12.8|
                          DCD      0x40026058

                          AREA ||i.wm8978_CfgAudioIF||, CODE, READONLY, ALIGN=1

                  wm8978_CfgAudioIF PROC
;;;338    	*/
;;;339    void wm8978_CfgAudioIF(uint16_t _usStandard, uint8_t _ucWordLen)
000000  b510              PUSH     {r4,lr}
;;;340    {
000002  460a              MOV      r2,r1
;;;341    	uint16_t usReg;
;;;342    
;;;343    	/* WM8978(V4.5_2011).pdf 73页，寄存器列表 */
;;;344    
;;;345    	/*	REG R4, 音频接口控制寄存器
;;;346    		B8		BCP	 = X, BCLK极性，0表示正常，1表示反相
;;;347    		B7		LRCP = x, LRC时钟极性，0表示正常，1表示反相
;;;348    		B6:5	WL = x， 字长，00=16bit，01=20bit，10=24bit，11=32bit （右对齐模式只能操作在最大24bit)
;;;349    		B4:3	FMT = x，音频数据格式，00=右对齐，01=左对齐，10=I2S格式，11=PCM
;;;350    		B2		DACLRSWAP = x, 控制DAC数据出现在LRC时钟的左边还是右边
;;;351    		B1 		ADCLRSWAP = x，控制ADC数据出现在LRC时钟的左边还是右边
;;;352    		B0		MONO	= 0，0表示立体声，1表示单声道，仅左声道有效
;;;353    	*/
;;;354    	usReg = 0;
000004  2100              MOVS     r1,#0
000006  b148              CBZ      r0,|L13.28|
;;;355    	if (_usStandard == I2S_Standard_Phillips)	/* I2S飞利浦标准 */
;;;356    	{
;;;357    		usReg |= (2 << 3);
;;;358    	}
;;;359    	else if (_usStandard == I2S_Standard_MSB)	/* MSB对齐标准(左对齐) */
000008  2810              CMP      r0,#0x10
00000a  d009              BEQ      |L13.32|
;;;360    	{
;;;361    		usReg |= (1 << 3);
;;;362    	}
;;;363    	else if (_usStandard == I2S_Standard_LSB)	/* LSB对齐标准(右对齐) */
00000c  2820              CMP      r0,#0x20
00000e  d000              BEQ      |L13.18|
;;;364    	{
;;;365    		usReg |= (0 << 3);
;;;366    	}
;;;367    	else	/* PCM标准(16位通道帧上带长或短帧同步或者16位数据帧扩展为32位通道帧) */
;;;368    	{
;;;369    		usReg |= (3 << 3);;
000010  2118              MOVS     r1,#0x18
                  |L13.18|
;;;370    	}
;;;371    
;;;372    	if (_ucWordLen == 24)
000012  2a18              CMP      r2,#0x18
000014  d006              BEQ      |L13.36|
;;;373    	{
;;;374    		usReg |= (2 << 5);
;;;375    	}
;;;376    	else if (_ucWordLen == 32)
000016  2a20              CMP      r2,#0x20
000018  d007              BEQ      |L13.42|
00001a  e008              B        |L13.46|
                  |L13.28|
00001c  2110              MOVS     r1,#0x10              ;357
00001e  e7f8              B        |L13.18|
                  |L13.32|
000020  2108              MOVS     r1,#8                 ;361
000022  e7f6              B        |L13.18|
                  |L13.36|
000024  f0410140          ORR      r1,r1,#0x40           ;374
000028  e001              B        |L13.46|
                  |L13.42|
;;;377    	{
;;;378    		usReg |= (3 << 5);
00002a  f0410160          ORR      r1,r1,#0x60
                  |L13.46|
;;;379    	}
;;;380    	else
;;;381    	{
;;;382    		usReg |= (0 << 5);		/* 16bit */
;;;383    	}
;;;384    	wm8978_WriteReg(4, usReg);
00002e  2004              MOVS     r0,#4
000030  f7fffffe          BL       wm8978_WriteReg
;;;385    
;;;386    
;;;387    	/*
;;;388    		R6，时钟产生控制寄存器
;;;389    		MS = 0,  WM8978被动时钟，由MCU提供MCLK时钟
;;;390    	*/
;;;391    	wm8978_WriteReg(6, 0x000);
000034  2100              MOVS     r1,#0
000036  e8bd4010          POP      {r4,lr}
00003a  2006              MOVS     r0,#6
00003c  f7ffbffe          B.W      wm8978_WriteReg
;;;392    }
;;;393    
                          ENDP


                          AREA ||i.wm8978_CfgAudioPath||, CODE, READONLY, ALIGN=1

                  wm8978_CfgAudioPath PROC
;;;402    	*/
;;;403    void wm8978_CfgAudioPath(uint16_t _InPath, uint16_t _OutPath)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;404    {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;405    	uint16_t usReg;
;;;406    
;;;407    	/* 查看WM8978数据手册的 REGISTER MAP 章节， 第89页 */
;;;408    
;;;409    	if ((_InPath == IN_PATH_OFF) && (_OutPath == OUT_PATH_OFF))
000008  4328              ORRS     r0,r0,r5
00000a  d04f              BEQ      |L14.172|
;;;410    	{
;;;411    		wm8978_PowerDown();
;;;412    		return;
;;;413    	}
;;;414    
;;;415    	/*
;;;416    		R1 寄存器 Power manage 1
;;;417    		Bit8    BUFDCOPEN,  Output stage 1.5xAVDD/2 driver enable
;;;418     		Bit7    OUT4MIXEN, OUT4 mixer enable
;;;419    		Bit6    OUT3MIXEN, OUT3 mixer enable
;;;420    		Bit5    PLLEN	.不用
;;;421    		Bit4    MICBEN	,Microphone Bias Enable (MIC偏置电路使能)
;;;422    		Bit3    BIASEN	,Analogue amplifier bias control 必须设置为1模拟放大器才工作
;;;423    		Bit2    BUFIOEN , Unused input/output tie off buffer enable
;;;424    		Bit1:0  VMIDSEL, 必须设置为非00值模拟放大器才工作
;;;425    	*/
;;;426    	usReg = (1 << 3) | (3 << 0);
00000c  210b              MOVS     r1,#0xb
;;;427    	if (_OutPath & OUT3_4_ON) 	/* OUT3和OUT4使能输出到GSM模块 */
00000e  0728              LSLS     r0,r5,#28
000010  d500              BPL      |L14.20|
;;;428    	{
;;;429    		usReg |= ((1 << 7) | (1 << 6));
000012  21cb              MOVS     r1,#0xcb
                  |L14.20|
;;;430    	}
;;;431    	if ((_InPath & MIC_LEFT_ON) || (_InPath & MIC_RIGHT_ON))
000014  07a0              LSLS     r0,r4,#30
000016  d001              BEQ      |L14.28|
;;;432    	{
;;;433    		usReg |= (1 << 4);
000018  f0410110          ORR      r1,r1,#0x10
                  |L14.28|
;;;434    	}
;;;435    	wm8978_WriteReg(1, usReg);	/* 写寄存器 */
00001c  2001              MOVS     r0,#1
00001e  f7fffffe          BL       wm8978_WriteReg
;;;436    
;;;437    	/*
;;;438    		R2 寄存器 Power manage 2
;;;439    		Bit8	ROUT1EN,	ROUT1 output enable 耳机右声道输出使能
;;;440    		Bit7	LOUT1EN,	LOUT1 output enable 耳机左声道输出使能
;;;441    		Bit6	SLEEP, 		0 = Normal device operation   1 = Residual current reduced in device standby mode
;;;442    		Bit5	BOOSTENR,	Right channel Input BOOST enable 输入通道自举电路使能. 用到PGA放大功能时必须使能
;;;443    		Bit4	BOOSTENL,	Left channel Input BOOST enable
;;;444    		Bit3	INPGAENR,	Right channel input PGA enable 右声道输入PGA使能
;;;445    		Bit2	INPGAENL,	Left channel input PGA enable
;;;446    		Bit1	ADCENR,		Enable ADC right channel
;;;447    		Bit0	ADCENL,		Enable ADC left channel
;;;448    	*/
;;;449    	usReg = 0;
000022  2100              MOVS     r1,#0
;;;450    	if (_OutPath & EAR_LEFT_ON)
000024  07e8              LSLS     r0,r5,#31
000026  d000              BEQ      |L14.42|
;;;451    	{
;;;452    		usReg |= (1 << 7);
000028  2180              MOVS     r1,#0x80
                  |L14.42|
;;;453    	}
;;;454    	if (_OutPath & EAR_RIGHT_ON)
00002a  07a8              LSLS     r0,r5,#30
00002c  d501              BPL      |L14.50|
;;;455    	{
;;;456    		usReg |= (1 << 8);
00002e  f4417180          ORR      r1,r1,#0x100
                  |L14.50|
;;;457    	}
;;;458    	if (_InPath & MIC_LEFT_ON)
000032  07e0              LSLS     r0,r4,#31
000034  d001              BEQ      |L14.58|
;;;459    	{
;;;460    		usReg |= ((1 << 4) | (1 << 2));
000036  f0410114          ORR      r1,r1,#0x14
                  |L14.58|
;;;461    	}
;;;462    	if (_InPath & MIC_RIGHT_ON)
00003a  07a0              LSLS     r0,r4,#30
00003c  d501              BPL      |L14.66|
;;;463    	{
;;;464    		usReg |= ((1 << 5) | (1 << 3));
00003e  f0410128          ORR      r1,r1,#0x28
                  |L14.66|
;;;465    	}
;;;466    	if (_InPath & LINE_ON)
000042  0760              LSLS     r0,r4,#29
000044  d501              BPL      |L14.74|
;;;467    	{
;;;468    		usReg |= ((1 << 4) | (1 << 5));
000046  f0410130          ORR      r1,r1,#0x30
                  |L14.74|
;;;469    	}
;;;470    	if (_InPath & MIC_RIGHT_ON)
00004a  07a0              LSLS     r0,r4,#30
00004c  d501              BPL      |L14.82|
;;;471    	{
;;;472    		usReg |= ((1 << 5) | (1 << 3));
00004e  f0410128          ORR      r1,r1,#0x28
                  |L14.82|
;;;473    	}
;;;474    	if (_InPath & ADC_ON)
000052  06a0              LSLS     r0,r4,#26
000054  d501              BPL      |L14.90|
;;;475    	{
;;;476    		usReg |= ((1 << 1) | (1 << 0));
000056  f0410103          ORR      r1,r1,#3
                  |L14.90|
;;;477    	}
;;;478    	wm8978_WriteReg(2, usReg);	/* 写寄存器 */
00005a  2002              MOVS     r0,#2
00005c  f7fffffe          BL       wm8978_WriteReg
;;;479    
;;;480    	/*
;;;481    		R3 寄存器 Power manage 3
;;;482    		Bit8	OUT4EN,		OUT4 enable
;;;483    		Bit7	OUT3EN,		OUT3 enable
;;;484    		Bit6	LOUT2EN,	LOUT2 output enable
;;;485    		Bit5	ROUT2EN,	ROUT2 output enable
;;;486    		Bit4	0,
;;;487    		Bit3	RMIXEN,		Right mixer enable
;;;488    		Bit2	LMIXEN,		Left mixer enable
;;;489    		Bit1	DACENR,		Right channel DAC enable
;;;490    		Bit0	DACENL,		Left channel DAC enable
;;;491    	*/
;;;492    	usReg = 0;
000060  2100              MOVS     r1,#0
;;;493    	if (_OutPath & OUT3_4_ON)
000062  0728              LSLS     r0,r5,#28
000064  d501              BPL      |L14.106|
;;;494    	{
;;;495    		usReg |= ((1 << 8) | (1 << 7));
000066  f44f71c0          MOV      r1,#0x180
                  |L14.106|
;;;496    	}
;;;497    	if (_OutPath & SPK_ON)
00006a  0768              LSLS     r0,r5,#29
00006c  d501              BPL      |L14.114|
;;;498    	{
;;;499    		usReg |= ((1 << 6) | (1 << 5));
00006e  f0410160          ORR      r1,r1,#0x60
                  |L14.114|
;;;500    	}
;;;501    	if (_OutPath != OUT_PATH_OFF)
000072  b10d              CBZ      r5,|L14.120|
;;;502    	{
;;;503    		usReg |= ((1 << 3) | (1 << 2));
000074  f041010c          ORR      r1,r1,#0xc
                  |L14.120|
;;;504    	}
;;;505    	if (_InPath & DAC_ON)
000078  06e0              LSLS     r0,r4,#27
00007a  d501              BPL      |L14.128|
;;;506    	{
;;;507    		usReg |= ((1 << 1) | (1 << 0));
00007c  f0410103          ORR      r1,r1,#3
                  |L14.128|
;;;508    	}
;;;509    	wm8978_WriteReg(3, usReg);	/* 写寄存器 */
000080  2003              MOVS     r0,#3
000082  f7fffffe          BL       wm8978_WriteReg
;;;510    
;;;511    	/*
;;;512    		R44 寄存器 Input ctrl
;;;513    
;;;514    		Bit8	MBVSEL, 		Microphone Bias Voltage Control   0 = 0.9 * AVDD   1 = 0.6 * AVDD
;;;515    		Bit7	0
;;;516    		Bit6	R2_2INPPGA,		Connect R2 pin to right channel input PGA positive terminal
;;;517    		Bit5	RIN2INPPGA,		Connect RIN pin to right channel input PGA negative terminal
;;;518    		Bit4	RIP2INPPGA,		Connect RIP pin to right channel input PGA amplifier positive terminal
;;;519    		Bit3	0
;;;520    		Bit2	L2_2INPPGA,		Connect L2 pin to left channel input PGA positive terminal
;;;521    		Bit1	LIN2INPPGA,		Connect LIN pin to left channel input PGA negative terminal
;;;522    		Bit0	LIP2INPPGA,		Connect LIP pin to left channel input PGA amplifier positive terminal
;;;523    	*/
;;;524    	usReg = 0 << 8;
000086  2100              MOVS     r1,#0
;;;525    	if (_InPath & LINE_ON)
000088  0760              LSLS     r0,r4,#29
00008a  d500              BPL      |L14.142|
;;;526    	{
;;;527    		usReg |= ((1 << 6) | (1 << 2));
00008c  2144              MOVS     r1,#0x44
                  |L14.142|
;;;528    	}
;;;529    	if (_InPath & MIC_RIGHT_ON)
00008e  07a0              LSLS     r0,r4,#30
000090  d501              BPL      |L14.150|
;;;530    	{
;;;531    		usReg |= ((1 << 5) | (1 << 4));
000092  f0410130          ORR      r1,r1,#0x30
                  |L14.150|
;;;532    	}
;;;533    	if (_InPath & MIC_LEFT_ON)
000096  07e0              LSLS     r0,r4,#31
000098  d001              BEQ      |L14.158|
;;;534    	{
;;;535    		usReg |= ((1 << 1) | (1 << 0));
00009a  f0410103          ORR      r1,r1,#3
                  |L14.158|
;;;536    	}
;;;537    	wm8978_WriteReg(44, usReg);	/* 写寄存器 */
00009e  202c              MOVS     r0,#0x2c
0000a0  f7fffffe          BL       wm8978_WriteReg
;;;538    
;;;539    
;;;540    	/*
;;;541    		R14 寄存器 ADC Control
;;;542    		设置高通滤波器（可选的） WM8978(V4.5_2011).pdf 31 32页,
;;;543    		Bit8 	HPFEN,	High Pass Filter Enable高通滤波器使能，0表示禁止，1表示使能
;;;544    		BIt7 	HPFAPP,	Select audio mode or application mode 选择音频模式或应用模式，0表示音频模式，
;;;545    		Bit6:4	HPFCUT，Application mode cut-off frequency  000-111选择应用模式的截止频率
;;;546    		Bit3 	ADCOSR,	ADC oversample rate select: 0=64x (lower power) 1=128x (best performance)
;;;547    		Bit2   	0
;;;548    		Bit1 	ADC right channel polarity adjust:  0=normal  1=inverted
;;;549    		Bit0 	ADC left channel polarity adjust:  0=normal 1=inverted
;;;550    	*/
;;;551    	if (_InPath & ADC_ON)
0000a4  06a0              LSLS     r0,r4,#26
0000a6  d505              BPL      |L14.180|
;;;552    	{
;;;553    		usReg = (1 << 3) | (0 << 8) | (4 << 0);		/* 禁止ADC高通滤波器, 设置截至频率 */
0000a8  210c              MOVS     r1,#0xc
0000aa  e004              B        |L14.182|
                  |L14.172|
0000ac  e8bd41f0          POP      {r4-r8,lr}
0000b0  f7ffbffe          B.W      wm8978_Reset
                  |L14.180|
;;;554    	}
;;;555    	else
;;;556    	{
;;;557    		usReg = 0;
0000b4  2100              MOVS     r1,#0
                  |L14.182|
;;;558    	}
;;;559    	wm8978_WriteReg(14, usReg);	/* 写寄存器 */
0000b6  200e              MOVS     r0,#0xe
0000b8  f7fffffe          BL       wm8978_WriteReg
;;;560    
;;;561    	/* 设置陷波滤波器（notch filter），主要用于抑制话筒声波正反馈，避免啸叫.  暂时关闭
;;;562    		R27，R28，R29，R30 用于控制限波滤波器，WM8978(V4.5_2011).pdf 33页
;;;563    		R7的 Bit7 NFEN = 0 表示禁止，1表示使能
;;;564    	*/
;;;565    	if (_InPath & ADC_ON)
0000bc  06a0              LSLS     r0,r4,#26
0000be  d510              BPL      |L14.226|
;;;566    	{
;;;567    		usReg = (0 << 7);
0000c0  2600              MOVS     r6,#0
;;;568    		wm8978_WriteReg(27, usReg);	/* 写寄存器 */
0000c2  4631              MOV      r1,r6
0000c4  201b              MOVS     r0,#0x1b
0000c6  f7fffffe          BL       wm8978_WriteReg
;;;569    		usReg = 0;
;;;570    		wm8978_WriteReg(28, usReg);	/* 写寄存器,填0，因为已经禁止，所以也可不做 */
0000ca  4631              MOV      r1,r6
0000cc  201c              MOVS     r0,#0x1c
0000ce  f7fffffe          BL       wm8978_WriteReg
;;;571    		wm8978_WriteReg(29, usReg);	/* 写寄存器,填0，因为已经禁止，所以也可不做 */
0000d2  4631              MOV      r1,r6
0000d4  201d              MOVS     r0,#0x1d
0000d6  f7fffffe          BL       wm8978_WriteReg
;;;572    		wm8978_WriteReg(30, usReg);	/* 写寄存器,填0，因为已经禁止，所以也可不做 */
0000da  4631              MOV      r1,r6
0000dc  201e              MOVS     r0,#0x1e
0000de  f7fffffe          BL       wm8978_WriteReg
                  |L14.226|
;;;573    	}
;;;574    
;;;575    	/* 自动增益控制 ALC, R32  - 34  WM8978(V4.5_2011).pdf 36页 */
;;;576    	{
;;;577    		usReg = 0;		/* 禁止自动增益控制 */
0000e2  2600              MOVS     r6,#0
;;;578    		wm8978_WriteReg(32, usReg);
0000e4  4631              MOV      r1,r6
0000e6  2020              MOVS     r0,#0x20
0000e8  f7fffffe          BL       wm8978_WriteReg
;;;579    		wm8978_WriteReg(33, usReg);
0000ec  4631              MOV      r1,r6
0000ee  2021              MOVS     r0,#0x21
0000f0  f7fffffe          BL       wm8978_WriteReg
;;;580    		wm8978_WriteReg(34, usReg);
0000f4  4631              MOV      r1,r6
0000f6  2022              MOVS     r0,#0x22
0000f8  f7fffffe          BL       wm8978_WriteReg
;;;581    	}
;;;582    
;;;583    	/*  R35  ALC Noise Gate Control
;;;584    		Bit3	NGATEN, Noise gate function enable
;;;585    		Bit2:0	Noise gate threshold:
;;;586    	*/
;;;587    	usReg = (3 << 1) | (7 << 0);		/* 禁止自动增益控制 */
0000fc  2107              MOVS     r1,#7
;;;588    	wm8978_WriteReg(35, usReg);
0000fe  2023              MOVS     r0,#0x23
000100  f7fffffe          BL       wm8978_WriteReg
;;;589    
;;;590    	/*
;;;591    		Mic 输入信道的增益由 PGABOOSTL 和 PGABOOSTR 控制
;;;592    		Aux 输入信道的输入增益由 AUXL2BOOSTVO[2:0] 和 AUXR2BOOSTVO[2:0] 控制
;;;593    		Line 输入信道的增益由 LIP2BOOSTVOL[2:0] 和 RIP2BOOSTVOL[2:0] 控制
;;;594    	*/
;;;595    	/*	WM8978(V4.5_2011).pdf 29页，R47（左声道），R48（右声道）, MIC 增益控制寄存器
;;;596    		R47 (R48定义与此相同)
;;;597    		B8		PGABOOSTL	= 1,   0表示MIC信号直通无增益，1表示MIC信号+20dB增益（通过自举电路）
;;;598    		B7		= 0， 保留
;;;599    		B6:4	L2_2BOOSTVOL = x， 0表示禁止，1-7表示增益-12dB ~ +6dB  （可以衰减也可以放大）
;;;600    		B3		= 0， 保留
;;;601    		B2:0`	AUXL2BOOSTVOL = x，0表示禁止，1-7表示增益-12dB ~ +6dB  （可以衰减也可以放大）
;;;602    	*/
;;;603    	usReg = 0;
;;;604    	if ((_InPath & MIC_LEFT_ON) || (_InPath & MIC_RIGHT_ON))
000104  07a0              LSLS     r0,r4,#30
;;;605    	{
;;;606    		usReg |= (1 << 8);	/* MIC增益取+20dB */
000106  f44f7880          MOV      r8,#0x100
00010a  d000              BEQ      |L14.270|
00010c  4646              MOV      r6,r8
                  |L14.270|
;;;607    	}
;;;608    	if (_InPath & AUX_ON)
00010e  0720              LSLS     r0,r4,#28
000110  d501              BPL      |L14.278|
;;;609    	{
;;;610    		usReg |= (3 << 0);	/* Aux增益固定取3，用户可以自行调整 */
000112  f0460603          ORR      r6,r6,#3
                  |L14.278|
;;;611    	}
;;;612    	if (_InPath & LINE_ON)
000116  0760              LSLS     r0,r4,#29
000118  d501              BPL      |L14.286|
;;;613    	{
;;;614    		usReg |= (3 << 4);	/* Line增益固定取3，用户可以自行调整 */
00011a  f0460630          ORR      r6,r6,#0x30
                  |L14.286|
;;;615    	}
;;;616    	wm8978_WriteReg(47, usReg);	/* 写左声道输入增益控制寄存器 */
00011e  4631              MOV      r1,r6
000120  202f              MOVS     r0,#0x2f
000122  f7fffffe          BL       wm8978_WriteReg
;;;617    	wm8978_WriteReg(48, usReg);	/* 写右声道输入增益控制寄存器 */
000126  4631              MOV      r1,r6
000128  2030              MOVS     r0,#0x30
00012a  f7fffffe          BL       wm8978_WriteReg
;;;618    
;;;619    	/* 数字ADC音量控制，pdf 35页
;;;620    		R15 控制左声道ADC音量，R16控制右声道ADC音量
;;;621    		Bit8 	ADCVU  = 1 时才更新，用于同步更新左右声道的ADC音量
;;;622    		Bit7:0 	增益选择； 0000 0000 = 静音
;;;623    						   0000 0001 = -127dB
;;;624    						   0000 0010 = -12.5dB  （0.5dB 步长）
;;;625    						   1111 1111 = 0dB  （不衰减）
;;;626    	*/
;;;627    	usReg = 0xFF;
00012e  21ff              MOVS     r1,#0xff
;;;628    	wm8978_WriteReg(15, usReg);	/* 选择0dB，先缓存左声道 */
000130  200f              MOVS     r0,#0xf
000132  f7fffffe          BL       wm8978_WriteReg
;;;629    	usReg = 0x1FF;
000136  f24017ff          MOV      r7,#0x1ff
00013a  4639              MOV      r1,r7
;;;630    	wm8978_WriteReg(16, usReg);	/* 同步更新左右声道 */
00013c  2010              MOVS     r0,#0x10
00013e  f7fffffe          BL       wm8978_WriteReg
;;;631    
;;;632    	/* 通过 wm8978_SetMicGain 函数设置mic PGA增益 */
;;;633    
;;;634    	/*	R43 寄存器  AUXR C ROUT2 BEEP Mixer Function
;;;635    		B8:6 = 0
;;;636    
;;;637    		B5	 MUTERPGA2INV,	Mute input to INVROUT2 mixer
;;;638    		B4	 INVROUT2,  Invert ROUT2 output 用于扬声器推挽输出
;;;639    		B3:1 BEEPVOL = 7;	AUXR input to ROUT2 inverter gain
;;;640    		B0	 BEEPEN = 1;	Enable AUXR beep input
;;;641    
;;;642    	*/
;;;643    	usReg = 0;
000142  2100              MOVS     r1,#0
;;;644    	if (_OutPath & SPK_ON)
000144  0768              LSLS     r0,r5,#29
000146  d500              BPL      |L14.330|
;;;645    	{
;;;646    		usReg |= (1 << 4);	/* ROUT2 反相, 用于驱动扬声器 */
000148  2110              MOVS     r1,#0x10
                  |L14.330|
;;;647    	}
;;;648    	if (_InPath & AUX_ON)
00014a  0720              LSLS     r0,r4,#28
00014c  d501              BPL      |L14.338|
;;;649    	{
;;;650    		usReg |= ((7 << 1) | (1 << 0));
00014e  f041010f          ORR      r1,r1,#0xf
                  |L14.338|
;;;651    	}
;;;652    	wm8978_WriteReg(43, usReg);
000152  202b              MOVS     r0,#0x2b
000154  f7fffffe          BL       wm8978_WriteReg
;;;653    
;;;654    	/* R49  Output ctrl
;;;655    		B8:7	0
;;;656    		B6		DACL2RMIX,	Left DAC output to right output mixer
;;;657    		B5		DACR2LMIX,	Right DAC output to left output
;;;658    		B4		OUT4BOOST,	0 = OUT4 output gain = -1; DC = AVDD / 2；1 = OUT4 output gain = +1.5；DC = 1.5 x AVDD / 2
;;;659    		B3		OUT3BOOST,	0 = OUT3 output gain = -1; DC = AVDD / 2；1 = OUT3 output gain = +1.5；DC = 1.5 x AVDD / 2
;;;660    		B2		SPKBOOST,	0 = Speaker gain = -1;  DC = AVDD / 2 ; 1 = Speaker gain = +1.5; DC = 1.5 x AVDD / 2
;;;661    		B1		TSDEN,   Thermal Shutdown Enable  扬声器热保护使能（缺省1）
;;;662    		B0		VROI,	Disabled Outputs to VREF Resistance
;;;663    	*/
;;;664    	usReg = 0;
000158  2100              MOVS     r1,#0
;;;665    	if (_InPath & DAC_ON)
00015a  06e0              LSLS     r0,r4,#27
00015c  d500              BPL      |L14.352|
;;;666    	{
;;;667    		usReg |= ((1 << 6) | (1 << 5));
00015e  2160              MOVS     r1,#0x60
                  |L14.352|
;;;668    	}
;;;669    	if (_OutPath & SPK_ON)
000160  0768              LSLS     r0,r5,#29
000162  d501              BPL      |L14.360|
;;;670    	{
;;;671    		usReg |=  ((1 << 2) | (1 << 1));	/* SPK 1.5x增益,  热保护使能 */
000164  f0410106          ORR      r1,r1,#6
                  |L14.360|
;;;672    	}
;;;673    	if (_OutPath & OUT3_4_ON)
000168  0728              LSLS     r0,r5,#28
00016a  d501              BPL      |L14.368|
;;;674    	{
;;;675    		usReg |=  ((1 << 4) | (1 << 3));	/* BOOT3  BOOT4  1.5x增益 */
00016c  f0410118          ORR      r1,r1,#0x18
                  |L14.368|
;;;676    	}
;;;677    	wm8978_WriteReg(49, usReg);
000170  2031              MOVS     r0,#0x31
000172  f7fffffe          BL       wm8978_WriteReg
;;;678    
;;;679    	/*	REG 50    (50是左声道，51是右声道，配置寄存器功能一致) WM8978(V4.5_2011).pdf 56页
;;;680    		B8:6	AUXLMIXVOL = 111	AUX用于FM收音机信号输入
;;;681    		B5		AUXL2LMIX = 1		Left Auxilliary input to left channel
;;;682    		B4:2	BYPLMIXVOL			音量
;;;683    		B1		BYPL2LMIX = 0;		Left bypass path (from the left channel input boost output) to left output mixer
;;;684    		B0		DACL2LMIX = 1;		Left DAC output to left output mixer
;;;685    	*/
;;;686    	usReg = 0;
000176  2600              MOVS     r6,#0
;;;687    	if (_InPath & AUX_ON)
000178  0720              LSLS     r0,r4,#28
00017a  d501              BPL      |L14.384|
;;;688    	{
;;;689    		usReg |= ((7 << 6) | (1 << 5));
00017c  f44f76f0          MOV      r6,#0x1e0
                  |L14.384|
;;;690    	}
;;;691    	if ((_InPath & LINE_ON) || (_InPath & MIC_LEFT_ON) || (_InPath & MIC_RIGHT_ON))
000180  f0140f05          TST      r4,#5
000184  d101              BNE      |L14.394|
000186  07a0              LSLS     r0,r4,#30
000188  d501              BPL      |L14.398|
                  |L14.394|
;;;692    	{
;;;693    		usReg |= ((7 << 2) | (1 << 1));
00018a  f046061e          ORR      r6,r6,#0x1e
                  |L14.398|
;;;694    	}
;;;695    	if (_InPath & DAC_ON)
00018e  06e0              LSLS     r0,r4,#27
000190  d501              BPL      |L14.406|
;;;696    	{
;;;697    		usReg |= (1 << 0);
000192  f0460601          ORR      r6,r6,#1
                  |L14.406|
;;;698    	}
;;;699    	wm8978_WriteReg(50, usReg);
000196  4631              MOV      r1,r6
000198  2032              MOVS     r0,#0x32
00019a  f7fffffe          BL       wm8978_WriteReg
;;;700    	wm8978_WriteReg(51, usReg);
00019e  4631              MOV      r1,r6
0001a0  2033              MOVS     r0,#0x33
0001a2  f7fffffe          BL       wm8978_WriteReg
;;;701    
;;;702    	/*	R56 寄存器   OUT3 mixer ctrl
;;;703    		B8:7	0
;;;704    		B6		OUT3MUTE,  	0 = Output stage outputs OUT3 mixer;  1 = Output stage muted C drives out VMID.
;;;705    		B5:4	0
;;;706    		B3		BYPL2OUT3,	OUT4 mixer output to OUT3  (反相)
;;;707    		B4		0
;;;708    		B2		LMIX2OUT3,	Left ADC input to OUT3
;;;709    		B1		LDAC2OUT3,	Left DAC mixer to OUT3
;;;710    		B0		LDAC2OUT3,	Left DAC output to OUT3
;;;711    	*/
;;;712    	usReg = 0;
0001a6  2100              MOVS     r1,#0
;;;713    	if (_OutPath & OUT3_4_ON)
0001a8  0728              LSLS     r0,r5,#28
0001aa  d500              BPL      |L14.430|
;;;714    	{
;;;715    		usReg |= (1 << 3);
0001ac  2108              MOVS     r1,#8
                  |L14.430|
;;;716    	}
;;;717    	wm8978_WriteReg(56, usReg);
0001ae  2038              MOVS     r0,#0x38
0001b0  f7fffffe          BL       wm8978_WriteReg
;;;718    
;;;719    	/* R57 寄存器		OUT4 (MONO) mixer ctrl
;;;720    		B8:7	0
;;;721    		B6		OUT4MUTE,	0 = Output stage outputs OUT4 mixer  1 = Output stage muted C drives outVMID.
;;;722    		B5		HALFSIG,	0 = OUT4 normal output	1 = OUT4 attenuated by 6dB
;;;723    		B4		LMIX2OUT4,	Left DAC mixer to OUT4
;;;724    		B3		LDAC2UT4,	Left DAC to OUT4
;;;725    		B2		BYPR2OUT4,	Right ADC input to OUT4
;;;726    		B1		RMIX2OUT4,	Right DAC mixer to OUT4
;;;727    		B0		RDAC2OUT4,	Right DAC output to OUT4
;;;728    	*/
;;;729    	usReg = 0;
0001b4  2100              MOVS     r1,#0
;;;730    	if (_OutPath & OUT3_4_ON)
0001b6  0728              LSLS     r0,r5,#28
0001b8  d500              BPL      |L14.444|
;;;731    	{
;;;732    		usReg |= ((1 << 4) |  (1 << 1));
0001ba  2112              MOVS     r1,#0x12
                  |L14.444|
;;;733    	}
;;;734    	wm8978_WriteReg(57, usReg);
0001bc  2039              MOVS     r0,#0x39
0001be  f7fffffe          BL       wm8978_WriteReg
;;;735    
;;;736    
;;;737    	/* R11, 12 寄存器 DAC数字音量
;;;738    		R11		Left DAC Digital Volume
;;;739    		R12		Right DAC Digital Volume
;;;740    	*/
;;;741    	if (_InPath & DAC_ON)
0001c2  06e0              LSLS     r0,r4,#27
0001c4  d50a              BPL      |L14.476|
;;;742    	{
;;;743    		wm8978_WriteReg(11, 255);
0001c6  21ff              MOVS     r1,#0xff
0001c8  200b              MOVS     r0,#0xb
0001ca  f7fffffe          BL       wm8978_WriteReg
;;;744    		wm8978_WriteReg(12, 255 | 0x100);
0001ce  4639              MOV      r1,r7
0001d0  200c              MOVS     r0,#0xc
0001d2  f7fffffe          BL       wm8978_WriteReg
;;;745    	}
;;;746    	else
;;;747    	{
;;;748    		wm8978_WriteReg(11, 0);
;;;749    		wm8978_WriteReg(12, 0 | 0x100);
;;;750    	}
;;;751    
;;;752    	/*	R10 寄存器 DAC Control
;;;753    		B8	0
;;;754    		B7	0
;;;755    		B6	SOFTMUTE,	Softmute enable:
;;;756    		B5	0
;;;757    		B4	0
;;;758    		B3	DACOSR128,	DAC oversampling rate: 0=64x (lowest power) 1=128x (best performance)
;;;759    		B2	AMUTE,		Automute enable
;;;760    		B1	DACPOLR,	Right DAC output polarity
;;;761    		B0	DACPOLL,	Left DAC output polarity:
;;;762    	*/
;;;763    	if (_InPath & DAC_ON)
;;;764    	{
;;;765    		wm8978_WriteReg(10, 0);
0001d6  2100              MOVS     r1,#0
0001d8  200a              MOVS     r0,#0xa
0001da  e005              B        |L14.488|
                  |L14.476|
0001dc  2100              MOVS     r1,#0                 ;748
0001de  200b              MOVS     r0,#0xb               ;748
0001e0  f7fffffe          BL       wm8978_WriteReg
0001e4  4641              MOV      r1,r8                 ;749
0001e6  200c              MOVS     r0,#0xc               ;749
                  |L14.488|
0001e8  e8bd41f0          POP      {r4-r8,lr}            ;749
0001ec  f7ffbffe          B.W      wm8978_WriteReg
;;;766    	}
;;;767    }
;;;768    
                          ENDP


                          AREA ||i.wm8978_CtrlGPIO1||, CODE, READONLY, ALIGN=1

                  wm8978_CtrlGPIO1 PROC
;;;802    	*/
;;;803    void wm8978_CtrlGPIO1(uint8_t _ucValue)
000000  b118              CBZ      r0,|L15.10|
;;;804    {
;;;805    	uint16_t usRegValue;
;;;806    
;;;807    	/* R8， pdf 62页 */
;;;808    	if (_ucValue == 0) /* 输出0 */
;;;809    	{
;;;810    		usRegValue = 6; /* B2:0 = 110 */
;;;811    	}
;;;812    	else
;;;813    	{
;;;814    		usRegValue = 7; /* B2:0 = 111 */
000002  2107              MOVS     r1,#7
                  |L15.4|
;;;815    	}
;;;816    	wm8978_WriteReg(8, usRegValue);
000004  2008              MOVS     r0,#8
000006  f7ffbffe          B.W      wm8978_WriteReg
                  |L15.10|
00000a  2106              MOVS     r1,#6                 ;810
00000c  e7fa              B        |L15.4|
;;;817    }
;;;818    
                          ENDP


                          AREA ||i.wm8978_Init||, CODE, READONLY, ALIGN=1

                  wm8978_Init PROC
;;;121    	*/
;;;122    uint8_t wm8978_Init(void)
000000  f7ffbffe          B.W      wm8978_Reset
;;;123    {
;;;124    	uint8_t res;
;;;125    
;;;126    	res=wm8978_Reset();			/* 硬件复位WM8978所有寄存器到缺省状态 */
;;;127    	return res;
;;;128    }
;;;129    
                          ENDP


                          AREA ||i.wm8978_NotchFilter||, CODE, READONLY, ALIGN=1

                  wm8978_NotchFilter PROC
;;;773    	*/
;;;774    void wm8978_NotchFilter(uint16_t _NFA0, uint16_t _NFA1)
000000  b570              PUSH     {r4-r6,lr}
;;;775    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;776    	uint16_t usReg;
;;;777    
;;;778    	/*  page 26
;;;779    		A programmable notch filter is provided. This filter has a variable centre frequency and bandwidth,
;;;780    		programmable via two coefficients, a0 and a1. a0 and a1 are represented by the register bits
;;;781    		NFA0[13:0] and NFA1[13:0]. Because these coefficient values require four register writes to setup
;;;782    		there is an NFU (Notch Filter Update) flag which should be set only when all four registers are setup.
;;;783    	*/
;;;784    	usReg = (1 << 7) | (_NFA0 & 0x3F);
000006  f000003f          AND      r0,r0,#0x3f
00000a  f0400180          ORR      r1,r0,#0x80
;;;785    	wm8978_WriteReg(27, usReg);	/* 写寄存器 */
00000e  201b              MOVS     r0,#0x1b
000010  f7fffffe          BL       wm8978_WriteReg
;;;786    
;;;787    	usReg = ((_NFA0 >> 7) & 0x3F);
000014  f3c511c5          UBFX     r1,r5,#7,#6
;;;788    	wm8978_WriteReg(28, usReg);	/* 写寄存器 */
000018  201c              MOVS     r0,#0x1c
00001a  f7fffffe          BL       wm8978_WriteReg
;;;789    
;;;790    	usReg = (_NFA1 & 0x3F);
00001e  f004013f          AND      r1,r4,#0x3f
;;;791    	wm8978_WriteReg(29, usReg);	/* 写寄存器 */
000022  201d              MOVS     r0,#0x1d
000024  f7fffffe          BL       wm8978_WriteReg
;;;792    
;;;793    	usReg = (1 << 8) | ((_NFA1 >> 7) & 0x3F);
000028  f3c410c5          UBFX     r0,r4,#7,#6
;;;794    	wm8978_WriteReg(30, usReg);	/* 写寄存器 */
00002c  e8bd4070          POP      {r4-r6,lr}
000030  f4407180          ORR      r1,r0,#0x100          ;793
000034  201e              MOVS     r0,#0x1e
000036  f7ffbffe          B.W      wm8978_WriteReg
;;;795    }
;;;796    
                          ENDP


                          AREA ||i.wm8978_OutMute||, CODE, READONLY, ALIGN=2

                  wm8978_OutMute PROC
;;;218    	*/
;;;219    void wm8978_OutMute(uint8_t _ucMute)
000000  b510              PUSH     {r4,lr}
000002  4c1a              LDR      r4,|L18.108|
;;;220    {
;;;221    	uint16_t usRegValue;
;;;222    
;;;223    	if (_ucMute == 1) /* 静音 */
000004  2801              CMP      r0,#1
000006  f8b41068          LDRH     r1,[r4,#0x68]
00000a  d019              BEQ      |L18.64|
;;;224    	{
;;;225    		usRegValue = wm8978_ReadReg(52); /* Left Mixer Control */
;;;226    		usRegValue |= (1u << 6);
;;;227    		wm8978_WriteReg(52, usRegValue);
;;;228    
;;;229    		usRegValue = wm8978_ReadReg(53); /* Left Mixer Control */
;;;230    		usRegValue |= (1u << 6);
;;;231    		wm8978_WriteReg(53, usRegValue);
;;;232    
;;;233    		usRegValue = wm8978_ReadReg(54); /* Right Mixer Control */
;;;234    		usRegValue |= (1u << 6);
;;;235    		wm8978_WriteReg(54, usRegValue);
;;;236    
;;;237    		usRegValue = wm8978_ReadReg(55); /* Right Mixer Control */
;;;238    		usRegValue |= (1u << 6);
;;;239    		wm8978_WriteReg(55, usRegValue);
;;;240    	}
;;;241    	else	/* 取消静音 */
;;;242    	{
;;;243    		usRegValue = wm8978_ReadReg(52);
;;;244    		usRegValue &= ~(1u << 6);
00000c  f0210140          BIC      r1,r1,#0x40
;;;245    		wm8978_WriteReg(52, usRegValue);
000010  2034              MOVS     r0,#0x34
000012  f7fffffe          BL       wm8978_WriteReg
000016  f8340f6a          LDRH     r0,[r4,#0x6a]!
;;;246    
;;;247    		usRegValue = wm8978_ReadReg(53); /* Left Mixer Control */
;;;248    		usRegValue &= ~(1u << 6);
00001a  f0200140          BIC      r1,r0,#0x40
;;;249    		wm8978_WriteReg(53, usRegValue);
00001e  2035              MOVS     r0,#0x35
000020  f7fffffe          BL       wm8978_WriteReg
000024  8860              LDRH     r0,[r4,#2]
;;;250    
;;;251    		usRegValue = wm8978_ReadReg(54);
;;;252    		usRegValue &= ~(1u << 6);
000026  f0200140          BIC      r1,r0,#0x40
;;;253    		wm8978_WriteReg(54, usRegValue);
00002a  2036              MOVS     r0,#0x36
00002c  f7fffffe          BL       wm8978_WriteReg
000030  88a0              LDRH     r0,[r4,#4]
;;;254    
;;;255    		usRegValue = wm8978_ReadReg(55); /* Left Mixer Control */
;;;256    		usRegValue &= ~(1u << 6);
000032  f0200140          BIC      r1,r0,#0x40
                  |L18.54|
;;;257    		wm8978_WriteReg(55, usRegValue);
000036  e8bd4010          POP      {r4,lr}
00003a  2037              MOVS     r0,#0x37
00003c  f7ffbffe          B.W      wm8978_WriteReg
                  |L18.64|
000040  f0410140          ORR      r1,r1,#0x40           ;226
000044  2034              MOVS     r0,#0x34              ;227
000046  f7fffffe          BL       wm8978_WriteReg
00004a  f8340f6a          LDRH     r0,[r4,#0x6a]!        ;227
00004e  f0400140          ORR      r1,r0,#0x40           ;230
000052  2035              MOVS     r0,#0x35              ;231
000054  f7fffffe          BL       wm8978_WriteReg
000058  8860              LDRH     r0,[r4,#2]            ;231
00005a  f0400140          ORR      r1,r0,#0x40           ;234
00005e  2036              MOVS     r0,#0x36              ;235
000060  f7fffffe          BL       wm8978_WriteReg
000064  88a0              LDRH     r0,[r4,#4]            ;235
000066  f0400140          ORR      r1,r0,#0x40           ;238
00006a  e7e4              B        |L18.54|
;;;258    	}
;;;259    }
;;;260    
                          ENDP

                  |L18.108|
                          DCD      ||.data||+0x8

                          AREA ||i.wm8978_PowerDown||, CODE, READONLY, ALIGN=1

                  wm8978_PowerDown PROC
;;;327    	*/
;;;328    void wm8978_PowerDown(void)
000000  f7ffbffe          B.W      wm8978_Reset
;;;329    {
;;;330    	wm8978_Reset();			/* 硬件复位WM8978所有寄存器到缺省状态 */
;;;331    }
;;;332    
                          ENDP


                          AREA ||i.wm8978_ReadOUT1Volume||, CODE, READONLY, ALIGN=2

                  wm8978_ReadOUT1Volume PROC
;;;195    	*/
;;;196    uint8_t wm8978_ReadOUT1Volume(void)
000000  4802              LDR      r0,|L20.12|
000002  f8900068          LDRB     r0,[r0,#0x68]
;;;197    {
;;;198    	return (uint8_t)(wm8978_ReadReg(52) & 0x3F );
000006  f000003f          AND      r0,r0,#0x3f
;;;199    }
00000a  4770              BX       lr
;;;200    
                          ENDP

                  |L20.12|
                          DCD      ||.data||+0x8

                          AREA ||i.wm8978_ReadOUT2Volume||, CODE, READONLY, ALIGN=2

                  wm8978_ReadOUT2Volume PROC
;;;205    	*/
;;;206    uint8_t wm8978_ReadOUT2Volume(void)
000000  4802              LDR      r0,|L21.12|
000002  f890006c          LDRB     r0,[r0,#0x6c]
;;;207    {
;;;208    	return (uint8_t)(wm8978_ReadReg(54) & 0x3F );
000006  f000003f          AND      r0,r0,#0x3f
;;;209    }
00000a  4770              BX       lr
;;;210    
                          ENDP

                  |L21.12|
                          DCD      ||.data||+0x8

                          AREA ||i.wm8978_Reset||, CODE, READONLY, ALIGN=2

                  wm8978_Reset PROC
;;;825    	*/
;;;826    uint8_t wm8978_Reset(void)
000000  b510              PUSH     {r4,lr}
;;;827    {
000002  b09e              SUB      sp,sp,#0x78
;;;828    	/* wm8978寄存器缺省值 */
;;;829    	const uint16_t reg_default[] = {
000004  2274              MOVS     r2,#0x74
000006  490a              LDR      r1,|L22.48|
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       __aeabi_memcpy4
;;;830    	0x000, 0x000, 0x000, 0x000, 0x050, 0x000, 0x140, 0x000,
;;;831    	0x000, 0x000, 0x000, 0x0FF, 0x0FF, 0x000, 0x100, 0x0FF,
;;;832    	0x0FF, 0x000, 0x12C, 0x02C, 0x02C, 0x02C, 0x02C, 0x000,
;;;833    	0x032, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,
;;;834    	0x038, 0x00B, 0x032, 0x000, 0x008, 0x00C, 0x093, 0x0E9,
;;;835    	0x000, 0x000, 0x000, 0x000, 0x003, 0x010, 0x010, 0x100,
;;;836    	0x100, 0x002, 0x001, 0x001, 0x039, 0x039, 0x039, 0x039,
;;;837    	0x001, 0x001
;;;838    	};
;;;839    	uint8_t res;
;;;840    	uint8_t i;
;;;841    
;;;842    	res=wm8978_WriteReg(0x00, 0);
00000e  2100              MOVS     r1,#0
000010  4608              MOV      r0,r1
000012  f7fffffe          BL       wm8978_WriteReg
;;;843    
;;;844    	for (i = 0; i < sizeof(reg_default) / 2; i++)
;;;845    	{
;;;846    		wm8978_RegCash[i] = reg_default[i];
000016  4b07              LDR      r3,|L22.52|
000018  2100              MOVS     r1,#0                 ;844
00001a  466a              MOV      r2,sp                 ;829
                  |L22.28|
00001c  f8324011          LDRH     r4,[r2,r1,LSL #1]
000020  f8234011          STRH     r4,[r3,r1,LSL #1]
000024  1c49              ADDS     r1,r1,#1
000026  b2c9              UXTB     r1,r1                 ;844
000028  293a              CMP      r1,#0x3a              ;844
00002a  d3f7              BCC      |L22.28|
;;;847    	}
;;;848    	return res;
;;;849    }
00002c  b01e              ADD      sp,sp,#0x78
00002e  bd10              POP      {r4,pc}
;;;850    
                          ENDP

                  |L22.48|
                          DCD      ||.constdata||
                  |L22.52|
                          DCD      ||.data||+0x8

                          AREA ||i.wm8978_SetLineGain||, CODE, READONLY, ALIGN=2

                  wm8978_SetLineGain PROC
;;;288    	*/
;;;289    void wm8978_SetLineGain(uint8_t _ucGain)
000000  b570              PUSH     {r4-r6,lr}
;;;290    {
000002  4604              MOV      r4,r0
;;;291    	uint16_t usRegValue;
;;;292    
;;;293    	if (_ucGain > 7)
000004  2807              CMP      r0,#7
000006  d900              BLS      |L23.10|
;;;294    	{
;;;295    		_ucGain = 7;
000008  2407              MOVS     r4,#7
                  |L23.10|
00000a  4d0a              LDR      r5,|L23.52|
00000c  f8150f5e          LDRB     r0,[r5,#0x5e]!
;;;296    	}
;;;297    
;;;298    	/*
;;;299    		Mic 输入信道的增益由 PGABOOSTL 和 PGABOOSTR 控制
;;;300    		Aux 输入信道的输入增益由 AUXL2BOOSTVO[2:0] 和 AUXR2BOOSTVO[2:0] 控制
;;;301    		Line 输入信道的增益由 LIP2BOOSTVOL[2:0] 和 RIP2BOOSTVOL[2:0] 控制
;;;302    	*/
;;;303    	/*	R47（左声道），R48（右声道）, MIC 增益控制寄存器
;;;304    		R47 (R48定义与此相同)
;;;305    		B8		PGABOOSTL	= 1,   0表示MIC信号直通无增益，1表示MIC信号+20dB增益（通过自举电路）
;;;306    		B7		= 0， 保留
;;;307    		B6:4	L2_2BOOSTVOL = x， 0表示禁止，1-7表示增益-12dB ~ +6dB  （可以衰减也可以放大）
;;;308    		B3		= 0， 保留
;;;309    		B2:0`	AUXL2BOOSTVOL = x，0表示禁止，1-7表示增益-12dB ~ +6dB  （可以衰减也可以放大）
;;;310    	*/
;;;311    
;;;312    	usRegValue = wm8978_ReadReg(47);
;;;313    	usRegValue &= 0x8F;/* 将Bit6:4清0   1000 1111*/
000010  f000008f          AND      r0,r0,#0x8f
;;;314    	usRegValue |= (_ucGain << 4);
000014  ea401104          ORR      r1,r0,r4,LSL #4
;;;315    	wm8978_WriteReg(47, usRegValue);	/* 写左声道输入增益控制寄存器 */
000018  202f              MOVS     r0,#0x2f
00001a  f7fffffe          BL       wm8978_WriteReg
00001e  78a8              LDRB     r0,[r5,#2]
;;;316    
;;;317    	usRegValue = wm8978_ReadReg(48);
;;;318    	usRegValue &= 0x8F;/* 将Bit6:4清0   1000 1111*/
000020  f000008f          AND      r0,r0,#0x8f
;;;319    	usRegValue |= (_ucGain << 4);
000024  ea401104          ORR      r1,r0,r4,LSL #4
;;;320    	wm8978_WriteReg(48, usRegValue);	/* 写右声道输入增益控制寄存器 */
000028  e8bd4070          POP      {r4-r6,lr}
00002c  2030              MOVS     r0,#0x30
00002e  f7ffbffe          B.W      wm8978_WriteReg
;;;321    }
;;;322    
                          ENDP

000032  0000              DCW      0x0000
                  |L23.52|
                          DCD      ||.data||+0x8

                          AREA ||i.wm8978_SetMicGain||, CODE, READONLY, ALIGN=1

                  wm8978_SetMicGain PROC
;;;265    	*/
;;;266    void wm8978_SetMicGain(uint8_t _ucGain)
000000  b510              PUSH     {r4,lr}
;;;267    {
000002  4604              MOV      r4,r0
;;;268    	if (_ucGain > GAIN_MAX)
000004  283f              CMP      r0,#0x3f
000006  d900              BLS      |L24.10|
;;;269    	{
;;;270    		_ucGain = GAIN_MAX;
000008  243f              MOVS     r4,#0x3f
                  |L24.10|
;;;271    	}
;;;272    
;;;273    	/* PGA 音量控制  R45， R46 
;;;274    		Bit8	INPPGAUPDATE
;;;275    		Bit7	INPPGAZCL		过零再更改
;;;276    		Bit6	INPPGAMUTEL		PGA静音
;;;277    		Bit5:0	增益值，010000是0dB
;;;278    	*/
;;;279    	wm8978_WriteReg(45, _ucGain);
00000a  4621              MOV      r1,r4
00000c  202d              MOVS     r0,#0x2d
00000e  f7fffffe          BL       wm8978_WriteReg
;;;280    	wm8978_WriteReg(46, _ucGain | (1 << 8));
000012  f4447180          ORR      r1,r4,#0x100
000016  e8bd4010          POP      {r4,lr}
00001a  202e              MOVS     r0,#0x2e
00001c  f7ffbffe          B.W      wm8978_WriteReg
;;;281    }
;;;282    
                          ENDP


                          AREA ||i.wm8978_SetOUT1Volume||, CODE, READONLY, ALIGN=1

                  wm8978_SetOUT1Volume PROC
;;;134    	*/
;;;135    void wm8978_SetOUT1Volume(uint8_t _ucVolume)
000000  b510              PUSH     {r4,lr}
;;;136    {
;;;137    	uint16_t regL;
;;;138    	uint16_t regR;
;;;139    
;;;140    	if (_ucVolume > VOLUME_MAX)
000002  283f              CMP      r0,#0x3f
000004  d900              BLS      |L25.8|
;;;141    	{
;;;142    		_ucVolume = VOLUME_MAX;
000006  203f              MOVS     r0,#0x3f
                  |L25.8|
;;;143    	}
;;;144    
;;;145    	regL = _ucVolume;
000008  4601              MOV      r1,r0
;;;146    	regR = _ucVolume;
00000a  460c              MOV      r4,r1
;;;147    
;;;148    	/*
;;;149    		R52	LOUT1 Volume control
;;;150    		R53	ROUT1 Volume control
;;;151    	*/
;;;152    	/* 先更新左声道缓存值 */
;;;153    	wm8978_WriteReg(52, regL | 0x00);
00000c  2034              MOVS     r0,#0x34
00000e  f7fffffe          BL       wm8978_WriteReg
;;;154    
;;;155    	/* 再同步更新左右声道的音量 */
;;;156    	wm8978_WriteReg(53, regR | 0x100);	/* 0x180表示 在音量为0时再更新，避免调节音量出现的“嘎哒”声 */
000012  f4447180          ORR      r1,r4,#0x100
000016  e8bd4010          POP      {r4,lr}
00001a  2035              MOVS     r0,#0x35
00001c  f7ffbffe          B.W      wm8978_WriteReg
;;;157    }
;;;158    
                          ENDP


                          AREA ||i.wm8978_SetOUT2Volume||, CODE, READONLY, ALIGN=1

                  wm8978_SetOUT2Volume PROC
;;;164    	*/
;;;165    void wm8978_SetOUT2Volume(uint8_t _ucVolume)
000000  b510              PUSH     {r4,lr}
;;;166    {
;;;167    	uint16_t regL;
;;;168    	uint16_t regR;
;;;169    
;;;170    	if (_ucVolume > VOLUME_MAX)
000002  283f              CMP      r0,#0x3f
000004  d900              BLS      |L26.8|
;;;171    	{
;;;172    		_ucVolume = VOLUME_MAX;
000006  203f              MOVS     r0,#0x3f
                  |L26.8|
;;;173    	}
;;;174    
;;;175    	regL = _ucVolume;
;;;176    	regR = _ucVolume;
;;;177    
;;;178    	/*
;;;179    		R54	LOUT2 (SPK) Volume control
;;;180    		R55	ROUT2 (SPK) Volume control
;;;181    	*/
;;;182    	/* 先更新左声道缓存值 */
;;;183    	wm8978_WriteReg(54, regL | 0x100);
000008  f4407480          ORR      r4,r0,#0x100
00000c  4621              MOV      r1,r4
00000e  2036              MOVS     r0,#0x36
000010  f7fffffe          BL       wm8978_WriteReg
000014  4621              MOV      r1,r4
;;;184    
;;;185    	/* 再同步更新左右声道的音量 */
;;;186    	
;;;187    	wm8978_WriteReg(55, regR | 0x100);	/* 在音量为0时再更新，避免调节音量出现的“嘎哒”声 */
000016  e8bd4010          POP      {r4,lr}
00001a  2037              MOVS     r0,#0x37
00001c  f7ffbffe          B.W      wm8978_WriteReg
;;;188    }
;;;189    
                          ENDP


                          AREA ||i.wm8978_WriteReg||, CODE, READONLY, ALIGN=2

                  wm8978_WriteReg PROC
;;;106    	*/
;;;107    static uint8_t wm8978_WriteReg(uint8_t _ucRegAddr, uint16_t _usValue)
000000  b570              PUSH     {r4-r6,lr}
;;;108    {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;109    	uint8_t res;
;;;110    	i2c_CfgGpio(IIC_WM8978,I2C_TYPE_SIMULATE);		/* 配置GPIO iic 模拟方式 */
000006  2101              MOVS     r1,#1
000008  4608              MOV      r0,r1
00000a  f7fffffe          BL       i2c_CfgGpio
00000e  f7fffffe          BL       i2c_Start
000012  2034              MOVS     r0,#0x34
000014  f7fffffe          BL       i2c_SendByte
000018  f7fffffe          BL       i2c_WaitAck
;;;111    	res=WM8978_I2C_WriteRegister(_ucRegAddr,_usValue);
00001c  b978              CBNZ     r0,|L27.62|
00001e  0668              LSLS     r0,r5,#25
000020  f3c42100          UBFX     r1,r4,#8,#1
000024  ea416010          ORR      r0,r1,r0,LSR #24
000028  f7fffffe          BL       i2c_SendByte
00002c  f7fffffe          BL       i2c_WaitAck
000030  b928              CBNZ     r0,|L27.62|
000032  b2e0              UXTB     r0,r4
000034  f7fffffe          BL       i2c_SendByte
000038  f7fffffe          BL       i2c_WaitAck
00003c  b130              CBZ      r0,|L27.76|
                  |L27.62|
00003e  f7fffffe          BL       i2c_Stop
000042  2000              MOVS     r0,#0
                  |L27.68|
;;;112    	wm8978_RegCash[_ucRegAddr] = _usValue;
000044  4903              LDR      r1,|L27.84|
000046  f8214015          STRH     r4,[r1,r5,LSL #1]
;;;113    	return res;
;;;114    }
00004a  bd70              POP      {r4-r6,pc}
                  |L27.76|
00004c  f7fffffe          BL       i2c_Stop
000050  2001              MOVS     r0,#1
000052  e7f7              B        |L27.68|
;;;115    
                          ENDP

                  |L27.84|
                          DCD      ||.data||+0x8

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  00000000          DCW      0x0000,0x0000
000004  00000000          DCW      0x0000,0x0000
000008  00500000          DCW      0x0050,0x0000
00000c  01400000          DCW      0x0140,0x0000
000010  00000000          DCW      0x0000,0x0000
000014  000000ff          DCW      0x0000,0x00ff
000018  00ff0000          DCW      0x00ff,0x0000
00001c  010000ff          DCW      0x0100,0x00ff
000020  00ff0000          DCW      0x00ff,0x0000
000024  012c002c          DCW      0x012c,0x002c
000028  002c002c          DCW      0x002c,0x002c
00002c  002c0000          DCW      0x002c,0x0000
000030  00320000          DCW      0x0032,0x0000
000034  00000000          DCW      0x0000,0x0000
000038  00000000          DCW      0x0000,0x0000
00003c  00000000          DCW      0x0000,0x0000
000040  0038000b          DCW      0x0038,0x000b
000044  00320000          DCW      0x0032,0x0000
000048  0008000c          DCW      0x0008,0x000c
00004c  009300e9          DCW      0x0093,0x00e9
000050  00000000          DCW      0x0000,0x0000
000054  00000000          DCW      0x0000,0x0000
000058  00030010          DCW      0x0003,0x0010
00005c  00100100          DCW      0x0010,0x0100
000060  01000002          DCW      0x0100,0x0002
000064  00010001          DCW      0x0001,0x0001
000068  00390039          DCW      0x0039,0x0039
00006c  00390039          DCW      0x0039,0x0039
000070  00010001          DCW      0x0001,0x0001

                          AREA ||.data||, DATA, ALIGN=2

                  I2S_DMA_TX_Callback
                          DCD      0x00000000
                  I2S_DMA_RX_Callback
                          DCD      0x00000000
                  wm8978_RegCash
000008  00000000          DCW      0x0000,0x0000
00000c  00000000          DCW      0x0000,0x0000
000010  00500000          DCW      0x0050,0x0000
000014  01400000          DCW      0x0140,0x0000
000018  00000000          DCW      0x0000,0x0000
00001c  000000ff          DCW      0x0000,0x00ff
000020  00ff0000          DCW      0x00ff,0x0000
000024  010000ff          DCW      0x0100,0x00ff
000028  00ff0000          DCW      0x00ff,0x0000
00002c  012c002c          DCW      0x012c,0x002c
000030  002c002c          DCW      0x002c,0x002c
000034  002c0000          DCW      0x002c,0x0000
000038  00320000          DCW      0x0032,0x0000
00003c  00000000          DCW      0x0000,0x0000
000040  00000000          DCW      0x0000,0x0000
000044  00000000          DCW      0x0000,0x0000
000048  0038000b          DCW      0x0038,0x000b
00004c  00320000          DCW      0x0032,0x0000
000050  0008000c          DCW      0x0008,0x000c
000054  009300e9          DCW      0x0093,0x00e9
000058  00000000          DCW      0x0000,0x0000
00005c  00000000          DCW      0x0000,0x0000
000060  00030010          DCW      0x0003,0x0010
000064  00100100          DCW      0x0010,0x0100
000068  01000002          DCW      0x0100,0x0002
00006c  00010001          DCW      0x0001,0x0001
000070  00390039          DCW      0x0039,0x0039
000074  00390039          DCW      0x0039,0x0039
000078  00010001          DCW      0x0001,0x0001

;*** Start embedded assembler ***

#line 1 "..\\..\\Complex\\wm8978\\bsp_wm8978.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_bsp_wm8978_c_ef408190____REV16|
#line 138 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_bsp_wm8978_c_ef408190____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_bsp_wm8978_c_ef408190____REVSH|
#line 153
|__asm___12_bsp_wm8978_c_ef408190____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_bsp_wm8978_c_ef408190____RRX|
#line 328
|__asm___12_bsp_wm8978_c_ef408190____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
